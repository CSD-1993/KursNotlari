/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												
													C ve Sistem Programcıları Derneği

														C++ Programlama Dili 

											Sınıfta Yapılan Örnekler ve Özet Notlar
			
														Eğitmen: Kaan ASLAN  
					
					Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

								(Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz)
								
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

								
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														1. Ders 14/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Merhaba Dünya C++ programı
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello World" << endl;
    
    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															2. Ders 16/08/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın ilk standardı ISO/IEC tarafından 1998 yılında oluşturuldu (ISO/IEC 14882: 1998).Bunu 2003 yılındaki standartlar izledi. 2003 standartları daha çok düzeltme 
	niteliğinde idi. Daha sonra C++'ın 2011 yılında yeni bir standardı oluşturuldu. Bu standartlarla C++'a pek çok yenilik eklendi. 2011 standartlarını 2014, 2017 
	ve 2020 standartları izledi. Şu anda üzerinde çalışılmakta olan standart 2023'tür. Bu standartlar halk arasında sırasıyla C++98, C++03, C++11, C++14, C++17, 
	C++20 ve C++23 olarak bilinmektedir. 
	
	Klasik C++ olan C++98 ve C++03'e yapılan eklemeler iki kategoride ele ele alınabilmektedir. Bunlardan biri "doğrudan dile yapılan eklemelerdir (core language 
	feaures)",	diğeri ise C++'ın standart kütüphanesine yapılan eklemelerdir. C++'a en önemli eklemeler C++11 standartları ile yapılmıştır. C++11 ve sonrasına 
	C++ dünyasında "Modern C++" da denilmektedir. C++11'den sonra artık standartların üç senelik periyotlarla oluşturulması kabul edilmiştir. Kanımızca üç 
	semelik periyotlar C++ gibi bir dil için çok hızlı bir süreçtir. Bu hızlı gelişme çeşitli sancıları da beraberinde getirmiştir. 

	C Progralama Dilinin ilk standartları "ISO/IEC 9899: 1990" ismiyle 1990 yılında ISO tarafından oluşturulmuştur. Buna halk arasında C90 denilmektedir. 
	(Aslında C standartları önce 1989 yılında Amerika'nın standart kurumu olan ANSI tarafından aluşturulmuştu. 1990 ISO standartları bu ANSI standartlarının alınarak
	bazı bölüm numaralarının değiştirilmesiyle oluşturulmuşur.) C'nin 1999 yılında yeni bir standardı daha oluşturuldu. Buna da C99 denilmektedir. Daha sonra 
	C'nin 2011 yılında yeni bir standardı oluşturulmuştur. Buna da C11 denilmektedir. Nihayet C'nin 2017 yılında son sürümü yayınlandı. Buna da C17 denilmektedir. 
	Ancak bu C17'de yeni özellikler eklenmedi. Yalnızca C11'deki bozukluklar düzeltildi. C'nin üzerinde çalışılan son standart sürümü C23'tür. C23 standartlarının 
	2024'te yayınlanacağı düşünülmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarının üç senelik periyotlarla hızlı bir biçimde güncellenmesi bazı tasarım hatalarının ve pişmanlıkların oluşmasına da yol açmıştır. Dolayısıyla
	Modern C++'a yönelik bazı ince ayrıntılar C++'ın versiyonundan versiyonuna değişmiş olabilmektedir. Biz yeni öğrenen kişilere C++ standartların doğrudan 
	okunmasını tavsiye etmemekteyiz. Çünkü standart metinleri (bazı diğer standartları da böyle) pedagojik metinler değildir. Olanı tam olarak betimlemek amacıyla 
	oluşturulmuş metinelerdir. Son yıllarda "C++ Reference" isminde C++ standartlarını açıklamalı (annotated) bir biçimde dokümante eden bir girişim oldukça 
	popüler hale gelmiştir. Biz de kursumuzda pek çok yerde doğrudan bu standartlara referans etmektense C++ Reference sitesinden faydalanacağız. Siteye aşağıdaki
	bağlantıdan ulaşabilirsiniz:

	https://en.cppreference.com/w/
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  	Bir C++ programı IDE'ler yoluyla kolayca derlenip, link işlemi yapılarak çalıştırılabilir. Windows sistemlerinde en yaygın kullanılan IDE Microsoft'un
	"Visual Studio" isimli IDE'sidir. C++ için diğer bir IDE seçeneği "Qt-Creator" olabilir. Qt Creator "cross platform" biçimindedir. Yani Windows, macOS ve Linux 
	sistemlerinde benzer biçimde kullanılabilmektedir. Tabii aslında derleyiciler komut satırından çalıştırılan programlar biçiminde oluşturulmuştur. IDe'ler aslında 
	derleyicileri çalıştırarak derleme ve bağlama işlemlerini yapmaktadır. Microsoft'un C ve C++ derleyicisi "cl.exe" isimli programdır. Bu derleyici ile derleme 
	komut satırında şöyle yapılabilir:

	cl sample.cpp

	Derleyici default durumda derleme işleminden sonra bağlayıcı (linker) programı da çalıştırır. Bu işlemden eğer programınızda bir hata yoksa "sample.exe" 
	dosyasını elde edeceksinizç Tabii istersek çalıştırılabilen dosyanın ismini /Fe seçeneği ile de değiştirebiliriz:

	cl /Fe:test.exe sample.cpp

	UNIX/Linux ve macOS sistemlerinde GNU'nun g++ ve clang++ derleyicileri kullanılabilmektedir. g++ derleyicisi ile komut satırından derleme tipik olarak 
	şöyle yapılmaktadır:

	g++ sample.cpp 

	clang++ derleuyicilerinin kullanımları da g++ ile uyumludur:

	clang++ sample.cpp

	Burada derleyici derleme işleminden sonra yine bağlayıcı programı çalıştırmaktadır. Bu durumda çalıştırılabilen dosya "a.out" biçiminde oluşur. Çalıştırılabilen 
	dosyanın ismini değiştirmek için -o seçeneği kullanılmaktadır. Örneğin:

	g++ -o sample sample.cpp

	ya da örneğin:

	clang++ -o sample sample.cpp 

	UNIX/Linux sistemlerinde bir program dosyasını çalıştırmak için dosya isminin önüne ./ getirmeyi unutmayınız. Örneğin:

	./sample

	C++'ın çeşitli standartları olduğuna göre derleme işlemi bu standartlar belirtilerek yapılabilir. Visual Stduio IDE'sinde bu durum menüler yoluyla 
	ayarlanmaktadır. g++ ve clang derleyicinde -std seçeneği ile ayarlama yapılır. Örneğin:

	-std=c++11
	-std=c++14
	-std=c++17
	-std=c++20  (-std=c++2a)
	-std=c++2b

	Örneğin:

	g++ -std=c++2a -o sample sample.cpp

	Burada -std=c++2a artık yeni derleyicilerde -std=c++20 ile değiştirilmiştir. -std=c++2b ise C++23'ün de bazı özelliklerini barındırmaktadır.

	gcc ile C++ programları da derlenebilir. (Aslında gcc önce GNU C derleyicisi olarak geliştirilmişti. Sonra diğer derleyicileri de çalıştıran bir program
	haline getirildi.) Bu durumda gcc zaten g++ derleyicisini çalıştırmaktadır. Ancak gcc ile derleme yapılırken libstdc++ kütüphanesinin "-lstdc++" komut satırı 
	argümanı ile link aşamasında devreye sokulması gerekmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de ve C++'ta standartlarda belirtilen sentaks ve semantik kurallara uyulmadan yazılmış olan programlar yine de derleyici tarafından başarıyla derlenebilirler. 
	Çünkü standartlar geçerli programların derlenmesi gerektiğini koşul olarak ifade etmiştir. Ancak geçesiz programların derlenip derlenmeyeceği konusunda bir hüküm
	belirtmemiştir. Yalnızca standartlarda geçersiz durumlar karşısında derleyicilerin bunu en az bir mesajla (diagnostic message) bildirimeleri zorunlu tutulmuştur. 
	Yani bu durumda	geçerli programlar her zaman başarıyla derlenmek zorundadır. Ancak geçersiz programlar başarıyla derlenebilir ya da derlenmeyebilir. Bu nedenle
	derleme işleminin başarısına bakarak dilin kurallarını öğrenmeye çalışmak iyi bir yöntem değildir. Ayrıca C ve C++'ta derleyiciler diğer derleyicilerde olmayan 
	"eklentilere (extensions)" sahip olabilirler. Neyin bir eklenti olup olmadığının programcı tarafından bilinmesi gerekir. Eğer biz bir derleyicinin eklentisini 
	kullanırsak o kodu başka bir derleyiciye götürdüğümüzde kod başarılı olarak derlenmeyebilir. Çalıştığınız derleyicilerin eklentilerini bilmelisiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın C'den farklılıkları genellikle "fazlalık" biçimindedir. Bu fazlalıkların bir bölümü C++'ı daha iyi bir C yapmak için dile eklenmiştir. Bunlara "C++'ın 
	C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları" diyeceğiz. Biz kurusumuzda önce bunlar üzerinde duracağız. 
	Sonra C++'ı "Nesne Yönelimli bir dil yapan C++ özgü konular üzerinde duracağız. Yani kursumuz kabaca üç bölümden oluşmaktradır:
	
	1) C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları
	2) C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgili Olan Fazlalıkları ve Farklılıkları
	3) C++'ın Diğer Öenmli Özellikleri ve Standart Kütüphanesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu bölümde "C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları" maddeler halinde ele alınacaktır.
	Burada her maddeyi özet bir cümleyle başlatacağız ve sonra onun ayrıntılarına gireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    1) C++'a // ile satır sonuna kadar yorumlama eklenmiştir. Bu özellik C90'da yoktu. Fakat C++98'den sonra sonra çıkan C99 ile birlikte C'ye de eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	cout << "Hello World" << endl;			// Merhaba dünya programı

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    2) C++'ta yerel değişkenler blokların herhangi bir yerinde bildirilebilirler. Halbuki C90'da yerel değişkenler blokların başlarında bildirilmek zorundaydı. 
	Ancak C99 ile birlikte bu kural C'de de C++'takşi gibi değiştirildi. C++'ta bir yerel değişkenin faaliyet alanı bildirim yerinden bildirildiği bloğun sonuna 
	kadarki bölgededir. Yine C++'ta iç içe ya da ayrık bloklarlarda aynı isimli yerel değişkenler bildirilebilir. Ancak aynı blok içerisinde aynı isimli yerel 
	değişkenler bildirilemez. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    3) C++'ta for döngülerinin birinci kısmında bildirimler yapılabilmektedir. Bu özellik C90'da yoktu. Ancak C99 ile birlikte C'ye de eklendi. Ayrıca C++'ta 
	diğer deyimlerin parantezleri içerisinde de bildirimler yapılabilmektedir. for döngüsünün birinci kısmında bildirim yapılabilmesi sentaksını C++'tan almış olan 
	Java ve C# gibi dillerde söz konusudur. Bu özellik döngü yazımını kolaylaştırmaktadır. Örneğin:

	for (int i = 0; i < 10; ++i) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		cout << i << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    for döngüsünün birinci kısmında bildirilen değişkenlerin faaliyet alanları for döngüsü ile sınırlıdır. Başka bir deyişle:

	for (bildirim; ifade; ifade) 
		<deyim>

	işleminin eşdeğeri aşağıdaki gibi düşünülmelidir:

	{
		bildirim;
	
		for (;ifade; ifade) 
			<deyim>
	}

	Yani "for döngüsünü kapsayan bir gizli blok" varmış gibi düşünmelisiniz. for döngüsünün diğer kısımlarında bildirim yapılamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) {
		cout << i << " ";
	}
	cout << endl;

	cout << i << endl;			// error! 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bu biçimdeki bir for döngüsünü aşağıya kopyalarsak faaliyet alanı bakımından bir sorun oluşmayacaktır.Örneğin:

	for (int i = 0; i < 10; ++i) {
		//...
	}
		
	for (int i = 0; i < 10; ++i) {
		//...
	}

	Buradaki i değişkenleri aslında ayrık bloklardaki i değişkenleri gibidir. Yukarıdaki kodun eşdeğerini aşağıdaki gibi düşünmelisiniz:

	{
		int i = 0;
	
		for (; i < 10; ++i) {
			ß//...
		}
	}

	{
		int i = 0;
	
		for (; i < 10; ++i) {
			//...
		}
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) 
		cout << i << " ";
	
	for (int i = 0; i < 10; ++i) 		// Buaraki i başka bir i
		cout << i << " ";

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe for döngülerinde de aynı isimli değişkenlerin bulunması bu bağlamda bir sorun oluşturmaz. Ancak iç for döngüsünde biz dış for döngüsünün birinci 
	kısmında bildirilen değişkenleri kullanamayız. Örneğin:

	for (int i = 0; i < 10; ++i)
		for (int i = 0; i < 10; ++i) {
			//...
		}

	Burada bir sorun yoktur. Çünkü yukarıdaki kodun eşdeğeri aşağıdaki gibidir:

	{
		int i = 0;

		for (; i < 10; ++i) 
			{
				int i = 0;

				for (; i < 10; ++i) {
					//...
				}
			}
	}

	Yani aslında buradaki söz konusu iki i değişkeni aynı blokta değildir, iç içe bloklardadır. Tabii biz iç döngüde dış döngüdeki i değişkenini artık kullanamayız. 

	Her ne kadar iç içe for döngülerinde döngülerin birinci kısmında aynı isimli değişkenler bildirilebiliyorsa da aslında bu durum iyi bir teknik değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		for (int i = 0; i < 10; ++i)
			cout << i << endl;		// Buradaki i iç for döngüsündeki i, diğer i'ye erişemeyiz
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	for döngülerinin birinci kısmında "aynı türden olmak koşulu ile" birden fazla değişkenin bilfirimi de yapılabilir. Örneğğin:

	for (int i = 0,  k = 100; i + k > 50; ++i, k -= 2) {
		//...
	}

	Ancak burada bildirilen değişkenler farklı türlerden olamamaktadır. Örneğin:

	for (int i = 0, long k = 100; ...) {		// geçersiz!..
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0, k = 100; i + k > 50; ++i, k -= 2)
		cout << i << ", " << k << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	for döngüsünün birinci kısmında bildirilen değişkenlere ilkdeğer verilmesi gerekir. Ancak bu durum C++'ta standartlarında zorunlu tutulmamıştır. Genel olarak 
	bu biçimde bildirilen değişkenlere ilkdeğer verilmemesinin bir anlamı yoktur. Örneğin:

	for (int i; i < 10; ++i) {		// geçerli ama çöp değer kullanılıyor
		//...
	}

	Java ve C# gibi diğer dilelrde ilkdeğer verme bir zounluluktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														3. Ders 21/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta if, while switch gibi deyimlerin parantezleri içerisinde de bildirimler yapılabilir. Bu durumda o değişkenlere atanan değerler test işlemine girer. Örneğin:

	if (void *ptr = malloc(1024)) {		// tahsisat başarılı ise
		//...
	}

	Burada ptr'ye atanan değer test işlemine sokulmaktadır. Örneğin:

	while (int a = foo()) {
		//...
	}

	Burada foo fonksiyonu sıfır dışı bir değerle geri döndüğü sürece döngü devam edecektir. Örneğin:

	switch (int a = rand() % 10) {
		//...
	}

	Böyle bir özellik C'de yoktur.

	Deyimlerin parantezleri içerisinde bildirim yapıldıktan sonra artık atanan değerin aynı ifadede işleme sokulması mümkün değildir. Örneğin:

	while ((int i = foo() < 10) {		// geçersiz! böyle bir sentaks yok
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
    static int i = 10;

    return --i;
}

int main()
{
    while (int i = foo())
        cout << i * i << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    4) C++'a bool türü ve bool türünden değer belirten true ve false anahtar sözcükleri de eklenmiştir. bool türü C90'da yoktu. Ancak C99 ile birlikte C'ye de 
	_Bool ismiyle bir boolean tür eklenmiştir. (C99'da <stdbool.h> içerisinde bool ismi ve true ve false isimleri makrolar biçiminde de oluşturulmuşttr.) C++'a 
	bool türü eklenince if gibi while gibi deyimlerdeki koşul ifadeleri de "bool türden olacak" biçimde değiştirilmiştir. Yani C++'ta if deyiminin ve while deyiminin
	koşul ifadesi artık bool türdendir. Eğer bu koşul ifadeleri bool türden değilse derleyici tarafından otomatik olarak (implictly) bool türüne dönüştürülmektedir.  
	Aynı durum for döngüsünün ikinci kısmı için de geçerlidir. 

	C++'ta karşılaştırma operatörlerinin ürettiği değerler de bool türdendir. (C'nin bütün standartlarında karşılaştırma operatörlerinin int türden değer ürettiğini 
	anımsayınız.)

	Standartlar bool türü için ayrılacak yerin derleyiciye bağlı olarak değişebileceğini (implementation-defined) belirtmektedir (8.5.2.3-1). Tipik olarak 
	derleyicileer bool türü için 1 byte yer ayırmaktadır.

	C++'a bool türünün C uyumunu koruyacak biçimde eklendiğine dikkat ediniz. Yani C++'taki bool türü adeta içerisinde 1 ve 0 değerleri bulunan bir tamsayı türü 
	gibidir. Ancak adres türleri otomatik olarak bool türüne dönüştürülebilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 0;
	bool result;

	result = a > 10;		// karşılaştırma operatörleri bool türden değer üretir
	cout << result << endl;

	result = true;			// true ve false birer anahtar sözcüktür

	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bool türü aritmetik işlemlere sokulabilir. Bu durumda "int türüne yükselteme kuralı (integral promotions)" gereğince otomatik olarak int türüne 
	dönüştürüldükten sonra işleme sokulmaktadır (7.6-6). Dönüştürme sırasında true değeri 1 olarak false değer 0 olarak dönüştürülmektedir. Yani örneğin int + bool 
	gibi bir işlemin sonucu int türden, double + bool biçiminde bir işlemin sonucu double türden, bool + bool gibi bir işlemin sonucu int türden elde edilecektir. 
	Skaler türler de bool türüne otomatik olarak (implicitly) dönüştürülebilmektedir. Sıfır dışı skaler değerler true olarak, 0 değeri ise false olarak 
	dönüşürülmektedir. Ayrıca adres türlerinden bool türüne de otomatik dönüştürme vardır. NULL adres değerleri false olarak diğer adresler ise true olarak bool 
	türüne dönüştürülürler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10, c;
	bool b = true;
	char s[10];

	c = a + b;		// geçerli bool türü işlem öncesinde otomatik olarak int türüne dönüştürülür

	cout << c << endl;

	b = 120;		// geçerli, sıfır dışı değerler true olarak dönüştürülür

	cout << b << endl;	

	b = 0;			// geçerli, sıfır değeri false olarak dönüştürülür

	cout << b << endl.i

	b = s;			// geçerli NULL pointer falsde olarak diğer adresler true olarak dönüştürülür

	cout << b << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    5) C++'ta bir fonksiyonun çağrılma noktasına kadar derleyicinin o fonksiyonun prototipiyle ya da tanımlamasıyla karşılaşmış olması gerekmektedir. C90'da 
	fonksiyon çağrısını gören derleyici eğer daha önce fonksiyon hakkında bir bilgi edinmemişse onun int geri dönüş değerine sahip olarak tanımlandığını varsayıyordu.
	Gerçi bu kural da C99 ile birlikte C++'taki gibi değiştirilmiştir. Bu durumda C++'ta örneğin bir kütüphane fonksiyonu çağrılacaksa mutlaka o fonksiyonun 
	prototipinin bulunduğu başlık dosyası da include edilmelidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	foo();		// C90'da geçerli ancak C++'ta ve C99'da geçersiz

	return 0;
}

int foo(void)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    6) C++'ta fonksiyon prototiplerinde parametre parantezinin içinin boş bırakılması ile parametre parantezlerinin içine void yazılması aynı anlamdadır. Ancak 
	C'nin tüm standartlarında bunlar farklı anlamlara gelir. C'de prototiplerde parametre parantezinin içinin boş bırakılması "bu fonksiyon herhangi bir sayıda 
	parametreye sahip olabilir, bu nedenle fonksiyon çağrılırken argümanlar sayıca ve türce kontrol edilmeyecek" anlamına geliyordu. Halbuki C++'ta artık parametre
	parantezinin içinin boş bırakılmasıyla void yazılması tamamen aynı anlama gelmektedir. Tabii C'de de bir fonksiyonun tanımlanması sırasında parametre arantezinin 
	içinin boş bırakılmasıyla void yazılması aynı anlama geliyordu. C ile C++ arasındaki farklılık tanımlamada değil prototip bildiriminde ortaya çıkmaktadır.
	Tabii C++'ta programcı isterse yine prototiplerde ya da tanımalam sırasında parametre parantezlerinin içerisine void yazabilir. 

	Aşağıdaki örnekteki kod C'de geçerli olduğu halde C++'ta geçersizdir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo();

int main()
{
	foo(10, 20);		// C'de geçerli, C++'ta geçersiz

	return 0;
}

int foo(int a, int b)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi hem C'de hemde C++'ta başından beri fonksiyon tanımlaması sırasında parametre parantezinin içinin boş bırakılması fonksiyonun 
	parametreye sahip olmadığı anlamına gelmektedir. Biz Derneğimizde C kurslarında genel olarak parametresiz fonksiyonların tanımlamasında parametre parantezinin
	içini boş bırakmayıp void yazıyorduk. Ancak C++ kurslarımızda parametre almayan fonksiyonlarda tanımlama sırasında ve prototip bildiriminde parametre parantezinin 
	içerisini boş bırakacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()			// C'de de C++'ta da foo fonksiyonun parametresi yok void yazmakla aynı
{
	return 0;
}

int main()
{
	foo(10, 20);		// C'de ve C++'ta geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    7) Hem C'de hem de C++'ta void göstericiye herhangi bir türden adres atanabilir. Ancak void bir adresin void olmayan göstericiye atanması C'de geçerli olduğu 
	halde C++'ta geçersizdir. C++'ta void bir adres void olmayan bir göstericiye tür dönüştürmesi yapılarak atanmalıdır. Örneğin:

	void *pv;
	int *pi;
	//...

	pv = pi;			// hem C'de hep de C++'ta geçerli
	pi = pv;			// C'de geçerli fakat C++'ta geçersiz!
	pi = (int *)pv;		// hem C'de hem de C++'ta geçerli

	C++'ta void adresin void olmayan bir göstericiye atanmasının (yani otomatik olarak dönüştürülmesinin) engellenmesinin temel nedeni aslıda C'deki bir açığı 
	kapatmak içindir. C'de aşağıdkai gibi bir bir açık vardı:

	int *pi;
	char *pc;
	void *pv;
	...

	pv = pi;		// C'de v e C++'ta geçerli
	pc = pv;		// C'de geçerli

	Burada biz aslında pc = pi işlemini yapmış olmaktayız. Normalde geçersiz olması gereken bu işlem araya bir void gösterici sokularak geçerli hale gelmektedir. 
	Oysa C++'ta böylesi bir "arkadan dolaşma" yapılamamaktadır. Tabii C'de neden void bir adresin void olmayan bir göstericiye atanabildiğini sorgulayabilirsiniz. 
	Bu tarihsel bir özelliktir. Zaten C++ fırsat bu fırsat C'nin böylesi açıklarını da kapatmak istemiştir. Bu tür durumlarda tür dönüştürmesi genel olarak 
	"işlemin programcı tarafından yanlışlıkla değil bilinçli olarak yapıldığını" ifade etmektedir. 

	Programlama dillerinde "kuvvetli tür kontrolü (strong type checking)" ve "zayıf tür kontrolü (weak (loose) type checking)" biçimibde bir kavram vardır. Eğer 
	biz bir dilde farklı türleri serbestçe biribine atayıp onları birlikte işleme sokabiliyorsak o dilin tür kontrolü zayıftır. Eğer bir dilde biz farklı türleri 
	birbirine atayamayıp onları birlikte işleme sokamıyorsak o dilin tür kontrolü kuvvetlidir. C ve C++'ın tür kontrolü kuvvetli değildir. Orta düzeydedir. 
	Örneğin Java ve C#'taki tür kontrolü C ve C++'a göre daha kuvvetlidir. Swift gibi Rust gibi dillerde tür kontrolü çok daha kuvvetlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a[10];
	void *pv;
	double *pd;

	pv = a;		// hem C'de hem C++'ta geçerli
	pd = pv;	// C'de geçerli, C++'ta geçersiz

	pd = (double *)pv;					// geçerli 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											4. Ders 23/08/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    8) C'de string'ler char türden bir dizi kabul edilmektedir. (Yani string'leri gören derleyici onun karakterlerini null karakter dahil olmak üzere char türden 
	statik ömürlü bir diziye yerleştirir. String yerine o dizinin kullanıldığını varsayar.) Ancak string'lerin karakterlerinin güncellenmesi "tanımsız davranışa 
	(undefined behavior)" yol açmaktadır. Ancak C++'ta string'ler const char türünden dizi anlamına gelmektedir. Dolayısıyla bir string'i char türden bir göstericiye 
	atarken göstericinin de gösterdiği yer const olan bir gösterici olması gerekir. Örneğin:

	char *str;
	//...

	str = "ankara";			// C'de geçerli C++'ta geçersiz!
	
	Örneğin:

	const char *str;
	//...

	str = "ankara";			// C'de de C++'ta da geçerli

	char türden, signed char türden ve unsigned char türden bir diziye ilkdeğer verirken kullanılan iki tırnakların string belirtmediğini anımsayınız. Bu 
	nedenle C++'ta da tıpkı C'de olduğu gibi char türden, signed char türden ve unsigned char türden diziler iki tırnak ifadesiyle ilkdeğer verilerek 
	tanımlanabilirler.

	char s1[] = "ankara";				// C'de de C++'ta da geçerli
	signed char s2[] = "ankara";		// C'de de C++'ta da geçerli
	unsigned char s[] = "ankara";		// C'de de C++'ta da geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	const char *str = "ankara";

	cout << str << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	9) C'de N elemanlı char türden, signed char türden ve unsigned char türden bir diziye iki tırnak içerisinde N karakterli bir yazı ile ilkdeğer verilebilir. Bu 
	durumda derleyici null karakteri diziye yerleştirmez. Ancak bu durum C++'ta geçerli değildir. C++'ta N karakterlik bir yazının ilkdeğer verildiği dizinin
	en azından N + 1 karakter uzunluğunda olması (ya da uzunluk belirtilmemesi) gerekir. Örneğin:

	char s[6] = "ankara";		// C'de geçerli ancak C++'ta geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    10) C++11 ile birlikte UNICODE string'ler ve karakter sabitleri de dile eklenmiştir. UNICODE UTF-8 için u8 öneki, UNICODE UTF-16 için u öneki ve UNICODE 
	UTF-32 için U öneki kullanılmaktadır. u önekli string'ler const char16_t türünden, U önekli string'ler const char32_t türünden ve u8 önekli string'ler de 
	const char8_t türünden bir dizi olarak ele alınmaktadır. C++20'ye kadar char8_t biçiminde bir tür yoktu. Bu tür C++20 ile eklenmiştir. Bu tür isimleri 
	typedef değil anahtar sözcüklerdir. Bu türlerin hepsi işaretsiz bir tamsayı türü belirtmektedir. Bunların işaretli biçimleri de yoktur. C++'ta u önekli string'ler
	const char16_t türünden, U önekli string'ler const char32_t türünden ve u8 önekli string'ler ise const char8_t türünden dizi kabul edilmektedir. Örneğin:

	const char *s = "Ankara";					// default karakter tablosu 
	const char16_t *k = u"Ağrı Dağı";			// UTF-16
	const char32_t *t = U"Ağrı Dağı";			// UTF-32
	const char8_t *m = u8"Ağrı Dağı";			// UTF-8
	
	char8_t türünden, char16_t türünden ve char32_t türünden dizilere u8 önekli, u önekli ve U önekli iki tırnaklı ifadeler ilkdeğer olarak verilebilmektedir. 
	Tabii bu durumda dizilerin const olması gerekmez. Örneğin:

	char8_t s1[] = u8"ankara"; // geçerli
    char16_t s2[] = u"ankara"; // geçerli
    char32_t s3[] = U"ankara"; // geçerli

	C++20'ye kadar char8_t türü yoktu. Dolayısıyla C++20'ye kadar u8 önekli string'ler unsigned char türünden diziler gibi ele alınıyordu. C++20'de u8 önekli 
	string'ler için de char8_t türü eklenmiştir. C++20 satndartları C++20'ye eklenen char8_t türünün unsigned char türü ile aynı uzunlukta olması gerektiği 
	belirtilmiştir. (Başka bir deyişle C++20'de eklenen char8_t türü adeta unsigned char türü gibidir ancak fakat farklı bir türdür.)

	char8_t türü, char16_t türü ve char32_t türü cout ile stdout dosyasına yazdırılamamaktadır. 

	Tabii nasıl u önekli, U önekli ve u8 önekli stringler varsa aynı zamanda bu önekli karakter sabitleri de vardır. Bu karakter sabitleri de sırasıyla char16_t, char32_t 
	ve char8_t türünden sabitler kabul edilmektedir. Örneğin:

    char8_t a = u8'a';
    char16_t b = u'b';
    char32_t c = U'c';

	Karakter kodlamaları (character encoding) ayrıntıları olan uygulamada çetrefil bir konudur. Bir karakter tablosu "glyph", "code point" ve "encoding" denilen 
	üç kavramla ilgilidir. Karakter tablosundaki karakter görüntülerine "glyph" denilmektedir. Karakter tablosunu oluşturanlar her karaktere bir numara verirler. 
	İlgili glyph'in numarasına "code point" denilmektedir. Bir code point'in ikilik sistemde byte'lar haline ifade edilme biçimine de "encoding" denilmektedir. 
	Örneğin ASCII tablosunda 'A' glyph'inin code point'i 65'tir. ASCII tablosu tamamne düz binary dönüştürmeyle encode edilmektedir. Son 20 yıldır ASCII tablosunun 
	ve bu tablonun "code page" varyasonları çeşitli bakımlardan yetersiz kaldığı için UNICODE denilen (ISO 10646) her karakterin kabaca 2 byte ile ifade edilebildiği
	dünyanın bütün karakterlerinin içinde bulunduğu karakter tablosu oldukça yaygınlaşmıştır. Pek çok yeni programlama dilinde "char" türü UNICODE karakterleri
	tutmak için oluşturulmuştur. UNICODE tablonun UTF-16, UTF-32 ve UTF-8 denilen encoding'leri vardır. UTF-16 UNICODE için en doğal encoding'tir. Bu encoding'te 
	kabaca her UNICODE code point WORD biçimde (2 bytelık sayı olarak) kodlanmaktadır. UTF-32'de ise her code point 4 byte ile kodlanmaktadır. Ancak UNICODE tablonun 
	en yaygın encoding'i UTF-8 denilen encoding'tir. UNICODE tablonun ilk 128 karakteri standart ASCII tablosu ile aynıdır. Sonraki 128 karakteri de ISO 8859-1 
	denilen Latin1 code page'i ile aynıdır. UTF8-8 encoding'inde standart ASCII karakterler 1 byte ile diğer karakterler duruma göre 2 byte, 3 byte 4 byte ve 5 byte 
	ile kodlanmaktadır. Bugün kullandığımız programalama editörlerinin büyük kısmının default encoding'i UNICODE UTF-8'dir. 

	Ancak bu konu sanıldığından daha çetrefildir. Çünkü bir C/C++ programı yazarken değişik aktörler devreye girmektedir. Bu aktörlerden birincisi kodu yazdığımız 
	editördür. Bu editörün default bir encoding'i vardır. Örneğin kursun yapıldığı bilgisayardaki Visual Studio IDE'sinin default encoding'i ASCII 1254 code page'idir. 
	Visual Studio Code IDE'sinin defaulşt encoding'i UNICODE UTF-8'dir. İkinci aktör bizzat derleyicinin kendisidir. Derleyici kaynak kodu aldığında o kaynak 
	koddaki yazının da belli bir encoding'e göre kodlandığını varsaymaktadır. Eğer bizim kaynak kodda kullandığımız encoding derleyicinin varsaydığı encoding'ten 
	farklıysa burada da potansiyel bir problem vardır. Buna derleyicinin "kaynak karakter kümesi (source character set)" denilmektedir. Kaynak karakter kümesi 
	derleycilerde komut satırı seçenekleriyle değiştirilebilmektedir. Üçüncü aktör ise programın çalıştırıldığı ortamdaki aygıtların (stdout ve stdin aygıt 
	sürücülerinin) varsaydığı encoding'tir. Buradaki uyuşmazlık karakterlerin doğru gözükmemesine yol açacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    11) C++'ta sınıflarla temel türlerin şablon uyumunun sağlanması için temel türlere de parantezler ile ilkdeğer verilebilmesi mümkün hale getirilmiştir. 
	Örneğin:

	int a = 10;

	Biz bu tanımlamayı şöyle de yapabilirdik:

	int a(10);		// C++'a özgü, C'de böyle bir ilkdeğer verme sentaksı yok

	Ancak parantezlerin içini boş bırakmak "fonksiyon prototipi" anlamına gelmektedir. Örneğin:

	int b();		// bu ilkdeğer verme sentaksı değil! Fonksiyon prototipi

	Örneğin:

	const char *name("ali");

	Pekiyi bir diziye ya da yapıya da bu biçimde ilkdeğer verebilir miyiz? Örneğin:

	int a[3](10, 20, 30);

	Bu durum C++20'ye kadar geçerli değildi. Yani C++20 öncesinde dizilere ve yapılaba normal parantezlerle ilkdeğer verilemiyordu. Ancak C++20 ile birlikte 
	bu durum da geçerli hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    12) C++'ta çeşitli biçimlerde ilkdeğer verme (initialization) sentaksları bulunmaktadır. Örneğin bir değişkene bir ifade ile '=' atomu kullanılarak ilkdeğer 
	verilebilir:

	int a = 10;
	
	Böyle ilkdeğer verme C'de yoktur. Bu normal parantez sentaksı C++'ta sınıflar için düşünülmüştür. Ancak temel türler için de kullanılabilmektedir. 

	Bir diziye küme parantezleriyle ilkdeğer verilir:

	int a[] = {1, 2, 3};

	C'de ve C++'ta skaler türlere de küme parantezi ile ilkdeğer verilebilmektedir. Örneğin:

	int a = {10};

	Bir sınıf nesnesi normal parantezlerle ilkdeğerlenir:

	Sample s(10, 20);

	Yukarıda da belirttiğimiz C++'ta bu sınıflar düşünülmüş olan (...) sentaksı skaler türler için de kullanılabilmektedir. Örneğin:

	int a(10); 

	İşte C++11 ile birlikte her durum için geçerli olan ilkdeğer verme sentaksı oluşturulmuştur. Buna "Uniform Initializer Syntax" denilmektedir. Bu sentaksta 
	hiç '=' atomu kullanılmadan doğrudan küme parantezleri içerisinde ilkdeğer verilir. Örneğin:

	int a{10};
	const char *b{"ali"};
	int c[]{1, 2, 3};
	int d{};				// d = 0

	Bu ilkdeğer verme sentaksına "Uniform Initializer Syntax" denilmesinin nedeni her türden değişkene bu biçimde ilkdeğer verilebilmektedirilmesidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a{10};
	const char *b{"ali"};
	int c[]{1, 2, 3};
	int d{};				// d = 0

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Uniform Initializer Syntax ile ilkdeğer verme sırasında bilgi kaybına yol açabilecek dönüştürmeler geçerli değildir. Bilgi kaybına yol açabilecek dönüştürmelere
	C++11 standartlarında "daraltıcı dönüştürmeler (narrowing conversion)" denilmektedir. Büyük tamsayı türünden küçük tamsayı türüne yapılan dönüştürmeler, 
	gerçek sayı türlerinden tamsayı türlerine yapılan dönüştürmeler bilgi kaybı oluşturabildiği için "daraltıcı dönüştürmeler (narrowing conversion)" durumundadır. 
	Örneğin:

	int a{3.14};		// geçersiz!
	int b = 3.14;		// geçerli
	double c{3.14};		// geçerli
	float d{c}; 		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a{10.2};			// geçersiz!
	int b = 10.2;			// geçerli
	int c[]{1, 2, 3.4, 5};	// geçersiz!

	long d{100};			// geçerli
	int e{d};				// geçersiz

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															5. Ders 28/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki dönüştürmeler daraltıcı dönüştürmeler olarak kabul edilmektedir:

	- Gerçek sayı türlerinden tamsayı türlerine yapılan dönüştürmeler (örneğin long double, double ve float türünden int türüne yapılan dönüştürmeler). Örneğin:

	double d{3.0};
    int a{d};			// geçersiz! 
	int b{3.0};			// geçersiz!

	- Büyük gerçek sayı türünden bir daha küçük bir gerçek sayı türüne yapılan dönüştürmeler. Örneğin double türünden float türüne yapılan dönüştürmeler
	daraltıcı dönüştürmelerdir. Ancak büyük gerçek sayı türünden değer bir sabit ifadesi biçiminde verildiyse ve bu sabit ifadesi hedef tür ile tam olarak 
	ifade edilebiliyorsa bu daraltıcı dönüştürme kabul edilmemektedir. Örneğin:

	double d{3.14};
	float f{d};			// geçersiz!
	float e{3.14}		// geçerli, çünkü 3.14 bir sabit ifadesidir ve float türüyle tam olarak temsil edilebilmektedir. 
	float g{3.14 + 1};	// geçerli, çünkü 4.14 bir sabit ifadesidir ve float türüyle tam olarak temsil edilebilmektedir. 

	- Bir tamsayı türünden gerçek sayı türüne dönüştürmeler de bilgi kaybına yol açabilme potansiyeline sahip olduğu için daraltıcı dönüştürmelerdir. Ancak 
	tamsayı türünden değer bir sabit ifadesi biçiminde belirtilmişse ve bu sabit ifadesi hedef tür tarafından tam olarak ifade edilebiliyorsa bu bir daraltıcı
	dönüştürme değildir. Örneğin:

	int a{10};
	double b{a};		// geçersiz!
	char c;
	double e{c};		// geçersiz!
	float f{1234};		// geçerli

	- Bir tamsayı türünden başka bir tamsayı türüne dönüştürme yapılırken eğer hedef tür "o sistemdeki" kaynak türün tüm değerlerini içeriyorsa bu bir daraltıcı 
	dönüştürme değildir. Ancak içermiyorsa bu bir daraltıcı dönüştürmedir. Örneğin:

	int a{10};
    unsigned b{a};      // geçersiz!
	unsigned c{10};
    int d{c};			// geçersiz!
	long e{10};
    int f{e};			// int ile long türünün aynı uzunlukta olduğu sistemlerde geçerli (örneğin Microsoft derleyicilerinde)
						// ancak int ve long türünün farklı uzunluklarda olduğu sistemlerde geçersiz (örneğin 64 bit Linux derleyicilerinde)

	Ancak kaynak tamsayı türündeki değer bir sabit ifadesi ise ve hedef türün sınırları içerisinde kalıyorsa bu bir daraltıcı dönüştürme değildir. 
	Örneğin:

	unsigned a{10};		// geçerli, 10 int türden fakat unsigned int sınırları içerisinde
	unsigned b{-10};	// geçersiz! -10 int türden fakat unsigned int sınırları içerisinde değil
	int c{123L};		// geçerli, 123 long türden ancak int sınırları içerisinde 
	long d{123};		// geçerli, 123 int türden ve long türünün sınırları içerisinde

	- Anımsanacağı gibi adres türlerinden bool türüne otomatik dönüştürme vardı. Ancak adres türlerinden bool türüne yapılan dönüştürmeler daraltı
	dönüştürmelerdir. Örneğin:

	char s[10];
    bool b = s;     // geçerli

    bool c{s};		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++11 ile birlikte küme parantezleri ile ilkdeğer vermelerin hepsinde daraltıcı dönüştürme yasaklanmıştır. Örneğin aşağıdaki ilkdeğer vermeler 
	C++11 öncesi geçerli olduğu halde C++11 ile birlikte artık geçersizdir:

	int a[] = {10.2, 1, 2};				// geçersiz!
	int b = {3.14};						// geçersiz!
	short c[]{10L, 100, 1000};			// geçerli

	Görüldüğü gibi her ne kadar daraltıcı dönüştürmeler C++11'in Uniform Initializer Syntax'ı ile kavramsal olarak dile eklendiyse de yalnızca Uniform Initializer 
	Syntax ile değil tüm küme parantezleri ile ilkdeğer verilirken etkili olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a[] = {10.2, 1, 2};		// C++11 ile birlikte artık geçerli değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	13) C++'ta const nesneler onlara verilen ilkdeğerler "sabit ifadesi (constant expression)" ise sabit ifadesi belirtirler. Halbuki C'de const nesneler hiçbir 
	zaman sabit ifadesi belirtmezler. Ayrıca C++'ta global const nesneler "internal linkage"a sahiptir. (Yani sanki static global nesneler gibi düşünülmelidir.)
	Tabii bir sabit ifadesi sabit ifadeleriyle de oluşturulabilmektedir. Örneğin:

	const int a = 10;		// a sabit ifadesi olarak kullanılabilir
	const int b = a + 20;	// b sabit ifadesi olarak kullanılabilir
	const int c = foo();	// c sabit ifadesi olarak kullanılamaz!

	Anımsanacağı gibi C'de (ve C++'ta) bazı durumlarda sabit ifadesi kullanımı zorunludur. Örneğin case ifadelerinin sabit ifadesi olması gerekir. Örneğin dizi
	tanımlanırken dizi uzunluklarının sabit ifadesi olması gerekmektedir. (C99'da yerel diziler için bu zorunluluk ortadan kaldırılmıştır.) Örneğin C++'ta 
	şablonların tür olmayan (none-type) parametreleri sabit ifadesi olarak girilmek zorundadır. Sabit ifadelerinin diğer önemli bir işlevi de onların değerlerinin 
	derleme zamanında hesaplanabilmesi dolayısıyla programın çalışma zamanı sırasında gereksiz bir biçimde yapılmamasıdır. Bu optimizasyon temsaına "constant folding"
	denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

const int SIZE = 10;

int main()
{
	int a[SIZE];			// geçerli SIZE sabiti ifadesi ile ilkdeğer verilmiş bir const nesne
	
	int val;
	const int AA = 2;
	int b = 10;
	const int BB = b;

	cout << "Bir değer giriniz:";
	cin >> val;

	switch (val) {
		case AA:				// geçerli AA bir sabit ifadesi
			break;
		case BB:				// geçersiz! BB bir sabit ifadsi değil, çünkü ona verilen ilkdeğer sabit ifadesi değil
			break;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta global const nesnelerin "internal linkage" özelliğine sahip olması onların başka bir modülden extern yapılsa bile kullanılamayacağı anlamına gelmektedir. 
	Bu durumda derleyiciler global const nesnelere verilen ilkdeğerler sabit ifadesi ise onlar için hiç ayırmayabilirler. Çünkü aslında sabit ifadeleri ile ilkdeğer
	verilmiş olan global const nesneler kod içerisinde kullanıldığında derleyici zaten onların değerlerine koda enjekte edecektir. Bunlar başka bir modülden de
	kullanılamayacağına göre onlar için yer ayrılmasının da bir anlamı kalmayacaktır. Şüphesiz aynı durum yerel const nesneler için de geçerlidir. Anımsanacağı gibi 
	yerel değişkenlerin zaten "linkage" özelliği yoktur. Tabii programcı const nesnelere sabit ifadesi ile ilkdeğer verdikten sonra onların adreslerini alıp 
	kod içerisinde kullanırsa derleyiciler mecburen onlar için yer ayırmak durumunda kalır. 
	
	O halde C++'ta sabit ifadeleriyle ilkdeğer verilmiş global const nesneler adeta #define sembolik sabitleri gibi kullanılabilmektedir. Biz global const 
	nesneleri (özellikle sabit ifadeleriyle ilkdeğer verilmiş olanları) başlık dosyalarına (header files) yerleştirip birden fazla kaynak dosyadan include 
	edebiliriz. Bu durumda herhangi bir problem ortaya çıkmayacaktır. C++ programcıları #define sembolik sabitleri yerine global const nesneleri kullanmayı 
	tercih edebilmektedir.

	Anımsanacağı gibi iki yer belirleyici (storage class specifier) anahtar sözcük bildirimde bir arada kullanılamamaktadır. Örneğin:

	extern static int g_x;		// geçersiz!

	Ancak tür niteleyicileriyle (const ve volatile) yer belirleyicileri birlikte kullanılabilirler. Örneğin:

	extern const int g_x = 10;

	C++'ta const nesneler default durumda "inernal linkage" özelliğine sahiptir. Ancak özellikle extern belirlemesi yapılırsa "external linkage" özelliğine 
	sahip olmaktadır. 

	Ayrıca C++'ta const nesnelere artık ilkdeğer verilmek zorundadır. Halbuki C'de anlamsız olsa da const nesnelere ilkdeğer vermek zorunlu değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    14) C++'ta statik ömürlü değişkenlere (yani global ve statik yerel nesnelere) verilen ilkdeğerler sabit ifadesi olmak zorunda değildir. Halbuki C'de global 
	değişkenlere ve statik yerel değişkenlere verilen ilkdeğerlerin sabit ifadesi olması zorunludur. C'de bu zorunluluk derleyicinin statik ömürlü değişkeni
	ilkdeğeri ile birlikre amaç koda yazma gerekeliliğinden kaynaklanmaktadır. Bu gereklilik C++'ta oratadan kaldırılmıştır. (Çünkü C++'ta main fonksiyonu 
	çağrılmadan önce derleyici başka kodlar da çalıştırabilmektedir.) Örneğin:

	int foo()
	{
		return 10;
	}

	int g_x = foo();			// C'de geçersiz! C++'ta geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    15) C++11 ile birlikte C++'a ismine "constexpr" denilen bir tür niteliyici (type qualifier) da eklenmiştir. constexpr bir değişken her zaman bir sabit ifadesi 
	biçiminde kullanılabilir. (const bir değişken sabit ifadesi olarak kullanılabilmesi için ona verilen ilkdeğerin sabit ifadesi belirtmesi gerektiğini anımsayınız.)
	Ancak constexpr değişkenlere verilen ilkdeğerlerin sabit ifadesi olması zorunludur.  Global constexpr değişkenler de yine "internal linkage" sahiptirler.
	constexpr değişkenler aynı zamanda const nesneler olarak ele alınmaktadır. Dolayısıyla örneğin bir constexpr değişkenin adresi ancak const bir göstericiye 
	atanabilir.	Örneğin:

	constexpr int a = 10;		// geçerli
	constexpr int b = a + 1;	// geçerli
	int c = 20;
	constexpr int d = c + 1;	// geçersiz! constexpr değişkene verilen ilkdeğerin sabit ifadasi olması gerekir
	const int e = 10
	constexpr int f = e + 1;	// geçerli

	constexpr değişkenler const değişkenlerin daha katı bir biçimi gibidir. Biz programımız içerisindeki sembolik sabitleri #define ile değil constexpr değişkenlerle 
	de oluşturabilmekteyiz. Örneğin:

	constexpr int SIZE = 10;

	Derleyiciler eğer onların adresleri alınmadıysa constexpr değişkenler için hiç yer ayırmayabilirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

constexpr int SIZE = 10;

int main()
{
	int a[SIZE];						// geçerli, SIZE bir sabit ifadesi

	constexpr int AA = SIZE + 2;		// geçerli, SIZE + 2 bir sabit ifadesi

	int b = 10;
	constexpr int CC = b + 2;			// geçersiz! b + 2 bir sabit ifadesi değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															6. Ders 04/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr tür niteleyicisi fonksiyonlarda da kullanılabilmektedir. Bu tür fonksiyonlara constexpr fonksiyonlar denilmektedir. constexpr fonksiyonların 
	dile sokulmasından amaç bir fonksiyon çağrısının sabit ifadesi biçiminde derleme zamanında ele alınabilmesini sağlamaktır. const niteleyicisinin böyle bir 
	yeteneği yoktur. Örneğin:

	constexpr int foo()
	{
		return 10;
	}

	Bu fonksiyon çağrıldığında derleyici CALL makine komutu ile fonksiyonu çağırmaz. Doğrudan sanki çağrıdan 10 değeri elde edilmiş gibi 10 değerini kullanır. 
	Örneğin:

	constexpr int x = foo();

	Bu işlem için derleyici aşağıdakine eşdeğer bir kod üretecektir:

	constexpr int x = 10;

	constexpr fonksiyonların bazı ayrıntıları vardır. İzleyen bölümlerde bu ayrıntılar üzerinde duracağız. Örneğin:

	constexpr int x = foo();		// geçerli

	Yukarıdaki foo fonksiyonu sabit ifadesi oluşturduğu için constexpr bir değişkene ilkdeğer vermede kullanılabilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
	return 10;
}

constexpr int bar()
{
	return 10;
}

int main()
{
	int a[foo()];		// geçersiz! fonksiyon çağrıları sabir ifadesi oluşturmaz
	int b[bar()];		// geçerli, bar çağrısı sabit ifadesi oluşturur

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr fonksiyonlar aynı zamanda inline fonksiyon olarak kabul edilmektedir. inline fonksiyonlar izleyen paragraflarda ele alınmaktadır. Bu durumda her
	constexpr fonksiyon aynı zamanda bir inline fonksiyondur. Ancak inline fonksiyonlar constexpr fonksiyon değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11'de constexpr fonksiyonların birkaç önemsiz bildirimin dışında tek bir satırdan oluşması gerekiyordu. Yani C++11'de constexpr fonksiyonlar yalnızca return 
	içerebiliyordu. Ancak daha sonra bu constexpr fonksiyonların sentaks ve semantiğinde neredeyse her standartta biraz oynama yapılmıştır. C++20'yi dikkate 
	alırsak artık constexpr fonksiyonların içerisinde if gibi for gibi deyimler kullanılabilmektedir. Yani constexpr fonksiyonlar artık neredeyse normal bir 
	fonksiyon gibi yazılabilir durumuna getirilmiştir. C++11'de constexpr fonksiyonların çağrıldıklarında sabit ifadesi belirtmesi gerekiyordu. Ancak C++14 ile birlikte 
	constexpr fonksiyonların sabit ifadesi belirtme zorunluluğu da ortadan kaldırılmıştır. Ancak constexpr fonksiyonların sabit ifadesi belirtmesi için onlar çağrılırken
	argüman olarak sabit ifadelerinin kullanılıyor olması ve return ifadelerinin de sabit ifadesi oluşturuyor olması gerekmektedir. (Tabii return ifadelerinde parametreler 
	kullanılabilir. Eğer fonksiyon sabit ifadesi argümanlarla çağrılmışsa parametrelerin de sabit ifadesi belirttiği kabul edilmektedir.) Örneğin:

	constexpr int square(int a)
	{
		return a * a;
	}
	//...
	constexpr int a = square(10);		// geçerli
	constexpr int b = square(a + 2);	// geçerli

	int c = 10;
	constexpr int d = square(c);		// geçersiz! square çağrısı sabit ifadesi belirtmiyor.		

	Yukarıda da belirttiğimiz gibi artık constexpr fonksiyonların sabit ifadesi belirtmesi gerekmemektedir. Eğer constexpr bir fonksiyon sabit ifadesi olmayan 
	argümanlarla çağrılmışsa ya da return ifadesinde sabit ifadesi yoksa bu durumda sabit ifadesi belirtmez. Ancak sabit ifadesi belirtmeyen constexpr fonksiyonlar 
	tamamen normal inline fonksiyon gibi işleme sokulmaktadır.	Örneğin:

	int a = 10;
	int b = square(a);		// geçerli

	Burada contstexpr fonksiyon sabit ifadesi belirtmemektedir. Normal bir fonksiyon olarak ele alınacaktır.

	constexpr fonksiyonların geri dönüş değerleri ve parametre türleri "literal türlere (literal types)" ilişkin olmak zorundadır. Literal tür kavramı 
	birtakım yeniliklerin sonucunda dile eklenmiştir. Skaler türler ve void türü literal türlerdir. Literal tür tanımına giren diğer türler başka konuların
	içerisinde ele alınacaktır.

	C++23'e kadar (henüz resmi basımı yapılmadı) constexpr fonksiyonların en azından bir argümanlı çağrısı sabit iafdesi oluşturabilecek potansiyelde olması 
	gerekiyordu. Ancak bu kural da gevşetilmiştir. 

	constexpr fonksiyonun tüm bildirimlerinde constexpr niteleyicisinin kullanılması gerekir. Ancak tabii constexpr fonksiyonun sabit ifadesi olarak ele 
	alınabilmesi için derleyicinin çağrılma noktasına kadar constexpr fonksiyonunun tanımlaması ile karşılaşmış olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

using namespace std;

constexpr int square(int a)
{
	return a * a;
}

int main()
{
	int a[square(10)];		// geçerli, burada square(10) çağrısı sabit ifadesi belirtiyor
	int b{10};
	int c[square(b)];		// geçersiz artık square bir sabit ifadesi belirtimiyor
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi constexpr bir fonksiyon yan etkiye sahip olabilir mi? Örneğin:

	using namespace std;

	void foo()
	{
		//...
	}

	constexpr int bar(int a)
	{
		foo();

		return a;
	}

	Böyle bir bar fonksiyonu constexpr olarak tanımlanabilir mi? İşte C++23'e kadar bu durum mümkün değildi. Çünkü C++23'e kadar constexpr fonksiyonların 
	yalnızca sabit ifadesi üretmesi esastı. Buradaki sorun bar fonksiyonunun aslında hiçbir biçimde sabit ifadesi üretememesidir. bar fonksiyonun sabit 
	ifadesi üretmesi yalnıca return ifadesinde sabit ifadesi oluşturması anlamına gelmemektedir. bar fonksiyonun sabit ifadesi oluşturabilmesi demek her şeyiyle
	derleme aşamasında yalnızca bir sabit değerin elde edilebilmesi demektir. Ancak C++23 ile birlikte bu durum da gevşetilmiştir. C++23'te bar fonksiyonun 
	tanımlaması geçerlidir. Ancak fonksiyon hiçbir zaman sabit ifadesi oluşturamayacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun constexpr olması ve onun sabit ifadesi biçiminde açılabiliyor olması derleyicinin ""eğer bir zorunluluk yoksa"" onu derleme aşamasında sabit
	ifadesi olarak ele almasını zorunlu hale getirmemektedir. Örneğin:
	
	constexpr int square(int a)
	{
		return a * a;
	}
	//...

	int result = square(4);

	Burada derleyici square çağrısını derleme aşamasında ele alıp oraya 16 yazmak zorunda değildir. Gerçekten de derleyicilerin bir bölümü optimizasyon seçeneklerini 
	açmadıktan sonra bu çağrıyı sabit ifadesi olarak ele almamaktadır. Ancak C++ standratlarına göre buradaki square çağrısı sabit ifadesi olarak kullanılabilir. 
	Dolayısıyla biz bu square çağrısını sabit ifadesi gereken bir yerde kullanırsak artık derleyici kesinlikle onu bir sabit ifadesi gibi ele alacak ve çağrı 
	yerine doğrudan çağrı sonucunda elde edilecek değeri yerleştirecektir:

	constexpr int square(int a)
	{
		return a * a;
	}
	//...

	constexpr int result = square(4);

	Burada derleyici kodu aşağıdaki gibi ele alacaktır:

	constexpr int result = 16;

	Özetle "constexpr bir fonksiyonun çağrısı sabit ifadesi koşullarını sağlıyor olsa bile eğer çağrı bir sabit ifadesi gereken yerde kullanılmamışsa"" derleme
	aşamasında ele alınmak zorunda değildir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Mademki artık son standartlarda neredeyse constexpr fonksiyonlar normal fonksiyonlar gibi olmuştur. Bu durumda biz her fonksiyonu mümkün olduğunca constexpr
	yapmalı mıyız? Yukarıda da belirttiğimiz gibi hala constexpr fonksiyonlar için bazı kısıtlar bulunmaktadır. Bu kısıtları ayrıntı olduğu gerekçesiyle burada 
	şimdi ele almayacağız. Ancak olabilecek her fonksiyonu constexpr fonksiyon olarak tanımalama çalışmak da iyi bir fikir değildir. Bunun en önemli nedeni 
	constexpr fonksiynların default olarak inline kabul edilmesidir. Biz henüz inline fonksiyonları görmemiş olsak da inline fonksiyonların bazı kısıtları ve 
	dezavantajları söz konusu olabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr fonksiyonlarda fonksiyonun tüm prototip ve tanımlamasında constexpr belirleyicisinin kullanılması gerekmektedir. Örneğin:

	constexpr int square(int a);
	//...
	
	int square(int a)		// geçerli değl! burada da constexpr anahtar sözcüğünün kullanılması gerekirdi.
	{
		return a * a;
	}

	Tabii constexpr fonksiyonlarda fonksiyon çağrılana kadar derleyicinin fonksiyonun tanımlamasını görmesi gerekmemektedir. Ancak burada constexpr etkisi oluşmaz.
	Örneğin:

	constexpr int square(int a);
	//...
	
	int main()
	{
		constexpr int a = square(10);		// geçersiz! tanımalam görülmediği için constexpr etkisi oluşmaz
		int a = square(10);					// geçerli! constexpr fonksiyonların sabit ifadesi belirtmesi zorunlu değildir. 
		//...

		return 0;
	}

	int square(int a)		// geçerli değl! burada da constexpr anahtar sözcüğünün kullanılması gerekirdi.
	{
		return a * a;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında constexpr fonksiyonlarla ilgili bazı ayrıntılar da vardır. Örneğin cbir sınıfın yapıcı fonksiyonu (constructor) constexpr olabilmektedir. Sınıfın 
	üye fonksiyonları da constexpr olabilektedir. Konun bu ayrıntıları ilgili bölümlerde ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	16) constexpr fonksiyonlar C++11 ile dile eklendiğinde amaç bu fonksiyonların her zaman sabit ifadesi oluşurması biçimindeydi. Daha sonra bu koşul gevşetildi ve
	constexpr fonksiyonlar "koşula bağlı olarak sabit ifadesi oluşturur" hale getirildi. İşte C++20 ile birlikte her zmaan sabit ifadesi oluşturması gereken (yani
	C++11'deki constexpr fonksiyonlar gibi) yeni bir fonksiyon biçimi oluşturuldu. Bunlara consteval fonksiyonlar ya da "immediate fonksiyonlar" denilmektedir. 
	consteval bir fonksiyonun her çağrısının sabit ifadesi oluşturması zorunludur. Örneğin:

	constexpr int square1(int a)
	{
		return a * a;
	}

	consteval int square2(int a)
	{
		return a * a;
	}
	...
	
	int x = 10;
    int y = square1(x);			   // geçerli 
    int z = square2(x);            // geçersiz!

	Burada hem square1 hem de square2 çağrıları sabit ifadesi oluşturmamaktadır. Ancak constexpr fonksiyonların zaten çağrıldıklarında sabit ifadesi oluşturma 
	zorunluluğu yoktur. Fakat consteval fonksiyonların çağrıldıklarında sabit ifadesi oluşturma zorunluluğu vardır. Biz consteval fonksiyonları hangi ifadede 
	ve hangi nesneye ilkdeğer vermek için çağırırsak çağıralım çağrının sabit ifadesi oluşturması zorunludur. 

	consteval fonksiyonların constexpr fonksiyonların içerisinde çağrılması bu bakımdan bir farklılık yaratmamaktadır. Örneğin:

	consteval int square1(int a)
	{
		return a * a;
	}

	constexpr int square2(int a)
	{
		return square1(a);
	}

	Burada square2 fonksiyonu square1 fonksiyonunu çağırmıştır. Ancal square1 çağrısında sabit ifadesi kullanılmamış durumdadır. Bu işlemin tersini yapalım:

	constexpr int square1(int a)
	{
		return a * a;
	}

	consteval int square2(int a)
	{
		return square1(a);
	}

	Burada consteval fonksiyon olan square2, constexpr fonksiyon olan square1 fonksiyonunu çağırmıştır. Bu tanımlama derleme aşamsında bir sorun oluşturmayacaktır.
	Tabii square2 çağrılırken yine sabit ifadesi oluşturması gerekmektedir. Örneğin:

	int x = square2(10);		// geçerli

	int z = 10;
	int k = square2(z);			// geçersiz!

	Buradan da görüldüğü gibi önemli olan consteval fonksiyonun çağrısının derleme aşamasında sabit ifadesi oluşturma zorunluluğudur. 

	consteval bir fonksiyon için prototip bulundurulabilir. eğer fonksiyonun prototipinde consteval anahtar sözcüğü kullanılmışsa tanımlamasında da consteval
	anahtar sözcüğünün kullanılması zorunludur. consteval bir fonksiyonun henüz tanımalama görülmeden kullanılması geçerli bir durum oluşturmamaktadır. Örneğin:

	consteval int square(int a);

	int main()
	{
		int result = square(5);		// geçersiz! henüz tamlama görülmedi
		//...

		return 0;
	}

	consteval int square(int a)
	{
		return a * a;
	}

	consteval fonksiyonların adresleri alınamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    17) C'de ifadeler ya "lvalue" ya da "rvalue" biçimindedir. C'de nesne belirtilen ifadelere lvaluei nesne belirtmeyen ifadelere rvalue denilmektedir. C++ da 
	C'nin bu lvalue rvalue terimlerini kullanmıştır. Ancak C++11'e gelindiğinde dile bazı yeni özellikler eklenenince bu lvalue ve rvalue terimleri yetersiz kalmıştır.
	Böylece C++11 ile birlikte bu konu "value categories" ismiyle genişletilmiştir. C++11'de C'deki ve C++11 öncesindeki C++'taki "lvalue" yine "lvalue" olarak kalmıştır. 
	Ancak "rvalue" artık "prvalue (pure rvalue)" olarak değiştirilmiştir. C++11'deki bu konuda yapılmış olan asıl yenilik "xvalue (expiring value)" biçiminde yeni 
	bir kategorinin oluşturulmasıdır. Yukarıda da belirttiğimiz gibi bu kategorinin oluşturulmasının nedeni C++11 ile birlikte dile eklenen bazı özelliklerdendir. 
	C++11'le birlikte eklenen "xvalue" kategorisi duruma göre hem bir "lvalue" gibi hem de "rvalue" gibi kulalnılabilen ifadelerdir. Bu durumda C++11'e "glvalue (generilized
	value)" ve "rvalue" biçiminde iki üst kategori de eklenmiştir. glvalue kategorisi lvalue ve xvalue kategorilerinin birleşiminden oluşmaktadır. rvalue kategorisi ise
	prvalue ve xvalue kategorilerinin birleşiminden oluşmaktdır. Bu durum aşağıdaki şekil ile özetlenebilir:
		
		glvalue     rvalue
		glvalue     rvalue
		/  \	   /  \
	   /    \     /    \
	lvalue   xvalue    prvalue

	C++ standartlarında rvlaue denildiğinde artık prvalue ve xvalue anlaşılmaktadır. glvalue denildiğinde ise lvalue ve xvalue anlaşılmaktadır. Eski lvalue terimi 
	lvalue olarak kaldığına göre ve eski rvalue terimi de prvalue haline geldiğine göre o halde xvalue nedir? xvalue terimi yukarıda da belirttiğimiz gibi "hayatını 
	kaybetmek üzere olan" nesneler için kullanılmaktadır. Konunun ayrıntıları başka konularla ilgili olduğu için burada bu ayrıntılara henüz girmeyeceğiz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	18) C++'ta C'de olmayan ismine "referans (reference)" denilen göstericilere benzer adres tutan yeni bir tür de bulunmaktadır. C++11'e kadar C++'ta yalnızca 
	referans kavramı ve terimi vardı. Ancak C++11 ile birlikte "move semantic" denilen bir özelliğin C++'a eklenebilmesi için ismine "sağ tafa değeri referansı (rvalue
	referance)" denilen yeni bir referas türü daha dile eklenmiştir. Artık C++11 ve sonrasında eski referanslar "sol taraf değeri referansı (lavlue reference)" biçiminde
	isimlendirilmektedir. Yani eski referanslara artık "sol taraf değeri referansları" denilmektedir. C++11 ile eklenen referanslar ise "sağ taraf değeri referanlarıdır".

	Biz "referans" dediğimizde hem sol taraf değeri referanslarını hem de sağ taraf değeri referanslarını kastedeceğiz. Ancak bunları ayırmamız gerektiğinde açıkça
	"sol taraf değeri referansı" ya da "sağ taraf değeri referansı" diyeceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sol taraf değeri referansı dekleratörde & atomuyla tanımlanır. Referanslara tanımlama sırasında ilkdeğer verilmesi zorunludur. Bir sol taraf değeri 
	referansı tipik olarak aynı türden nesne belirten bir ifade ile (yani bir bir sol taraf değeri ile) ilkdeğer verilerek tanımlanmaktadır. Örneğin:

	int a{10};
	int &r = a;

	Sol taraf değerine ilişkin referansa ilkdeğer olarak verilen nesneye ilkdeğer verilmiş olması gerekmez. Örneğin:

	int a;
	int &r = a;		// gayet normal

	Bir referans ilkdeğer verilerek tanımlandığında derleyici ilkdeğer olarak verilen nesnenin adresini referansın içerisine yerleştirmektedir. Örneğin:

	double d{3.14};
	double &r = d;

	Burada derleyici d nesnesinin adresini r referansına yerleştirmektedir. Aslında C++ standartlarında referans için bir yer ayrılmayabileceği söylenmiştir. 
	Yani eğer derleyici referansın refere ettiği nesneyi doğrudan kullanbilirse optimizasyon mekanizması ile referans için hiç yer ayırmayabilir. Ancak tipik 
	olarak derleyiciler referans için bir yer ayırırlar ve referanslar da adres tutarlar. 

	Bir referans ilkdeğer verilmeden tanımlanamaz. Örneğin:

	int &r;				// geçersiz! İlkdeğer verme zorunlu

	Yukarıda da belirttiğimiz gibi sol taraf değeri referansına verilen ilkdeğerin referansla aynı türden nesne belirten bir ifade olması gerekir. Çünkü ancak 
	nesne belirten ifadelerin adresleri alınabilir. Örneğin:

	int a = 10;
	int &r = a;			// geçerli ilkdeğer verilmiş, r referansının içerisinde a'nın adresi var.

	Örneğin:

	int &r = 10;		// geeçersiz! Verilen ilkdeğer bir nesne belirtimiyor
	
	long a = 10;
	int &r = a;			// geçersiz verilen ilkdeğer farklı türden

	int a = 10;
	int &r = a;			// geçerli aynı türden bir nesne ile ilkdeğer verilmiş. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Teknik olarak referanslarla göstericiler çok benzerdir. Referanslar "düzeyi yüksek bir gösterici" gibidir. Yani hem referanslar hem de göstericiler adres 
	tutarlar. Ancak referanslara adresler onlara ilkdeğer verilirken yerleştirilmektedir. Oysa göstericilere istenildiği zaman adresler atanabilmektedir. Örneğin:

	int a = 10;
	int &r = a;

	Burada a'nın adresini derleyici elde edip r referansına yerleştirmektedir. Oysa örneğin:

	int a = 10;
	int *pi = &a;

	Göstericilere atama yaparken nesnenin adresini & operatörüyle bizim elde etmemiz gerekir. 

	Bir referans ilkdeğer verildikten sonra kullanıldığında	artık referansın içerisindeki adreste bulunan nesnenin (referansın refere ettiği nesnenin) kullanıldığı
	kabul edilmeketedir. Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Burada aslında r referansının içerisindeki adreste bulunan nesneye 20 yerleştiriliyor. 
	
	Görüldüğü gibi bir referansa tanımlanma sırasında bir adres yerleştirilmekte ve artık referans o nesneyi göstermektedir (refere etmektedir). Bir referans 
	tanımlandıktan sonra artık başka bir nesneyi gösterir hale getirilemez. 

	Referans içeren kodların eşdeğer gösterici karşılıkları konunun daha iyi anlaşılmasına yardımcı olmaktadır. Referans içeren bir kodun eşdeğer gösterici 
	karşılığı demekle referans yerine gösterici kullanılarak oluşturulan kodu kastediyoruz. Mademki referans içerisindeki adres ilkdeğer verildikten sonra bir daha
	değiştirilememektedir bu durumda referanslar "kendisi const olan const göstericilere" benzetilebilir. 
	
	Örneğin:

	int a = 10;
	int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int * const r = &a;

	Görüldüğü gibi bir referansa bir nesne ile ilkdeğer verildliğinde derleyici o nesnenin adresini kendisi referansa yerleştirmektedir. Ancak göstericilere biz 
	nesnenin adresini elde ederek yerleştirmekteyiz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											7. Ders 06/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi bir referans ilkdeğer verildikten sonra kullanıldığında her zaman artık refere ettiği nesnenin kullanıldığı kabul edilir. 
	Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Bu işlemin eşdeğer gösterici eşdeğeri şöyledir:

	int a = 10;
	int * const r = &a;
	*r = 20;

	Tabii C++11 ve sonrasında referanslara da "uniform initializer syntax" ile ilkdeğer verebiliriz. Örneğin:

	int a{10};
	int &r{a};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi bir referans ilkdeğer verilen nesneyi gösterir (refere eder). Artık referansın başka bir nesneyi göstermesi sağlanamaz. 
	(Çünkü referansı tanımladıktan sonra artık ona değer atadığımızda değer referansın kendisine değil onun refere ettiği nesneye atanmış olmaktadır. Halbuki 
	göstericiler eğer const değillerse herhangi bir zaman başka bir nesneyi gösterebilirler. Referanslar C++'a "güvenli gösterici oluşturmak için" sokulmuştur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a{10};
	int &r = a;

	cout << r << endl;

	r = 20;

	cout << a << endl;
			
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir referansın adresi alındığında biz referansın kendi adresini almış olmayız. Zaten referansın adresini almanın bir yolu da yoktur. Biz referansın adresini 
	aldığımızda referansın refere ettiği nesnenin adresini almış oluruz. Örneğin:

	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		// a'nın adresi alınıyor

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int * const r = &a;
	int *pi;

	pi = &*r;		// a'nın adresi alınıyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		

	*pi = 20;

	cout << a << endl;		// 20
	cout << r << endl;		// 20
		
	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Konunun girişinde de belirttiğimiz gibi C++ standartlarında eğer derleyici bunun bir yolunu bulabilirse referans için hiç yer ayırmayabilir. Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Burada derleyici isterse hiç r referansı için bir yer ayırmadan doğrudan 20 değerini a'ya aatayabilir. Yani derleyici burada aşağıdakine eşdeğer bir kod 
	üretebilir:

	int a = 10;
	
	a = 20;

	Tabii derleyicilerin referanslar için bir yer ayırmayacağı durumlarda aslında referans kullanmanın gerekliliği yoktur. (inline fonksiyonlarda da derleyici buna 
	benzer optimizasyonlar yaoabilmektedir.) Dolayısıyla biz örneklerimizde referans için bir yer ayrıldığını varsayarak konuları ele alacağız.  
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir referans tanımlanabilir. const referanslar gösterdiği yer const olan const göstsericiler gibidir. Yani const bir referansın refere ettiği nesnenin
	değerini değiştiremeyiz. (Referansın kendi içerisindeki adresin referans tanımlandıktan sonra değiştirilemeyeceğini anımsayınız.) Örneğin:

	int a = 10;
	const int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	const int * const pi = &a;

	const bir referans ile o referansın refere ettiği nesneyi değiştiremeyiz. Örneğin:

	int a = 10;
	const int &r = a;

	r = 20;		// geçersiz! referans const
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'de (ve tabii C++'ta da) const bir nesnenin adresi gösterdiği yer const olmayan bir göstericiye atanamaz. Benzer durum C++'taki sol taraf 
	değeri referansları için de söz konusudur. Bir sol taraf değeri referansına aynı türden const bir nesneyi bind edemeyiz. Örneğin:

	const int a{10};
	int &r = a;				// geçersiz! 

	Buradaki sorun programcının nesneyi const yaptığı halde onun referns tarafından değiştirilmesine olanak tanımasıdır. const bir nesne ancak const bir sol taraf 
	değeri referansına bind edilebilir. Örneğin:

	const int a{10};
	const int &r = a;		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İlkdeğer verme (initialization) bir nesne yaratılır yaratılmaz ona değer yerleştirme işlemine denilmektedir. C'de ve C++'ta (ve diğer bazı dillerde) ilkdeğer 
	verme işlemi anlamına gelen üç temel durum vardır:

	1) Tanımlama sırasında '=' ile ya da "Uniform İnitilizer Syntax" ile ilkdeğer verme. Örneğin:

	int a = 10;
	int b{10};

	2) Anımsanacağı gibi fonksiyonların parametre değişkenleri fonksiyon çağrıldığında yaratılmakta ve fonksiyon sonlandığında yok edilmektedir. İşte parametreli 
	bir fonksiyonun çağrılması aslında parametre değişkenlerine argümanlarla ilkdeğer verme anlamına gelmektedir. Örneğin:

	void foo(int a)		// int a = 10 gibi düşünülmeli
	{
		// ....
	}

	foo(10);

	Burada aslında a parametre değişkenine 10 ile ilkdeğer verilmiştir.

	3) return işlemi sırasında bir geçici nesne yaratılıp return ifadesi o geçici nesneye ilkdeğer olarak verilmektedir. Yani return işlemi de aslında bir ilkdeğer
	verme işlemidir. Örneğin:
		

	int foo()
	{
		// ...

		return ifade;
	}
	
	//...
	
	x = foo() * 2;

	Aslında burada şu işlemler arka planda yapılmakatadır:

	1) int temp = return ifadesi;

	2) x = temp * 2;

	3) temp yok yok ediliyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonların parametre değişkenleri sol taraf referansı olabilir. Böyle fonksiyonlar referansla aynı türden bir sol taraf değeri ile (yani nesne
	belirten ifadeyle) çağrılmalıdır. Bu çağırma sırasında derleyici argümanda belirtilen nesnenin adresini alarak referansa yerleştirir. Artık fonksiyonda
	referansı kullandığımızda argümanda belirtilen nesneye erişmiş oluruz. Böylece "call by reference" işlemi C++'ta referanslarla da sağlanmış olmaktadır. Örneğin:

	void foo(int &r)
	{
		r = 20;
	}
	
	//...
	
	int a = 10;
	foo(a);

	Burada aslında fonksiyon çağrıldığında r referansına a'nın adresi yerleştirilmektedir. Fonksiyonda r'yi kullandığımızda aslında r'nin refere ettiği nesne 
	olan a'yı kullanmış oluruz. BYukarıdkai kodun eşdeğer gösterici karşılığı şöyle olacaktır:

	void foo(int * const r)
	{
		*r = 20;
	}

	//...

	int a = 10;
	foo(&a);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r);

int main()
{
	int a = 10;

	foo(a);

	cout << a << endl;			// 20
			
	return 0;
}

void foo(int &r)			// int &r = a
{
	cout << r << endl;			// 10

	r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin göstericilerle oluşturulmuş eşdeğer gösterici karşılığı aşağıdaki gibidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int * const r);

int main()
{
	int a = 10;

	foo(&a);
	cout << a << endl;
			
	return 0;
}

void foo(int * const r)		// int * const r = &a
{
	cout << *r << endl;
	*r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İki int nesne içerisindeki değerleri yer değiştiren swap isimli fonksiyonu C'de göstericileri kullanarak yazmıştık. C++'ta aynı fonksiyonu referansları 
	kullanarak da yazabiliriz. Örneğin:

	void swap(int &a, int &b)
	{
		int temp = a;
		a = b;
		b = temp;
	}

	//...

	int x = 10, y = 20;

	swap(x, y);
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int x = 10, y = 20;

    cout << "x = " << x << ", y = " << y << endl;

    swap(x, y);

    cout << "x = " << x << ", y = " << y << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta sol taraf değeri referanslarının göstericilerden en önemli farkı şudur: Bir sol taraf değeri referansına aynı türden bir nesne ile ilkdeğer verdiğimizde 
	artık derleyici o nesnenin adresini referansa yerleştirir. Böylece referans o nesnesyi gösterir hale gelir. O referansın başka bir nesneyi göstermesi mümkün 
	değildir. Halbuki göstericilere farklı nesnelerin adreslerini atayarak onların farklı nesneleri göstermesini sağlayabiliriz. Böylece refeanslar daha güvenli 
	bir gösterici olarak kullanılabilmektedir. 

	Bir referansın * ya da [...] operatörleriyle kullanılamayacağına dikkat ediniz. p bir gösterici olmak üzere biz p göstericisinin gösterdiği yerden n ileriye
	p[n] ifadesi ile erişebiliriz. Ancak r bir referans ise böyle bir kullanım geçerli değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta C'de olduğu gibi göstericiyi gösteren gösterici (pointer to pointer) söz konusu olabilir. Ancak referansı refere eden referans olamaz. Tabii bunun 
	olamamasının en açık nedeni aslında referansın kendi adresinin alınamamasıdır. Örneğin:

	int a = 10;
	int &r = a;
	int &k = r;

	Burada biz k referansına r referansının adresini yerleştirmiş olmamaktayız. a nesnesinin adresini yerleştirmiş olmaktayız. Çünkü bir referans ilkdeğer 
	verildikten sonra kullanıldığında artık refere ettiği nesne anlamına gelmektedir. Yukarıdaki kodun eşdeğer gösterici karşılıği şöyledir:

	int a = 10;
	int * const r = &a;
	int * const k = &*r;

	C++'a C++11 ile birlikte eklenen "sağ taraf değeri referansları (rvalue reference)" C++'a yeni başlayan C programcıları tarafından sanki "referansın referansı"
	sanılmaktadır. Oysa sağ taraf değeri referansının bununla hiçbir ilgisi yoktur. Örneğin:

	int &&r = 10;		// bu tamamen başka bir anlama gelmektedir. 

	Bu bildirim tamamen başka bir anlama gelmektedir. İzleyen paragraflarda sağ taraf değeri referansları ele alınacaktır. 

	C++'ta referans dizileri diye de bir kavram yoktur. Örneğin:

	int &r[3] = {a, b, c};		// böyle bir kavram yok! dolayısıyla derleme zamanında error oluşacaktır.

	Ancak tabii göstericileri refere eden referanslar oluşturulabilir. Örneğin:

	int *pi;
	int *&r = pi;

	Burada r referansı int * türünden bir referanstır. Yani bir r referansını kullandığınımızda aslında pi göstericisini kullanmış oluruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int a{10};
    int *pi{&a};

    int *&r = pi;       // geçerli

    cout << *r << endl;     // 10

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'de yapıları genel olarak adres yoluyla fonksiyonlara aktarıyorduk. Bu durumda fonksiyonun parametre değişkeni bir gösteri oluyordu. 
	Biz de fonksiyonu aynı türden bir yapı nesnesinin adresiyle çağırıyorduk. Fonksiyon içerisinde yapı elemanlarına bu gösterici yoluyla -> operatörünü 
	kullnarak erişiyorduk. İşte C++'ta bir yapıyı referans yoluyla da fonksiyona aktaranbiliriz. Bu durumda yapının elemanlarına referans yoluyla erişirken 
	ok operatörü değil nokta operatörü	kullanılmaktadır. Örneğin:

	struct DATE {
		int day;
		int month;
		int year;
	};
	//...

	void disp_date(const struct DATE &r)
	{
		cout << r.day << '/' << r.month << '/' << r.year << endl;
	}
	//...

	struct Date date = {6, 9, 2023};

	disp_date(date);

	Bir referansı ilkdeğer verdikten sonra kullandığımızda artık referansın refere ettiği nesneyi kullanmış olmaktayız. Yani biz bu örnekte disp_date içerisinde 
	r referansını kullandığımızda aslında bütünsel olarak date nesnesini kullanmış gibi oluruz. Bir yapı nesnenin bütünü kullnarak elemanlarına erişmek için 
	nokta operatörünün kullanıldığına dikkat ediniz. 

	Bir yapı nesnesinin C++'ta fonksiyona gösterici yoluyla aktarılmasıyla referans yoluyla aktarılması arasında hiçbir etkinlik farklılık yoktur. İkisi de aynı 
	derecede etkindir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const DATE &r)
{
	cout << r.day << '/' << r.month << '/' << r.year << endl;
}

int main()
{
	struct DATE d = { 10, 12, 2001 };

	disp_date(d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşdeğer gösterici kaşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const struct DATE * const r)
{
	cout << (*r).day << '/' << (*r).month << '/' << (*r).year << endl;
}

int main()
{
	struct DATE d = {10, 12, 2001};

	disp_date(&d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun geri dönüş değeri bir sol taraf değeri türünden referans olabilir. Bu durumda return ifadesinin aynı türden bir nesne belirten bir ifade olması gerekir. 
	Biz böyle fonksiyonları çağırdığımızda elde ettiğimiz ifade return ifadesindeki nesne haline gelmektedir. Örneğin:

	int g_a = 10;

	int &foo()		// int &temp =g_ a
	{
		return g_a;
	}
	//...

	foo() = 20;		// temp = 20

	Burada aartık fonksiyon çağrısı bir sol taraf değeri belirtmektedir. Görüldüğü gibi C'de fonksiyon çağrıları her zaman sağ taraf değeri belirtir. AncakC++'ta
	fonksiyonun geri dönüş değeri sol taraf değeri referansı ise artık fonksiyon çağrısı sol taraf değeri belirtir. Fonksiyon çağrısına bir değer atadığımızda aslında biz
	return ifadesindeki nesneye değer atamış oluruz. Tabii nasıl bir fonksiyon yerel bir nesnenin adresi ile geri dönmemeli ise benzer biçimde aynı durum referanslar
	için de geçerlidir. Yani fonksiyonun geri dönüş değeri bir referans ise biz return ifadesinde yerel bir nense kullanmamalıyız (fonksiyon bittiğinde yerel nesnelerin 
	stack'ten boşaltıldığını anımsayınız.) Örneğin:

	int &foo()
	{
		int x = 10;

		return x;				// geçerli ama tanımsız davranış oluşturur
	}
	//...

	foo() = 20;					// dikkat! değer artık olmayan bir nesneye atanmaya çalışılıyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int g_a = 10;

int &foo()			
{
	//...

	return g_a;		// int &temp = g_a
}

int main()
{
	foo() = 20;

	cout << g_a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşedeğer gösterici karşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int g_a = 10;

int *foo()			
{
	//...

	return &g_a;		
}

int main()
{
	*foo() = 20;

	cout << g_a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta "geçici nesne (temporary object)" denildiğinde "derleyicinin kendisi tarafından yaratılan ve yok edilen isimsiz nesneler" anlaşılmaktadır. Örneğin 
	fonksiyonun geri dönüş değerinin oluşturulması bir geçici nesne yolyla yapılmaktadır. İşte C++'ta bazı durumlarda derleyici geçici nesneler yaratılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir sol taraf değeri referansını biz bir sağ taraf değeri ile ilkdeğer vererek tanımlayabiliriz. Bu durumda referansın const olması gerektiğine dikkat ediniz. Örneğin:

	int &r = 10;			// geçersiz! referans const değil
	const int &k = 10;		// geçerli, referans const

	Tabii bu durumda ilkdeğer olarak verilen sağ taraf değerinin referansla aynı türden olması da gerekmez. Örneğin:

	const int &r = 3.14;		// geçerli

	const bir referansa sağ taraf değeri bind edildiğinde derleyici önce referans türüyle aynı türden geçici bir nesne yaratır. Sonra sağ taraf değerini bu geçici nesneye
	yerleştirir. Sonra da bu geçici nesnenin adresini referansa yerleştirir. Örneğin:

	const int &r = 10;

	Burada aslında şu işlemler yapılmaktadır:

	int temp = 10;
	const int &r = temp;

	Burada geçici nesnenin referans türünden olduğuna dikkat ediniz. Örneğin:

	const int &r = 3.14;

	Bu kodun eşdeğeri de şöyledir:

	int temp = 3.14;		// dikkat bilgi kaybı oluşacak ama geçerli
	const int &r = temp;

	Burada artık r referansının gösterdiği int nesnede 3.14 değeri değil 3 değeri olacaktır. 

	Bu örneklerde r referansının artık derleyici tarafından yaratılmış geçici nesneleri gösterdiğine dikkat ediniz. Referans const olduğu için o nesneler üzerinde 
	değişklik yapamayacağız.

	C++ standartlarına göre bu biçimde yaratılmış olan geçici nesneler referansın ömrü boyunca yaşamaya devam eder. Referans yaşamını kaybederken bu geçici nesne 
	de derleyici tarafından yok edilecektir. Bu geçici nesnenin yok edilmesi ile programcının uğraşmadığına dikkat ediniz. 

	Bu biçimde const bir sol taraf değeri referansına sağ taraf değeri ile ilkdeğer verilirken eğer Uniform İnitializer Syntax kullanılıyorsa ya da küme parantezi 
	sentaksı kullanılıyorsa bu durumda daraltıcı dönüştürmelere izin verilmemektedir. Örneğin:

	const int &r {3.14};		// geçersiz! double -> int dönüştürmesi daraltıcı bir dönüştürme
	const int &k = {3.14};		// C++11'den sonra geçersiz! double -> int dönüştürmesi daraltıcı bir dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	const int &r = 10;

	cout << r << endl;		// geçici nesne kullanılıyor		

	r = 20;					// error! Referans const

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sol taraf değeri referansına bir sol taraf değeri ile ilkdeğer verildiğinde derleyicinin tipik olarak bu ilkdeğer olarak verilen nesnenin adresini 
	referansa yerleştirdiğini söylemiştik. Bu durumda bir sol taraf değeri referansına bir dizi ile ilkdeğer verdiğimizde derleyici dizinin adresini referansa 
	,yerleştiecektir. Anımsanacağı gibi C'de bir dizinin adresi alınırsa bu adres "dizi göstericisi (pointer to array)" bir göstericiye yerleştirilebilir. İşte 
	buradan hareketle C++'ta eğer biz sol taraf değeri referansına bir diziyi bind edersek referansın da "dizi referansı (reference to array)" olması gerekmektedir. 
	Örneğin:

	int a[10];
	int &r = a;					// geçersiz!
	int (&r)[10] = a;			// geçerli

	Burada artık r referansını kullandığımızda tamamen a dizisini kullanmış gibi olmaktayız. Yukarıdaki işlemin eşdeğer gösterici karşılığı şöyledir:

	int a[10];
	int (*r)[10] = &a;

	Konunun daha iyi anlaşılması için C'de "dizi göstericileri (pointer to array)" kavramının biliniyor olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														8. Ders 11/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bir sol taraf değeri referansını farklı türden bir nesneyle ilkdeğer vererek tanımlayamayız. Örneğin:

	double a = 10.2;
	int &r = &a;		// geçersiz!

	Ancak sol taraf değeri referansı const ise bu mümkündür. Bu durumda yine derleyici ilkdeğer olarak verilen nesneyi referansla aynı türden bir geçici nesnenin 
	içine yerleştirir, bu geçici nesneyi referansa bind eder. Örneğin:

	double a = 10.2;
	const int &r = a;

	Bu işlemin eşdeğeri şöyledir:

	double a = 10.2;
	int temp = a;
	const int &r = temp;

	Tabii eğer ilkdeğer verme yine "uniform initializer" sektasıyla ya da küme parantezi sentaksıyla yapılıyorsa bilgi kaybına yol açabilen daraltıcı dönüştürmelere 
	izin verilmemektedir. Örneğin:

	double a = 10.4;
	const int &r{a};		// geçersiz!
	cont int &k = {a};		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ve sonrasında dil hepten karmaşık hale geldiği için daha önce kullanılmayan bazı terimler de uydurulmuştur. Örneğin bir prvalue ifadesinin bu tür 
	durumlarda bir geçici nesneye dönüştürülmesine "temporary materializaition" denilmektedir. 

	Biz kursumuzda yukarıda "sol taraf değeri (lvalue)" ve "sağ taraf değeri (rvalue)" terimlerini C++11 ve sonrasındaki "value category" tanımına göre kullanıyoruz.
	Örneğin "const bir referansa bir sağ değeri ile ilkdeğer verilebilir" derken bu sağ taraf değeri "prvalue" ya da "xvalue" anlamına gelmektedir. Ancak "bir sol 
	değeri referansına bir aynı türden bir sol taraf değeri ile ilk değer verilebilir" derken buradaki "sol taraf değeri" gvalue olmayan sol taraf değeri anlamına 
	gelmektedir. C++11 ile birlikte eklenen "value category" terimlerini aşağıda yeniden vermek istiyoruz:

	   glvalue     rvalue
		/  \	   /  \
	   /    \     /    \
	lvalue   xvalue    prvalue
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi C++11 ile birlikte ismine "sağ taraf değeri referansları (rvalue references)" denilen başka bir referans türü daha dile eklenmiştir. 
	Böylece eski referansların da isimleri "sol taraf değeri referansları (lavlue references)" biçiminde değiştirilmiştir. Sağ taraf değeri referansları dekleratörde 
	&& atomlarıyle belirtilir. (Burada && atomları referansın referansı gibi bir anlama gelmemektedir. Zaten refereransın adresi alınamamaktadır.)

	Bir sağ taraf değeri referansı bir sağ taraf değeri ile (yani nesne belirtmeyen bir ifade ile) ilkdeğer verilerek tanımlanır. Biz nasıl bir (const olmayan) sol 
	taraf değeri referansına bir sağ taraf değerine ilişkin ifadeyi bind edemiyorsak bir sağ taraf değeri referansına da bir sol taraf değerine ilişkin ifadeyi 
	bind edemeyiz. Örneğin:
	
	Örneğin:

	int a = 10;
	int &&r = a;		// geçersiz! a bir sağ taraf değeri değil
	int &&r = 10;		// geçerli, a bir sağ taraf değeri

	Örneğin:
	
	int a = 10, b = 20;
	int &&r = a + b;			// geçerli, a + b sağ taraf değeri belirtiyor

	Tabii normak olan durum bir sağ taraf değeri referansına aynı türden bir sağ taraf değeri ile ilkdeğer vermektir. Ancak bir sağ taraf değeri referansı 
	farklı bir sağ taraf değeri türü ile de ilkdeğer verilerek tanımlanabilir. Örneğin:

	int &&r = 3.14;			// tuhaf ama geçerli
	long a = 10, b = 20;
	int &&k = a + b;		a+ b long türden ama geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sağ taraf değeri referansına bir sağ taraf değeri ile ilkdeğer verdiğimizde derleyici o sağ taraf değerini referansla aynı türden bir geçici nesnenin
	içerisine yerleştirir ve referansa o geçici nesnenin adresini atar. Örneğin:

	int &&r = 10;

	Bu işlemin eşdeğeri şöyledir:

	int temp = 10;
	int &&r = temp'in adresi

	Pekiyi aynı işlemi zaten const olan sol taraf değeri referansı ile de yapabiliyorduk. O halde değişen ne var? Buradaki tek fark sağ taraf değeri referansının 
	const olmaması ve dolayısıyla o geçici nesneyi değiştirebilmesidir. Bu biçimde bir prvalue ifadesi için geçici nesne yaratılmasına C++17'de "temporary materialization"
	dendiğini anımsayınız.

	Yine bir sağ taraf değeri referansını kullandığımızda referansın refere ettiği nesneyi kullanmış oluruz. Yani kullanım bakımından sağ taraf değeri referansının 
	sol taraf değeri referansından bir farkı yoktur. Örneğin:

	int &&r = 10;

	r = 20;						// geçerli, geçici nesne değiştiriliyor

	const int &k = 10;

	k = 20;						// geçersiz! referans const

	Sağ taraf değeri referansları kullanıldıklarında artık sol taraf değeri belirtirler. Örneğin:

	int &&r = 10;
	int &k = r;			// geçerli
	int &&m = r;		// geçersiz!
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int &&r = 10;
	
	cout << r << endl;		// 10

	r = 20;					// geçerli

	cout << r << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sağ taraf değeri referansına biz farklı türden bir sol taraf değeri ile de ilkdeğer verebiliriz. Bu durumda yine farklı türden sol taraf değeri referans 
	ile aynı türden derleyici tarafındna yaratılan geçici nesneye yerleştirilir ve geçici nesnenin adresi referansa atanır. Örneğin:

	double d = 3.14;
	int &&r = d;			// geçerli!

	Bu işlemin eşdeğeri şöyledir:

	double d = 3.14;
	int temp = d;
	int &&r = temp'in adresi

	Tabii burada biz referansa yoluyla referansın refere ettiği yeri deştirdiğimizde d'yi değiştirmiş olmayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	double d = 3.14;
	int &&r = d;

	cout << r << endl;		// 3

	r = 10;

	cout << d << endl;		// 3.14
	cout << r << endl;		// 10

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi sağ taraf değeri referansı da const olabilir mi? Tabii sağ taraf değeri referansları da const olabilir. Ancak sağ taraf değeri referanslarının dile
	eklenmesinin asıl nedeni zaten sağ taraf değerini güncelleyebilmesidir. Yani const bir sağ taraf değeri referansının anlamlı bir kullanımı yoktur. const bir 
	sağ taraf değeri referası zaten const bir sol taraf değeri referansıyla benzer işleve sahiptir. Özetle sağ taraf değeri referansları const olabilse de bunun 
	aslında anlamı yoktur. Örneğin:

	const int &&r = 10;		// geçerli

	r = 20;					// geçersiz! r const
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yine eğer sağ taraf değeri referansına ilkdeğer verme işlemi Uniform Initializer Syntax ile ya d aküme parantezleri kullanılarak yapılıyorsa daraltıcı 
	dönüştürmelere izin verilmemektedir. Örneğin:

	int &&r{3.14};			// geçersiz! double -> int dönüştürmesi daraltıcı dönüştürme
	int &&k = {3.14};		// geçersiz! geçersiz! double -> int dönüştürmesi daraltıcı dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun parametre değişkeni sağ taraf değeri referansı olabilir. Bu durumda fonksiyon bir sağ taraf değeri argüman yapılarak ya da farklı türden 
	sol taraf değeri ile çağrılmak zorundadır. Örneğin:

	void foo(int &&r)
	{
		cout << r << endl;
	}

	//...

	int a = 10, b = 20;

	foo(10);			// geçerli
	foo(a + b);			// geçerli

	foo(a);				// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &&r)
{
	cout << r << endl;
}

int main()
{
	int a = 10, b = 20;

	foo(10);			// geçerli
	foo(a + b);			// geçerli

	foo(a);				// geçersiz!
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun geri dönüş değeri sağ taraf taraf değeri referansı olabilir. Böyle fonksiyonlar çağrıldığında "xvalue" belirtirler. Bu konu ileride 
	ele alınacaktır. Ancak bu tür durumlarda yaratılacak geçici nesne fonksiyonun yerel değişkeni biçiminde yaratılır. Dolayısıyla aşağıdaki gibi 
	bir tanımlama "tanımsız davranışa (undefined behavior)" yol açmaktadır:

	int &&foo()
	{
		return 10;		// dikkat temporary yerel bir nesne olarak yaratılacak
	}

	Bu tanımlamanın eşdeğeri şöyledir:

	int &&foo()
	{
		int temp = 10;

		return temp'in adresi;
	}

	Görüldüğü gibi fonksiyondan çıkıldığında bu geçici nesne yok edilecektir. Böyleci geçici nesnelerin fonksiyon içerisinde onun stack'inde yaratıldığına
	dikkat ediniz. 

	Yukarıda da belirttiğimiz gibi geri dönüş değeri sağ taraf değeri referansı olan fonksionların çağrı ifadeleri "xvalue" belirtmektedir. "xvalue" bir "glavlue"
	olmasına karşın "lvalue" değildir. Dolayısıyla bir "xvalue" sol atarf değeri referansına bind edilemez. Örneğin:
	
	int &r = foo();		// geçersiz! xvalue bir lvalue değildir. 

	Ancak "xvalue" bir "rvalue" olduğuna göre sağ taraf değeri referansına bind edilebilir. Örneğin:

	int &&r = foo();		// geçerli

	Pekiyi bu durumda fonksiyonun geri dönüş değerinin sağ taraf değeri referansı olmasının ne anlamı vardır? İşte aslında ilerideki konularda da görüleceği gibi 
	bir sol tafa değeri "sanki bir sağ taraf değeri imiş gibi" geri döndürülmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int &&foo()
{
	return 10;		// geçerli ama tanımsız davranışa yol açar
}

int main()
{
	const int &r = foo();

	cout << r << endl;		// tanımsız davranış!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri sağ taraf değeri referansı olan fonksiyonların return ifadelerindeki sağ taraf değeri için yaratılacak yerel değişkeninin o fonksiyonun  
	yerel değişkeni gibi olması böyle bir fonksiyonun anlamsız olduğunu akla getirmektedir. Ancak aslında bu tür fonksiyonlar belli bir amaç doğrultusunda 
	kullanılabilmektedir. Bu tür fonks,yonların kullanımına ilşkin anlamlı örneklerle ilerideki konularda karşılaşacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	19) C++'ta dinamik bellek yönetimi için new ve delete isimli iki operatör eklenmiştir. Tabii C++ C'nin standrat kütüphanesini de kapsadığı için biz C++'ta
	C'de kullandığımız malloc, calloc, realloc ve free fonksiyonlarını da kullanbiliriz. Ancak C++'ta dinamik bellek tahsisatı için C++'a özgü new ve delete
	operatörlerinin kullanılması iyi bir tekniktir. 
	
	new operatörü iki biçimde kullanılabilir:

	1) new <tür>
	2) new <tür><[uzunluk ifadesi]>

	Birinci biçimde heap'te ilgili türden tek bir elemanlık yer tahsis edilir. İkinci biçimde ilgili türden belirtilen uzunlukta yer tahsis edilir. new
	operatörü tahsis edilen alanın başlangı adresini ilgi türden bize verir. Örneğin:

	int *pi;
	char *pc;

	pi = new int;
	pc = new char[10];

	Burada birinci satırda heap'te bir int uzunluğunda bir alan tahsis edilip onun başlangıç adresi pi göstericisine atanmıştır. İkinci satırda ise heap'te char 
	türden 10 elemanlı bir dizi tahsis edilmiş dizinin başlangıç adresi pc göstericisine atanmıştır. 

	new operatörü ilgili tür türünden bir adres vermektedir. (malloc, calloc ve realloc fonksiyonlarının void adres verdiğini anımsayınız.) Örneğin:

	int *pi;

	pi = new char[10];		// geçersiz! char türden adres int türden göstericiye atanmış!
	
	new operatörü ile tahsis etmiş olduğumuz alan içerisinde çöp değerler vardır. new operatörü normal kullanımda başarıszlık durumunda "bad_alloc" isimli bir 
	exception fırlatmaktadır. Dolayısıyla programcı tahsisatın başarıını NULL gösteri ile kontrol etmez. Böyle bir kontrol yapmayınız. 

	Exception sözcüğü programın çalışma zamanı sırasında oluşan problemli durumları anlatmaktadır. C++'ta bir exception oluştuğunda programcı oluşan excception'ı 
	ele alabilir (handle edebilir) bu durumda çalışma normal bir biçimde başka yerden devam eder. Ancak programcı oluşan exception'ı ele almazsa program çökmektedir. 
	C++'ta exception ayrıntıları olan geniş bir konudur. Biz de ilerideki bçlümlerde bu konuyu ayrı başlık altında ele alacağız. 

	new her ne kadar bir operatörse de aslında tahsisat işlemi yine programın akışı new yapılan yere geldiğinde çalışma azamanı yapılmaktadır. new operatörü 
	"operator new" denilen bir tahsisat fonksiyonunu çağırarak athsisatını yapmaktadır. new operatörünün bir operatör olmasının nedeni sınıflar konusuyla ilgilidir. 
	new operatörüyle bir sınıf türünden tahsisat yapıldığında new operatörü tahsisat yapıldıktan sonra sınıfın "yapısı fonksiyonunun (constructor)" çağrılmasına da
	yol açmaktadır. 

	T bir tür belirtmek üzere new operatörü ile bir elemanlık yer tahsisatını iki biçimde yapabiliriz:

	new T
	new T[1]

	Bu iki new ifadesi de bir elemanlık yer tahsis ediyor olsa da bu iki ifadenin arasında semantik bazı farklılıklar vardır. izleyen paragraflarda bu durum ele 
	alınacaktır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = new int[10];

	for (int i = 0; i < 10; ++i)
		pi[i] = i * i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << ' ';
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														9. Ders 13/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ile yapılan dinamik tahsisatlar delete operatörü ile serbest bırakılır. delete operatörünün de iki sentaktik biçimi vardır:

	1) delete <adres>
	2) delete [] <adres>

	Eğer new ile köşeli parantezsiz tahsisat yapılmışsa bunun boşaltımı köşeli parantezsiz delete yapılmalıdır. Eğer new ile köşeli parantezli bir tahsisat 
	yapılmışsa bunun bhoşaltımı da köşeli parantezli delete ile yapılamlıdır.  Örneğin:

	int *pi;
	char *pc;
	//...

	pi = new int;
	pc = new char[32];

	//...

	delete[] pc;
	delete pi;
	
	Tahisa edilen 1 elemanlık bile olsa eğer tahsisat new operatörünün köşeli parantezli biçimi ile yapılmışsa alanı serbest bırakmak için delete operatörünün 
	yine köşeki panatezli biçimi ile yapılmalıdır. Örneğin:

	int *pi = new int[1];
	//...
	delete[] pi;

	new operatörü ile tahsis edilen alan delete operatörü ile boşaltılmazsa Windows, macOS, Linux gibi yaygın işletim sistemlerinin hepsinde program bittiğinde 
	bu alanlar otomatik olarak boşaltılmaktadır. Çünkü işletim sistemlerinde genel oalrak "heap alanı prosese özgüdür". Yani her prosesin heap alanı diğerlerinden 
	farklıdır. Yani bir programda yapılan dinamik tahsisatın diğer çalışmakta olan programlara hiçbir etkisi yoktur. Ancak heap alanının prosese özgü olduğu 
	C ve C++ standartlarında garanti edilmemiştir. (Yani başka işletim sistemlerinde heap alanı prosese özgü olmayabilit.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = new int[1];

	delete [] pi;			// doğru

	pi = new int[10];

	delete[] pi;			// doğru

	pi = new int;			
	delete pi;				// doğru

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii tıpkı malloc fonksiyonunda olduğu gibi new operatörü ile tahsisat yapılırken de uzunluğun sabit ifadesi ile belirtilmesi gerekmez. Örneğin:

	char *pc;
	int size;
	//...

	cin >> size;
	pc = new char[size];
	//...
	delete[] pc;
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte new ile tahsis edilen alana küme paramtezleriyle ilkdeğer verilebilmektedir. Örneğin:

	pi = new int[3] {10, 20,30};

	Tabii tahsis edilen dizideki az sayıda elemana bu biçimde ilkdeğer verilebilir. Bu durumda geri kalan elemanların hepsi sıfırlanmaktadır. Örneğin:

	pi = new int[10] {1};		// geri kalanelemanlar 0

	Küme parantezinin içi boş da bırakılabilir. Bu durumda da tüm elemanlar sıfırlanır. Örneğin:

	pi = new int[10] {};	// tüme elemanlar sıfırlanır

	İlkdeğer verilirken köşeli parantezlerin içi boş bırakılabilir. Bu durumda derleyici verilen ilkdeğerleri sayar ve dinamik dizinin o kadar elemandan 
	oluştuğnu kabul eder. Örneğin:

	pi = new int[] {10, 30, 40};		// 3 elemanlık tahsisat yapılıyor

	İlkdeğer verme sentaksında köşeli parantezlerin içerisinin sabit ifadesi olması gerekmemektedir. (Bazı dillerde benzer sentakslarda sabit ifadesi zorunluğu
	vardır.) Ancak bu durumda tahsisat uzunluğundan fazla ilkdeğer verilirse "tanımsız davranış" oluşmaktadır. Örneğin:

	int size;
	
	cout << "size:";
	cin >> size;

	int *pi = new int[size] {1, 2, 3, 4, 5};

	Burada size değeri 5'ten küçükse tanımsız davranış oluşacaktır. size değeri 5'ten büyükse tahsis edilen alandaki diğer değerler sıfırlanacaktır.

	Tabii C++11 ve sonrasında bütün küme parantezi sentakslarında "daraltıcı dönüştüre (narrowing conversion)" yasaklanmıştır. Örneğin:

	int *pi = new int[] = {1, 2, 3.14};		// geçersiz! double -> int dönüştürmesi daaraltıcı dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = new int[3]{ 10, 20, 30 };		// C++11 ile birlikte

	for (int i = 0; i < 3; ++i)
		cout << pi[i] << endl;

	delete [] pi;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new operatörü ile biz bir gösterici dizisi de tahsis edebiliriz. Tabii bu durumda tahsis edilen gösterici dizisinin adresinin göstericiyi gösteren göstericye 
	atanması gerekir. Örneğin:

	int a = 10, b = 20, c = 30;
	int **ppi;

	ppi = new int *[] {&a, &b, &c};
	//...
	delete[] ppi;

	Burada tahsisatın new int * biçiminde yapıldığına dikkat ediniz. Tabii boşaltım yine delete operatörünün köşeli parantezli versiyonu ile yapılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	const char **names;

	names = new const char *[] {"ali", "veli", "selami", NULL};

	for (int i = 0; names[i] != NULL; ++i)
		cout << names[i] << endl;

	delete[] names;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new operatörü ile çok boyutlu diziler için tahsisatlar yapabiliriz. Ancak çok boyutlu dizilerin başlangıç adreslerinin yerleştirileceği göstericilerin 
	dizi göstericileri türünden olması gerekir. Örneğin:

	int *pi;

	pi = new int[3][4];		// geçersiz! tür uyuşmazlığı var!

	new int[3][4] bir tahsisatın adresinin atanacağı göstericisinin int (*)[4] türünden olması gerekmektedir. Örneğin:

	
	int (*pa)[4];
	pa = new int[3][4];		// geçerli
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int (*pa)[4];

	pa = new int[3][4]{{1, 2, 3, 4}, {5, 6, 7, 8}, {0, 1, 2, 3}};

	for (int i = 0; i < 3; ++i) {
		for (int k = 0; k < 4; ++k)
			cout << pa[i][k] << " ";
		cout << endl;
	}

	delete[] pa;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ C'nin standart kütüphanesini de desteklediğine göre biz C++ programları içerisinde C'nin malloc, calloc, realloc ve free fonksiyonlarını kullanabiliriz. 
	Ancak bir C++ programı içerisinde hem "new ve delete" hem de "malloc, calloc, realloc ve free" fonksiyonları birlikte kullanılmamalıdır. Tahsisat işlemleri 
	için tahsisat algoritmaları kullanılmaktadır. İşte C++'ın new ve delete operatörlerinin kullandığı tahsisat algaoritması ile C'nin dinamik bellek fonksiyonlarının 
	kullandığı tahsisat algoritması farklı olabilmektedir. Bunun sonucu olarak da C++'ın new operatörü ile tahsis edilmiş olan bir alan C'nin tahsisat 
	fonksiyonları tarafından tahsis edilmemiş olarak gözükebilmektedir. Tabii tersi de söz konusu olabilmektedir. Bazı C++ derleyicilerinde new işlemi sıreasında
	çağrılan operator new fonksiyonu kendi içerisinde malloc fonksiyonu ile tahsisatı yapıyor olabilir. Benzer biçimde delete işlemi ile tahsis edilen alan serbest 
	bırakılırken operator delete fonksiyonu free fonksiyonu ile bunu yapıyor olabilir. Bu sistemlerde vu iki dilin tahsisat mekanizmasının birlikte kullanılması 
	soruna yol açmayabilir. Ancak C++ standartları bunun garantisi vermemiştir. Bu nedenle aynı programda bu iki grup tahsisat sistemini birlikte kullanmak 
	sorunlara yol açabilmektedir. 
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new ve delete operatörlerine ilişkin bazı ayrıntılar vardır. Örneğin bu operatörlerin "placement" versiyonları bulunmaktadır. Biz bu placement versiyonlar 
	sayesinde örneğin new operatörünün bellek tahsisatı yapılamadığı durumda bad_alloc ile exception fırlatmak yerine NULL adres ile geri dönmesini sağlayabiliriz. 
	Bu operatörlerin "placement" versiyonları "operatör fonksiyonları" konusunda ele alınacaktır.
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	20) C++'ta C'nin tüm standart fonksiyonları kullanılabilir. Ancak bu konuda birkaç ayrıntı vardır. Birincisi C++'ta C'nin başlık dosyalarının ismi değiştirilmiştir. 
	C'nin standart bir başlık dosyası <x.h> olmak üzere bunun C++'taki ismi <cx> biçimindedir. Uzantının olmadığına ve başlık dosyalarının başına 'c' harfi getirildiğine 
	dikkat ediniz. İkinci farklılık standart C fonksiyonlarının std isim alanına taşınmış olmasıdır. 

	Biz henüz isiö alanları (name space) konusunu görmedik. Ancak C++'ın tüm kütüphanesindeki isimler std isim alanında ya da o isim alanın içerisindeki bir isim alanında
	bulunmaktadır. Bir isim alanındaki bir ismi kullanmak için <isim_alanı_ismi>::<isim> sentaksı kullanılmaktadır. Burada :: operatörüne "çözünürlük operatörü (scope 
	resolution operator)" denilmektedir. Biz örnek programlarımızda bu çözünürlük operatörünü kullanmamak için programın yukarısına aşağıdaki direktifi yerleştirdik:
	
	using namespace std;
	
	Bu direktif bizim std isim alanındaki isimleri çözünürlük operatörü olmadan doğrudan kullanmamızı sağlamaktadır. Eğer bu operatör olmasaydı cout gibi endl gibi 
	isimleri çözünürlük operatörü ile kullanmak zorunda kalırdık. Örneğin:

	std::cout << "test" << std::endl;

	İsim alanları konusu ayrıntıları olan ayrı bir konudur. Kursumuzun ilerleyen bölümlerinde bu konu zaten ele alınacaktır. 

	C++'ta <cx> biçiminde belirttiğimiz başlık dosyalarındaki isimlerin aynı zamanda global isim alanında bulunup bulunmayacağı derleycicileri yazanların isteğine 
	bırakılmıştır. Ancak C++'ta biz <x.h> biçimindeki başlık dosyalarını da C'de olduğu gibi include edebiliriz. Bu başlık dosyalarındaki isimler bu durumda
	global isim alanına yerleştirilmiş olmak zorundadır. Fakat <x.h> dosyalarının aynı zamanda std isim alanına da yerleştirilip yerleştirilmeyeceği derleyicileri 
	yazanların isteğine bırakılmıştır. Ancak C++'ta C'nin başlık dosyalarının <x.h> biçiminde include edilmesi kötü bir tekniktir. Biz kurusumuzda C'nin başlık 
	dosyalarını <cx> biçimind include edeceğiz ve oradaki isimlerin std isim alanında olduğunu varsayacağız. 

	Her ne kadar C++ C'nin standart fonksiyonlarını destekliyorsa da ayrıca C++'ın kendine özgü "template" tabanlı bir standart kütüphanesi de vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>

using namespace std;

int main()
{
	printf("This is a test\n");		// printf std isim alanının içeisinde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    21) C++'ta makrolara benzer ismine "inline fonksiyon" denilen fonksiyonlar da bulunmaktadır. Aslında inline fonksiyon kavramı C'de de çok uzun süredir çeşitli 
	derleyicilerde birier eklenti (extension) biçiminde bulunuyordu. Ancak inline fonksiyonlar C ailesine ilk kez C++'ta resmi olarak eklenmiştir. C++'tan sonra 
	inline fonksiyonlar C99 ile birlikte C'ye de sokulmuştur. Ancak C++'ın inline fonksiyonlarıyla C99'un inline fonksiyonları arasında semantik farklılıklar vardır. 
	Ayrıca C99 ile C'ye eklenmden önce derleycilerin eklenti biçiminde bulundurduğu inline fonksiyon semantiklerinde de farklılıklar bulunmaktadır. Tabii biz burada
	C++'taki inline fonksiyonları ele alacağız. 

	Bir fonksiyon "inline" belirleyici (function specifier) kullanılarak inline yapılabilir. Örneğin:
	
	inline void foo()
	{
		//...
	}

	inline bir fonksiyon çağrıldığında derleyici fonksiyon çağrısı yerine inline fonksiyonun iç kodunu çağrılan yere enjekte edebilmektedir. Böylece fonksiyon
	çağrısının bazı maliyetleri (function call overhead) ortadan kaldırılmış olmaktadır. Bir fonksiyon çağrıldığında derleyiciler normal olarak fonksiyonu CALL 
	makine komutuyla çağırmaktadır. CALL işleminden	önce argümanlar fonksiyonun parametre değişkenlerine kopyalanır. Fonksiyonda da geri dönüşü sağlamak için RET 
	makine komutu gerekir. Yine fonksiyonun stack üzerinde işlemler yapabilmesi için "stack frame düzenlemesine" gereksinim duyulabilmektedir. Bu düzenleme de 
	birkaç makine komutu ile yapılmaktadır. İşte fonksiyonların CALL işlemi yerine iç kodlarının çağrılan yere enjekte edilmesi bu ekstra makine komutlarını elimine 
	edebilmektedir. Örneğin şağaıdaki gibi bir fonksiyon söz konsu olsun:

	int add(int a, int b)
	{
		return a + b;
	}
	
	Bu fonksiyonu biz şöyle çağırmış olalım:

	result = add(10, 20);

	32 Bit Intel işlemcilerinin kullanıldığı sistemlerde add fonksiyonu için tipi olarak şu makine komutları üretilmektedir:Ç

	_add:
		push	ebp
		mov		ebp, esp
		mov		eax, [ebp + 8]
		add		eax, [ebp + 12]
		mov		esp, ebp
		pop		evp
		ret

	Burada aslında asıl toplamayı yapan aşağıdaki iki makine komutudur:

	mov		eax, [ebp + 8]
	add		eax, [ebp + 12]

	Diğer makine komutları ekstra maliyete yol açmaktadır. Fonksiyon çağrılması sırasında da tipik olarak şu makine komutları üretilmektedir:

	push	20
	push	10
	call	_add
	add		esp, 8

	Görüldüğü gibi aslında iki makine komutu ile yapılabilecek işlem 11 makine komutuyla yapılabilmiştir. Şimdi add fonksiyonunun inline olduğunu düşünelim:

	inline int add(int a, int b)
	{
		return a + b;
	}
	...
	result = add(10, 20);

	İşte bu durumda derleyici fonksiyonun iç kodunu çağrılan yere enjekte ederek çağırma işlemini elimine edebilmektedir. inline açımda (inline expansion) üretilecek 
	komutlar muhtemelen aşağıdaki gibi olacaktır:

	mov		eax, 10
	add		eax, 20
	mov		result, eax
	
	Klasik olarak C'de inline fonksiyon öncesinde bu tür optimizasyonlar parametreli makrolarla sağlanıyordu. Örneğin:

	#define add(a, b)		((a) + (b))

	Böylece kod enjekte işlemi derleme modülü tarafından değil önişlemci modülü tarafındna yapılıyordu. Örneğin:

	result = add(10, 20);

	Önişlemci bu kodu aşağıdaki biçime dönüştürüyordu:

	result = ((10) + (20))

	Ancak parametrelerin makroların şu dezavantajları vardır:

	1) Yazımları oldukça zordur.
	2) Tanımsız davranışa yol açabilirler. Bu konuda dikkat edilmesi gerekir. 
	3) Birkaç satırlık makroların yazımları problemlidir. 
	4) Önişlemci C'yi bilmemektedir. Dolayısıyla pek kontrolğ önişlemci yapamamaktadır. 

	Örneğin:

	#define square(a)		((a) * (a))

	Böyle bir makroyu aşağıdaki gibi çağırmış olalım:

	int x = 10;

	result = square(++x);

	Burada square bir fonksiyon olsaydı kod gayet normal olarak ele alınacaktı. Ancak makrolarda açım aşağıdaki gibi yapılacağından tanımsız davranış olşuacaktır:

	result = ((++x) * (++x))

	Ancak tabii inline bir fonksiyonun çokça çağrılması neticesinde bir kod büyümesi söz konusu olabilir. O halde kısa (örneğin bir iki satırlık) fonksiyonların 
	inline yapılması uygun bir yaklaşımdır. 

	inline belirleyicisi "bir emir değil rica" niteliğindedir. Yani biz bir fonksiyonu inline yaptığımızda derleyici onun iç kodunu enjekte etmek zorunda değildir. 
	inline fonksiyona yine derleyici normal fonksiyon muamelesi yapabilir. Bu konuda herhangi bir uyarı mesajı da vermeyebilir. inline konusu derleyicilerde genel 
	olarak optimizasyon konusu ile ilişkilendirilmiştir. Yani derleyicimizin optimizasyon seçeneklerini yeteri kadar açmazsak derleyicimiz inline açım yapmaz. 
	Microsoft derleyicilerinde en azından /O2,  g++ ve clang++ derleyicilerinde -O2 seçeneği "inline açım (inline expansion) için uygulanmalıdır. 

	Biz derleyicilerde optimizasyon seçeneklerini açsak bile derleyiciler "döngü içeren, iç içe çok fazla if deyiminin bulunduğu, uzun kodları" kodları
	inline olarak açmak istemezler. Bazı kodlar (örneğin özyineleme içeren) yine inline olarak açılamamaktadır. 

	Derleyiciler kodu inline olarak genellikle açmamışsa herhangi bir uyarı mesajı vermemektedir. Pekiyi biz fonksiyonuninline açılıp açılmadığını nasıl 
	anlayabiliriz? Bunun en sağlam yolu kodun sembolik makine dili çıktısını incelemek ya  da programı debugger altında çalıştırmaktır. Microsoft derleyicilerinde
	"assembly listing" oluşturmak için /FA seçeneği g++ ve clang++ derleyicilerinde ise -S seçeneği kullanılmaktadır. (Visual Studio IDE'sinde bu işlem) proje
	ayarlarından "Properties/C-C++/Output Files/Assembly Output" menüsüyle le yapılbilmektedir.)

	Örneğin:

	g++ -S -masm=intel sample.cpp

	-o seçeneği kullanılmamışsa üretilen dosya ".s" uzantılı olacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

inline int square(int a)
{
	return a * a;
}

int main()
{
	int result;
	int val;

	cout << "Bir değer giriniz:";
	cin >> val;

	result = square(val);		// result = val * val
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
 												10. Ders 18/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    inline fonksiyonlar kütüphanelere yerleştirilemezler (yerleştirilmeye çalışılmaları hata oluşturmayabilir ancak anlamlı değildir.) Çünkü her derleme işleminde 
	inline açım yapabilmesi için derleyicinin inline fonksiyonun tanımlamasını görmesi gerekir. C++ standartlarına göre bir inline fonksiyon farklı kaynak dosyalardan 
	kullanılacaksa her kaynak dosyada inline olarak ve tamamen ödeş biçimde tanımlanmalıdır. Örneğin aşağıdaki gibi bir inline fonksiyon olsun:

	inline int square(int a)
	{
		return a * a;
	}

	Biz bu fonksiyonu projemizi oluşturan "a.cpp", "b.cpp" ve "c.cpp" dosyalarından kullanmak isteyelim. İşte bu fonksiyon -eğer kullanacaksak- bu kaynak dosyalarda 
	inline olarak aynı biçimde tanımlanmış olması gerekir. 
	
	Bir inline fonksiyonun projenin farklı kaynak dosyalarında inline olarak aynı biçimde kullanılabilmesinin en pratik yolu bir başlık dosyası oluşturmak, inline 
	fonksiyonu o başlık dosyasının içerisine yerleştirmek ve dosyayı kullanılacak olan modillerden include etmektir. Yani inline fonksiyonlar tipik olarak projelerde
	başlık dosyalarının içerisine yerleştirilirler. 

	inline fonksiyonlar başlık dosyalarına yerleştirildiğinde ve birden fazla modülde o başlık dosyası include edildiğinde inline fonksiyon da bireden fazla modülde 
	tanımlanmış olacaktır. Pekiyi inline fonksiyonların birden fazla modülde tanımlanmış olması link aşamasında bir problem oluşturmaz mı?

	Yukarıda da belirttiğimiz gibi standartlara göre bir fonksiyon bir modülde inline olarak tanımlanmışsa o fonksiyonu kullanan her modül fonksiyonu yine inline 
	olarak aynı biçimde tanımlamak zorundadır. Bu "aynı biçimde tanımlama" tipik olarak inline fonksiyonun bir başlık dosyasına yerleştirilip modüllerden include 
	edilmesi ile sağlanmaktadır. İşte derleyici eğer inline fonksiyonu inline olarak açarsa ve fonksiyonun adresi de herhangi bir biçimde kodda kullanılmadıysa bu 
	durumda derleyici fonksiyonun derlenmiş halini hiç object dosyaya yazmayabilir. Ancak derleyici inline fonksiyon için inline açım yapmamışsa ya da fonksiyonun 
	adresi kullanılmışsa mecburen fonksiyonu object dosyaya yazacaktır. Bu biçimde projeyi oluşturan tüm modüllerde bu fonksyion object dosyaya yazılacağına göre 
	link aşamasında bir sorun oluşmayacak mıdır? İşte linker farklı object dosyalarda aynı inline fonksiyonun tanımlaması ile karşılaştığında onun herhangi bir 
	object dosyadaki tek bir kopyasını çalıştırılabilen dosyaya yazmaktadır. Bunun için modern object dosya formatlarında "common" bölümler ya da attribute'lar 
	bulunmaktadır. 

	C++'ta inline fonksiyonlar (static inline yapılmadıktan sonra) yine "external linkage'a" sahiptirler. Biz bir inline fonksiyonun adresini alabiliriz. 
	Bu durumda derleyici inline açım yapıyor olsa bile mecburen fonksiyon tanımlamasını yine object dosyaya yerleştirir. Benzer biçimde biz inline bir fonksiyonun 
	farklı modüllerde adresini alsak bile bu adreslerin hepsi aynı olmak zorundadır. Bu durum static olmayan inline fonksiyonun "external linkage'a" sahip olduğunu 
	açık biçimde göstermektedir. Bir inline fonksiyonun farklı modüllerde adresinin alınması durumunda bütün adreslerin aynı olması nasıl sağlanabilmektedir?
	İşte "linker" programları object dosyaları birleştirirken kodun bazı bölümlerinde düzeltmeler de yapmaktadır.

	Özetle programcı birkaç satırlık fonksiyonların hızlı çalışmasını istiyorsa onu inline yapabilir. inline fonksiyonlar tipik olarak başlık dosyalarına 
	yerleştirilirler. Böylece projeyi oluşturan her modülde onlar aynı biçimde bulunurlar. Eğer inline açım yapılırsa çalıştırılabilir dosyada bu inline 
	fonksiyon hiç bulunmayabilir. Eğer inline açım yapılmamışsa ya da inline fonksiyonun adresi kullanılmışsa bu fonksiyonların çalıştırılabilen dosyada 
	tek kopyası bulundurulmaktadır. 

	constexpr fonksiyonların otomatik olarak inline kabul edildiklerini anımsayınız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	inline anahtar sözcüğü fonksiyon prototiplerine yerleştirilebilir. Bu durumda fonksiyon tanımlanırken inline anahtar sözcüğü yazılabilir ya da yazıalmayabilir. 
	Örneğin:

	inline void foo();
	//...

	void foo()		// burada inline yazılmamış olsa bile prototipte inline belirtildiği için fonksiyon inline durumdadır. 
	{
		//...
	}

	Derleyici bir fonksiyon prototipini inline olarak gördükten sonra henüz fonksiyonun tanımlamasını görmeden fonksiyon çağrılırsa onu inline olarak açabilir 
	ya da açmayabilir. Genel olarak derleyiciler bu durumda fonksiyonu inline açmamktadır. Örneğin:

	inline void foo();
	
	int main()
	{
		foo();		// derleyici inline açım yapamayabilir

		return 0;
	}

	void foo()
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	22) C++11 ile birlikte auto anahtar sözcüğü otomatik tür belirleme için bir "tür belirleyicisi (type specifier)" haline getirilmiştir. Eskiden bu auto anahtar 
	sözcüğü (hala C'de böyle) gerçek bir işlevi olmayan "storage class specifier" olarak bulundurulan bir anahtar sözcüktü. C++11 ile bu atıl durumdaki auto anahtar
	sözcüğüne yeni bir işlev yüklenmiştir. 

	Bir değişken auto anahtar sözcüğü ile tanımlanıyorsa ona ilkdeğer verilmek zorundadır. Örneğin.

	auto int a;		// geçersiz!

	Derleyici auto anahtar sözcüğü ile tanımlanmış bir nesnenin türünü ona verilen ilkdeğerden hareketle belirler. Ona verilen ilkdeğer hangi türdense auto yerine
	sanki o türün yazılmış olduğunu kabul eder. Örneğin:

	int foo()
	{
		//...
	}

	//...

	auto a = 123;		// int a = 123;
	auto b = 12.3;		// double b = 12.3;
	auto c = foo;		// void (*c)() = foo;
	auto d = foo();		// int d = foo();

	auto tür belirleyici ile birden fazla değişken tanımlanabilir. Ancak onlara verilen ilkdeğerin hepsinin aynı türden olması gerekir. Örneğin:

	auto a = 10, b = 20;		// geçerli
	auto c = 10, d = 2.3;		// geçersiz!

	auto tür belirleyicisi ile birden fazla değişkenin bildiriminin yapıldığı durumda onların herbirinin türünün verilen ilkdeğerlere göre 
	tespit edildiğine ve bu türlerin aynı türler olması gerektiğine dikkat ediniz. Örneğin:

	auto a = 10, b = "ankara";		// geçersiz!

	Burada a için auto int türünü, b için const char * türünü temsil etmektedir. Bu türler farklı olduğundan bildirim geçersizdir. 

	auto özellikle karmaşık kullanıcı tanımlı türlerin ifade edilmesi konusunda programcıya pratiklik sağlamaktadır. Örneğin:

	vector<int> v;

	auto iter = v.begin();		// vector<int>::iterator iter = v.begin();

	Bildirimdeki auto belirleyicisinin bir tür belirttiğine dikkat ediniz. Örneğin:

	auto a = 10;

	Burada auto tür belirleyicisi int türünü temsil etmektedir. 

	auto belirleyici ile yer belrleyicileri ve tür niteleyicileri (cv qualifers) ve karmaşık dekleratörler birlikte kullanılabilir. Bu durumda tür tespiti 
	"şablon türlerin tespit edilmesi (template argument deduction)"	sürecinde olduğu gibi yapılmaktadır. Örneğin:

	int a = 10;
	auto &r = a, b = 20;					// auto = int
	const auto *s = "ali", ch = 'a';		// auto = char
	auto k = "veli"							// auto = const char *

	Örneğin:

	auto a = "ankara";			// auto = const char *
	auto *b = "ankara";			// auto = const char
	const auto *c = "ankara";	// auto = char

	Yukarıda da belirttiğimiz gibi ilkdeğerden hareketle auto tür belirleyicisinin belirttiği türün tespit edilmesi şablonlardaki tür tespitindeki kurallarla 
	yapılmaktadır. Şablonlar (templates) konusu çok sonra ele alacağımız bir konu olsa da burada yine auto belirleyicisinin şablon eşdeğeri üzerinde bir açıklama
	yapmak istiyoruz. Aşağıdaki gibi bir auto bildirimi yapılmış olsun:

	auto x = ifade;

	Buradaki tür tespiti aşağıdaki şablon parametrelerinin türlerinin tespit eedilmesindeki gibi yapılmaktadır:

	template <typename T>
	void foo(T x)
	{
		//....
	}
	
	foo(ifade);

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											11. Ders 20/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	auto belirleyici ile tür tespiti yapılırken dekleratöre göre kabaca üç farklı durum oluşmaktadır:

	1) auto ile bildirilen değişkenin referans ya da gösterici olmaması durumu (yani dekleratörde &, && ya da * kullanılmaması durumu)
	2) auto ile bildirilen değişkenin sol taraf değeri referansı ya da gösterici olması durumu (yani dekleratörde & ya da * kullanılması durumu)
	3) auto ile bildirilen değişkenin sağ taraf değeri referansı olması durumu (yani dekleratörde && kullanılması durumu)

	auto ile bildirilen değişken bir referans ya da gösterici değilse ilkdeğer olarak verilen nesnenin const ya da volatile olması tür üzerinde etkili 
	olmamaktadır. Örneğin:

	const int a = 10;
	auto b = a;			// auto = int

	Burada b int türdendir, const int türünden değildir. Örneğin:

	const volatile int a = 10;
	auto b = a;		// auto = int

	Burada b int türdendir, const volatile int türden değildir. 

	auto ile bildirilen değişken bir sol taraf değeri referansı ya da bir gösterici ise ilkdeğer verilen ifadedeki const ve volatile niteleyicileri
	türde etkili olmaktadır. Örneğin:

	const int a = 10;
	auto &b = a;			// auto = const int

	Burada b const int türünden bir referanstır.

	Bu durumda tür tespiti yapılırken üst düzey (top level) olmayan tür niteleyicilerinin de dikkate alındığına dikkat ediniz. Örneğin:

	const volatile int a = 10;
	auto &b = a;				// auto = const volatile int

	Burada b const volatile int türünden referanstır. Örneğin:

	const int a = 10;
	auto *p = &a;				// auto = cont int *

	Burada p gösterdiği yer const olan int türden bir göstericidir (yani const int * türündendir). 

	Eğer auto ile bildirilen değişken bir sağ taraf değeri referansı ise bu özel bir durum belirtmektedir. Bu tür referanslara "forwarding reference" ya da 
	"universial	reference" denilmektedir. Bu konu şablon işlemlerinin anlatıldığı bölümde ayrıntılarıyla ele alınacaktır. Ancak burada yine de bazı açıklamalar 
	yapmak istiyouz. 
	
	Normal olarak bir sağ taraf değeri referansına bir sol taraf değeri bind edilememektedir. Ancak "forwarding reference" özel ve istisnai bir durumdur. 
	auto belirleyicisi ile bildirilmiş olan bir sağ taraf değeri reeferansına bir sol taraf değeri ile ilkdeğer verilirse bildirilen değişken bir sol taraf 
	değeri referansı, bir sağ taraf değeri ile ilkdeğer verilirse bildirilen değişken bir sağ taraf değeri referansı olur. Örneğin:

	int a = 10;
	auto &&b = a;		

	Burada b bir sol taraf değeri referansıdır. Yani b int & türündendir. b referansının içerisine a'nın adresi yerleştirilmektedir. Örneğin:

	const int a = 10;
	auto &&b = a;

	Burda b const bir sol taraf değeri referansıdır. Yani b const int & türündendir. Ancak örneğin:

	auto &&b = 10;

	Burada b bir sağ taraf değeri referansıdır. Yani b int && türündendir. Forward reference konusunun ayrıntıları ileride diğer konular içerisinde ele alınacaktır.

	auto belirleyicisi bildirimde tek başına kullanılmak zorunda değildir. auto belirleyicisi ile birlikte yer ve tür belirleyicileri de kullanılabilir, dekleratörde
	başka atomlar da bulundurulabilir. Bu durumda auto belirleyicisinin hangi türü temsil ettiği yukarıda da belirttiğimiz gibi "şablon parametrelerinin türlerinin
	belirlenmesi (template argument deduction)" kuralına göre yapılmaktadır. Bu konunun ayrıntıları şablonların (templates) anlatıldığı bölümde ele alınacaktır. Örneğin:

	int a = 10;
	const auto &b = a, c = 10;		// auto = int

	Burada b const int & türünden, c ise const int türündendir. Buradaki const belirleyicisinin dekleratöre değil türe ilişkin olduğuna dikkat ediniz. 
	Örneğin:

	int a[10];
	auto b = a;				// auto = int *
	auto c = &a;			// auto = int (*)[10]

	Burada b int türünden bir gösterici (yani b int * türünden), c de 10 elemanlı int türden bir dizi göstericisidir (yani c int (*)[10] türündendir). Örneğin:

	int a[10];
	auto &b = a;		// auto = int[10]

	Burada b int türden 10 elemanlı bir dizi referansıdır (yani b int (&r)[10] türündendir).
	
	Örneğin:

	int a[10];
	auto (&b)[10] = a, c = 20;		// auto = int

	Burada auto int türünü temsil etmektedir. Böylece b bir 10 elemanlı bir diziyi temsil eden referans (yani b int (&r)[10] türündendir) c de int türünden bir nesne 
	belirtmektedir. 

	auto belirleyicisi ile bildirilmiş olan değişkenlere küme parantezleri ile ilkdeğer verildiğinde özel bir durum söz konusu olmaktadır. Bu durumu birkaç madde ile
	açıklamak istiyoruz:

	a) C++17'ye kadar auto ile küme parantezleri ile ilkdeğer verilmesi durumunda değişkenin initializer_list<T> türünden olduğu kabul ediliyordu. C++17'ye kadarki durumu
	aşağıdaki örnekle açıklamak istiyoruz.

	auto a{10};					// C++17'ye kadar a initilizer_list<int> türünden
	auto b = {10};				// b initializer_list<int> türünden
	auto c = {10, 20 , 30};		// c initializer_list<int> türünden
	auto d{10, 20, 30};			// geçersiz!
	auto e(10, 20, 30);			// geçersiz!

	b) C++17 ile birlikte küme parantezi ile tek elemanlı doğrudan (yani '=' olmadan) ilkdeğer vermelerde artık tür initializer_list<T> olarak değil doğurdan T olarak
	belirlenmektedir. Örneğin:
	
	auto a{10};					// a C++17'ye kadar a initializer_list<int> türünden ancak C++17 ve sonrasında int türden
	auto b = {10};				// b C++17 sonrasında ve öncesinde initializer_list<int> türünden

	C++17'den sonraki durum için aşağıdaki örnekleri vermek istiyoruz:

	auto a{10};					// C++17'ye kadar a initializer_list<int> türünden ancak C++17 ve sonrasında int türden
	auto b = {10};				// b C++17 sonrasında ve öncesinde initializer_list<int> türünden
	auto c = {10, 20 , 30};		// b C++17 sonrasında ve öncesinde initializer_list<int> türünden
	auto d{10, 20, 30};			// geçersiz!
	auto e(10, 20, 30);			// geçersiz!

	Özetle bu konudaki kurallarda C++17 öncesi ve sonrasındaki tek farklılık "uniform initilizer syntax" ile küme parantezleri kullanıldığındaki durumdur. C++17 
	öncesiinde bildirilen değişken initializer_list<T> kabeul edilirken C++17 ve sonrasında artık T kabul edilmektedir.

	C++14 ile birlikte fonksiyonun geri dönüş değeri için de auto kullanılabilir hale gelmiştir. Fonksiyonun geri dönüş değerinin türü yerine auto kullanılırsa
	derleyici geri dönüş değerinin türünü return ifadesindeki türe bakarak belirler. Örneğin:

	auto foo()		// auto = int
	{
		return 10;
	}

	Burada foo fonksiyonun geri dönüş değerinin int türden olduğu anlaşılmaktadır. Tabii fonksiyon içerisinde birden fazla kez return deyimi kullanılmışsa return 
	ifadelerinin tür tespitinin yapılabilmesi için aynı türden olması gerekir. Örneğin:

	auto foo(int a)		
	{
		if (a > 0)
			return 3.14;

		return 3;		// geçersiz!
	}

	auto void tür tespiti için de kullanılabilir. Eğer fonksiyonda hiç return kullanılmamışsa ya da tüm return deyimlerinde bir ifade bulundurulmamışsa bu durumda
	fonksiyonun geri dönüş değerinin void olduğu tespit edilir. Örneğin:

	auto foo(int a)			// auto = void
	{
		if (a < 0)
			return;

		cout << "foo" << endl;
	}

	C++20 ile birlikte fonksiyonun parametre değişkeninde de auto artık kullanılabilmektedir. Ancak bu kullanım fonksiyonun "gizli bir biçimde şablon olduğu" anlamına gelmektedir. 
	Örneğin:

	auto foo(auto a)
	{
		cout << a << endl;
	}

	int main()
	{
		foo(10);		// auto = int
		foo(20.2);		// auto = double
		foo("ankara");	// auto = const char *
	
		return 0;
	}

	Burada aslında derleyici bir tane foo değil üç farklı foo oluşturmaktadır. Bu kavrama C++'ta "şablon (template)", Java ve C# gibi diğer dillerde "generic"
	denilmektedir. Şablon konusu ileride ayrı bir bölüm olarak ele alınacaktır.

	Buradaki foo fonksiyonunun fonksiyon şablonu olarak eşdeğeri şöyledir:

	template <typename T>
	void foo(T a)
	{
		cout << a << endl;
	}

	C++11 ile eklenen auto tür belirleyicisinin ayrıntıları vardır. Ancak bu ayrıntılar üzerinde daha ileride ilgili konuların içerisinde duracağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    23) C++11 ile birlikte C++'a "aralık tabanlı for döngüsü (range based loop)" ismiyle yeni bir for döngüsü eklenmiştir. Aslında bu tarz for döngüleri 
	zaten C# gibi Java gibi dillerde "foreach" döngüsü ismiyle bulunuyordu. Aralık tabanlı for döngüsünün genel biçimi şöyledir:

	for (<tür> <değişken ismi> : <dizi ismi ya da dolaşılabilir nesne>)
		<deyim>

	C++20 ile birlikte aralık tabanlı for döngülerine normal for döngülerindeki gibi bir "init" bölümü de eklenmiştir ve genel biçim şu hale gelmiştir:

	for ([ifade ya da bildirim>;] <tür> <değişken ismi> : <dizi ismi ya da dolaşılabilir nesne>)
		<deyim>

	Aralık tabanlı for döngüleri şöyle çalışmaktadır: Bir dizi ya da dolaşılabilir (iterable) bir nesnenin her elemanı için döngü bir kez yinelenir. Her yinelemede 
	dizinin ya da dolaşılabilir nesnenin sıradaki elemanı döngü değişkenine yerleştirilir ve döngü deyimi çalıştırılır. Örneğin:

	int a[] {10, 20, 30, 40, 50};

    for (int x : a)
        cout << x << endl;

	Burada sırasıyla dizinin her elemanı döngü değişkeni olan x'e yerleştirilmiş ve döngü deyimi çalıştırılmıştır. Aralık tabanlı for döngüsünde döngü değişkeninin 
	faaliyet alanı yine for döngüsü ile sınırlıdır. Örneğin:

	for (int x : a) {
		//...
	}
	
	Biz x döngü değişkenini yalnızca döngünün içerisinde kullanabiliriz, döngünün dışında kullanamayız. 

	Aralık tabanlı for döngüleri "dizilerle ya da iterator yoluyla dolaşılabilir" nesnelerle kullanılabilmektedir. Biz bu nesnelere anlatımı kolaylaştırmak
	için "dizilim" diyeceğiz. (C++ standartlarında böyle bir terim yoktur. C++ standartlarında buna "range expression" denilmektedir.)

	Standartlarda aralık tabanlı for döngülerinin eşdeğeri iteratör kullanılarak verilmiştir. Ancak bi zhenüz iteratör kavramını bilmiyoruz. Hatalı olsa da
	şimdilik aralık tabanlı for döngüsünün dizisel eşdeğerini şöyle varsayabilirsiniz. Aralık tabanlı for döngüsü bir dizi ile aşağıdaki gibi kullanılmış olsun:

	T a[] = {1, 2, 3, 4, 5};

	for (T x : a) {
		//...
	}

	Bunun yaklaşık eşdeğer (tam eşdeğeri değil) şöyledir:

	auto __begin = a
	auto __end = a + 5;

	for (; __begin != __end; ++__begin) {
		T x = *begin;
		//...
	}

	Bu yaklaşık eşdeğerlilikte dikkat edilmesi gereken noktalardan biri "döngü değişkeninin sanki her yinelemede yeniden yaratılıyormuş gibi" olmasır. Diğer 
	dikkat edilmesi gereken nokta da dizilimin sıradaki elemanının döngü değişkenine "ilkdeğer veriliyormuş gibi" yerleştirilmesidir. 

	Aralık tabanlı for döngülerinde dizilimin her elemanı döngü değişkenine ilkdeğer veriliyormuş gibi atandığı için döngü değişkeni bir referans da olabilmektedir. Örneğin:

	int a[] {10, 20, 30, 40, 50};

    for (int &r : a)
        r = 2 * r;

	Burada a dizisinin her bir elemanı sanki referansa ilkdeğer veriliyormuş gibi düşünülmelidir. Dolayısıyla döngü deyiminde r referansına değer atanması
	aslında dizinin ilgili elemanına değer atanması anlamına gelmektedir. O halde örneğin:

	T a[] = {1, 2, 3, 4, 5};

	for (T &r : a) {
		//...
	}

	işleminin eşdeğeri şöyledir:

	auto __begin = a
	auto __end = a + 5;

	for (; __begin != __end; ++__begin) {
		T &r = *begin;
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int a[]{10, 20, 30, 40, 50};

    for (int x : a)
        cout << x << " ";
    cout << endl;

    for (int &r : a)
        r = 2 * r;

    for (int x : a)
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngüsünde herhangi bir türden dizi kullanabiliriz. Tabii normal olarak döngü değişkeninin de o dizi türüne uygun olması gerekir. Örneğin:

	const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (const char *name : names) {
		//...
	}
    
	Burada dizinin her elemanı const char * türündendir ve bir ismin adresini tutmaktadır. Döngü her yinelendiğinde name isimli gösterici sırasıyla dizideki
	isimleri gösterecektir. 

	String'ler de const char türünden dizi belirttiğine göre biz bir string'teki karakterleri de aralık tabanlı for döngüleri ile dolaşabiliriz. Örneğin:

	for (char ch : "ankara) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <iostream>

using namespace std;

int main()
{
    const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (const char *name : names)
        cout << name << " ";
    cout << endl;

    for (char ch : "ankara")
        cout << ch << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde ':' atomunun sağındaki dizilim belirten ifade (range expression) bir gösterici olamaz. Dizi isimlerinin ifadelere sokulduğunda
	dizinin ilk elemanını gösteren adreslere dönüştürüldüğünü biliyoruz. Ancak aralık tabanlı for döngülerinde böyle bir dönüştürme yapılmamaktadır. Dolayısıyla
	aralık tabanlı for döngülerinde ':' atomunun sağındaki ifadenin diziyi gösteren bir gösterici değil bizzat dizi nesnesinin kendisi olması gerekir. Örneğin:

	int a[] {1, 2, 3, 4, 5};

	for (int x : a) {		// geçerli
		//...
	}

	Ancak örneğin:

	int a[] {1, 2, 3, 4, 5}, *pi = a;

	for (int x : pi) {		// geçersiz!
		//...
	}

	Dolayısıyla ':' atomunun sağına biz bir string yerleştirdiğimizde aslında oaray const char türünden bir dizi nesnesini yerleştirmiş gibi olmaktayız. Örneğin:

	for (char ch : "ankara") {
		//...
	}

	Bu döngünün eşdğerinin aşağıdaki gibi olduğu varsayılmalıdır:

	const char __temp[] = "ankara";

	for (char ch : __temp) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi aralık tabanlı for döngüleri iteratör desteği olan dolaşılabilir (iterable) sınıf nesneleri ile de kullanılabilmektedir. 
	Örneğin C++'ın standart kütüphanesindeki vector gibi list gibi sınıflar dolaşılabilir olduğu için aralık tabanlı for döngülerinde kullanılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v{ 10, 20, 30, 40, 50 };

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda auto belirleyicisi ile küme parantezi kullanılarak ildeğer vermelerde (C++17'deki küçük değişikliği anımsayınız) aslında initializer_list<T>
	türünden bir sınıf nesnesinin yaratıldığını söylemiştik. İşte initializer_list sınıfı da iteratör yoluyla dolaşılabildiği için aralık atablı for döngülerinde
	kullanılabilmektedir. Örneğin:

	auto a = {1, 2, 3, 4, 5};		// a initializer_list<int> türünden

	for (int x : a) {	// geçerli
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    auto a = {1, 2, 3, 4, 5};       // a initializer_list<int> türünden

    for (int x : a)
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aralık tabanlı for döngülerinde döngü değişkeninin normal olarak ilgili dizilimin eleman türünden olması gerekir. Örneğin biz int bir diziyi aralık tabanlı 
	for döngüsüyle dolaşacaksak döngü değişkeninin int türdne olmasını bekleriz. Pekiyi o zaman döngü değişkeninin türünü belirtmeye ne gerek vardır? İşte aslında 
	mademki döngü değişkenine dizinin elemanları ilkdeğer veriliyormuş gibi yerleştirilmektedir o halde aslında bu türler farklı olabilir. Örneğin:

	double a[]{3.14, 2.718, 12.34, 5.2, 7.8};

    for (int x : a) {
        //....
    }

	Tabii burada double türünden int türüne dönüştürme sırasında bilgi kaybı söz konusu olacaktır. İşte bazı konular dikkate alındığında döngü değişkeninin 
	farklı türden olabilmesi dah esnek bir kullanım oluşturmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    double a[]{3.14, 2.718, 12.34, 5.2, 7.8};

    for (int x : a) 
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														12. Ders 25/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde döngü değişkeninin türü yerine "auto" tür belirleyicisi kullanılabilir . Bu durumda eğer dolaşılan nesne bir dizi ise dizinin 
	türüne dayalı tür tespiti yapılır. Eğer dolaşılan nesne iteratör yoluyla dolaşılabilir bir nesne ise burada iteratörün türüne göre tür tespiti yapılmaktadır.
	(Bu tür durumlarda ilgili sınıfının * operatör fonksiyonu çağrıldığı için bu operatör fonksiyonunun geri dönüş değerine dayalı olarak tür tespiti yapılmaktadır.)
	Örneğin:

	int a[] = {1, 2, 3, 4, 5};
	
	//...

	for (auto x : a) {			// auto = int
		//...
	}

	Burada dizi int türden olduğu için dizi elemanları da int türdendir. Dolayısıyla auto belirleyicisi int türünü olarak belirlenecektir. Örneğin:

	const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};
	
	//...

	for (auto x : names) {			// auto = const char *
		//...
	}

	Burada names dizisi const char * türünden olduğu için auto da cont char * türü olarak belirlenecektir. Örneğin:

	vector<int> v{1, 2, 3, 4, 5};

	//...

	for (auto x : v) {		auto = int
		//...
	}

	Her ne kadar vector sınıfını görmemiş olsak da burada bu vector nesnesi int türden değerler tuttuğu için auto da int olarak belirlenecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    double a[]{3.14, 2.718, 12.34, 5.2, 7.8};
    vector<int> v{1, 2, 3, 4, 5};
    const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (auto x : a)            // auto = double
        cout << x << " ";
    cout << endl;

    for (auto &x : a)            // auto = double
        cout << x << " ";
    cout << endl;

    for (auto x : v)            // auto = int
        cout << x << " ";
    cout << endl;

    for (auto x : names)        // auto = const char *
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde döngü değişkeni dizilim için doğrudan küme parantezleri içerisinde bir değer listesi kullanılabilir. Bu durumda bu küme 
	parantezli listederleyici tarafından otomatik olarak initializer_list<T> türüne dönüştürülmektedir. Ancak bu dönüştürmenin yapılabilmesi için küme parantezleri 
	içerisindeki değerlerin aynı türden olması gerekmektedir. initilizer_list<T> türünün iteratör yoluyla dolaşılabilen bir tür olduğunu anımsayınız. initializer_list 
	sınıfı kursumuzun ilerleyen zamanlarında ele alınacaktır. Örneğin:

	for (auto x : {1, 2, 3, 4, 5}) {		// auto = int
		//...
	}

	Burada auto belirleyicisi int olarak tespit edilecektir. Tabii biz aslında auto yerine doğrudan int türünü de kullanabilirdik. Örneğin:

	for (int x : {1, 2, 3, 4, 5}) {			// geçerli
		//...
	}

	Bu biçimdeki for döngülerinde küme parantezi içerisindeki elemanların aynı türden olması gerekmektedir. Örneğin:

	for (auto x : {1, 2, 3.5, 4, 5}) {		// geçersiz! 
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++20 ve sonrasında aralık tabanlı for döngülerinde ""isteğe bağlı olarak (optional)" bir "init" kısmı bulundurulabilmektedir. Eğer "init" kısım 
	bulundurulacaksa bunu ";" atomu izlemelidir. Örneğin:

	int total;

	//...

	for (total = 0; auto x : {1, 2, 3, 4, 5})
        total += x;
    cout << total << endl;

	Bu "init" ifadesi boş da bırakılabilir. Ancak bunun bir anlamı yoktur. Örneğin:

	for (; auto x : a) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int total;

    for (total = 0; auto x : {1, 2, 3, 4, 5})
        total += x;
    cout << total << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	24) C'de tek tırnak içerisindeki karakterler int türden kabul edilmektedir. Örneğin C'de 'a' karakter sabiti her ne kadar karakter sabiti ise de int türdendir. 
	Ancak C++'ta içerisinde yaşnızca tek bir karakter bulunan karakter sabitleri int türden değil char türdendir. Örneğin C++'ta 'a' sabiti char türdendir. 
	Dolayısıyla örneğin sizeof('a') C'de int türünün byte uzunluğunu verirken C++'ta 1 verecektir. Tabii hem C'de hem de C++'ta aslında tek tırnak içerisine
	int türünün byte uzunluğu kadar karakter girilebilir. C++'ta tek tırnak içerisine birden fazla karakter girilirse bu durumda böyle sabitler C'de olduğu 
	gibi int türden kabul edilmektedir. Yani örneğin 'ab' sabiti hem C'de hem de C++'ta int türdendir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    25) C++'ta yapılar, birlikler, sınıflar ve enum türleri için tür bilgisi ifade edilirken "struct", "union", "class"  ve "enum" anahtar sözcüklerinin 
	kullanımı zorunlu değildir. Halbuki C de yapı, birlik ve enum türleri yalnızca isimle belirtilmemektedir. Örneğin C'de date isimli bir yapı bildirmiş olalım. 
	Biz bu yapı türünden nesne tanımlarken tür ismi olarak "struct date" kullanmak zorundayız. Halbuki C++'ta yalnızca "date" ismi yeterli olmaktadır. Örneğin:

	struct complex {
		double real;
		double imag;
	};

	complex z;			// C'de geçersiz, C++'ta geçerli

	C'de yukarıdaki yapı bildirimi ile oluşturulan türün ismi "complex" değildir, "struct complex" biçimindedir. Halbuki C++'ta bu yapıya ilişkin tür yalnızca
	"complex" ismiyle kullanılabilmektedir. Tabii C++'ta istersek tür isminin önüne struct, class, union, enum anahtar sözcüklerini getirebiliriz. Örneğin:

	struct complex z;		// Hem C'de hem de C++'ta geçerli

	Tabii bu tür isimleri tür isminin kullanılabildiği yerde bu biçimde kullanılabilir. Örneğin:

	date *pd;			// geçerli
	void *pv;
	//...

	pd = (date *)pv;		// geçerli 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct date {
    int day, month, year;
};

int main()
{
    date d = {10, 12, 2009};            // C'de geçersiz, C++'ta geçerli
    struct date k = {10, 12, 2009};     // Hem C'de hem de C++'ta geçerli

    cout << d.day << '/' << d.month << '/' << d.year << endl;
    cout << k.day << '/' << k.month << '/' << k.year << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    26) C'de enum türleri ile int türü arasında bir farklılık yoktur. Yani C'de bir enum türünden nesne sanki int türden bir nesneymiş gibi derleyiciler tarafından 
	ele alınmaktadır. Benzer biçimde C'de enum sabitleri de (enumators) sanki int türden sabitler gibi ele alınmaktadır. Dolayıısyla biz C'de enum türünden bir 
	değişkene int türünden bir değişkene atayabileceğimiz her şeyi atayabiliriz. Benzer biçimde C'de enum sabitleri ya da enum türünden nesneler sanki int türündenmiş
	gibi işlem öncesi tür dönüştürmesine sokulmaktadır. Örneğin aşağıdaki gibi bir C kodu olsun:
	
	enum Direction {
		Up, Right, Down, Left
	};
	//...

	enum Direction d;
	int val;

	d = 2;				// geçerli
	val = d + 1;		// geçerli
	val = Down + 1;		// geçerli
		
	Ancak C++'ta her enum türü bağımsız ve farklı bir türdür. mümerik türlerden enum türlerine otomatik dönüştürme yoktur. Ancak bunun tersi olan enum türlerinden 
	nümerik türlere otomatik dönüştürme vardır. Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};
	//...
	
	Direction d;
    int val;

    d = Right;
    val = d + 1;
    cout << val << endl;            // 2

    val = Right + Down;

    cout << val << endl;            // 3

	d = 2;                          // geçersiz!
    d = (Direction)2;               // geçerli

	Görüldüğü gibi C'de biz nümerik türden bir değeri doğrudan enum türünden bir değişkene atayabilmekteyiz. Ancak C++'ta bu durum geçerli değildir. Ancak C++'ta
	biz enun türünden bir değeri nümerik türlerle işleme sokabiliriz. Bu durumda enum türü sanki bir tamsayı türüymüş gibi işleme sokulmaktadır. Yine C'de 
	iki farklı enum türünü birbirlerine atayabiliriz. Çünkü C'de enum türleri tamamen int türü gibi ele alınmaktadır. Ancak C++'ta iki farklı enum türü arasında
	otomatik dönüştürme yoktur. Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};

	enum Color {
		Red, Green, Blue
	};

	Color c;

	c = Right;		// geçersiz! Direction türünden Color türüne otomatik dönüştürme yok!

	C'de enum sabitleri de (enumerators) int türden kabul edilmektedir. Halbuki C++'ta enum türleri farklı bir tür belirttiği için enum sabitleri de ilgili 
	enum türündendir. Örneğin:

	enum Day {
		Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
	};

	Burada örneğin Sunday, Thursay enum sabitleri Day isimli enum türündendir. Örneğin:

	Day d;

	d = Thursday;		// geçerli, d de Thursday de Day türünden

	Tabii yukarıdaki örnekte de görüldüğü gibi tür dönüştürme operatöryle nümerik türler enum türlerine, enum türleri başka enum türlerine dönüştürülebilir. 
	Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};

	enum Color {
		Red, Green, Blue
	};
	//...

	Direction d;

	d = Green;					// geçersiz!
	d = (Direction)d;			// geçerli fakat anlamlı olmayabilir

	C++'ta her enum türünün "ilişkin oldu bir tamsayı türü (underlying integer type)" vardır. enum türünün ilişkin olduğu tamsayı türü aslında o enum türünün 
	gerçekte derleyici tarafından ele alındığı tamsayı türüdür. enum türünün ilişkin olduğu tamsayı türünün bizim için iki önemi vardır:

	1) İlgili enum türünden bir nesne tanımladığımızda o nesne o enum türünün ilişkin olduğu tamsayı türü kadar yer kaplamaktadır.
	2) enum türünden bir değer artimetik işlemlere sokulduğunda ya da atama işlemine sokulduğunda derleyici sanki işleme giren değerin o enum türünün ilişkin 
	olduğu tamsayı türüymüş gibi olduğunu kabul etmektedir. 

	Özetle enum türü aslında C++ derleyicisi için arka planda bir tamsayı türü imiş gibi işleme sokulmaktadır. İşte buna enum türünün ilişkin olduğu tamsayı türü 
	denilmektedir. 
	
	enum türünün ilişkin olduğu tamsayı türü naısl belirlenmektedir? İşte C++11 ile birlikte enum türünün ilişkin olduğu tamsayı türü açıkça ": <tür>" sentaksıyla 
	belirtilebilmektedir. Örneğin:

	enum Direction : int {
		Up, Right, Down, Left
	};

	Burada Direction isimli enum türünün ilişkin tamsayı türü açıkça "int" olarak belirtilmiştir. Tabii ": <tür>" sentaksındaki türün tamsayı türlerinden biri 
	olması gerekmektedir. (C++ standartlarında buna enum türünün ilişkin olduğu tamsayı türünün "fixed" yapılması de denilmektedir.) Tabii ": <tür" sentaksı 
	C++11 ile C++'a eklenmiştir ve bu sentaks enum bildiriminde kullanılmak zorunda değildir. Pekiyi bu durumda enum türünün ilişkin olduğu tamsayı türü ne 
	olacaktır? İşte bu durumda C++ standratlarına göre enum türünün ilişkin olduğu tamsayı türü tüm enum sabitlerinin değerini içerecek biçimde herhangi bir tamsayı 
	olabilmektedir. Ancak standartlar eğer enum sabitlerinin değeri int ve unsigned int türünün sınırlarını aşmadıysa int ve unsigned int türünden büyük bir tür 
	olamayacağını da söylemektedir. Örneğin:

	enum Direction {
		Up = 10, Right = 20, Down = 30, Left = 40
	};

	Burada Direction isimli enum türünün ilişkin olduğu tamsayı türü char, signed char, unsigned char, short, unsigned short ve int ve unsigned int olabilir. 
	Ancak long, unsigned long, long long ve unsigned long long olamaz. 

	Bir enum türünün enum sabitleri o enum türünün ilişkin olduğu tamsayı türünün sınırları dışında değer alamaz. Örneğin:

	enum Direction : unsigned char {
		Up, Right, Down=255, Left               // geçersiz! Left = 256 ama unsigned char sınırlarının dışında
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de ve C++'ta normal enum türlerinde enum sabitleri (enumerators) enum bildirimi hangi faaliyet alanında yapılmışsa sanki o faaliyet alanındaki değişkenler 
	gibi kabul edilmektedir. Örneğin:

	enum Color {
		Red, Green, Blue
	};

	Burada Color isimli enum türü eğer global alanda bildirilmişse Red, Green ve Blue bir global değişken gibi, yerel blokte bildirilmişse bir yerel değişken gibi 
	kullanılmaktadır. Bu da farklı kütüphanelerin bir arada kullanılmasında "isim çakışması (name collision)" oluşturabilmektedir. Örneğin biz iki farklı kaynak 
	tarafından oluşturulmuş olan "x.hpp" ve "y.hpp" dosyalarını include ettiğimizde o dosyalardaki farklı enum türlerinde tesadüfen aynı enum sabitleri bulunabilmektedir.
	Bu durumda aynı faaliyet alanı ieçrisinde aynı değişkenden birden fazla kez tanımlanması nedeniyle error oluşmaktadır. Tabii C++'ta ileride görecek olduğumuz 
	"isim alanları (namespace)" kullanılarak bu farklı kaynaklar bu enum türlerini kendi isim alanlarında bildirebilirler. Böylece isim çakışmasının önüne 
	geçilebilmektedir. Tabii bunun da ayrı bir zahmeti vardır. 

	C++11 ile birlikte dile ismine "faaliyet alanlı enum (scoped enumeration)" denilen yeni bir enum türü daha eklenmiştir. Faaliyet alanlı enum "enum struct" ya da 
	"enum class" anahtar sözcükleriyle bildirilmektedir. Bu iki bildirim arasında hiçbir farklılık yoktur. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};

	Faaliyet alanlı enum türlerinde enum sabitleri (enumerators) artık enum bildiriminin yapıldığı faaliyet alanında değildir. enum sabitlerine her zaman 
	<enum_ismi>::<enum sabiti> ifadesiyle erişilmektedir. Örneğin:

	Direction d;

	d = Direction::Up;			// geçerli
	d = Up;						// geçersiz!

	Burada enum sabitlerine erişmekte kullanılan :: operatörüne "çözünürlük operatörü (scopre resolution operator)" denilmektedir. Atomlar arasında istenildiği 
	kadar boşluk karakteri bırakılabileceğinie göre aşağıdaki yazım da geçerlidir:

	d = Direction :: Up

	Ancak programcılar genel olarak çözünürlük operatörünün iki tarafında boşluk kullanmazlar. Çözünürlük operatörü ile ileride başka onularda da karşılaşacağız. 
	Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};

	enum class Style {
		Up, Down, Hatch, Cross
	};

	Bu iki faaliyet alanlı enum türünün birlikte bulunmasının bir sakıncası yoktur. Çünkü bunların enum sabitlerine artık enum ismi belirtilerek erişilmektedir. 

	Faaliyet alanlı enum türünün normal enum türünden bir farklılığı da otomatik dönüştürmeye izin vermemesidir. Biz faaliyet alanlı bir enum türünü bir tamsayı türüne 
	ya da nümerik türe atayamayız. Faaliyet alanlı bir enum türünü nümerik türlerel işleme sokamayız. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};
	//...

	Direction d = Direction::Down;
	int val;

	val = d;		// Normal enum türleri için geçerli ama faaliyet alanlı enum türleri için geçersiz!
	val = d + 1;	// Normal enum türleri için geçerli ama faaliyet alanlı enum türleri için geçersiz!
	d = 1;			// Hem normal enum türleri için hem de faaliyet alanlı enum türleri için geçersiz!
	
	Görüldüğü gibi faaliyet alanlı enum türleri tür dönüştürmesi bakımından daha katıdır. 

	Tabii faaliyet alanlı enum türlerine ilişkin değerler de tür dönüştürme operatörleriyle nümerik türlere dönüştürülebilir. Nümerik türler de yine tür dönüştürme 
	operatörleriyle faaliyet alanlı enum türlerine dönüştürülebilir. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};		
	//...

	Direction d = Direction::Down;
    int val;

    val = (int)d;               // geçerli
    cout << val << endl;

    d = (Direction)(val + 1);   // geçerli

	Faaliyet alanlı enum türlerinin de ilişkin olduğu tamsayı türü vardır. Bu tamsayı türü yine normal enum türlerinde olduğu gibi ": <tür>" sentaksıyla 
	belirtilmektedir. Örneğin:

	enum class Color : unsigned char {
		Red, Green, Blue
	};

	Ancak faaliyet alanlı enum türlerinde ilişkin olunan tamsayı türü belirtilmezse default durum "int" kabul edilmektedir. Örneğin:

	enum class Color {			// Color enum türünün ilişkin olduğu tamsayı türü int
		Red, Green, Blue
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum Direction {
    Up, Right, Down, Left
};

void move(Direction d)
{
    switch (d) {
        case Direction::Up:
            cout << "moving up...\n";
            break;
        case Direction::Right:
            cout << "moving right...\n";
            break;
        case Direction::Down:
            cout << "moving down...\n";
            break;
        case Direction::Left:
            cout << "moving left...\n";
            break;
    }
}

int main()
{
    move(Direction::Up);
    move(Direction::Down);

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												13. Ders 27/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    27) C++14 ile birlikte C++'a tamsayı türlerine ilişkin sabitlerin 2'lik sistemde ifade edilebilmesi özelliği eklenmiştir. Anımsanacağı gibi C'de tamsayı 
	türlerine ilişkin sabitler 10'luk, 16'lık ve 8'lik sistemlerde ifade edilebiliyordu. C++14 ile birlikte 2'lik sistemde de ifade olanağı dile eklenmiştir. 
	Tamsayıların 2'lik sistemde ifadesi için 0b ya da 0B önekleri kullanılmaktadır. Örneğin:

	c = 0b10101100;

	Aynı özellik C'ye de C23 ile eklenmek istenmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    unsigned char a = 0B1000011;

    printf("%02X\n", a);

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    28) C++'a C++14 ile birlikte sabitlerdeki basamakların birbirinden görsel olarak ayırt edilebilmesi için basamak ayıracı özelliği eklenmiştir. Büyük sayıların 
	ayıraçsız bir biçimde oluşturulması sayıların okunabilirliğini zorlaştırmaktadır. Örneğin:

	a = 1000000000;

	Burada a'ya atanan değerin kaç olduğunu anlayabilmek için özel bir dikkatin sarf edilmesi gerekmektedir. C++14 ile birlikte artık ' (tek tırnak) basamakları
	görsel biçimde ayırmak için kullanılabilmektedir. Örneğin:

	a = 1'000'000'000;

	Tabii burada tek tırnak karakterlerinin üçlü basamakları ayırmak için kullanılması zorunlu değildir. Örneğin:

	a = 1'0'0'0'0'0'0'0'0'0;		// geçerli

	Ancak tek tırnak sayının başında ya da sonunda olamaz. Örneğin:

	a = '10'000;					// geçersiz!
	a = 10000';						// geçersiz!

	Sabit içerisinde yan yana birden fazla tek tırnak ayıracı da kullanılamamaktadır. Örneğin:

	a = 1''000'000'000;				// geçersiz!

	Aslında basamak ayırçları pek çok dilde eskiden beri bulunuyordu, bazılarına ise onların çeşitli versiyonlarında eklendi. Örneğin Python, C# ve Java'da
	basamak ayıracı olarak _ (alt tire) kullanılmaktadır. 

	Basamak ayıraçları yalnızca 10'luk sistemde belirtilen sabitlerde değil diğer sistemlerde belirtilen sabitlerde de kullanılabilmektedir. Örneğin:

	a = 0x12'34'56'78;
	b = 0'12'456;
	c = 0b1000'1010

	Tek tırnak ayıracı 0x ya da 0X, 0b ya da 0B'den hemen sonra getirilemez. Ancak octal sistemde 0'dan hemen sonra getirilebilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    29) C++'ta C'de olmayan uzmanlaşmış tür dönüştürme operatörleri vardır. C'nin "(tür) operand" biçimindeki tür dönüştürme operatörü C++'ta aslında aynı biçimde
	kullanılabilmektedir. Ancak C'nin tür dönüştürme operatörü değişik dönüştürmeleri bir arada yaptığı için hatalara zaemin hazırlayabilmektedir. İşte C++'ta 
	farklı tarzda tür dönüştürmeleri için farklı operatörler bulundurulmuştur. C++'ta C tarzı tür dönüştürmesi yerine bu özel operatörlerin kullanılması iyi bir 
	ekniktir. C++'ın özel tür dönüştürme operatörleri şunlardır:

	static_cast
	const_cast
	reinterpret_cast
	dynamic_cast

	Bu operatörler şablon senktası biçimde kullanılır. Yani dönüştürülecek tür açısal parantezler içerisinde belirtilir. Dönüştürülecek ifade de paranteze alınır. 
	Kullanımın genel biçimi şöyledir:

	xxx_cast<tür>(ifade)

	Örneğin:

	val = static_cast<int>(color);

	C'nin C++'ta da kullanılabilen tür dönüştürme operatörü adeta static_cast, const_cast, reinterpret_cast operatörlerinin birleşimi gibidir. Ancak bu konuda 
	bazı ayrıntılar da vardır. dynamic_cast sınıflar konusuyla ilgilidirç Bu nedenle bu cast operatörü çok ileride ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	static_cast "standart dönüştürmeler (standard conversion)" için kullanılmaktadır. Standart dönüştürme demekle aritmetik türler arası dönüştürmeler, enum ile nümerik 
	dönüştürmeleri, void * dönüştürmeleri, türemiş sınıftan taban sınıfa adres dönüştürmeleri kastedilmektedir. Örneğin double bir değeri int türüne dönüştürmek 
	isteyelim:

	double d = 12.34;
	int i;

	i = d;							// geçerli
	i = static_cast<int>(d);		// geçerli

	Görüldüğü gibi otomatik dönüştürmenin yapıldığı her yerde static_cast operatörü de kullanılabilmektedir. Örneğin:

	int a, b;
	double c;
	//...

	a = 10;
	b = 4;
	c = static_cast<double>(a) / b;

	static_cast operatörü ile enum türleri nümerik türlere, nümerik türler de enum türlrine dönüştürülebilir. Örneğin:

	enum class Color {
		Red, Green, Blue
	};
	//...

	Color c;
    int val;

    c = Color::Green;
    val = static_cast<int>(c);
    
	void bir adresin türü belirli bir adrese, türü belirli bir adresin de void adrese dönüştürülmesi static_cast ile yapılabilmektedir. Örneğin:

	pi = static_cast<int *>(malloc(10 * sizeof(int)));

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void *foo()
{
	return NULL;
}

enum Color {
	Red, Green, Blue
};

int main()
{
	double a = 10.2;
	int val;
	int *pi;
	Color color;

	val = static_cast<int>(a);			// Zaten operatöre gerek yok
	pi = static_cast<int *>(foo());		// void *'dan diğer adres türlerine 
	color = static_cast<Color>(2);		// geçerli, static_cast bu dönüştürmeyi yapar
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	const_cast adres dönüştürmelerinde const'luğu atmak için (const away cast) kullanılmaktadır. Örneğin:

	int a = 10;
	const int *pci = &a;
	int *pi;

	pi = const_cast<int *>(pci);

	const_cast ile aynı türdeki adreslerde const'luk atılabilir. Örneğin:

	int a = 10;
	const int *pci = &a;
	char *pc;

	pc = const_cast<char *>(pci);		// geçerli değil! yalnızca canst'luk atılmıyor

	const_cast adreslerdeki const'luğu atmaktadır. Dolayısıyla const_cast operatörğndeki hedef türün bir adres olması gerekektedir. Örneğin:

	const int a = 10;
	int b;

	b = const_cast<int>(a);		// geçersiz! const_cast adresler için kullanılır

	const_cast const olmayan bir adresin const adrese dönüştürülmesinde de kullanılabilir. Ancak bu dönüştürme zaten otomatik yapıldığı için bu operatörün 
	kullanılmasına gerek yoktur. Yukarıda da belirttiğimiz gibi otomatik dönüştürmelerin hepsi zaten static_cast operatörü ile de yapılabilmektedir. Yani biz 
	örneğin int * türünü const int * türüne static_cast ile de dönüştürebiliriz. const_cast operatörünün asıl yaptıı şey adreslerdeki const'luğu atmaktır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	const int *pci = &a;
	int *pi;

	pi = const_cast<int *>(pci);		// geçerli
	*pi = 20;

	cout << a << endl;

	pi = (int *)pci;					// geçerli fakat kötü teknik!
	*pi = 30;

	cout << a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    reinterpret_cast farklı türlerdeki adresler arasında ve adres türleriyle aritmetik türler arasında tür dönüştürmeleri için kullanılmaktadır. Örneğin:

	int a = 12345;
	unsigned char *pc;

	pc = reinterpret_cast<unsigned char *>(&a);

	Burada int * türü unsigned int * türüne dönüştürülmüştür. Örneğin:

	int a = 12345;
	unsigned long addr;

	addr = reinterpret_cast<unsigned long>(&a);

	Burada bir adresin sayısal bileşeni bir tamsayı türüne reinterpret_cast operatörü ile dönüştürülerek atanmıştır. Örneğin:

	int *pi;

	pi = reinterpret_cast<int *>(0x123456);

	Burada 0x12345 int türden sabit bir adresin sayısal bileşeni olarak int türden göstericiye yerleştirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a[] = { 1, 2, 3, 4, 5 };
	unsigned char *pc;
	unsigned long addr;

	pc = a;											// error!
	pc = (unsigned char *)a;						// geçerli ama C++'ta kötü teknik
	pc = reinterpret_cast<unsigned char *>(a);		// iyi teknik

	addr = (unsigned long)a;						// geçerli ama C++'ta kötü teknik
	addr = reinterpret_cast<unsigned long>(a);		// geçerli ve iyi teknik

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hem adresteki const'luğu atmak hem de adresi farklı türe dönüştürmek için iki operatör birlikte kullanılmalıdır. Örneğin:

	const int *pi;
	char *pc;
	//...

	pc = reinterpret_cast<char *>(const_cast<int *>(pi));

	ya da şöyle de yapılabilirdir:

	pc = const_cast<char *>(reinterpret_cast<const char *>(pi));
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	const int *pci;
	unsigned char *pc;

	pci = &a;

	pc = const_cast<unsigned char *>(reinterpret_cast<const unsigned char *>(pci));
	
	for (size_t i = 0; i < sizeof(a); ++i)
		printf("%02X ", pc[i]);
	printf("\n");

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	dynamic_cast operatörü sınıflarla ilgili işlem yapmaktadır. Bu operatör çok ileride ele elınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	30) C++'ta C'deki tür dönüştürme operatörünün sentaks olarak ters biçimini andıran "fonksiyonel tür dönüştürme operatörü" de bulunmaktadır. Fonksiyonel 
	tür dönüştürme operatörü hem sınıflar konusunda uyum oluşturmak için hem de şablon mekanizmasını desteklemek için bulundurulmuştur. Bu operatör C++'ın ilk
	zamanlarından beri varlığını sürdürmektedir. Ancak C++11 ile "uniform initializer syntax" dile eklenince bunun küme parantezli biçimi de oluşturulmuştur. 
	Fonksiyonel tür dönüştürme operatörü yukarıda da belirttiğimiz gibi adeta klasik tür dönüştürme operatörünün sentaks bakımından tersidir. Yani T bir 
	tür belirtmek üzere C'nin klasik tür dönüştürme operatörü (T)ifade biçimindedir. Fonksiyonel tür dönüştürme operatörü ise T(ifade) biçimindedir. Burada 
	dönüştürülecek türün değil ifadenin paranteze alındığına dikkat ediniz. T(ifade) bir fonksiyon çağrısına benzediği için buna "fonksiyonel tür dönüştürme
	operatör" denilmiştir. Örneğin:

	int a = 10;
	int b = 4;
	double c;
	//...
	
	c = double(a) / b;

	Fonksiyonel tür dönüştürme operatörü işlev olarak C'nin tür dönüştürme operatörü gibidir. Yani yine static_cast, const_cast ve reinterpret_cast operatörlerinin
	bir birleşmi gibidir. Başka bir deyişle C tarzı tür dönüştürme operatörü ile yapılan hger şey fonksiyonel tür dönüştürmesi ile de yapılabilmektedir. 
	
	Fonksiyonel tarzda tür dönüştürmesinin önemli bir sentaks kısıtı vardır. Bu dönüştürmede dönüştürülecek türün tek atomdan oluşması gerekmektedir. Örneğin:

	double a = 12.345;
	unsigned long b;
	
	b = unsigned long(a);		// geçersiz! unsigned long iki atomdan oluşuyor

	Burada unsigned long türü iki atomdan oluştuğu için kullanım geçersizdir. Tabii unsigned long türünü typedef edip tek atomla ifade edersek bu durumda 
	dönüştürme geçeli olur:

	double a = 12.345;
	unsigned long b;
	typedef unsigned long ulong;

	b = ulong(a);

	Buradaki tek atom koşuluna dikkat ediniz:

	int a = 10;
	char *pc;

	pc = char *(&a);		// geçersiz! char * tek atomdam oluşmuyor

	Yine typedef işlemi ile bunu geçerli hale getirebiliriz:

	int a = 10;
	char *pc;
	typedef char *char_ptr;

	pc = char_ptr(&a);

	C++11 ile birlikte "uniform initializer syntax" dile eklenince fonksiyonel tarza tür dönüştümesinin küme parantezli versiyonu da oluşturuldu. T bir tür belirtmek 
	üzere T{ifade} sentaksı da fonksiyonel tarzda tür dönüştürmesi gibi kullanılabilmektedir. Ancak burada "uniform initializer syntax" dolayısıyla daraltıcı 
	dönüştürmelere izin verilmemektedir. Örneğin:

	int a = 10;
	int b = 4;
	double c;

	c = double{a} / b;		// geçersiz! int -> double dönüştürmesi daraltıcı bir dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	int b = 4;
	double c;

	c = double(a) / b;
	cout << c << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											14. Ders 02/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	30) C'de fonksiyonlar ve diziler bütünsel olarak birer nesne kabul edilmektedir. Ancak fonksiyon isimleri bir ifade de kullanıldığında derleyici tarafından 
	otomatik olarak fonksiyonun başlangıç adresine dönüştürülmektedir. Aynı durum C'de diziler için de söz konusudur. Bir dizi ismini biz bir ifadede kullandığımızda 
	derleyici bu dizi nesnesini otomatik olarak dizinin başlangıç adresine (yani ilk elemanın adresine) dönüştürmektedir. O halde C'de bir fonksiyonun ismi ifade
	içerisinde kullanıldığında onun başlangıç adresini belirtmektedir. Pekiyi fonksiyon çağırma operatörünün operandı ne olmalıdır? C standartlarına göre fonksiyon 
	çağırma operatörünün operandı bir fonksiyon adresi olmalıdır. Dolayısıyla foo bir fonksiyon nesnesi olmak üzere foo(...) ifadesi aslında foo adresinden başlayan 
	fonksiyonun çağrılması anlamına gelmektedir. Öte yandan foo fonksiyon nesnesi ifade kullanıldığında zaten fonksiyon adresine dönüştürüldüğü için *foo ifadesi de
	yeniden fonksiyon nesnenin kendisi anlamına gelir. O halde fonksiyon nesnesi ifadede kullanıldığında fonksiyon adresine dönüştürüleceğine göre (*foo)(...) 
	geçerli olmaktadır. Aynı durum fonksiyon göstericilerinde de böyledir. pf bir fonksiyon göstericisi olmak üzere bu göstericinin gösterdiği yerdeki fonksiyon 
	pf(...) ifadesiyle ya da (*pf)(...) ifadesiyle de çağrılabilmektedir. Ayrıca C'de gerekmiyor olsa da bir fonksiyon nesnesinin adresi & operatöryle alınabilmektedir. 
	Örneğin pf bir fonksiyon göstericisi foo da onunla uyumlu bir fonksiyon olmak üzere aşağıdaki iki ifade eşdeğerdir:

	pf = foo;
	pf = &foo;
	
	C++ tasarım olarak C'yi kapsayacak biçimde oluşturulmuştur. Tabii bu kapsama mutlak değildir. Ancak C++ tasarlanırken özellikle ilk yıllarda C uyumunun korunmasına 
	çalışılmıştır. Ancak C++'ta referanslar da olduğu için durum biraz daha farklılışamaktadır. C++'ta bir fonksiyon türünden referanslar söz konusu olabilir. Tabii 
	böyle referanslar bir fonksiyon ile ilkdeğer verilerek tanımlanmalıdır. Örneğin:

	void foo()
	{
		cout << "foo" << endl;
	}
	//...

	void (&f)() = foo;

	f();

	Bu referans ifadesinin eşdeğer gösterici karşılığı şöyle oluşturulabilir:

	void (*f)() = &foo;

	(*f)();

	İşte C++'ta fonksiyon referansı ile fonksiyon göstericilerine ilkdeğer verirken aslında doğrudan fonksiyon isimleri kullanılabilmektedir. Ancak genel eğilim 
	(üye fonksiyon göstericilerinde zorunlı olan durum) fonksiyon göstericilerinde fonksiyonun adresinin programcı tarafından alınmasıdır. Örneğin:

	void (*pf1)() = foo;			// geçerli!
	void (*pf2)() = &foo;			// C++'a göre daha uygun 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	32) C++'a C++11 ile birlikte decltype isimli bir "tür belirleyicisi (type specifier)" eklenmiştir. decltype belirleyicisi parantez içerisinde bir ifade ile 
	kullanılmaktadır. Genel biçimi şöyledir:

	decltype(<ifade>)

	C++ statik tür sistemine sahip bir programlama dili olduğu için bir ifadenin türü derleme aşamasında derleyici tarafından belirlenebilmektedir. İşte decltype
	belirleyicisi bizim ona verdiğimiz ifadenin türünü belirtir. Yani decltype belirleyicisine bir ifade verdiğimizde aslında biz o ifadenin türünü belirtmiş gibi 
	oluruz. Örneğin:

	int a;
	const long b = 10;

	Burada decltype(a) int türünü, decltype(b) const long türünü, decltype(a + b) ise long türünü belirtmektedir. Biz tür bilgisi gereken her yerde decltype
	belirleyicisini kullanabiliriz. Örneğin:

	decltype(a) c;			// burada c int türünden
	decltype(b) d = 10;		// burada d const long türünden
	decltype(a + b) e;		// burada e long türden

	Örneğin:

	int foo(int a)
	{
		//...
	}
	//...
	
	decltype(&foo) pf;		// burada pf int (*)(int) türünden
	decltype(foo()) a;		// burada a int türden

	decltype belirleyicisinde parantezler içerisine bir fonksiyon ismi yazıldığında oluşturulan tür fonksiyon adres türü olmamaktadır. O fonksiyonun türü 
	olmaktadır. Dolayısıyla eğer parantezler içerisinde bir fonksiyon ismi bulundurulacaksa bu durumda gösaterici ya da referans oluşturmak için dekleratörde * 
	ya da & atomunun bulundurulması gerekmektedir. Örneğin:

	decltype(foo) *pf;		// burada decltype foo int(int) türünden bir fonksiyon belirtmektedir. 

	Aynı durum diziler için de söz konusudur. decltype belirleyicisinin parantezleri içerisinde bir dizi ismi verilirse decltype bu dizi türünü belirtir. 
	Örneğin:

	int a[10];

	decltype(a) b;		// int b[10] ie eşdeğer, yani b int[10] türünden

	Tabii decltype belirleyicinin parantezi içerisinde yazdığımız ifade çalıştırılmamaktadır. Derleyici yalnızca o ifadenin türüyle ilgilenmektedir. 

	Anımsanacağı gibi fonksiyon parametresi olarak dizi ya da fonksiyon dekleratörü kullanılırsa bu dekleratör gösterici belirtmektedir. Örneğin:

	void foo(int a[])
	{
		//...
	}

	Burada a int türden bir göstericidir. Örneğin:

	void bar(void f())
	{
		//...
	}

	Burada f geri dönüş değeri void olan parametresi olmayan bir fonksiyon göstericisidir. Tabii prototiplerde biz değişken isimlerini yazmak zorunda değiliz:

	void foo(int[]);
	void bar(void());

	Bu tür durumlarda decltype belirleyicisinden de faydalanılabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	void bar(decltype(foo) f)
	{
		//...
	}

	Buradaki bar fonksiyonunun tanımlanması aşağıdaki tanımlamayla eşdeğerdir:

	void bar(void f())
	{
		//...
	}

	Tabii dekleratörde açıkça gösterici de kullanabilirdik:

	void bar(decltype(foo) *f)
	{
		//...
	}

	Buradaki bar tanımlaması da aşağıdaki ile eşdeğerdir:

	void bar(void (*f)())
	{
		//...
	}

	Aynı tanımlamayı şöyle de yapabilirdik:

	void bar(decltype(&foo) f)
	{
		//...
	}

	decltype belirleyicisi fonksiyon adreslerine dönen fonksiyonların yazımını da kolaylaştırabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	void (*bar())()
	{
		//...

		return foo;
	}

	Burada bar geri dönüş değeri void parametresi olmayan bir fonksiyon adresine geri dönmektedir. Aynı tanımlamayı şöyle de yapabilirdik:

	decltype(foo) *bar()
	{
		//...

		return foo;
	}

	Ya da şöyle de yapabilirdik:

	decltype(&foo) bar()
	{
		//...

		return foo;
	}

	decltype belirleyicisine operand olarak sol taraf değeri oluşturan bir ifade verilirse bu durumda tür sol taraf değeri referansı olmaktadır. Örneğin:

	int a[1];
	int b = 10;

	decltype(a[0]) c = b;
    
	Burada c bir referanstır ve "int &" türündendir. decltype belirleyicisine operand olarak bir değişken ismi verilmesiyle sol taraf değeri oluşturan bir ifade
	verilmesi arasındaki farka dikkat ediniz:

	int a[0];
	int b;

	Burada decltype(a[0]) "int &" türünü, decltype(b) int türünü belirtmektedir. Bir ismi paranteze aldığımızda bir ifade oluşturduğuna göre burada decltype((a))
	da "int &" türünü belirtecektir.

	C++14 ile birlikte decltype belirleyicisi auto belirleyici ile birlikte de kullanılabilir hale getirilmiştir. Örneğin:

	int a;
	decltype(auto) b = a;

	decltype bu biçimde auto ile yalnızca bildirimlerde kullanılabilir ve decltype(auto) ile bildirilen değişkenlere ilkdeğer verilmek zorundadır. Örneğin:

	decltype(auto) x;		// geçersiz! ilkdeğer verilmemiş

	Örneğin:

	int a;
	decltype(auto) b = a;

	decltype(auto) ile auto arasında ince bir farklılık vardır. Normal olarak auto olarak bildirilmiş olan değişkene verilen ilkdeğer referans ise bildirilen değişken 
	referans olmaz. Örneğin:

	int a = 10;
    int &b = a;
    auto c = b;       // c int türden

	Ancak decltype(auto) ile bildirilen değişkene verilen ilkdeğer referans ise bildirilen değişken de referans olmaktadır. Örneğin:

	int a = 10;
    int &b = a;
    decltype(auto) c = b;       // c int türden referans yani int & türünden

	decltype(auto) özellikle fonksiyonların geri dönüş değerlerinde anlamlı bir biçimde kullanılmaktadır. Örneğin:

	decltype(auto) foo()
	{
		//...
	}

	Burada foo fonksiyonun return ifadesinde bir referans varsa fonksiyonun geri dönüş değeri de return ifadesindeki tür türünden bir referans olacaktır. Eğer 
	return ifadesinde bir referans yoksa bu durumda fonksiyonun geri dönüş değeri return ifadesindeki tür türünden olacaktır. Yukarıda da belirttiğimiz gibi 
	C++14 ile eklenen decltype(auto) belirleyicisi daha çok fonksiyonların geri dönüş değerlerinde karşımıza çıkmaktadır. Ancak bu konudaki örnekler şablon içeren
	nispeten karmaşık örneklerdir. Bu nedenle biz burada bu duruma örnek vermeyeceğiz. İlerideki konularda bununla ilgili örnekler verilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	32) C++11 ile birlikta C++'a NULL adres sabitini temsil eden nullptr anahtar sözcüğü eklenmiştir. Anımsanacağı gibi C'de NULL adres sabiti iki biçimde 
	belirtiliyordu:

	1) 0 değerini veren tamsayı türlerine ilişkin sabit ifadeleri
	2) 0 değerini veren tamsayı türlerine ilişkin sabit ifadelerinin void * türüne dönüştürülmüş hali. Örneğin (void *) 0 gibi.

	C++'ta NULL adres sabiti başından beri 0 değerini veren tamsayı türlerine ilişkin sabit ifadesi biçiminde oluşturulmaktaydı. (C++'ta void * türü diğer
	türlere otomatik biçimde dönüştürülmediği için NULL adres sabiti olarak kullanılmamaktadır.) C++'ta NULL sembolik sabiti de tipik olarak şöyle define edilmiştir:

	#define NULL	0

	Tabii standartlara bakılırsa NULL sembolik sabiti 0 değerini veren tamsayı türlerine ilişkin bir sabit ifadesi olarak da define edilebilir. 

	NULL adres her ne kadar 0 ile temsil ediliyor olsa da NULL adresin sayısal bileşeni derleyicileri yazanlar tarafından belirlenmektedir. Yani NULL adres 
	belleğin tepesindeki 0 adresi olmak zorunda değildir. NULL adres derleyici tarafından o sistemde kullanılmayan herhangi bir adres olabilir. Ancak yaygın 
	sistemlerin hemen hepsinde derleyiciler NULL adres olarak gerçekten belleğin tepesindeki 0 adresini almaktadır. 
	
	Örneğin:

	int *pi;

	pi = 0;		// pi'ye int 0 değil NULL adres değeri atanıyor

	Burada pi göstericisine 0 adresi atanmamaktadır. O sistemdeki NULL adres neyse o atanmaktadır. Benzer biçimde örneğin:


	if (pi == 0) {		// pi'nin içerisinde 0 adresi vr mı diye bakılmıyor, o sistemdeki NULL adres var mı diye baklılıyor
		//...
	}

	Burada da pi'nin içerisinde 0 adresi var mı diye kontrol yapılmamaktadır. O sistemdeki derleyicini belirlediği NULL adres var mı diye kontrol yapılmaktadır. 
	Örneğin:

	if (pi) {
		//...
	}

	Bu ifade C'de ve C++'ta aşağıdaki ile eşdeğer kabul edilmektedir:

	if (pi != 0) {
		//...
	}

	NULL adresin tamsayı 0 ile temsil edilmesi C'nin ilk zamanlarından beri problem yaratan bir durum olmuştur. İşte C++11 ile artık NULL adres için nullptr 
	isminde bir anahtar sözcü dile eklenmiştir. Örneğin:

	int *pi;

	pi = nullptr;		// C++11 ve sonrasında izlenmesi gereken iyi teknik

	Burada pi göstericisine yine o sistemde derleyicini belirlediği NULL adres atanmaktadır. nullptr anahtar sözcünün C++ standartlarında nullptr_t isimli bir 
	türden olduğu belirtilmektedir. Standartlar nullptr türünü şöyle açıklamıştır:

	typedef decltype(nullptr) nullptr_t;

	Burada biraz komik özyinelemeli bir anlatım uygulanmıştır. "nullptr nullptr_t türündendir. nullptr_t ise nullptr'nin türüdür". Özetle nullptr_t yalnızca nullptr 
	değerine sahip olan özel bir türdür. 

	C++11 ve sonrasında artık NULL adres sabiti için 0 yerine bu nullptr anahtar sözcüğünün kullanılması iyi bir teknik kabul edilmektedir. Bu anahtar sözcüğün 
	eklenmesiyle birlikte "overload resolution" mekaznizması bu bakımdan güçlendirilmiştir. 

	Null adresi temsil etmek için C23'e de aynı biçimde bir nullptr anahtar sözcüğünün eklenmesine karar verilmiştir. Belki de C'de en başından beri bu NULL adresin 
	bir anahtar sözcük ile temsil edilmesi gerekiyordu. Pascal, Java, C# diller çok önceleri NULL adres için bir anahtar sözcük kullanmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	33) typedef anahtar sözcüğü bir bildirime eklenebilir ve bildirimdeki değişkeni o değişkenin türüne ilişkin tür ismi haline getirir. C++11 ile birlikte bazı 
	nedenlerden dolayı alternatif bir typedef mekanizması da dile eklenmiştir. Buna "type alias" da denilmektedir. Bu alternatif typedef mekanizmasının genel biçimi 
	şöyledir:

	using <isim> = <sembolik tür>;

	Örneğin:

	using I = int;

	Bu aşağıdaki typedef bildirimi eşdeğer etki oluşturmaktadır:

	typedef int I;

	Örneğin:

	using STRA = const char *[5];

	Burada STRA türü 5 elemanlı her elemanı const char türünden bir gösterici olan diziyi temsil etmektedir. Yani:

	STRA names;

	bildirimi ile:

	const char *names[5];

	bildirimi eşdeğerdir. Örneğin:

	using PF = void (*)();

	Burada PF geri dönüş değeri void parametresi olmayan bir fonksiyon adres türünü temsil etmektedir. Yani:

	PF pf;

	bildiri ile aşağıdaki bildirim eşdeğerdir:

	void (*pf)();

	C'de ve C++'ta void anahtar sözcüğü de teknik olarak bir tür belirtmektedir. Örneğin:

	using VOID = void

	VOID *pv;

	Bu bildirim aşağıdaki ile eşdeğerdir:

	void *pv;

	Pekiyi C++11 ile birlikte neden böyle alternatif bir typedef mekanizması eklenmiştir? Öncelikle bu yeni mekanizma daha doğal bir görünüme sahiptir. typedef
	bildirimleri kişiler tarafından zor öğrenilmektedir. Ancak bu alternatif typedef mekanizmasının dile asıl yerleştirilme gerekçesi şablon konusunda sağladığı 
	kolaylıklardır. Bu mekanizma şablon mekanizması ile birlikte kullanılabilmektedir. Bu bağlamda çeşitli kolaylıklar sunmaktadır. Şablon mekanizması ileride ele 
	alınacaktır. 

	decltype belirleyicisi ise typedef ya da using tür bildirimi birlikte de kullanılabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	using FP = decltype(foo) *;

	FP bar()
	{
		//...

		return foo;
	}

	Ya da örneğin:

	typedef decltype(&foo) FP;

	FP bar()
	{
		//...

		return foo;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											15. Ders 04/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	34) C++'ta parametre değişkenleri default değer alabilmektedir. Fonksiyon çağrılırken default değer alan parametre değişkenleri için argüman girilmeyebilir. 
	Bu durumda sanki argüman olarak o default değerlerin girilmiş olduğu kabul edilir. Eğer default değer alan parametre değişkenleri için argüman girilmişse bu 
	durumda	bu default değerler dikkate alınmaz. Örneğin:

	void foo(int a, int b = 10, int c = 20)
	{
		//...
	}

	Burada a parametre değişkeni için argüman girilmek zorundadır. Ancak b ve c parametre değişkenleri için argüman girilmeyebilir. Default argümanın verilme
	biçimine dikkat ediniz. Önce parametre değişkeninin ismi sonra '=' atomu ve sonra default değer belirtilmektedir. Default değer alan parametre değişkenlerine 
	ilişkin fonksiyuonlar çağrıldığında aslında her zaman parametre değişkenleri için argüman ataması yapılmaktadır. Örneğin:

	foo(100, 200);

	Burada c parametre değişkeni için argüman belirtilmemiştir. Bu durumda c parametre değişkenine default olarak 20 değeri atanacaktır. Yani yukarıdaki çağrının
	eşdeğeri aşağıdaki gibidir:

	foo(100, 200, 20);

	Default argüman yalnızca çağrımı kolaylaştırmaktadır. Örneğin:

	foo(100, 200);

	Bu çağrının makine kodlarına bakıldığında aslında c paarametre değişkeni için 20 değerinin akratıldığı görülecektir. Yani verilen default değerlerin aktarımı 
	konusunda bir etkinlik söz konusu değildir. Buradaki fonksiyon her zaman üç parametreye sahiptir ve çağrım sırasında her zaman bu üç parametre için üç argüman 
	aktarılmaktadır. Yukarıdaki fonksiyonu aşağıdaki gibi çağırmış olalım:

	foo(100);

	Bu çağrının eşdeğeri şöyledir:

	foo(100, 10, 20);

	Bu örneğimizde a parametre değişkeni default değer almadığı için bu parametre değişkeni için argüman girilmesi zorunludur. 

	Bir fonksiyonun bütün parametre değişkenleri default değer alabilir. Örneğin:

	void foo(int a = 10, int b = 20, int c = 30)
	{
		//...
	}

	Böyle bir fonksiyonu biz argümansız da çağırabilirdik:

	foo();

	Bu çağrının eşdeğeri şöyledir:

	foo(10, 20, 30);

	Bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer almış olması gerekmektedir. Örneğin:

	void foo(int a = 10, int b, int c = 20)			// geçersiz!
	{
		//...
	}

	Burada yukarıda belirttiğimiz kurala uyulmamıştır. a parametre değişkeni default değer aldığı için onun sağındakilerin hepsinin default değer alması gerekirdi.
	Bu kural şöyle ifade edilebilir: Default değer alan parametre değişkenleri parametre listesinin sağında birikmiş olmalıdır. Eğer yukarıdaki gibi bir durum 
	geçerli olsaydı aşağıdaki gibi bir sentaksın da geçerli olması gerekirdi:

	foo(100, , 200);		// böyle bir sentaks yok!

	Halbuki böyle bir sentaks yoktur.

	Parametre değişkenlerine verilen ilkdeğerler tipik olarak sabit ifadesi olmaktadır. Ancak global değişkenler ve hatta fonksiyonlar da bu ilkdeğer vermede 
	kullanılabilmektedir. (Sınıflar konusuna geldiğimizde üye fonksiyonlar için sınıfın veri elemanları da ilkdeğer vermede kullanılabilmektedir.)
	Örneğin:

	int g_x = 10;

	void foo(int a = g_x + 1)		// geçerli
	{
		//...
	}

	Ancak verilen ilkdeğerde önceki parametre değişkenleri kullanılamamaktadır. Örneğin:

	void foo(int a, int b = a + 1)		// geçerli değil!
	{
		//...
	}

	Örneğin parametre değişkenine verilen default değer bir string olabilir:

	void putmsg(const char *msg = "Ok")
	{
		cout << msg << endl;
	}
	//...
	
	putmsg("invalid command");
	putmsg();

	Parametre değişkenine verilen default değer fonksiyon çağrısının geri dönüş değeri ile ilişklili de olabilir. Örneğin:

	int square(int a)
	{
		return a * a;
	}

	void bar(int a = square(10))
	{
		//...
	}

	Tabii parametre değişkenlerine aslında fonksiyon çağrısı sırasında değer atanmaktadır. Yani parametre değişkeni örneğin global bir değişkene bağlı ise 
	global değişkenin son değeri işleme sokulacaktır. Örneğin:

	int g_x = 10;

	void foo(int a = g_x + 1)
	{
		//...
	}
	//...

	foo();

	Buradaki çağrının eşdeğeri şöyledir:

	foo(g_x + 1);

	Dolayısıyla a parametre değişkenine 11 değeri kopyalanacaktır. Örneğin:

	g_x = 20;

	foo();

	Buradaki çağrının da eşdeğeri yukarıdaki gibi olduğuna göre o anca g_x global değişkeninin değeri kullanılacağından a parametre değişkenine 21 kopyalanacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a = 100, int b = 200)
{
    cout << "a = " << a << ", b = " << b << endl;
}

int main()
{
    foo();              // foo(100, 200)
    foo(10);            // foo(10, 100)
    foo(10, 20);        // foo(10, 20)

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Default değer alan parametre değişkenlerine sahip fonksiyonlarda default değerler prototipte belirtilebilirler (genellikle böyle yapılır). Default değerler
	hem prototipte hem de tanımlamada belirtilemezler. Ya prototipte (tercih böyle olmalıdır) ya da tanımlamada belirtilmelidirler. Örneğin:

	void foo(int a = 10, int b = 20);
	void bar(double = 3.14);

	void foo(int a = 10, int b = 20)		// error!
	{
		//...
	}

	void bar(double a)						// geçerli
	{
		//...
	}

	Yukarıda da belirttiğimiz gibi eğer prototip bulunduruluyorsa default değerlerin prototipte belirtimesi tanımlama sırasında belirtilmemesi iyi tekniktir. 
	Örneğin:

	void foo(int a = 10, int b = 20, int c = 30);
	//...

	void foo(int a, int b, int c)
	{
		//...
	}

	Tabii prototiplerde de bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer alması gerekir. Örneğin:

	void foo(int a = 10, int b, int c = 20);		// geçersiz prototip!

	Prototiplerde değişken ismi belirtilmeyebileceğine göre aşağıdaki prototipler biraz tuhaf gözükmekle birlikte geçerlidir:

	void foo(int = 10, int = 20, int = 30);		// tuhat ama geçerli

	Standartlara göre bir paramere değişkenine yalnızca bir kez default değer verilebilir. Amcak bazı default değerler prototipte, bazıları ise tanımlama sırasında 
	da belirtilebilmektedir. Örneğin aşağıdaki bildirimler geçerlidir:

	void foo(int a, int b = 10, c = 30);

	void foo(int a = 20, int b, int c)		// geçerli, ama kötü teknik!
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void dispmsg(const char *msg = "Ok");

int main()
{
    dispmsg();
    dispmsg("error");

    return 0;
}

void dispmsg(const char *msg)
{
    cout << msg << endl;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Parametre değişkenlerine verilen default değerlerin yaygın kullanılan değerlerden olması gerekir. Aksi takdirde parametre değişkenin default değer almasının 
	bir anlamı kalmaz. Parametre değişkenlerine herhangi bir değeri default değer olarak vermek kötü bir tekniktir. Örneğin:
	
	int add(int a = 10, int b = 20)
	{
		return a + b;
	}

	Burada verilen default değerlerin diğer değerlerden hiçbir farkıyoktur. Dolayısıyla böyle bir kullanım kötü bir tekniktir. Bu biçimde verilen ilkdeğerler bir 
	anlam ifade etmediği gibi kodu inceleyenleri de yanlı yönlendirebilmektedir. Fakat örneğin:

	void disp_number(int a, int base = 10);

	Burada fonksiyonun ikinci parametresi birinci parametresindeki int değerin kaçlık sistemde ekrana yazdırılacağını belirtiyor olsun. Burada verilen default değer
	anlamlıdır. 

	Parametre değişkenlerinin default değer alması kullanım kolaylığı da sağlamaktadır. Bazen fonksiyonların çok fazla parametresi olabilir. Fonksiyonu çağıran 
	kişi bu detayları bilmek istemeyebilir. Böylece default değer almış parametreler programcı argüman girmez. Onlar için makul değerler fonksiyonu yazanlar tarafından 
	zaten kullanılmış durumdadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen parametre değişkenine verilen default değer aslında o parametre değişkeni için argüman girilmediğini tespit etmekte kullanılmaktadır. Programcı asıl 
	default değeri başka bir biçimde elde ediyor olabilmektedir. Örneğin:

	void disp_date(int day = 0, int month = 0, int year = 0);

	Burada aslında parametre değişkenlerine verilen 0 değeri çok kullanıldığı için verilmemiştir. Fonksiyonun default değerle çağrılıp çağrılmadığını anlamak 
	için verilmiştir. Örneğin:

	void disp_date(int day = 0, int month = 0, int year = 0)
	{
		auto t = time(nullptr);
		tm *pt;

		pt = localtime(&t);

		if (!day)
			day = pt->tm_mday;
	
		if (!month)
			month = pt->tm_mon + 1;

		if (!year)
			year = pt->tm_year + 1900;

		cout << day << '/' << month << '/' << year << endl;
	}

	Burada eğer ilgili parametre için argüman girilmemişse o anda içinde bulunulan tarihe ilişkin değer kullanılmıtr. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

void disp_date(int day = 0, int month = 0, int year = 0)
{
	auto t = time(nullptr);
	tm *pt;

	pt = localtime(&t);

	if (!day)
		day = pt->tm_mday;
	
	if (!month)
		month = pt->tm_mon + 1;

	if (!year)
		year = pt->tm_year + 1900;

	cout << day << '/' << month << '/' << year << endl;
}

int main()
{
	disp_date();
	disp_date(12);
	disp_date(12, 10);
	disp_date(12, 10, 2020);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	35) Anımsanacağı gibi C'de statik ömürlü (yani global ve statik yerel) nesnelere verilen ilkdeğerlerin sabit ifadesi olması zorunludur. Örneğin aşağıdaki gibi
	bir global değişken tanımalması C'de geçerli değildir:

	int square(int a)
	{
		return a * a;
	}

	int g_x = square(10);		// C'de geçersiz!

	Bu kuralın gerekçesi statik ömürlü nesnelerin ilkdeğerleriyle birlikte amaç dosyaya ve çalıştırılabilir dosyaya yazılması zorunluluğudur. Dolayısıyla derleyicinin 
	derleme aşamasında statik ömürlü nesnelere verilen ilkdeğeri belirlemiş olması gerekmektedir. Ancak C++'ta böyle bir zorunluluk yoktur. Yani C++'ta statik ömürlü 
	nesneleri sabit ifadeleriyle ilkdeğer verilmesi zorunlu değildir. Yukarıdaki kod C'de geçersiz olduğu halde C++'ta geçerlidir. 
	
	Pekiyi C++'ta statik ömürlü nesnelere nasıl ilkdeğer verilmektedir? Aslında bir C programında ve C++ programında akışın başlatıldığı yer main fonksiyonu değildir. 
	Akış derleyicilerin yerleştirdiği ismine "start-up code" denilen bir koddan başlatılır. Bu kod main fonksiyonunu çağırmaktadır. main bitince akış yine start-up 
	code döner. Zaten exit fonksiyonu da start-up code tarafından çağrılmaktadır. Startup-up code'un temsili şöyledir:

	...
	...				<Start-up code>
	...
	status = main()
	exit(status)

	İşte C++'ta eğer global değişkenlere sabit ifadesi ile ilkdeğer verilmemişse bu ilkdeğer verme işlemi main fonksiyonundan önce start-up code tarafından yapılmaktadır. 
	Bunun basit bir sınaması aşağıdaki programla yapılabilir:

	#include <iostream>

	using namespace std;

	int square(int a)
	{
		cout << "square" << endl;

		return a * a;
	}

	int g_x = square(10);


	int main()
	{
		cout << "main" << endl;

		cout << g_x << endl;

		return 0;
	}

	Program çalıştırıldığında ekrana (stdout dosyasına) şunlar basılacaktır:

	square
	main
	100

	C++ standartlarına göre global değişkenlere verilen aynı kaynak dosya (translation unit) için yukarıdan aşağıya doğru ilkdeğerleri verilmektedir. Ancak 
	proje birden fazla kaynak dosyadan oluşuyorsa bunların birbirlerine göre durumu hakkında bir sıra belirtilmemektedir. 

	Statik yerel değişkenlere sabit ifadeleriyle ilkdeğer verilmemişse eğer fonksiyon çağrılmışsa ve yalnızca ilk çağrıldığında akış ilkdeğer verme noktasına 
	geldiğinde bu ilkdeğer verme işlemi gerçekleştirilmektedir. Aşağıdaki program kuralın test edilmesinde kullanılabilir:

	#include <iostream>

	using namespace std;


	int square(int a)
	{
		cout << "square" << endl;

		return a * a;
	}

	void foo()
	{
		cout << "foo" << endl;

		static int x = square(10);

		cout << x << endl;
	}

	int main()
	{
		foo();
		foo();

		return 0;
	}

	Eğer burada foo hiç çağrılmasaydı square fonksiyonu da çağrılmayacaktı. foo birden fazla kez çağrıldığında yalnızca ilk çağırmada toplamda bir kez square
	çağrılacaktır. Akış statik yerel değişkenin tanımlandığı noktaya gelmezse square zaten hiç çağrılmayacaktr.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	36) C'de fonksiyon tanımlamada parametre değişkenlerine isim verilmesi zorunludur. Ancak C++'ta böyle bir zorunluluk yoktur. Örneğin:

	void foo(int)		// C'de geçersiz, C++'ta geçerli
	{
		//...
	}

	Tabii parametre değişkenine isim verilmemesi onun kullanılamayacağı anlamına da gelmektedir. C++'ta parametre değişkenine isim verilmemiş olsa da çağırma 
	sırasında yine onun için argüman tedarik edilmek zorundadır. Örneğin:

	void foo(int)
	{
		//...
	}
	//...

	foo();		// geçersiz!
	foo(10)		// geçerli

	Yine isimsiz parametreler için default argüman belirtilebilmektedir. Ancak bu durum genel olarak bir faydaya yol açmamaktadır. Örneğin:

	void foo(int = 10)			// geçerli ama tuhaf
	{
		//...
	}

	İsim verilmemiş parametre değişkenlerinin parametre listesinin sonunda toplanması gibi bir zorunluluk yoktur. Örneğin:

	void foo(int a, int, int b)		// geçerli
	{
		//...
	}

	Parametre değişkenlerine isim verilmemesi onların programcı tarafından kullanılamamasına yol açmaktadır. Pekiyi neden programcı böyle bir şeyi tercih etsin?
	İşte bazen programcının aynı parametrik yapıya sahip birden fazla fonksiyon tanımlaması gerekebilmektedir. Bu tür durumlarda kullanılmayan ama sözde (dummy)
	bir parametre değişkenine gereksinim duyulmaktadır. Sonraki paragrafta fonksiyonların overload edilmeleri konusu ele alınmaktadır. 

	Tabii mademki isim verilmemiş parametre değişkenleri aslında fonksiyon tarafından kullanılamamaktadır. O halde optimizasyon sırasında derleyici o parametre
	değişkeni için bazı koşullar da sağlanıyorsa agrüman parametre aktarımını hiç yapmayabilir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											16. Ders 09/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    37) C++'ta parametrik yapıları farklı olmak koşuluyla aynı faaliyet alanında aynı isimli birden fazla fonksiyon bulunabilir. Bu duruma İngilizce "function 
	overloading" denilmektedir. Halbuki C'de hiçbir durumda aynı isimli birden fazla fonksiyon bulunamamaktadır. Parametrik yapıların farklı olması demek parametrelerin 
	türce veya sayıca farklı olması demektir. Parametre değişkenlerinin isimlerinin ve fonksiyonların geri dönüş değerlerinin türlerinin bu bağlamda bir önemi yoktur. 
	Önemli olan parametre değişkenlerinin türlerinin ya da sayılarının farklı olmasıdır. Örneğin aşağıdaki foo fonksiyonları C++'ta birlikte bulunabilir:

	void foo(int a)
	{
		//...
	}

	void foo(double a)
	{
		//...
	}

	void foo(int a, int b)
	{
		//...
	}

	void foo()
	{
		//...
	}

	Ancak aşağıdaki fonksiyonlar bir arada bulunamazlar:

	void bar(int a)
	{
		//...
	}

	void bar(int b)
	{
		//...
	}

	int bar(int c)
	{
		//...
	}

	Fonkisyonların geri dönüş değerlerinin farklı olması bu bağlamda dikkate alınmamaktadır. Yani parametrik yapısı aynı olan ancak geri dönüş değerleri farklı 
	olan aynı isimli fonksiyonlar bir arada bulunamazlar. Örneğin:

	void foo(int a, int b)
	{
		//...
	}

	int foo(int a, int b)		// geçersiz! overload edilemez
	{
		//...
	}

	Buradaki iki foo fonksiyonu overload edilemez. Çünkü bu iki fonksiyonun parametrik yapısı aynıdır. Bunların geri dönüş değerlerinin farklı olması bu bağlamda
	bir farklılık oluşturmamaktadır.

	Farklı parametrik yapılara ilişkin aynı isimli fonksiyonların bulunabilmesi özelliği yalnızca C++'ta değil diğer nesne yönelimli programlama dilelrini büyük 
	bölümünde de vardır. Örneğin bu özelliğe Java ve C#'ta "method overloading" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyon ismi ve parametre türlerinin oluşturduğu dizilime "fonksiyonun imzası (function signature)" da denilmektedir. Örneğin:

	void foo(int *pi, int size)
	{
		//...
	}

	Burada fonksiyonun imzası "foo, int *, int" biçimindedir. İmzaya parametre değişkenlerinin isimlerinin ve fonksiyonun geri dönüş değerinin dahil edilmediğine 
	dikkat ediniz. Örneğin:

	int bar(int a, long b)
	{
		//..
	}

	Burada bar fonksiyonunun imzası "bar, int, long" biçimindedir. 

	O halde overload edilme kuralını şu biçimde de ifade edebiliriz: "Aynı faaliyet alanı içerisinde aynı imzaya sahip olan birden fazla fonksiyon tanımlanamaz,
	ancak farklı imzalara sahip fonksiyonlar tanımlanabilir." 

	Fonksiyon imzasının bir küme değil bir dizilim belirttiğine dikkat ediniz. Aşağıdaki iki fonksiyonun imzası farklıdır, dolayısıyla bu fonksiyonlar overload
	edilebilirler:

	void foo(int a, long b)		// imza: foo, int, long
	{
		//...
	}

	void foo(long a, int b)		// imza: foo, long, int
	{
		//...
	}

	Tabii türlerin typedef ya da using isimleri değil onların gerçek türleri imzayı oluşturmaktadır. Örneğin:

	void foo(size_t size)
	{
		//...
	}

	void foo(unsigned a)
	{
		//...
	}

	Burada eğer size_t türü ilgili sistemde unsigned int olarak typedef edilmişse bu iki fonksiyonun imzası aynı olur. Dolayısıyla overload edilemez. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türlerdeki "üst düzey const ve volatile niteleyicileri (top level cv qualifiers)" türleri farklılaştırmamaktadır. Yani fonksiyonun imzası oluşturulurken üst 
	düzey const ve volatile niteleyicileri atılmaktadır. Üst düzey const ve volatile niteleyicileri "nesnenin kendisini niteleyen" const ve volatile niteleyicileridir. 
	Örneğin:

	const int a = 10;						// buradaki const üst düzey
	const volatile int b = 20;				// buradaki const ve volatile üst düzey
	const int *pi;							// buradaki const üst düzey değil
	const char * volatile str;				// buradaki volatile üst düzey, const üst düzey değil
	const char * const *names;				// buradaki her iki const da üst düzey değil

	Referanslardaki const ve volatile niteleyicileri referansların kendilerine ilişkin olmadığı için üst düzey değildir. Zaten referanslarda üst düzey const ve volatile 
	oluşturulamamaktadır. Örneğin:

	int a = 10;
	const int &r = a;		// buradaki const üst düzey değil
	
	Örneğin:

	void foo(int a)
	{
		//...
	}

	void foo(const int a)
	{
		//...
	}

	Burada iki foo fonksiyonunun imzaları aynıdır. Dolayısıyla aynı anda bulunamazlar. Ancak üst düzey olmayan const ve volatile niteleyicileri türleri 
	farklılaştırmaktadır. Yani fonksiyonun imzasında üst düzey olmayan const ve volatile belirleyicileri korunmaktadır. Örneğin:

	void foo(int *pi, int size)				// imza: foo, int *, int
	{
		//...
	}

	void foo(const int *pi, int size)		// imza: const int *, int
	{
		//...
	}

	Burada ilk fonksiyonun imzası "foo, int *, int" ikinci fonksiyonun imzası "foo, const int *, int" biçimindedir. Aynı durum referanslar için de söz konusudur. 
	Örneğin:

	void foo(int a)					// imzası: foo, int
	{
		//...
	}

	void foo(int &r)				// imzası: foo, int &
	{
		//...
	}

	void foo(const int &r)			// imzası: foo, const int &
	{
		//...
	}

	Buradaki üç foo fonksiyonunun da parametrik yapıları dolayısıyla imzaları farklıdır. Overload işlemi geçerlidir. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonlardaki default argümanlar imzayı etkilememektedir. Örneğin:

	void foo(int a, int b = 10)
	{
		//...
	}

	void foo(int a)		// parametrik yapılar yani imzalar farklı, overload işlemi geçerli
	{
		//...
	}

	Bu iki fonksiyonun parametrik yapıları yani imzaları farklıdır. Birinci fonksiyonun inzası "foo, int, int" ikinci fonksiyonun imzası ise "foo, int"
	biçimindedir. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

 /*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Amaç dosya formatlarında (object file formats) aynı isimli birden fazla global sembol bulunamamaktadır. Bu durumda C++ derleyicileri overload edilmiş 
	fonksiyonların isimlerini mecburen onların parametre türleriyle kombine ederek amaç dosyaya yazmaktadır. Genel olarak bir global sembolün isminin değiştirilerek
	amaç dosyaya yazılmasına İngilizce "name decoration" ya da "name mangling" denilmektedir. Böylece programcı fonksiyonlara aynı isimleri vermiş olsa da aslında 
	C++ derleyicisi onları farklı isimlerle amaç dosyaya yazmaktadır. C++ standartları "name decoration" konusunda herhangi bir belirlemede bulunmamıştır. Yani 
	bu konu tamamen derleyicileri yazanların isteğine bırakılmıştır. Derleyiciler arasında "name decoration" bakımından önemli farklılıklar bulunabilmektedir. 
	Genellikle C++ programcılarının bu konunun ayrıntılarını bilmesine gerek yoktur. Ancak sembolik makine dilinde C++ için fonksiyon yazanların mecburen bu durumun
	farkında olması gerekmektedir. Aslında "name decoration" C'de uygulanabilmektedir. Örneğin Microsoft C derleyicileri global sembollerin başın "_" öneki getirerek 
	onu amaç koda yazmaktadır. Yine 32 bit sistemlerde Microsoft değişik "fonksiyon çağırma biçimlerine (calling convention)" değiik isim dekorasyonu kullanmaktadır. 

	Aşağıdaki bağlantıda Microsoft C++ derleyicilerinin uyguladığı isim dekoroasyonu hakkında ayrıntılı bilgiler verilmektedir:

	https://en.wikiversity.org/wiki/Visual_C%2B%2B_name_mangling

	g++ ve clang++ derleyicilerinin isim dekorasyonları için de aşağıdaki bağlantıyı kullanabilirsiniz:

	https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling

	Microsoft dekore edilmiş isimlerin aslında hangi parametrik yapıya sahip fonksiyonlara karşılık geldiğini anlayabilmek için "undname" isimi bir utility 
	program da bulundurmaktadır. Örneğin:

	F:\Dropbox\Kurslar\SysProg-1\Src>undname ?foo@@YAXHH@Z
	Microsoft (R) C++ Name Undecorator
	Copyright (C) Microsoft Corporation. All rights reserved.

	Undecoration of :- "?foo@@YAXHH@Z"
	is :- "void __cdecl foo(int,int)"

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli bir fonksiyon çağrıldığında o fonksiyonlardan hangisinin çağrıldığının tespit edilmesi sürecine İngilizce "overload resolution" denilmektedir. 
	Overload resolution işleminin bazı ayrıntılı kuralları vardır. Ancak overload resolution işlemi en basit haliyle şöyledir: "Çağrılma ifadesindeki argümanların 
	türleriyle tam uyuşan bir fonksiyon varsa o fonksiyon çağrılır." Örneğin:
	
	void foo(int a)		
	{
		cout << "int" << endl;
	}

	void foo(long a)	
	{
		cout << "long" << endl;
	}

	void foo(double a)
	{
		cout << "double" << endl;
	}

	void foo(const char *str)
	{
		cout << "const char *" << endl;
	}

	Burada biz foo fonksiyonunu şöyle çağırmış olalım:

	foo(10);

	10 int türdne bir sabittir. Dolayısıyla argüman int türdendir. O halde int paranetreye sahip olan foo fonksiyonu çağrılacaktır. Örneğin:

	foo(3.14);

	3.14 double türdendir. O halde double türden parametreye sahip olan foo fonksiyonu çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a)
{
	cout << "int" << endl;
}

void foo(long a)
{
	cout << "long" << endl;
}

void foo(double a)
{
	cout << "double" << endl;
}

void foo(int a, int b)
{
	cout << "int, int" << endl;
}

void foo(const char *str)
{
	cout << "const char *" << endl;
}

int main()
{
	long x = 100;

	foo(10);			// int
	foo(10.2);			// double
	foo("ankara");		// const char *
	foo(x);				// long
	foo(10, 20);		// int, int

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi ya çağrılma ifadesindeki argümanların türleriyle tam bir uyuşma gösteren fonksiyon yoksa ne olacaktır? İşte bu durumda iki sonuç oluşabilir. Birincisi 
	çağırma işlemi geçersiz olabilir. Yani çağırma error ile sonuçlanır. İkincisi mevcut aynı isimli fonksiyonlardan bir tanesi "kötünün iyisi" olarak seçilir. 
	Bu noktada "overload resolution" sürecinin ayrıntıları devreye girmektedir. İzleyen paragraflarda ayrıntılı kurallar açıklanacaktır. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Derleyici tarafından yapılan dönüştürmelere "otomatik tür dönüştürmeleri (implicit type conversions)" denilmektedir. Overload resolution sürecinin ayrıntılarını 
	anlayabilmek için otomatik (implicit) tür dönüştürmeleri arasındaki kalite farklılıklarının bilinmesi gerekir.

	T1, T2 ve T3 birer tür belirtmek üzere T1 -> T3 dönüştürmesi ile T2 -> T3 dönüştürmesi arasında bir iyiilk kıyaslaması yapıldığında üç durum söz konusu olabilir:

	1) T1 -> T3 dönüştürmesi T2 -> T3 dönüştürmesinden daha iyi olabilir. 
	2) T2 -> T3 dönüştürmesi ile T1 -> T3 dönüştürmesinden daha iyi olabilir
	3) T1 -> T3 dönüştürmesi ile T2 -> T3 dönüştürmelerinden hiçbiri diğerinden iyi ya da kötü olmayabilir. 

	Örneğin:

	int -> long
	char -> long

	Burada T1 türü int türünü, T2 türü char türünü ve T3 türü de long türünü temsil etmektedir. C++ standartlarına göre bu iki dönüştürme arasında bir kalite farklılığı 
	yoktur. Örneğin:

	char -> int
	long -> int

	C++ standartlarına göre char -> int dönüştürmesi long -> int dönüştürmesinden daha iyidir. 

	Otomatik dönüştürmeler arasındaki kalite farklılıkları iyiden kötüye doğru şöyle sıralanmaktadır:

	1) Tam Uyum (Exact Match): Üst düzet const ve volatile belirleyicileri atıldıktan sonra iki tür birbirinin aynısı ise tam uyum söz konusudur. Örneğin:

	int -> int
	const int -> int
	int -> volatile int
	double -> double

	2) Int Türüne Yükseltme Dönüştürmesi (Ineteger Promotion Conversion) ya da Double Türüne Yükseltme Dönüştürmesi (Floating Point Promotion): Bilindiği gibi 
	int türünden küçük olan türlerin int türüne dönüştürülmesine standartlarda "integer promotion" ya da "integral promotion" denilmektedir. Benzer biçimde float
	türünden double türüne dönüştürmeye de "floating point promotion" denilmektedir. Örneğin:

	char -> int
	shor -> int
	float -> double

	3) Nümerik Dönüştürmeler (Numeric Conversions): Yukarıdaki durumların dışında kalan temel nümerik türler arasındaki dönüştürmelerdir. Örneğin:

	int -> long
	char -> long
	long -> int
	char -> long
	double -> float

	4) Kullanıcı Tanımlı Dönüştürmeler (User Defined Conversion): Bu dönüştürmeler sınıflar konusu ile ilgilidir. Burada üzerinde durmayacağız. 

	O halde artık T1 -> T3 ve T2 -> T3 dönüştürmelerinin kıyaslamasını yapabiliriz. Örneğin:

	char -> int
	long -> int

	Burada char -> int dönüştürmesi daha iyidir. Örneğin:

	float -> double
	int -> double

	Burada float -> double dönüştürmesi daha iyidir. Örneğin:

	float -> long double
	int -> long double

	Burada iki dönüştürme de aynı kalitededir. Örneğin:

	int -> double
	long -> double

	Burada da iki dönüştürme aynı kalitededir. Örneğin:

	short -> long
	int -> long

	Burada da iki dönüştürme aynı kalitededir. 
	
	Java ve C# ile C++ bu bakımdan farklılıklar göstermektedir. Örneğin bu dillerde int -> long dönüştürmesi shprt -> lng dönüştürmesinden daha iyi kabul edilmektedir. 
	Bu dillerden geçenler bu durumlara dikkat etmemlidirler. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çağrılma ifadesindeki argümanların türleriyle tam uyuşan bir fonksiyon yoksa derleyici bazı kurallara göre mevcut fonksiyonların içerisinden birini seçebilmektedir
	ya da çağrıyı geçersiz kabul edebilmektedir. İşte bu noktada "overload resolution" işleminin bazı ayrıntıları devreye girmektedir. Şimdi bu ayrıntılar üzerinde 
	duracağız. 
	
	Overload resolution işlemi üç aşamada yürütülmektedir:

	1) Önce aday fonksiyonlar (candidate functions) belirlenir.
	2) Aday fonksiyonların içerisinden uygun olan (viable) fonksiyonlar seçilir. 
	3) Uygun olan fonksiyonlar arasından en uygun olan (the best viable) fonksiyon seçilmeye çalışılır. 

	Eğer en uygun fonksiyon varsa ve bir tane ise overload resolution işlemi başarıyla sonuçlandırılır. En uygun fonksiyon yoksa ya da birden fazla ise overload 
	resolution işlemi başarısızlıkla sonuçlanacaktır.

	Overload resolution işlemini iş yerine personel alımı için işletilen sürece benzetebiliriz. Önce kişiler CV'lerini gönderirler. Bunlar adaylardır. Onların 
	arasından uygun olanlar seçilir ve mülakata çağrılır. Onların arasından da en uygun kişi seçilmeye çalışılır. 

	1) İlgili faaliyet alanında çağrılma ifadesi ile aynı isimli olan tüm fonksiyonlar aday fonksiyonlardır. Yani bir fonksiyonun aday olması için isminin aynı olması 
	yeterlidir. 

	2) Çağrılma ifadesindeki argümanların sayısı ile aynı sayıda parametre değişkenine sahip olan ve her argümandan parametre değişkenine otomatik (implicit) tür 
	dönüştürmesinin mümkün olduğu fonksiyonlar uygun (viable) fonksiyonlardır. (Yani uygun fonksiyon demek "eğer bu fonksiyon tek başına bulunsaydı çağrılabilirdi" 
	demektir.) Bir aday fonksiyonunun uygun olabilmesi için argümanlarla aynı sayıda parametre değişkenine sahip olması ve argümanlardan parametre değişkenlerine 
	otomatik dönüştürmenin mümkün olması gerekmektedir. Fonksiyonun n tane parametresi olduğunu ve fonksiyon k tane argümanla çağrıldığını varsayalım. Bu k tane 
	argümanın hepsinden n tane parametrenin ilk k tanesi ile otomatik dönüştürme mümkün olsun. Eğer fonksiyonun n - k tane parametresi defult değer alıyorsa bu 
	fonksiyon da uygun fonksiyondur. Benzer biçimde fonksiyonun k + 1'inci parametresi ya da default değer almış olan parametrelerin sonundaki 
	parametresi "... (ellipsis)" biçimindeyse bu fonksiyon da uygun fonksiyondur. 

	3) En uygun fonksiyon "her argüman parametre deönüştürmesi diğer uygun fonksiyonlara göre ya daha iyi olan ya da daha kötü olmayan" fonksiyondur. Eğer böyle tek bir 
	fonksiyon varsa o fonksiyon en uygun (best viable) fonksiyon olarak seçilir. Eğer bu biçimde birden fazla fonksiyon varsa ya da hiçbir fonksiyon yoksa çağırma 
	işlemi geçersizdir ve error ile sonuçlanır. 

	Örneğin aşağıdaki gibi overload edilmiş foo fonksiyonları olsun:

	void foo(int a, int b)						// 1
	{
		cout << "int, int" << endl;
	}

	void foo(int a, double b)					// 2
	{
		cout << "int, double" << endl;
	}

	void foo(double a, double b)				// 3
	{
		cout << "double, double" << endl;
	}

	void foo(const char *str, double a)			// 4
	{
		cout << "int, double" << endl;
	}

	void foo(int a)								// 5
	{
		cout << "int" << endl;
	}

	void bar(int a)								// 6
	{
		cout << "bar int" << endl;
	}

	Biz de bu fonksiyonu aşağıdaki gibi çağırmış olalım:

	foo(12.3f, 3.2f);

	Burada 1, 2, 3, 4 ve 5 numaralı fonksiyonlar aday fonksiyonlardır. Ancak yalnızca 1, 2 ve 3 numaralı fonklsiyonlar uygun fonksiyonlardır. Bu 1, 2 ve üç 
	numaralı fonksiyonları çağrılma ifadesindeki her argüman parametre dönüştürmesi için birbirleriyle kıyazlayalım. Birinci argüman-parametre dönüştürmesi 
	şöyledir:

	float ->int			// 1
	float -> int		// 2
	float -> double		// 3

	Burada 3 numaralı fonksiyonun birinci argüman parametre dönüştürmesi diğer uygun fonksiyonlardan daha iyidir. Şimdi ikinci argüman-parametre dönüştürmesine 
	bakalım:

	float -> int		// 1
	float -> double		// 2
	float -> double		// 3

	Burada da 2 ve 3 numaralı fonksiyonlar eşit iyiliktedir ancak daha kötü değildir. O halde "tüm argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da 
	daha kötü olmayan" fonksiyon 3 numaralı fonksiyondur. Oberload resolution işleminden bu fonksiyon seçilecektir. 

	Şimdi çağrısının şöyle yapıldığını varsayalım:

	foo('a', 2.3f);

	Bu durumda yine 1, 2 ve 3 numaralı fonksiyonlar uygun fonksiyonlardır. "Her argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da dha kötü olmayan"
	bir fonksiyon vardır. O da 2 numaralı fonksiyondur. Bu durumda overload resolution işleminden 2 numaralı fonksiyon seçilecektir. 

	Çağrının şöyle yapılmış olduğunu varsayalım:

	foo(3.14, 10);

	Burada 3 numaralı fonksiyonun birinci argüman-parametre dönüştürmesi diğerlerinden daha iyidir. Ancak ikinci argüman-parametre dönüştürmesi 1 numaralı fonksiyondan 
	kötüdür. Benzer biçimde 1 numaralı fonksiyonun da nirinci argüman-parametre dönüştürmesi 3 numaralı fonksiyondan kötüdür. O halde burada "tüm argüman-parametre 
	dönüştürmeleri diğerlerinden daha iyi olan ya da daha kötü olmayan" bir fonksiyon yoktur. Dolayısıyla overload resolution işlemi error ile sonuçlanacaktır. 
	Bu tür error durumlarına İngilizce "ambiguity error" de denilmektedir. 

	Aşağıdaki gibi iki bar fonksiyonu olsun:

	void bar(int a, long b)
	{
		//...
	}

	void bar(long a, int b)
	{
		//...
	}

	Biz de fonksiyonu şöyle çağırmış olalım:

	bar(10, 20);

	Burada da en uygun fonksiyon bulunamamaktadır. Şimdi aşağıdaki foo fonksiyonları bulunyor olsun:

	void foo(double a, double b)
	{
		//...
	}

	void foo(float a, float b)
	{
		//...
	}

	foo(10, 20);

	Burada "her argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da daha kötü olmayan" iki fonksiyon vardır. Dolayısıyla en uygun fonksiyon 
	iki tanedir. Budurum da error ile sonuçlanacaktır. 

	Tabii biz çok sayıda uygun fonksiyonun olduğu durumda çağrı ifademizdeki argümanlarının türlerini bu uygun fonksiyonlardan birinin parametre türleriyle 
	aynı yaparsak kesinlikle o fonksiyon seçilir. Çünkü tam uyumdan (exact match) daha iyi olabilecek bir fonksiyon yoktur. Tam uyumu sağlayan da zaten birden 
	fazla fonksiyonun overload edilmesi mümkün değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, long b)					// 1
{
    cout << "int, long" << endl;
}

void foo(long a, long b)				// 2
{
    cout << "long, long" << endl;
}

void foo(double a, long b)				// 3
{
    cout << "double" << endl;
}

void foo(int a, int b)					// 4
{
    cout << "int, int" << endl;
}

void foo(double a, double b)			// 5
{
    cout << "double, double" << endl;
}

void foo(char a, short b)				// 6
{
    cout << "char, short" << endl;
}

void foo(int a, const char *s)			// 7
{
    cout << "int , const char *" << endl;
}

void foo(int a)							// 8
{
    cout << "int" << endl;
}

void bar(int a)							// 9
{
    cout << "bar, int" << endl;
}

int main()
{
    int a = 10;
    long b = 20;

    foo(a, b);		// int, long
    foo('a', 'b');	// ambiguity error!
    foo(10L, 2.3);  // ambiguity error!

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													17. Ders 11/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz. İlk iki çağrıda en uygun fonksiyon 1 numaralı fonksiyon olarak seçilecektir. Ancak üçüncü çağrıda en uygun fonksiyon bulunamayacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, int b)          // 1
{
    cout << "int, int" << endl;
}

void foo(double a, int b)       // 2
{
    cout << "double, int" << endl;
}

void foo(long a, long b)    // 3
{
    cout << "long, long" << endl;
}

int main()
{
    foo('a', 3.2);   // int, int
    foo('a', 'b');   // int, int
	foo(3.2, 10L);   // ambiguity error

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi overload resolution işleminde gösterici ve referanslardaki "üst düzey (top level) olmayan" const ve volatile niteleyicisi 
	kaliteyi etkilemektedir. Her zaman kendi niteleyicine dönüştürme daha iyidir. Örneğin:

	void foo(const int *pi)			// 1
	{
		//...
	}
	
	void foo(int *pi)				// 2
	{
		//...
	}
	
	Aşağıdkai gibi bir çağrının yapıldığını varsayalım:

	const int a = 10;
	foo(&a);						

	Burada 1 numaralı fonksiyon seçilecektir. Çünkü 2 numaralı fonksiyon zaten uygun bir fonksiyon değildir. Dolayısıyla üçüncü adıma zaten yalnızca birinci 
	fonksiyon girmektedir. Çağrının şöyle yapıldığını varsayalım:

	int b = 10;
	foo(&b);						

	Burada her iki fonksiyon da aday ve uygundur. Ancak int * -> int * dönüştürmesi ile int * -> const int * dönüştürmesi kıyaslandığında int * -> int * 
	dönüştürmesi daha iyi kabul edilmektedir. Tabii aynı durum referanslar için de söz konusudur. Örneğin:

	void bar(int &r)				// 1
	{
		//...
	}
	
	void bar(const int &r)			// 2
	{
		//...
	}
	
	Çağrı şöyle yapılmış olsun:

	int a = 10;
	bar(a);		
	
	Aynı gerekçeyle burada yine 1 numaralı fonksiyon daha iyidir. Çağrı şöyle yapılmış olsun:

	bar(10);

	Burada 1 numaralı fonksiyon yine uygun bir fonksiyon değildir. Dolayısıyla 2 numaralı fonksiyon seçilecektir. 

	T1, T2 ve T3 birer tür belirtiyor olsun:

	T1 -> const T3 &
	T2 -> const T3 &

	Buradaki otomatik dönüştürmeler arasındaki kalite kıyaslaması referanslar dikkate alınmadan türlere bakılarak belirlenmektedir. Örneğin:

	int -> const int &
	int -> const double &

	Burada int -> const int & dönüştürmesi daha iyidir. Örneğin:

	char -> const int &
	char -> const double &

	Burada char -> const int & dönüştürmesi daha iyidir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(const int &r)          // 2
{
    cout << "const int &" << endl;
}

int main()
{
    int a{10};

    foo(a);         // 2

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir tür belirtmek üzere T ve T & parametrelerine sahip aynı isimli fonksiyonlar birlikte bulunabilir. Bunların imzaları farklıdır. Örneğin:

	void foo(int a)
	{
		//...
	}

	void foo(int &r)
	{
		//...
	}

	Ancak T bir belirtmek üzere T -> T dönüştürmesi ile T -> T & dönüştürme arasında bir kalite farklılığı yoktur. Her iki dönüştürme de "tam uyum (exact match)"
	kabul edilmektedir. Dolayısıyla aşağıdaki gibi bir çağrım geçerli değildir:

	int x = 10;
	foo(x);

	Burada her iki fonksiyon da "en uygun fonksiyon" durumundadır. 

	T bir tür belirtmek üzere:

	T -> T
	T -> const T &

	dönüştürmeleri arasında da bir kalite farkı yoktur. Benzer biçimde:

	const T -> T
	const T -> const T 6

	dönüştürmeleri arasında da bir kalite farklılığı yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(int a)          		// 2
{
    cout << "int" << endl;
}

int main()
{
    int a = 10;
    
    foo(a);     // ambiguity error!
    foo(10);    // 2 seçilir çünkü 1 uygun fonksiyon değil

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Default argüman almış parametre değişkenleri "overload resolution" işleminin üçüncü adımında hiç dikkate alınmamaktadır. Örneğin:

	void foo(int a, int b = 10)
	{
		//...
	}

	void foo(int a)
	{
		//...
	}

	Bu iki fonksiyonun aynı anda bulunmasında bir sorun yoktur. Çünkü bunların parametrik yapıları farklıdır. Şimdi fonksiyonu şöyle çağırmış olalım:

	foo(10);

	Bu çağrım error ile sonuçlanacaktır. Çünkü birinci fonksiyonun default argüman alan parametreleri zaten overload resolution işleminin üçüncü adımında 
	yokmuş gibi ele alınacaktır. Dolayısıyla burada her iki fonksiyon da en uygun fonksiyondur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İleride çokça karşılaşacağımız bir durum da sol taraf değeri referansı ve sağ taraf değeri referansı parametrelerine sahip aynı isimli fonksiyonlardır.
	Bunların birlikte bulunması bir soruna yol açmaz. Çünkü bunlar farklı türlerdendir ve overload edilebilirler. Örneğin:

	void foo(int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada foo fonksiyonu bir sdol taraf değeri ile çağrılırsa 2 numaralı fonksiyon, bir sağ taraf değeri ilke çağrılırsa 1 numaralı fonksiyon uygun fonksiyon olmaz. 
	Dolayısıyla bir "ambiguity" durumu yaşanmaz. Örneğin:

	int x = 10;
	foo(x);			// 1 numaralı fonksiyon çağrılır

	foo(10);		// 2 numaralı fonksiyon çağrılır

	Pekiyi sol taraf değeri referansı const olsaydı ve fonksiyon sağ taraf değeir ile çağrılsaydı ne olurdu? Örneğin:

	void foo(const int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada fonksiyonun şöyle çağrıldığını varsayalım:

	foo(10);

	Her iki fonksiyon da uygun fonksiyonlardır. Ancak bu durumda sağ taraf değeri referansına sahip olan fonksiyonun daha iyi bir dönüştürme uyguladığı kabul 
	edilmektedir. Dolayısıyla 2 numaralı fonksiyon seçilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli sol taraf değeri referansı paranetresine ve sağ taraf deeri referansı parametresine sahip olan iki fonksiyonun bulunduğu bir durumda biz bu
	fonksiyonu sol taraf değeri ile çağrıdığımızda sol taraf değeir referans parametreli fonksiyonun çağrılacağını yukarıda söylemiştir. Örneğin:

	void foo(int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada foo fonksiyonunu sol taraf değeri ile çağıralım:

	int x = 10;
	foo(x);

	Yukarıda da belirttiğimiz gibi zaten ikinci fonksiyon uygun fonksiyon olmadığı için birinci fonksiyon çağrılacaktır. Ancak ileride göreceğimiz bazı nedenlerden 
	dolayı bazen programcılar bu sol taraf değeri ile sağ taraf değeri referans parametresine sahip fonksiyonun çağrılmasını isteyebilmektedir. Bu nasıl sağlanabilir?
	Sol taraf değerini paranteze almak bize bir fayda sağlamamaktadır. Çünkü C++'a göre bir sol taraf değerini paranteze alsak da o solf taraf değeri olmaya
	devam etmektedir. Örneğin:

	foo((x));

	Burada yine birinci fonksiyon çağrılacaktır. int türüne dönüştümek geçici nesne oluşturacağı için fayda sağlayabilir. Örneğin:

	foo((int)x);		// foo(static_cast<int>(x));

	Ancak bu genel bir çözüm değildir. Çünkü T bir tür ve t de o türden bir sol taraf değeri belirtmek üzere biz her tür için (T)t işlemini yapamayız. 
	Sol taraf değerini sol taraf değeri referansına dönüştürürsek hiçbir fayda sağlayamayız. Örneğin:

	foo((int &)x);		// foo(static_cast<int &>(x));

	Burada yine bir numaralı fonksiyon çağrılacaktır. İşte bu işlemin en taşınabilir ve normalk yolu sol taraf değerini sağ taraf değeri referansına dönüştürmektir. 
	Örneğin:

	foo((int &&)x);		// static_cast<int &&>(x));

	Artık ikinci fonksiyon çağrılacaktır. Yukarıda da belirriğimiz gibi böyle bir gereksinim başka konularda karşımıza çıkacaktır. Bunu daha resmi olarak yapabilmek
	için C++'ın standart kütüphanesine C++11 ile birlikte move isimli bir fonksiyon eklenmiştir. move fonksiyonun bazı detrayları vardır. Ama yaptığı işlem 
	bir sol taraf değerini sanki sağ taraf değeri gibi işleme sokmaktır. Örneğin:

	foo(move(x));

	Burada ikinci fonksiyon çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													18. Ders 16/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Overload işlemi aynı faaliyet alanında yapılan bir işlemdir. Dolayısıyla "overload resolution" aynı faaliyet alanındaki aynı isimli fonksiyonlar arasında 
	yürütülmektedir. Başka bir deyişle "verload resolution" işlemi için "aday fonksiyonlar (candidate functions)" isim aramsı sırasında ismin bulunduğu faaliyet
	alanındaki fonksiyonlardan oluşturulmaktadır. Özellikle sonraki maddede açıklayacak olduğumuz isim alanları ve daha sonra görecek olduğumuz sınıflar konusunda 
	bunun önemi ortaya çıkacaktır. 

	Aşağıdaki örnekte main fonksiyonu içerisinde foo fonksiyonu çağrılmıştır. foo fonksiyonu main fonksiyonunun yerel bloğunda bulunduğu için artık o yerel 
	blokta bildirilen fonksiyonlar overload resolution işleminde aday fonksiyon olarak seçilecektir. Dolayısıyla double parametreye sahip olan foo aday fonksiyon 
	olmadığı için overload resolution işlemine girmeyecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(double a)
{
    cout << "double" << endl;
}

void foo(long a)
{
    cout << "long" << endl;
}

void foo(int a)
{
    cout << "int" << endl;
}

int main()
{   
    void foo(int a);            

    foo(3.14);          // int parametreli foo çağrılacak

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi farklı parametrik yapılara sahip aynı isimli fonksiyon tanımlamanın bize ne faydası vardır? Yani bu özellik C++'a neden eklenmiştir? NYPT birtakım 
	anahtar kavramların bileşimi olarak ele alınabilir. Bu anahtar kavramların hepsi aslında uzun kodların daha kolay algılanmasına	yönelik kavramlardır. İşte 
	NYPT'te benzer işlemleri yapan ama aralarında küçük farklılıklar bulunan fonksiyonlara özellikle aynı isimler verilmektedir. Böylece "sanki farklı çok sayıda
	fonksiyon var" algısından "tek bir fonksiyon var" algısına geçiş yapılır. Zaten NYPT insanın doğayı algılayış biçiminden modellenmiştir. Örneğin çok farklı 
	sandalyeler olabilir. Bunların renkleri yapıldığı malzemeler farklı olabilir. Ancak neticede bizim için hepsi oturulabilecek sandelyedir. Zaten doğada biribirinin 
	aynısı olan şeyler genellikle bulunmamaktadır. Dikkatle incelendiğinde aynı marka ve renkteki sandalyeler arasında da farklılıklar olduğunu görürüz. Ancak 
	bizim için o sandalyeler biribirinin aynısı gibidir. Görüldüğü gibi birtakım nesneleri farklılaştırmak algısal karışıklık yaratmaktadır. Benzer olanları 
	aynıymış gibi algılamak ise algısal açıklık sağlamaktadır. Eğer bizim bilişsel sistemimiz farklı olan ancak biribirine benzeyenleri aynıymış gibi ele alamasydı
	dünya beynimizin işleyebileceğinden çok daha karmaşık bir hale gelirdi. 

	İşte NYPT'de benzer işlemleri yapan ama ayrıntıda farklılar içeren fonksiyonlara aynı isimleri vermek iyi bir tekniktir. Örneğin:

	int abs(int a);
	long abs(long a);
	double abs(double a);
	...

	Burada abs fonksiyonlarının hepsi benzer işlemleri yapmaktadır. Yalnızca işlem yaptıkları tür farklıdır. O halde bunlara aynı isimleri vermek iyi bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    38) C++'ta global "isim kirliliğini (name pollution)" engellemek için "isim alanları (namespaces)" denilen C'de olmayan bir özellik bulunmaktadır. Farklı firma 
	ya da kurumların kütüphanelerinin bir arada kullanıldığı projelerde "isim çakışmaları (name collisions)" oluşabilmektedir. Örneğin A firmasının kütüphanesi 
	ile B firmasının kütüphanesini birlikte kullanırken bu iki firma tesadüfen bir yapı ya da sınıfa aynı isimleri vermiş olabilirler. Bu önemli bir problemdir. 
	Biz her iki firmanın kütüphanelerini kullanmak için onların başlık dosyalarını include ettiğimizde isim çalışması nedeniyle error'ler oluşacaktır. İşte isim 
	alanları bu problemleri ortadan kaldırmak için düşünülmüştür. Örneğin A firmasının kütüphanesi ile B firmasının kütüphanesini birlikte kullanmak isteyelim. 
	Bunun için iki firmanın oluşturduğu başlık dosyalarını include edelim:

	#include "a.hpp"
	#include "b.hpp"

	İki firma da tesadüfen bir yapıya aynı ismi vermiş olabilir. Bu durumda derleme sırasında error oluşacaktır. Bu error'leri pratik bir biçimde düzeltmek de 
	mümkün değildir. Çünkü kütüphane derlenmiştir ve oradaki isimler object modüllere çoktan yazılmıştır. Yani çakışan isimleri başlık dosyasında dğeiştirmek 
	bir fayda sağlamayacaktır. 

	Bir isim alanı bildiriminin genel biçimi şöyledir:

	namespace <isim> 
	{
		// namespace içindeki eleman bildirimleri
	}

	İsim alanları global bölgede bildirilirler. Yerel isim alanları oluşturmak mümkün değildir. Global alanda yapılabilen tüm bildirimler ve tanımlamalar isim 
	alanları içerisinde de yapılabilmektedir. İsim alanları içerisindeki fonksiyonlar yine global fonksiyonlardır. İsim alanları içerisinde tanımlanmış olan 
	değişkenler yine global değişkenlerdir. İsim alanları yalnızca isimleri farklılaştırma işlevini görmektedir. Her isim alanı farklı bir faaliyet alanı 
	belirtmektedir. 

	Aynı isim alanı içerisinde aynı isimli birden fazla değişken tanımlanamaz. Ancak farklı isim alanlarında aynı isimli değişkenler tanımlanabilmektedir. (Farklı 
	isim alanlarındaki aynı isimli fonksiyonlar için "overload" terimi kullanılmaz. Çünkü "overload" aynı faaliyet alanındaki fonksiyonlar için kullanılmaktadır.) 
	Yerel bir bloğun içerisinde isim alanı oluşturulamamaktadır. İsim alanları global bölgede oluşturulmak zorundadır.

	Bir isim alanı içerisindeki bir isme isim alanı ismi ve :: operatörü ile erişilir. :: operatörü iki operandlı araek bir operatördür. Bu operatöre 
	"çözünürlük operatörü (scope resolution operator)" denilmektedir. Örneğin:

	CSD::foo();

	gibi bir ifadede foo fonksiyonunun CSD isim alanı içerisinde olduğunu belirtmekteyiz. Çözünürlik operatörü aslında başka bağlamlarda da kullanılmaktadır. 
	Burada çözünürlük operatörünün solundaki opendın isim alanı ismi, sağındaki operandın o isim alanı içerisindeki bir isim olduğuna dikkat ediniz. Çözünürlük 
	operatörü ile belirtilen isimlere "niteliklendirilmiş (qualified)" isimler denilmektedir. 

	Her kurum global isimlerini kendine özgü bir isim alanı içerisinde oluşturursa global isim kirliliği büyük ölçüde (ama tamamen değil) engellenmiş olmakradır.

	İsim alanına benzer benzer kavramlar pek çok yeni dilde de bulunmaktadır. Örneğin bu kavram Java'da "paket (package)", Python'da "modül (module)" ismiyle 
	karşımıza çıkmaktadır. C# her ne kadar büyük ölçüde Java'dan kopya çekilmişse de kendini C++'a dah fazla yaklaştırmıştır. C# C++'ın isim alanlarını basitleştirerek 
	bünyesine katmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    int a = 10;

    void foo()
    {
        cout << "CSD::foo" << endl;
    }
}

namespace Other
{
    int a = 20;

    void foo()
    {
        cout << "Other::foo" << endl;
    }
}

int main()
{
    cout << CSD::a << endl;
    cout << Other::a << endl;

    CSD::foo();
    Other::foo();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe (nested) isim alanları söz konusu olabilir. Bu durumda içteki isim alanınının elemanlarına dışarıdan birden fazla çözünürlük operatörü kullanılarak 
	erilişir. Örneğin:
	
	namespace CSD
	{
		namespace Util
		{
			void foo()
			{
				cout << "CSD::Util::foo" << endl;
			}
		}

		void foo()
		{
			cout << "CSD::foo" << endl;
		}
    
	}

	int main()
	{   
		CSD::foo();
		CSD::Util::foo();

		return 0;
	}

	Birbirlerini kapsayan isim alanlarında da aynı isimli değişkenler bulunabilirler. Bunlar birbirleriyle karışmaz. Bu örnekteki foo fonksiyonlarından biri
	doğrudan CSD isim alanı içerisinde diğeri ise CSD isim alanı içerisindeki Util isim alanı ieçrisindedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    namespace Util
    {
        void foo()
        {
            cout << "CSD::Util::foo" << endl;
        }
    }

    void foo()
    {
        cout << "CSD::foo" << endl;
    }
    
}

int main()
{   
    CSD::foo();
    CSD::Util::foo();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç bir isim alanı C++17 ile birlikte artık hamlede bildirilebilmektedir. Örneğin:

	namespace A::B::C 
	{
		void foo()
		{
			//...
		}
	}

	Burada foo fonksiyonu A isim alanının içerisindeki B isim alanının içerisindeki C isim alanının içerisine yazılmıştır. Yani aşağıdaki bildirim yukarıdaki ile 
	eşdeğerdir:

	namespace A
	{
		namespace B 
		{
			namespace C
			{
				void foo()
				{
					//...
				}
			}
		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A::B::C
{
    void foo()
    {
        cout << "A::B::C::foo" << endl;
    }
}

int main()
{
   A::B::C::foo();
   
    return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir isim alanı ismi dışarıdan çözünürlük operatörü ile isim alanı ismini belirterek kullanabiliyorduk. Ancak aynı isim alanı içerisindeki bir isim doğrudan 
	kullanılabilmektedir. Örneğin:

	namespace CSD
	{
		int g_x;

		void foo()
		{
			cout << g_x << endl;		// geçerli
		}
	}

	Burada foo fonksiyonu g_x değişkenini hiç niteliklendirmeden doğrudan kullanabilmektedir. Çünkü foo fonksiyonunun kendisi de aynı isim alanı içeisindedir. 
	Niteliksiz isim arama (unqualified name lookup) sırasında isim alanlarına içten dışa doğru bakılmaktadır. Dolayısıyla iç bir isim alanı onun dışındaki isimleri 
	de niteliklendirmeden kullanabilir. İsim aramsı (name lookup) ayrıntıları ileride ele alınacaktır. Örneğin:

	namespace CSD
	{
		int g_x;

		namespace Util
		{
			void foo()
			{
				cout << g_x << endl;		// geçerli
			}
		}
	}

	Burada g_x değişkeni Util isim alanı içerisinde değildir, util isim alanını kapsayan isim alanı ieçrisindedir. Ancak g_x aranırken isim alanlarına içten dışa 
	doğru bakıldığı için g_x bulunacaktır. 
	
	İsim alanları ayrı faaliyet alanları belirtmektedir. Faaliyet alanı kuralına niteliksiz aramalarda göre dar faaliyet alanındaki isme erişilir. Örneğin:

	namespace CSD
	{
		int g_x;

		namespace Util
		{
			int g_x;

			void foo()
			{       
				cout << g_x << endl;        // Buradaki g_x kendi isim alanındaki g_x. CSD::g_x görünür (visible) değil
			}
		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aynı isim alanını birden fazla kez bildirmek tamamen geçerli bir durumdur. Bu durum isim alanına ekleme yapıldığı anlamına gelir. Örneğin:

	namespace CSD
	{
		void foo()
		{
			//...
		}
	}
	
	//...

	namespace CSD
	{
		void bar()
		{
			//...
		}
	}

	Burada foo ve bar fonksiyonlarının her ikisi de CSD isim alanı içerisindedir. Yani isimn alanları tek parça olarak yazılmak zorunda değildir. Tabii aynı isim 
	alanı içerisinde aynı isimli tek bir değişken tanımlamabilir. Örneğin:

	namespace CSD
	{
		int g_x;
	}
	
	//...

	namespace CSD
	{
		int g_x;		// geçersiz! aynı isim alanında aynı isimli tek bir değişken tanımlanabilir
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
    void foo()
    {
        cout << "A::foo" << endl;
    }
}

namespace A                 // geçerli
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main()
{
    A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii farklı isim alanlarının içerisindeki aynı isim alanları aslında farklı isim alanlarıdır. Burada ekleme işlemi söz konusu değildir. Örneğin:

	namespace A 
	{
		namespace B
		{
			//...
		}
	}

	namespace B
	{
		//...
	}

	Buradaki B isim alanları tamamen farklı isim alanlarıdır. Dolayısıyla birleştirilmezler. Aynı isim alanlarının içindeki aynı isimli isim alanalrı 
	birleştirilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    namespace A
    {
        void foo()
        {
            cout << "A::foo" << endl;
        }
    }
}

namespace A
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main()
{
    CSD::A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hiçbir isim alanının içerisinde olmayan global bölge de bir isim alanı belirtmektedir. O bölgeye "global isim alanı (global namespace)" denilmektedir. 
	Örneğin:

	namespace CSD
	{
		void foo()
		{
			//...
		}
	}

	void bar()
	{
		//...
	}

	int main()
	{
		//...
	}

	Burada bar fonksiyonu global isim alanı içerisindedir. CSD isim alanı da global isim alanı içerisindedir. Her isim alanınının doğrudan ya da dolaylı olarak
	global isim alanı içerisinde olduğuna dikkat ediniz. main fonksiyonu da global isim alanı içerisindedir. İsim alanlarını bir dizin (directory) ağacına 
	benzetirsek global isim alanını kök dizine benzetebiliriz. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{	
    void foo()                  // global isim alanı içerisindeki CSD isim alanının içerisinde
    {
        cout << "A::foo" << endl;
    }	
}

void foo()                  // global isim alanının içersinde
{
    cout << "foo" << endl;
}

int main()
{
    CSD::foo();     // CSD'nin içerisindeki foo çağrılıyor
    foo();          // global isim alanı içerisindeki foo çağrılıyor

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun prototipi bir isim alanı içerisinde bildirilip tanımlaması onu kapsayan herhangi bir isim alanında niteliklendirilerek yapılabilir. Örneğin:

	namespace CSD
	{
		void foo();
		//...
	}

	void CSD::foo()		// geçerli
	{
		//...
	}

	Burada foo fonksiyonu aslında CSD isim alanı içerisindedir. Ancak tanımlaması global isim alanında yapılmıştır. Tanımlama sırasında foo isminin nitelikli 
	bir biçimde belirtildiğine dikkat ediniz. Örneğin:

	namespace CSD
	{
		namespace Util
		{
			void foo();
			//...
		}
		
		void Util::foo()		// geçerli
		{
			//...
		}
	}

	Burada prototip bildirimi CSD::Util içerisinde yapılmış, tanımlama onu kapsayan CSD isim alanı alnı içerisinde yapılmıştır. Tabii tanımlamanın hemen bir 
	yukarıdaki isim alanı içerisinde yapılması zorunlu değildir. Kapsayan herhangi bir isim alanı içerisinde yapılabilir. Örneğin:

	
	namespace CSD
	{
		namespace Util
		{
			void foo();
			//...
		}
		//...		
	}

	void CSD::Util::foo()		// geçerli
	{
		//...
	}
	
	Global isim alanının CSD isim alanını kapsadığına dikkat ediniz. 

	Ancak prototip de tanımalamada kapsayan isim alanında yapılamaz. En azından prototipin kendi isim alanınde bildirilmesi gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	namespace B
	{
		void foo();
		void bar();
		void tar();
		//...

		void foo()
		{
			cout << "A::B::foo" << endl;
		}
	}

	void B::bar()
	{
		cout << "A::B::bar" << endl;
	}
}

void A::B::tar()
{
	cout << "A::B::tar" << endl;
}

int main()
{
	A::B::foo();
	A::B::bar();
	A::B::tar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Çözünürlük operatörünün tek operandlı (unary) biçimi de vardır. Tek operand'lı kullanım şöyledir:

	::<isim>
	
	Çözünürlük operatörünün tek operand'lı biçimi isim aramasını global isim alanında yapmaktadır. Örneğin:	

	::foo();

	Burada global isim alanındaki foo çağrılmıştır. Eğer isim global isim alanında bulunamazsa başka bir isim alanına bakılmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo()
{
	cout << "foo" << endl;
}

namespace CSD
{
	void foo()
	{
		cout << "CSD::foo" << endl;
	}

	void bar()
	{
		foo();		// CSD::foo
		::foo();	// global isim alanındaki foo
	}
}

int main()
{
	CSD::bar();

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında önce isim araması yapılır. İsim bulunursa ismin bulunduğu faaliyet alanındaki aynı isimli fonksiyonlar aday fonksiyon olarak 
	overload resolution	işlemine sokulur. Daha üst isim alanlarındaki fonksiyonlar aday fonksiyon olarak seçilmezler. Yani overload işlemi aynı isim alanındaki 
	aynı isimli fonksiyonların bulunması anlamına gelmektedir. Örneğin:

	void foo(double a)
	{
		cout << "::foo, int" << endl;
	}

	void foo(long a)
	{
		cout << "::foo, long" << endl;
	}

	namespace CSD
	{
		void foo(int a)
		{
			cout << "CSD::foo, int" << endl;
		}

		void bar()
		{
			foo(3.2);		// CSD::foo, int çağrılır
		}
	}

	Burada CSD::bar fonksiyonunda foo fonksiyonu double bir argümanla çağrılmıştır. Niteliksiz isim aramada CSD içerisindeki foo fonksiyonu bulunacaktır. İşte 
	artık aday fonksiyonlar CSD isim alanı içerisindeki foo fonksiyonları olacaktır. Bu örnekte global isim alanı içerisinde "tam uyum (exact match)" sağlayan
	bir foo fonksiyonu olsa da o fonksiyonun çağrılmayacağına dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	void foo(const char *str)
	{
		cout << "A::foo const char *" << endl;
	}

	namespace B
	{
		void foo(double a)
		{
			cout << "A::B::foo double" << endl;
		}

		namespace C
		{
			void foo(int a)
			{
				cout << "A::B::C::foo int" << endl;
			}

			void bar()
			{
				foo(12.3);		// A::B::C::foo çağrılıyor
				foo("ankara");	// geçersiz!
			}
		}
	}
}

int main()
{
	A::B::C::bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											19. Ders 18/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi içerisindeki ve C++'ta C'nin standart kütüphanesi içerisindeki tüm öğeler "std" isimli bir isim alanı içerisine yerleştirilmiştir. 
	Bu nedenle bu isimler kullanılırken isimlerin "std" ismi ile niteliklendirilmesi gerekir. Aksi takdirde isimler global isim alanında aranır ve o isim alanında
	bulunamayacaklardır. Örneğin:

	std::cout << a << std::endl;

	Biz şimdiye kadar böyle bir niteliklendirme yapmadık. Bunun nedeni programın yukarısa using namespace denilen direktifi yerleştirmiş olmamızdır:

	using namespace std;

	Bu direktif sayesinde std isim alanındaki isimleri kullanırken niteliklendirmeyi elimine etmekteyiz. Ancak bazı programcılar bu direktifi kullanmazlar ve 
	std isim alanındaki isimlere nitelikli bir biçimde erişirler. Böyle kodlçar görürseniz yadırgamamalısınız. Biz kursumunda gebel olarak bu direktiften 
	faydalanacağız. Bu direktifin işlevi izleyen paragraflarda ele alınmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdio>

int main()
{
	std::cout << "this is a test" << std::endl;
	
	std::printf("this is a test\n");

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Farklı isim alanları içerisindeki aynı değişkenlerin birbirleriyle karışmaması nasıl sağlanmaktadır. Aslında amaç dosya (object file) formatlarında isim alanı
	biçiminde bir kavram yoktur. Yani isim alanları C++'ın bir kabulüdür. Aslında C Programala Dili C++ Programlama Dilinden daha doğaldır. Burada "doğallık" 
	makinede olanları daha doğrudan ifade etme ve ona yakınlık anlamında kullanılmaktadır. C++ C'den yüksek seviyeli bir programlama dilidir. Örneğin bir şey 
	"C'de böyle ancak C++'ta şöyle yapılıyorsa" gerçekte C'deki gibi yapılmaktadır. İşlemciler C'deki gibi çalışmaktadır. C++'taki pek çok kavram NYPT'yi uygulamak
	dile eklenmiş yapay kavramlardır. Örneğin amaç kod düzeyinde isim alanı diye bir kavram yoktur. Sınıf diye de bir kavram yoktur. 

	Derleyiciler isim alanları içerisindeki isimleri amaç dosyaya (object file) isim alanı isimleriyle kombine ederek yazmaktadır. Bu nedenle farklı isim alanlarının 
	içerisindeki aynı isimler aslında amaç dosyada farklı isimler gibi bulurlar. Tabii daha önceden de belirttiğimiz gibi isim dekorasyonu (name decoration) 
	derleyiciden derleyiciye değişebilmektedir. Bu nedenle bir derleyicide oluşturulmnuş bir amaç dosya diğer derleyicide kullanılamamaktadır. Örneğin;:

	namespace CSD
	{
		namespace Util
		{
	
			int x;
		}
	}

	Buradaki x ismini Microsoft derleyicileri amaç dosyaya şöyle yazmaktadır:

	?x@Util@CSD@@3HA

	Aynı ismi g++ derleyicisi amaç dosyaya şöyle yazmıştır:

	ZN3CSD4Util1xE

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun başka bir modülde (yani başka bir C++ kaynak dosyasında) tanımlanmış olduğunu ya da kütüphane içerisinde bulunduğunu varsayalım. Bi bu 
	fonksiyonu başka bir modülden (C++ kaynak dosyasından) kullanmak istiyorsak onun prototipini bulundurmamız gerekir. Fonksiyonun kendisi link aşamasında 
	linker tarafından bulunmaktadır. Tabii bu prototip bildiriminin aynı isim alanı içerisinde yapılması gerekmktedir. Örneğin:

	namespace CSD
	{
		void foo();
		//...
	}

	Buraki fonksiyonlar muhtemelen başka bir kaynak dosya içerisinde CSD alanında tanımlanmıştır. Bizim bu isimleri başka bir kaynak dosyadan kullanabilmemiz için 
	prototip bildirimini de aynı isim alanı içerisinde yapmalıyız. Bunun yukarıdakinden daha bir prtaik bir yolu yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İsim alanı bildirimi yapılırken namespace anahtar sözcüğünden sonra isim alanı ismi belirtilmeden doğrudan blok açılırsa böyle isim alanlarına "isimsiz isim
	alanları (unnamed namespace)" denilmektedir. Örneğin:

	namespace 
	{
		int g_x;

		void foo()
		{
			//...
		}
	}
	
	Burada g_x ve foo isimsiz isim alanı içerisindedir. İsimsiz isim alanlarındaki isimler o isimsiz isim alanı hangi isim alanı içerisinde bildirilmişse sanki 
	o isim alanındaki isimler gibi kullanılabilmektedir. Yukarıdaki örneğimizde isimsiz isim alanı global isim alanı içerisinde bildirilmiştir. (Genellikle hep 
	böyle yapılır.) o halde biz g_x ismini ve foo ismini sanki global isim alanındaymış gibi kullanabiliriz. Örneğin:

	#include <iostream>

	using namespace std;

	namespace 
	{
		int g_x;

		void foo()
		{
			cout << "foo" << endl;
		}
	}

	int main()
	{
		g_x = 10;				// geçerli

		foo();					// geçerli

		cout << g_x << endl;	// geçerli

		return 0;
	}

	Pekiyi isimsiz isim alanları neden kullanılmaktadır? İsimsiz isim alanlarını gören derleyici aslında bu isim alanlarına kendisi "tek (unique)" olan bir isim 
	uydurmaktadır. Yani örneğin:

	namespace 
	{
		//...
	}

	gibi bir isimsiz isim lanaı bildirimi aşağıdaki ile eşdeğerdir:

	namespace compiler_generated_unique_named
	{
		//...
	}

	using namespace compiler_generated_unique_named;

	Yani aslında isimsiz isim alanı içerisindeki isimler amaç dosyaya derleyici tarafından üretilmiş olan bir isim alanı ismi eşliğinde yazılmaktadır. Dolayısıyla
	farklı C++ kaynak dosyalarındaki isimsiz isim alanları içerisindeki aynı isimler karışmamaktadır. Çünkü derleyici her kaynak dosyadaki isimsiz isim alanını 
	diğerlerinden farklı olacak bir isim ile kombine ederek amaç dosyaya yazmaktadır. İşte isimsiz isim alanları "modüle özgü global değişken oluşturabilmek"
	için kullanılmaktadır. Farklı modüllerdeki isimsiz isim alanları içerisinde aynı isimli değişkenler bulunabilir. Anımsanacağı gibi modüle özgü global değişkenler
	C'de "static" anahtar sözcüğü ile "static global" değişkenler olarak oluşturulmaktadır. C++'ta her ne kadar static global değişken bildirimi yine varsa da
	bu yöntem "modüle özgü global değişken oluşturabilmek için" kötü bir teknik olarak kabul edilmektedir. static global değişkenler yerine C++'ta "isimsiz isim 
	alanları (unnamed namespaces)" kullanılmalıdır. Tabii derleyiciler isimsiz isim lanalarının içerisindeki değişkenleri aslında amaç dosyaya PUBLIC olarak 
	yazmamaktadır. Yani tıpkı static global değişkenlerde olduğu gibi bu değişkenler gerçekten ismi biliniyor olsa bile başka bir modülden extern bildirimi ile 
	kullanılamamaktadır. Başka bir deyişle aslında isimsiz isim alanınındaki isimlerin static belirleyicisi ile oluşturulmuş isimlerden link işlemi bakımından 
	bir farklılık oluşmamaktadır. 

	İsimsiz isim alanları başka isim alanlarının içerisinde de olabilmektedir. Örneğin:

	namespace CSD
	{
		namespace 
		{
			int g_x;
			//...
		}
	}

	Buradaki g_x ismi sanki CSD isim alanındaymış gibi kullanılabilir. Örneğin biz bu ismi CSD::g_x biçiminde kullanabiliriz. Tabii bu isimlerin de başka bir 
	modülden (C++ kaynak dosyasından) kullanılma olanağı yoktur. Yukarıdaki bildirimin eşdeğerini şöyle düşnebilirsiniz:

	namespace CSD
	{
		namespace compiler_generated_unique_name
		{
			int g_x;
			//...
		}

		using namespace compiler_generated_unique_name;
	}

	using namespace direktifi izleyen paragraflarda ele alınmaktadır. 

	Tabii aynı isim alanı içerisindeki isimsiz isim alanları yine tek bir isimsiz isim alanı biçiminde birleştirilmektedir. Başka bir deyişle biz isimsiz isim 
	alanlarını da tek parça olarak yazmak zorunda değiliz. 

	İsimsiz isim alanı içerisindeki değişkenlerle aynı isimli üst isim alanında değişkenler bulunabilir. Bu durum bir soruna yol açmaz. Örneğin:

	namespace 
	{
		int g_x = 10;
		//...
	}

	int g_x;

	Ancak bu örnekte her iki g_x değişkeni de isim aramsı sırasında sanki global isim alanındaymış gibi bir etki oluşacağına göre bu ismin niteliksiz kullanımı
	soruna yol açacaktır. Örneğin:

	cout << g_x << endl;		// geçersiz! hangi g_x olduğu belli değil

	Tabii global olana erişmek için tek operand'lı çözünürlük operatöründen faydalanabiliriz. Örneğin:

	cout << ::g_x << endl;		// geçerli, global isim alanındaki g_c kullanılıyor.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte inline isim alanları biçiminde bir isim alanı türü de dile eklenmiştir. inline isim alanları herhangi bir isim alanının içerisinde 
	bildirilebilir. Bildirim sırasında inline anahtar sözcüğü de kullanılmaktadır. Örneğin:

	inline namespace CSD
	{
		//...
	}

	inline anahtar sözcüğünün fonksiyonlarla kullanımını görmüştük. Ancak buradaki inline anahtar sözcüğünün inline fonksiyonlardaki inline anahtar sözcüğü ile 
	semantik bir benzerliği yoktur. inline isim alanı içerisindeki isimler inline alanı hangi isim alanının içerisinde bildirilmişse sanki o isim alanındaki 
	isimlermiş gibi kullanılabilmektedir. (Anımsanacağı gibi isimsiz isim alanlarındaki isimler de bu biçimde kullanılabiliyordu) Örneğin:
		
	inline namespace CSD
	{
		int g_x;

		void foo()
		{
			cout << "CSD" << endl;
		}
	}

	Biz burada G-x ve foo isimlerini inline CSD isim alanı içerisinde bildirdik. CSD isim alanı global isim alanı içerisinde olduğu için sanki bu isimler 
	global isim alanı içerisindeymiş gibi de kullanılabilmektedir. Örneğin:

	g_x = 10;					// geçerli, niteliklebdirmeye gerek yok

	cout << g_x << endl;		// geçerli, niteliklendirmeye gerek yok

	foo();						// geçerli, niteliklendirmeye gerek yok

	Tabii istersek yine bu isim alanındaki isimleri nitelikli de kullanbiliriz:

	
	CSD::g_x = 10;				// geçerli, açıkça niteliklendirme yapılmış

	cout << CSD::g_x << endl;	// geçerli, açıkça niteliklendirme yapılmış

	CSD::foo();					// geçerli, açıkça niteliklendirme yapılmış

	Pekiyi bunun anlamı nedir? Aslında inline isim alanları o kadar sık kullanılabilecek bir özellik değildir. Özellikle kütüphanelerin farklı versiyonlarının 
	kolay bir biçimde default hale getirilmesi için düşünülmüştür. Örneğin:

	namespace CSD
	{
		namespace utilV1 
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		inline namespace utilV2
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}
		//...
	}

	Burada aslında CSD isim alanı içerisinde foo ve bar fonksiyonları bulunmaktaymış. Ancak zamanla bu fonksiyonların ileri versiyonları oluşturulmuş. Programcı da
	eski versiyonları muhafaze ederek yeni versyionları default hale getirmek istemiş olabilir. Burada UtilV2 içerisindeki isimler sanki CSD içerisindeymiş 
	gibi bir etki oluşmaktadır. Daha ileride bu kütüphanein üçüncü versiyonu çıkartıldığnda programcı muhtemelen şöyle yapacaktır:

	namespace CSD
	{
		namespace utilV1 
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		namespace utilV2
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		inline namespace utilV3
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}
		//...
	}

	Eski versiyonlara yine erişilebildiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											20. Ders 23/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   39) Gereksiz niteliklendirmeyi elimine edebilmek için "using namespace direktifi" denilen bir direktiften faydalanılmaktadır.  using namespace direktifinin 
   genel biçimi şöyledir:

	using namespace <isim_alanı_ismi>;

	Burada isim alanı ismi tek bir isimden olaşabileceği gibi :: operatörü kullanılarak oluşturulan iç bir isim alanı da olabilir. Örneğin:

	using namespace CSD;
	using namespace CSD::Util::Test
	using namespace std;

	using namespace direktiflerinin ayrı ayrı oluşturulması gerekmektedir. Aşağıdaki gibi bir arada oluşturulamamaktadır:

	using namespace CSD, CSD::Util, std;		// geçersiz! böyle bir sentaks yok

	Bu direktiflerin aşağıdaki gibi ayrı ayrı oluşturulması gerekir:

	using namespace CSD;
	using namespace CSD::Util;
	using namespace std;

	using namespace direktifi bir isim alanına ya da yerel bir bloğa yerleştirilebilir (bir sınıf içerisine yerleştirilemez). Tabii using namespace direktifinde 
	belirtilen isim alanının daha önce derleyici tarafından görülmüş olması gerekmektedir. Yani önce isim alanı bildirimi yapılmalı daha sonra o isim alanı için 
	using namespace direktifi kullanılmalıdır. Olmayan bir isim alanına using namespace direktifi uygulanamaz. 

	using namespace direktifini ele almadan önce "isim araması (namelookup)" denilen bir kavramdan kısaca bahsedeceğiz. İsim araması kavramı C standratlarınd olmayan 
	C++'ın karmaşıklığı nedeniyle C++ standartlarına bulunan bir kavramdır. Derleyici bir isim ile karşılaştığında o isme ilişkin bir bildirimi bulmaya çalışır. 
	Çünkü her ismin bir bildirimi olmak zorundadır. İşte derleyici isimleri sırasıyla bazı faaliyet alanlarında aramaktadır. İsim bir faaliyet alanında bulunursa
	başka bir faaliyet alanına bakılmamaktadır. Yani arama isim bulunamadığı sürece devam ettirilmektedir. Örneğin C'de (her ne kadar bu kavram C'de yoksa da)
	yerel bir blokte bir isim kullanıldığında önce o ismin bildirimi içten dışa doğru yerel bloklarda aranmaktadır. Nihayet bu yerel bloklarda bulunamazsa global 
	alana da bakılmaktadır. C++'ta isim araması iki grubua ayrılmaktadır:

	1) Niteliksiz isim araması (unqualified name lookup)
	2) Nitelikli isim arama (qualified name lookup)

	Çözünürlük operatörü olmadan yazılmış isimlerin aranması ve çözünürlük operatörlerinin en solundaki isimlerin aranması niteliksiz isim arama kurallarına göre 
	yapılmaktadır. Örneğin:

	a = 10;
	CSD::Util::foo();

	Burada a ve CSD isimleri niteliksiz isim arama kurallarına göre aranmaktadır. 

	Çözünürlük operatörünün sağındaki isimler nitelikli isim arama kurallarına göre aranmaktadır. Örneğin:

	std::cout << "test" << std::endl;

	Burada std niteliksiz isim arama kurallarına göre cout ve endl nitelikli isim arama kurallarına göre aranmaktadır. İsim araması biraz karmaşık bir konudur. 
	Çünkü ileride görülecek başka konular da devreye girdiğinde konu biraz da ayrıntılı hale gelmektedir. Ancak biz bu aşamada en basit bir biçimde diğer konuları 
	hiç dikkate almadan isim araması konusunda bazı şeyler söylmek istiyoruz. Niteliksiz isim araması kabaca şu aşamalarla yapılmaktadır (else-if biçiminde):

	1) İsim kullanıldığı bloğun içerisinde kullanım yerine kadar olan yerel bölgede aranır. 
	2) İsim yerel bloğu kapsayan yerel bloklarda içten dışa doğru değişkenin kullanıldığı bölgede sırasyla aranır. 
	3) İsim yerel bloğun ilişkin olduğu fonksiyonun içinde bulunduğu isim alanında kullanım yerine kadarki bölgede aranır.
	4) İsim kapsayan isim alanlarında içten dışa doğru kullanım yerine kadarki bölgede aranır. 
	5) İsim nihayet global isim alanında kullanım yerine kadarki bölgede aranır.

	Niteliksiz isim aramasını şuna benzetebiliriz: "Biz arkadaşımıza Ahmet'i gördün mü?" diye bir soru soralım. Arkadaşımız Ahmet'i önce arkadaş çevresinde, bulamazsa
	okulda, bulamazsa şehirde, bulamazsa ülkede, bulamazsa dünyada bulamazsa evrende arayacaktır. 

	Nitelikli isim aramada isim kabaca (ayrıntıları vardır) ilgili isim alanında aranmaktadır. Eğer isim o isim alanında bulunamazsa kapsayan isim alanlarına 
	bakılmamaktadır. Örneğin:

	CSD::a = 10;

	Burada a değişkeni CSD isim alanında aranır. Eğer orada bulunmazsa CSD'yi kapsayan isim alanlarında arama yapılmamaktadır. Nitelikli isim aramayı da şuna 
	benzetebiliriz: Biz arkdaşımıza "Okuldaki Ahmet'i gördün mü?" diye sorsaydık. Arkadaşımız Ahmet'i yalnızca okulda arardı. Okulda bulmazsa şehre bakmazdı. 
	Çünkü biz zaten onun okulda olması gerektiğini söylemiş olmaktayız. 

	using namepspace direktifinde iki isim alanı söz konusudur. Birincisi direktifin yerleştirildiği isim alanı, ikincisi direktifte belirtilen isim alanı. Eğer 
	direktif bir yerel bloğa yerleştirilmişse direktifin yerleştirildiği isim alanı o yerel bloğu kapsayan isim alanıdır. 

	Derleyici using namespace direktifini gördüğünde önce direktifin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim alanını 
	tespit eder. Örneğin:

	namespace A
	{
		namespace B
		{
			//...
		}

		using namespace B;
		//...
	}

	Burada direktifin yerlşetirildiği isim alanı A'dır. Direktifte belirtilen isim alanı ise B'dir. İkisini kapsayan en dar isim alanı A'dır. Örneğin:

	using namespace std;

	Burada direktifin yerleştirildiği isim alanı global isim alanıdır. Direktifte belirtilen isim alanı ise std isim alanıdır. İkisini de kapsayan en dar isim alanı 
	global isim alanıdır. Örneğin:

	namespace A
	{
		namespace B
		{
			namespace C
			{
				//...
			}
		}

		using namespace B::C;
		//...
	}

	Burada direktifin yerleştirildiği isim alanı A, direktifte belirtilen isim alanı A::B::C'dir. İki isim alanını kapsayan en dar isim alanı A'dır.
	
	
	using direktif şöyle etki göstermektedir: Niteliksiz isim araması (unqualified name lokkup) sırasında sanki direktifte belirtilen isim alanının 
	içerisindekiler direktifin yerleştirildiği ve direktifte belirtilen isim alanı kapsana en dar isim alanına enjekte edilmiş gibi olmaktadır. Ancak 
	bu enjekte edilme niteliksiz isim aramaları (unqualified name lookup) sırasında (yani doğrudan yazılan isimlerin aranması sırasında) ve yalnızca
	direktifin yerleştirildiği faaliyet alanında etkili olmaktadır. Örneğin:
	
	#include <iostream>

	using namespace std;

	int main()
	{
		cout << "this is a test" << endl;

		return 0;
	}

	Burada cout ve endl isimleri aranırken sanki std isim alanı içerisindeki her şey global isim alanındaymış gibi bir etki oluşmaktadır. Böylece cout ve endl 
	isimleri aslında std isim alanında olduğu halde derleyici tarafından global isim alanında bulunacaktır.
	
	Tabii niteliksiz isim araması sırasında aranan isim using direktifinin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim
	alanına kadar bulunursa zaten direktifin bir etkisi kalmamaktadır. Örneğin:

	namespace CSD
	{
		int a;
	}

	using namespace CSD;

	int main()
	{
		int a;

		a = 10;				// yerel a, CSD isim alanındaki a değil

		return 0;
	}

	Burada main fonksiyonunun içerisindeki a ismi (a = 10'daki a ismi) zaten yerel blokta bulunacaktır. Dolayısıyla CSD içerisndeki a sanki global isim alanı 
	içerisindeymiş gibi oluşan etki burada bir fayda sağlamayacaktır. 

	using namespace direktifinin etki göstermesi için niteliksiz isimlerin aranmasında direktifin yerleştirildiği isim alanına baklıyor olması gerekmektedir. 
	Aksi takdirde bu direktif ilgili ismin aranmasında bir etki göstermemektedir. Örneğin:

	namespace A
	{
		namespace B
		{
			namespace C
			{
				using namespace std;

				void foo()
				{
					cout << "A::B::C::foo" << endl;		// geçerli
				}
			}
		}
	}

	int main()
	{
		cout << "this is a test" << endl;		// error!

		return 0;
	}

	Burada A::B::C içerisine yerleştirilmiş olan using namespace direktifi main fonksiyonundaki isimlerin aranmasında etkili olmaz. Çünkü main fonksiyonundaki 
	isimlerin aranması sırasında using namespace direktifi görülmemektedir. Örneğin:

	using namespace std;

	namespace A
	{
		namespace B
		{
			namespace C
			{
				void foo()
				{
					cout << "A::B::C::foo" << endl;		// geçerli
				}
			}
		}
	}

	int main()
	{
		cout << "this is a test" << endl;		// geçerli

		return 0;
	}


	Artık hem A::B::C::foo içerisindeki hem de main içerisindeki isimlerin aranmasında direktif etkili olacaktır. 

	using namespace direktifi bir yerel bloğa yerleştirilirse yalnızca o yerel bloktaki niteliksiz aramalarda direktif görüleceği için etki yalnızca o yerel 
	blokta oluşacaktır. Örneğin:

	int main()
	{
		using namespace std;

		cout << "this is a test" << endl;		// geçerli

		return 0;
	}

	void foo()
	{
		cout << "this is a test" << endl;	// geçersiz'
	}
	
	main fonksiyonu içerisindeki direktifin foo fonksiyonunda bir etkisi yoktur. 

	İsim hem direktifte belirtilen isim alanında hem de direktifin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim alanında 
	bulunursa bu durum geçersizdir. Örneğin:

	namespace CSD
	{
		int a = 10;
	}

	int a = 20;

	int main()
	{
		using namespace CSD;

		cout << a << endl;		// ambigous? Hangi a?
	
		return 0;
	}

	Tabii bu örnekte eğer isim global isim alanına kadar isim araması sırasında bulunsaydı herhangi bir sorun oluşmayacaktı. Örneğin:

	#include <iostream>

	using namespace std;

	namespace CSD
	{
		int a = 10;
	}

	int a = 20;

	int main()
	{
		int a = 100;

		using namespace CSD;

		cout << a << endl;		// main fonksiyonundaki a

		return 0;
	}

	Burada CSD içerisindeki a sanki global isim alanındaymış gibi etki göstermektedir. Oysa global isim alanında da bir a değişkeni bulunmaktadır. Bu durumda 
	isim araması başarısz olacaktır. Benzer biçimde isim birden fazla using namespace direktifi ile belirtilen isim alanında bulunyorsa bu durumda da isim araması
	başarısız olur. Örneğin:

	namespace A
	{
		int x;
		int y;
	}

	namespace B
	{
		int x;
		int z;
	}

	using namespace A;
	using namespace B;

	int main()
	{
		x = 10;		// geçersiz! hangi x?
		y = 20;		// sorun yok, A::y nalaşılır
		z = 30;		// sorun yok B::z anlaşılır

		return 0;
	}

	Tabii burada using namespace direktiflerinin yerleştirilmesinde bir sorun yoktur. Sorun a isminin niteliksiz biçimde kullanılması sırasında oluşmaktadır. 
	Bu tür durumlarda çakışma olmadığı sürece isimleri niteliksiz bir biçimde, çakışma durumda da nitelikli bir biçimde kullanabiliriz. Örneğimizde x değişkenini
	niteliksiz kullanamadığımıza göre A::x ve B::x biçiminde nitelikli kullanma yoluna gidebiliriz. 

	Niteliksiz isim aramsı sırasında using namespace direkifi ile bleirtilen isim alanında da using namespace direktifi varsa etki geçişli olarak devam eder. Örneğin:

	
	namespace A
	{
		int x;
		//...

	}

	namespace B
	{
		using namespace A;

		int y;
		//...
	}

	using namespace B;

	int main()
	{
		x = 10;			// geçerli
	
		return 0;
	}

	Burada etki şöyle düşünülmelidir. "using namespace B" direktifi ileB isim alanı içerisindeki isimler global isim alanına enjekte edilmiş gibi olmaktadır. 
	Böylece isim alanındaki "using namespace A" direktifi de sanki global isim alanındaymış gibi etkiye sahip olacaktır. Bu etki de A isim alanı içerisindekilerin
	global isim alanına enjekte edilmesine yol açacaktır. 

	Oveload resolution işlemi sırasında aday fonksiyonların seçilmesinde using namespace direktifi etkili olmaktadır. Aşağıdaki örneği inceleyiniz:

	using namespace std;

	namespace A
	{
		void foo(int a)
		{
			cout << "A::foo(int)" << endl;
		}
	}

	namespace B
	{
		using namespace A;

		void foo(long a)
		{
			cout << "B::foo(long)" << endl;
		}
	}

	void foo(double a)
	{
		cout << "::foo(double)" << endl;
	}

	using namespace B;

	int main()
	{
		foo(10);		// A::foo çağrılır
		foo(10L);		// B::foo çağrılır
		foo(3.14);		// ::foo çağrılacak
	
		return 0;
	}

	Burada tüm foo fonksiyonları aslında global isim alanındaymış gibi düşünülmelidir. Dolayısıyla bu fonksiyonların hepsi aday fonksiyon olarak seçilecektir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Nitelikli isim araması sırasında yalnızca belirtilen isim alanına bakıldığına dikkat ediniz. Örneğin:

	int a = 10;

	namespace CSD
	{
		int b = 20;
		//...
	}

	int main()
	{
		CSD::a = 10;		// geçersiz!

		return 0;
	}

	Burada CSD::a ifadesindeki a ismi nilikli bir biçimde yalnızca CSD isim alanında aranacaktır. Eğer orada bulunmazsa kapsayan isim alanlarına bakılmayacaktır.

	Nitelikli isim araması sırasında "isim ilgili isim alanında bulunamazsa" o isim alanındaki using namespace direktiflerinde belirtilen isim alanlarında da
	nitelikli arama yapılmaktadır. (Burada en dar isim alanı tanımı kullanılmamaktadır.) 
	
	Örneğin:
		
	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int y = 20;
		//...
	}

	int main()
	{
		cout << B::x << endl;		// geçerli A::x anlaşılır

		return 0;
	}

	Burada B::x ifadesindeki x ismi B isim alanında bulunamadığı için A isim alanına da bakılacak ve orada bulunacaktır. Eğer isim ilgili isim alanında bulunsaydı 
	o isim alanındaki using namespace direktifleri etkili olmayacaktı. Örneğin:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int y = 20;
		int x = 30;
		//...
	}

	int main()
	{
		cout << B::x << endl;		// geçerli, B::x anlaşılır

		return 0;
	}

	Burada B::x ifadesindeki x ismi B'de bulunduğu için A'da aranmayacaktır. Aşağıdaki örneği inceleyiniz:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int x = 20;
		//...
	}

	namespace C
	{
		using namespace B;

		//...
	}

	int main()
	{
		cout << C::x << endl;		// geçerli, B::x anlaşılır

		return 0;
	}

	Buradaki C::x ifadesinde x'in aranması sırasında bir sorun oluşmayacaktır. Çünkü standartlara göre isim C isim alanında bulunamadığında sanki B::x gibi 
	aranacaktır. Dolayısıyla isim B isim alanında bulunduğu için sorun çıkmayacaktır. 
	
	Aşağıdaki örnekte ise C::x ifadesindeki x birden fazla isim alanında buulunacağı için isim araması başarısız olacaktır. Bu tür durumlarda using namespace 
	direkt,flerinin sırasının hiçbir önemi yoktur:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		int x = 20;
		//...
	}

	namespace C
	{
		using namespace A;
		using namespace B;

		//...
	}

	int main()
	{
		cout << C::x << endl;	// geçersiz! ambiguity, A::x ve B::x arasında seçim yapılamaz

		return 0;
	}

	Bu tür durumlarda isimlerin farklı isim alanlarında bulunuyor olmaması gerekir. Bulunma derinliğinin bir önemi yoktur. Örneğin:

	namespace CSD
	{
		int x;
		//...
	}

	namespace A
	{
		using namespace CSD;
		//...
	}

	namespace B
	{
		int x = 20;
		//...
	}

	namespace C
	{
		using namespace A;
		using namespace B;
		//...
	}

	int main()
	{
		cout << C::x << endl;	// geçersiz! ambiguity, B::x ve CSD::x arasında seçim yapılamaz

		return 0;
	}

	Burada C::x isminin aranması yine başarısızlıkla sonuçlanacaktır. 

	using namespace direktifindeki isim alanlarına ilişkin isimler de isim aramsına sokulmaktadır. Örneğin:

	using namespace CSD::Util

	Burada derleyici CSD ismini "niteliksiz olarak", Util ismini de CSD içerisinde nitelikli olarak arayacaktır. Direktifin geçerli olması için burada belirtilen 
	isim alanı isimlerinin bulunuyor olması gerekir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													21. Ders 25/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    40) using namespace direktifinin dışında C++'ta ayrıca bir de "using bildirimi" denilen bir bildirim de vardır. using bildirimi bir isim alanındaki ismi 
	bir faaliyet alanına sokmak için kullanılmaktadır. Bu nedenle bu bir direktif değil bildirimdir. Çünkü bildirimlerde yeni bir isim bir faaliyet alanına 
	katılmaktadır. using bildiriminin genel biçimi şöyledir:

	using <isim_alanı_ismi>::<isim>, [<isim_alanı_ismi>::<isim>], [...];

	Buradaki isim_alanı_ismi iç bir isim alanı (nested namespace) belirtebilir. Örneğin:

	using std::cout, std::endl;
	using CSD::Util::test

	//...
	cout << "this is a test" << endl;
	test();

	Tabii using bildirimi bir faaliyet alanına yenibir ismi soktuğuna göre o faaliyet alanında o ismin tek olması gerekmektedir. Örneğin:

	namespace CSD
	{
		int a;
		//...
	}

	void foo()
	{
		using CSD::a;
		int a;				// geçersiz! aynı faaliyet alanında aynı isim birden fazla kez bildirilemez
		//...
	}

	using bildirimi bir fonksiyona uygulandığında o isim alanındaki aynı isimli tüm fonksiyonlar ilgili faaliyet alanına sokulmuş olur.  Yalnızca aynı 
	isimli tek bir fonksiyonunun using bildirimi ile faaliyet alanına sokulması mümkün değildir. Örneğin:

	namespace CSD 
	{
		void foo()
		{
			//...
		}

		void foo(int a)
		{
			//...
		}
		//...
	}

	int main()
	{
		using CSD::foo;

		foo();				// geçerli
		foo(10);			// geçerli

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
	int x, y, z;

	void foo()
	{
		cout << "CSD::foo()" << endl;
	}

	void foo(int a)
	{
		cout << "CSD::foo(int)" << endl;
	}

	void bar()
	{
		cout << "CSD::bar" << endl;
	}
}

void foo(double a)
{
	cout << "CSD::foo(double)" << endl;
}

int main()
{
	using CSD::foo, CSD::x;

	foo();				// CSD::foo()
	foo(10);			// CSD::foo(int)
	foo(3.14);			// CSD::foo(int)

	x = 10;				// geçerli
	CSD::y = 20;		// geçerli
	CSD::z = 30;		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	41) İsim alanlarına ilişkin diğer bir bildirim de "namespace alias" denilen bildirimdir. Bu bildirim bir isim alanı ismini daha kolay kullanmak için düşünülmüştür. 
	Örneğin isim alanı ismi uzun olabilir. Biz bunu kısa bir biçimde kullanmak isteyebiliriz. Ya da örneğin iç bir isim alanınını tek bir isim iel kullanmak isteyebiliriz. 
	bildirimin genel biçimi şöyledir:

	namespace <isim> = <isim_alanı_ismi>;

	Burada '=' atomunun sağında bir isim alanı bulunmak zorundadır. Bir tür ismi bulunamaz. Tabii buradaki isim alanı iç bir isim alanı olabilir. Örneğin:

	namespace U = CSD::Util;

	Artık burada U demekle CSD::Util demek tamamen aynı anlama gelmektedir. Bu işlemin bir typedef işlemi olmadığında dikkat ediniz. typedef işleminde ya da 
	onun modern biçimi olan using işleminde bir türe alternatif isim verilmektedir. İsim alanları tür belirtmemektedir. Bu nedenle bu bildirime "namespace alias"
	bildirimi denilmektedir. 	

	namespace alias bildirimi herhangi bir isim alanına ya da herhangi bir bloğa yerleştirilebilir. Tabii ismin faaliyet alanı yerleştirildiği yere bağlı olarak 
	değişmektedir. 

	namespace alias bildirimi tek tek yapılma zorundadır. Örneğin:

	namespace U = CSD::Util
	namespace T = CSD::Test

	Aşağıdaki gibi yapılamaz:

	namespace U = CSD::Util, T = CSD::Test
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	42) C++11 ile birlikte diğer bazı dillerde çeşitli biçimlerde bulunan "öznitelikler (attributes)" konusu dile eklenmiştir. Öznitelikler derleyici için 
	kullanılan direktiflerdir. Özniteliklerin temel amacı derleyicinin daha iyi kod üretmesini sağlamak, uyarı mekanizması üzerinde etkili olmak ve derleyicinin 
	bazı davranışlarını değiştirmektir. 

	C'de derleyicinin kimi davranışları komut satırı argümanlarıyla ya da #pragma direktifi yardımıyla değiştirilebilmektedir. #pragma direktifi C'de standart 
	bir direktif olmasına karşın direktifin	yanındaki komutlar derleyiciden derleyiciye değişebilmektedir. Örneğin:

	#pragma pack(1)

	struct SAMPLE {
		char a;
		short b;
		int c;
	};

	#pragma pack komutu yapı elemanlarının hizalanması üzerinde etkili olmaktadır. Bu pragma komutu pek çok derleyici tarafından desteklenmektedir. Ancak pek çok 
	pragma direktifi ilgili derleyiciye hatta ilgili platforma özgü olabilmektedir. C'de pragma direktifleri önişlemci aşamasında parse edilmektedir. Dolayısıyla
	zayıf bir kullanım alanına sahiptir. İşte öznitelikler bu pragram direktiflerinin standart ve genel bir biçimi gibi düşünülebilir. 

	C++11 ile dile eklenen öznitelikler zaman içerisinde neredeyse tüm sentaktik öğelerde kullanılabilir duruma getirilmiştir. İzleten paragraflarda tipik olarak 
	bu özniteliklerin hangi sentaktik öğelerde kullanılabileceğinin bir listesini (ayrıntılı olmayan listesini) vereceğiz. 

	Bir öznitelik oluşturmanın genel biçimleri şöyledir:

	[[öznitelik_ismi]]
	[[öznitelik_ismi()]]
	[[öznitelik_ismi(argüman_listesi)]]
	[[öznitelik_isim_alanı::öznitelik_ismi]]
	[[öznitelik_isim_alanı::öznitelik_ismi()]]
	[[öznitelik_isim_alanı::öznitelik_ismi(argüman_listesi)]]
	[[using öznitelik_isim_alanı: öznitelik_ismi, öznitelik_ismi, ...]]

	Yukarıdaki iki köşeli parantezler içerisindeki çznitelik isimleri birden fazla olabilir. Bu durumda öznitelikler ',' atomu ile ayrılmalıdır. Aşağıda 
	bazı geçerli öznitelik oluşturma örnekleri vermek istiyoruz:

	[[xxx]]
	[[xxx, yyy]]
	[[xxx(aaa, bbb)]]
	[[xxx(), yyy(aaa, bbb)]]
	[[nnn::xxx]]
	[[nnn::xxx(aaa, bbb)]]
	[[nnn::xxx(aaa, bbb), kkk::yyy(cccc)]]
	[[using N: xxx, yyy]]

	Burada xxx, yyy, aaa, bbb, ccc gibi isimler herhangi bir isim olarak kullanılmıştır. Öznitelik isim alanı iç içe olamamaktadır. Örnepşn:
	
	[[nnn::kkk::xxx]]		

	Böyle bir öznitelik isim alanı geçerli değildir. Yani öznitelik bildiriminde en fazla bir tane :: atomu kullanılmalıdır. 
	
	Bir sentaktik öğeye tek bir [[...]] yerleştirilmek zorunluluğu da yoktur. Birden fazla [[...]] aralarına başka bir atom bulundurulmadan yerleştirilebilir. 

	Yukarıda da belrttiğimiz gibi öznitelikler (attributes) pek çok sentaktik öğede kullanılabilmektedir. Özniteliğin sentakstaki yerine göre kimin için yazıldığı 
	belirlenebilmektedir. Örneğin:

	[[xxx::yyy]] void foo()
	{
		//...
	}

	Burada öznitelik fonksiyonun kendisi bulundurulmuştur. Örneğin:

	[[xxx::yyy]] int a, b, c;

	Burada öznitelik bildirimin tamamı için bulundurulmuştur. Örneğin:

	int a [[xxx::yyy]], b, c;

	Burada öznitelik a değişkeni için bulundurulmuştur. Örneğin:

	namespace [[xxx::yyy]] CSD
	{
		//...
	}

	Burada öznitelik CSD isim alanı için bulundurulmuştur. Özetle özniteliğin bulundurulduğu yer o özniteliğin sentaksın hangi parçasını nitelediğini belirtmektedir. 

	Öznitelikler kabaca şu sentaktik öğelerde kullanılabilmektedir:

	- İsim alanlarında isim alanı isimlerinden önce. Örneğin:

	namespace [[xxx::yyy]] CSD
	{
		//...
	}

	- Bildirimlerde tür belirleyicilerinden ve niteleyicilerinden önce (yani bildirimlerin başında). Örneğin:

	[[xxx::yyy]] int a, b, c;

	- Bildirimlerde dekleratördeki isimlerden sonra. Örneğin:

	int a [[xxx::yyy]], b;

	- Dizi dekleratörlerinde diziyi belirten köşeli parantezlerden sonra. Örneğin:

	int a[10] [[xxx::yyy]];

	- Gösterici ve referanslarda *, & ve && atomlarından sonra. Örneğin:

	int * [[xxx::yyy]]pi;
	int & [[xxx::yyy]] r = x;

	- Fonksiyonlarda bildirimin başında. Örneğin:

	[[xxx::yyy]] void foo()
	{
		//...
	}

	- Fonksiyonlarda fonksiyonun parantezlerinden sonra. Örneğin:

	void foo() [[xxx::yyy]]
	{
		//...
	}

	- Fonksiyonlarda fonksiyon isimlerinden sonra. Örneğin:

	void foo [[xxx::yyy]]()
	{
		//...
	}

	- Parametre değişkenlerinde tür belirleyicisndne önce. Örneğin:

	void foo([[xxx::yyy] int a, int b)
	{
		//...
	}

	- Parametre değişkenlerinde değişken isminden sonra. Örneğin:

	void foo(int a [[xxx::yyy], int b)
	{
		//...
	}

	- Deyimlerin başlarında. Örneğin:

	[[xxx::yyy]]
	if (ifade) {
		//...
	}

	[[xxx::yyy]]
	{
		ifade1;
		ifade2;
		ifade3;
	}

	[[xxx::yyy]]
	for (int i = 0; i < 10; ++i) {
		//...
	}

	- Boş deyimlerde. Örneğin:

	[[xxx::yyy]];

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														22. Ders 30/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Belli bir sentaktik öğeye yerleştirilen özniteliklerin ne anlam ifade ettiği (yani semantiiği) derleyicileri yazanların isteğine bırakılmıştır. Yani 
	derleyicilerin farklı öznitelikleri olabilmektedir. Her öznitelik her sentaktik öğede geçerli olmayabilir. Örneğin bazı öznitelikler yalnızca fonksiyon 
	bidiriminde ya da tanımlamasında kullanılabilir. Bazı öznitelikler değişken tanımlamasında kullanılabilir. C++ standartlarında her derleyicinin desteklemesi 
	gereken az sayıda öznitelik baştan belirlenmiştir. (C++'ın çeşitli sürümlerinde bu listeye eklemeler yapılmıştır.) Bunlara "standart öznitelikler" diyebiliriz. 
	Standanrtlara göre isim alanı içermeyen tüm öznitelikler ve std isim alanı içeren öznitelikler "reserved" bırakılmıştır. Yani bunların programcılar tarafından 
	ve derleyiciler tarafından kullanılması yasaklanmıştır. (Genel olarak standartlarda "reserved" özelliklerin kullanılması "tanımsız davranış" olarak ele 
	alınmaktadır.) Örneğin [[xxx]] biçiminde isim alanı içermeyen bir öznitelik programcılar tarafından da derleyicleri yazanlar tarafından da kullanılmamalıdır. 
	Benzer biçimde [[std:xxx]] biçimindeki bir öznitelik de "reserved" durumdadır. O halde derleyicileri yazanlar kendileri öznitelik isim alanı uydurup kendi 
	özniteliklerini bu öznitelik isim alanı ile oluşturmalıdırlar. Örneğin [[gnu::xxx]] gibi, [[msvc::xxx] gibi. Ayrıca standartlar "derleyici tarafından tanınmayan"
	bütün özniteliklerin derleyici tarafından "görmezden gelinmesi (ignore) gerektiğini" belirtmektedir. Bu durumda biz derleyicilerde olmayan bir öznitelik ismi 
	uydursak programda herhangi bir hata ortaya çıkmayacaktır. (Tabii derleyiciler tanıyamadıkları öznitelikler için uyarı mesajları verebilirler.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi özniteliklere neden gereksinimn duyulmaktadır? Temel nedenleri şöyle ifade edebiliriz:
	
	- Derleyicilerde bazı davranışların değiştirilmesini sağlamak için
	- Derleyiciye ipucu vererek daha etkin kod üretimini sağlamak için
	- Derleyicilerin uyarı mekanizmalarında etkili olabilmek için
	- Derleyicilerin bazı "implementation defined" durumlarına yönelik açıklama yapmak için
	- Kodun okunabilirliğini artırmak için

	Konunun başında de belirttiğimiz gibi yukarıdaki amaçların bazıları komut satırı argümanlarıyla ve #pragma direktifleriyle kısmen sağlanabilmektedir. Ancak
	öznitelikler "daha genel ve çok daha spesifik" bir yöntem sunmaktadır. Öznitelikler neredeyse her sentaktik öğeye getirilebildiği için çok daha ince belirlemelerin
	yapılmasına olanak sağlamaktadır. Standart özniteliklerin yanı sıra çalıştığınız derleyiciye özgü özniteliklere göz gezdirebilirsiniz. Biz bu bölümde 
	bazı standart öznitelikleri gözden geçireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[noreturn]] özniteliği yalnızca fonksiyonlarda kullanılabilmektedir. Bir fonksiyonu bu biçimde özniteliklendirirsek derleyiciye bu fonksiyonun 
	geri dönmeyeceğini söylemiş oluruz. Böyle fonksiyonların geri dönmesi "tanımsız davranış" oluşturmaktadır. noreturn özniteliği herhangi bir argüman almamaktadır. 
	Bu öznitelik C++11'den beri bulunmaktadır. Bir fonksiyonun prototipinde ya da tenımlamasında [[noreturn]] özniteliği kullanılmışsa bütün prototiplerinde ve
	tanımlamasında bu özniteliğin kullanılması gerekmektedir. 
	
	
	Pekiyi bir fonksiyonun geri dönmemesi nasıl mümkün olabilir? İşte aşağıda bazı senaryolaır görüyorsunuz:

	[[noreturn]] void foo()
	{
		//...

		exit(EXIT_SUCCESS);
	}

	[[noreturn]] void bar()
	{
		//...

		for (;;) {			// sonsuz dönü
			//...
		}
	}

	[[noreturn]] void tar()
	{
		//...

		throw exception();
	}

	Öte yandan standrat kütüphanedeki bazı fonksiyonlar da artık [[noreturn]] ile bildirilmiştir. Örneğin exit fonksiyonu böyledir:

	[[noreturn]] void exit(int exit_code);

	
	Pekiyi bir fonksiyonun geri dönmeyeceğini derleyiciye söylemekle kim ne kazanmış olmaktadır? Derleyiciler fonksiyonları geri döndürebilmek için bazı makine
	komutlarını üretilen koda yerleştirmek zorundadır. (Örneğin pek çok işlemcide geri dönüşü "ret" isimli makine komutu sağlamaktadır. Ancak tek başına bu "ret")
	makine komutu yeterli de olmayabilir. Derleyici bazı yazmaçları geri dönmeden önce girişteki değerlerle yeniden yüklemek zorunda kalabilmektedir. Dolayısıyla
	fonksiyonun geri dönmeyeceğini anlayan derleyici bu kodları fonksiyona eklemeyebilir. Bu da daha etkin bir kod üretimi anlamına gelmektedir. Öte yandan 
	fonksiyon çağrısında da kodun geri dönmeyeceğini anlayan derleyici orada da bazı optimizasyonları yapabilmektedir. [[noreturn]] programcılar için okunabilirliği 
	de artırmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[deprecated]] özniteliği pek çok sentaktik öğeye getirilebilmektedir. Bu öznitelik ilgili özelliğin "deprecated" yapıldığını belirtir. Bu öznitelik 
	C++14 ile eklenmiştir. Örneğin:

	[[deprecated]] void foo();

	Burada foo fonksiyonunun ilgili kütüphanede artık "deprecated" yapıldığı belirtilmiştir. Deprecated sözcüğü "hala desteklenen ancak ileri verisyonlarda 
	artık kaldırılabilecek olan" öğeleri belirtmektedir. Yukarıdaki örnekte foo fonksiyonunu biz hala kullanabiliriz. Ancak ileride bu fonksiyon kaldırılabileceğine
	göre bunu kullanmamaız daha uygun olacaktır. Genellikle "deprecated" öğeler için "daha iyi" alternatifler bulundurulmaktadır. Programcının bu daha iyi olan 
	alternatifleri kullanması uygun olacaktır. Tipik olarak derleyiciler "deprecated" özellikleri gördüklerinde bir uyarı mesajıyla durumu programcıya bildirmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[likely]] ve [[unlikely]] öznitelikleri deyimlerde ve etiketlerde (labels) kullanılabilmektadır. Bu öznitelik C++20 ile eklenmiştir. Örneğin:

	if (koşul) [[likely]] {
		//...
	}
	else {
		//...
	}

	Burada if deyimim doğruysa ksımından sapması çok daha muhtemel bir durum olarak belirtilmiştir. derleyiciler bu tür durumlarda daha iyi makine komutları 
	üretebilmektedir. Bu konu "instruction scheduling", "instruction reordering" ve "jump prediction" denilen optimizasyon temalarıyla ilgilidir. İşlemciler bir
	makine komutunu yaparken aynı zamanda sonraki komutlar üzerinde de birtakım hazırlık işlemlerini yapabilmektedir. Bu nedenle if deyimlerinde mümkün olan 
	durumun makine komutları olarak öne yerleştirilmesi önemlidir. Örneğin:

	if (foo() == -1) [[unlikely]] {
		//...
	}

	Burada foo başarısız olduğunda -1 değerine geri dönüyor olsun. Programcı derleyiciye "bu fonksiyonun başarsız olma olasılığı çok düşük" demek istemektedir.
	Bu bilgiyi elde eden derleyici daha etkin makine komutları üretebilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standat [[assume(ifade)]] özniteliği belli bir noktada belli bir koşulun kesinlikle sağlanması gerektiğini belirtmktedir. Bu öznitelik boş deyime uygulanabilir. 
	(Yani bu öznitelikten sonra ';' atomunun gelmesi gerekir.) Eğer söz konusu koşul sağlanmazsa "tanımsız davranış" oluşmaktadır. Örneğin:

	void foo(int a)
	{
		[[assume(a > 0)]];
		//...
	}

	Burada fonksiyonun pozitif bir argümanla çağrılacağı derleyiciye bildirilmiştir. Derleyici bu varsayımı kullanarak daha etkin kod üretebilir. Eğer assume
	özniteliğine geçirilen argüman virgül operatörü içeriyorsa bu virgül operatörü paranteze alınmalıdır. Bu durumda virgül operatörünün sol tarafı öncül işlemi
	sağ tarafı koşulu belirtir. Örneğin:

	[[assume((foo(), x > 0))]]

	Burada foo çağrıldıktan sonra x değişkeninin değerinin pozitif olacağı belirtilmiştir. Tabii assume özniteliğindeki ifade işletilmez. Yai bu örnekte foo 
	çağrılmayacaktır. Derleyici ileride foo çağrıldığında bu çağrıdan sonra x'in 0'dan büyük olacağını anlayacaktır. Örneğin (cppreference.com sitesinden 
	alınmıştır):

	x = 3;
    int z = x;
 
    [[assume((h(), x == z))]];	
								
    h();
    g(x); // Derleyici bu işlemi g(3) ile eşdeğer olarak ele alabilir
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[fallthrough]] özniteliği swith deyimlerinde case etiketleri için kullanılmaktadır. Öznitelik boş deyimlere uygulanabilmektedir. Fallthroug işleminin 
	kasten yapıldığını belirtmektedir. Dolayısıyla derleyiciler bu tür durumlarda "yanlışlıkla yapılan fallthrough işlemlerinde" verdikleri uyarı mesajlarını 
	vermezler. Bu öznitelik C++17 ile birlikte standartlara eklenmiştir. Örneğin:

	void f(int n) 
	{
		void g(), h();

		switch (n) {
			case 1:
			case 2:
				g();
				[[fallthrough]];
			case 3: 
				h();
		}
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	standart [[maybe_unused]] özniteliği bildirilen bir değişkenin kullanılmadığında oluşabilecek uyarıyı ortadan kaldırmak için kullanılmaktadır. Bu öznitelik
	değişken bildirimlerinde, sınıf bildirimlerinde enum bildirimlerinde, enum sabit bildiriminde, typedef isimlerinin bildiriminde sınıfın veri elemanlarının,
	global fonksiyonların ve üye fonksiyonların (ileride görülecek) bildirimlerinde kullanılabilir. Örneğin:

	[[maybe_unused]] int a;

	void foo(int a, [[maybe_unused]] b)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	43) C++'ın çeşitli versyonlarında deyimlerde de bazı eklemeler yapılmıştır. 
	
	C++17 ile birlikte if deyimine isteğe bağlı bir "init kısmı" eklenmiştir. Bu init kısmı bir ifade içerir. İfadeden sonra ';' atomunun bulunması gerekir. 
	Yukarıda da belirttiğimiz gibi bu "init" kısmı deyidme bulundurulmak zorunda değildir. Dolayısıyla deyim eski biçimiyle uyumludur. Örneğin:

	if (ifade; koşul) {
		//...
	}
	else {
		//...
	}

	Bu deyim aşağıdaki ile eşdeğerdir:

	{
		ifade;

		if (koşul) {
			//...
		}
		else {
			//...
		}
	}

	if deyim,ne eklenen bu "init" kısmının adeta for döngüsünün birinci kısmı gibi deyime girişte yapıldığına dikkat ediniz. if deyiminin init ksımında bir bildirim 
	de bulunabilmektedir. Bu durumda bildirilen değişken if deyimi içerisinde kullanılabilir. Örneğin:

	if (char buf[32]; fgets(buf, 32, stdin) != NULL) {
		//...
	}

	Burada if deyiminin "init" kısmında buf dizisi bildirilmiş ve if içerisinde kullanılmıştır. Buradaki buf dizisinin faaliyet alanı if ile sınırlıdır. "init"
	kısmı boş da bırakılabilir. Tabii böyle bir kullanımın anlamı yoktur. Örneğin:

	if (; koşul) {		// geçerli ama anlamsız
		//...
	}

	Benzer biçimde switch deyimine de "init" kısmı eklenmiştir. Genel kullanım if deyiminde belirttiğimiz gibidir. Örneğin:

	switch (int x = foo(); x) {
		//...
	}

	C++20 ile birlikte Aralık tabanlı for döngülerine de "init" kısmının eklendiğini aralık tabanlı for döngülerini anlattığımız kısımda belirtmiştik. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	44) C++17 ile birlikte "constexpr if" C++23 ile de "consteval if" deyimi biçiminde yeni iki if deyimi varyasyonu eklenmiştir. constexpr if deyiminin genel biçimi 
	şöyledir:

	if constexpr ([init;] koşul) 
		<deyim>
	[
		else 
			<deyim>
	]

	constexpr if deyiminde koşul ifadesinin sabit ifadesi olması gerekmektedir. Aslında constexpr if deyimi #if önişlemci komutunu çağrıştırmaktadır. Anısanacağı
	gibi #if komutunda #if anahtar sözcüğünün yanınadaki sabit ifadesi sıfırdan farklı ise #else anahtar sözcüğüne kadarki kısım derleme modülüne veriliyordu, 
	eğer #if anahtar sözcüğünün yanındaki ifade 0 ise #else ile #endif arasındaki kod bölümü derleme modülüne veriliyordu. Başka bir deyişle #if deyiminin koşula 
	göre bir kısmı koddan atılmaktaydı. İşte constexpr if deyimi de bunun bir benzerini yapmaktadır. Ancak bu işlem önişlemci aşamasında değil derleme aşamasında
	yapılmaktadır. Örneğin:

	constexpr int x = 10;
	//...

	if constexpr (x > 0) 
		foo();
	else 
		bar();
	
	Burada if deyiminin else kısmı tamamen koddan kaldırılacaktır. consexpr if deyimi #if önişlemci komutunu çağrıştırıyor olsa da aralarında önemli farklılıklar 
	vardır. constexpr if deyiminin derleme aşamasında derleme modülü tarafından yapılıyor olması çeşitli durumlarda esneklikler sağlamaktadır. constexpr if 
	deyimi özellikle şablonlarla birlikte kullanılmaktadır. constexpr if deyiminde deyimin bir kısmı kodda atılıyor olsa bile atılan kısmın yine de sentaks ve 
	semantik kısıtları sağlıyor olması gerekmektedir. Örneğin:

	constexpr int x = 10;
	int *pi;
	//...

	if constexpr (x > 0) {
		foo();
	}
	else {
		pi = 10;			// geçersiz!
	}

	Burada constexpr if deyiminin yanlışsa kısmı koddan atılacak olsa da buradaki deyimler üzerinde sentaks ve semantik kontroller yine yapılacaktır.

	C++23 ile birlikte consteval if deyimi de dile eklenmiştir. 

	consteval if deyiminin işlevi ve gerekliliği biraz daha karmaşıktır. Deyimin genel biçimi şöyledir:

	1) 

	if consteval {
		<deyim>
	}
	[ else {
		<deyim>
	  }]
	
	2) 

	if consteval {
		<deyim>
	}
	[ else {
		<deyim>
	  }]

	
	Bu özellik C++'a çok yeni eklendiği için derleyicileriniz bu özelliği desteklemiyor olabilir. Bu if deyimi şu anlama gelmektedir: "Eğer söz konusu kod parçası 
	sabit ifadesi gereken bir bağlamda kullanılmışsa buradaki if deyimi doğruysa biçimde sapacak, eğer söz konusu kod parçası sabit ifadesi gereken bir bağlamda 
	kullanılmadıysa buradaki if deyimi yanlışsa biçiminde sapacaktır." Örneğin:

	constexpr int cube(int a)
	{
		if consteval {
			return a * a * a;
		}
		else {
			return pow(a, 3);	
		}
	}

	Burada cube fonksiyonu parametresi ile aldığı sayının kübüyle geri dönmektedir. Ancak bu constexpr fonksiyon sabit ifadesi gereken bir bağlamda da çağrılmış 
	olabilir, sabit ifadesi gerekmeyen bir bağlamda da çağrılmış olabilir. Eğer bu fonksiyon sabit ifadesi gereken bir bağlamda çağrılmışsa bu durumda consteval if 
	deyimim doğruysa kısmı derleme aşamasında devreye girecek ve a * a * a işlemi ile derleme aşamsında değer hesaplanacaktır. Eğer bu fonksiyon sabit ifadesi gerekmeyen 
	bir bağlamda çağrılmışsa bu durumda consteval if deyiminin yanlışsa kısmı devreye girecek ve küp alma işlemi derleme zanında değil fonksiyon çağrılarak 
	yapılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	45) C++'ta ilk standartlardan beri "anonim birlik (anonymous union)" oluşturma özelliği bulunmaktadır. Anonim birlik oluşturabilmek için birliğe bir isim 
	verilmemesi ve birlik bildiriminde aynı zamanda nesne tanımlamanın yapılmamış olamsı gerekmektedir. Örneğin:

	union {
		int a;
		long b;
		double c;
	};

	Burada biz a, b, ve c değişkenlerini doğrudan kullanabiliriz. Bu değişkenler çakışık yerleştirilmektedir. Yani burada yapılmak istenen şey aşağıdakiyle 
	eşdeğerdir:

	union SomeName {
		int a;
		long b;
		double c;
	};

	SomeName sn;

	Biz burada sn.a, sn.b ve sn.c ile çakışık yerleştirilen birlik elemanlarını kullanabiliriz. Ancak anonim birliklerde buna hiç gerek yoktur. 

	Yukarıda da belirttiğimiz gibi anonim birlik oluşturabilmek için birliğe isim verilmemiş olamsı gerekmektedir. Örneğin:

	union U {
		int a;
		long b;
		double c;
	};

	Burada artık biz a, b, ve c değişkenlerini doğrudan kullanamayız. Benzer biçimde:

	union {
		int a;
		long b;
		double c;
	} x;

	Burada da biz a, b ve c değişkenlerini doğrudan kullanamayız. 

	Birlikler C++'ta aslında sınıflar gibi özelliklere sahiptir. Dolayısıyla anonim birlikler sınıflara ilişkin özleliklere sahip olamazlar. (Örneğin ileride
	birliklerin içerisinde üye fonksiyonların bulunabileceğini göreceğiz. Ancak anonim birliklerde üye fonksiyonlar bulunamamaktadır.)

	Anonim birliklerin yazım kolaylığı sağladığına dikkat ediniz. Örneğin:

	union {
		int a;
		double;
	};

	ile aşağıdaki tanımlamalara dikkat ediniz:

	int a;
	double b;

	Bu ikisi tanımlama arasındaki tek fark anonim birlik tanımlamasında a ve b nesnelerinin çakışık yerleştirilmesidir. 

	Anonim birlikler bir isim alanının içerisinde (yani global düzeyde) tanımlanacaksa union anahtar sözcüğünün önüne static anahtar sözcüğünün getirilmesi 
	gerekmektedir. Örneğin:

	static union {
		int a;
		double b;
	};

	Ancak anonim birlik sisimsiz isim alanı içerisine yerleştirilirse bu static belirleyicisine gerek kalmamaktadır. Anom birliklerin elemanlarının birliğin 
	yerleştirildiği faaliyet alanına enjekte edildiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	46) C++11 ile birlikte dile static_assert isimli bir bildirim (decalartion) eklenmiştir. static_assert bildirimi derleme zamanında assert kontrolü yapmaktadır. 
	Bilindiği gibi standart assert fonksiyonu programın çalışma zamanı sırasında işleme sokulmkatadır. Halbuki static_assert bildirimi derleme aşamsında işleme 
	sokulur. Derleme aşamasında #if önişlemci komutuyla da bazı kontroller yapılıp #error önişlemci komutuyla derleme işlemi sonlandırılabilmektedir. 
	Ancak önişlemci aşamasında yapılacek kontroller oldukça sınırlıdır. assert bildiriminin genel biçimi şöyedidr:

	static_assert(sabit_ifadesi_koşulu, "mesaj");

	Derleme aşamasında eğer buradaki koşul sağlanmazsa derleyici derleme işlemini keser ve ikinci argümanla girilen hata mesajını yazdırır. Örneğin.

	static_assert(sizeof(int) >= 4, "int type too small");

	Burada programcı int türünün 4 byte'tan küçük olmamasını istemektedir. sizeof bir derleme zamanı operatörü olduğu için kontrolün bizzat derleme aşamasında 
	yapılması gerekmektedir. C++17 ile birlikte buradaki ikinci parametre artık bulundurulmak zorunda değildir. Örneğin:

	static_assert(sizeof(int) >= 4);

	Tabii static_assert bildiriminde koşulun sabit ifadesi biçiminde oluşturulması gerekmektedir. 

	Her ne kadar semantik olarak static_assert bir bildirime benzemiyorsa da static_assert C++ standartlarında bir "bildirim (declaration)" olarak gramere eklenmiştir. 

	static_assert özellikle şablonlarla birlikte sıkça kullanılmaktadır. 

	static_assert bildiriminin derleme aşmasında ele alındığına dikkat ediniz. Bu bildirim bir fonksiyonun içerisine yerleştirilirse etki göstermesi için 
	o fonksiyonun çağrılmasına gerek yoktur. Çünkü fonksiyonun çağrılması çalışma zamanına ilişkin bir etkinliği belirtir. 

	İleride göreceğimiz şablon işlemlerinde "şablon açımları (template instantiation)" derleme aşamasında yapılmaktadır. Eğer static_assert fonksiyon şablonlarında
	kullanılırsa bunların devreye girmesi "açım (instantiation)" yapılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	47) C99 ile birlikte C'ye "designated initializer" denilen ilkdeğer verme biçimi eklenmişti. Bu sayede artık C99 ve sonrasında yapıların ve dizilerin 
	elemanlarına sırasıyla ilkdeğer verme zorunluğu kaldırılmış oldu. C'de sentaks aşağıdaki gibidir:

	struct SAMPLE {
		int a, b, c, d;
	};

	struct SAMPLE s = {.c = 10, .a = 20};
	int a[10] = {[5] = 20, [3] = 30, 40};

	İşte bu "designated initiaizer" sentaksı daraltılarak C++20 ile C++'a da sokulmuştur. Ancak C99'da olmayan aşağıdaki kısıtlar oluşturulmuştur:

	- C++'ta dizilerde designated initializer kullanımı yoktur.

	- Bazı koşulları sağlayan C ile uyumlu yapılarda ve sınıflarda (C++'ta yapılar da birer sınıftır) designated initializer kullanılabilmektedir. Ancak yapıların 
	ve sınıfların sıralı elemanlarına bu biçimde değer verilebilmektedir. 

	struct Sample {
		int a, b, c, d;
	};

	Sample s = {.b = 10, .d = 20};		// geçerli
	Sample k = {.d = 20, .b = 10};		// geçersiz!

	Burada yapı (ya da sınıf) elemanlarına önceki eleman önde olacak biçimde ilkdeğer verilmek zorundadır. Halbuki C99'da böyle bir zorunluluk yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C ve C++ standartlarında "operatörlerin öncelik tablosu" diye bir tablo bulunmamaktadır. Operatörler arasındaki öncelik ilişkisi standartlarda zaten
	BNF gramerinin doğal sonucu olarak oluşmaktadır. Operatörlerin öncelik tablosu aslında gerçek durumu belli bir kusurla basitleştirmek için düşünülmüştür. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													24. Ders 06/11/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
							C++'ın Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgili Olan Farklılıkları ve fazlalıkları
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz şimdiye kadar "C++'ın C'den Nesne Yönelimli Programalama Tekniği İle Doğrudan İlgili Olamayan Farklılıkları ve Fazlalıkları" üzerinde durduk. Artık
	C++'ı "nesne yönelimli (object oriented)" bir dil yapan sınıflar ve onlarla ilgili konuları ele alacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ı nesne yönelimli bir dil yapan en önemli özellik "sınıflar (classes)" konusudur. Sınıflar C'deki yapılara benzer olmakla birlikte yalnızca data değil 
	aynı zamanda fonksiyon da içeren veri yapılarıdır. Yani C'deki yapılar yalnızca data içerirken C++'taki sınıflar aynı zamanda fonksiyon da içermektedir. 
	Zaten C'deki yapılar ve birlikler de artık C++'ta sınıf anlamına gelmektedir. C++'ta "sınıf türü (class type)" denildiğinde yalnızca sınıflar değil, yapılar 
	ve birlikler de anlaşılmalıdır. C++'ta bir sınıf hem data hem fonksiyon içermek zorunda değildir. Yalnızca data ya da yalnızca fonksiyon da içerebilir. Bu 
	durumda sınıf kavramı aslında C'deki yapılar üzerinde bir fazlalık gibi değerlendirilebilir. 

	Sınıflar nesne yönelimli programlama tekniğinin yapı taşlarıdır. Tüm nesne yönelimli dillerde sınıf isminde ya da bu işlevde bir veri yapısı bulunmaktadır. 
	Tabii diller arasında bu veri yapıları arasında temel özellikleri aynı olmak üzere farklılıklar bulunabilmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf bildiriminin genel biçimi şöyledir:

	class <isim> {
		[data ve fonskiyon bildirimleri ve tür tanımlamaları]
	};

	struct <isim> {
		[data ve fonksiyon bildirimleri ve tür tanımlamaları]
	};

	Örneğin:

	class Sample {
		//...
	};

	struct Mample {
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta bir sınıfın içerisindeki fonksiyonlara "üye fonksion (member function)" denilmektedir. Halbuki Java, C#, Python gibi dillerde buna "metot (method)" 
	denilmektedir. C++'ta bir sınıf "public", "protected" ve "private" olmak üzere üç bölümden oluşmaktadır. Bir bölüm, bölüm belirten anahtar sözcük ve ':' atomu 
	ile başlatılır, başka bir bölüm belirten anahtar sözcüğe kadar devam eder. Sınıf bildirimi içerisinde bu bölüm belirten anahtar sözcükler birden fazla kez 
	kullanılabilirler. Örneğin:

	class Sample {
	public:
		//...
	protected:
		//...
	private:
		//...
	public:
		//...
	private:
		//...
	};

	Sınıf isimleri pek çok programcı tarafından "Pascal tarzı (Pascal casting)" ile harflendirilmektedir. Pascal tarzında her sözcüğün ilk harfi büyük harf 
	ile yazılır. Biz de kursumuzda bu isimlendirmeyi tercih edeceğiz. Ancak C++'ın standart kütüphanesindeki sınıf isimleri "klasik C tarzı (snake casting)" 
	ile isimlendirilmiştir.

	Bir sınıf bildirimine hiçbir bölüm belirten anahtar sözcük ile başlanmazsa bu durumda sınıf bildirimi "class" anahtar sözcü ile yapılmışsa default bölüm "private",
	"struct" anahtar sözcüğü ya da "union" ile yapılmışsa default bölüm "public" biçimdedir. Bunun dışında sınıf bildiriminin class ya da struct anahtar sözcüğüyle 
	yapılmasının bir farkı yoktur. struct ve union bildirimlerinde C ile uyumu korumak amacıyla default bölüm public yapılmıştır. Örneğin:

	class Sample {
		// buradaki elemanlar private bölümde
	public:
		// buradaki elemanlar public bölümde
		
	protected:
		// buradaki elemanlar protected bölümde
	};

	Örneğin:

	struct Test {
		// buradaki elemanlar public bölümde
	private:
		// buradaki elemanlar private bölümde
	protected:
		// buradaki elemanlar protected bölümde
	};

	Sınıf içerisinde bölümlerin oluşturulma sırasının hiçbir önemi yoktur. Ancak ağırlıkı tercih edilen durum önce public, sonra protected, sonra da private
	bölümdür. Örneğin:

	class Sample {
	public:
		//...
	protected:
		//...
	private:
		//...
	};

	Tabii sınıf bildiriminde bu bölümlerin hepsi olmak zorunda değildir. Herhangi biri ya da birden fazlası olabilir. C'deki struct ve union türleri C++'ta
	birer sınıf belirtmekle birlikte C uyumunun korunması için onların default bölümü public yapılmıştır. Örneğin:

	struct Sample {
		int a, b, c;		// bu elemanlar public bölümde
	};

	Biz bu bölümlerin ne anlam ifade ettiğini görene kadar sınıf elemanlarını hep public bölüme yerleştireceğiz. 

	Diğer bazı nesne yönelimli dillerde public, protected ve private bölümlerin dışında başka bölümler de olabilmektedir. (MÖrneğin C#'ta "internal" ve "protected 
	internal" bölümler vardır.) Python gibi bazı dilelrde sınıflarda bölümler yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta sınıflar global ya da yerel biçimde bildirilebilirler. Ancak C'deki yapılarda olduğu gibi hemen her zaman sınıflar yerel değil global olarak bir 
	isim alanının içerisinde bildirilmektedir. (Hiçbir isim alanının içinde olmayan global bölgenin de "global isim alanı" denilen bir isim alanı belirttiğini 
	anımsayınız.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın üye fonksiyonlarının yalnızca prototipleri sınıf bildirimi içerisinde belirtilebilir. Tanımlamaları o sınıfın içinde bulunduğu isim alanında 
	ya da o isim alanını kapsayan isim alanlarından birinde yapılabilir. Üye fonksiyon tanımlaması sınıf dışında yapılırken fonksiyon isminin sınıf ismi ile 
	:: operatörü kullanılarak niteliklendirilmesi gerekir. Üye fonksiyonu dışarıda tanımlamanın genel biçimi şöyledir:

	<geri dönüş değerinin türü> <[isim alanı isimleri::]sınıf ismi>::<fonksiyon ismi>([prametre bildirimi])
	{
		//...
	}

	Örneğin:

	class Sample {
	public:
		void foo();
		void bar();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Standratlara göre üye fonksiyon tanımalamaları sınıf bildirimini kapsayan daha dış bir isim alanında isim alanını ismi de bedlirtilerek yapılabilir. Örneğin:

	namespace CSD
	{
		class Sample {
		public:
			void foo();
			void bar();
			//...
		};

		void Sample::foo()		// geçerli
		{
			//...
		}
	}

	void CSD::Sample::bar()		// geçerli
	{
		//...
	}

	int main()
	{
		//...

		return 0;
	}

	Tabii en normal durum sınıf bildirimi hangi isim alanı içerisinde yapılmışsa üye fonksiyon tanımalamarının da o isim alanının içerisinde yapılmasıdır. Tabii 
	using namespace direktifi ile yine sınıf isminin görülmesi sağlanabilir. Örneğin:

	namespace CSD
	{
		class Sample {
		public:
			void foo();
			void bar();
			//...
		};

		void Sample::foo()		// geçerli
		{
			//...
		}
	}

	using namespace CSD;

	void Sample::bar()		// geçerli
	{
		//...
	}

	Burada Sample ismi CSD ile niteliklendirilmemiştir. Çünkü zaten derleyici tarafından Sample ismi görülmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main()
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir üye fonksiyonun tanımlaması sınıf içerisinde yapılabilir. Ancak bu durumda üye fonksiyon inline kabul edilmektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo()		// foo inline
		{
			//...
		}

		void bar()		// bar inline
		{
			//...
		}
	};

	Bu nedenle programcılar inline olarak açılmasını istedikleri küçük küçük üye fonksiyonların tanımlamalarını doğrudan sınıf bildirimi içerisinde yapabilmektedir. 
	Tabii üye fonksiyonun prototipinin önüne inline anahtar sözcüğü getirilip fonksiyon yine dışarıda tanımlanırsa da inline olur. Ancak bu biçim pek tercih 
	edilmemektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		inline void foo();		// foo inlile
		inline void bar();		// bar inline
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Java ve C# gibi dillerde prototip olmadığı için mecburen sınıfın metotları sınıf içerisinde tanılanmaktadır. Bu dillerde inline diye bir kavram da yoktur. 
	Bu dillerde metotlar sınıfın içerisinde yazılmak zorunda olduğu için bölüm C++'taki gibi bölüm kavramının okunabilirliği azaltacağı düşünülmüştür. Bu nedenle 
	bu dillerde bölüm belirten anahtar sözcükler ayrıca her alan'da ve metotta belirtilmektedir. Örneğin:

	// Dikkat C#/Java örneği

	class Sample {
		private int a;
		private int b;

		public void foo()
		{
			//..
		}

		public void bar()
		{
			//...
		}

		void tar()			// C#'ta private, java'da internal
		{
			//...
		}
	}

	Bu dillerde alan ya da metotlarda erişim belirleyici anahtar sözcükler yazılmazsa default durum C#'ta private, Java'da ise internal kabul 
	edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo()
	{
		cout << "Sample::foo" << endl;
	}

	void bar(int a)
	{
		cout << "Sample::bar" << endl;
	}
};

int main()
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi C++'ta bir fonksiyon ya sınıfların dışında yani global bölgede bulunabilir ya da sınıfların içerisinde bulnabilir. Sınıfların 
	içerisinde bulunan fonksiyonlara "üye fonksiyon (member function)" dendiğini söylemiştik. Biz kurusuuzda sınıfların içerisinde olmayan C'de ki gibi fonksiyonlara  
	"global fonksiyonlar (global functions)" da diyeceğiz. Tabii global fonksiyon dendiğinde global isim alanındaki fonksiyonlar anlaşılmamlıdır. Global fonksiyonlar
	sınıfların içerisinde bulunmayan fonksiyonlardır. Yani herhangi bir isim alanın içerisinde bulunan ancak bir sınıfın içerisinde bulunmayan fonksiyonlara 
	"global fonksiyon" diyeceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta sınıflar (yapıların ve birliklerin de bir sınıf olduğunu anımsayınız) bir "faaliyet alanı (scaope)" da belirtmektedir. Dolayısıyla C++'ta farklı 
	sınıflarda aynı isimli ve aynı parametrik yapıya sahip fonksiyonlar bulunabilir. Bunlar farklı faaliyet alanlarında bulundurklarından sorun oluşturmazlar. 
	Tabii aynı zamanda aynı isimli ve aynı parametrik yapıya sahip bir global fonksiyon da bulunabilmektedir. Örneğin:

	class Sample {
	public:
		void foo();
		//...
	};

	class Test {
	public:
		void foo();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Test::foo()
	{
		//...
	}

	void foo()
	{
		//...
	}

	Örnekteki bu fonksiyonların hepsinin birlikte bulunmasında hiçbir sakınca yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıflar hem data hem de fonksiyonlara sahip olabiliyordu. C++'ta sınıflar içerisindeki fonksiyonların "üye fonksiyon (member function)" biçiminde isimlendirildiğini 
	belirtmiştik. İşte C++'ta sınıftaki data elemanlarına da "veri elemanları (data member)" denilmektedir. Hem üye fonksiyonlar hem de veri elemanları sınıfın 
	elemanlarıdır. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	Burada a ve b Sample sınıfının veri elemanlarıdır. foo ve bar ise üye fonksiyonlarıdır. Sınıflardaki veri elemanlarının isimlendirilmesi dilden dile 
	değişebilmektedir. Örneğin C# ve Java'da bunlara "alan (field)" denilmektedir. Python'da ise "öznitelik (attribute)" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta her sınıf bir tür de belirtmektedir. Sınıflar türünden nesneler tanımlanabilir. Örneğin:

	class Sample {
		//...
	};

	Sample s;			// s nesnesi Sample türünden
	class Sample k;		// tür isminde class ve struct sözcükleri de kullanılabilir, ancak gereksizdir.

	Sınıfların tür isimleri yalnızca sınıf isimleriyle belirtilebilmektedir. Ancak tür isminde class anahtar sözcüğü de kullanılabilir. Örneğin:

	class Sample {
		//...
	};

	int Sample;			// geçerli
	Sample s;			// geçersiz!
	class Sample k;		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi içerisinde sınıfın üye fonksiyonları (member functions) yer kaplamaz. Üye fonksiyonlar mantıksal bakımdan sınıfla ilişkilendirilmiş durumdadır. 
	Üye fonksiyonlar tıpkı global fonksiyonlar gibi programın ".text" denilen bölümünde yer kaplarlar. Sınıf nesnesi içerisinde yalnızca sınıfın "static olmayan 
	veri elemanları (nonstatic data member)" yer kaplamaktadır. C++'ta veri elemnanları ve üye fonksiyonlar static olabilir ya da static olmayabilir. 
	Static veri elemanları ve static üye fonksiyonlar ileri ele alınacaktır. Örneğin:

	class Sample {
	public:
		int a;				// nesne içerisinde yer kaplar
		int b;				// nesne içerisinde yer kaplar
		static int c;		// nesne içerisinde yer kaplamaz! static veri elemanları ileride ele alınacak

		void foo();			// nesne içerisinde yer kaplamaz
		void bar();			// nesne içerisinde yer kaplamaz
		static void tar();	// nesne içerisinde yer kaplamaz! static üye fonksiyonlar ileride ele alınacaktır. 
	};

	Pekiyi bir sınıf nesnesi içerisindeki eleman organizasyonu nasıldır? İşte sınıf türünden türünden nesneler statik olmayan veri elemanlarından oluşan bileşik 
	nesnelerdir. C++ standartlarına göre "iki bölüm belirten anahtar sözcük arasındaki veri elemanları ilk yazılan eleman düşük adreste olacak biçimde ardışıl 
	bir biçimde" yerleştirilir. Ancak farklı bölümlerdeki elemanların birbirlerine göre durumu standartlarda derleyicileri	yazanların isteğine bırakılmıştır. 
	Fakat yaygın tüm derleyiciler bölüm farkı gözetmeksizin ilk yazılan eleman düşük adreste olacak biçimde ardışıl bir yerleşim uygulmaktadır. Tabii yine 
	derleyiciler C'de olduğu gibi elemanlar arasında hizalama amaçlı kontrollü boşluklar (padding) bırakabilmektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;
	private:
		int c;
		int d;
	};

	Burada a ile b ve c ile d ilk yazılan eleman düşük adreste olacak biçimde ardışıl yerleştirilmek zorundadır. Ancak hangi bölümün nesnenin düşük adresinde 
	bulunacağı standartlarda derleyicileri yazanların isteğine bırakılmıştır. Yaygın derleyicilerin hepsi bölümleri dikkate almaksızın tıpkı yapılarda 
	olduğu gibi elemanları yukarıdan aşağıya doğru ardışıl dizmektedir. Standartlardaki anlatıma göre biz bir sınıf nesneninin adresini aldığımızda bu adres ile
	sınıfın ilk veri elemanının adresi aynı olmak zorunda olmak zorunda değildir. (Halbuki C'deki yapılarda bir yapı nesnesinin adresi onun ilk elemanının adresi 
	ile aynı olmak zorundadır. C'de yapı nesnelerinin başında derleyiciler padding uygulayamazlar.)

	Biz kurusmuzda gösterimlerde sınıfın veri elemanlarını ilk yazılan eleman düşük adreste olacak biçimde peşi sıra geliyormuş diziliyormuş gibi göstereceğiz. 
	Böylece bazı açıklamaları daha anlaşılabilir bir hale getirebileceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;	// s'in içerisinde yalnızca a ve b veri elemanları yer kaplıyor.

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
																25. Ders 08/11/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Üye fonksiyonlar global fonksiyonlar gibi doğrudan isim belirtilerek çağrılamazlar. Üye fonksiyonlar ilgili sınıf türünden bir nesne ile "." operatörü 
	kullanılarak çağrılırlar. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Sample s;			// s Sample sınıfı türünden bir nesne

	s.foo();			// üye fonksiyonlar ilgili sınıf türünden bir nesne ile çağrılabilir
	s.bar();			// üye fonksiyonlar ilgili sınıf türünden bir nesne ile çağrılabilir

	Görüldüğü gibi bir üye fonksiyonu çağırabilmek için önce ilgili sınıf türünden bir nesnenin tanımlanmış olması gerekmektedir. 

	Burada üye fonksiyonların Sample::foo() ve Sample::bar() biçiminde çağrılmadığına, ilgili sınıf türünden bir nesne kullanılarak çağrıldığına dikkat ediniz. 
	İleri üye fonksiyonların static de olabileceğini göreceğiz. static üye fonksiyonlar nesne olmadan sınıf ismiyle niteliklendirilerek (yani Sample::tar() gibi)
	çağrılabilmektedir. Ancak biz bu konuyu anlatana kadar zaten üye fonksiyonların static olmayan (nonstatic) üye fonksiyonlar olduğunu varsayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

void foo()
{
	cout << "global foo" << endl;
}

void bar()
{
	cout << "global bar" << endl;
}

int main()
{
	foo();		// global foo
	bar();		// global bar

	Sample s;		// s nesnesi Sample türünden

	s.foo();		// Sample sınıfının üye fonksiyonu olan foo
	s.bar();		// Sample sınıfının üye fonksiyonu olan bar

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların veri elemanlarına da yine ilgili sınıf türünden bir nesne ile "." operatörü kullanılarak erişilmektedir. Bu erişim biçimi zaten C'deki yapılarda 
	da böyledir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};
	//...

	Sample s;

	s.a = 10;			// geçerli
	s.b = 20;			// geçerli
	
	s.foo();			// geçerli
	s.bar();			// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;

	s.a = 10;
	s.b = 20;

	cout << s.a << endl;
	cout << s.b << endl;

	s.foo();
	s.bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta "sınıf faaliyet alanı (class scope)" isminde yeni bir faaliyet alanı daha vardır. Sınıf faaliyet alanı sınıf bildiriminin içerisinde ve
	sınıfın tüm üye fonksiyonların içerisinde bir ismin doğrudan kullanılabilirliğini anlatmaktadır. Bu durumda C++'ta faaliyet alanları genişten dara doğru 
	şöyledir:

	- Dosya faaliyet alanı (file scope)
	- Sınıf faaliyet alanı (class scope)
	- Fonksiyon faaliyet alanı (function scope)
	- Block faaliyet alanı (block scope)

	Sınıfın tüm elemanaları yani sınıf bildirimi içerisinde bildirilen tüm isimler sınıf faaliyet alanı kuralına uyarlar. Biz bu isimleri doğrudan üye fonksiyonlar 
	içerisinden kullanabiliriz. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	void Sample::foo()
	{
		a = 10;			// geçerli, a sınıf faaliyet alanına ilişkin 
		b = 20;			// geçerli b sınıf faaliyet alanına ilişkin 
	}

	void Sample::bar()
	{
		cout << a << endl;	// geçerli, a sınıf faaliyet alanına ilişkin 
		cout << b << endl;	// geçerli b sınıf faaliyet alanına ilişkin 

		foo();				// geçerli foo sınıf faaliyet alanına ilişkin
	}

	Burada sınıf bildiriminin içerisinde bildirilmiş olan a, b, foo ve bar değişkenleri "sınıf faaliyet alanı (class scope)" kuralına uymaktadır. Bu nedenle 
	bu isimler Sample sınıfının üye fonksiyonları içerisinde doğrudan (yani niteliklendirilmeden) kullanılabilirler. Sınıf faaliyet alanının "bir grup fonksiyon
	içerisinde" tanınma aralığı anlamına geldiğine ve bu nedenle fonksiyon faaliyet alanından daha geniş ancak dosya faaliyet alanından daha dar bir faaliyet
	alanı belirttiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	a = 10;			// geçerli, a sınıf faaliyet alanına ilişkin 
	b = 20;			// geçerli b sınıf faaliyet alanına ilişkin 
}

void Sample::bar()
{
	cout << a << endl;	// geçerli, a sınıf faaliyet alanına ilişkin 
	cout << b << endl;	// geçerli b sınıf faaliyet alanına ilişkin 

	foo();				// geçerli foo sınıf faaliyet alanına ilişkin
}

int main()
{
	//...

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir üye fonksiyonun içerisinde kullanılan sınıfın veri elemanları aslında o üye fonksiyon hangi nesne ile çağrılmışsa o nesnenin veri elemanlarıdır. 
	Zaten üye fonksiyonların nesne ile çağrılmasının nedeni budur. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void set(int x, int y);
		void disp();
	};

	void Sample::set(int x, int y)
	{
		a = x;
		b = y;
	}

	void Sample::disp()
	{
		cout << a << ", " << b << endl;
	}

	Buradaki set ve disp iye fonksiyonlarının içerisinde a ve b değişkenleri aslında bu üye fonksiyonlar hangi nesneyle çağrılırsa onun a ve b veri elemanlarıdır.
	Örneğin:

	Sample s, k;

	s.set(10, 20);
	k.set(30, 40);

	Burada s.set(10, 20) çağırısında 10 değeri s'in a elemanına, 20 değeri ise s'in b elemanına atanmaktadır. Benzer biçimde k.set(30, 40) çağrısında da 30 ve 40
	k nesnesinin a ve b elemanlarına atanmaktadır. Örneğin:

	s.disp();
	k.disp();

	Burada s.disp() çağrısındaki a ve b s nesnesinin a ve b elemanlarıdır. Bunların içeisinde 10 ve 20 bulunduğuna göre ekrana 10 ve 20 basılacaktır. k.disp()
	çağrısındaki a ve b ise k nesnesinin a ve b elemanlarıdır. k nesnesinin a ve b elemanlarında 30 ve 40 değerleri vardır. Bu durumda 30 ve 40 değerleri 
	ekrana basılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;
	Sample k;

	s.set(10, 20);
	k.set(30, 40);

	s.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bu durumda sınıfın veri elemanları ve üye fonksiyonları ne anlama gelmektedir? İşte sınıfın veri elemanları aslında üye fonksiyonlar tarafından ortak
	bir biçimde kullanılan data'ları temsil etmektedir. Sınıfın üye fonksiyonları aynı nesnenin veri elemanlarını ortak olarak kullanmaktadır. Bir üye 
	fonksiyon o elemanlara değer yerleştirdiğinde diğer bir üye fonksiyon o değerleri kullanabilmektedir. Sınıflar belli bir konuda faydalı işlemler yapan 
	üye fonksiyonlardan oluşmaktadır. Üye fonksiyonların da bu faydalı işlemleri yapabilmesi için ortak veri elemanlarını kullanması gerekmektedir. 

	NYPT'de sınıflar belli bir konu (kavram) üzerinde işlemler yapan üye fonksiyonlar gibi değerlendirilebilir. Örneğin Date isimli bir sınıf tarih konusunda 
	yararlı birtakım işlemleri yapan üye fonksiyonlara sahip olabilir. String isimli bir sınıf bir yazı üzerinde işelmler yapan üye fonksiyonlara sahip olabilir. 
	Benzer biçimde SerialPort isimli bir sınıf seri port işlemlerini yapan üye fonksiynlara sahip olabilir. 

	NYPT'de artık fonksiyonlar temelinde konuşmak yerine sınıflar temelinde konuşulur. Böylece "birbirinden farklı çok sayıda fonksiyon var" algısı yerine 
	"belli işlemleri yapan belli sınıflar var" oluşturulmaktadır. Bu da tasarım ve yazım işlemlerini algısal bakımdan kolaylaştırmaktadır. 

	O halde biz NYPT'de bir sınıf ile karşılaştığımıuzda "bu sınıfın belli bir konu üzerinde faydalı işlemler yapan üye fonksiyonlara sahip olduğunu, bu üye 
	fonksiyonların da sınıfın veri elemanlarını (yani nesnesinin parçalarını) ortak biçimde kullanıdığını" anlamalıyız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın bir üye fonksiyonu başka bir üye fonksiyonunu doğrudan (niteliklendirmeden) çağırabilir. Çünkü üye fonksiyonlar da sınıf faaliyet alanındadır. Bu durumda 
	çağıran üye fonksiyon hangi nesneyle çağrılmışsa çağrılan üye fonksiyonun da aynı nesneyle çağrılmış olduğu kabul edilir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void set(,nt x, int y);
		void disp();
	};

	void Sample::set(int x, int y)
	{
		a = x;
		b = y;

		disp();		// set hangi nesneyle çağrılmışsa disp de o nesneye çağrılmış gibi işlem görür
	}

	void Sample::disp()
	{
		cout << a << ", " << b << endl;
	}

	Burada set fonksiyonu şöyle çağrılmış olsun:

	Sample s;

	s.set(10, 20);

	Bu durumda set içerisindeki a ve b elemanları s nesnesinin a ve b elemanlarıdır. set üye fonksiyonu disp üye fonksiyonunu çağırmıştır. İşte burada sanki 
	disp üye fonksiyonu da s ile çağrılmış gibi bir etki oluşacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;

	disp();
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;

	s.set(10, 20);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															26. Ders 13/11/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın üye fonksiyonları da overload edilebilir. Yani bir sınıf içerisinde parametrik yapıları farklı olan aynı isimli üye fonksiyonlar bulunabilir. 
	Sınıfların da birer faaliyet alanı belirttiğini anımsayınız. Dolayısıyla farklı faaliyet alanlarında aynı isimli ve parametrik yapıya ilişkin (aynı imzaya 
	ilişkin) fonksiyonlar bulunabildiğine göre farklı sınıflarda aynı isimli ve aynı parametrik yapıya sahip üye fnksiyonlar buunabilir. Örneğin:

	class Sample {
		public:
			void foo(int a);
			void foo(double a);
			void foo(const char *str);
			//...
	};

	Bu durumda "overload resolution" işlemi daha önce açıkladığımız kurallarla yürütülmektedir. Yani önce aday fonksiyonlar seçilmekte, sonra onların arasından 
	uygun fonksiyonlar ve nihayet en uygun fonksiyon seçilmeye çalışılmaktadır. Biz üye fonksiyonu aynı türden bir sınıf nesnesi ile çağırdığımızda sınıftaki 
	aynı isimli tüm üye fonksiyonlar aday fonksiyonlar olarak seçilmektedir. 
	
	Örneğin:

	class Sample {
		public:
			void foo(int a);
			void foo(double a);
			void foo(const char *str);
			//...
	};

	Sample s;

	s.foo(10);		// foo(int)
	s.foo(12.3);	// foo(double)

	(Daha ileride sınıflarda türetme işlemlerini göreceğiz. Overload resolution sürecinde aday fonksiyonlar aşağıdan yukarı ismin ilk bulunduğu sınıftan 
	seçilmektedir. Taban sınıflardaki aynı isimli fonksiyonlar aday fonksiyon olarak alınmamaktadır. C++'taki Java ve C# dillerindne bu bakımdan farklıdır.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void foo(int a);
	void foo(double a);
	void foo(const char *str);
};

void Sample::foo(int a)
{
	cout << "foo(int)" << endl;
}

void Sample::foo(double a)
{
	cout << "foo(double)" << endl;
}

void Sample::foo(const char *tr)
{
	cout << "foo(const char *)" << endl;
}

int main()
{
	Sample s;

	s.foo('a');			// Sample::foo(int) çağrılır
	s.foo(3.14);		// Sample::foo(double) çağrılır
	s.foo("ankara");	// Sample::foo(const char *) çağrılır

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi yaratıldığında derleyici tarafından otomatik olarak çağrılan sınıfın özel üye fonksiyonlarına "yapıcı fonksiyonlar (constructors)" denilmektedir. 
	Yapıcı fonksiyonlar tipik olarak birtakım ilk işlemleri yapmak ve sınıfın veri elemanlarına birtakım ildeğerleri vermek için kullanılmaktadır. 

	Yapıcı fonksiyonlar sınıf ismiyle aynı isimli olan üye fonksiyonladır. Örneğin

	class Sample {
	public:
		Sample();			// yapısı fonksiyon
		void foo();			// normal bir üye fonksiyon
		//...
	};

	Sample::Sample()
	{
		//...
	}

	void Sample::foo()
	{
		//...
	}
	
	Yapıcı fonksiyonların geri dönüş değerleri diye kavramları yoktur. Bu nedenle yapıcı fonksiyonlarda geri dönüş değerlerinin türü yerine hiçbir şey yazılmaz.
	Geri dönüş değerinin türü yerine void yazmak da geçerli bir durum değildir. Çünkü "void" ger i dönüş değerinin olmadığı anlamına gelmektedir. Halbuki yapıcı
	fonksiyonların böyle bir kavramları yoktur. 

	Yapıcı fonksiyonlar içerisinde return deyimini kullanabiliriz. Ancak onun yanına bir ifade yazamayız. 

	Yapıcı fonksiyonlar ilgili sınıf türündne bir nesne yaratıldığında derleyici tarafından otomatik olarak çağrılmaktadır. Örneğin:

	Sample s;		// yapıcı fonksiyon çağrılacaktır

	Böylece bir nesne yaratıldığında o nesnenin ilişkin olduğu sınıfın hedeflediği amaçlar için birtakım ilk işlemler arka planda yapılmış olur. Örneğin:

	class SerialPort {
		//...
	};
	//...

	SerailPort sp;

	Burada yaratılan SerialPort nesnesi için yapıcı fonksiyon çağrılacaktır. Bu fonksiyon da seri port işlemleri için gerekli birtakım ilk işlemleri yapabilecektir. 

	Yapıcı fonksiyon içerisinde kullanolan sınıfın veri elemanarı o anda yaratılmış olan nesnenin veri elemanlarıdır. Örneğin:

	class Sample {
	public:
		Sample();
		void disp();

		int a;
		int b;
	};

	Sample::Sample()
	{
		a = 10;
		b = 20;
	}

	void Sample::disp()
	{
		cout << a << ", " << b << endl;
	}
	//...

	Sample s;

	s.disp()
	
	Burada s nesnesi yaratıldığında yapıcı fonksiyon çağrılacaktır. Onun içerisindeki a ve b elemanları s nesnesinin veri elemanıdır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	void disp();

	int a;
	int b;
};

Sample::Sample()
{
	a = 10;
	b = 20;
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın yapıcı fonksiyonları overload edilebilir. Yani sınıfta birden fazla yapıcı fonksiyon bulunabilir. Örneğin:

	class Sample {
	public:
		Sample();
		Sample(int a);
		Sample(double a);
		Sample(const char *str);
		//...
	};

	Parametresi olmayan yapıcı fonksiyona "default yapıcı fonksiyon (default constructor)" denilmektedir. Örneğin:

	class Sample {
	public:
		Sample();						// default constructor
		Sample(int a);
		Sample(double a);
		Sample(const char *str);
		//...
	};

	Eğer yapıcı fonksiyonun bütün parametreleri default değer almışsa bu yapıcı fonksiyon da "default yapıcı fonksiyon" olarak kullanılabilmektedir. Örneğin:

	class Sample {
	public:
		Sample(int a = 0);			// bu yapıcı fonksiyon parametre aldığı halde defauult yapıcı fonksiyon olarka da kullanılabilir
		Sample(double a);
		Sample(const char *str);
		//...
	};

	Bir sınıf nesnesi yaratılırken eğer isimden sonra hiç parantez açılmamışsa bu durumda derleyici nesne için sınıfın default yapıcı fonksiyonunu (default constructor)
	çağırır. Örneğin:

	Sample s;		// default yapıcı fonksiyonu çağrılır

	Eğer değişken isminden sonra parantezler açılırsa parantezlerin içerisine argümanlar yerleştirilir. Bu durumda çağrılacak yapıcı fonksiyon overload resolution 
	kuralına göre tespit edilir. Örneğin:

	class Sample {
	public:
		Sample();						// default constructor
		Sample(int a, int b);
		Sample(double a, double b);
		//...
	};
	//...


	Sample s(10, 20);		// int, int parametreye sahip yapıcı fonksiyon çağrılacaktır

	Bu durumda sınıfın bütün yapıcı fonksiyonları aday fonksiyonlardır. Bunlar arasından uygun olanlar seçilir ve uygun olanlar arasından da en uygun yapıcı fonksiyon 
	seçilmeye çalışılır. 

	C++11 ile birlikte "uniform initializer" sentaks dile eklendikten sonra nesne yaratırken normal parantezler yerine kğme parantezleri de kullanılabilmektedir. 
	Örneğin:

	Sample a{10, 20};		// C++11 ve sonrasında geçerli
	
	Ancak uniform initializer sentaksında "daraltıcı dönüştürmelere (narrowing conversion)" izin verilmediğini anımsayınız. Tabii daha önceden de belirttiğimiz gibi
	önce overload resolution işlemi yapılıp en uygun fonksiyon tespit edilir. Sonra bu fonksiyonun daraltıcı dönüştürmeye yol açıp açmadığına bakılır. Örneğin:

	class Sample {
	public:
		Sample();
		Sample(int a);
		//...
	};
	//...

	Sample s{3.14};

	Burada overload resolution işlemi sonucunda int parametreli fonksiyon seçilecektir. Ancak bu fonksiyon daraltıcı dönüştürme uyguladağı için tanımlama error ile 
	sonuçlanacaktır. Verilen hata mesajının bu biçimde olduğuna dikkat ediniz.
		
	Default yapıcı fonksiyon çağrılacak biçimde nesne yaratma işlemi aşağıdaki gibi yapılamamaktadır:

	Sample s();

	Çünkü bu bir nesne tanımlaması değil bir prototip bildirimidir. Tabii C++11 ile birlikte aşağıdaki tanımlama default yapıcı fonksiyonun çağrılması için geçerlidir:

	Sample s{};

	Çünkü böyle bir prototip bildirim sentaksı yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);

};

Sample::Sample()
{
	cout << "default constructor" << endl;

	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	cout << "int, int constructor" << endl;
	a = x;
	b = y;
}

int main()
{
	Sample s;					// default constructor
	Sample k(10, 20);			// int parametreli constructor

	cout << "ok" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yerel sınıf nesneleri için yapıcı fonksiyonlar programın akışı nesnenin tanımlandığı noktaya geldiğinde çağrılmaktadır. Örneğin:

	int main()
	{
		//...
		Sample s;			// akış bu noktaya geldiğinde s için default yapıcı fonksiyon çağrılır
		//...
		Sample k;			// akış bu noktaya geldiğinde k için default yapıcı fonksiyon çağrılır
		//....

		return 0;
	}

	Tabii birden fazla nesne aynı bildirimde de tanımlanabilir. Bu durumda yapıcı fonksiyonlar tanımlama sırasına göre çağrılacaktır. Örneğin:

	Sample s, k;		// önce s için sonra k için yapısı fonksiyon çağrılır

	Burada önce s için sonra k için yapısı fonksiyon çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Global sınıf nesneleri için yapıcı fonksiyonlar akış henüz main fonksiyonuna girmeden çağrılmaktadır. Çağrılma sırası kaynak dosyadaki (translation unit) 
	yuakarıdan aşağıya ve soldan sağa yönüne göredir. Yani kaynak kodda daha önce tanımlanan nesnenin yapıcı fonksiyonu daha sonra tanımlanandna önce çağrılır. 
	Ancak proje birden fazla kaynak dosyadan oluşyorsa kaynak dosyalardaki global nesneler birbirilerine göre yapıcı fonksiyon çağrılma sırası standartlarda 
	"belirsiz (unspecified)" bırakılmıştır. Örneğin:

	// a.cpp

	Sample g_a;
	Sample g_b;

	// b.cpp

	Sample g_x
	Sample g_y;

	Burada g_a nesnesi için yapıcı fonksiyon g_b nesnesi için yapıcı fonksiyondan daha önce çağrılır. Benzer biçimde g_x için yapıcı fonksiyon g_y için yapıcı 
	fonksiyondan daha önce çağrılacaktır. Ancak kaynak doslayar arasındaki sıra konusunda bir belirleme yapılmamıştır. 

	Aşağıdaki örneği çalıştırarak durumu inceleyiniz. Ekranda şunları göreceksiniz:

	Sample(int): 100
	Sample(int): 200
	Sample(int): 300
	main begins...
	Sample(int): 10
	Sample(int): 20
	main continues...
	Sample(int): 30
	main ends...

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x);
	//...
};

Sample::Sample(int x)
{
	cout << "Sample(int): " << x << endl;
}

Sample x{100};
Sample y{200};

int main()
{
	cout << "main begins..." << endl;

	Sample s{10}, k{20};

	cout << "main continues..." << endl;

	Sample m{30};

	cout << "main ends..." << endl;
		
	return 0;
}

Sample z{300};

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi static yerel sınıf nesneleri için yapıcı fonksiyonlar ne zaman çağrılmaktadır? İşte static yerel sınıf nesneleri için yapıcı fonksiyonlar "programın 
	akışı nesnenin tanımlandığı noktaya ilk kez geldiğinde yalnızca bir kez" çağrılmaktadır. Bu cümleden iki sonuç çıkmaktadır:

	1) Eğer akış static yerel sınıf nesnesinin tanımlandığı noktaya hiç gelmezse onun yapıcı fonksiyon hiç çağrılmayacaktır.
	2) Akış static yerel sınıf nesnelerinin tanımlandığı noktaya birden fazla kez gelirse yalnızca ilk gelişinde nesne için yapıcı fonksiyon çağrılacaktır.

	Aşağıdaki örneği çalıştırarak sonucu inceleyiniz. Ekrana şunları göreceksiniz:

	Sample(int): 100
	Sample(int): 200
	Sample(int): 300
	main begins...
	Sample(int): 10
	Sample(int): 20
	main continues...
	Sample(int): 30
	foo begins...
	Sample(int): 1000
	foo ends...
	foo begins...
	foo ends...
	main ends...
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x);
	//...
};

Sample::Sample(int x)
{
	cout << "Sample(int): " << x << endl;
}

Sample x{100};
Sample y{200};

void foo()
{
	cout << "foo begins..." << endl;

	static Sample s{1000};

	cout << "foo ends..." << endl;
}

int main()
{
	cout << "main begins..." << endl;

	Sample s{10}, k{20};

	cout << "main continues..." << endl;

	Sample m{30};

	foo();
	foo();

	cout << "main ends..." << endl;
		
	return 0;
}

Sample z{300};

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonun parametre değişkeni bir sınıf türünden olabilir. Örneğin:

	void foo(Sample k)
	{
		//...
	}

	Bu durumda biz fonksiyonu tipik olarak aynı sınıf türünden bir nesneyle çağırırız. Örneğin:

	Sample s;

	foo(s);

	Parametre değişikenlerinin fonksiyon çağrıldığında yaratıldığını anımsayınız. O zaman bu örnekte foo fonksiyonunun k isimli parametre değişkeni için 
	yapıcı fonksiyon bu fonksiyon çağrıldığında çağrılacaktır. Tabii fonksiyon her çağrıldığında yeni bir parametre değişkeni yaratıldığına göre yine yapıcı 
	fonksiyon çağrılacaktır. Ancak bu tür durumlarda parametre değişkenleri için ismine "kopya yapıcı fonksiyonu (copy constructor)" denilen özel bir yapıcı 
	fonksiyon çağrılmaktadır. Bu konu ileride ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer programcı sınıf için hiçbir yapıcı fonksiyon yazmamışsa (standart terminolojisi ile sınıfın "user provided" yapıcı fonksiyonu yoksa) bu durumda derleyici 
	sınıf için default yapıcı fonksiyonu public bölümde içi boş olarak inline biçimde (mümkünse aynı zamanda constexpr biçiminde) kendisi tanımlamaktadır. Böylece 
	biz bir sınıf için hiçbir yapıcı fonksiyon yazmadıysak o sınıf türünden default yapıcı fonksiyonun çağrılacağı bir nesne tanımlayabiliriz. Eğer biz bir sınıf 
	için herhangi bir yapıcı fonksiyon yazmışsak bu durumda	derleyici default yapıcı fonksiyonu kendisi yazmamaktadır. Örneğin:

	class Sample {
	public:
		Sample (int a);
		//...
	};
	//...

	Sample s;		// geçersiz! programcı sınıf için bir yapıcı fonksiyon yazmış, derleyici default yapıcı fonksiyonu yazmaz

	Burada programcı sınıf için bir yapıcı fonksiyon tanımladığından dolayı derleyici default yapıcı fonksiyonu kendisi tanımlamayacaktır. Örneğin:

	class Sample {
	public:
		void foo();
		void bar();
		//...
	};
	//...

	Sample s;			// geçerli! programcı sınıf için bir yapıcı fonksiyon yazmamış, derleyici default yapıcı fonksiyonu içi boş olarak kendisi yazacak,
	Sample k{10};		// geçersiz! derleyici yalnızca default yapıcı fonksiyonu biizm için yazmaktadır

	Burada programcı sınıf için hiçbir yapıcı fonksiyon yazmadığından derleyici default yapıcı fonksiyonu kendisi içi boş olarak yazmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	//...
};

class Mample {
public:
	Mample(int a)
	{}
};

int main()
{
	Sample s;		// geçerli, default yapıcı fonksiyon derleyici tarafından yazılmış
	Mample k;		// geçersiz! sınıf için programcı yapıcı fonksiyon yazdığından dolayı artık derleyici 
					// default yapıcı fonksiyonu kendisi yazmaz.

	Mample m(10);	// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yapıcı fonksiyonlar da default argüman alabilmektedir. Default argümanların imzayı değiştirmediğini anımsayınız. Örneğin:

	class Sample {
	public:
		Sample();				// default constructor
		Sample(int a = 0);		// default constructor olarak kullanılabilir
		//...
	};

	Burada bu iki üye fonksiyonun birlikte bulunmasının bir sakıncası yoktur. Çünkü bunların parametrik yapıları farklıdır. Fakat örneğin:

	Sample s;		// geçersiz! iki constructor da en uygun ve en uygun

	Burada derleyici iki yapıcı fonksiyondan birini tercih etmez. Overload resolution kurallarına göre bu durum "ambiguity" oluşturmaktadır. Tabii bu durumda
	int parametreli yapıcı fonksiyonun default değer almasının da bir anlamı yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta sınıfların yapıcı fonksiyonları programcı tarafından çağrılabilen fonksiyonlar değildir. Yine C++'ta yapıcı fonksiyonların adresleri de alınamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte "açıkça default hale getirilmiş default yapıcı fonksiyon (explicitly defaulted default constructor)" biçiminde bir kavram da dile eklenmiştir. 
	Bir default yapıcı fonksiyon için prototipten sonra " = default" sentaksı kullanılırsa bu sentaks "default yapıcı fonksiyonu içi boş olarak derleyici tarafından 
	yazılsın" anlamına gelmektedir. Örneğin:

	class Sample {
	public:
		Sample() = default;
		Sample(int a, int b);
		//...
	};

	Burada sınıfın başka bir yapıcı fonksiyonu olduğu için derleyici default yapıcı fonksiyonu kendiliğinden yazmayacaktır. İşte " = default" sentaksı bunu 
	sağlamaktadır. Tabii "= default" dentaksı yerine biz zaten içi boş bir default yapıcı fonksiyonu kendimiz de oluşturabilirdik. Ancak teknik anlamda aşağıdaki 
	iki tanımlama arasında bazı ince farklılıklar vardır:

	Sample() = default;
	Sample() {}

	Gövdesi boş default yapıcı fonksiyon teknik olarak "programcı tarafından yazılmış (user provided)" yapıcı fonksiyon olarak ele alınmaktadır. Halbuki açıkça
	default hale getirilmiş yapıcı fonksiyon bu biçimde ele alınmamaktadır. Bu ayrım da bazı konularda bazı ince anlam farklılıklarına yol açmaktadır. Bu konu 
	ileride başka konular içerisinde ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													27. Ders 15/11/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte "açıkça silinmiş default yapıcı fonksiyon (explicitly deleted default constructor)" sentaksı da dile eklenmiştir. Bir default yapıcı 
	fonksiyonda " = delete" sentaksı kullanılırsa artık derleyici sınıfın programcı tarafından yazılmış olan bir yapıcı fonksiyonu olmasa bile default yapıcı 
	fonksiyonunu kendisi yazmaz. Örneğin:

	class Sample {
	public:
		void foo();
		void bar();
		//...
	};

	Burada sınıf için hiçbir yapıcı fonksiyon yazılmadığı için derleyici defauşt yapıcı fonksiyonu içi boş olarak yazacaktır. Ancak biz default yapıcı fonksiyonu
	açıkça silinmiş hale getirirsek derleyici artık default yapıcı fonksiyonu biizm yazmaz. Örneğin:

	class Sample {
	public:
		Sample() = delete;		// açıkça silinmiş default yapıcı fonksiyon
		void foo();
		void bar();
		//...
	};

	Tabii bu durumda biz bu sınıf türünden nesne de yaratamayız. Çünkü nesne yaratımı sırasında sınıfın yapıcı fonksiyonu çağrılacaktır. Bu sınıfta yapıcı fonksiyon 
	olmadığı için yaratım girişimi error ile sonuçlanacaktır. Örneğin:

	Sample s;		// geçersiz! sınıfın default yapıcı fonksiyonu yok

	Pekiyi açıkça silinmiş default yapıcı fonksiyon oluşturmaya ne gerek vardır? Bir sınıf türürnden hiçbir nesne tanımlayamadıktan sonra sınıfın bulumasının 
	bir anlamı olabilir mi? Şimdiye kadar gördüğümüz konular dikkate alındığında sanki bunun bir anlamı yokmuş gibi bir fikir oluşabilir. Ancak ileride görülecek 
	bazı konulardan sonra bunun bazı kullanımlarının olabileceğini göreceksiniz. Aşağıdaki sınıf bildiriminde default yapıcı fonksiyonun açıkça silinmesi 
	geçerli bir durum oluştursa da anlamsızdır:

	class Sample {
	public:
		Sample() = delete;		// geçerli ama anlamsız
		Sample(int a);
		void foo();
		void bar();
		//...
	};

	Burada zaten programcı sınıfa bir yapıcı yerleştirdiği için default yapıcı fonksiyon derleyici tarafından yazılmayacaktır. Zaten yazılmayacak olan fonksiyonun 
	yazılmamasını istemenin bir anlamı yoktur.

	Açıkça deleted hale getirme dışında C++11 ve sonrasında standartlarda bazı anlatım değişikliklerine gidilmiş ve "özel üye fonksiyonların (special member functions)"
	bazı durumlarda derleyici tarafından "deleted" yapılacağı standartlara eklenmiştir. Yani örneğin biz sınıfın default yapıcı fonksiyonunu açıkça deleted yapmasak
	bile bazı koşullar altında derleyici kendisinin yazdığı bu default yapıcı fonksiyonu deleted hale getirmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = delete;
	//...
};

int main()
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bir sınıf için hiçbir yapıcı fonksiyon yazmamışsak ya da bir yapıcı fonksiyon içerisinde sınıfın veri elemanlarına hiç değer atamadıysak nesnenin bu 
	veri elemanlarında hangi değerler bulunacaktır? Örneğin:

	class Sample {
	public:
		int a, b;
		void foo();
		void bar();
	};
	//...

	Sample s;		// s'in a ve b elemanlarında hangi değerler vardır?

	Bu konu ileride MIL sentaksı içerisinde haada detaylı bir biçimde açıklanacaktır. Ancak burada pratik bazı şeyler söylmek istiyoruz. Eğer sınıfın yapıcı 
	fonksiyonlarında veri elemanlarına değer atanmamışsa kabaca (ayrıntılar ileride ele alınacak) şu durumlar söz konusudur:

	1) Eğer sınıf nesnesi yerel ise sınıfın temel türlere ilişkin veri elemanlarına herhangi bir değer atanmaz. Dolayısıyla o elemanlarda çöp değer bulunur. 
	Yani yukarıdaki örnekte s nesnesi yerel ise tanımlama sonrasında a ve b veri elemanlarında çöp değerler (indeterminate values) bulunacaktır. (Buna standartlarda 
	"default-initilize" denilmektedir: 9.4.1-6)

	2) Eğer sınıf nesnesi statik ömürlüyse (global ya da static yerel) sınıfın temel türlere ilişkin veri elemanlarına 0 değeri yerleştirilmektedir. (Buna da 
	standartlarda "zero-initialize" denilmektedir: 9.4.1-6).
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standartlarda "kullanıcı tarafından yazılmış olan default yapıcı fonksiyon (user-provided default constructor)" terimi default yapıcı fonksiyonun programcı 
	tarafından açıkça yazıldığını belirtmektedir. Açıkça default hale getirilmiş (explicitly defaulted) ve silinmiş (deleted) default yapıcı fonksiyonlar 
	"user-provided" yapıcı fonksiyon" değillerdir. Bir sınıfta hiçbir yapıcı fonksiyon yoksa derleyicinin yazdığı default yapıcı
	fonksiyon da "user-provided" değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların yapıcı üye fonksiyonlarının temelde iki işlevi vardır:

	1) Sınıfın konusuyla ilgili bazı ilk işlemleri yapmak.
	2) Sınıfın veri elemanlarına bazı ilkdeğeri vermek.

	Sınıfın yapıcı fonksiyonlarının programcıdan aldığı değerleri sınıfın veri elemanlarına yerleştirmesi çok karşılaşılan bir durumdur. Bu biçimde basit set
	işlemleri yapan yapıcı fonksiyonların inline biçimde tanımlanması iyi bir tekniktir.

	Aşağıdaki örnekte Date sınıfının yapıcı fonksiyonları sınıfın veri elemanlarına ilkdeğerlerini vermektedir. Bu örnekte üç parametreli yapıcı fonksiyonun 
	aldığı bu değerleri sınıfın veri elemanlarına yerleştirdiğine dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	Date()
	{
		day = 1;
		month = 1;
		year = 1900;
	}
	Date(int d, int m, int y)
	{
		day = d;
		month = m;
		year = y;
	}

	void disp();

	int day, month, year;
};

void Date::disp()
{
	cout << day << '/' << month << '/' << year << endl;
}

int main()
{
	Date d;
	Date k(15, 11, 2023);

	d.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Complex sınıfının real ve imag isimli iki veri elemanı bulunmaktadır. Sınıfın iki parametreli yapıcı fonksiyonunun dış dünyadan aldığı 
	değerleri bu veri elemanlarına yerleştirdiğine dikkat ediniz. Sınıfın defautl yapıcı fonksiyonu açıkça defaulted hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Complex {
public:
	Complex() = default;
	Complex(double r, double i)
	{
		real = r;
		imag = i;
	}

	void disp();

	double real;
	double imag;
};

void Complex::disp()
{
	cout << real << "+" << imag << 'i' << endl;
}

int main()
{
	Complex z;				// dikkat! veri elemanlarında çöp değerler var
	Complex k{2, 4};

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte "default member initializer" ismiyle sınıfın veri elemanlarına sınıf bildirimi içerisinde ilkdeğer verme sentaksı da dile eklenmiştir. 
	Aslında sınıfın veri elemanalrına sınıf bildirimi içerisinde ilkdeğer verme zaten Java ve C# gibi dillerde çok önceden beri bulunyordu. C++ bu özelliği 
	C++11 ile bünyesine katmıştır. Bu özelliğe göre biz sınıfın veri elemanalrına yapıcı fonksiyonun yanı sıra istersek artık sınıf bildirimi içerisinde de 
	ilkdeğer verebiliriz. Örneğin:

	class Complex {
	public:
		Complex()
		{}
		double real = 0;
		double imag = 0;
	};

	Anımsanacağı gibi C'de yapılar için böyle bir sentaks yoktur. Pekiyi bu sentaks ne anlama gelmektedir? Aslında derleyiciler bu durumda veri elemanına verilen 
	ilkdeğerlerin hepsini bildirim sırasına göre atama deyimlerine dönüştürerek sınıfın tüm yapıcı fonksiyonlarının ana bloğunun başına gizli bir biçimde 
	yerleştirmektedir. Yani bu ilkdeğerler aslında sınıfın tüm yapıcı fonksiyonlarında ilgili veri elemanına verilmiş gibi bir işlem söz konusu olmaktadır. 
	Standartlar bir veri elemanına hem sınıf bildirimi içerisinde hem de yapıcı fonksiyonda ilkdeğer verildiğinde sınıf bildirimind everilen ilkdeğerin dikkate
	alınmayacağını (ignore edileceğini) belirtmektedir. Bu anlatım verilen ilkdeğerilerin atama deyimlerine dönüştürülerek tüm yapıcı fonksiyonların başına 
	yerleştirilmesi anlatımı ile aynı anlama gelmektedir. 

	Pekiyi eskiden olmayan bu zöelliğin C++11 ile eklenmesinin ne amacı vardır? İşte sınıfın çok veri elemanı ve çok yapıcı fonksiyonu olabilir. Bazı veri 
	elemanlarına her yapıcı fonksiyonda aynı ilkdeğerler veriliyor olabilir. Bu özellik sayesinde programcı bu elemanlara tüm yapıcı fonksiyonalar içerisinde 
	aynı değeri atamak yerine sınıf bildirimi içerisinde bir kez bu atamayı yapabilir. 

	Sınıf bildirimi içerisinde veri elemanlarına verilen ilkdeğerlerin sabit ifadesi olması gerekmez. Aslında bu ilkdeğer verme işlemi sanki yapıcı fonksiyon 
	içerisinde yapılıyormuş gibi düşünülmelidir. Dolayısıyla isim araması buna göre yapılmaktadır. Yani bu atama işlemleri yapıcı fonksiyon içerisinde yapılabiliyorsa
	sınıf bildirimi içerisinde de yapılabilmektedir. Örneğin:

	class Sample {
	public:
		int a = 10;
		int b = a + 1;
		//...
	};
	//...

	Sample s;

	Burada s nesnesinin a elemanında 10, b elemanında 11 bulunacaktır. Aşağıdaki örnekte s nesnesinin a elemanında 1, k nesnesinin a elemanında 2 değeri 
	bulunacaktır:

	int g_x = 0;

	class Sample {
	public:
		int a = ++g_x;
		//...
	};

	int main()
	{
		Sample s, k;

		cout << s.a << endl;			// 1
		cout << k.a << endl;			// 2

		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarında nesnelere "default olarak ilkdeğer vermekte" anlatımı kolaylaştırmak için üç terim kullanılmaktadır: 

	1) Default-initialization
	2) Zero-initialization
	3) Value-initialization

	Bu tanımlar genel olarak nesneye belli bir ilkdeğer verilmediğinde nesnenin nasıl ilkdeğer alacağı konusunda kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarında bir nesneye ilkdeğer verilmesi için kullanılan "default-initialize" terimi kabaca şu anlama gelmektedir:

	1) Eğer nesne bir sınıf türündense nesne için sınıfın default yapıcı fonksiyonu çağrılır.
	2) Eğer nesne bir dizi türündense dizinin her elemanı için "default ilkdeğer verme" işlemi uygulanır.
	3) Diğer durumlarda (yani nesne temel türlerdense, enum türündense vs.) nesneye herhangi bir ilkdeğer verilmez. Yani nesnede çöp değer kalır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarında bir nesneye ilkdeğer verilmesi için kullanılan "zero-initialize" terimi ise kabaca şu anlama gelmektedir:

	1) Eğer nesne temel türlerdense ya da gösterici türündense (standartlarda bu kümeye "scaler types" denilmektedir) nesneye sanki 0 değeri atanıyor gibi işlem
	yapılır. (Göstericilere 0 değerinin atanmasının onlara NULL adresin atanması anlamına geldiğini anımsayınız.)
	2) Eğer nesne sınıf türündense nesnenin tüm statik olmayan veri elemanları "zero-initilize" edilir. Ayrıca padding bitleri de sıfırlanmaktadır.
	3) Eğer nesne bir dizi ise dizinin her elemanı "zero-initilize" yapılır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarında bir nesneye ilkdeğer verilmesi için kullanılan "value-initialize" terimi ise kabaca şu anlama gelmektedir:

	1) Eğer nesne bir sınıf türündense ve sınıfın default yapıcı fonksiyonu yoksa ya da default yapıcı fonksiyonu silinmişse bu durum geçersizdir (error 
	oluşturmaktadır).
	2) Eğer nesne bir sınıf türündense ve sınıfın "user-provided" default yapıcı fonksiyonu varsa nesne default-initilze edilir (yani nesnenin default yapıcı 
	fonksiyonu çağrılır.)
	3) Eğer nesne bir dizi türündense dizinin her elemanı "value-initialize" edilir. 
	4) Diğer bütün durumlarda nesne "zero-initliaze" edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu terimlerde en çok "default-initialize" ile "value-initialize" birbirleriyle karışıtırılmaktadır. Default-initialize kabaca "sınıflar için default yapıcı 
	fonksiyonu çağır, diğer nesneler için ilkdeğer verme" anlamına gelmektedir. Halbuki value-inialize kabaca "sınıflar için eğer user-provided default yapıcı 
	fonksiyon varsa onu çağır yoksa zero-initiliaze yap" anlamına gelmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarına göre herhangi bir türden yerel nesne tanımlanırken ilkdeğer verilmezse (yani değişken isminden sonra normal parantez ya da küme parantezi 
	kullanılmamışsa) nesne "default-initialize" edilmektedir. Örneğin:

	{
		int a;
		Sample s;
		//...
	}

	Burada a da, s de "default-initialize" edilir. 

	Eğer nesne statik ömürlü ise ve temel türlerdense nesneye ilkdeğer verilmemesi durumunda nesne "zero-initialize" yapılmaktadır. Statik ömürlü sınıf nesneleri 
	işin başında (program yüklenirken) önce "zero-initialize" yapılır. Sonra onlar üzerinde tanımlama biçimine göre "default-initialize", "value-initialize"
	işlemi uygulanır ya da uygun yapıcı fonksiyon çağrılır.

	int g_a;
	Sample g_s;

	Burada her iki nesnenin de global olduğunu varsayalım. Her iki nesne de başlangıçta "zero-inialize" edilecektir. Ancak g_s nesnesi için default yapıcı fonksiyon 
	da çağrılacaktır. Böylece bu yapıcı fonksiyon sınıfın temel türlere ilişkin bazı veri elemanlarına değer atamamışsa onların içerisinde de 0 olacaktır. 
	g_s'nin ilkdeğer verilmesini şöyle de açıklayabiliriz: Bu nesne için önce "zero-initialize" uygulanır sonra hiç parantezler kullanılmadığı için "default-initialize"
	uygulanır. Nesne içi boş küme parantezleri ile tanımlanırsa bu durumda "value-initialize" işlemi uygulanmaktadır. Örneğin:

	int a{};
	Sample s{};

	Burada a nesnesi "value-initialize" edilecek dolayısıyla içerisine 0 değeri yerleştirilecektir. s nesnesi de "value-initialize" edilecek. (Yani eğer sınıfın 
	"user-provided default yapıcı fonksiyonu" varsa o çağrılacak yoksa nesne sıfırlanacak.)

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta yapıcı fonksiyonların sınıfın veri elemanlarına ilkdeğerlerini vermesi için ismine "MIL Sentaksı (Member Initializer Syntax)" ya standart terminolojisi ile
	"ctor-initializer" denilen alternatif bir sentaks da bulunmaktadır. MIL sentaksı başından beri C++'ta zaten vardı. MIL sentaksı bazı durumlarda alternatif 
	bir ilkdeğer verme biçimi olarak, bazı durumlarda da zorunlu bir ilkdeğer verme biçimi olarak kullanılmaktadır. İleride bu sentaksın semantiğine ilişkin 
	ayrıntılı bilgiler vereceğiz. Burada yalnızca sentaksın yalın kullanımını ve anlamını açıklayacağız. 

	MIL sentaksı yalnızca yapıcı fonksiyonların tanımlamalarında kullanılabilen bir sentakstır. Bu sentaks başka üye fonksiyonlarda ya da global fonksiyonlarda 
	kullanılamamaktadır. Sınıfın ismi T olmak üzere sentaksın genel biçimi şöyledir:

	T::T(...) : veri_elemanın_ismi(ilkeğer_ifadesi), veri_elemanın_ismi{ilkdeğer_ifadesi}, veri_elemanın_ismi{ilkdeğer_ifadesi}, ...
	{
		//...
	}

	Görüldüğü gibi yapıcı fonksiyonun kapanış parantezinden sonra önce bir ":" atomu sonra da veri elemanın ismi ve parantezler içerisinde ona verilecek ilkdeğer 
	belirtilmektedir. C++11'e kadar buradaki parantezler normal parantez olmak zorundaydı. C++11 ile birlikte "uniform initializer syntax" dile eklenince buradaki 
	parantezler için küme parantezleri de kullanılmaya başlandı. Yine küme parantezleri ile ilkdeğer verilirken "daraltıcı dönüştürmelere (narrowing conversion)" 
	izin verilmemektedir. 

	Aşağıda MIL sentaksının (ctor-initializer) kullanımına bir örnek verilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x, int y);
	void disp();
public:
	int a; 
	int b; 
	//...
};

Sample::Sample(int x, int y) : a(x), b(y)
{}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s(10, 20);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														28. Ders 20/11/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	MIL sentaksı aslında sınıfın başka sınıf türünden veri elemanlarına ilkdeğer vermek için ve taban sınıfa ilkdeğer vermek için de kullanılmaktadır. Yani 
	sentaksın semantiği biraz ayrıntılıdır. Biz burada geldiğimiz yere kadarki konuları dikkate alarak bir semantik açıklama yapacağız. 

	MIL sentaksındaki ilkdeğer ifadesinde kullanılan isimler aranması nasıl olmaktadır? Yani biz burada hangi değişkenleri kulanabiliriz? İşte bu ilkdeğer 
	ifadesinideki değişkenler sanki yapıcı fonksiyonun ana bloğunun hemen başında kullanılıyormuş gibi bir etki oluşturmaktadır. Yani isim araması sanki buradaki 
	isimler yapıcı fonksiyonun ana bloğunun başına kullanılmış gibi yapılmaktadır. Dolayısıyla biz ilkdeğer ifadesinde parametre değişkenlerini, global değişkenleri
	ve sınıfın veri elemanlarını kullanabiliriz. Örneğin:

	class Sample {
	public:
		Sample(int x);
		//...

		int a, b;
	};

	int g_x = 10;

	Sample::Sample(int x) : a(x + 1), b(g_x + 2)		// geçerli
	{}

	C++'ta önce her zaman MIL sentaksında belirtilen ilkdeğer vermeler yapılır. Sonra yapıcı fonksiyonun ana bloğu çalıştırılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta gelecekteki konuları da kapsayacak biçimde "ilkdeğer verme sırası hiçbir zaman MIL sentaksındaki sıraya göre yapılmamaktadır. Her zaman bildirimdeki
	sıraya göre yapılmaktadır." Örneğin:

	class Sample {
	public:
		Sample();
		//...
		int a, b, c;
	};

	Sample::Sample() : c(10), b(20), a(30)
	{}

	Burada ilkdeğer verme sırası MIL sentaksındaki sıraya göre yapılmayacaktır. İlkdeğer verme her zaman bildirdimdeki sıraya göre yapılmaktadır. Yani burada 
	kesinlikle önce a = 30, sonra b = 20 ve sonra da c = 10 işlemi yapılacaktır. 

	Örneğin:

	class Sample {
	public:
		Sample();
		//...
		int a, b, c;
	};

	Sample::Sample() : c(10), b(c), a(b)
	{}

	Biz sınıfın veri elemanlarına MIL sentaksı ile ilkdeğer verirken diğer veri elemanlarını kullanabiliriz. Ancak ilkdeğer verme sırası MIL sentaksındaki 
	sıraya göre değil bildirimdeki sıraya göre yapılmaktadır. Dolayısıyla burada a ve b değişkenlerine çöp değerler atanacaktır. C'de ve C++'ta genel olarak
	çöp değerleri kullanmak "tanımsız davranış (undefined behavior)" kabul edilmektedir. 

	Yukarıda da belirttğimiz gibi her zaman önce MIL sentaksındaki ilkdeğer verm işlemi bildirimdeki sıraya göre yapılmakta sonra yapıcı fonksiyonun ana bloğu 
	çalıştırılmaktadır. Bu durumda biz sınıfın bir veri elemanına hem MIL sentaksında hem de yapıcı fonksiyonun ana bloğunda değer atarsak ana blokta atadığımız
	değer nihai değer olarak veri elemanında kalacaktır. Örneğin:

	Sample::Sample() : a(10), b(20), c(30)
	{
		a = 100;
	}

	Burada nesnenin a veri elemanında 100 bulunacaktır. 

	C++ derleyicileri tipik olarak MIL sentaksındaki ilkdeğer verme işlemlerini atama deyimlerine dönüştürerek gizlice yapıcı fonksiyonunana bloğunun başına 
	yerleştirmektedir. Böylece örneğin:

	Sample::Sample() : a(10), b(20), c(30)
	{
		a = 100;
	}

	İşlemi için derleyici aşağıdaki gibi bir kod üretmektedir:

	Sample::Sample() 
	{
		a = 10;		// derleyici tarafından gizlice yerleştiriliyor
		b = 20;		// derleyici tarafından gizlice yerleştiriliyor
		c = 30;		// derleyici tarafından gizlice yerleştiriliyor

		a = 100;
	}

	C++ standartlarına göre eğer bir veri elemanına MIL sentaksında ilkdeğer verilmemişse o veri elemanı henüz akış yapıcı fonksiyonun ana bloğuna girmeden
	"default-initialize" edilmektedir. Örneğin:

	class Sample {
	public:
		Sample();
		//...
		int a, b, c;
	};

	Sample::Sample() : c(10), a(30)
	{
		b = 20;
	}

	Burada standartlara göre şu işlemler gerçekleşecektir: 

	1) Önce a'ya 30 atanır.
	2) b deafult-initialize edilir. b temel türlerden olduğu için onun default-initialize edilmesi ona herhangi bir atamanın yapılmayacağı anlamına gelmektedir. 
	Yani onun içerisinde çöp bir değer olacaktır.
	3) c'ye 10 atanır.
	4) Yapıcı fonksiyonun ana bloğu çalıştırılır. Orada b'ye 20 atanmıştır. 

	Buradan birkaç sonuç çıkarabiliriz:

	1) Sınıfın temel türlere ilişkin veri elemanlarına MIL sentaksıyla ilkdeğer verme ile yapıcı fonksiyonun ana bloğu içerisinde ilkdeğer verme arasında 
	bir farklılık yoktur. (Ancak sınıfın başka sınıf türünden veri elemanları söz konusu olduğunda bu durum değişmektedir.)

	2) Biz sınıfın temel türlere ilişkin veri elemanlarına ne MIL sentaksında ne de yapıcı fonksiyonun ana bloğunda ilkdeğer vermemişsek bu durumda o veri elemanında 
	çöp değer bulunacaktır. 

	C++11 ile birlikte sınıfın veri elemanlarına sınıf bildirimi içerisinde ilkdeğer verilebiliyordu (default member initializer). Bu ilkdeğerlerin de derleyiciler 
	tarafından sınıfın yapıcı fonksiyonlarının başına taşındığından bahsetmiştik. Pekiyi hem bir veri elemanına sınıf bildirimi içerisinde ilkdeğer verilmişse hem de 
	MIl sentaksında ilkdeğer verilmişse veri elemanında hangi değer bulunacaktır? C++ standartları bu durumda sınıf bildiriminde verilen ilkdeğerin dikkate alınmayacağını
	yani MIL sentaksındaki değerin veri elemanında gözzükeceğini belirtmektedir. Örneğin:

	#include <iostream>

	using namespace std;

	class Sample {
	public:
		Sample();
		void disp();
	public:
		int a = 10;

		//...
	};

	Sample::Sample() : a(100)
	{}

	void Sample::disp()
	{
		cout << a << endl;
	}

	int main()
	{
		Sample s;

		s.disp();			// 100

		return 0;
	}

	Pekiyi bu durumda sınıfın veri elemanlarına MIL sentaksında ilkdeğer vermeye gerek var mıdır? Yukarıdaki anlatımdan da anlaşılacağı gibi sınıfın temel türlerden 
	veri elemanları için MIL sentaksının kullanılmasına gerek yoktur. Ancak ileride ele alacağımız konularla birlikte MIL sentaksının bazı durumlarda mecburen 
	kullanılması gerektiğini göreceksiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte dile "delege yapıcı fonksiyon çağrımı (delagating constructors)" özelliği de eklenmiştir. Aslında bu özellik Java ve C# gibi dillerde 
	zaten hep vardı. C++'a C++11 ile eklendi. Delege yapıcı fonksiyon çağrımı aslında bir yapıcı fonksiyonun diğerini çağırabilmesi özelliğidir. Sınıfın çok sayıda
	yapıcı fonksiyonu varsa ve bu fonksiyonlarda ortak birtakım işlemler ve ilkdeğer vermeler yapılıyorsa eskiden kod tekrarını engellemek için normal üye 
	fonksiyonlar kullanılıyordu. Delege yapıcı fonksiyon çağırımı sayesinde artık çoğu kez buna gerek kalmamaktadır. Örneğin:

	class Sample {
	public:
		Sample();
		Sample(int x);
		void disp();
		//...

		int a;
	};

	Burada iki yapıcı fonksiyonda da ortak şeylerin yapıldığını varsayalım. Eskiden kod tekrarını engellemek için aşağıdaki gibi bir yöntem kullanılıyrodu:

	Sample::Sample()
	{
		common_initialize();
		//...
	}

	Sample::Sample(int a)
	{
		common_initialize();
		//...
	}

	Halbuki artık bir yapıcı fonksiyon diğerini çağırabildiği için böyle bir ortak fonksiyon oluşturmaya gerek kalmamaktadır. 

	Delege yapıcı fonksiyon çağrımı MIL sentaksında yapıcı fonksiyonun belirtilmesiyle sağlanmaktadır. Örneğin:

	Sample::Sample() : Sample(0)
	{
		//...
	}

	Burada default yapıcı fonksiyon int parametreli yapıcı fonksiyonu çağırmıştır.

	MIL sentaksında delege yapıcı fonksiyon kullanılacaksa artık başka hiçbir ilkdeğer verme uygulanamaz. Yani MIL sentaksının yalnızca delege yapıcı fonksiyon
	çağrımını içermesi gerekmektedir. Örneğin:

	Sample::Sample() : Sample(0), a(10)		// geçersiz! yalnızca delege yapıcı fonksiyon çağrımı bulunabilir
	{}

	Bir yapıcı fonksiyonun MIL sentaksında delege yapıcı fonksiyon çağrımı varsa önce delege yapıcı fonksiyon çağrılır sonra o yapıcı fonksiyonun ana bloğu işletilir. 
	Tabii bir yapıcı fonksiyon başka bir yapıcı fonksiyonu o da başka bir yapıcı fonksiyonu çağırabilir. Ancak bu çağrımlar sırasında döngsüsel bir durum durum 
	oluşursa programın akışı sonsuz döngüye girebilir. Bu durum genel olarak "tanımsız davranış (undefined behavior)" oluşturmaktadır. 

	Yukarıda da belirttiğimiz gibi delege yapıcı fonksiyon çağrımı özellikle sınıfın çok fazla yapıcı fonksiyonu olduğunda ve bu yapıcı fonksiyonlarda orta 
	birtakım şeyler yapıldığında kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	Sample(int x);
	Sample(int x, int y);
	void disp();

	int a;
	int b;
	//...
};

Sample::Sample() : Sample(10, 20)
{
	cout << "default constructor" << endl;
}

Sample::Sample(int x) : Sample(x, 10)
{
	cout << "int constructor" << endl;
}


Sample::Sample(int x, int y) 
{
	// ortak yapılması gereken şeylerü
	cout << "common codes..." << endl;

	cout << "int, int constructor" << endl;

	a = x;
	b = y;
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;
	Sample k(10);

	s.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														29. Ders 22/11/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin yaşamı sona ererken yani sınıf nesnesi bellekten yok edilmeden hemen önce derleyici tarafından otomatik olarak çağrılan üye fonksiyona
	"yıkıcı fonksiyon (destructor)" denilmektedir. Yıkıcı fonksiyonların isimleri ~sınıf_ismi biçimindedir. (~ ile sınıf ismi bitişik yazılmak zorundadır).
	Yıkıcı fonksiyonların da geri dönüş değerleri biçiminde bir kavramları yoktur. Yani bunların da geri dönüş değerleri yerine bir şey yazılmaz. Yıkıcı fonksiyonlar
	overload edilemezler. Yıkıcı fonksiyonlar parametresiz biçimde bulunmak zorundadır. Örneğin:

	class Sample {
	public:
		Sample();		// default constructor
		~Sample();		// destructor
		//...
	};

	Sample::Sample()
	{
		//...
	}

	Sample::~Sample()
	{
		//...
	}

	Yıkıcı fonksiyonlar yapıcı fonksiyonlar tarafından yapılan birtakım ilk işlemleri geri almak amacıyla kullanılmaktadır. Ancak yıkıcı fonksiyonlara yapıcı 
	fonksiyonlar kadar çok gereksinim duyulmamaktadır. Çünkü bir sınıf nesnesi için o nesne yok edilirken yapılacak özel bir şeyler	olmayabilir. Eğer programcı 
	sınıf için yıkıcı fonksiyon yazmamışsa derleyici yıkıcı fonksiyonu içi boş olarak public inline biçiminde (ve duruma göre constexpr olacak biçimde) yazmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	~Sample();
	//...
};

Sample::Sample()
{
	cout << "default constructor" << endl;
}

Sample::~Sample()
{
	cout << "dstructor" << endl;
}

int main()
{
	Sample s;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yerel sınıf nesneleri için yıkıcı fonksiyonlar programın akışı o yerel nesnenin tanımlandığı bloğun sonuna geldiğinde çağrılmaktadır. Örneğin:

	foo()
	{
		//...
		{
			Sample s;		// default constructor
			//....
		}					// ----> destructor
		//...
	}

	Global sınıf nesneleri için yıkıcı fonksiyonlar programın akışı main fonksiyonundan çıktıktan sonra çağrılmaktadır. Örneğin:

	Sample g_s;			// default constructor

	main()
	{
		//...

		return 0;
	}

	Burada g_s global sınıf nesnesi için yapıcı fonksiyon akış main fonksiyonuna girmeden, yıkıcı fonksiyon ise akış main fonksiyonundan çıktığında çağrılacaktır.

	static yerel sınıf nesneleri için yıkıcı fonksiyonlar "eğer onlar için yapıcı fonksiyon çağrılmışsa" akış main fonksiyonundan çıktıktan sonra çağrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta şimdiye kadar gördüğümüz konuları ve gelecekte de göreceğimiz konuları kapsayacak biçimde yapıcı ve yıkıcı fonksiyonların çağrılma sıraları hakkında 
	genel bir kural vardır: "Yapıcı fonksiyonlarla yıkıcı fonksiyonlar her zaman ters sırada çağrılırlar." Yani örneğin x sınıf nesnesi için yapıcı fonksiyon y 
	sınıf nesnesi için yapıcı fonksiyondan daha önce çağrılmışsa x sınıf nesnesi için yıkıcı fonksiyon y sınıf nesnesi için yıkıcı fonksiyondan daha sonra çağrılacaktır. 
	Örneğin:

	int main()
	{
		Sample s, k;
		//...
	
		return;
	}

	Burada önce s için sonra k için yapıcı fonksiyonlar çağrılır. Ancak yıkıcı fonksiyonlar ters sırada yani önce k için sonra s için çağrılacaktır. Örneğin:

	int main()
	{
		Sample s;
		//...

		{
			Sample k;
			//...
		}

		//...

		return 0;
	}

	Burada akış gereği önce s için sonra k için yapıcı fonksiyon çağrılır. O halde yıkıcı fonksiyonlar da önce k için sonra s için çağrılacaktır. Örneğin:

	Sample g_x, g_y;

	int main()
	{
		//...

		return 0;
	}

	Burada akış main fonksiyonuna girmeden önce g_x için sonra g_y için yapıcı fonksiyonlar çağrılacaktır. Akış main fonksiyonundan çıktığında ise önce g_y için
	sonra g_x için yıkıcı fonksiyonlar çağrılacaktır. 

	Aşağıdaki programı derleyerek çalıştırınız. Bu programda hangi sınıf sınıf nesneleri için yapıcı ve yıkıcı fonksiyonların çağrıldığı anlaşılmaktadır. 
	Programın çıktısına bakarak yukarıda ifade ettiğimiz kuralın geçerli olduğunu doğrulayınız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int x);
	~Sample();

	int a;
};

Sample::Sample(int x) : a(x)
{
	cout << "int constructor: "  << a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << a << endl;
}

void foo()
{
	cout << "foo begins..." << endl;

	static Sample s(50);
	
	cout << "foo ends..." << endl;
}

Sample s(10), k(20), m(30);

int main()
{
	cout << "main begins..." << endl;

	Sample x(100), y(200);

	{
		cout << "nested block begins..." << endl;

		Sample r(1000), z(2000);

		cout << "nested block ends..." << endl;
	}
	
	foo();
	foo();

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi yıkıcı fonksiyonlar "yapıcı fonksiyonlarda yapılan birtakım tahsisatları otomatik geri bırakmak" için kullanılmaktadır. 
	Eğer yapıcı fonksiyon içerisinde böylesi bir tahsisat yapılmamışsa sınıf için yıkıcı fonksiyon yazmaya da gerek yoktur. Örneğin aşağıdaki gibi bir sınıf
	için programcının yıkıcı fonksiyonu yazmasına gerek yoktur. Ancak biz sınıfın aslında yıkıcı fonksiyonunun olduğunu düşünmeliyiz. Çünkü biz bir 
	sınıf için yıkıcı fonksiyon yazmamışsak derleyici onun için yıkıcı fonksiyonu içi boş olarak public inline biçiminde yazmaktadır. (Bazı durumlarda derleyici 
	yıkıcı fonksiyonu yazamayabilir. C++11 ve sonrasında bu duruma "defaulted" yıkıcı fonksiyonun "deleted" yapılması denilmektedir.) Bu konu ileride ele alınacaktır. 

	#include <iostream>

	using namespace std;

	class Complex {
	public:
		Complex(double r = 0, double i = 0)
		{
			real = r;
			imag = i;
		}

		void disp();

		double real, imag;
	};

	void Complex::disp()
	{
		cout << real << '+' << imag << 'i' << endl;
	}

	int main()
	{
		Complex z{3, 2};

		z.disp();

		return 0;
	}

	C++20 ile birlikte sınıf şablonlarında alternatif yıkıcı fonksiyonlar bulunabildiği için standart dokğmanlarında bolca "destructor" yerine "prospective destructor"
	terimi kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirtitğimiz yıkıcı fonksiyonlar "yapıcı fonksiyonlar içerisinde yapılan birtakım ilk işlemlerin otomatik yok edilmesi amacıyla" kullanılmaktadır. 
	Örneğin yapıcı fonksiyon içerisinde new operatörü ile bir bellek tahsisatı yapılmış olabilir, bu tahsisat yıkıcı fonksiyon içerisinde delete operatörüyle
	free hale getirilebilir. 

	Aşağıdaki örnekte String sınıfının str isimli veri elemanı için sınıfın yapıcı fonksiyonunda bir tahsisat yapılmıştır. Bu tahsisat sınıfın yıkıcı fonksiyonunda 
	serbest bırakılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstring>

using namespace std;

class String {
public:
	String(const char *s);
	~String();
	void disp();
	//...
	
	char *str;
};

String::String(const char *s)
{
	str = new char[strlen(s) + 1];
	strcpy(str, s);
}

String::~String()
{
	delete[] str;
}

void String::disp()
{
	cout << str << endl;
}

int main()
{
	cout << "main begins..." << endl;

	String s{"izmir"};

	{
		String k{"ankara"};

		k.disp();
	}
	
	cout << "main ends..." << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bir sınıfın yapıcı fonksiyonu bir dosya açmış olabilir. Bu dosyanın kapatılması yıkıcı fonksiyon tarafından otomatik yapılabilir. Aşağıdaki örnekte
	yapıcı fonksiyon içerisinde dosya açılmış, yıkıcı fonksiyon içerisinde dosya kapatılmıştır. Bu örnekte bir noktaya dikkat ediniz. Yapıcı fonksiyon içerisinde
	dosya açım işleminin başarısını kontrol kontrol ettik ancak başarısızlığın gereğini yapamadık. Bu bir kusurdur. Pekiyi başarısızlık durumunda ne yapabilrdik?
	Programın tümden sonlandırılması iyi bir teknik değildir. Öte yandan bir mesaj veriyor olsak bile program çalışma devam edecek ve tanımsız davranışlar oluşacaktır. 
	İşte yapıcı fonksiyonlardaki başarısızlıklarda genel olarak "exception" fırlatılmaktadır. Biz henüz o konuyu görmedik. Örneğimiz cerr nesnesini de kullandık. 
	cout "stdout dosyasına", cerr ise "stderr dosyasına" yazım yapmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstdio>

using namespace std;

class File {
public:
	File(const char *path, const char *mode = nullptr);
	~File();
	void type();
	//...
	
	FILE *f;
};

File::File(const char *path, const char *mode)
{
	f = fopen(path, mode == nullptr ? "r" : mode);		// başarısızlık kontrol edilip exception fırlatılabilir

	if (f == nullptr)
		cerr << "cannot open file: " << path << endl;
}

File::~File()
{
	fclose(f);
}

void File::type()
{
	int ch;

	while ((ch = fgetc(f)) != EOF)
		cout << (char)ch;

	if (ferror(f)) 
		cerr << "cannot read file!.." << endl;
}

int main()
{
	//...

	{
		File file("xxxx.cpp");

		file.type();
	}

	//...
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıdaki sınıfı delege yapıcı fonksiyon çağırma sentaksı ile de aşağıdkai gibi oluşturabilirdik. Genel olarak delege yapıcı fonksiyonu çağırma burada bize
	önemli bir fayda sağlamamaktadır. Dolayısıyla bu tür durumlarda default argüman kullanmayı tercih edebilirsiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstdio>

using namespace std;

class File {
public:
	File(const char *path);
	File(const char *path, const char *mode);
	~File();
	void type();
	//...
	
	FILE *f;
};

File::File(const char *path) : File(path, "r")
{}

File::File(const char *path, const char *mode)
{
	f = fopen(path, mode );		// başarısızlık kontrol edilip exception fırlatılabilir

	if (f == nullptr)
		cerr << "cannot open file: " << path << endl;
}

File::~File()
{
	fclose(f);
}

void File::type()
{
	int ch;

	while ((ch = fgetc(f)) != EOF)
		cout << (char)ch;

	if (ferror(f)) 
		cerr << "cannot read file!.." << endl;
}

int main()
{
	//...

	{
		File file("sample.cpp");

		file.type();
	}

	//...
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi sınıfın yapıcı fonksiyonları programcı tarafından çağrılamamaktadır. Ancak sınıfın yıkıcı fonksiyonları programcı tarafından çağrılabilir. 
	Yıkıcı fonksiyonların birdeb fazla kez çağrılması da genel olarak tanımsız davranış oluşturmaktadır. Örneğin:

	{
		Sample s;
		//...
		s.~Sample();			// geçerli
	}							// ancak blok sonunda yine yıkıcı fonksiyon çağrılacaktır, tanımsız davranış

	Burada sınıfın yıkıcı fonksiyonu iki kez çağrılmış olmaktadır. Dolaysıyla tanımsız davranış söz konusudur. Yıkıcı fonksiyonların açıkça programcı tarafından 
	çağrılması çok seyrek bir gereklilik oluşturmaktadır. (Örneğin placement new fonksiyonu ile birlikte bu özellik kullanılabilmektedir.) Yıkıcı fonksiyon 
	ancak bir nesne ya da gösterici yoluyla çağrılabilir. Bir üye fonksiyon tarafından doğrudan çağrılamaz. Örneğin:

	void Sample::foo()
	{
		//...

		~Sample();		// geçersiz!
	}

	Yıkıcı fonksiyonların yine adresleri alınamamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte sınıfların yıkıcı fonksiyonları da "defaulted" ve "deleted" yapılabilmektedir. Zaten bir sınıf için yıkıcı fonksiyon yazılmamışsa derleyici 
	tarafından yıkıcı fonksiyonun içi boş olarak yazıldığını belirtmiştik. O halde bir yıkıcı fonksiyonun "defaulted" yapılmasının anlamı ne olabilir? Aslında 
	toplamda yıkıcı fonksiyonun açıkça "defaulted" yapılması ancak teorik açıklamalar için kullanılmaktadır. Yıkıcı fonksiyon açıkça "deleted" yapılırsa artık 
	biz o sınıf türünden nesneyi yok edemeyiz. Çünkü yok ederken yıkıcı fonksiyon çağrılmaktadır. Bu tür durumlarda hata link aşamasında değil derleme aşamasında 
	ortaya çıkmaktadır. Yine açıkça "deleted" yıkıcı fonksiyonlar ancak "static sınıflar için" anlamlı olabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	Sample() = default;
	~Sample() = delete;
};

int main()
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın veri elemanları tüm üye fonksiyonlar içerisinden doğrudan kullanılabilmektedir. İşte bu durum faaliyet alanı bakımından bu veri elemanı isimlerinin 
	yanlışlıkla	gizlenmesi sonucunu doğurabilmektedir. Örneğin bir üye fonksiyonun parametre değişkeni sınıfın bir veri elemanının ismiyle aynı olursa biz bu üye 
	fonksiyon içerisinde artık sınıfın bu veri elemanına erişemeyiz: Çünkü C'de ve C++'ta aynı blokta birden fazla aynı isimli değişken faaliyet gösteriyorsa o 
	blokta dar faaliyet alanına	sahip olan değişkenlere erişilebilmektedir. Örneğin:

	class Date {
	public:
		Date(int day, int month, int year)
		{
			day = day;
			month = nonth;
			year = year;
		}
		//...

		int day, month, year;
	};
	
	Burada yapıcı fonksiyonda biz parametre değişkenlerini sınıfn veri elemanlarına atamamaktayız. Parametre değişkenlerini kendi kendilerine atamaktayız. 
		
	Yine bir üye fonksiyonu inceleyen kişi oradaki değişkenin bir veri elemanı olup olmadığını çabuk anlarsa kodu daha iyi anlamlandırabilir. İşte bu nedenlerden 
	dolayı C++ programcıları genellikle sınıfın veri elemanlarını özel öneklerle ya da soneklerle isimlendirmektedir. Örneğin Microsoft sınıfların veri elemanlarını 
	m_xxxx biçiminde "m_" öneki ile isimlendirmektedir. Bazı programcılar da "d_" önekini tercih ederler. Bazı programcılar ismin sonuna '_' getirirler. Biz de 
	kursumuzda bundan sonra sınıfların bütün veri elemanlarını m_xxxx biçiminde "m_" öneki ile isimlendireceğiz. Örneğin:

	class Date {
	public:
		Date(int day, int month, int year)
		{
			m_day = day;
			m_month = nonth;
			m_year = year;
		}
		//...

		int m_day, m_month, m_year;
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	int m_day, m_month, m_year;

	Date(int d, int m, int y);
	void disp();
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main()
{
	Date date(10, 12, 1995);

	date.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														30. Ders 04/12/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin adresi alınabilir. Bu adres aynı türden bir sınıf göstericisine atanabilir. Örneğin:

	class Sample {
	public:
		//...

		int m_a;
		int m_b;
	};
	//...

	Sample s;
	Sample *ps;

	ps = &s;

	Burada &s ifadesi Sample türünden bir adres bilgisi oluşturmaktadır. Yani &s ifadesi Sample * türündendir. Nasıl C'de bir yapı nesnesi yoluyla yapı elemanlarına
	nokta operatörüyle, yapı türünden adres yoluyla yapı elemanlarına ok operatörüyle eriiliyorsa C++'ta da erişim benzerdir. ps bir sınıf türünden gösterici 
	ve m_a bu sınıfın bir veri elemanı olmak üzere erişim (*ps).m_a ifadesiyle de ps->m_a ifadesiyle de yapılabilir. Benzer biçimde foo bu sınıfın bir üye 
	fonksiyonu olmak üzere ps göstericisi ile bu üye fonksiyon (*ps).foo(...) ifadesi ile de ps->foo(...) ifadesi ile de çağrılabilir. 

	Bir sınıf türünden gösterici ile sınıfın bir üye fonksiyonunu çağırdığımızda üye fonksiyon içerisindeki veri elemanları aslında göstericinin gösterdiği
	yerdeki nesnenin veri elemanlarıdır. Örneğin:

	Sample s;

	ps = &s;
	ps->foo();

	Burada foo fonksiyonu içerisindeki veri elemanları ps göstericisinin gösterdiği yerdeki nesnenin veri elemanlarıdır. ps göstericisinin gösterdiği yerde s
	nesnesi olduğuna göre buradaki veri elemanları aslında s nesnensinin veri elemanlarıdır. Zaten bu çağrı da aşağıdakiyle eşdeğerdir:

	(*ps).foo();

	Burada *ps zaten s anlamına geldiğine göre yine foo fonksiyonundaki veri elemanları s'in veri elemanlarıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{}

	void disp();

	int m_a;
	int m_b;
};

void Sample::disp()
{
	cout << m_a << ", " << m_b << endl;
}

int main()
{
	Sample s{10, 20};
	Sample *ps;

	ps = &s;

	ps->disp();
	(*ps).disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   new operatörüyle sınıf nesnesi dinamik olarak heap'te de tahsis edilebilir. Bu durumda önce programın çalışma zamanı sırasında heap'te sınıfın veri elemanlarını
   tutacak büyüklükte dinamik bir alan tahsis edilir sonra o alan için sınıfın uygun yapıcı fonksiyonu çağrılır. Yani new operatörü hem dinamik tahsisatı yapmakta
   hem de tahsis edilmiş olan alan için sınıfın uygun yapıcı fonksiyonunu çağırmaktadır. Örneğin:

   class Sample {
	public:
		Sample(int a, int b) : m_a(a), m_b(b)
		{}

		void disp();

		int m_a;
		int m_b;
	};

	Burada dinamik tahsisatı şöyle yapabiliriz:

	Sample *ps;

	ps = new Sample(10, 20);

	Artık ps göstericisinin gösterdiği yerdeki nesnenin m_a ve m_b veri elemanlarında sırasıyla 10 ve 20 değerleri bulunacaktır. new operatörünün türü belirli 
	bir adres verdiğine dikkat ediniz. Bu örnekte new operatörü Sample türünden bir adres vermektedir. 

	new operatörüyle tahsis edilmiş olan dinamik alanların delete operatörüyle boşaltıldığını anımsayınız. O halde yukarıdaki dinamik tahsisat şöyle boşaltılabilir:

	delete ps;

	delete operatörü de boşaltımı yapmadan hemen önce sınıfın yıkıcı fonksiyonunu çağırmaktadır. Nasıl new operatörü sınıfın yapıcı fonksiyonunun çağrılmasına 
	yol açıyorsa delete operatörü de sınıfın yıkıcı fonksiyonun çağrılmasına yol açmaktadır. 

	Bir sınıf türünden gösterici tanımladığımızda sınıf nesnesi tanımlamış olmayız. Bu nedenle bir yapıcı fonksiyonun çağrılmasını beklemeyiniz. Örneğin:

	Sample *ps;

	Burada sınıf nesnesi yaratılmamaktadır. Yalnızca bir gösterici yaratılmaktadır. Nesnenin yaratımının new işlemi sırasında yapıldığına dikkat ediniz. 

	Aşağıdaki örnekte Sample sınıfı türünden new operatörüyle dinam ik bir nesne yaratılmış ve sonra nesne delete operatöryle yok edilmiştir. Örnekte new 
	operatörünün heap'te dinamik yaratılan nesne için yapıcı fonksiyonu çağırdığına, delete operatörünün de yıkıcı fonksiyonu çağırdığına dikkat ediniz. 
	Programı çalıştırdığınızda ekranda şunları göreceksiniz:

	one
	Sample constructor
	two
	Sample destructor
	three
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b);
	~Sample();
	void disp();

	int m_a;
	int m_b;
};

Sample::Sample(int a, int b) : m_a(a), m_b(b)
{
	cout << "Sample constructor" << endl;
}

Sample::~Sample()
{
	cout << "Sample destructor" << endl;
}

void Sample::disp()
{
	cout << m_a << ", " << m_b << endl;
}

int main()
{
	Sample *ps;

	cout << "one" << endl;

	ps = new Sample(10, 20);

	cout << "two" << endl;

	delete ps;

	cout << "three" << endl;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new operatörüyle bir sınıf nesnesi için tahsisat yapılırken aşağıdaki dört sentaks biçimi kullanılabilir:
	
	1) new T(...)
	2) new T{...}
	3) new T;
	4) new T() veya new T{};
	
	1) Birinci biçimde tahsisat sonrasında sınıfın argüman yapısına en uygun olan yapıcı fonksiyonu çağrılır. Yani sınıfın bütün yapıcı fonksiyonları aday 
	fonksiyonlardır. Bunların arasındna uygun olanlar ve nihayet en uygun yapıcı fonksiyon seçilir. 

	2) İkinci biçimde yine birinci biçimde olduğu gibi en uygun yapıcı fonksiyon seçilir. Ancak bu fonksiyonun "daraltıcı dönüştürme (narrowing converison)"
	oluşturmaması gerekir. Eğer seçilen yapıcı fonksiyon daraltıcı dönüştürme oluşturursa yaratım geçersiz olur. 

	3) Burada dinamik yaratılan nesne "default-initialize" yapılmaktadır. Yani sınıfın default yapıcı fonksiyonu varsa o çağrılacaktır, yoksa yaratım geçersizdir.

	4) Burada dinamiik yaratılan nesne "value-initialize" yapılmaktadır. Yani sınııfn "user-provided" yapıcı fonksiyonu varsa o çağrılır, ancak default yapıcı 
	fonksiyonu var fakat "user provided" değilse nesne "zero-initialize" edilecektir. 

	Burada üç ve dördüncü maddeler arasındaki ince farka dikkat ediniz:

	class Sample {
	public:
		int m_a;
		int m_b;
	};

	auto *ps = new Sample;

	Burada nesnenin m_a ve m_b elemanlarında çöp değerler bulunacaktır. Fakat örneğin:

	auto *ps = new Sample();

	Burada artık nesnenin m_a ve m_b elemanlarında 0 bulunacaktır. Bu iki madde arasındaki farklılık genellikle C++ programcıları tarafından pek bilinmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void disp();

	int m_a;
	int m_b;
};

void Sample::disp()
{
	cout << m_a << ", " << m_b << endl;
}

int main()
{
	auto ps1 = new Sample;

	ps1->disp();		// dikkat çöp değerler

	auto ps2 = new Sample();

	ps2->disp();		// sıfır değerleri 

	delete ps2;
	delete ps1;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bir sınıf nesnesinin dinamik bir biçimde tahsis edilmesine neden gereksinim duyulmaktadır? İşte biz bir sınıf nesnesini programın belli bir notasında 
	yaratıp	belli bir noktasında yok etmek isteyebiliriz. Yerel sınıf nesneleriyle ve global sınıf nesneleriyle bunun yapılması mümkün değildir. Biz bir sınıf 
	nesnesini yerel olarak yarattığımızda yaratım akış tanımlamanın yapıldığı yere geldiğinde yapılmaktadır. Ancak nesnenin yok edilmesi akışın o yerel nesnenin 
	içinde bulunduğu bloğun sonuna gelmesiyle yapılır. Oysa biz new operatörü ile nesneyi herhangi bir yerde yaratıp herhangi bir yerde yok edebiliriz. Örneğin:

	{
		Sample *ps;
		//...

		{
			ps = new Sample();		// nesne bu noktada yaratıldı
			//...
		}
		//...

		delete ps;					// nesnene bu noktada yok ediliyor
		//...
	}

	Aşağıdkai örneği incelyiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b);
	~Sample();
	void disp();

	int m_a;
	int m_b;
};

Sample::Sample(int a, int b) : m_a{a}, m_b{b}
{
	cout << "constructor" << endl;
}

Sample::~Sample() 
{
	cout << "destructor" << endl;
}

void Sample::disp()
{
	cout << m_a << ", " << m_b << endl;
}

int main()
{
	Sample *ps;

	cout << "one" << endl;

	{
		cout << "two" << endl;

		ps = new Sample(10, 20);

		cout << "three" << endl;
	}

	ps->disp();

	cout << "four" << endl;

	delete ps;

	cout << "five" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi pek çok sistemde (ama garantisi yok) program sonlandığında heap alanı boşaltıldığı için dinamik tahsisatlar yok edilmiş gibi olmaktadır. 
	Çünkü Windows gibi UNIX/Linux gibi macOS gibi işletim sistemlerinin bulunduğu sistemlerde heap alanı prosese özgüdür. Tabii C ve C++ standartlarında aslında
	heap alanının prosese özgü olup olmadığı konusunda bir şey söylenmemiştir. C++'ta bir sınıf nesnesini new operatöryle dinamik bir biçimde tahsis edip onu 
	delete operatöryle yok etmemişsek program sonlandığında onun o dinamik nesne için yıkıcı fonksiyon çağrılmaz. Mevcut sistemlerin hemen hepsinde heap alanı 
	prosese özgü olduğu için bu dinamik nesnenin kapladığı alan proses sonlandığında yok edilecektir ancak yıkıcı fonksiyon çağrılmayacaktır. Başka bir deyişle
	dinamik tahsis edilmiş olan sınıf nesneleri için eğer delete işlemi yapılmamışsa hiçbir biçimde yıkıcı fonksiyon çalıştırılmamktadır.Örneğin:

	{
		Sample *ps = new Sample();
		//...
	}

	Buarada akış bloğu bitirdiğinde ps göstericisinin faaliyet alanı artık sonlanacak ve bu gösterici stack'ten yok edilecektir. Ancak onun gösterdiği yerdeki 
	nesne heap'te kalmaya devam edecektir. Bu durum en azından bir "bellek sızıntısı (memory leak)" oluşturacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıflar türünden referanslar tanımlanabilir. Bir sınıf türünden sol taraf değeri referansı aynı sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanmak 
	zorundadır. Örneğin:

	Sample s;
	Sample &r = s;

	Bu işlemin eşdeğer gösterici karşılığı şöyle oluşturulabilir:

	Sample s;
	Sample *r = &s;

	Bir referans ile sınıfın elemanlarına erişmek için ok operatörü değil nokta operatörü kullanılmaktadır. Çünkü referansı ilkdeğer verdikten sonra kullandığımızda
	artık referansın refere ettiği nesneyi kullanmış olmaktayız. Örneğin:

	Sample s;
	Sample &r = s;

	r.foo();		// dikkat ok operatörü değil, nokta operatörü ile erişim yapılıyor

	Tabii bir sınıf türünden sağ taraf değeri referansı da oluşturulabilir. Ancak bu durumda ilkdeğer olarak verilen nesnenin aynı sınıf türünden bir sağ taraf 
	değeri belirtmesi gerekir. Sınıflar türünden sağ taraf değeri oluşturma ile ilgili konuları henüz görmedik. Bu nedenle buna ilişkin açık bir örnek henüz 
	veremiyoruz:

	Sample &&r = <Sample sınıfı türünden sağ taraf değeri belirten bir nesne>;
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}

private:
	int m_a;
};

int main()
{
	Sample s(10);
	Sample &r = s;

	r.disp();			// 10
	r.set_a(20);
	s.disp();			// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi fonksiyona parametre yoluyla aktarılabilir. Tıpkı C'de bir yapı nesnesinin fonksiyona "atama yoluyla (call by value)" ve adres yoluyla (call
	by reference) aktarılmasında olduğu gibi C++'ta sınıf nesneleri de atama yoluyla ve adres yoluyla fonksiyonlara aktarılabilmektedir. Örneğin Sample bir 
	sınıf belirtiyor olsun:

	void foo(Sample k)
	{
		//...
	}
	//...

	Sample s;

	foo(s);

	Burada atama yoluyla aktarım söz konusudur. Yani s'in veri elemanlarının hepsi k'ya kopyalanacaktır. Genel olarak atama yoluyla aktarım (call by value)
	kötü bir tekniktir. Ayrıca C++'ta bu tür durumlarda parametre değişkeni için ismine "kopya yapıcı fonksiyonu (copy constructor)" denilen bir yapıcı fonksiyon
	çağrılmaktadır. Kopya yapıcı fonksiyonları ileride ayrı bir başlık halinde ele alınacaktır.

	Tıpkı C'deki yapılarda olduğu gibi sınıf nesneleri fonksiyonlara adres yoluyla aktarılmalıdır. Anımsanacağı gibi C++'ta adres yoluyla aktarım göstericilerle
	ve referanslarla yapılabiliyordu. Bu iki aktarım biçimi arasında bir performans farkı bulunmuyordu. Ancak referanslar bu bağlamda daha güvenli olan göstericiler
	gibi işlev gördüğü için aktarımda referans kullanımı daha yaygndır. Gösterici yoluyla aktarımda fonksiyonun parametre değişkeni ilgili sınıf türünden gösterici 
	olur. Fonksiyon da aynı sınıf türünden bir nesnenin adresiyle çağrılır. Örneğin:

	void foo(Sample *ps)
	{
		//...
	}
	//...

	Sample s;

	foo(&s);

	Fonksiyonun içerisinde ok operatörrüyle sınıfın veri elemanlarına ve üye fonksiyonlarına erişilebilir. Referans yoluyla aktarımda fonksiyonun parametre 
	değişkeni ilgili sınıf türünden referans (sol taraf değeri referansı) olur. Fonksiyon da aynı sınıf türünden nesnenin kendisiyle çağrılır. Örneğin:

	void foo(Sample &r)
	{
		//...
	}
	//...

	Sample s;

	foo(s);		// dikkat! nesnenin adresini programcı değil derleyici almaktadır

	Fonksiyonun içerisinde sınıfın veri elemanlarına ve üye fonksiyonlarına nokta operatörüyle erişilmektedir. 

	Anımsanacağı gibi C'de fonksiyonun parametre değişkeni bir gösterici ise eğer fonksiyon adresini aldığı nesneyi değiştirmeyecekse parametrenin "gösterdiği yer 
	const olan const bir gösterici" yapılması iyi bir tekniktir. Aynı durum C++'ta parametre değişkeni olan referanslar için de söz konusudur. Ancak biz const 
	nesneleri ve const sınıf göstericilerini ve referanslarını ayrı bir paragrafta ele alacağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b);
	void disp();

	int m_a;
	int m_b;
};

Sample::Sample(int a, int b) : m_a{a}, m_b{b}
{}

void Sample::disp()
{
	cout << m_a << ", " << m_b << endl;
}

void foo(Sample *ps)
{
	ps->disp();
}

void bar(Sample &r)
{
	r.disp();
}

int main()
{
	Sample s{10, 20};

	foo(&s);
	bar(s);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	SInıflar türünden diziler de oluşturulabilmektedir. Örneğin Sample bir sınıf belirtmek üzere bu sınıf türünden 5 elemanlı bir diziyi şöyle oluşturabiliriz:

	Sample s[5];

	Burada s dizisinin her elemanı Sample sınıfı türünden bir nesnedir. Dolayısıyla buradaki dizinin her elemanı için sırasıyla sınıfın default yapıcı fonksiyonu 
	çağrılacaktır. C++'ta sınıflar türünden diziler oluştururken sınıfın başka bir yapıcı fonksiyonun çağrılması mümkün değildir. Yani aşağıdaki gibi bir sentaks 
	bunu yapamamaktadır:

	Sample s[5](10);			// geçerli değil

	C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonların ters sırada çağrıldığını belirtmiştik. Bu dizi de yok edileceği zaman yıkıcı fonksiyonlar 
	ters sırada çağrılacaktır. Aşağıdkai örnek kod ile bunu doğrulayabiliriz. Bu örneği çalıştırdığınızda ekranda şunları göreceksiniz:

	default constructor: 0
	default constructor: 1
	default constructor: 2
	default constructor: 3
	default constructor: 4
	destructor: 4
	destructor: 3
	destructor: 2
	destructor: 1
	destructor: 0
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	Sample(int a) :m_a(a) {}
	~Sample();
	
	void disp();

	int m_a;
};

int g_a;

Sample::Sample()
{
	m_a = g_a++;
	cout << "default constructor: " << m_a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << m_a << endl;
}

int main()
{
	Sample s[5];
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													31. Ders 06/12/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Her ne kadar henüz sınıflar türünden geçici yaratmayı görmemiş olsak da bir sınıf türünden dizilerin tanımlanmasında küme parantezleri ile ilkdeğer 
	verilerek dizi elemanları için istenilen yapıcı fonksiyonların çağrılması sağlanabilmektedir. Örneğin:

	Sample s[10] = {Sample(), Sample(10), Sample(), Sample(20)};

	T bir sınıf belirtmek üzere C++'ta T(...) ifadesi "T türünden geçici nesne yarat" anlamına gelmektedir. Örneğimizde yaratılan bu geçici nesne dizi elemanlarına
	atanacaktır. C++17 ve sonrasında bu tür durumlarda artık "copy elision" zorunlu hale getirilmiştir. Bu paragrafın ne anlam ifade ettiğini ancak bu konuları 
	ele aldıktan sonra anlayabileceksiniz. 

	Aşağıdaki örneği inceleyiniz. Programı çalıştırdıktan sonra aşağıdaki gibi bir çıktı elde edeceksiniz:

	default constructor: 0
	int constructor: 10
	default constructor: 0
	int constructor: 20
	default constructor: 0
	default constructor: 0
	default constructor: 0
	default constructor: 0
	default constructor: 0
	default constructor: 0
	destructor: 0
	destructor: 0
	destructor: 0
	destructor: 0
	destructor: 0
	destructor: 0
	destructor: 20
	destructor: 0
	destructor: 10
	destructor: 0

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	Sample(int a);
	~Sample();
	
	void disp();

	int m_a;
};

Sample::Sample()
{
	m_a = 0;

	cout << "default constructor: " << m_a << endl;
}

Sample::Sample(int a)
{
	m_a = a;

	cout << "int constructor: " << m_a << endl;

}

Sample::~Sample()
{
	cout << "destructor: " << m_a << endl;
}

int main()
{
	Sample s[10] = {Sample(), Sample(10), Sample(), Sample(20)};
	//...
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new operatörüyle birden fazla sınıf nesnesi için dinamik tahsisat yapabiliriz. Örneğin:

	Sample *ps;

	ps = new Sample[10];

	Burada heap'te 10 tane Sample türünden ardışıl nesne tahsis edilmiştir. Bu dinamik dizinin başlangıç adresi ps göstericisine atanmıştır. new operatörü 
	dinamik dizinin elemanları için tek tek sırasıyla default yapıcı fonksiyonu çağırmaktadır. Bu biçimde tahsis edilmiş olan sınıf dizileri delete operatörü 
	ile serbest bırakılabilir:
	
	delete[] ps;

	C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonların ters sırada çağrıldığını anımsayınız. Burada dizi elemanları için yıkıcı fonksiyonlar sondan başa 
	doğru çağrılacaktır. 

	new operatörü ile bir sınıf dizisi dinamik olarak tahsis edilirken yine ancak dizi elemanlaır için sınıfın default yapıcı fonksiyonları çağrılabilmektedir. 
	Aşağıdaki gibi bir sentaks geçerli değildir:

	Smaple *ps;

	ps = new Sample[10](10);		// böyle bir sentaks yok

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	Sample(int a);
	~Sample();
	
	void disp();

	int m_a;
};

int g_a;

Sample::Sample()
{
	m_a = g_a++;

	cout << "default constructor: " << m_a << endl;
}

Sample::Sample(int a)
{
	m_a = a;

	cout << "int constructor: " << m_a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << m_a << endl;
}

int main()
{
	Sample *ps;

	ps = new Sample[10];
	//...

	delete[] ps;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yine dinamik olarak tahsis edilen sınıf dizilerine C++11 ile birlikte geçici nesne yoluyla farkı yapıcı fonksiyonlarla ilkdeğer verilebilmektedir. Örneğin:

	Sample *ps;

	ps = new Sample[10]{Sample(), Sample(10), Sample(20)};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz daha önce sınıfların public, protected ve private olmak üzere üç bölümden oluştuğunu belirtmiştik. Örneklerimizde sınıf elemanlarını hep public bölüme
	yerleştirdik.Yine anımsanacağı gibi C++'ta class ile struct arasındaki tek fark default bölüm ile ilgiliydi. class tanımlamalarında default bölüm private,
	struct tanımlamalarında default bölüm public biçimindeydi. Şimdi de bu bölümlerin anlamları üzerinde duracağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıf bildirimi içerisinde bildirilen varlıklara sınıfın elemanları diyebiliriz. Sınıfın elemanları denildiğinde tipik olarak sınıfın veri elemanları ve 
	üye fonksiyonları anlaşılmaktadır. Ancak sınıfın başka elemanları da söz konusu olabilir. 

	Sınıfların public, protected ve private bölümleri sınıf elemanlarına nereden erişilebileceği üzerinde etkili olmaktadır. Sınıflardaki erişim kuralları şöyledir:

	1) Sınıfın elemanlarına o elemanlar hangi bölümde olursa olsun sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde doğrudan erişilebilir. 
	Yani sınıfın kendisi için bir erişim kısıtı yoktur. Örneğin biz sınıfımızın public bölümündeki bir fonksiyonu içerisinde sınıfımızın private bölümündeki 
	bir elemana erişebiliriz. Başka bir deyişle sınıfın üye fonksiyonları sınıfın tüm bölümlerine doğrudan erişebilmektedir. 

    2) Sınıfın dışından yani sınıfın üye fonksiyonu olmayan bir fonksiyondan (örneğin global bir fonksiyondan ya da sınıfın başka bir üye fonksiyonundan) sınıfın
	yalnızca public bölümüne erişilebilir. Yani biz sınıfın dışındaki bir fonksiyondan o sınıf türünden bir nense ya da referans yoluyla nokta operatörünü kullanarak
	ya da o sınıf türünden bir gösterici yoluyla ok operatörünü kullanarak sınıfın yalnızca public bölümündeki elemanlara erişebiliriz. private ve protected bölümdeki elemanlara 
	erişemeyiz. 

	3) Sınıfın private bölümündeki elemanlara sınıfın üye fonksiyonu olmayan bir fonksiyon içerisinde o sınıf türünden bir nesne, referans ya da gösterici yoluyla "." ya da 
	"->" operatörünü kullanarak erişemeyiz. Yani private bölümdeki elemanlar sınıfın dışından erişime kapalıdır. Bu elemanlara yalnızca sınıf bildiriminden ya da üye 
	fonksiyonlar içerisinden erişilebilir. 

	4) Sınıfın protected bölümü dışarıdan (yani sınıfın üye fonksiyonu olmayan fonksiyonlardan) erişime kapalı ancak türemiş sınıf erişimine açık bölümüdür. 
	Sınıfın protected bölümündeki elemanlara türemiş sınıfın üye fonksiyonları doğrudan erişebilmektedir. Ancak private bölümdeki elemanlara türemiş sınıfın 
	üye fonksiyonları tarafından da erişilememektedir. Sınıfın protected ve private bölümündeki elemanlara sınıf içerisinden doğrudan erişilebilir. Ancak dışarıdan
	erişilemez. Bu iki bölüm arasındaki fark türetme söz konusu olduğunda ortaya çıkmaktadır. protected bölüm türemiş sınıf tarafından erişilebilen bir bölümken
	privtae bölüm yalnızca sınıfın kendisi tarafından erişilebilen bir bölümdür. Türetme işlemlerinin anlatıldığı bölümde protected bölümün anlamı ayrıntılı olarak 
	ele alınacaktır. Biz de türetme konusunu işleyene kadar protected bölümü hiç kullanmayacağız. 

	Sınıfın en korunaklı bölümü private bölümdür. Bu bölümdeki elemanlara yalnızca sınıfın üye fonksiyonları tarafından yani sınıfın kendisi tarafından 
	erişilebilmektedir. Sınıfın herkese açık bölümü public bölümdür. public bölümdeki elemanlara sınıfın dışından (yani sınıfın üye fonksiyonu olmayan 
	fonksiyonlardan) o sınıf türünden nesne, referans ya da gösterici yoluyla erişilebilmektedir. Sınıfın protected bölümü dışarıdan erişilemeyen ancak türemiş 
	sınıflar tarafından erişilebilen bölümüdür. Sınıfın bölümleri korunaklılık durumuna göre yüksekten alçağa doğru public, protected, private biçimindedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int m_a;
	void foo();
protected:
	void bar();
private:
	int m_b;
	void tar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample:bar" << endl;
}

void Sample::tar()
{
	cout << "Sample::tar" << endl;
}

int main()
{
	Sample s;

	s.foo();		// geçerli, foo public bölümde
	s.tar();		// geçersiz! tar private bölümde

	s.m_a = 10;		// geçerli, m_a public bölümde
	s.m_b = 20;		// geçersiz! m_b private bölümde

	s.bar();		// geçersiz! bar protected bölümde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi sınıfın elemanlarını hangi bölüme yerleştirmeliyiz?

	1) Eğer ilgili elemana herkesin erişmesini istiyorsak onu public bölüme yerleştirmeliyiz.
	2) Eğer ilgili elemana sınıfın içerisinden erişilmesini istiyorsak ancak sınıfın dışından erişmesini istemiyorsak onu private bölüme yerleştirmeliyiz. 
	3) Eğer iligili elemana sınıf içerisinden ve o sınıftan türetilen sınıfların erişmesini istiyorsak onu protected bölüme yerleştirmeliyiz. 

	Sınıfın bölümlerine erişimi şuna benzetebiliriz.

	1) Ancak kendimizin bildiğimiz bilgiler söz konusu olabilir. Bu bizim private bölümümüzdür.
	2) Bizim hakkımızda herkesin bildiği bilgiler söz konusu olabilir. Bu bilgiler bizim public bölümümüzdür.
	3) Bizim bazı bilgilerimizi çocuklarımız biliyor olabilir ancak başkaları bilmiyor olabilir. Bunlar da protected bölümümüzü oluşturmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne yaratırken o sınıfın yapıcı ve yıkıcı fonksiyonlarının o anda erişilebilir olması gerekmektedir. Örneğin sınıfın yapıcı ve/veya yıkıcı 
	fonksiyonu private bölümdeyse biz sınıfın dışından o sınıf türündne nesneyi yaratamayız. Örneğin:

	class Sample {
		Sample();		// yapıcı fonksiyon private bölümde
		//...
	};

	void test()
	{
		Sample s;			// geçersiz! yapıcı fonksiyona erişilemiyor!
		//...
	}

	O halde genel olarak yapıcı ve yıkıcı fonksiyonların sınıfın public bölümünde olması gerekir. Bu fonksiyonların seyrek de olsa private ve protected bölümlere 
	yerleştirilmeleri için gerekçeler de vardır. Bu gerekçelere ileride başka konularda değinilecektir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	Sample();
	//...
};

Sample::Sample()
{
	//...
}

int main()
{
	Sample s;		// error! yapıcı fonksiyon private bölümde, erişilebilir değil!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT (Nesne Yönelimli Programlama Tekniği) birtakım anahtar kavramların birleşimi olarak düşünülebilir. Bu anahtar kavramlar birbirleriyle iç içe geçmiş 
	durumdadır. NYPT'nin anahtar kavramlarından biri "kapsülleme (encapsulation)" denilen kavramdır. Kapsülleme bir olguyu bir sınıfla temsil edip, sınıfın dış 
	dünyayı ilgilendirmeyen, iç işleyişe ilişkin kısımlarının private bölüme yerleştirilerek dış dünyadan gizlenmesi anlamına gelmektedir. Kapsülleme aslında 
	gerçek dünyada da karşılaştığımız bir olgudur. Örneğin arabanın önemli fakat kullanıcıyı ilgilendirmeyen öğeleri kaput içerisine gizlenmiştir. Biz televizyonu
	yalnızca public bölümü temsil eden kumandayla kullanırız. Televizyonun iç devreleri çerçeve içerisinde gizlenmiştir. Bir bankaya gittiğimizde biz yalnızca
	public bölümdeki memurlarla işlerimizi yürütürüz. Bankanın temizliği ile, yönetmi ile, oradaki kişilerin birbirleriyle ilişkileri ile kafamızı yormayız. 
	Bunlar o olgunun private bölümündeki öğelerdir. 

	Bir sınıf için iki bakış açısı önemlidir: Sınıfı kullananların bakış açısı ve sınıfı yazanların bakış açısı. Sınıfı kullananlar yalnızca public bölüm ile 
	ilgilenirler. Sınıfı yazanlar ise sınıfın her bölümünü bilmek durumundadırlar. Sınıfın kullanıcı için dokümantasyonu yapılırken private bölüm açıklanmaz. 
	Yalnızca public ve protected bölümlerin dokümantasyonu yapılır. 

	Örneğin Sample isimli bir sınıf yazacak olalım. Bu sınıfın do_something_important isimli bir üye fonksiyonu olsun. Bu fonksiyon da işin bazı kısımlarını yapan 
	foo, bar, tar üye fonksiyonlarını çağırıyor olsun. Birisinin bu foo, bar, tar fonksiyonlarını çağırmasının bir anlamı olmadığı gibi bunları çağırması da 
	sorunlara yol açabilir. Bu durumda bizim foo, bar, tar fonksiyonlarını sınıfın private bölümünde gizlememiz uygun olur. Örneğin:

	class Sample {
	public:
		void do_something_important();
	private:
		void foo();
		void bar();
		void tar();
	};

	Birisi bu sınıfın bildirimini gördüğünde artık foo, bar ve tar fonksiyonlarıyla ilgilenmez. Çünkü zaten o kişinin bu fonksiyonları çağırm aimkanı da yoktur. 
	O kişi çağırabileceği public bölümdeki do_something_important fonksiyonuyla ilgilenecektir. Bu durum tıpkı bizim bir buzdolabını kullanırken onun üretim
	detayları ile ilgilenmediğimiz yalnızca bizim kullanımımız için bize verilen kısımla ilgilendiğimiz duruma benzemektedir. Örneğin biz bir fareyi kullanırken 
	o farenin içindeki devreleri genellikle merak etmeyiz. Bizim için fare üç tuşu olan, tekerleği olan, sürüklenen, tıklanan bir nesnedir. Bu fonksiyonlar farenin 
	public bölümünü oluşturmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void do_something_important();
private:
	void foo();
	void bar();
	void tar();
};

void Sample::do_something_important()
{
	//...
	foo();
	//..
	bar();
	//...
	tar();
	//...
}

int main()
{
	Sample s;

	s.do_something_important();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'nin diğer önemli bir prensibi de (anahtar kavramı da) "veri elemanlarının gizlenmesi (data hiding)" denilen prensiptir. Bu prensibe göre sınııfn veri 
	elemanları genellikle iç işleyişe ilişkindir ve private bölüme yerleştirilerek dışarıdan gizlenmelidir. Örneğin:

	class Date {
	public:
		Date(int day, int month int year);
		void disp();
	private:
		int m_day;
		int m_month;
		int m_year;
	};

	Sınıfın veri elemanları private bölüme yerleştirildiğinde bu elemanlar sınıfın üye fonksiyonları tarafından kullanılabilirler. Ancak artık dışarıdan bu elemanlara 
	erişilemez. Böylece veri elemanları dış dünyaya kapatılmış olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main()
{
	Date d;

	d.disp();

	Date k{10, 12, 2005};

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														32. Ders 11/12/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarını private bölüme yerleştirince artık bunlara dışarıdan erişemeyiz. Pekiyi bunlara erişmemiz gerekiyorsa ne yapaliriz? İşte private 
	veri elemanlarına dışarıdan erişebilmek için sınıfın public bölümüne o elemanların içerisindeki değerleri alan "getter" üye fonksiyonlara, o elemanların 
	içerisine değer yerleştiren "setter" üye fonksiyonlara gereksinim duyulmaktadır. Bu tür fonksiyonlara "erişimci fonksiyonlar (accessors)" de denilmektedir. 
	Erişimci fonksiyonlar genellikle (ama her zaman değil) küçük fonksiyonlar olma eğilimindedir. Bu nedenle bu fonksiyonlar genellikle sınıf içeisinde inline 
	olarak yazılırlar.

	Sınıfın her private veri elemanı için bir getter ve setter fonksiyonların yazılması gerekmemektedir. Ancak dışarıdan erişilmesi istenen veri elemanları için
	bu fonksiyonlar yazılmalıdır. Bazı elemanların dışarıdan yalızca değerleri elde edilmek istenir. Bu tür veri elemanları için yalnızca getter üye fonksiyonu 
	yazılabilir. Benzer biçimde seyrek de olsa bazı veri elemanlarına yalnızca dışarıdan değer atanması istenebilir. Bu tür veri elemanları için yalnızca setter
	fonksiyonların yazılması uygun olur. Nihayet bir veri elemanına hem dışarıdan değer atanması hem de onun değerinin elde edilmesi isteniyorsa onun için hem 
	getter hem de setter fonksiyon bulundurulur. 

	Aşağıdaki örnekte Date sınıfının m_day, m_month ve m_year elemanlarını get ve set eden üye fonksiyonlar oluşturulmuştur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	Date(int day, int month, int year);
	void disp();

	// accessors
	int get_day() { return m_day; }
	void set_day(int day) { m_day = day; }

	int get_month() { return m_month; }
	void set_month(int month) { m_month = month; }

	int get_year() { return m_year; }
	void set_year(int year) { m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main()
{
	Date date(10, 12, 2005);

	auto result = date.get_day();
	cout << result << endl;
	
	date.set_day(11);

	date.disp();
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın private veri elemanlarına erişmek için kullanılan getter ve setter üye fonksiyonlar genellikle birkaç biçimde isimlendirilmektedir. Sınıfın private
	veri elemanı m_xxx olmak üzere (örneklerde Date sınıfının m_day veri elemanını kullanacağız):

	1) get_xxx ve set_xxx biçiminde. Örneğin:

	int get_day()
	{
		return m_day;
	}

	void set_day(int day)
	{
		m_day = day;
	}

	2) xxx ve set_xxx biçiminde. Örneğin:

	int day()
	{
		return m_day;
	}

	void set_day(int day)
	{
		m_day = day;
	}

	3) getXxx ve setXxx biçiminde. Deve notasyonunun kullanıldığı sistemlerde bu isimlendirme biçimine rastlanmaktadır. Örneğin:

	int getDay()
	{
		return m_day;
	}

	void setDay(int day)
	{
		m_day = day;
	}

	4) GetXxx ve SetXxxx. Pascal notasyonunu kullanan programcılar de genellikle bu isimlendirmeyi tercih etmektedir. Örneğin Microsoft Windows ortamında
	C++'ta Pascal tarzı fonksiyon isimlendirmelerini kullanmaktadır. Örneğin:

	int DetDay()
	{
		return m_day;
	}

	void SetDay(int day)
	{
		m_day = day;
	}

	5) xxx ve xxx biçiminde. Getter ve setter fonksiyonların parametreleri farklı olduğu için onlara aynı isimler de verilebilmektedir. Örneğin C++'ın standart
	kütüphanesinde bu isimlendirme biçimi kullanılmaktadır:

	int day()
	{
		return m_day;
	}

	void day(int day)
	{
		m_day = day;
	}

	Örneğin yukarıda yazdığımız Date sınıfını C++ standart kütüphanesindeki gette/setter isimlendirmesine göre aşağıdaki gibi yazabiliriz:

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	Date(int day, int month, int year);
	void disp();

	// accessors
	int day() { return m_day; }
	void day(int day) { m_day = day; }

	int month() { return m_month; }
	void month(int month) { m_month = month; }

	int year() { return m_year; }
	void year(int year) { m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main()
{
	Date date(10, 12, 2005);

	auto result = date.day();
	cout << result << endl;
	
	date.day(11);

	cout << date.day() << endl;

	date.disp();
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi veri elemanlarının private bölümde gizlenmesinin gerekçesi nedir? İşte temelde bunun için 4 gerekte gösterilebilir. Ancak programcı için burada 
	açıklayacağımız 4 gerekçenin hiçbiri geçerli değilse bu durumda veri elemanlarının privet bölüme yerleştirilmesine de gerek yoktur. Doğrudan veri elemanları 
	dışarıdan erişilecek biçimde public bölüme de yerleştirilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Gerekçe 1: Deneyimler sınıfın veri elemanlarının tür ve isim bakımından sıkça değiştirildiğini göstermektedir. Eğer veri elemanları sınıfın public bölümüne 
	yerleştirilseler onları programcı doğrudan kullanabileceği için onlarda yapılacak değişiklik onları kullanan kodları geçersiz hale getirecektir. Ancak veri 
	elemanları prvate bölüme yerleştirildiğinde ve onlara public getter/setter üye fonksiyonlarla erişildiğinde onlarda değişikler yapıldığında bu getter/setter 
	fonksiyonların içi yeniden düzenlenerek onları kullanmış olan kodların bu değişiklikten etkilenmemesi sağlanabilmektedir. 

	Normal olarak sınıfı kullanan kodlar sınıfın kendi kodlarından çok daha fazla olma eğilimindedir. Üsteli sınıfı kullanan kodlar başka programcılar tarafından 
	yazılmış olabilir. Sınıfın private veri elemanları değiştirildiğinde bu değişikliği yapan programcı sınıfın üye fonksiyolarının içini yeniden yazmak zorunda 
	kalabilir. Ancak toplamda onları kullanan kodlar çok daha fazla olduğu için onları kullanan kodlarda bir değişikliğin yapılmaması önemli bir kazanç olacaktır.

	Tabii programcı sınıfın veri elemanları üzerinde bir değişiklik yapmayacağını öngörebilir. Bu durumda bu gerekçe o sınıf için geçerli olmayabilir.

	Aşağıdaki örnekte bu durum tesmsil edilmiştir. "date1.cpp" kodunda Date sınıfının tarih bilgisi private bölümde olan üç int türden üç veri elemanında tutulmuştur. 
	"datec.pp" kodunda ise Date sınıfının tarih bilgisini tutan veri elemanı char türden bir dizi biçiminde değiştirilmiştir. Yani sınıfı tasarlayan kişi 
	tarih bilgisini artık "dd/mm/yyyy" biçiminde char türden bir dizide yazı olarak saklamak istemiştir. Bu durumda sınıfın kendi kodları yeni duruma göre değiştirilmiş
	ancak onları kullanan kodlarda bir değişiklik gerekmemiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date1.cpp 

#include <iostream>

using namespace std;

class Date {
public:
	Date(int day, int month, int year);
	void disp();

	// accessors
	int day() { return m_day; }
	void day(int day) { m_day = day; }

	int month() { return m_month; }
	void month(int month) { m_month = month; }

	int year() { return m_year; }
	void year(int year) { m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main()
{
	Date date(10, 12, 2005);

	date.disp();

	date.day(12);
	date.month(11);
	date.year(2010);

	cout << date.day() << '/' << date.month() << '/' << date.year() << endl;
	
		
	return 0;
}

// date2.cpp

#include <iostream>
#include <cstdlib>

using namespace std;

class Date {
public:
	Date(int day, int month, int year);
	void disp();

	// accessors
	int day() 
	{ 
		return atoi(m_date);
	}
	void day(int day)
	{
		sprintf(m_date, "%02d", day);
		m_date[2] = '/';
	}

	int month() 
	{ 
		return atoi(m_date + 3);
	}
	
	void month(int month) 
	{ 
		sprintf(m_date + 3, "%02d", month);
		m_date[5] = '/';
	}

	int year() 
	{ 
		return atoi(m_date + 6);
	}

	void year(int year) 
	{ 
		sprintf(m_date + 6, "%04d", year);
	}
private:
	char m_date[11];
};

Date::Date(int day, int month, int year)
{
	sprintf(m_date, "%02d/%02d/%04d", day, month, year);
}

void Date::disp()
{
	cout << m_date << endl;
}

int main()
{
	Date date(10, 12, 2005);

	date.disp();

	date.day(12);
	date.month(11);
	date.year(2010);

	cout << date.day() << '/' << date.month() << '/' << date.year() << endl;
			
	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Gerekçe 2: Eğer biz veri elemanlarını sınıfın private bölümüne yerleştirip onlara değer atamayı setter fonksiyonlarına yaptırırsak bu durumda onlara atanacak 
	değerin	sınamasını bu setter fonksiyonlarının içerisinde yapabiliriz. Sınamanın başarısyz olduğu durumda bir exception fırlatılabiliriz. Eğer sınıfın veri 
	elemanlarını public bölüme yerleştirirsek onlara programcı istediği gibi sınır dışında değerler atayabilir. Bu durum derleme aşamasında denetlenemez. Dolayısıyla
	böceklere zemin hazırlar. 

	Tabii bu gerekçe de ilgili sınıf için söz konusu olmayabilir. Yani sınıfın veri elemanlarına set işlemi yapılırken bir sınama (validation) gerekmeyebilir.

	Aşağıdaki örnekte Date sınıfının setter fonksiyonlarında sınır kontrolü (validation) uygulanmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date(int day, int month, int year);
	void disp();

	// accessors
	int day() { return m_day; }
	void day(int day);
	
	int month() { return m_month; }
	void month(int month) 
	{
		if (month < 0 || month > 12)
			throw invalid_argument("month out of range");

		m_month = month; 
	}

	int year() { return m_year; }
	void year(int year) { m_year = year; }
private:
	bool isleap(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::day(int day)
{
	if (day < 0)
		throw invalid_argument("day out of range");

	switch (m_month) {
	case 1:
	case 3:
	case 5:
	case 7:
	case 8:
	case 10:
	case 12:
		if (day > 31)
			throw invalid_argument("day out of range");
		break;
	case 2:
		if (isleap(m_year)) {
			if (day > 29)
				throw invalid_argument("day out of range");
		}
		else
			if (day > 28)
				throw invalid_argument("day out of range");
		break;
	case 4:
	case 6:
	case 9:
	case 11:
		if (day > 30)
			throw invalid_argument("day out of range");
		break;
	}

	m_day = day;
}


void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main()
{
	Date date(10, 2, 2000);

	date.disp();

	date.day(29);			// bu noktada exception oluşacak!

	date.disp();
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Gerekçe 3: Bazen sınıfın veri elemanları arasında birtakım ilişkiler söz konusu olabilir. Yani bir veri elemanının değerini değiştirdiğimizde başka veri 
	elemanlarının değerlerini ona göre değiştirmek durumunda kalabiliriz. İşte bu tür durumlarda sınıfın veri elemanlarını public bölüme yerleştirirsek bu durumda 
	tüm ilişkiyi programcının bilmesi ve uygulaması gerekir. Halbuki bu veri elemanlarını private bölüme yerleştirirsek bu ilişki setter fonksiyonlarında arka 
	planda oluşturulabilir. 

	Tabii sınıfın veri elemanları arasında herhangi bir ilişki de olmayabilir. Bu durumda bu sınıf için bu gerekçe geçerli olmayacaktır.

	Aşağıdaki örnekte Circle sınıfının m_radius elemanı m_area elemanı ile ilişkilidir. radius setter fonksiyonunda işleminde m_area elemanı da değiştirilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Circle {
public:
	Circle(double x, double y, double radius)
	{
		m_x = x;
		m_y = y;
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	double x() { return m_x; }
	void x(double x) { m_x = x; }

	double y() { return m_y; }
	void y(double y) { m_y = y; }

	
	double radius() { return m_radius; }
	void radius(double radius)
	{
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	void disp();

	void foo();		// m_area'yı kullandığını varsayalım
	void bar();		// m_area'yı kullandığını varsayalım
	void tar();		// m_area'yı kullandığını varsayalım

private:
	double m_x;
	double m_y;
	double m_radius;
	double m_area;
};

void Circle::disp()
{
	cout << m_x << ", " << m_y << ", " << m_radius << ", " << m_area << endl;
}

int main()
{
	Circle c(1, 2, 3);

	c.disp();

	c.radius(4);

	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Gerekçe 4: Bazen sınıfın bir veri elemanı üzerinde işlem yaparken arka planda başka birtakım işlemlerin de yapılması gerekebilmektedir. Örneğin SerialPort 
	isimli bir sınıfta seri portun hızı sınıfın public m_baudrate elemanında tutuluyor olsun. Baud rate alınmak istendiğinde hemen bu veri elemanından alınabilecektir. 
	Ancak biz şimdi bu elemana değer yerleşirdiğimizde seri portu hızı değişmeyecektir. Çünkü seri portun hıznını değiştirmek için UART işlemcisinin programlanması 
	gerekir. Ancak biz m_baudrate elemanını private bölümde tutup onu setter fonksyonu ile değer atamayı zorlarsak bu setter fonksiyonu bu işlemi kendi içerisinde 
	yapacak ve programcının bu ayrıntırları bilmesine gerek kalmayacaktır.

	Tabii bir veri elemanı set ederken ya da get ederken arka planda birtakım işlemlerin yapılmasına gereksinim olmayabilir. Bu durumda bu gerekçe bu sınıf için 
	geçerli olmayacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıda açıkladığımız dört gerekçenin hiçbiri bizim geçerli olmayabilir. Yani biz sınıfın veri elemanlarını değiştirmeyeceğmizden eminsek, o veri elemanları 
	üzerinde sınır kontrolü gerekmiyorsa, o veri elemanı başka bir veri elemanı ile ilişkili değilse, o veri elemanını kullanırken başka işlemler yapmamız gerekmiyorsa 
	o zaman pekala biz veri de elemanlarımızı public bölüme yerleştirebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														33. Ders 13/12/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Projelerin tek bir kaynak dosya biçimind oluşturulması kötü bir tekniktir. Çünkü bu durumda en küçük bir değişiklikte tüm kaynak dosyanın yenidne derlenmesi 
	gerekir. Bunun için küçük olmayan projelerin kaynak dosyalara bölünmesi hem bu sorunu kısmen ortadan kaldırmakta hem de projenin daha iyi ele alınmasını 
	sağlamaktadır. Farklı kaynak dosyaların derlenip elde edilen amaç dosyaların (object files) link edilip hedef dosyanın (çalıştırılabilir dosya ya da kütüphane 
	dosyası) elde edilmesi sürecine "build işlemi" ya da "make" işlemi denilmektedir. Projeyi oluşturan hangi kaynak dosyada değişilik yapıldığının belirlenerek
	ve bu sürecin etkin bir biçimde yürütülmesi için "build otomasyon araçları (build automation tools)" denilen araçlar kullanılmaktadır. Bunların en ünlüsü 
	"GNU'nun make" isimli aracıdır. Microfost'un GNU make aracınaq benzer "nmake" isimli bir aracı da vardır. Yine Microsoft'un Visual IDE'sine entegre ettiği
	"msbuild" denilen bir nuild otomasyon aracı da bulunmaktadır. Qt dünyasında "qmake" isimli araç çokça tercih edilmektedir. Tipik bir build otomasyon aracında
	önce ne yapılmak istendiği özel bir script dosyasında özel bir dille yazılır. Sonra bu script dosyası build otomasyon aracına verilir. Bu araç da o dosyadaki 
	yönergeleri izler. Örneğin GBU make aracında programcı ismine "make dosyası (make file)" denilen bir dosya oluşturur. Bu dosyanın içerisine yönergeleri yazar.
	Sonra "make" isimli programı çalıştırarak build işlemini gerçekleştirir.

	GNU make aracını öğrenmek biraz zaman alıcı bir işlemdir. Ancak en basit haliyle bir make dosyası "kurallardan (rules)" oluşmaktadır. Kurallar bir hedef (target), 
	bir koşul (prerequiste) ve bu koşul sağlandığında yapılacak işlemlerdne oluşturulur. Örneğin:

	sample.o: sample.cpp
		gcc -c sample.cpp

	Burada "sample.o" ve "sample.cpp" iki dosyadır. Eğer "sample.cpp" dosyasının tarih ve zamanı "sample.o" dosyasının tarih ve zamanından daha ileride ise 
	aşağıdaki satırdaki işlemler yapılacaktır. Tabii kurallar biribirine bağlı olabilir. Bu kurallardan bir graf üretip işlemleri sıraya koymak make programının 
	görevidir. Örneğin:

	sample: sample.o mample.o
		g++ -o sample sample.o mample.o

	sample.o: sample.cpp
		g++ -c sample.cpp

	mample.o: mample.cpp
		g++ -c mample.cpp

	make programı dosya ismi belirtilmeden çalıştırılırsa ilgili dizindeki bazı isimli dosyalara bakmaktadır. Bunlardna biri Makefile isimli dosyadır. Örneğin:

	make -f mymake.mak

	Burada make programı "mymake.mak" dosyasını işletecektir. Fakat örneğin:

	make

	Burada make programı "Makefile" dosyasını işletecektir. 

	Build otomasyon araçları genel olarak IDE'lere entegre edilmiş durumdadır. Böylece bir IDE'de bir kaynak dosya projeye eklendiğinde zaten bu mekanizma 
	görsel biçimde oluşturulur. IDE'lerin çoğu görsel olarak yapılan işlemlerden otomasyon aracının kullandığı script dosyasını oluşturur. Build işlemi yine
	ilgili otomasyon aracı tarafından yapılır. 

	make aracı çok klasik bir araçtır. Ancak karmalıktır. Karmaşık işlemlerde make dosyası oluşturmak için aracın iyi kullanılması gerekmektedir. make aracı karmaşık 
	olduğu için işlemleri basitleştirmek amacıyla üst düzey build otomasyon araçları da oluşturulmuştur. Örneğin "cmake" isimli üst düzey aracın daha basit bir 
	dili vardır. cmake aslında ürün olarak make dosyası oluşturmaktadır. Yani cmake aracının ürettiği make dosyasının ayrıca make edilmesi gerekir. Aynı durum 
	qmake aracında da söz konusudur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta proje geliştirirken tipik olarak her sınıf iki kaynak dosya biçiminde yazılmaktadır. Sınıfın ismi X olmak üzere bu dosyalar "x.hpp" (ya da "x.h") ve 
	"x.cpp" dosyalarıdır. Sınıfın bildirimleri, sınıfla ilgili sembolik sabitler ve inline fonksiyon tanımlamaları "x.hpp" dosyası içerisine yerleştirilir. 
	Sınıfın üye fonksiyon tanımlamaları, global nesne tanımlamaları ise "x.cpp" dosyasına yerleştirilir. Böylece sınıfın kullanılacağı her yerde "x.hpp" dosyası 
	include edilir. "x.cpp" dosyası derlenerek link aşamasında kullanılır ya da derlenerek kütüphane yerleştirilir. Tabii "x.hpp" dosyası aynı zamanda "x.cpp"
	dosyasından de include edilmelidir. 

	Projede çok fazla sınıf varsa ve bu sınıfların bazıları küçükse onların birkaçı gruplanarak tek bir ".hpp" ve ".cpp" dosyalarına yerleştirilebilir. using 
	namespace direktifleri başlık dosyalarında bulunmamlıdır. Çünkü o başlık dosyası include edildiğinde isim aramsı include eden programcının isteğinin dışında 
	using namespace direktifinde belirtilen dizinde de yapılacaktır. 

	Bir sınıfın bir kaynak dosyadan kullanılabilmesi için o sınıfın bildiriminin görülmesi yeterlidir. Sınıfın üye fonksiyonları zaten link aşamasında linker tarafından
	çalıştırılabilir dosyayla ilişkilendirilecektir. Örneğin Date sınıfını biz "date.hpp" ve "date.cpp" biçiminde iki dosyada oluşturmuş olalım. Biz "date.hpp"
	dosyasını include ederek o sınıfı herhangi bir ".cpp" dosyasında kullanabiliriz. 

	Örneğin Date sınıfını aşağıdaki gibi iki dosya olarak organize edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() { return m_day; }
	void day(int day) { m_day = day; }

	int month() { return m_month; }
	void month(int month) { m_month = month; }

	int year() { return m_year; }
	void year(int year) { m_year = year; }

private:
	int m_day;
	int m_month;
	int m_year;
};

#endif


// date.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

Date::Date()
{
	m_day = 1;
	m_month = 1;
	m_year = 1900;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date date(3, 12, 2004);

	date.disp();

	return 0;
}
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Başkaları tarafından yazılmış bir sınıfı kullanmak istediğimizde hangi dosyalara sahip olmamız gerekir? Sınıfı yazan kişi kaynak kodu gizlemek istediği için 
	bize .cpp dosyasını vermeyebilir. Bu durumda bize derlenmiş amaç dosyayı (yani o.obj ya da .o dosyasını) ya da amaç dosyanın yerleştirildiği kütüphane 
	dosyasını verecektir? Tabii kişinin bize sınf bildiriminin bulunduğu .hpp (ya da .h) dosyasını da vermesi gerekir. Biz de bu dosyayı include ederiz. Link 
	aşamasında ilgili amaç dosyanın ya da kütüphane dosyasının işleme sokulmasını sağlarız. Gerçekten de genel olarak başkaları tarafından yazılmış sınıf kütüphaneleri
	için bize link aşamasına dahil edilecek kütüphane dosyaları ve sınıfların bildirimlerinin bulunduğu başlık dosyaları verilmektedir. Tabii eğer kütüphane 
	açık kaynak kodluysa kütüphanenin tüm kaynak kodları da istenirse kişilere verilebilmektedir. 

	Bir sınıfı kullanmak için sınıfın private bölümündeki bildirimlere gerek var mıdır? Ne de olsa programcı bu bölüme erişememektedir. Sınıf bildiriminde sınıfın
	bütün veri elemanlarının derleyici tarafından görülmesi gerekir. Aksi takdirde derleyici kod üretemektedir. Ancak private üye fonksiyonlar kod derlendikten 
	sonra sınıf bildiriminden silinebilirler. Tabii bunun için sınıf içi inline fonksiyonların bu private üye fonksiyonları kullanmaması gerekir. 

	C'de ve C++'ta bir başlık dosyasının içerisinde başka bir başlık dosyasındaki sembolik sabitler, typedef isimleri gibi bildirimler kullanılacaksa bunların 
	bulunduğu başlık dosyası bunları kullanan başlık dosyasının içerisinde include dilmelidir. Çünkü başlık dosyaları kendi kendine yeter durumda olmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
										34. Ders 18/12/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıf bildirimi içerisinde typedef bildirimi yapılabilir. Bu durumda typedef ismi sınıf faaliyet alanında olur. Yani bu isme üye fonksiyonlar içerisinden 
	doğrudan erişilebilir. Ancak sışarıdan "eğer bildirim public bölümde yapılmışsa" sınıf ismi ve çözünürlük operatörü ile erişilebilir. Örneğin:

	class Sample {
	public:
		void foo();

		typedef int I;
		//...
	};

	void Sample::foo()
	{
		I i;			// geçerli

		//...
	}

	int main()
	{
		Sample::I a;		// geçerli

		//...

		return 0;
	}

	Tabii typedef bildirimini C++11 ile birlikte dile eklenen using bildirimi ile de benzer biçimde sınıf içerisinde yapabiliriz:

	class Sample {
	public:
		void foo();

		using I = int;
		//...
		};

	void Sample::foo()
	{
		I i;			// geçerli

		//...
	}

	int main()
	{
		Sample::I a;		// geçerli

		//...

		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Falliyet alanlı olmayan enum türleri de (unscoped enumeration) sınıf bildirimi içerisinde bildirilebilir. Bu durumda tıpkı typedef isimleri gibi bu enum 
	isimleri ve enum sabitleri sınıf faaliyet alanı içerisinde olur. Yani üye fonksiyonlar içerisinde bunlar doğrudan kullanılabilirler. Ancak dışarıdan "eğer 
	sınıfın public nölümündelerse" sınıf ismi ile niteliklendirilerek kullanılabilirler. Örneğin:
		
	class Sample {
	public:
		void foo();

		enum Color { Red, Green, Blue };
		//...
	};

	void Sample::foo()
	{
		Color c = Green;		// geçerli

		//..
	}

	int main()
	{
		Sample::Color c;

		c = Sample::Green;		// geçerli

		//...

		return 0;
	}

	Tabii sınıf bildirimi içerisinde faaliyet alanlı enum türleri de (scoped enumeration) bildirilebilir. Anımsanacağı gibi bu enum türlerinin enum sabitleri 
	enum ismiyle niteliklendirilerek kullanılmak zorundaydı. Sınıfın kendisi zaten bir faaliyet alanı belirttiği için sınıf içerisinde faaliyet alanlı enum 
	kullanımı çoğu kez programcılar tarafından eğer bir çakışma durumu da yoksa tercih edilmemektedir. Örneğin:

	class Sample {
	public:
		void foo();

		enum class Color { Red, Green, Blue };
		//...
	};

	void Sample::foo()
	{
		Color c = Color::Green;		// geçerli

		//...
	}

	int main()
	{
		Sample::Color c;

		c = Sample::Color::Green;		// geçerli

		//...

		return 0;
	}

	Genellikle sınıf bildirimleri içerisinde faaliyet alanlı olmayan enum bildirimleriyle karşılaşırız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta "isim araması (name lookup)" konusu ileride ayrı bir paragrafta ele alınacaktır. Ancak bu aşamada birkaç nokta üzerinde durmak istiyoruz. 

	Bir üye fonksiyon içerisindeki isimler üye fonksiyonun yerel bloklarında arandıktan sonra sınıf bildiriminin her yerinde aranır. Dolayısıyla örneğin bir
	üye fonksiyonu inline biçimde sınıf bildiriminin içerisinde tanımladığımızda daha sonra tanımlanmış olan sınıf elemanlarını bu üye fonksiyonda kullanabiliriz. 
	Örneğin:

	class Sample {
	public:
		void foo()
		{
			m_a = 10;		// geçerli
			bar();			// geçerli
			//...
		}
		void bar()
		{
			//...
		}
	private:
		int m_a;
	};

	Ancak sınıf bildirimi içerisinde kullanılan isimlerin sınıf içerisinde aranması kullanım yerinden yukarıdaki bölgede yapılmaktadır. Örneğin:

	class Sample {
	public:
		void foo()
		{
			I a;		// geçerli
			//...
		}
	private:
		I m_a;			// geçersiz!
		typedef int I;
	};

	Burada I ismi sınıf bildirimi içerisinde kullanılmıştır.Ancak derleyici bu I ismini sınıf içerisinde kullanım yerinden yukarıdaki alanda aramaktadır. 
	Dolayısıyla bu kullanım geçersizdir. Ancak sınıf bildirimi aşağıdaki gibi olsaydı kullanım geçerli olurdu:

	class Sample {
	public:
		void foo()
		{
			I a;			// geçerli
			//...
		}
	private:
		typedef int I;
		I m_a;				// geçerli
	};

	Bir üye fonksiyonun parametresi ve geri dönüş değeri sınıf içerisindeki bir typedef ismi türünden olabilir. Parametre parantezinin içerisi sanki üye fonksiyonun 
	içiymiş gibi ele alınmaktadır. Ancak geri dönüş değeri böyle değildir. Geri dönüş değerindeki isimler sınıf faaliyet alanında aranmamaktadır. Tanımlama nereye 
	yerleştirilmişse orada aranmaktadır.Örneğin:

	class Sample {
	public:
		using I = int;

		I foo(I a)			// geçerli
		{
			//...
		}

		I bar(I a);		// geçerli
	};

	Buraki bar fonksiyonunun dışarıdaki tanımlamasına dikkat ediniz:

	I Sample::bar(I a)		// geçersiz!
	{
		//...
	}

	Buradaki parametre parantezi içerisinde bulunan I ismi sanki üye fonksiyonun içerisindeymiş gibi sınıf faaliyet alanında aranacak ve bulunacaktır. Ancak 
	geri dönüş değerindeki I ismi sınıf faaliyet alanında aranmamaktadır. Üye fonksiyonun tanımlandığı yerde aranmaktadır. Bu nedenle yukarıdaki tanımlama 
	geçersizdir. Bu tanımlama aşağıdaki gibi yapısaydı geçerli olurdu:

	Sample::I Sample::bar(I a)		// geçerli
	{
		//...
	}

	Özetle parametre parantezinin içi sanki sınıfın üye fonksiyonun içiymiş gibi kabul edilirken geri dönüş değerinin yazıldığı yer üye fonksiyonun içiymiş gibi
	kabul edilmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları içerisinde aynı sınıfın her bölümündeki elemanlara doğrudan erişebildiğimizi belirtmiştik. Bir fonksiyon içerisinde aynı sınıf 
	türünden bir nesne, gösterici ya da referans ile de bunların belirttiği nesnelerin ber bölümüne erişebiliriz. Örneğin:

	class Sample {
	public:
		void foo();
		//...
	private:
		int m_a;
	};

	void Sample::foo(Sample &s)
	{
		Sample k;

		m_a = s.m_a;		// geçerli, sınıfın her bölümündeki elemanlara erişebiliriz
		
		k.m_a = m_a;		// geçerli, sınıfın her bölümündeki elemanlara erişebiliriz
		//...
	}

	Yani bir sınıfın üye fonksiyonunda o sınıf türünden her nesne ile o nesnenin her bölümüne erişebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pek çok nesne yönelimli programlama dilinde onların standart kütüphanelerinde yazısal işlemleri yapmak için bir "string" sınıfı bulunmaktadır. C++'ın standart 
	kütüphanesinde de böyle bir sınıf vardır. Biz önce böyle bir sınıfı basit bir düzeyde yazmaya çalışıp sonra standart kütüphanede olan string sınıfını 
	tanıtacağız. 

	String sınıfları mecburen yazıyı dinamik bir alanda tutarlar. Yazının sonunda özel bir karakter varsa (tipik olarak null karakter) yazının uzunluğunu tutmaya 
	gerek olmayabilir. Ancak yazı uzunluğu değişik işlemlerde gerekebildiği için yazının uzunluğunun da ayrıca bir veri elemanında tutulması uygun olmaktadır. 
	Bu durumda basit string sınıfının veri elemanları aşağıdaki gibi olabilir:

	class String {
	public:
		//...
	private:
		char *m_str;		// yazının başlangıç adresini tutuyor
		size_t m_size;		// yazının uzunluğunu tutuyor	
	};

	Bir string'e yazı eklenmesi ya da insert edilmesi çok karşılaşılan durumdur. Bu işlemlerde dinamik alanın büyütülmesi zaman kaybına yol aöabileceği için 
	pek çok string sınıfı aslında gerekenden daha büyük bir alanı tahsis edip yeniden tahsisat işlemini (reallocation) azaltmaya çalışmaktadır. Bu tür durumlarda 
	asıl tahsis edilen alanın uzunupuna genellikle "kapasitge (capacity)" denilmektedir. Böyle bir tasarım yapılacaksa sınıfın veri elemanları aşağıdaki gibi 
	olacaktır:

	class String {
	public:
		//...
	private:
		char *m_str;			// yazının başlangıç adresini tutuyor
		size_t m_size;			// yazının uzunluğunu tutuyor	
		size_t m_capacity;		// tahsis edilmiş olan alanın uzunluğu
	};

	Biz gerçekleştirimde önce kapasite elemanını kullanmayacağız. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
										35. Ders 20/12/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda yazılar üzerinde işlemler yapan String isimli bir sınıfın yazımı verilmiştir. Buradaki String sınıfı C++'ın standart kütüphanesindeki string 
	sınıfına benzemektedir. Ancak C++'ın standart kütüphanesindeki string sınıfı daha ayrınrılı işlemler yapabilen üye fonksiyonlara sahiptir. İzleyen 
	paragraflarda C++'ın standart string sınıfı ana hatlarıyla ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

namespace CSD
{
	const int DEF_CAPACITY = 8;

	class String {
	public:
		using size_type = std::size_t;
		enum : size_type { npos = static_cast<size_type>(- 1) };

		// constructors
		String();
		String(const char *str);
		String(size_type, char ch);
		String(const char *str, size_type n);
		~String();

		// getters
		size_type size() { return m_size; }
		const char *c_str() { return m_str; }
		size_type capacity() {	return m_capacity; }
		
		// utilities 
		void reserve(size_type capacity);
		void append(char ch);
		void append(const char *str);
		void append(const char *str, size_type n);
		inline void append(String &r);

		bool insert(size_type index, size_type count, char ch);
		bool insert(size_type index, const char *str);
		bool insert(size_type index, const char *str, size_type count);
		inline bool insert(size_type index, String &r);

		bool erase(size_type index = 0, size_type count = npos);
		inline void clear();

		void resize(size_type count);
		void resize(size_type count, char ch);
		void shrink_to_fit();

		bool replace(size_type pos, size_type count, const char *str);
		bool replace(size_type pos, size_type count, String &s);
		
		size_type find(char ch, size_type pos = 0);
		size_type find(const char *str, size_type pos = 0);

		char &at(size_type pos) { return m_str[pos]; }
		char &front() { return m_str[0]; }
		char &back() { return m_str[m_size - 1]; }

		void disp();
				
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	inline void String::append(String &r)
	{
		append(r.m_str);
	}

	inline bool String::insert(size_type index, String &r)
	{
		return insert(index, r.m_str, r.m_size);
	}

	inline void String::clear()
	{
		m_str[0] = '\0';
		m_size = 0;
	}
}

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

namespace CSD
{
	String::String()
	{
		m_str = new char[DEF_CAPACITY];
		m_str[0] = '\0';
		m_size = 0;
		m_capacity = DEF_CAPACITY;
	}

	String::String(const char *str)
	{
		m_size = strlen(str);
		m_str = new char[m_size + DEF_CAPACITY];
		strcpy(m_str, str);
		m_capacity = m_size + DEF_CAPACITY;
	}

	String::String(size_type n, char ch)
	{
		
		m_str = new char[n + DEF_CAPACITY];
		m_str[n] = '\0';
		memset(m_str, ch, n);
		m_size = n;
		m_capacity = n + DEF_CAPACITY;
	}

	String::String(const char *str, size_type n)
	{
		m_str = new char[n + DEF_CAPACITY];
		strncpy(m_str, str, n);
		m_str[n] = '\0';
		m_size = n;
		m_capacity = n + DEF_CAPACITY;
	}

	String::~String()
	{
		delete[] m_str;
	}

	void String::reserve(size_type capacity)
	{
		if (capacity <= m_capacity)
			return;

		char *newstr = new char[capacity];
		strcpy(newstr, m_str);
		delete[] m_str;
		m_str = newstr;
		m_capacity = capacity;
	}

	void String::append(char ch)
	{
		size_type new_size = m_size + 1;

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		m_str[m_size++] = ch;
		m_str[m_size] = '\0';
	}

	void String::append(const char *str)
	{
		size_type new_size = m_size + strlen(str);

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		strcat(m_str, str);
		m_size = new_size;
	}

	void String::append(const char *str, size_type n)
	{
		size_type new_size = m_size + n;

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		strncat(m_str, str, n);
		m_size = new_size;
	}

	bool String::insert(size_type index, size_type count, char ch)
	{
		if (index > m_size)
			return false;

		size_type new_size = m_size + count;

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		memmove(m_str + index + count, m_str + index, m_size - index);
		memset(m_str + index, ch, count);
		m_size = m_size + count;
		m_str[m_size] = '\0';

		return true;
	}

	bool String::insert(size_type index, const char *str)
	{
		if (index > m_size)
			return false;

		size_type len_str = strlen(str);
		size_type new_size = m_size + len_str;

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		memmove(m_str + index + len_str, m_str + index, m_size - index);
		memcpy(m_str + index, str, len_str);

		m_size = m_size + len_str;
		m_str[m_size] = '\0';

		return true;
	}
	
	bool String::insert(size_type index, const char *str, size_type count)
	{
		if (index > m_size)
			return false;

		size_type new_size = m_size + count;

		if (new_size + 1 > m_capacity)
			reserve(new_size * 2);

		memmove(m_str + index + count, m_str + index, m_size - index);
		memcpy(m_str + index, str, count);

		m_size = m_size + count;
		m_str[m_size] = '\0';

		return true;
	}

	bool String::erase(size_type index, size_type count)
	{
		if (index > m_size)
			return false;

		if (count == npos)
			count = m_size - index;

		memmove(m_str + index, m_str + index + count, count);
		m_size = m_size - count;
		m_str[m_size] = '\0';

		return true;
	}

	void String::resize(size_type count)
	{
		if (count > m_capacity) 
			reserve(count + DEF_CAPACITY);

		if (count > m_size)
			memset(m_str + m_size, 0, count - m_size);
		m_size = count;
		m_str[m_size] = '\0';
	}

	void String::resize(size_type count, char ch)
	{
		if (count > m_capacity)
			reserve(count + DEF_CAPACITY);

		if (count > m_size)
			memset(m_str + m_size, ch, count - m_size);
		m_size = count;
		m_str[m_size] = '\0';
	}

	void String::shrink_to_fit()
	{
		char *newstr = new char[m_size + 1];
		strcpy(newstr, m_str);
		delete[] m_str;
		m_str = newstr;
		m_capacity = m_size + 1;
	}

	bool String::replace(size_type pos, size_type count, const char *str)
	{
		if (!erase(pos, count))
			return false;

		return insert(pos, str);
	}

	bool String::replace(size_type pos, size_type count, String &s)
	{
		if (!erase(pos, count))
			return false;

		return insert(pos, s);
	}

	String::size_type String::find(char ch, size_type pos)
	{
		for (size_type i = pos; i < m_size; ++i)
			if (m_str[i] == ch)
				return i;

		return npos;
	}

	String::size_type String::find(const char *str, size_type pos)
	{
		char *result;

		if ((result = strstr(m_str + pos, str)) == nullptr)
			return npos;

		return static_cast<size_type>(result - m_str);
	}

	void String::disp()
	{
		cout << m_str << ", size = " << m_size << ", capacity = " << m_capacity << endl;
	}
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;
using namespace CSD;

int main()
{
	String s{"ankara"};
	s.disp();
	String::size_type result;

	result = s.find("kar");
	if (result == String::npos)
		cout << "cannot find!.." << endl;
	else
		cout << "found at index: " << result << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
										36. Ders 25/12/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında yukarıda da belirttiğimiz gibi C++'ın standart kütüphanesinde zaten yazsısal işlemlerin yapılabilmesi için tasarlanmış string isimli bir sınıf 
	bulunmaktadır. string sınıfının bildirimi <string> başlık dosyası içerisindedir. C++'ın standart kütüphanesindeki öğelerin std isim alanı içerisinde bulunduğunu 
	anımsayınız. Aslında yazısal işlem yapan sınıfın asıl ismi basic_string biçimindedir. basic_string sınıfı "sınıf şablonu olarak" oluşturulmuştur. Aslında bu 
	sınıfın char açılımı string sınıfını belirtmektedir:

	typedef basic_string<char> string;

	sınıf şablonları kursumuzda iler bölümlerde ele alınmaktadır. 

	C++11 ile birlikte ve C++11'den sonra string sınıfı üzerinde bazı değişiklikler ve eklemeler de yapılmıştır.

	Orijinal string sınıfı da yeniden tahsisat miktarını azaltmak için bir kapasite ile çalışmaktadır. Yani sınıf aslında tutacağı yazıdan daha büyük bir alanı 
	tahsis etmekte ve böylece ekleme ve insert gibi işlemlerde yeniden tahsisat yapılma olasılığını azaltmaktadır. Tasarım büyük ölçüde yukarıda yazmış olduğumuz
	String sınıfına benzemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının const char * parametreli yapıcı fonksiyonu bizden bir yazı alıp onu dinamik bir biçimde tahsis etmiş olduğu char türden dizi içerisinde tutar. 
	cout nesnesi zaten standart string nesnelerini de yazdırabilmektedir. Örneği:

	string s{"ankara"};

	cout << s << endl;			// ankara
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{ "ankara"};

	cout << s << endl;			// ankara
	
	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının diğer çok kullanılan bir yapıcı fonksiyonu bizden bir sayı ve bir karakter alır. Nesneyi o karakterden o sayıda olacak biçimde oluşturur. 
	Örneğin:

	string s(10, 'a');

	cout << s << endl;		// aaaaaaaaaa
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s(10, 'a');

	cout << s << endl;		// aaaaaaaaaa
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Belli bir string nesnesinin belli bir index'inden başlanarak onun belli sayıda karakterlerinden string nesnesi yapan bir yapıcı fonksiyon da vardır. Örneğin:

	string s("ankara");
	string k(s, 2, 3);

	cout << k << endl;		// kar
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string k(s, 2, 3);

	cout << s << endl;		// ankara
	cout << k << endl;		// kar
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tıpkı bizim yazdığımız string sınıfında olduğu gibi standart string sınıfında da sınıfın public bölümünde bildirilmiş olan size_type isimli bir tür ve bu 
	türden npos isimli bir sembolik sabit de (aslında sınıfın const static bir veri elemanı) bulunmaktadır. size_type türü kullanlan "allocator" nesnesine 
	bağlı olarak değişebilmekle birlikte default durumda size_t türündendir. Kursumuzun son bölümlerinde allocator kavramı üzerinde duracağız. npos değeri bazı
	fonksiyonlarda default argüman geçildiğini belirlemek için ya da başarısızlığı belirlemek için kullanılmaktadır. Bu size_typeve npos isimleri sınıf içerisinde 
	bildirildiği dışarıdan string::size_type ve string::npos biçiminde kullanılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir string nesnesinin tuttuğu yazının uzunluğu size ya da length üye fonksiyonlarıyla elde edilebilmektedir. Bu üye fonksiyonlar string::size_type türünden 
	değer vermektedir. size üye fonksiyonu ile length üye fonksiyonu arasında da hiçbir farklılık yoktur.

	string sınıfı yendien tahsisat işlemini azaltmak için kapasite kullanılarak gerçekleştirilmektedir. Nesnenin kapasite değeri (yani yazı için gerçekten 
	tahsis edilen alanın uzunluğu) capacity üye fonksiyonuyla elde edilebilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	string::size_type len;

	len = s.size();

	cout << len << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İki string nesnesi '+' operatörü ile toplama işlemine sokulabilir. Bu durumda soldaki string'in cuna sağdaki string eklenmekte ve bu içerikte yeni bir string 
	nesnesi oluşturulmaktadır. Yani biz iki string nesnesini '+' operatörü ile topladığımızda aslında onların uçuca eklenmesindne oluşan yeni bir string nesnesi 
	elde etmiş oluruz. Örneğin:

	string s{"ankara"}, k{"izmir"}, result;

	result = s + k;

	cout << result << endl;		// ankaraizmir

	İki sınıf nesnesinin ya da bir sınıf nesnesi ile temel türlere ilişkin bir değerin işlemlere sokulabilmesi için söz konusu sınıfta ismine "operatör fonksiyonları"
	denilen fonksiyonların bulunuyor olması gerekmektedir. Standart string sınıfında bu işlemi yapabilecek bir '+' operatör fonksiyonu vardır. Operatör fonksiyonlarına
	"operator overloading" de denilmektedir. C++'ın dışında diğer bazı nesne yönelimli dillerde de operatör fonksiyonu oluşturabilme özelliği vardır. Ancak bazı 
	nesne yönelimli dillerde bu özellik bulunmamaktadır. 
	
	Yukarıdaki örnekte bir toplama sonucunda elde edilen yeni string nesnesi başka bir string nesnesine atanmıştır. Anımsanacağı gibi C'de aynı türden iki yapı 
	nesnesi birbirine atandağında yapının karşılıklı elemanları birbirine atanmaktadır. Fakat C++'ta aynı türdne iki sınıf nesnesi birbirine atandığında aslında 
	ismine "kopya atama operatör fonksiyonu" ya da "taşıma atama operatör fonksiyonu" denilen bir fonksiyon devreye girmektedir. Bu konu ileride aytı bir paragrafta 
	ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string k("izmir");
	string result;

	result = s + k;

	cout << result << endl;		// ankaraizmir
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının + operatör fonksiyonu char türden bir gösterici ile toplama işlemi de yapabilmektedir. Bu durumda operatör fonksiyonu C tarzı bir string ile 
	C++ string nesnesini toplamış gibi olmaktadır. Tabii yine bu toplama işleminden iki yazının uçuca eklenmesinden oluşan yeni bir string nesnesi elde edilecektir. 
	Örneğin:

	string s("ankara");
	char k[] = "izmir";
	string result;

	result = s + k;

	cout << result << endl;		// ankaraizmir

	result = k + s;		

	cout << result << endl;		// izmirankara

	result = s + "bursa";		

	cout << result << endl;		// ankarabursa
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	char k[] = "izmir";
	string result;

	result = s + k;

	cout << result << endl;		// ankaraizmir

	result = k + s;		

	cout << result << endl;		// izmirankara

	result = s + "bursa";		

	cout << result << endl;		// ankarabursa

	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir string nesnesi ile bir char değer de toplanabilir. Bu durumda yine stirng'teki yazı ile söz konusu char değerin uçuca eklenmesinden oluşan yeni bir string 
	nesnesi yaratılmaktadır. Örneğin:

	string s("ankara");
	string result;

	result = s + 'x';

	cout << result << endl;		// ankarax

	result = 'x' + s;;

	cout << result << endl;		// xankara
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string result;

	result = s + 'x';

	cout << result << endl;

	result = 'x' + s;;

	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının karşılaştırma operatör fonksiyonları da vardır. Biz bir string nesnesi ile başka bir string nesnesini ya da C tarzı bir yazıyı (yani char *
	türünü)	karşılaştırma işlemine sokabiliriz. Buradaki karşılaştırma strcmp fonksiyonunda olduğu gibi leksikografik bir biçimde yapılmaktadır. (Yani eşit olduğu
	sürece ilerlenir, ilk eşit olmayan karakterin durumuna bakılır.) Örneğin s ve k birers tring nesnesi olmak üzere aşağıdaki gibi işlemler yapılabilmektedir:

	if (s > k) {
		//...
	}
	else if (s < k) {
		//...
	}
	else if (s == k) {		// bilerek yerleştirilmiştir 
		//...
	} 

	C++20 ye kadar aşğıdaki 6 karşılaştırma operatörü de string sınıfında bulunuyordu:

	<, >, <=, >=, == != 

	Ancak C++20 ile birlikte == dışındaki operatör fonksiyonları string sınıfından kaldırılmış bunun yerine <=> operatörü eklenmiştir. <=> operatörüne "üç 
	yönlü karşılaştırma operatörü (three way comparison operator)" ya da "uzay gemisi operatür (space ship operator)" denilmektedir. Dolayısıyla C++20 ve 
	sonrasında string sınıfında <, >, <=, >=, != operatörlerine ilişkin operatör fonksiyonları bulunmamaktadır. Ancak derleyiciler bu operatörleri geçmişe
	doğru uyumu korumak için halen barındırmaktadır. 

	Pekiyi C++20 ile eklenen <=> operatörü nasıl bir değer üretmektedir? Bu operatör aslında strong_ordering, partial_ordering, weak_ordering gibi bazı sınıflar 
	türünden değerler üretmektedir. Biz bu sınıfların hepsini xxx_ordering sınıfı biçiminde ifade edebiliriz. Bu xxx_ordering sınıfları "> 0", "< 0" ve "== 0"
	karşılaştırmalarını yapabilecek operatmr fonksionlarına sahiptir. Dolayısıyla biz bu <=> operatöründen elde edilen değeri bu biçimde karşılaştırma işlemine 
	sokabiliriz. Örneğin:

	auto result = a <=> b;

	Eğer result > 0 işlemi true değerini verirse buradan a > b sonucu çıkartılmalıdır. Eğer result < 0 işlemi true değerini verirse buradan a < b sonucu 
	çıkartılmalıdır. Eğer result == 0 işlemi true verirse buradan da a == b sonucu çıkartılmalıdır. Benzer biçimde result != 0 karşılaştırması da yapılabilmektedir. 
	Ancak !result işlemi yapılamamaktadır. Örneğin:

	string s("ankara");
	string k("ankastre");

	auto result = s <=> k;

	if (result > 0)
		cout << "s > k" << endl;
	else if (result < 0)
		cout << "s < k" << endl;
	else if (result == 0)
		cout << "s == k" << endl;

	Standartlara göre <=> operatörünün her iki operandı da tamsayı türlerine ilişkinse karşılaştırma sonucunda strong_ordering sınıfı türünden bir değer elde 
	edilmektedir. Eğer operand'lardan biri gerçek sayı türlerine ilişkin ise bu durumda <=> operatör partial_ordering sınıfı türünden bir değer üretmektedir. 
	string sınıfında genel olarak elde edilen ürün weak_ordering sınıfı türündendir. Ancak bu konunun bazı ayrıntıları vardır. Konu ileride başka bir paragrafta 
	bağımsız olarak yeniden ele alınacaktır. 

	Üç yönlü karşılaştırma operatörü C++ standartlarına göre diğer karşılaştırma operatörlerinden daha yüksek öncelik durumdadır. Dolayıısyla aşağıdaki gibi bir işlem 
	geçerlidir:

	if (s <=> k > 0) {
		//...
	}

	Ancak Microsoft derleyicilerinde bu konuda bir sorun vardır. Microsoft derleyicileri bu operatörü daha düşük öncelikliymiş gibi ele almaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														37. Ders 27/12/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı programlama dillerinde o dillerin standart kütüphanelerinde bulunan string sınıfları "değiştirilemez (immutable)" sınıflardır. Örneğin Java, C#, Python 
	gibi billerde bir string nesnesi oluşturulduktan sonra onun karakterlerini herhangi bir biçimde dğiştiremeyiz. Halbuki C++'ın standart string sınıfı 
	"değiştirilebilir (mutable)" bir sınıftır. Yani biz yaratılmış olan bir string nesnesindeki yazı üzerinde değişiklikler yapabiliriz. 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının append isimli üye fonksiyonları mevcut yazının sonuna yeni bir yazı ya da karakter eklemektedir. Yani üye fonksiyonları ile şu eklemeleri 
	yapabiliriz:

	1) string'e C tarzı string ekleyebiliriz. Bunun için sınıfın const char * parametreli append fonksiyonu vardır. 
	2) string'e başka bir string nesnesini ekleyebiliriz. 
	3) string'e belli bir sayıda bir karakterden ekleyebiliriz. 
	4) string'e C tarzı string'in ilk n karakterini ekleyebiliriz. 
	5) string'e başka bir string'in belli bir indeksinden itibaren n tane karakterini ekleyebiliriz. 

	C++11 ile birlikte initializer_list içeren bir append fonksiyonu da sınıfa eklenmiştir. 

	Ayrıca iteratör yoluyla ekleme yapan append üye fonksiyonları da vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara"), k("eskisehir");

	s.append("izmir");			// 1
	s.append(k);				// 2
	s.append(10, 'x');			// 3
	s.append("erzurum", 3);		// 4
	s.append(k, 3, 2);			// 5

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının += operatör fonksiyonu da bulunmaktadır. Bu operatör fonksiyonu sayesinde biz append üye fonksiyonu ile yaptığımız bazı işlemleri operatör 
	sentaksıyla da yapabiliriz. += operatöründe sol taraf operand string olduğunda sağ taraftaki operand şunlardan biri olabilir:

	1) Başka bir string nesnesi
	2) Tek bir karakter
	3) C tarzı bir string (yani const char *)
	
	C++11 ile birlikte initializer_list içeren bir += operatör fonksiyonu da sınıfa eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"}, k{"izmir"};

	s += k;

	cout << s << endl;		// ankaraizmir (1)

	s += 'x';

	cout << s << endl;		// ankaraizmirx (2)

	s += "istanbul";

	cout << s << endl;		// ankaraizmirxistanbul (2)

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının erase isimli üye fonksiyonları string'ten karakter silmek için kullanılmaktadır. iki parametreli erase fonksiyonu belli bir indeksten itibaren 
	n tane karakteri silmektedir. Bu iki parametre de girilmezse yazının tamamı silinmektedir. Birinci parametre girilip ikinci parametre girilmezse o indeksten
	itibaren yazının geri kalanı silinmektedir. Sınıfın dieğr erase üye fonksiyonları iterator konusyla ilgilidir. Dolyaısıyla biz onları bu konu görülene kadar
	açıklamayacağız. eğer index değeri nesne içerisindeki yazıdan büyükse exception oluşmaktadır. Ancak silinecek karakter miktarının kalan karakter sayısından 
	büyük olması durumunda herhangi bir exception oluşmamakta geri kalan karakterlerin hepsi silinmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	
	s.erase(2, 3);

	cout << s << endl;			// ana

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir string nesnesinin herhangi bir karakterine [] operatörüyle erişebiliriz. Yine [] operatörü ile string'in herhangi bir karakterini de değiştirebiliriz. 
	Örneğin:

	string s{"ankara"};
	char ch;
	
	ch = s[4];
	
	cout << ch << endl;		// r

	s[4] = 'x';

	cout << s << endl;		// ankaxa

	Köşeli parantez içerisindeki değer yazı uzunluğuna eşit olabilir. Bu durumda '\0' karakter elde edilir. Ancak köşeli parantez içerisindeki değer yazı 
	uzunluğuna eşit olduğu durumda bir atama yapılmak istendiğinde atanan değer '\0' değilse tanımsız davranış oluşmaktadır. Eğer bu ibdeks değeri yazının 
	uzunluğundan büyükse yine tanımsız davranış oluşmaktadır. Operatör fonksiyonu tarafından herhangi sınır kontrolü yapılmamaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	char ch;
	
	ch = s[4];
	
	cout << ch << endl;		// r

	s[4] = 'x';

	cout << s << endl;		// ankaxa
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	at üye fonksiyonu da belli bir indeksteki karaktere erişmek için kullanılmaktadır. Ancak bu fonksiyonun [] operatör fonksiyonundan farkı sınır kontrolü 
	uygulamasıdır. Eğer indeks değeri yazının uzunluğundan büyük ya da yazının uzunluğuna eşitse bu fonksiyon exception (std::out_of_range) oluşturmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	char ch;

	ch = s.at(4);

	cout << ch << endl;		// r

	s.at(4) = 'x';

	cout << s << endl;		// ankaxa

	ch = s.at(100);			// exception oluşacak!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir string aralık tabanlı for döngüleriyle de karakter karakter dolaşılabilmektedir. Her yinelemede yazının sıradaki karakteri elde edilmektedir. Örneğin:

	string s{"ankara"};

	for (char c : s)
		cout << c << " ";
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};

	for (auto c : s)
		cout << c << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii aralık tabanlı for döngüsünde referans da kullanabiliriz. Bu durumda bu referans string içerisindeki karakterleri gösterir. Yani onun güncellenmesi 
	string'in karakterlerinin güncellenmesi anlamına gelecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cctype>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	
	for (auto &ch : s)
		ch = toupper(ch);

	cout << s << endl;		// ANKARA

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının substr isimli üye fonksiyonu belli bir indeksten itibaren string'in n tane karakterini bir string olarak elde etmek için kullanılmaktadır. 
	İkinci parametre girilmezse	string'in sonuna kadarki tüm karakterler elde edilir. İki parametre de girilmezse yazının aynısı elde edilmektedir. Bu da 
	kopyalama anlamına gelir. Örneğin:

	string s("ankara");
	string result;

	result = s.substr(2, 2);
	cout << result << endl;			// ka
	
	result = s.substr(2);			
	cout << result << endl;			// kara
	
	result = s.substr();			
	cout << result << endl;			// ankara

	substr fonksiyonunda indeks belirten değer yazının uzunluğundan büyükse exception (std::out_of_range) oluşmaktadır. Eğer indeks belirten değer yazının 
	uzunluğuna eşitse exception oluşmaz boş string elde edilir. Elde edilecek karakter sayısı büyükse exception oluşmaz geri kalan karakterlerin hepsi elde 
	edilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string result;

	result = s.substr(2, 2);
	cout << result << endl;			// ka
	
	result = s.substr(2);			
	cout << result << endl;			// kara
	
	result = s.substr();			
	cout << result << endl;			// ankara
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınfın replace isimli üye fonksiyonları string içeriisndeki yazının belli bir kısmını başka bir yazıyla yer değiştirmektedir. Yani bu belli kısım önce 
	silinip	sonra o yere insert işlemi yapılıyor gibi bir etki oluşturmaktadır. Sınıfın önemli replace fonksiyonları şunları yapmaktadır:

	1) String nesnesinin belli bir kısmını başka bir string nesnesindeki yazı ile yer değiştiren replace fonksiyonu
	2) String nesnesinin belli bir kısmını başka bir string nesnesindeki yazının belli bir kısmı ile yer değiştiren replace fonksiyonu
	3) String nesnesinin belli bir kısmını C tarzı bir string'in ilk n karakteri ile yer değiştiren replace fonksiyonu
	4) String nesnesinin belli bir kısmını bir karakterden n tane ile yer değiştiren replace fonksiyonu

	Fonksiyonlarda indeks belirten değerde sınır kontrolü uygulanmaktadır. Eğer indeks belirten değerler string'in belirttiği yazının uzunluğundan büyük olursa 
	exception (out_of_range) oluşmaktadır. Aynı durum değiştirilecek yazı için de söz konusudur. Ancak yazılardaki karakter miktarını belirteen değerlerde sınır
	kontrolü uygulanmamaktadır. Bu değer büyük olursa bu durum "geri kana hepsi" anlamına gelmektedir. Ancak indeks belirten değer yazı uzunluğuna eşitse bu durumda
	exception oluşmaz. Bu durum "ekleme yapma" anlamına gelir. Örneğin:

	string s{"istanbul"}, k{"ankara"};
	
	s.replace(2, 3, k);						
	cout << s << endl;							// isankarabul 

	Sınıfın overload edilmiş diğer replace fonkiyonlarını şimdilik burada ele almayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"istanbul"}, k{"ankara"}, m{"izmir"}, r{"edirne"};
	
	s.replace(2, 3, k);							// 1

	cout << s << endl;							// isankarabul 

	k.replace(2, 3, m, 2, 2);					// 2

	cout << k << endl;							// anmia

	m.replace(0, 2, "kastamonu", 3);			// 3

	cout << m << endl;							// kasmir			

	r.replace(1, 3, 5, 'x');					// 4

	cout << r << endl;							// exxxxxne

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının overload edilmiş insert fonksiyonları vardır. Bu insert fonksiyonları string'in belirttiği yazıya insert işlemi uygulamaktadır. Bu insert 
	fonksiyonlarının bazıları şunlardır:

	1) string'in belli bir indeksine belli bir karakterden n tane insert eden fonksiyon
	2) string'in belli bir indeksine C tarzı bir string'i insert eden fonksiyon
	3) string'in belli bir indeksine C tarzı bir string'in ilk n karakterini insert eden fonksiyon
	4) string'in belli bir indeksine başka bir string'i insert eden fonksiyon
	5) string'in belli bir indeksine başka bir string'in bir kısmını insert eden fonksiyon

	Bu fonksiyonlarda indeks değeri eğer string nesnesinin belirttiği yazıdan büyük olursa exception (std::length_error) oluşmakta ancak eklenecek karakter 
	sayısı büyük olursa "geri kalan hepsi" etkisi oluşmaktadır. Eğer indeks belirten değer yazının uzunluğu kadarsa bu durumda fonksiyonlar ekleme yapmaktadır.
	Sınıfın diğer insert fonksiyonlarını şimdilik burada ele almayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;
  
int main()
{
	string s{"istanbul"}, k{"ankara"}, m{"izmir"}, r{"edirne"}, t{"van"}, n{"afyon"}, v{"rize"};
	
	s.insert(4, 5, 'x');		// 1

	cout << s << endl;			// istaxxxxxnbul

	m.insert(2, "adana");		// 2

	cout << m << endl;			// isadanamir

	r.insert(2, "izmit", 3);	// 3
	
	cout << r << endl;			// edizmirne

	t.insert(1, n);				// 4

	cout << t << endl;			// vafyonan

	n.insert(1, v, 1, 2);		// 5

	cout << n << endl;			// aizfyon 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												38. Ders 03/01/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının find isimli üye fonksiyonları yazı içerisinde bir karakteri ya da başka bir yazıyı bulmak için kullanılmaktadır. Eğer söz konusu karakter 
	ya da yazı string sınıfının belirttiği yazı içerisinde bulunursa fonksiyonlar bulunduğu yerin indeks numarasıyla, bulunamazsa string::npos değeriyle 
	geri dönmektedir. find fonksiyonlarının geri dönüş değerleri string sınıfı içerisinde typedef edilmiş olan size_type türündendir. Sınıfın en çok kullanılan 
	find üye fonksiyonları şunlardır:

	- Yazının belli bir indeskinden başlayarak belli bir string nesnesinin belirttiği yazıyı arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir C tarzı string'i arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir C tarzı string'in ilk n karakterini arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir karakteri arayan fonksiyon.

	Sınıfın diğer find fonksiyonlarını şimdilik burada ele almayacağız.

	find fonksiyonlarında indeks belirten değer yazının uzunluğuna büyük ya da onunla eşit olursa fonksiyon doğrudan başarısız olur ve string::npos değeri ile 
	geri döner. find fonksiyonu bir exception oluşturmamaktadır. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{
		string s{ "ankara" };
		string::size_type result;

		if ((result = s.find("aralik", 2, 3)) == string::npos)
			cout << "cannot find" << endl;

		else
			cout << "found: " << result << endl;

		return 0;
	}

	Burada arama "ankara" yazısının 2'inci indeksin başlatılmaktadır ve "aralik" yazısının ilk üç karakterinden oluşan yazı aranmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string::size_type pos;

	pos = s.find('k');
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının rfind isimli üye fonksiyonları ilgili karakterin ya da yazının son bulunduğu yerin indeks numarasını vermektedir. Başka bir deyişle bu 
	fonksiyonlar aramayı sondan başa doğru yaparlar. Önemli rfind fonksiyonları şunlardır:
	
	- Yazının belli bir indeskinden başlayarak belli bir string nesnesinin belirttiği yazıyı sondan itibaren arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir C tarzı string'i belirttiği yazıyı sondan itibaren arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir C tarzı string'in ilk n karakterini belirttiği yazıyı sondan itibaren arayan fonksiyon
	- Yazının belli bir indeskinden başlayarak belli bir karakteri belirttiği yazıyı sondan itibaren arayan fonksiyon

	Fonksiyonlardaki indeks parametresi her zaman aramanın yapılacağı yazının başından itibaren bir indeks belirtmektedir. Arama 
	[0, index] aralığında yapılmaktadır.Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{
		string s{"anastas"};
		string::size_type result;

		if ((result = s.rfind("as", 3)) == string::npos)
			cout << "cannot find" << endl;
		else
			cout << "found: " << result << endl;		// 2

		return 0;
	}

	Burada "ankara" yazısının 3'üncü indeksinden geriye doğru arama yapılmaktadır. 
		
	Sınıfın diğer rfind fonksiyonlarını şimdilik burada ele almayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"anastas"};
	string::size_type result;

	if ((result = s.rfind("as", 3)) == string::npos)
		cout << "cannot find" << endl;
	else
		cout << "found: " << result << endl;		// 2

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın find_first_of üye fonksiyonları da yazı içerisinde karakter aramaktadır. Ancak aranan karakterler belli bir gruptan herhangi birisi olabilmektedir. 
	Sınıfın önemli find_first_of fonksiyonları şunlardır:

		- Yazının belli bir indeksinden itibaren bir string nesnesinin içerisindeki karakterlerin herhangi birini arayan fonksiyon
		- Yazının belli bir indeksinden itibaren C tarzı bir string'in karakterinden herhangi birini arayan fonksiyon
		- Yazının belli bir indeksinden itibaren C tarzı bir string'in ilk n karakterinden herhangi birini arayan fonksiyon
		- Yazının belli bir indeksinden itibaren tek bir karakteri arayan fonksiyon (bunun find fonksiyonundan bir farkı yoktur)

	Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{
		string s{ "ankara" };
		string::size_type result;

		if ((result = s.find_first_of("ka")) == string::npos)
			cout << "cannot find" << endl;
		else
			cout << "found: " << result << endl;		// 0

		return 0;
	}

	Burada "ankara" yazısı içerisinde 'a' ya da 'k' karakteri aranmıştır. Yazının 0'ıncı indeksinde 'a' karakteri bulunduğu için fonksiyon 0 iler geri dönecektir.

	Sınıfın diğer find_first_of fonksiyonlarını şimdilik burada ele almayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"}, k{"ka"};
	string::size_type result;

	if ((result = s.find_first_of(k)) == string::npos)
		cout << "cannot find" << endl;
	else
		cout << "found: " << result << endl;		// 0

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının find_first_not_of üye fonksiyonları string'in belirttiği yazının içerisinde belli bir karakter grubunda olmayan ilk karakteri bulmak için
	kullanılmaktadır. Önemli find_first_not_of fonksiyonları şunlardır:
	
	- Yazının belli bir indeksinden itibaren bir string nesnesinin içerisindeki karakterlerin herhangi birinden olmayan ilk karakteri arayan fonksiyon
	- Yazının belli bir indeksinden itibaren C tarzı bir string'in karakterlerinden herhangi birinden olmayan ilk karakteri arayan fonksiyon
	- Yazının belli bir indeksinden itibaren C tarzı bir string'in ilk n karakterinden  herhangi birinden olmayan ilk karakteri arayan fonksiyon
	- Yazının belli bir indeksinden itibaren tek bir karakteri arayan fonksiyon (bunun rfind fonksiyonundan bir farkı yoktur)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"}, k{"ka"};
	string::size_type result;

	if ((result = s.find_first_not_of("akn")) == string::npos)
		cout << "cannot find" << endl;
	else
		cout << "found: " << result << endl;		// 1

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının find_last_of ve find_last_not_of fonksiyonları find_first_of ve find_first_not of fonksiyonları gibidir. Ancak bu fonksiyonlar aramayı sondan 
	başa doğru yapmaktadır. Yukarıda da belirttiğimiz gibi buradaki indeks parametresi aramanın sondan yapılacağı yerin başını göstermektedir. Yani arama o indeksten
	itibaren başa doğru yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının starts_with ve ends_with üye fonksiyonları string nesnesinin belirttiği yazının başının ve sonunun belli bir karakterler ya da yazı ile 
	başladığını ya da bittiğini belirlemek için kullanılmaktadır. Bu üye fonksiyonların geri dönüş değerleri bool türdendir. Aşağıdaki parametrik yapılara ilişkin
	starts_with ve ends_with üye fonksiyonları vardır:

		- Belli bir karakter ile başlama ya da bitmenin tespit edilmesini sağlayan fonksiyon
		- Belli bir C tarzı string ile başlama ya da bitmenin tespit edilmesini sağlayan fonksiyon
		- Belli bir string nesnesinin belirtitği yazı ile başlama ya da bitmenin tespit edilmesini sağlayan fonksiyon

	By üye fonksiyonlar string sınıfına C++20 ile eklenmiştir. 

	Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{
		string s{"ankara"};

		cout << (s.ends_with("ara") ? "ok" : "not ok") << endl;

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++23 ile birlikte string nesnesinin içerisinde bir karakterin ya dayazının olup olmadığını belirlemek için contains isimli üye fonksiyonlar da sınıfa 
	eklenmiştir. Şu parametrik yapılara sahip contains üye fonksiyonları vardır:

		- Yazının içerisinde tek bir karakterin olup olmadığını belirlemek için kullanılan fonksiyon
		- Yazının içerisinde bir string nesnesinin belirttiği yazının olup olmadığını belirlemek için kullanılan fonksiyon
		- Yazının içerisinde C tarzı bir stirng'in olup olmadığını belirlemek için kullanılan fonksiyon

	contains fonksiyonları da bool değere geri dönmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfın tıpkı strcmp fonksiyonunda olduğu gibi karşılaştırma yapan compare fonksiyonları da vardır. Bu fonksiyonların geri dönüş değerleri int türdendir. 
	Asıl yazı parametre belirtilen yazıdan büyükse bu fonksiyonlar pozitif herhangi bir değere, küçükse negatif herhangi bir değere ve eşitse sıfır değerine 
	geri dönmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string ınıfının reserve fonksiyonu kapasiteyi büyütmek için kullanılmaktadır. C++20'ye kadar yeni kapasite değeri size değerine kadar indirilebiliyordu. 
	Ancak C++20 ile birlikte artık kapasite düşümü yapılmamaktadır. Yani reserve fonksiyonuna geçilen argüman eğer nesnenin mevcut kapasitesine eşit ya da 
	ondan küçükse fonksiyon hiçbir şey yapmamaktadır. Standartlara göre reserve fonksiyonu parametresiyle belirtilen miktardan daha büyük bir kapasite de 
	oluşturabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;

	s.reserve(100);

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;
	
	s.reserve(100);

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının shink_to_fit metodu kapasiteyi size için yeterli düzeye çekmek amacıyla kullanılmaktadır. Fonksiyon yeni capacity değerinin size değerine
	eşit olacağını garanti etmemektedir. Ancak bu fonksiyonun fazla kapasiteden kurtulmak için kullanılabileceğini belirtmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;

	s.reserve(100);

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;
	
	s.shrink_to_fit();

	cout << s << ", size: " << s.size() << ", capacity: " << s.capacity() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	stdin dosyasından bir satırlık yazıyı okuyup bir string nesnesinin içerisine yerleştirmek için <string> başlık dosyasında prototipi bulunan getline isimli
	global fonksiyon aşağıdaki gibi kullanılmaktadır:

	string s;

	getline(cin, s);
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s;

	cout << "Bir yazi giriniz:";
	getline(cin, s);

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'a "user defined literals" diye isimlendirilen bir özellik eklenmiştir. string sınıfı da bu özelliği kullanmaktadır. Bu konu operatör
	fonksiyonlarının anlatıldığı bölümde zaten ele alınacaktır. Biz burada yalnızca basit bir açıklama ile yetineceğiz. İki tırnak ifadesinin sonuna onunla 
	yapışık 's' karakteri getirilirse bu durum "bu yazıdan oluşan bir string nesnesi yarat" anlamına gelmektedir. Örneğin "ankara"s biçiminde bir yazı aslında 
	bir string nesnesi belietmektedir. Örneğin:

	string result;

	result = "ankara"s + "izmir";

	Burada aslında içerisinde "ankara" yazısı bulunan bir string nesnesi ile "izmir" yazısı toplanarakve yeni bir string nesnesi elde edilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string result;

	result = "ankara"s + "izmir";

	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte string kütüphanesine stoxxx biçiminde global fonksiyonlar da eklenmiştir. Bu fonksiyonların listesi şöyledir:
	
	stoi
	stol
	stoll
	stoul
	stoull
	stof
	stod
	stold

	Bu fonksiyonlar string nesnesi içeisindeki sayısal yazıyı ilgili temel nümerik türlere türüne dönüştürürler. (Yani bunlar atoi, atol, atof 
	gibi standart C fonksiyonlarının yaptığı işleri yapmaktadır.) Fonksiyonların geri dönüş değerleri buradaki xxx türündendir. 

	Bu fonksiyonlar yine yazının başındaki ve sonundaki boşluk karakterlerini dikkate almamaktadır. İlk tıpkı atoi, atof gibi fonksiyonlarda olduğu gibi 
	sayısal olmayan karakterde işlemini sonlandırmaktadır. Ancak yazının başında hiçbir sayılsal karakter yoksa bu fonksiyonlar exception (invalid_argument) 
	oluşturmaktadır. Örneğin:

	string s{"123ankara"};
	int result;

	result = stoi(s);

	cout << result << endl;		// 123

	Aslında bu fonksiyonların default argüman almış size_t * ve int türden parametreleri de vardır. Bu parametreler strtol, strtoul standrat C fonksiyonlarındaki
	parametrelerle aynı anlamda kullanılmaktadır. Yani dönüştürme bittiğinde biten yerin indeksi ve dönüştürmenin hangi tabana göre yapılacağını belirtmektedir. 

	Yukarıdaki fonksiyonların overload edilemeyeceğine dikkat ediniz. Çünkü bu fonksiyonların parametreleri aynı geri dönüş değerleri farklıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{"123ankara"};
	int result;
	size_t pos;
		
	result = stoi(s, &pos);

	cout << result << ", " << pos << endl;		// 123, 3

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yine C++11 ile birlikte string kütüphanesine bir grup overload edilmiş global to_string fonksiyonları da eklenmiştir. Bu fonksiyonlar stoxxx fonksiyonlarının 
	tersini yapmaktadır. Yani parametreleriyle belirtilen int, long, double gibi değerleri alıp o sayıları string nesnesi biçiminde bize verirler. to_string 
	fonksiyonlarının farklı parametrik yapılarla overload edildiğine dikkat ediniz. Yani tek bir to_string fonksiyonu yoktur. Farklı parametrik yapılara ilişkin 
	aynı isimli farklı to_string fonksiyonları vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	int val = 1234;
	string s;

	s = to_string(val);
	cout << s << endl;

	s = to_string(12.34);
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir Windows'ta bir yol ifadesinin sonundaki dosya ismi elde edilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string path, fname;

	cout << "Bir yol ifadesi giriniz:";
	getline(cin, path);

	auto pos = path.find_last_of("\\/");
	if (pos != string::npos)
		fname = path.substr(pos + 1);
	else
		fname = path;

	cout << fname << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının atama operatör fonksiyonları da vardır. Böylece biz bir string nesnesine "=" operatörü ile C tarzı bir string'i ya da başka bir string 
	nesnesini atayabiliriz. Bu tür atamalarda atanan string nesnesi başka bir yazıyı tutuyorsa onun boşaltımı yapılmaktadır. Yani herhangi bir bellek sızıntısı 
	oluşmamaktadır. Böylesi atamalarda "içerik kopyalaması" yapılmaktadır. Yani kaynak yazı yeni bir alan tahsis edilerek hedefe kopyalanmaktadır. Örneğin:

	string s("ankara");
	string k("izmir");

	k = s;

	cout << s << endl;		// ankara
	cout << k << endl;		// ankara

	s.append("kayseri");	

	cout << "---------" << endl;

	cout << s << endl;		// ankarakayse
	cout << k << endl;		// ankara

	cout << "---------" << endl;
		
	k = "istanbul";
	
	cout << k << endl;		// istanbul
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s("ankara");
	string k("izmir");

	k = s;

	cout << s << endl;
	cout << k << endl;

	s.append("kayseri");

	cout << "---------" << endl;

	cout << s << endl;
	cout << k << endl;

	cout << "---------" << endl;

	k = "istanbul";

	cout << k << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													39. Ders 08/01/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın static olmayan ye fonksiyonları "const üye fonksiyonlar" yapılabilir. Bunun için fonksiyonun parametre parantezinden sonra "const" anahtar sözcüğü 
	kullanılmaktadır. Buradaki const anahtar sözcüğü hem prototipte hem de tanımlama sırasında bulundurulmak zorundadır. Örneğin:

	class Sample {
	public:
		void foo() const;
		//...
	};

	void Sample::foo() const
	{
		//...
	}

	Global fonksiyonlar ya da static üye fonksiyonlar const yapılamamaktadır. Ayrıca sınıfın (constructor) yapıcı ve yıkıcı (destructor) üye fonksiyonları da
	const üye fonksiyon yapılamamaktadır. 

	Sınıfın const üye fonksiyonları sınıfın static olmayan veri elemanlarını  kullanabilirler ancak onları değiştiremezler. Yani bir üye fonksiyonu const yapan 
	programcı derleyiciye "o üye fonksiyon içerisinde sınıfın (static olmayan) bir veri elemanını değiştirmeyeceği sözünü" vermektedir. Tabii eğer programcı 
	bu sözünde durmazsa bu durumda program geçersiz (ill formed) olur ve derleme zamanında error oluşur. Örneğin:

	#include <iostream>

	using namespace std;

	class Sample {
	public:
		Sample(int a, int b);
		void disp() const;
		//...

	private:
		int m_a;
		int m_b;
	};

	Sample::Sample(int a, int b)
	{
		m_a = a;
		m_b = b;
	}

	void Sample::disp() const
	{
		cout << m_a << ", " << m_b << endl;		// geçerli

		m_a = 100;								// geçersiz! const üye fonksiyon sınıfın const olmayan veri elemanlarını değiştiremez
	}

	int main()
	{
		Sample s{10, 20};

		s.disp();
	
		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b);
	void disp() const;
	//...

private:
	int m_a;
	int m_b;
};

Sample::Sample(int a, int b)
{
	m_a = a;
	m_b = b;
}

void Sample::disp() const
{
	cout << m_a << ", " << m_b << endl;
}

int main()
{
	Sample s{10, 20};

	s.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi const bir üye fonksiyon içerisinde biz sınıfın veri elemanlarının değerlerini değiştiren başka bir üye fonksiyonu çağırmaya çalışsak (yani başka bir
	üye fonksiyon yoluyla sözümüzde durmamaya çalışsak) ne olur? İşte const üye fonksiyonlar const olmayan (ve static olmayan) üye fonksiyonları çağıramamaktadır. 
	Sınıfın const üye fonksiyonları yalnızca sınıfın const üye fonksiyonlarını çağırabilmektedir. Örneğin:

	class Sample {
	public:
		Sample(int a, int b);
		void disp() const;
		void foo();
		//...

	private:
		int m_a;
		int m_b;
	};

	Sample::Sample(int a, int b)
	{
		m_a = a;
		m_b = b;
	}

	void Sample::disp() const
	{
		cout << m_a << ", " << m_b << endl;

		foo();		// geçersiz! const bir üye fonksiyon sınıfın const olmayan (ve static olmayan) üye fonksiyonunu çağıramaz. 
	}

	void foo()
	{
		//...
	}

	Tabii derleyici const olmayan üye fonksiyonun sınıfın veri elemanlarını değiştirip değiştmediğine bakmamaktadır. Yani yukarıdaki örnekte foo fonksiyonu 
	sınıfın veri elemanlarını değiştirmiyor olsa bile vonst üye fonksiyonlar tarafından çağıralamaz. 

	Tabii sınıfın const olmayan bir üye fonksiyonunun const bir üye fonksiyonu çağırmasında herhangi bir sakınca yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi const yapılabilir. const sınıf nesneleri için çağrılan yapıcı ve yıkıcı fonksiyonlar o nesnenin veri elemanlarında değişiklik yapabilirler. 
	Ancak bu istisna durum dışında const nesnenin veri elemanları herhangi bir biçimde (yani doğrudan ya da dolaylı olark) değiştirilemezler. const bir sınıf 
	nesnesi ile sınıfın yalnızca const üye fonksiyonları çağrılabilmektedir. Çünkü const üye fonksiyonların sınıfın veri elemanlarını değiştirmeyeceği zaten 
	derleyici tarafından denetlenmektedir. Yapıcı fonksiyonların bir "ilkdeğer verme" işlemi de yaptıklarına dikkat ediniz. Biz const nesnelere ilkdeğer verebilmekteyiz. 
	Ancak ilkdeğer verdikten sonra artık onları değiştiremeyiz. Sınıfın yıkıcı fonksiyonları birtakım kaynakları serbest bırakırken sınıfın veri elemanlarını 
	da değiştirmek zorunda kalabilmektedir. Bu nedenle yıkıcı fonksiyonların da nesne const olsa bile sınıfın veri elemanlarını değiştirebilmesine olanak 
	sağlanmıştır. Örneğin:

	#include <iostream>

	using namespace std;

	class Sample {
	public:
		Sample(int a, int b);
		void disp() const;
		void foo();
		//...

	private:
		int m_a;
		int m_b;
	};

	Sample::Sample(int a, int b)
	{
		m_a = a;
		m_b = b;
	}

	void Sample::disp() const
	{
		cout << m_a << ", " << m_b << endl;
	}

	void Sample::foo()
	{
		disp();
	}

	int main()
	{
		const Sample s{10, 20};

		s.disp();		// geçerli, const nesne ile const üye fonksiyonlar çağrılabilir
		s.foo();		// geçersiz! const üye fonksiyonlarla const olmayan üye fonksiyonlar çağrılamaz!

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfn veri elemanları üzerinde değişiklik yapmayan üye fonksiyonların const üye fonksiyon yapılması iyi bir tekniktir. Ya da tersten söylersek sınıfın 
	veri elemanlarını değiştirmeyen üye fonksiyonların const üye fonksiyon yapılamamsı kötü bir tekniktir. Bunun tipik olarak üç nedeni vardır:

	1) Eğer üye fonksiyon sınıfın veri elemanlarını değiştirmediği halde onu const yapmazsak onun const nesnelerle çağrılabilirliğini engellemiş oluruz. 
	Örneğin:

	using namespace std;

	class Sample {
	public:
		Sample(int a, int b);
		void disp();
		//...
	private:
		int m_a;
		int m_b;
	};

	Burada disp üye fonksiyonu const yapılabileceği halde yapılmamıştır. Bu durumda biz onu aslında const bir nesneyle çağırabileceğimiz halde çağıramaz duruma
	geliriz:

	const Sample s{int a, int b};

	s.disp();		// geçersiz!

	2) const üye fonksiyonlar okunabilirliği artırmaktadır. Yani onların çağrıldığını gören kişiler onun nesnenin durumunu değiştirmediğini yalnızca veri 
	elemanlarını kullandığını anlarlar ve kodu daha iyi anlamlandırılar 

	3) const üye fonksiyonlar optimizasyon konusunda da fayda dsağlayabilmektedir. Örneğin foo fonksiyonun const bir üye fonksiyon olduğunu kabul edelim:

	s.foo();

	Derleyici bu üye fonksiyonu CALL etmeden önce o nesnenin veri elemanlarının bazılarını CPU yazmaçlarında tutmuş olabilir. Fonksiyon çağrıldıktan sonra 
	nesnenin veri elemanları değişmeyeceğine göre yazmaçtaki değer yeniden yüklemeden kullanbilir. 

	Üye fonksiyonlarda const durumu tutarlı bir biçimde kullanıldığında artık "const olmayan üye fonksiyonların sınıfın veri elemanlarını değiştirdiği" sonucu 
	da çıkartılabilir. (Çünkü eğer böyle bir const olmayan fonksiyon sınııfn veri elemanlarını değiştiriyor olmasaydı zaten const yapılırdı. Demek ki 
	değiştirmemektedir. 

	Bundan sonra kursumuzda artık sınıfın veri elemanlarını değiştirmeyen tüm üye fonksiyonlarını const üye fonksiyon yapacağız. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın private veri elemanlarının değerlerini elde etmek için kullanılan "getter" fonksiyonlar tipik const üye fonksiyon olmaya aday fonksiyonlardır. Örneğin:

	class Date {
	public:
		//...
		int day() const { return m_day;}
		int month() const { return m_month;}
		int year() const { return m_year;}
		//...
	private:
		int m_day, m_month, m_year;
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Üye fonksiyonun const olması onun imzasını değiştirmektedir. Yani sınıfta aynı isimli ve aynı parametrik yapıya sahip biri const olan diğeri const olmayan 
	üye fonksiyonlar birlikte bulnabilir. Örneğin:

	class Sample {
	public:
		//...
		void foo();				// geçerli
		void foo() const;		// geçerli
		//...
	};

	Böylsi bir durumda eğer üye fonksiyon const bir nesne ile çağrılırsa const üye fonksiyonun, const olmayan bir nesne ile çağrılırsa const olmayan üye fonksiyonun
	çağrılmış olduğu kabul edilmektedir. const bir nesneyle const olmayan üye fonksiyon zaten çağrılamamaktadır. Overload resulotion kurallarına göre const olmayan
	nesne için const olmayan üye fonksiyon daha iyi dçnüştürme sağlamaktadır. Çrneğin:

	const Sample s;
	Sample k;

	s.foo();		// const olan foo çağrılıyor
	k.foo();		// const olmayan foo çağrılır
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	void foo();
	void foo() const;
	//...
};

void Sample::foo()
{
	cout << "non-const foo" << endl;
}

void Sample::foo() const
{
	cout << "const foo" << endl;
}

int main()
{
	Sample s;
	const Sample k;

	s.foo();
	k.foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	const üye fonksiyonlar konusunda programcıların kafalarının karıştığı bir durum vardır. Sınıfın veri elemanı bir dizi ise const üye fonksiyon içerisinde
	bu dizinin bütün elemanları const gibidir. Böylece dizinin ismi de "gösterdiği tyer const olan" const bir adres gibidir. Örneğin:

	class Sample {
	public:
		//...
		void foo() const;
	private:
		char m_name[32];
	};

	void Sample::foo() const
	{
		m_name[0] = 'x';				// geçersiz!
		strcpy(m_name, "kaan");			// geçersiz! m_name gösterdiği yer const olan bir adres gibi
	}

	Buradaki const üye fonksiyon olan foo içerisinde biz m_name dizisinin hiçbir elemanını değiştemeyiz. Bu işlemi dolaylı olarak strcpy fonksiyonuyla da 
	yapamayız. Çünkü strcpy fonksiyonun birinci paramtesi gösterdiği yer const olmayan bir göstericidir. Halbuki const üye fonksiyon içerisinde m_name ifadesi
	gösterdiği yer const olan const bir adres gibidir. 

	Pekiyi sınıfın veri elemanı bir gösterici olsaydı ne olacaktı? Örneğin:

	class Sample {
	public:
		Sample() : m_name(new char[64])
		{}
		void foo() const;
	private:
		char *m_name;
	};

	const üye fonksiyon olan foo içerisinde m_name göstericisinin kendisi const gibidir,onun gösterdiği yer const değildir. Dolayısıyla foo içerisinde m_name
	göstericisinin gösterdiği yer değiştirilebilir ancak onun kendisi değiştirilemez:

	void Sample::foo() const
	{
		m_name[0] = 'x';				// geçerli, çünkü m_name nesnesinin kendisi const, gösterdiği yer değil
		strcpy(m_name, "kaan");			// geçerli, çünkü m_name nesnesinin kendisi const, gösterdiği yer değil
	}

	Fakat burada mantıksal bir karışıklık söz konusu olabilmektedir. Örneğin bir String sınıfında replcae simli bir üye fonksiyon tutulan yazının belli 
	bir karakterini belli bir karakterle yer değiştiriyor olsun:

	class String {
	public:
		//...
		void replace(char x, char y);
	private:
		char *m_str;
		size_t m_size;
		size_t m_capacity;
	};

	Burada replace fonksiyonu aslında sınıfın veri elemanları üzerinde bir değişiklik yapmamaktadır. m_str göstericisinin gösterdiği yerdeki yazıda değişiklik 
	yapmaktadır. Dolayısıyla aslında replace fonksiyonu const yapılabilir. Fakat mantıksal bakımdan durum ele alındığında sınıfı kullanan kişilerin sınıfın iç 
	yapısını bilmek zorunda olmadığına göre, sınıfı kullan kişiler için replace işlemi "değişiklik yapan" bir işlemdir. Dolayısıyla her kadar bu fonksiyon 
	const yapılabilirse de mantıksal bakımdan const yapılmaması daha uygun olabilmektedir. Yani buradaki replace fonksiyonu aslında const bir fonksiyon oalbilirse 
	de mantıksal bakımdan const değildir. Dolayısıyla bu tür durumlarda böylesi fonksiyonların const yapılmamsı daha uygundur. 

	Yukarıda biz aynı isimli ve aynı parametrik yapıya sahip const olan ve vonst olmayan üye fonksiyonların aynı sınıfta bulunabileceğini söylemiştik. Pekiyi bunun 
	ne anlamı olabilir? String sınıfının at isimli ğye fonksiyonun yazının bir karakterinin adresiyle (ya da referabsıyla) geri döndüğünü varsayalım:

	class String {
	public:
		//...
		char &at(size_t index);
	private:
		char *m_str;
		size_t m_size;
		size_t m_capacity;
	};

	char &String::at(size_t index)
	{
		return m_str[index];
	}

	Aslında buradaki at fonksiyonu const üye fonksiyon yapılabilir. Çünkü const üye fonksiyon içerisinde m_str göstericisinin kendisi const durumdadır, onun 
	gösterdiği yer const değildir. Dolayısıyla m_str[index] ifadesi const bir nesne belirtmez. Ancak burada da yine mantıksal bir uygunsuzluk vardır. Sınıfı 
	kullanan kişiler bu at ile yazıda değişiklik yapabileceklerini anlarlar ve fonksiyonun const olması mantıksal bakımdan onlara çelişkili gelir. Bu tür durumlarda
	yine böylesi fonksiyonların aslında const yapılabileceği halde const yapılmaması uygun olur. Tabii biz artın onu const bir nesneyle çağıramayız. Örneğin:

	const String s{"ankara"};

	s.at(5) = 'x';		// geçersiz! const nesne ile const olmayan üye fonksiyon çağrılamaz. 

	Ancak burada da şöyle bir sıkıntı vardır: const bir nesne ile yazının belli bir karakterine erişip orayı değiştirmeyen bir at fonksiyonun da olması gerekir. 
	İşte bu durumda sınıfta biri const olan diğeri olmayan iki at fonksiyonu bulundurulabilir. Tabii const olan at fonksiyonunun geri dönüş değeri const referans
	olmalıdır. Örneğin:

	class String {
	public:
		//...
		char &at(size_t index);
		const char &at(size_t index) const;
	private:
		char *m_str;
		size_t m_size;
		size_t m_capacity;
	};

	char &String::at(size_t index)
	{
		return m_str[index];
	}

	const char &String::at(size_t index) const
	{
		return m_str[index];
	} 

	Böylece artık aşağıdakine benzer işlemler yapılabilecektir:

	String s{"ankara"};
	const String k{"ankara"};

	s.at() = 'x';					// geçerli, const olmayan at çağrılacak

	k.at() = 'x';					// geçersiz! const olan at çağrılacak ancak const nesne değiştirilemez
		
	cout << k.at(5) << endl;		// geçerli, const olan at çağrılacak ama referansın gösterdiği yer değiştirilmiyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden referans const olabilir. Referans refere edilen nesneyi temsil ettiğine göre bu duurmda referansın gösterdiği yerdeki (refere ettiği yerdeki) 
	nesne değiştirilemez. Dolayısıyla biz const bir sınıf referansı ile sınıfın veri elemanlarını doğrudan ya da dolaylı bir biçimde değiştiremeyiz. const bir 
	sınıf referansı ile sınıfın ancak const üye fonksiyonlarını çağırabiliriz. Örneğin:

	Sample s;
	const Sample &r = s;

	Burada r referansı ile Sample sınıfının ancak const üye fonksiyonları çağrılabilir. Benzer durum göstericiler için de aynı biçimde söz konusudur. Örneğin:

	Sample s;
	const Sample *ps = &s;

	Burada ps göstericisi "gösterdiği yer const olan" const bir göstericidir. Dolayısıyla biz ps göstericisi ile ancak sınıfın const üye fonksiyonlarını 
	çağırabiliriz. Örneğin:

	void foo(const Sample &r)
	{
		//...
	}

	void bar(const Sample *ps)
	{
		//...
	}

	Burada fonksiyonlar adresini aldıkları nesne üzerinde değişiklik yapmama sözünü vermiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarında bir sınıfın veri elemanlarına ilkdeğer verilmesi MIL sentaksıyla (ctor sentaksıyla) yapılmaktadır. Yapıcı fonksiyonn gövdesi içerisinde 
	değer atama ilkdeğer verme anlamına gelmemektedir. Örneğin:

	class Sample {
		Sample(int a, int b);
		//...
	private:
		int m_a;
		int m_b;
	};

	Sample::Sample(int a, int b) : m_a(a)		// m_a'ya ilkdeğer verilmiş
	{
		m_b = b;			// bu bir ilkdeğer verme değil ilk kez değer atama
	}

	Burada her ne kadar m_a ile m_b veri elemanlarına değer atama arasında anlamsal bir farklılık yoksa da standart bağlamında m_a elemanına yapılan atamaya 
	ilkdeğer verme denilmektedir. Örneğin sınıfın veri elemanı const ise bizim ona MIL sentaksıyla ilkdeğer vermemiz gerekir. Çünkü const nesnelere ilkdeğer 
	verilmesi gerekmektedir ve ilkdeğer vermek standartlara göre MIL sentaksıyla değer vermektir. Örneğin:

	class Sample {
	public:
		Sample();
		//...
	private:
		const int m_a;
	};

	Sample::Sample()
	{
		m_a = 10;			// geçersiz! bu ilk değer vermek değil
		//...
	}

	Burada m_a veri elemanı const olduğu için ona MIL sentaksında ilkdeğer vermek gerekiyordu:

	class Sample {
	public:
		Sample();
		//...
	private:
		const int m_a;
	};

	Sample::Sample() : m_a(10)		// geçerli
	{
		//...
	}

	Artık biz const veri elemanına ilkdeğer vermiş durumdayız. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											40. Ders 10/01/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	Sınıfın referans türünden bir veri elemanı da olabilir. Referanslar ilkdeğer verilerek tanımlanmak zorunda olduğuna göre veri elemanı olan referanslara 
	MIL sentaksı ile ilkdeğer verilmesi gerekir. Örneğin:

	class Sample {
	public:
		Sample(int &r);
		int &r() const { return m_r; }
		//...
	private:
		int &m_r;
	};

	Sample::Sample(int &r) : m_r(r)
	{
		//...
	}

	Burada m_r veri elemanına aynı türden bir nesne ile ilkdeğer verildiğine dikkat ediniz. Bu örnekte m_r parametre değişkeni ile belirtilen referansın gösterdiği 
	nesneyi refere etmektedir. Tabii nesne yaşadığı sürece m_r referansının refere ettiği nesnenin de yaşaması gerekir. Örneğin:

	int x = 10;
	Sample s{x};

	s.r() = 20;

	cout << x << endl;

	Burada aslında 20 değeri x değişkenine atanmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int &r);
	int &r() const { return m_r; }
	//...
private:
	int &m_r;
};

Sample::Sample(int &r) : m_r(r)
{
	//...
}

int main()
{
	int x = 10;
	Sample s{x};

	s.r() = 20;

	cout << x << endl;			// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi constexpr olabilir. Anımsanacağı gibi constexpr nesneler aynı zamanda const nesne kabul ediliyordu. Yine constexpr nesnelere verilen 
	ilkdeğerlerin sabit ifadesi olması gerektiğini anımsayınız. C++11 ile birlikte constexpr sınıf nesneleri için çağrılacak yapıcı fonksiyonların constexpr
	yapıcı fonksiyonu olması gerekmektedir. Buradan da anlaşılacağı gibi yapıcı fonksiyonlar constexpr olabilirler. constexpr sınıf nesneleri için constexpr
	yapıcı fonksiyonları çağrıldığında sınıfın tüm veri elemanlarına sabit ifadeleri ile MIL sentaksında ilkdeğer veriliyor olması gerekmektedir. Örneğin:

	class Sample {
	public:
		constexpr Sample();
		void disp() const;
		//...
	
		int m_a;
		int m_b;
	};

	constexpr Sample::Sample() : m_a(10), m_b(20)
	{
		//...
	}

	void Sample::disp() const
	{
		cout << m_a << ", " << m_b << endl;
	}
	
	Burada constexpr yapıcı fonksiyonunda sınıfın m_a ve m_b veri elemanlarına sabit ifadeleriyle ilkdeğer verildiğine dikkat ediniz. Artık bu sınıf türünden
	constexpr bir nesne yaratıp kullanabiliriz:

	constexpr Sample s;

	s.disp();			// geçerli s constexpr yani aynı zamanda const, disp de const bir üye fonksiyon

	Burada artık constexpr sınıf nesnesi constexpr yapıcı fonksiyonu ile oluşturulmaktadır ve aynı zamanda sınıfın veri elemanlarına sabit ifadeleriyle ilkdeğer 
	verilmiştir. constexpr bir sınıf nesnesinin veri elemanları constexpr biçimindedir. Dolayısıyla bu nesnenin veri elemanları sabit ifadesi olarak kullanılabilir. 
	Örneğin:

	constexpr Sample s;
	constexpr int x = s.m_a			// geçerli artık s.m_a sabit ifadesi belirtir

	constexpr yapıcı fonksiyonunda sınıfın veri elemanlarına parametredeki değişkenler atanabilir. Ancak bu durumda parametrelere sabit ifadesi biçiminde 
	argüman geçirilmesi gerekmektedir. Örneğin:

	class Sample {
	public:
		constexpr Sample(int a, int b);
		void disp() const;
		//...

		int m_a;
		int m_b;
	};

	constexpr Sample::Sample(int a, int b) : m_a(a), m_b(b)
	{
		//...
	}

	//...

	constexpr Sample s{10, 20};						// geçerli 
	constexpr int x = s.m_a + s.m_b					// geçerli

	Aşağıdaki yaratımın geçerli olmadığına error oluşturacağına dikkat ediniz:

	int a = 10, b = 20;
	constexpr Sample s{a, b};		// geçersiz! m_a ve m_b veri elemanlarına sabit ifadeleriyle ilkeğer verilmemiş oluyor
	
	Tabii constexpr yapıcı fonksiyonları normal nesneleri oluşturmak için de kullanılabilir. Örneğin:

	int a = 10, b = 20;
	Sample s{a, b};							// geçerli, s constexpr değil
	
	constexpr int x = s.m_a + s.m_b;		// geçersiz! m_a ve m_b veri elemanları constexpr değil

	Burada s nesnesi constexpr değildir. Ancak bu nesneye constexpr yapıcı fonksiyonu ile ilkdeğer verilebilmektedir. Tabii bu durumda nesnenin m_a ve m_b 
	veri elemanları constexpr elemanlar olmaz. Özetle sınıfın constexpr yapıcı fonksiyonları aynı zamanda normal yapıcı fonksiyon olarak da kullanılabilmektedir. 

	Yukarıda da belirttiğimiz gibi C++'ın sürümü ilerledikçe constexpr fonksiyonlar gevşetilmiş ve adeta constexpr olmayan fonksiyonlar gibi bir yapıya bürünmüştür. 
	Dolayısıyla constexpr olmayan nesneler constexpr yapıcı fonksiyonlarıyla oluşturulabnilmektedir. Bu durumda nesnenin veri elemanlarına sbit ifadesi ile ilkdeğer 
	verilmeyebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları da constexpr olabilir. Bu üye fonksiyonlar çağrıldığında global constexpr fonksiyonların çağrılmasında olduğu gibi fonksiyona 
	verilen argümanlar ve return ifadesi de sabit ifadesiyse fonksiyonun geri dönüş değeri de sabit ifadesi olarak ele alınmaktadır. Tabii constexpr üye 
	fonksiyonlarda eğer üye fonksiyonun çağrıldığı nesne constexpr ise sınıfın veri elemanları da sabit ifadesi gibi kullanılabilmektedir. Ayrıca bir fonksiyonun 
	geri dönüş değerinin sabit ifadesi olarak kullanılabilmesi için "onun constexpr olmasının gerek koşul ancak yeter koşul olmadığını" anımsayınız.
	
	Örneğin constexpr bir sınıf nesnesinin veri elemanlarını private bölüme yerleştirince bizim onlara public getter fonkisyonlarla erişmemiz gerekir. İşte bu getter 
	fonksiyonların geri dönüş değerlerinin sabit ifadesi belirtmesi için onların constexpr üye fonksiyon olması gerekmektedir. Örneğin:

	class Sample {
	public:
		constexpr Sample(int a, int b);
		void disp() const;
		constexpr int a() const { return m_a;}
		constexpr int b() const { return m_b;}
		//...
	private:
		int m_a;
		int m_b;
	};

	constexpr Sample::Sample(int a, int b) : m_a(a), m_b(b)
	{
		//...
	}

	Burada a ve b getter fonksiyonlarının constexpr olduğuna dikkat ediniz. Artık bu fonksiyonlar constexpr sınıf nesneleriyle çağrıldığında bunların geri 
	dönüş değerleri sabit ifadesi belirtecektir:

	constexpr Sample s{10, 20};					// geçerli
	constexpr int x = s.a() + s.b();			// geçerli s.a() ve s.b() çağrıları sabit ifadesi belirtiyor

	Bu örnekte a ve b getter fonksiyonlarının aynı zamanda const üye fonksiyon olması gerektiğine dikkat ediniz. Eğer bu fonksiyonlar const üye fonksiyon 
	yapılmazsa constexpr nesne ile bu fonksiyonlar çağrılamazdı (constexpr nesnelerin aynı zamanda const nesneler olduğunu anımsayınız.)

	constexpr üye fonksiyonlar constexpr olmayan nesnelerle de çağrılabilmektedir. 

	Pekiyi biz bir sınıfın bir üye fonksiyonunun constexpr olduğunu gördüğümüzde ne anlamalıyız? İşte eğer üye fonksiyon constexpr ise bu üye fonksiyon çağrıldığında 
	elde edilecek geri dönüş değeri uygun koşullar sağlanmışsa sabit ifadesi olarak ele alınabilecektir. 

	Biz bir sınıf için hiç yapıcı fonksiyon yazmamışsak derleyici default yapıcı fonksiyonu kendisi içi boş olarak yazıyordu. İşte derleyicinin yazdığı bu default 
	yapıcı fonksiyon bazı koşullar sağlanıyorsa (standartlar buna "constexpre suitable class" denilmektedir) constexpr kabul edilmektedir. Ancak anımsanacağı gibi 
	derleyicinin kendisinin yazdığı default yapıcı fonksiyon MIL sentaksında hiçbir şey olmayan gövdesi boş olan bir yapıcı fonksiyondur. Örneğin:

	class Sample {
		//...
	};

	constexpr Sample s;			// geçerli

	Buradaki kod geçerlidir. Çünkü sınıfın bir veri elemanı olmadığı için constexpr sınıf nesnesinde sabit ifadeleriyle ilkdeğer verilmesi gereken bir veri elemanı 
	yoktur. Yani yukarıdaki kod aşağıdaki ile eşdeğerdir:

	class Sample {
	public:
		constexpr Sample()
		{}
	};

	constexpr Sample s;			// geçerli

	Şimdi sınıfın static olmayan bir veri elemanı bulunuyor olsun:

	class Sample {
	public:
		int m_a;
	};

	constexpr Sample s;			// geçersiz!

	Atrık constexpr nesnenin derleyici tarafından yazılmış olan default yapıcı fonksiyon ile oluşturulması geçersizdir. Çünkü standartlara göre yukarıdaki 
	kodun eşdeğeri şöyledir:

	class Sample {
	public:
		constexpr Sample() {}
		int m_a;
	};

	constexpr Sample s;			// geçersiz!

	Görüldüğü atrık constexpr nesne için çağrılan yapıcı fonksiyon sınııfn m_a veri elemanına bir sabit ifadesi ile ilkdeğer vermemiş durumdadır. 

	Sınıfların yıkıcı fonksiyonları da constexpr olabilmektedir. C++ standartlarına göre constexpr bir sınıf nesnesi için çağrılacak yıkıcı fonksiyonun constexpr 
	olması gerekmektedir. Örneğin:

	class Sample {
	public:
		constexpr Sample() : m_a(10)
		{}

		~Sample()
		{}
	
	private:
		int m_a;
	};

	Burada aşağıdaki gibi constexpr bir nesne yaratamayız:

	constexpr Sample s;		// geçersiz! yıkıcı fonksiyon constexpr değil

	constexpr nesnenin tanımlanabilmesi için yıkıcı fonksiyonun constexpr olması gerekirdi:

	class Sample {
	public:
		constexpr Sample() : m_a(10)
		{}

		constexpr ~Sample()
		{}
	
	private:
		int m_a;
	};

	constexpr Sample s;		// geçerli
	
	Standartlara göre biz bir sınıf için yıkıcı fonksiyon yazmasak derleyicinin yazdığı içi boş yıkıcı fonksiyon özel bazı koşulları da sağlıyorsa ("constexpr 
	suitable" ise) constexpr biçimdedir. 

	Yukarıda açıkladığımız durum açıkça defaulted hale getirilmiş yapıcı ve yıkıcı fonksiyonlar için de geçerlidir. Örneğin:

	class Sample {
	public:
		Sample() = default;
		~Sample() = delete;
	};

	constexpr Sample s;			// geçerli

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	const üye fonksiyonlarla constexpr üye fonksiyonların farklı anlamlara geldiğine dikkat ediniz. const üye fonksiyonlar const nesnelerle çağrılırlar. constexpr
	fonksiyonlar da eğer constexpr nesnelerle çağrılırsa sabit ifadesi belirtmektedir. En normal olan durum constexpr üye fonksiyonların aynı zamanda const olmasıdır. 
	Mevcut standartlarda bir üye fonksiyon constexpr olduğu halde const üye fonksiyon olmayabilir. Ancak böyle fonksiyonlar constexpr nesnelerle çağrılamazlar.
	Üye fonksiyonun constexpt olduğu halde const olmaması çok seyrek bazı durumlarda esneklik kazandırmaktadır. Ancak belirttiğimiz gibi en normal durum constexpr
	üye fonksiyonların aynı zamanda const üye fonksiyonlar olmasıdır. 	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi constexpr olmayan bir sınıf nesnesine constexpr bir yapıcı fonksiyon ile ildeğer verilmiş olsa bile nesnenin veri elemanları 
	constexpr kabul edilmemektedir. Örneğin:

	class Sample {
	public:
		constexpr Sample(int a) : m_a(a)
		{}
		int m_a;
	};
	//...

	Sample s{10};

	constexpr int a = s.m_a;		// geçersiz! s constexpr değil, dolayısıyla s.m_a da constexpr değil

	Ancak mevcut C++ standartlarına göre constexpr yapıcı fonksiyon ile oluşturulmuş olan geçici sınıf nesnelerine eğer constexpr nesne gibi ilkdeğer verilmişse
	bu durumda bu geçici nesne nesne ile sınıfın veri elemanlarına erişildiğinde bu veri elemanları constexpr nesneler gibi ele alınmaktadır. Örneğin:

	class Sample {
	public:
		constexpr Sample(int a) : m_a(a)
		{}
		int m_a;
	};
	//...

	constexpr int a = Sample(10).m_a;	// geçerli, artık yaratılan geçici nesne constexpr gibi ele alınıyor

	Biz henüz sınıflar türünden geçici nesnelerin oluşturulmasını görmedik. Bu nedenle bu konu üzerinde şimdilik çok takılmayınız. Sınıflar türünden geçici
	nesnelerin yaratılması ve kullanılması izleyen paragraflarda ele alınmaktadır. 

	Şimdi neden constexpr üye fonksiyonların default olarak const üye fonksiyon kabul edilmediğini merak ediyor olabilirsiniz. Mevcut C++ standartlarına göre 
	eğer constexpr yapıcı fonksiyon ile oluşturulmuş olan geçici sınıf nesnelerine constexpr nesne gibi ilkdeğer verilmişse bu durumda bu geçici nesne yoluyla
	sınıfın constexpr olan ancak const olmayan üye fonksiyonları çağrılabilir ve bu çağrı ifadesi diğer koşulları sağlıyorsa sabit ifadesi olarak ele alınabilmektedir. 
	Örneğin:

	class Sample {
	public:
		constexpr Sample(int a) : m_a(a)
		{}
		constexpr int set_and_inc(int a)
		{
			m_a = a;

			return m_a;
		}
	private:
		int m_a;			
	}
	//...

	constexpr int a = Sample(10).set_and_inc(20);	// geçerli, geçici nesne yoluyla sınıfın const olmayan ama constexpr olan üye fonksiyonu çağrılmış
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new operatörü sabit ifadesi yaratmakta mıdır? Mevcut C++ standartlarına göre new operatörünün sabit ifadesi yaratabilmesi için new operatörü ile tahsisatın
	yapıldığı ifade sonlandığında o tahsisatın delete operatörü ile siliniyor olması gerekir. Örneğin:
	
	class Sample {
	public:
		constexpr Sample(int a) : m_pa(new int(a))
		{}
		constexpr ~Sample()
		{
			delete m_pa;
		}
		constexpr int a() { return *m_pa;}

	private:
		int *m_pa;
	};

	Burada biz Sample sınıfı türünden constexpr bir nesneyi aşağıdaki gibi yaratamayız:

	constexpr Sample s{10};		// geçersiz!

	Buradaki sorun derleme aşamasında ele alınan new operatörü için delete işleminin çalışma zamanında yapılmasıdır. Yani bu haliyle s nesnesi aslında sabit 
	ifadesi biçiminde değerlendirilememektedir. Ancak bunun şöyle bir istisnası vardır: Eğer nesne geçici nesne olarak yaratılırsa bu durumda ilgili ifadenin 
	sonunda zaten yıkıcı fonksiyon çalışacağı için bu nesne de yalnızca o ifadede kullanılabileceği için new işlemi sabit ifadesi oluşturmada bir soruna yol 
	açmamaktadır. Örneğin:

	constexpr int x = Sample{10}.a();		// geçerli

	Yukarıdaki Sample{10}.a() ifadesi artık sabit ifadesi oluşturmaktadır. Bu ifadede her ne kadar yine new operatörü kullanılmışsa da delete ile boşaltım 
	ifadenin sonunda yapılacağı için söz konusu bu ifade bir yan etkiye yol açmadan derleme aşamasında yapılabilecektir. 

	Tabii bu anlatımın anlaşılabilebilmesi için "geçici sınıf nesnelerinin yaratılması" konusunun biliniyor olması gerekmektedir. İzleyen paragraflarda geçici 
	sınıf nesnelerin yaratılması konusu el alınmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütphanesinde zamanla değişik sürümlerde eski sınıfların pek çok üye fonksiyonları constexpr haline getirilmiştir. Ancak bu sınıfları kullanırken
	mevcut kütüphanenin (ve derleyicinin) bunu destekleyip desteklemediğine dikkat ediniz. Microsoft'un ve GNU'nun standart C++ kütüphaneleri standartlara göre 
	biraz geriden gelmektedir. Derleyicileri yazanlar ile standart kütüphaneyi yazanlar genellikle farklı proje gruplarıdır. Derleyicinin sürümünün ileri olması 
	standart kütüphanenin o sürümde olmasını sağlamayabilmektedir. 

	Örneğin standart string sınıfının bazı yapıcı fonksiyonları ve bazı üye fonksiyonları zamanla constexpr haline getirilmiştir. örneğin string sınıfın const char *
	parametreli yapıcı fonksiyonu C++20 ile birlikte constexpr yapılmıştır. Benzer biçimde size üye fonksiyonu da C++20 ile birlikte constexpr yapılmıştır. 
	Ancak yukarıdaki paragrafta belirttiğimiz nedenlerden dolayı biz yine C++20 bile olsa aşağıdaki gibi string sınıfı türünden constexpr bir nesneyi tanımlayamayız:

	constexpr string s{"ankara"};			// geçersiz!

	Ancak yine yukarıdaki paragrafta belirttiğimiz gerekçelerden dolayı aşağıdaki gibi geçici nesne yoluyla sabit ifadeleri oluşturulabilmektedir:

	constexpr string::size_type n = string{"ankara"}.size();			// geçerli

	Ancak maalesef mevcut standartlara göre (C++20) yukarıdaki tanımlama geçerli lolduğu halde henüz g++ derleyicisi bu kodu geçerli bir biçimde derleyememektedir. 
	Microsoft'un güncel C++ derleyicileri yukarıdaki kod derleyebilmektedir. clang++ derleyicisi "-std=c++2b" seçeneği ile derleyebilir hale gelmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Mademki artık C++ ile birlikte neredeyse constexpr fonksiyonlar normal fonksiyon gibi de kullanılabilmektedir. O halde genel olarak şu tavsiyede bulunulmaktadır:
	"Eğer "inline olabilecek global bir fonksiyonu ya da üye fonksiyonu constexpr olarak yazabiliyorsanız constexpr olarak yazınız." constexpr fonksiyonların 
	aynı zamanda inline olduğunu anımsayınız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta kursta geldiğimiz konular çerçevesinde ilkdeğer verme anlamına gelen üç tipik durum vardır:

	1) Açıkça tanımlamada tanımlanan nesneye ilkdeğer verilmesi durumu. Örneğin:

	int a = 10;
	int b{10};
	int c(10);

	2) Fonksiyon çağrılırken argümanlardan parametre değişkenlerine aktarımın yapıldığı durum. Örneğin:

	void foo(int a)		// int a = 10
	{
		//...
	}
	//...

	foo(10);


	3) return işleminde geri dönüş değerinin oluşturulmasındaki durum. Örneğin:

	int foo()		// int temp = 10
	{
		//...

		return 10;
	}

	C++ stanadartlarına göre bir nesneye normal parantezlerle ya da küme parantezleriyle (yani '=' atomu kullanılmadan) ilkdeğer verme işlemine "direct 
	initialization", '=' atomu kullanılarak ilkdeğer verme işlemine, fonksiyon çağrımı sırasında parametre değişkenine argüman yoluyla ilkdeğer verme işlemine
	ve return deyimi ile geçici nesneye ilkdeğer işlemine ise "copy initialization" denilmektedir. Örneğin:

	int a{10};		// direct initialization
	int a(10);		// direct initialization
	
	int b = 10;		// copy initialziation

	void foo(int a)
	{
		//...
	}

	foo(10);		//  copy initialization

	int bar()
	{
		//...

		return 10;		// copy initialization
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesinin aynı türden bir sınıf nesnesiyle ilkdeğer verilerek tanımlandığını düşünelim. Örneğin:

	Sample s;
	Sample k{s};

	Bu durum bir fonksiyonun çağrılması sırasında da söz konusu olabilir. Çünkü fonksiyon çağırma işlemi aslında parametre değişkenine ilkdeğer verme işlemi 
	gibi ele alınmaktadır. Örneğin:

	void foo(Sample k)
	{
		//...
	}
	//...

	Sample s;

	foo(s);

	Burada da aslında Sample k = s gibi bir işlem yapılmaktadır. Benzer biçimde return işlemi de aslında return işlemiyle yaratılacak olan geçici nesnye ilkdeğer 
	verme işlemidir. Örneğin:

	Sample foo()
	{
		Sample s;

		//

		return s;
	}

	Burada da aslında Sample temp = s gibi bir işlem yapılmaktadır. 

	Bir sınıf nesnesini aynı sınıf türünden bir nesneyle ilkdeğer vererek yarattığımız durumda ne olmaktadır? Örneğin:

	Sample s;
	Sample k{s};

	C'de aynı türden iki yapı nesnesinin birbirilerine atandığı durumda onların karşılıklı elemanlarının birbirine atandığını biliyorsunuz. Gerçekten de 
	C++'ta da bu tür durumlarda default olarak nesnenin karşılıklı veri elemanlarını birbirine atanmaktadır. Örneğin:

	class Complex {
	public:
		Complex(double real, double imag) : m_real(real), m_imag(imag)
		{}
		//...
	private:
		double m_real, m_imag;	
	};
	//...

	Complex x{3, 2};
	Complex y{x};

	Burada C++'ta default durumda x'in m_real veri elemanı y'nin m_real veri elemanına, x'in m_imag veri elemanı y'nin m_imag veri elemanına atanacaktır. 
	Ancak yapılan bu default atama bazı durumlarda sorunlara yol açabilmektedir. Örneğin sınıfın bir gösterici veri elemanı olduğunda karşılıklı veri elemanlarının
	birbirlerine atanması gösterici içerisindeki adreslerin birbirine atanmasına yol açacağı için sorun oluşturma potansiyeline sahiptir. Daha önce yazmış olduğumuz 
	String sınıfını çok yalın bir biçimde aşağıdaki gibi yeniden yazalım:
	
	class String {
	public:
		String(const char *str);
		~String();
		void disp() const;
	
	private:
		char *m_str;
		size_t m_size;
	};

	String::String(const char *str)
	{
		m_size = strlen(str);
		m_str = new char[m_size + 1];

		strcpy(m_str, str);
	}

	String::~String()
	{
		delete[] m_str;
	}

	void String::disp() const
	{
		cout << m_str;
	}

	Şimdi string nesnesinin yine bir String nesnesi ile ilkdeğer verilerek tanımlanmış olduğu aşağıdaki örneğe dikkat ediniz:

	String s{"ankara"};

	{
		String k{s};		// dikkat! adres kopyalaması yapılmaktadır

		//...
	}

	s.disp();

	Burada String k{s} tanımlamasında s'nin karşılıklı veri elemanları k'ya kopyalanırsa bu durumda s.m_str ile k.m_str aynı nesneyi gösterir hale gelir. Daha sonra
	ömrü kısa olan k için yıkıcı fonksiyon çağrıldığında bu fonksiyon k nesnesinin m_str göstericisi ile gösterilen alanı boşaltacağı için artık s nesnesinin
	m_str elemanının gösterdiği yer de boşaltılmış olacaktır. Böylece iç bloktan çıkıldığında s nesnesi bozuk bir durumda olacaktır. Buradan çıkan sonuç şudur: 
	Bu tür durumlarda karşılıklı veri elemanlarının kopyalanması özellikle gösterici veri elemanları söz konusu olduğunda sorunlara yol açabilmektedir. Pekiyi 
	bu problem nasıl çözülebilir? En uygun çözüm bu tür durumlarda "içerik kopyalamasının" yapılmasıdır. Yani gösterici veri elemanlarının gösterdiği yerin de 
	kopyasından çıkartılması böylese iki nesnenin gösteri veri elemanlarının farklı alanları göstermesinin sağlanmasıdır. Bu tür kopyalamalara diğer programlama
	dilelrinin bazılarında "derin kopyalama (deep copy)" de denilmektedir. 

	İşte C++'ta bir sınıf nesnesinin aynı sınıf türünden bir nesneyle ilkdeğer verilerek yaratılması durumunda yaratılan nesne için "kopya yapıcı fonksiyonu (copy 
	constructor)" denilen bir yapıcı fonksiyon çağrılmaktadır. Örneğin:

	Sample s;
	Sample k{s};

	Burada s için default yapıcı fonksiyon k için ise kopya yapıcı fonksiyon çağrılmaktadır. Eğer programcı sınıfı için kopya yapıcı fonksiyonu yazmazsa kopya 
	yapıcı fonksiyonu derleyici tarafındna sınıfın karşılıklı veri elemanlarını birbirine atayacak biçimde (ilkdeğer verecek biçimde) yazılmaktadır. İşte çoğu 
	kez derleyicinin kendisinin yazdığı bu yapıcı fonksiyon işimizi görmektedir. Ancak yukarıdaki String örneğinde olduğu gibi bazı durumlarda bizim bu fonksiyonu 
	içerik kopyalaması yapacak biçimde yazmamız gerekir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	 Sınıfın kopya yapıcı fonksiyonu sınıfın kendi türünden referans parametreli yapıcı fonksiyonudur. Sınıfın ismi T olmak üzere aşağıdaki parametrelere sahip 
	 yapıcı foksiyonların hepsi kopya yapıcı fonksiyon (copy contructor) olarak kullanılabilir:

	 const T &
	 T &
	 volatile T &
	 const volatile T &

	 Sınıfın en çok kullanılan kopya yapıcı fonksiyonu ""const T &" parametreli yapıcı fonksiyonudur. Sınıfın T parametreli (referans olmayan parametreli) yapıcı
	 fonksiyonunun kopya yapıcı fonksiyonu olarak ele alınmadığına dikkat ediniz. İleride de anlayacağız gibi eğer böyle bir yapıcı fonksiyon olabilseydi bazı
	 durumlarda sonsuz döngü oluşurdu. 

	 Sınıfın en çok kullanılan kopya yapıcı fonksiyonunun "const T &" parametreli kopya yapıcı fonksiyonu olduğunu söylemiştik. Bunun nedenini izleyen 
	 paragraflarda anlayacaksınız. Tabii kopya yapıcı fonksiyonları da overload edilebilir. Örneğin.

	 class Sample {
	 public:
		//...
		Sample(const Sample &r);
		Sample (Sample &r);
		//...
	 };

	 Yukarıdaki iki kopya yağıcı fonksiyon sınıfta birlikte bulunabilir. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														42. Ders 17/01/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------												
	Kopya yapıcı fonksiyonu bir sınıf türünden nesnenin aynı sınıf türünden bir nesneyle ilkdeğer verilerek yaratılması durumlarında çağrılmaktadır. 
	Daha açık bir ifade ile kopya yapıcı fonksiyonları tipik olarak şu durumlarda çağrılmaktadır:

	1) Bir sınıf nesnesinin aynı sınıf türünden bir nesneyle doğruadan ya da '=' atomuyla ilkdeğer verilerek tanımlanması durumunda. Örneğin:

	Sample s;
	Sample k{s};

	Burada ilkdeğer vermenin doğurdan (direct initialization) ya da '=' atomu ile yapılması (copy initialization) arasında hiçbir farklılk yoktur. Yani örneğin
	aşağıdaki tanımlamada da kopya yapıcı fonksiyonu çağrılacaktır:

	Sample s;
	Sample k = s;

	İleride de ele alacağımız gibi aslında doğrudan ilkdeğer verme ile '=' atomu ile ilkdeğer verme arasında bazı farklılıklar oluşabilmektedir. Ancak kaynak 
	tür yaratılacak hedef türle aynı sınıf türündense burada bir farklılık oluşmamaktadır.

	2) Fonksiyonun parametre değişkeni bir sınıf türünden ise ve u fonksiyon aynı sınıf türünden bir sınıf nesnesiyle çağrıldığında parametre değişkeni için de 
	kopya yapıcı fonksiyonu çağrılır. Örneğin:

	void foo(Sample k)
	{
		//...
	}
	//...

	Sample s;

	foo(s);

	Burada parametre değişkeni olan k için kopya yapıcı fonksiyonu çağrılır. 

	3) Fonksiyonun geri dönüş değeri bir sınıf türünden olabilir. Bu durumda return işleminde return anahtar sözcüğünün yanında aynı sınıf türünden bir nesne 
	olmalıdır. İşte geri dönüş değeri için yaratılacak olan geçici nesne için sınıfın kopya yapıcı fonksiyonu çağrılır. Örneğin

	Sample foo()
	{
		Sample s;

		//...

		return s;
	}

	Burada return işlemi oluşturulacak geçici nesne için kopya yapıcı fonksiyonu çağrılır.
		 
	Yukarıda da belirtitğimiz gibi sınıfın kopya yapıcı fonksiyonu içerik kopyalaması (derin kopyalama) yapacak biçimde yazılmalıdır. 
	 
	Kopya yapıcı fonksiyonu derleyici tarafından çağrıldığında ilkdeğer olarak verilen nesnenin adresi kopya yapıcı fonksiyonunun referans parametresine aktarılır. 
	Kopya yapıcı fonksiyonunu yazan programcı da o nesnenin içeriğini yeni yaratılan nesnede oluşturmaya çalışır. Örneğin:

	class Sample {
	public:
		Sample();						// default constructor
		Sample(const Sample &r);		// copy constructor
		//...
	};

	Sample::Sample(const Sample &r)
	{
		//...
	}
	//....

	Sample s;

	Sample k = s;

	Burada k nesnesi için kopya yapıcı fonksiyonu çağrılır. s nesnesinin adresi fonksiyonun r referans parametresine aktarılır.

	Sınıfın başka sınıf türünden veri elemanlarının bulunduğu durumda sınıfın kopya yapıcı fonksyonu bu veri elemanları için kendi sınıflarının kopya yapıcı 
	fonksiyonlarının çağrılmasını sağlamalıdır. Eğer programcı bunu sağlamazsa bu veri elemanları için kopya yapıcı fonksiyonu değil default yapıcı fonksiyon 
	çağrılmaktadır. Bu işlemin nasıl yapılacağı ileride ele alınacaktır.

	Aşağıda basitleştirilmiş bir String sınıfı için kopya yapıcı fonksiyonun yazılmasına bir örnek verilmişti. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstring>

using namespace std;

class String {
public:
	String(const char *str);
	~String();
	String(const String &r);
	void disp() const;
	
private:
	char *m_str;
	size_t m_size;
};

String::String(const char *str)
{
	m_size = strlen(str);
	m_str = new char[m_size + 1];

	strcpy(m_str, str);
}

String::String(const String &r)
{
	m_str = new char[r.m_size + 1];
	strcpy(m_str, r.m_str);
	m_size = r.m_size;
}

String::~String()
{
	delete[] m_str;
}

void String::disp() const
{
	cout << m_str << endl;
}

void foo(String k)			// String k = s
{
	k.disp();
}

int main()
{
	String s{"ankara"};

	foo(s);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda sınıfın en çok kullanılan kopya yapıcı fonksiyonunun "const T &" parametreli yapıcı fonksiyon olduğunu belirtmiştik. Pekiyi yapıcı fonksiyonu biz 
	"T &" parametreli yazarsak ne olur? Örneğin:

	class Sample {
	public:
		//...
		Sample(Sample &r);
		//...
	};

	Bu durumda ildeğer olarak verilen nesne const ise derleme aşamasında error oluşacaktır. Örneğin:

	const Sample s;
	Sample Sample k{s};			// geçersiz!

	const bir nesnenin adresi const olmayan bir sol taraf değeri referansına bind edilemez. Halbuki kopya yapıcı fonksiyonunun parametresi "const T &" olsaydı
	bir sorun oluşmayacaktı. Tabii pek karşılaşılmasa da sınıfta "const T &" ve "T &" parametreli iki ayrı kopya yapıcı fonksiyonu da bulunabilir. Örneğin:

	class Sample {
	public:
		//...
		Sample(const Sample &r);
		Sample(Sample &r);
		//...
	};
	//...

	Sample a;
	const Sample b;
	Sample c{a};			// Sample & parametreli kopya yapıcı fonksiyonu çağrılır
	Sample d{b};			// const Smaple & parametreli kopya yapıcı fonksiyonu çağrılır
	
	Eğer biz sınıf için hiç kopya yapıcı fonksiyonu yazmazsak derleyici tarafından yazılan kopya yapıcı fonksiyonu normal olarak "const T &" parametrelidir. 
	Ancak özel bir durum da söz konusudur. Eğer sınıfın başka sınıf türünden veri elemanları varsa (aynı durum sınıfın taban sınıfı için de geçerlidir) ve
	bu elemanlara ilişkin (ya da taban sınıfa ilişkin) sınıfların "const T &" parametreli yapıcı fonksiyonları yoksa bu durumda derleyicinin yazdığı default 
	kopya yapıcı fonksiyonu "T &" parametreli olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi biz sınıfımız için kopya yapıcı fonksiyonunu yazmazsak derleyici bizim için kopya yapıcı fonksiyonunu sınıfın karşılıklı veri 
	elemanlarını kopyalayacak biçimde (ilkdeğer verecek biçimde) kendisi yazmaktadır. Bu tür kopyalamalara C++'ta İngilizce "memberwise copy" denilmektedir. Örneğin:

	class Complex {
	public:
		Complex() = default;
		Complex(double real, double imag = 0);
		void disp() const;
	private:
		double m_real;
		double m_imag;
	};
	//...

	Complex x{3, 2};
	Complex y{x};

	Böyle bir sınıfta kopya yapıcı fonksiyonun yazılmasına hiç gerek yoktur. Zaten biz böyle bir sınıf için kopya yapıcı fonksiyonunu yazacak olsak derleyicinin 
	default olarak yazacağı kopya yapıcı fonksiyonu ile aynı şeyi yaparız. Yani kaynak nesnenin m_real ve m_imag elemanlarını hedef nesnenin karşılıklı olarak 
	m_real ve m_imag elemanına atarız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf için kopya yapıcı fonksiyonu yazılmadığında derleyicinin yazdığı kopya yapıcı fonksiyonu karşılıklı veri elemanlarının atanması işlemini ilkder 
	veriliyormuş gibi yapmaktadır. Başka bir deyişle derleyicinin yazdığı kopya yapıcı fonksiyonu sanki MIL sentaksında kerşılıklı veri elemanları ilkdeğer 
	verilerek kopyalanaıyormuş gibi işlem görmektedir. Örneğin:

	class Complex {
	public:
		Complex() = default;
		Complex(double real, double imag = 0);
		void disp() const;
	private:
		double m_real;
		double m_imag;
	};

	Burada sınıf için kopya yapıcı fonksiyonu yazılmamıştır. Derleycinin yazdığı kopya yapıcı fonksiyon "memberwise copy" işlemini aşağıdaki gibi yapmaktadır:

	Complex::Complex(const Complex &r) : m_real(r.m_real), m_imag(r.m_imag)
	{}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi kopya yapıcı fonksiyonunun yazımı sınıfın bir elemanının gösteri olduğu durumda mı gerekmektedir? Aslında bazı durumlarda veri elemanı bir gösterici 
	olmasa da kopya yapıcı fonksiyonun yazılması gerekebilmektedir. Örneğin UNIX/Linux sistemlerinde bir dosya açıldığında dosyayı betimleyen handle değeri int
	türdendir. Aynı handle değeri aynı dosyayı belirtmektedir. Böylesi bir durumda sınıfın veri elemanı "file descriptor" denilen bu handle değerini tutuyorsa
	bu değerin hedef nesneye aynı gerekçelerle doğrudan atanmaması gerekir. Burada içerik kopyalaması handle değerinin çiftlenmesi yoluyla yapılır. Aşağıda 
	böyle bir temaya örnek verilmiştir. Biz bu örnekte throw deyimi ile exception fırlattık. Exception konusu kursumuzun sonlarına doğru ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>
#include <cstdlib>
#include <fcntl.h>
#include <unistd.h>

using namespace std;

constexpr int BUFFER_SIZE = 4096;

class File {
public:
	File(const char *path);
	File(const File &r);
	~File();
	void  disp() const;
private:
	int m_fd;
};

File::File(const char *path)
{
	if ((m_fd = open(path, O_RDONLY)) == -1)
		return;
}

File::File(const File &r)
{
	if ((m_fd = dup(r.m_fd) )== -1)
		throw runtime_error("file cannot open");
}

File::~File()
{
	close(m_fd);
}

void File::disp() const
{
	char buf[BUFFER_SIZE + 1];
	ssize_t result;

	lseek(m_fd, 0, 0);

	while ((result = read(m_fd, buf, BUFFER_SIZE)) > 0) {
		buf[result] = '\0';
		cout << buf;
	}
	if (result == -1)
		throw runtime_error("cannot read file");

	cout << endl;
}

void foo(File f)
{
	//...
}

int main()
{
	File f("xsample.cpp");

	foo(f);

	f.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													43. Ders 22/01/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de bir fonksiyonun yapı gibi bileşik bir nesneyle geri dönmesi genel olarak iyi teknik kabul edilmemektedir. Örneğin iki karmaşık sayıyı toplayan bir fonksiyon
	şöyle olabilir::

	struct COMPLEX add(const struct COMPLEX *z1, const struct COMPLEX *z2);

	Burada fonksiyonun geri dönüş değerinin bir yapı nesnesi oldupuna dikkat ediniz. O halde bu fonksiyonun return ifadesi de aynı türden bir yapı nesnesi olmalıdır:

	struct COMPLEX add(const struct COMPLEX *z1, const struct COMPLEX *z2)
	{
		struct COMPLEX result;

		result.real = z1->real + z2->real;
		result.imag = z1->imag + z2->imag;

		return result;
	}

	Fonksiyonun şöyle kullanıldığını varsayalım:

	struct COMPLEX z1 = {3, 2};
	struct COMPLEX z2 = {7, 6};
	struct COMPELX z3;

	z3 = add(&z1, &z2);

	Burada hem return ifadesinde hem de atama ifadesinde yapı nesnesi iki kere bütünsel olarak kopyalanmaktadır. Alternatif taarım şöyle olabilirdi:

	void add(const struct COMPLEX *z1, const struct COMPLEX *z2, struct COMPLEX *result)
	{
		result->real = z1->real + z2->real;
		result->imag = z1->imag + z2->imag;
	}

	Bu fonksiyon şöyle kullanılabilir:

	struct COMPLEX z1 = {3, 2};
	struct COMPLEX z2 = {7, 6};
	struct COMPELX z3;

	z3 = add(&z1, &z2, &z3);

	İşte bu nedenle C'de programcılar genellikle fonksiyonun geri dönüş değerini yapı türünden yazpmazlar. 
	
	Ancak C++'ta bir fonksiyonun bir sınıf nesnesiyle geri dönmesi C'deki gibi kötü teknik kabul edilmemektedir. Tabii aslında arka planda sınıf nesneleri 
	C'deki yapı gibi organize edildiğine göre benzer zaman kaybı yine oluşaşaktır. Ancak C++'ın C'den daha yüksek seviyeli olduğunu anımsayınız. Bu nedenle 
	fonksiyonların sınıf nesnelerine geri dönmesi C++'ta C'deki gibi kötü teknik kabul edilmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Matlab gibi, R gibi bazı ortamlar ve dillerin vektörel işlem yapabilme özelliği bulunmaktadır. Vektörel işlem demekle iki dizinin karşılıklı elemanlarının 
	tek hamlede işleme sokulması anlaşılmaktadır. Bu özellik matematiksel uygulamalarda programcının işini çok kolaylaştırmaktadır. Python Programlama Dilinde 
	NumPy isimli üçüncü parti kütüphane de bu amaca hizmet etmektedir. 
		
	Aşağıda kopya yapıcı fonksiyonun gerekliliğine ilişkin diğer bir örnek verilmiştir. Bu örnekte vektörel işlem yapabilmek için VArray isimli bir sınıf 
	bulunmaktadır. Bir VArray nesnesi dinamik olarka tahsis edilen double türden bir dizinin adresini ve uzunluğunu tutmaktadır. Sınııfn içerisindeki add, sub,
	mul, div üye fonksiyonları iki VArray nesnesinin karşılıklı elemanlarını işleme sokup yeni bir VArray nesnesine geri dönmektedir. Bu fonksiyonların geri 
	dönüş değerleri oluşturulurken geçici nene için kopya yapıcı fonksiyonun çağrılacağına dikkat ediniz. Sınıftaki kopya yapıcı fonksiyonu "içerik kopyalaması"
	yapacak biçimde yazılmıştır. Örneğimizde kullanımı kolaylaştırmak için sınıfta "initializer_list" parametreli bir yapıcı fonksiyon bulundurkduk. Bu yapıcı 
	fonksiyon sayesinde küme parantezleriyle nesnemize ilkdeğer verilemesini sağladık. Örneğin:

	VArray x = {1, 2, 3, 4, 5};

	Bu konu ileride ayrı bir başlık altında ele alınacaktır. İki vektörün bu biçimde işleme sokulması için vektörlerin eşit uzunlukta olması gerektiğine 
	dikkat ediniz. Biz de örneğimizde henüz görmemiş olsak da başlangıçta bu kontrolü yaptık. Eğer üişleme soktuğumuz nesnelere ilişkin diziler eşit uzunlukta 
	değilse exception fırlattık. Exception konusunu da henüz görmedik. İleride bu konu da ayrı bir bölümde ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// varray.hpp

#ifndef VARRAY_HPP_
#define VARRAY_HPP_

#include <cstddef>
#include <initializer_list>

class VArray {
public:
	VArray() = default;
	VArray(size_t size);
	VArray(const double *v, size_t size);
	VArray(std::initializer_list<double> il);
	VArray(const VArray &va);
	~VArray();

	VArray add(const VArray &va) const;
	VArray add(double d) const;
	VArray sub(const VArray &va) const;
	VArray sub(double d) const;
	VArray mul(const VArray &va) const;
	VArray mul(double d) const;
	VArray div(const VArray &va) const;
	VArray div(double d) const;
	VArray pow(double d) const;

	double sum() const;
	double mean() const;

	size_t size() const { return m_size; }

	void disp() const;
private:
	double *m_v;
	size_t m_size;
};

#endif

// varray.cpp

#include <iostream>
#include <stdexcept>
#include <cstring>
#include <cmath>
#include "varray.hpp"

using namespace std;

VArray::VArray(size_t size)
{
	m_v = new double[size];
	m_size = size;
}

VArray::VArray(const double *v, size_t size) : VArray(size)
{
	::memcpy(m_v, v, sizeof(double) * size);
}

VArray::~VArray()
{
	delete[] m_v;
}

VArray::VArray(initializer_list<double> il)
{
	m_v = new double[il.size()];
	m_size = il.size();

	for (size_t i = 0; auto val : il)
		m_v[i++] = val;
}

VArray::VArray(const VArray &va)
{
	m_v = new double[va.m_size];
	m_size = va.m_size;

	::memcpy(m_v, va.m_v, sizeof(double) * m_size);
}

VArray VArray::add(const VArray &va) const
{
	if (m_size != va.m_size)
		throw invalid_argument("Varrays must be the same size");

	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] + va.m_v[i];

	return result;
}

VArray VArray::add(double d) const
{
	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] + d;

	return result;
}
VArray VArray::sub(const VArray &va) const
{
	if (m_size != va.m_size)
		throw invalid_argument("Varrays must be the same size");

	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] - va.m_v[i];

	return result;
}

VArray VArray::sub(double d) const
{
	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] - d;

	return result;
}

VArray VArray::mul(const VArray &va) const
{
	if (m_size != va.m_size)
		throw invalid_argument("Varrays must be the same size");

	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] * va.m_v[i];

	return result;
}

VArray VArray::mul(double d) const
{
	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] * d;

	return result;
}

VArray VArray::div(const VArray &va) const
{
	if (m_size != va.m_size)
		throw invalid_argument("Varrays must be the same size");

	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] / va.m_v[i];

	return result;
}

VArray VArray::div(double d) const
{
	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = m_v[i] / d;

	return result;
}

VArray VArray::pow(double d) const
{
	VArray result(m_size);

	for (size_t i = 0; i < m_size; ++i)
		result.m_v[i] = ::pow(m_v[i], d);

	return result;
}


double VArray::sum() const
{
	double total = 0;

	for (size_t i = 0; i < m_size; ++i)
		total += m_v[i];

	return total;
}

double VArray::mean() const
{
	return sum() / m_size;
}

void VArray::disp() const
{
	cout << '[';
	for (size_t i = 0; i < m_size; ++i)
		cout << m_v[i] << " ";
	cout << ']' << endl;
}

// app.cpp

#include <iostream>
#include "varray.hpp"

using namespace std;

int main()
{
	VArray x = {1, 2, 3, 4, 5};
	VArray y = {4, 5, 8, 9, 1};
	
	x.disp();
	y.disp();

	VArray result = x.mul(10).add(y);		// x * 10 + y

	result.disp();

	cout << "sum: " << x.sum() << endl;
	cout << "mean: " << x.mean() << endl;

	double std = sqrt(x.sub(x.mean()).pow(2).sum() / x.size() - 1);
	cout << "standard deviation: " << std << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Derleyici tarafından yaratılan ve yine derleyici tarafından yok edilen isimsiz nesnelere "geçici nesneler (temporary objects)" denilmektedir. Geçici nesneler
	çeşitli durumlarda oluşturulabilmektedir. Örneğin tür dönüştürmeleri, return işlemi geçici nesneler yoluyla yapılmaktadır. İşte sınıflar türünden de geçici 
	nesneler oluşturulabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta T bir tür ismi (genellikle sınıf) olmak üzere T([argüman_listesi]) biçminde ya da T{[argüman listesi]} biçiminde bir ifade "T türünden geçici nesne 
	yarat" anlamına gelmektedir. Bu biçimde geçici nesne yaratıldığında derleyici eğer yaratılan bir sınıf nesnesi ise bu nesne için argüman listesine uygun yapıcı 
	fonksiyonunu çağırır. Sonra bu geçici nesne bu geçici nesnenin yaratıldığı ifade bittiğinde yıkıcı fonksiyon çağrılarak geçici nesne yok edilir. Yani bu biçimde
	yaratılmış olan geçici nesnelerin ömürleri o nesnenin yaratıldığı ifade kadardır. O nesnenin yaratıldığı ifadenin bitiminde nesne için yıkıcı fonksiyon çağrılarak 
	nesne yok edilmektedir. Eğer bir ifadede birden fazla geçici sınıf nesnesi yaratılmışsa onların yıkıcı fonksiyonları yapıcı fonksiyonlarına göre ters sırada 
	çağrılmaktadır. Örneğin:

	void foo(Point pt)
	{
		//...
	}
	//...

	foo(Point{3, 2});

	Burada Point sınıfı türünden geçici bir nesne yaratılmış ve bu geçici nesne foo fonksiyonunun pt parametresine ilkdeğer olarak verilmiştir. Bu durumda 
	pt için kopya yapıcı fonksiyonunun çağrılacağına dikkat ediniz. (C++17 ile birlikte burada "copy elision" uygulaması artık zorunlu hale getirilmiştir. İzleyen
	paragraflarda bu konu ele alınacaktır.) Burada yaratılmış olan geçici Point nesnesi tüm ifade bittiğinde (yani fonksiyonun çağrısı bittiğinde) yok edilecektir. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Point {
public:
	constexpr Point(int x, int y) : m_x(x), m_y(y)
	{}
	constexpr int x() { return m_x; }
	constexpr int y() { return m_y; }
	void disp() const;
private:
	int m_x;
	int m_y;
};

void Point::disp() const
{
	cout << '(' << m_x << ',' << m_y << ')' << endl;
}

void foo(Point pt)
{
	pt.disp();
}

int main()
{
	Point pt{10, 2};

	foo(Point(10, 2));		// geçici nesne yaratılıyor
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												44. Ders 24/01/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte geçici biçimde yaratılan sınıf nesneleri için yapıcı ve yıkıcı fonksiyonların ne zaman çağrıldığı gözlemlenebilir. Bu örneği çalıştırdığınızda
	ekranda şunları göreceksiniz:

	one
	constructor: 10
	disp: 10
	destructor: 20
	two
	
	Geçici sınıf nesnesi için yıkıcı fonksiyonun onun yaratıldığı ifadenin sonunda çağrıldığında dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "constructor: " << m_a <<  endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}

	void disp() const
	{
		cout << "disp: " << m_a << endl;
	}

	int m_a;
};

void foo(Sample s)
{
	s.disp();

	s.m_a = 20;
}

int main()
{
	cout << "one" << endl;

	foo(Sample(10));

	cout << "two" << endl;
	
	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı ifade içerisinde birden fazla geçici sınıf nesnesi yaratıldığında onların yapıcı ve yıkıcı fonksiyonlarının ters sırada çağrılacağını anımsayınız. 
	Aşağıda bu duruma bir örnek verilmiştir. Bu örneği çalıştırdığınızda ekranda şunları göeceksiniz:

	one
	constructor: 10
	constructor: 20
	s: 20
	destructor: 30
	destructor: 10
	two

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "constructor: " << m_a <<  endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}

	void disp() const
	{
		cout << "disp: " << m_a << endl;
	}

	void foo(Sample s)
	{
		cout << "s: " << s.m_a << endl;

		s.m_a = 30;
	}

	int m_a;
};

int main()
{
	cout << "one" << endl;

	Sample(10).foo(Sample(20));

	cout << "two" << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir sınıf belirtmek üzere T(...) biçiminde yaratılan geçici nesneler sağ taraf değeri (prvalue) belirtmektedir. Dolayısıyla biz onu ancak const bir sol 
	taraf değeri referansına ya da bir sağ taraf değeri referansına bind edebiliriz. Örneğin:
		
	Sample &r = Sample(10);				// error! geçici nesne prvalue fakat referans const değil!
	const Sample &k = Sample(10);		// geçerli, geçici nesne prvalue ve referans const
	Sample &&m = Sample(10);			// geçerli, geçici nesne prvalue ancak referns rvalue referans

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda const bir sol taraf değeri referansaına bind edilen bir geçici nesne için yıkıcı fonksiyonunun bu referansın ömrü bittiğinde (yani referans bellekten 
	yok edileceği) çağrılacağını gösteren bir örnek verilmiştir. Bu örnekte ekranda şunları göreceksiniz:

	one
	constructor: 10
	two
	destructor: 10
	three
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "constructor: " << m_a <<  endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_a << endl;
	}
	
	int m_a;
};

int main()
{
	cout << "one" << endl;

	{
		const Sample &r = Sample(10);

		cout << "two" << endl;
	}

	cout << "three" << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'a çeşili öğeler eklendikçe standratlarda daha önce olmayan terimler uydurulmuştur. Örneğin C++17 ile birlikte "temporary materialization conversion"
	denilen bir terim uydurulmuştur. Bu terim "bir sağ taraf değerinden hareketle bir geçici nesnenin oluşturulmasını" belirtmektedir. Örneğin C++17 ve sonrasında
	bir geçici nesne const bir referansa ya da bir sağ taraf değeri referansına bind edildiğinde "temporary materialization conversion" oluşmaktadır. Yani 
	bu geçici nesne artık bir sağ taraf değeri olmaktan çıkıp bir nesne haline gelmektedir. Bu standartlarda "temporary materialization conversion" işlemi 
	sonucunda elde edilen nesnenin bir "xvalue" olduğu belirtilmektedir. Anımsanacağı gibi C++11 ve sonrasında "xvalue" hayatını kaybetmek üzere olan nesneleri 
	belirtmekteydi. "xvalue" duruma göre hem bir sol taraf değeri gibi hem de bir sağ taraf değeri gibi ele alınmaktaydı.

	Pekiyi C++17'de neden "temporary materialization conversion" terimi uydurulmuştur? İşte C++17 ile birlikte izleyen paragraflarda ele alacak olduğmuz eskiden 
	zorunlu olmayan bazı "copy elision" durumları zorunlu (mandatory) hale getirilmiştir. Dolayısıyla artık C++17 ile birlikte geçici nesne oluşturan ifadeler
	aslında gerçek anlamda geçici nesne oluşturmamaktadır. C++17 ile birlikte bu geçici nesne oluşturan ifadelerin gerçekten geçici nesne oluşturması durumu
	"temporary materialization conversion" terimi ile açıklanmıştır. Buna ilişkin daha sonra anlamlandırabileceğiniz bir örnek verelim:

	Sample s = Sample();			// C++17 ve sonrasında "temporary materialization conversion" uygulanmıyor
	const Sample &r = Sample();		// "temporary materialization conversion" uygulanıyor

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir sınıf belirtmek üzere T(...) ifadesi bir prvalue olduğuna göre onun adresini alamayız. Örneğin:

	void foo(const Sample *ps)
	{
		//...
	}
	//...

	foo(&Sample());			// geçersiz!
	
	Ancak yukarıda da belirttiğimiz gibi aynı işlem referans yoluyla yapılabilmektedir. Örneğin:

	
	void foo(const Sample &r)
	{
		//...
	}
	//...

	foo(Sample());			// geçerli

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıflar türünden geçici nesnelerin T(...) sentaksıyla yaratılması bazı işlemleri programcı açısından kolaylaştırmaktadır. Örneğin nokta kavramo Point sınıfıyla
	temsil edilmiş olsun. İki nokta arasında doğru çizen aşağıdaki gibi bir draw_line fonksiyonunun bulunduğunu düşünelim:

	void draw_line(const Point &pt1, const Point &pt2);

	Eğer geçici sınıf nesnesi yaratma diye bir şey olmasaydı biz fonksiyonu şöyle çağırmak zorunda kalırdık:

	Point pt1{100, 100}, pt2{200, 200};

	drawline(pt1, pt2);

	Halbuki geçici nesne yaratabilme özelliğini kullanarak fonksiyonu daha pratik bir biçimde şöyle çağırabilmekteyiz:

	drawline(Point{100, 100}, Point{200, 200});
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında "fonksiyonel tarzda tür dönüştürmesi" ile sınıflar türünden geçici nesne yaratılması benzer sentaksla yapılmaktadır. Örneğin Point(10, 20) gibi bir 
	ifadeyle Point sınıfı türünden bir geçici nesne yaratıldığı gibi int(10) gibi bir ifadeyle ibt türünden de geçici bir nesne yaratılabilmektedir. Hatta C++'ta 
	temel türler söz konusu olduğunda parantezin içi de boş bırakılabilmektedir. Dolayısıyla int() gibi bir ifade içi 0 olan geçici bir int nesnenin yaratılacağı
	anlamına gelmektedir. Bu sayede şablon (template) işlemlerinde temel türleri de kapsayabilecek bir genellik sağlanabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													45. Ders 29/01/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bazı durumlarda kopya yapıcı fonksiyonun (copy conctructor) derleyici tarafından çağrılması elimine edilebilmektedir. Yani bu durumlarda derleyici 
	kopya yapıcı fonksiyonları çağırmayabilmektedir. Bu duruma "kopya yapıcı fonksiyonun çağrılmasının elimine edilmesi (copy elision)" denilmektedir.(Bu terimin 
	İngilizce karşılığı "copy elision" biçimindedir. Buradaki "elision" sözcüğü "çıkarmak, atmak, atlamak" gibi anlamlara gelmektedir. Biz kursumuzda bu durumu 
	Türkçe "kopya yapıcı fonksiyonun çağrılmasının elimine edilmesi" ya da doğrudan İngilizce "copy elision" biçiminde belirteceğiz.)

	C++17'ye kadar kopya yapıcı fonksiyonun çağrılmasının elimine edilmesi "iste bağlı (optional)" durumdaydı. Yani derleyici bu eleminasyonu isteğe bağlı olarak 
	yapabilir ya da yapmayabilirdi. Ancak C++17 ile birlikte bazı durumlardaki eleminasyon artık "zorunlu (mandatory)" hale getirilmiştir. Biz burada C++17 ve 
	sonrasındaki nihai durumdan bahsedeceğiz. 

	C++17 ile birlikte bir sınıf türünden nesne aynı sınıf türünden "saf sağ taraf değerine (prvalue)" ilişkin bir nesne ile ilkdeğer verilerek yaratıldığında 
	(yani tipik olarak bir geçici nesne ile ilkdeğer verilerek yaratıldığında) yeni yaratılan nesne için kopya yapıcı fonksiyonu elimine edilmektedir. Bu durumda 
	doğrudan yeni nesneye saf sağ taraf değeri için çağrılacak yapıcı fonksiyonla ilkdeğer verilmektedir. Bu durumu özetle şöyle ifade edebiliriz: Biz bir sınıf 
	türünden nesneyi aynı sınıf türünden geçici bir nesne ile ilkdeğer vererek tanımladığımızda aslında o nesneyi sanki geçici nesnedeki yapıcı fonksiyon çağrılacak
	biçimde tanımlamış oluruz. Örneğin:

	Sample s = Sample(a, b, c);

	Burada normalde ilk bakıldığında önce geçici nesnenin uygun yapıcı fonksiyon ile yaratılacağıve sonra da bunun kopya yapıcı fonksiyonu ile s'e kopyalanacağı 
	sanılmaktadır. Halbuki C++17 ve sonrasında artık bu geçici nesne hiç yaratılmamakta ve kopya yapıcı fonksiyonu da hiç çağrılmamaktadır. Doğrudan s nesnesi sanki
	geçici nesnenin yaratımında belirtilen yapıcı fonksiyon ile tanımlanmış gibi bir etki oluşmaktadır. Yani C++17 ve sonrasında yukarıdaki ilkdeğer verme tamamen
	aşağıdakiyle eşdeğer biçimdedir:

	Sample s(a, b, c);

	Tabii buradaki ilkdeğer vermenin '=' ile yapılması (copy initialiation) gerekmemektedir. Aşağıdaki tanımalama da (direct initialization) tamamen yukarıdakilerle 
	eşdeğerdir:

	Sample s{Sample(a, b, c)};

	İşte C++17 öncesinde böyle bir eliminasyonun yapılıp yapılmayacağı derleyicilerin isteğine bırakılmıştır. Halbuki C++17 ile birlikte artık zorunla hale 
	getirilmiştir. 

	Tabii bir geçici sınıf nesnesinin başka bir geçici sınıf nesnesi ile ilkdeğer verilerek yaratıldığı durumda da bu eliminasyonlar yapılmaktadır. Örneğin:
	
	Sample s(Sample(Sample(Sample(a, b, c))));

	Burada tüm geçici nesnelerin yaratılması ve kopya yapıcı fonksiyonların çalıştırılması elimine edilecektir. Yani bu işlem yine aşağıdakine eşdeğerdir:

	Sample s(a, b, c);

	Fonksiyonun geri dönüş değeri bir sınıf türündense ve return ifadesinde aynı sınıf türünden saf sağ taraf değeri (prvalue) varsa (yani tipik olarak aynı türnden 
	geçici bir sınıf nesnesi ile return işlemi yapılıyorsa) bu durumda geri dönüş değeri için oluşturulacak nesne için yine kopya yapıcı fonksiyonu elimine 
	edilecektir. Örneğin:

	Sample foo()
	{
		//...

		return Sample(a, b, c);
	}

	Burada bu fonksiyon çağrıldığında akış return deyimine geldiği zaman önce geçici nesne oluşturulup sonra kopya yapıcı fonksiyonu ile geri dönüş değeri 
	için oluşturulan geçici nesneye kopyalama yapılmayacaktır. Zaten geri dönüş değeri için yaratılacak nesne doğrudan return deyiminde belirtilen yapıcı 
	fonksiyon ile ilkdeğer alacaktır. Tabii fonksiyonların geri dönüş değerleri referans değilse çağrı ifadesinin de saf sağ taraf değeir (prvalue) belirtitğini
	anımsayınız. Bu biçimde kopya yapıcı fonksiyonun elimine edilmesine C++ programcıları arasında "Unnamed Return Value Optimzation (URVO)" da denilmektedir. 
	Bu durumda örneğin:

	Sample s(foo());

	Böyle bir tanımlama aşağıdakiyle eşdeğer hale gelecektir:

	Sample s(a, b, c);

	Fonksiyonun parametre değişkeni bir sanıf türündense biz de fonksiyonu aynı sınıf türünden bir geçici nesne ile çağırırsak yine "zorunlu eliminasyon (mandatory
	copy elision)" yapılmaktadır. Örneğin:

	void foo(Sample s)
	{
		cout << s.a() << endl;
	}
	//...

	foo(Sample(100));

	Burada önce geçici nesne yaratılıp kopya yapıcı fonksiyonu ile parametre değişkenine aktarım yapılmayacaktır. Doğrudan parametre değişkeni geçici nesnenin 
	yaratılmasında belirtilen yapıcı fonksiyon ile ilkdeğer alacaktır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "int constructor" << endl;
	}

	Sample(const Sample &r) : m_a(r.m_a)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}

	int a() const { return m_a; }


private:
	int m_a;
};

Sample foo()
{
	cout << "foo" << endl;

	return Sample(10);
}

int main()
{
	Sample s = Sample(foo());		// Sample s(10);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca tüm C++ verisyonları dahil olmak üzere birkaç durumda da "isteğe bağlı (optional)" biçimde bir "copy elision" yapılabilmektedir. Bunlardan en önemli 
	olanı "NRVO (Named Return Value Optimization)" denilen durumdur. Bir fonksiyonun geri dönüş değeri bir sınıf türündense ve fonksiyonun return ifadesi o sınıf 
	türünden yerel bir sınıf nesnesinin isminden oluşuyorsa bu durumda derleyici bu yerel sınıf nesnesi için yapıcı fonksiyonu çağırıp, geri dönüş değeri için 
	kopya yapıcı fonksiyonu çağırmak yerine doğrudan bu yerel nesneyi zaten geri dönüş değeri ile aktarılacak geçici nesne biçiminde oluşturabilir. Dolayısıyla 
	return işlemi sırasında kopya yapıcı fonksiyonu elimine edilebilir. Örneğin:

	Sample foo()
	{
		//...
		
		Sample s(a, b, c);
		
		//...

		return s;
	}

	Burada aslında s nesnesi zaten geri dönüş değeri için yaratılacak nesne biçiminde oluşturulabilmektedir. Yani burada derleyici isterse geri dönüş değerine 
	ilişkin nesneyi	s gibi yaratabilir. Böylece kopya yapıcı fonksiyonu hiç çağrılmaz. Başka bir deyişle aslında fonksiyonun s yerel değişkeni zaten fonksiyonun 
	geri dönüş değeri için oluşturulan nesnedir. Böylece burada aslında kopya yapıcı fonksiyonu yine hiç çağrılmayabilir. Bu eliminasyonun C++17 sonrasında da
	"isteğe bağlı (optional)" olduğuna dikkat ediniz. 

	Eğer return ifadesindeki isim parametre değişkenine ilişkinse böyle bir optimizasyon yapılmamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "int constructor" << endl;
	}

	Sample(const Sample &r) : m_a(r.m_a)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}

	int a() const { return m_a; }


private:
	int m_a;
};

Sample foo()
{
	Sample s(10);

	cout << "foo" << endl;

	return s;			// burada geri dönüş değeri için kopya yapıcı fonksiyonun çağrılıp çağrılmayacağı derleyicileri yazanların isteğine bırakılmıştır
}

int main()
{
	Sample s{foo()};		
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önceden de belirttiğimiz gibi C++'ın yeni standartlarında yeni özellekler eklendikçe tutarlı bir anlatım oluşturabilmek için bazı terimler de uydurulmaktadır. 
	Örneğin kopya yapıcı fonksiyonun zorunlu elimine edilmesi (mandatory copy elision) C++17 ile dile eklenince standratlara "yemporary materialization" denilen 
	bir terim de sokulmuştur. Bu teriminin sokulmasının nedeni artık C++17 ve sonrasında geçici nesne yaratır gibi yaptığımızda aslında bir nesne yaratılmayabilceği 
	içindir. Örneğin:

	Sample s = Sample(x, y, z);

	Burada aslında C++17 ve sonrasında geçici nesne hiç yaratılmamaktadır. İşte bu durum standartlarda bu geçici nesnenin "materialize" olmaması biçiminde 
	ifade edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf başka bir sınıf türünden veri elemanlarına sahip olabilir. Örneğin Student sınıfı öğrencilerin bilgilerini tutup onlar üzerinde işlem yapan bir 
	sınıf olsun. Öğrencinin ismi String sınıfı türünden bir nesne ile tutulabilir. Öğrencinin doğum tarihi Date isimli bir sınıf nenesi yoluyla tutulabilir:

	class Student {
	public:
		//...
	private:
		int m_no;
		String m_name;
		Date m_bdate;
	};

	Pekiyi böylesi bir durumda elemanlar için yapıcı fonksiyonlar nerede ve nasıl çağrılmaktadır?
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Elemana sahip sınıf türünden bir nesne yaratıldığında eleman olan sınıf nesneleri o sınıfların kendi yapıcı fonksiyonları ile ilkdeğerlerini alır. Yani C++'ta
	elemana sahip sınıfın yapıcı fonksiyonları elemana ilişkin sınıfların yapıcı fonksiyonlarını çağırarak elemanlara ilkdeğerlerini vermektedir. Pekiyi elemana 
	sahip sınıfın yapıcı fonksiyonları elemana ilişkin sınıfın hangi yapıcı fonksiyonlarını ne zaman çağırmaktadır. İşte elemana sahip sınıfın yapıcı fonksiyonun 
	elemana ilişkin sınıfın hangi yapıcı fonksiyonunu çağıracağı MIL sentaksında belirlenmektedir. MIL sentaksında elemanın ismi ve parantezlerle argüman listesi 
	belirtilirse o elemanlar için ilgili sınıfların uygun uapıcı fonksiyonları çağrılmaktadır. Yani elemanlar çağrılacak yapıcı fonksiyonları aşağıdaki gibi 
	MIL sentaksında belirtebiliriz:

	T::T(...) : eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), ...
	{
		//...
	}

	Burada elemanlar için argüman listesine uygun yapıcı fonksiyonlar çağrılmaktadır. Daha önceden de belirttiğimiz gibi buradaki argüman listesinde global 
	değişkenler, elemana sahip sınıfın yapıcı fonksiyonlarının parametreleri kullanılabilir. Yani buradaki argümanlar sanki ğye fonksiyonun içeriisnde yazılmış
	gibi isim araması uygulanmaktadır. Örneğin:

	class Student {
	public:
		Student(const char *name, int day, int month, int year);
		//...
	private:
		String m_name;
		Date m_bdate;
	};

	Student::Student(const char *name, int day, int month, int year) : m_name(name), m_bdate(day, month, year)
	{
		//...
	}
	//...

	Student s("Ali Ay", 12, 11, 2002);

	Burada s nesnesi için Student sınıfının dört parametreli yapıcı fonksiyonu çağrılacaktır. MIL sentaksında m_name ve m_bdate elemanları için hafni yapıcı 
	fonksiyonların çağrılacağı belitilmiştir. 
	
	Eğer sınıfın başka sınıf türünden veri elemanı MIL sentaksında belirtilmezse o veri elemanı için "default yapıcı fonksiyon" çağrılmaktadır. Tabii elemana
	ilişkin sınıfın default yapıcı fonksiyonu yoksa ya da erişilemez biçimdeyse bu durum derleme aşamasında error oluşturacaktır.

	C++'ta her zaman elemana ilişkin sınıfların yapıcı fonksiyonları elemana sahip sınıfların yapıcı fonksiyonlarından daha önce çalıştırılır.Yani önce elemanlar 
	için yapıcı fonksiyonlar çağrılır, sonra programın akışı elemana sahip sınıfın ana bloğundan içeri girer. Derleyiciler genellikle elemana ilişkin sınıf 
	nesneleri için onların yapıcı fonksiyonlarını elemana sahip sınıfın yapıcı fonksiyonlarının ana bloğunun başına yerleştirdikleri gizli bir çağırma kodu 
	yoluyla çağırmaktadır.

	Daha önceden de belirttiğimiz gibi MIL sentaksındaki sıranın hiçbir önemi yoktur. Her zaman sınıf bildirimindeki sıra dikkate alınmaktadır. Elemanlar için 
	yapıcı fonksiyonlar her zaman bildirimdeki sıraya göre (yukarıdan aşağıya, soldan sağa) çağrılmaktadır. Örneğin:

	Student::Student(const char *name, int day, int month, int year) : m_bdate(day, month, year), m_name(name)
	{
		//...
	}
	
	Burada MIL sentaksında önce m_bdate elemanı sonra m_name elemanı belirtilmiştir. Ancak önce m_name elemanı için sonra m_bdate elemanı için yapıcı fonksiyonlar
	çalıştırılacaktır. Çünkü sınıf bildiriminde önce m_name sonra m_bdate bildirilmiştir. MIL sentaksında eleman ismi hiç belirtilmemiş olsa bile belirtilmeyen 
	elemanlar için default yapı fonksiyonlar yine bildirimdeki sıraya göre çağrılmaktadır. Örneğin:

	Student::Student(const char *name, int day, int month, int year) : m_bdate(day, month, year)
	{
		//...
	}

	Burada m_name elemanı MIL sentaksında belirtilmemiştir. Ancak yine önce m_name için String sınıfının default yapıcı fonksiyonu çağrılır, sonra m_bdate için 
	Date sınıfının yapıcı fonksiyonu çağrılır. 

	Sınıfın temel türlere ilişkin veri elemanlarının bulunduğu durumda biz MIL sentaksında ya da yapıcı fonksiyonun ana bloğunda bunlara değer atamamışsak 
	bunların içerisnde çöğ değerlerin bulunacağını anımsayınız. Tabii temel türler için MIL sentaksında ilkdeğer verilirse bunlar da bildirimdeki sıraya göre
	işlem görecektir. Örneğin:

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		//...
	private:
		int m_no;
		String m_name;
		Date m_bdate;
	};
	//...

	Student::Student(const char *name, int day, int month, int year, int no) : m_bdate(day, month, year), m_name(name), m_no(no)
	{
		//...
	}

	Burada önce m_no veri elemanına değer atanacak, sonra m_name için yapıcı fonksiyon çağrılacak, sonra da m_bdate için yapıcı fonksiyon çağrılacaktır. Bu çağrılardan sonra
	akış Student sınıfının yapıcı fonksiyonunun içine girecektir. 

	Sınıfın başka sınıf türünden veri elemanlarının bulunduğu durumda bu veri elemanlarına eleman sahip sınıfın yapıcı fonksiyonu içerisinde '=' operatörü ile değer atamaya
	çalışmak kötü bir tekniktir. (Tabii zaten bir sınıf nesnesine atama yapabilmek için sınıfın "atama operatör fonksiyonu" denilen bir üye fonksiyonunun bulunuyor olması 
	gerekmektedir. Bu konu ileride ele alınacaktır.) Çünkü biz ilgili veri elemanını MIL sentaksında belirtmediğimiz zaman zaten onun için önce default yapıcı fonksiyon 
	çağrılmaktadır. Ona elemana sahip sınıfın yapıcı fonksiyonu içerisinde değer atamak ikinci bir işlem gerektirmektedir. O halde şunları söyleyebiliriz: Elemana sahip sınıfın 
	yapıcı fonksiyonunda elemanlar için her zaman (eğer default yapıcı fonksiyonun çağrılmasını istemiyorsak) MIL sentaksıyla o elemanlar için ilkdeğer vermemiz gerekir. 

	Sınıfın temel türlere ilişkin (int, long double gibi) veri elemanları da MIL sentaksında belirtilebilir.

	Sınıfın temel türlere ilişkin veri elemanları söz konusu olduğunda o elemanlara MIL sentaksıyla değer atamak ile elemana sahip sınıfın yapıcı fonksiyonun 
	içerisinde değer atamak arasında hiçbir etkinlik farkı yoktur.

	Standartlar MIL sentaksında belirtilmeyen veri elemanları için "default-initialize" işleminin yapılacağını söylemektedir (11.9.3-9). Anımsanacağı default-initialize
	sınıf nesneleri için onların default yapıcı fonksiyonlarının çağrılması, temel türler için hiçbir initialize işleminin yapılmaması anlamına geliyordu.

	Örneğin:

	#include "string.hpp"
	#include "date.hpp"

	using namespace std;
	using namespace CSD;

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		void disp() const;
	private:
		String m_name;
		Date m_bdate;
		int m_no;
	};

	Student::Student(const char *name, int day, int month, int year, int no) 
		: m_name(name), m_bdate(day, month, year), m_no(no)
	{
	}

	void Student::disp() const
	{
		m_name.disp();
		m_bdate.disp();
	}

	int main()
	{
		Student s("Ahmet Ak", 7, 11, 1999, 123);

		s.disp();

		return 0;
	}
	
	Burada daha önce yazmış olduğumuz String ve Date sınıflarını Student sınıfının veri elemanları için kullandık. Bir Student nesnesi yaratıldığında önce 
	m_name için, sonra m_date için MIL sentaksında belirtilen yapıcı fonksiyonları çağrılacaktır. m_no veri elemanına MIL sentaksında belirtilen değer atanacaktır.
	
	Aşağıdaki örnekte Sample sınıfının Mample sınıfı tründen bir veri elemanıo vardır. Örneği çalıştırarak ekrana çıkan yazıları anlamdırınız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Mample {
public:
	Mample(int a);
	void disp() const;
private:
	int m_a;
};

class Sample {
public:
	Sample(int a, int b);
	void disp() const;

private:
	Mample m_m;
	int m_b;
};

Mample::Mample(int a) : m_a(a)
{
	cout << "Mample(int) constructor" << endl;
}

void Mample::disp() const
{
	cout << m_a << endl;
}

Sample::Sample(int a, int b) : m_m(a), m_b(b)
{
	cout << "Sample(int, int) constructor" << endl;
}

void Sample::disp() const
{
	m_m.disp();
	cout << m_b << endl;
}

int main()
{
	Sample s(10, 20);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													46. Ders 31/01/2024 - Çarşamba 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf için kopya yapıcı fonksiyonu yazmadığımızda derleyicinin yazdığı kopya yapıcı fonksiyonun "memberwise copy" yaptığını belirtmiştik. Aynı zamanda 
	bu "memberwise copy" işleminin ilkdeğer verme gibi MIL sentaksı yoluyla yapıldığını belirtmiştir. Bu durumda elemana sahip sınıf için kopya yapıcı fonksiyonu 
	yazılmamışsa aslında derleyicinin yazdığı kopya yapıcı fonksiyon sınıfın başka sınıf türünden veri elemanlarını kendi sınıflarının kopya yapıcı fonksiyonu 
	yoluyla kopyalayacaktır. Örneğin:

	#include "string.hpp"
	#include "date.hpp"

	using namespace std;
	using namespace CSD;

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		void disp() const;
	private:
		String m_name;
		Date m_bdate;
		int m_no;
	};

	Student::Student(const char *name, int day, int month, int year, int no) 
		: m_name(name), m_bdate(day, month, year), m_no(no)
	{
	
	}

	void Student::disp() const
	{
		m_name.disp();
		m_bdate.disp();
	}

	void foo(Student s)
	{
		s.disp();
	}
	//...

	int main()
	{
		Student s("Ahmet Ak", 7, 11, 1999, 123);

		foo(s);

		return 0;
	}

	Burada main fonksiyonundaki yerel s nesnesi foo fonksiyonun parametre değişkenine atanırken Student sınıfının kopya yapıcı fonksiyonu çalıştırıkacaktır. 
	Örneğimizde Student sınıfı için kopya yapıcı fonksiyonu yazılmamıştır. Derleyicinin yazdığı kopya yapıcı fonksiyonu nesnelerin m_name ve m_bdate veri elemanlarını
	kendi sınıflarının kopya yapıcı fonksiyonları yoluyla kopyalayacaktır. Dolayısıyla biz String sınıfı için kopya yapıcı fonksiyonu yazdığımızdan dolayı burada
	bir sorun oluşmayacaktır.Yani buradaki Student sınıfı için bizim kopya yapıcı fonksiyonunu yazmamıza gerek yoktur. Çünkü derleyicinin yazdığı kopya yapıcı 
	fonksiyonu zaten bizim işimizi görektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın başka sınıf türünden veri elemanlarının olduğu durumda sınıf için kopya yapıcı fonksiyon yazılırken veri elemanları için kopya yapıcı fonksiyonların 
	çağrılmasını sağlamak programcının sorumluluğundadır. C++'a yeni başlayanlar sezgisel olarak kopya yapıcı fonksiyonun MIL sentaksında belirtilmeyen veri elemanları 
	için o sınıfların kopya yapıcı fonksiyonlarının çağrılması gerektiğini düşünmektedir. Halbuki kopya yapıcı fonksiyonlarında da veri elemanları için MIL sentaksında
	belirleme yapılmamışsa diğer yapıcı fonksiyonlarda olduğu gibi veri elemanları için kendi sınıflarının default yapıcı fonksiyonları çeğrılmaktadır. Örneğin 
	yukarıda belirttiğimiz Student sınıfı için kopya yapıcı fonksiyonunu aşağıdaki gibi yazmış olalım:

	Student::Student(const Student &r)
	{
		//...
	}

	Burada MIL sentaksında bir belirleme yapılmadığı için sınıfın m_name ve m_bdate veri elemanalrı için default yapıcı fonksiyon çağrılacaktır. Tabii bu da 
	programcının istediği bir şey değildir. Bu sınıf için kopya yapıcı fonksiyonun şöyle yazılması gerekirdi:

	Student::Student(const Student &r) : m_name(r.m_name), m_bdate(r.m_bdate), m_no(r.m_no)
	{
		//...
	}

	Derleyicinin kendisini yazdığı kopya yapıcı fonksiyonun zaten bu biçimde bir MIL sentaksı kullandığına dikkat ediniz. Student sınıfı için aşağıdaki gibi 
	kopya yapıcı fonksiyon yazılmamlıdır:

	Student::Student(const Student &r) 
	{
		m_name = r.m_name;
		m_bdate = r.m_bdate;
		m_no = r.m_no;
	}

	Daha önceden de belirttiğimiz gibi bu durumda önce veri elemanları için default yapıcı fonksiyon çağrılıp sonra atama yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önceden C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonların ters sırada çalıştırıldığını söylemiştik. İşte sınıfın başka sınıf türünden veri 
	elemanlarına sahip olduğu durumda da bu ters sırada çağrılma kuralı geçerlidir. Yani elemana sahip sınıf türünden bir nesne yok edilirken "önce elemana sahip"
	sınıf için yıkıcı fonksiyon çalıştırılır, sonra ters sırada elemanlara ilişkin sınıfların yıkıcı fonksiyonları çalıştırılır". Bu da yapıcı fonksiyonların 
	çalıştırılma sırasının ters sırasıdır. Örneğin:

	#include "string.hpp"
	#include "date.hpp"

	using namespace std;
	using namespace CSD;

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		Student(const Student &r);
		~Student();
		void disp() const;
	private:
		String m_name;
		Date m_bdate;
		int m_no;
	};

	Student::Student(const char *name, int day, int month, int year, int no) 
		: m_name(name), m_bdate(day, month, year), m_no(no)
	{
	
	}

	Student::Student(const Student &r) 
	{
		m_name = r.m_name;
		m_bdate = r.m_bdate;
		m_no = r.m_no;
	}

	Student::~Student()
	{
		//...
	}

	void Student::disp() const
	{
		m_name.disp();
		m_bdate.disp();
	}

	int main()
	{
		Student s("Ahmet Ak", 7, 11, 1999, 123);

		s.disp();

		return 0;
	}

	Burada s nesnesi için çağrılacak yıkıcı fonksiyon aşağıdaki gibi yazılmıştır:

	Student::~Student()
	{
		//...
	}

	Bu s nesnesi yok edilirken önce bu yıkıcı fonksiyon çalıştırılıp sonra (ters sırada) sırasıyla m_bdate ve m_name veri elemanları için yıkıcı fonksiyonlar 
	çalıştırılacaktır. Tipik olarak derleyiciler bu işlemi aslında elemana sahip sınıfın yıkıcı fonksiyonlarının ana bloğunun sonuna yerleştirdikleri gizli bir 
	çağırma kodu yoluyla gerçekleştirmektedir. Yani sembolik olarak derleyicinin yukarıdaki yıkıcı fonksiyon için ürettiği kod aşağıdaki gibi olacaktır:

	Student::~Student()
	{
		//...

		m_bdate.~Date();		// derleyicinin yerleştirdiği gizli çağırma kodu
		m_name.~String();		// derleyicinin yerleştirdiği gizli çağırma kodu
	}

	Elemana sahip sınıf için biz yıkıcı fonksiyonu yazmadığımız zaman derleyicinin yazacağı içi boş yıkıcı fonksiyon yine veri elemanları için ters sırada yıkıcı 
	fonksiyonları çağıracaktır. Yani yukarıdaki örnekte biz Student sınıfı için yıkıcı fonksiyonu yazmamış olsak bile sınıfın m_name ve m_bdate veri elemanı için 
	String ve Date sınıflarının yıkıcı fonksiyonları çalıştırılacaktır. 

	Aşağıda elemana ilişkin ve sahip sınıfların yapıcı ve yıkıcı fonksiyonlarının ters sırada çağrıldığı gösterilmektedir. Programı çalıştırıp ekrana çıkan 
	yazıları inceleyiniz. Ekrana çıkan yazılar şöyle olacaktır:

	Mample(int) constructor
	Sample(int, int) constructor
	10
	20
	Sample destructor
	Mample destructor
-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Mample {
public:
	Mample(int a);
	~Mample();
	void disp() const;
private:
	int m_a;
};

class Sample {
public:
	Sample(int a, int b);
	~Sample();
	void disp() const;

private:
	Mample m_m;
	int m_b;
};

Mample::Mample(int a) : m_a(a)
{
	cout << "Mample(int) constructor" << endl;
}

Mample::~Mample()
{
	cout << "Mample destructor" << endl;
}

void Mample::disp() const
{
	cout << m_a << endl;
}

Sample::Sample(int a, int b) : m_m(a), m_b(b)
{
	cout << "Sample(int, int) constructor" << endl;
}

Sample::~Sample()
{
	cout << "Sample destructor" << endl;
}

void Sample::disp() const
{
	m_m.disp();
	cout << m_b << endl;
}

int main()
{
	Sample s(10, 20);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standartlarda özel üye fonksiyonların bazı durumlarda "trivial" olduğu belirtilmiştir. Burada "trival" sözcüğü Türkçe "önemsiz, ihmal edilebilir" gibi anlamlara
	gelmektedir. Standartlara göre bir yapıcı fonksiyon "trivial" ise aslında o yapıcı fonksiyon hiçbir şey yapmamaktadır. Dolayısıyla derleyici tarafından optimizasyon
	amacıyla aslında hiç çağrılmayabilir. Benzer biçimde bir yıkıcı fonksiyon "trival" ise bu yıkıcı fonksiyon da aslında bir şey yapmamaktadır. Dolayısıyla optimizasyon 
	amacıyla derleyici tarafından çağrılmayabilir. Yapıcı ve yıkıcı fonksiyonların "trivial" olması için onların "user provided" olmaması gerekmektedir. Programcının
	kendisinin yazdığı yapıcı ve yıkıcı fonksiyonlar için boş olasalar bile "trivial" olamazlar. Standartlarda derleyici tarafından yazılan yapıcı ve yıkıcı 
	fonksiyonların hangi durumlarda "trivial" olduğu maddeler halinde açıklanmıştır. Tabii yapıcı ve yıkıcı fonksiyonlar programcı tarafından inline olarak yazılmışsa
	ve gerçekten onların çağrılmasıyla bir yan etki oluşmayacaksa derleyici onları yine çağırmayabilir (yani boş bir inline açım yapabilir).
---------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın başka sınıf türünden veri elemanlarını get etmek için kullanılan getter fonksiyonları kopya yapıcı fonksiyonun çalıştırılmasına yol açabilmektedir. 
	Örneğin:

	using namespace std;
	using namespace CSD;

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		void disp() const;
		String name() const { return m_name; }
		Date bdate() const { return m_bdate; }
	private:
		String m_name;
		Date m_bdate;
		int m_no;
	};

	Student::Student(const char *name, int day, int month, int year, int no) 
		: m_name(name), m_bdate(day, month, year), m_no(no)
	{}

	void Student::disp() const
	{
		m_name.disp();
		m_bdate.disp();
	}

	Burada nesnenin içerisindeki m_name veri elemanını get etmek için name isimli üye fonksiyon, m_bdate veri elemanını get etmek için ise bdate isimli üye fonksiyon 
	sınıfa eklenmiştir. Ancak bu durumda biz üye fonksiyonları çağırdığımızda fonksiyonların geri dönüş değerleri sınıf türünden olduğu için ilgili sınıfların kopya 
	yapıcı fonksiyonları çalıştırılacaktır. Örneğin:

	Student s("Ahmet Ak", 7, 11, 1999, 123);

	s.name().disp();
	s.bdate().disp();

	Burada s.name() çağrısı ile önce geçici bir String nesnesi oluşturulup bu nesne üzerinde disp üye fonksiyonu çağrılmıştır. Bu tür durumlarda kopya yapıcı fonksiyonun
	çağrılmasını engellemek için veri elemanının referansıyla geri dönen getter fonksiyonlar oluşturulabilir. Örneğin:
		
	using namespace std;
	using namespace CSD;

	class Student {
	public:
		Student(const char *name, int day, int month, int year, int no);
		void disp() const;
		const String &name() const { return m_name; }
		const Date &bdate() const { return m_bdate; }
	private:
		String m_name;
		Date m_bdate;
		int m_no;
	};

	Buradaki name ve bdate getter fonksiyonları const üye fonksiyonlar olduğu için fonksiyonun geri dönüş değerine ilişkin referansların da const olması gerekmektedir. 
	(const üte fonksiyonlar içerisinde sınıfın veri elemanları const veri elemanları gibi ele alındığını anımsayınoz.) Bu durumda artık name ve bdate getter 
	fonksiyonlar doğrudan veri elemanlarının adreslerini verdiği için kopya yapıcı fonksiyonlar çalıştırılmayacaktır. 

	getter fonksiyonların yukarıdaki biçimde const referans yapılması gereksiz kopya yapıcı fonksiyonların çağrılmasını engelliyor olsa da nesne yönelimli 
	programlama tekniğindeki "veri elemanlarının gizlenmesi (data hiding)" prensibini biraz bozmaktadır. Çünkü ileride sınıfın bu veri elemanlarının tür bakımından 
	değiştirilmesi mümkün olamayacaktır. O halde programcı eğer sınıfın ilgili veri elemanlarını tür bakımından değiştirmeyecekse bu tekniği kullanabilir. Yani 
	sınıfın başka sınıf türünden veri elemanlarını get etmek için yazılan getter fonksiyonların nesnenin değeriyle mi referansıyla mı geri döndürüleceği 
	programcının isteğine ve gerekçelerine bağlı olarak değişebilmektedir. Örneğin Qt kütüphanesindeki sınıfların getter fonksiyonlarında duruma göre her iki 
	yöntem de kullanılmaktadır.

	Şimdi "sınıfın başka sının türünden veri elemanlarını referans yoluyla get etmek ve set etmek yerine onları doğrudan public bölümde bulundurmak arasında 
	ne fark var" biçiminde bir soru aklınıza gelebilir. Evet aslında bu ikisi arasında büyük bir farklılık olduğu söylenemez. Ama eğer biz sınıfın başka sınıf 
	türünen veri elemanlarınını referans yoluyla get ve set edersek onları bütünsel olarak alıp set edebiliriz. Onların veri elemanlarını doğrudan ya da dolaylı
	bir biçimde ara noktalarda değiştiremeyiz. 

	Aşağıda Qt kütüpanesindeki QWidget sınıfında buunan bazı getter fonksiyonları örnek olarka veriyoruz:

	QIcon windowIcon() const;
	void seetWindowIcon(const QIcon &icon);

	const QFont &font() const;
	void setFont(const QFont &font);

	const QPalette &palette() const;
	void setPalette(const QPalette &palette);

	QString	windowTitle() const;
	void setWindowTitle(const QString &str);
	
	QString	toolTip() const;
	void setToolTip(const QString &str);
	
	const QRect &geometry() const;
	void setGeometry(const QRect &rect);

	QSize size() const
	void resize(const QSize &size);

	Pekiyi burada tasarımcı neden bazı getter fonksiyonlarda const referans ile gerş dönerken bazılarında nesnenin değeriyle geri dönmüştür? İşte bunun 
	tasarımsal bazı nedenleri vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
										47. Ders 05/02/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	GUI framework'lerin kütüphanelerin pencere ve çizim işlemleri için genellikle Point, Size ve Rect gibi sınıflar bulundurulmaktadır. Point sınıfları bir pixel'in
	koordinatını Size sınıfı ise "genişlik ve yükseklik kavramını" temsil etmektedir. Rect sınıfları "bir dikdörtgensel bölgenin" tutulması ve 
	onun üzerinde bazı faydalı işlemlerin yapılması için bulundurulmaktadır. Örneğin bir C++ GUI kütüphanesi olan Qt Framework'ünde bu sınıflar QPoint, QSize
	ve QRect isimimleriyle bulunmaktadır. Microsoft C++ GUI framework'ü olan MFC'de ise bu sınıflar CPoint, CSize ve CRect isimleriyle bulunmaktadır. .NET Forms
	kütüphanesinde aynı sınıflar Point, Size ve Rectangle ismiyle bulunurlar. 

	Point gibi bir sınıfın x ve y değerlerini tutan iki int türden veri elemanın bulunması yeterlidir. Sınıfın yapıcı fonksiyonu bizden bu değerleeri alıp 
	veri elemanlarına yerleştirir. Yapıcı fonksiyonları constexpr yapmak gerektiğinde sabit ifadesi oluşturmak için kullanılabilir. Ancak pek çok çok framework
	zaten constexpr fonksiyon öncesinde yazıldığı için böyle bir işlevselliği desteklememktedir. 

	Size sınıfı da benzer biçimde genişlik ve yüksekliğe ilişkin iki veri veri elemanına sahip olabilir. Point sınıfı gibi Size sınıfı da bizden genişlik ve 
	yüksekliği alıp sınıfgın veri elemanlarında saklayabilir. 

	Biz aşağıdaki örnekte öğretici olsun diye Rect sınıfının veri elemanlarını Point ve Size türünden aldık. Rect sınıfı koordinatları "sol üst köşe" ve 
	"genişlik-yükseklik" biçiminde tutmaktadır. Örneğmizde rect sınıfına faydalı bazı üye fonksiyonlar da ekledik. Yukarıda sözünü ettiğimiz GUI framework'lerin
	kütüphanelerinde de genellikle bizim sınıfa eklediğimiz üye fonksiyonların benzerleri bulunmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// point.hpp

#ifndef POINT_HPP_
#define POINT_HPP_

namespace CSD 
{
	class Point {
	public:
		Point() = default;
		constexpr Point(int x, int y) : m_x(x), m_y(y)
		{}
		constexpr int x() const { return m_x; }
		constexpr int y() const { return m_y; }
		void disp() const;
		void move(int x, int y)
		{
			m_x += x;
			m_y += y;
		}
		void move(const Point &pt)
		{
			m_x += pt.m_x;
			m_y += pt.m_y;
		}
		constexpr Point add(int x, int y) const;
		constexpr Point add(const Point &pt) const;
	private:
		int m_x, m_y;
	};

	constexpr Point Point::add(int x, int y) const
	{
		return Point(m_x + x, m_y + y);
	}
	
	constexpr Point Point::add(const Point &pt) const
	{
		return Point(m_x + pt.m_x, m_y + pt.m_y);
	}
}


#endif

// point.cpp

#include <iostream>
#include "point.hpp"

using namespace std;

namespace CSD 
{
	void Point::disp() const
	{
		cout << '(' << m_x << ',' << m_y << ')' << endl;
	}
}

// size.hpp

#ifndef SIZE_H_
#define SIZE_H_

namespace CSD 
{
	class Size {
	public:
		Size() = default;
		constexpr Size(int width, int height) : m_width(width), m_height(height)
		{}
		constexpr int width() const { return m_width; }
		constexpr int height() const { return m_height; }
		void disp() const;
	private:
		int m_width;
		int m_height;
	};
}

#endif

// size.cpp

#include <iostream>
#include "size.hpp"

using namespace std;

namespace CSD 
{
	void Size::disp() const
	{
		cout << "width: " << m_width << ", height: " << m_height;
	}
}

// rect.hpp

#ifndef RECT_HPP_
#define RECT_HPP_

#include "point.hpp"
#include "size.hpp"

namespace CSD
{
	class Rect {
	public:
		constexpr Rect(int x, int y, int width, int height) 
			: m_pos(x, y), m_size(width, height)
		{}
		constexpr Rect(const Point &pos, const Size &size) 
			: m_pos(pos), m_size(size)
		{}
		constexpr Point pos() const { return m_pos; }
		constexpr Size size() const { return m_size; }
		constexpr int x() const { return m_pos.x(); }
		constexpr int y() const { return m_pos.x(); }
		constexpr int width() const { return m_size.width(); }
		constexpr int height() const { return m_size.height(); }
		constexpr Point bottom_right() const 
		{ 
			return m_pos.add(m_size.width(), m_size.height());
		}

		bool contains(const Point &pt) const;
		bool contains(int x, int y) const;
		bool contains(const Rect &rect) const;

		void move(int x, int y) { m_pos.move(x, y); }
		void move(const Point &pt) { m_pos.move(pt); }

	private:
		Point m_pos;
		Size m_size;
	};
}

#endif

// rect.cpp

#include <iostream>
#include "rect.hpp"

using namespace std;

namespace CSD 
{
	bool Rect::contains(const Point &pt) const
	{
		return pt.x() > m_pos.x() && pt.x() < m_pos.x() + m_size.width()
			&& pt.y() > m_pos.y() && pt.y() < m_pos.y() + m_size.height();
	}

	bool Rect::contains(int x, int y) const
	{
		return x > m_pos.x() && x < m_pos.x() + m_size.width()
			&& y > m_pos.y() && y < m_pos.y() + m_size.height();
	}

	bool Rect::contains(const Rect &rect) const
	{
		return contains(rect.m_pos) && contains(bottom_right());
	}
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın başka sınıf türünden veri elemanlarına sahip olması (ileride buna "içerme ilişkisi (composition)" diyeceğiz) aslında dolaylı bir biçimde gösterici 
	yoluyla da yapılabilir. Bunun için elemana sahip sınıf elemana ilişkin sınıf türünden nesnenin kendisini değil o türden bir gösterici tutar. Sonra elemana 
	sahip sınıfın yapıcı fonksiyonunda o gösterici için new operatörüyle tahsisat yapılır. Tabii elemana sahip sınıfın yıkıcı fonksiyonunda da dinamik tahsis 
	edilmiş nesne delete operatörü ile yok edilmelidir. Örneğin:

	class A {
		//...
	};

	class B {
		B();
		~B();
		//...
	private:
		A *m_a;
	};

	B::B() 
	{
		m_a = new A();
		//...
	}

	B::~B()
	{
		delete m_a;
	}

	Pekiyi bu biçimde bir içerme ilişkisi ile elemanın kendisinin tutulması arasında ne fark vardır? Yani örneğin yukarıdaki işlevsillikle aşağıdakinin arasında 
	ne fark vardır?

	class A {
		//...
	};

	class B {
		B();
		~B();
		//...
	private:
		A m_a;
	};

	B::B() : m_a()
	{
		//...
	}

	Biz birinci biçimde elemana sahip sınıf içersinde eleman olan sınıfa ilişkin bir gösterici tuttuk. İkinci biçimde elemana sahip sınıf içerisinde bizzat 
	elemanın kendisini tuttuk. Bu iki biçim arasında semantik farklılıklar olsa da aslında mantıksal bakımdan önemli bir farklılık yoktur. Neticide her iki
	durumda da sınıf başka sınıf türünden elemana sahip olmuştur. 
	
	Tabii sınıfın başka sınıf türünden gösterici veri elemanı olduğu durumda new yapılmadıktan sonra eleman olan sınıf için bir nesnenin yaratılmayacağına dikkat 
	ediniz. Örneğin:

	class B {
		B();
		~B();
		//...
	private:
		A *m_a;
	};

	B::B() 
	{
		//...
	}

	Burada m_a göstericisinin gösterdiği yer için otomatik olark bir nesne yaratılmamaktadır. Dolayısıyla elemana sahip sınıfın yapıcı fonksiyonunda bu örnekte
	A nesnesi için bir yapıcı fonksiyon da çağrılmayacaktır. A nesnesi için yapıcı fonksiyon o nesne new ile yaratılırken çağrılacaktır. Örneğin:

	B::B() 
	{
		m_a = new A();		// bu noktata A nesnesi yaratılır ve yapıcı fonksiyon çağrılır
	}

	Burada şu noktaya dikkat ediniz: B sınıfının veri elemanı olarak A sınıfı türünden bir nesnenin olması ile A sınıfı türünden bir göstericinin olması 
	NYPT bakımından benzer anlama gelse de C++ semantiği bakımından farklı anlamlara gelmektedir. Göstericilerin türü ne olursa olsun onlar sınıf nesnesi 
	değildir. Temel türlere ilişkin nesnelerdir. 

	Qt gibi bazı framework'lerde Widget nesneleri sınıfın veri elemanı olarak değil gösterici veri elemanı olarak bulundurulmaktadır. Dolayısıyla bunların 
	yaratımları eleman sahip Widget sınıflarının yapıcı fonksiyonları içerisinde new operatörüyle yapılmaktadır. Bu Qt'nin tasarımına ilişkin bir özelliktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													48. Ders 07/02/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesinin aynı sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanması durumunda tanımlanan nesne için kopya yapıcı fonksiyonun çağrıldığını 
	gördük. eğer biz kopya yapıcı fonksiyonu yazmazsak derleyici onu "sınıfın karşılıklı veri elemanlarını ilkdeğer veriyormuş gibi atayacak biçimde (memberwise 
	copy)" yazıyordu. Özellikle sınıfın bir gösterici veri elemanı varken bizim sınıf için kopya yapıcı fonksiyonu azmamız gerekiyordu. Pekiyi aynı sınıf türünden 
	iki sınıf nesnesi birbirine atandığunda ne olacaktır? Örneğin:

	class String {
		//...
	private:
		char *m_str;
		size_t m_size;
	};

	String a{"Ali Ak"};
	String b;

	b = a;

	Anımsanacağı gibi C'de aynı türden iki yapı nesnesi birbirine atandığında yapının karşılıklı elemanları birbirine atanıyordu. C++'ta sınıflar veri elemanlarının
	organizasyonu bakımından C'deki yapılara benzerdir. Pekiyi C++'ta aynı türden iki sınıf nesnesi birbirine atanırsa ne olacaktır?

	İşte C++'ta aynı türden iki sınıf nesnesini birbirine atadığımızda sınıfın ismine "kopya atama operatör fonksiyonu (copy assignment operator)" denilen bir
	üye fonksiyonu çağrılmaktadır. Atama işlemi bu üye fonksiyon tarafından yapılmaktadır. Aslında operatör fonksiyonları ayrı bir bölüme ele alacağımız geniş 
	ve ayrıntılı bir konudur. Kopya atama operatör fonksiyonunu da biz o bölğmde detaylı olarak ele alacağız. Ancak ne olursa olsun bu bölümde de kopya yapıcı 
	fonksiyonu ele aldıktan sonra kopya atama operatör fonksiyonu hakkında temel bazı bilgiler vereceğiz. Konu detaylı olduğu için detaylarını ileride ele alacağız.
	
	C++ standartlarına göre k bir sınıf nesnesi olmak üzere:

	k = s;

	işleminin eşdeğeri şöyledir:

	k.operator =(s);

	Görüldüğü gibi k nesnesi ile sınıfın "operator =" isimli bir üye fonksiyonu çağrılmıştır. Atanmak istenen değer de bu üye fonsiyona parametre olarak geçirilmiştir. 
	Operatör fonksiyonlarının isimleri "operator" anahtar sözcüğü ile bir operatör sembolünden oluşmaktadır. Operatör fonksiyonlarının bazı kısıtlar dışında diğer
	bakımlardan diğer üye fonksiyonlardna bir farkı yoktur. Eğer programcı sınıfı için kopya atama operatör fonksiyonunu yazmazsa bu fonksiyon derleyici tarafından 
	yazılır. Derleyicinin yazdığı kopya atama operatör fonksiyonu da sınıfın karşılıklı veri elemanlarını birbirine atar (memwise copy). Yani biz bir sınıf için 
	kopya atama operatör fonksiyonunu yazmayabiliriz. Bu durumda aynı türden iki sınıf nesnesi birbirine atandığında tıpkı C'de olduğu gibi sınıfın karşılıklı veri 
	elemanları biribirine atanacaktır. 

	Pekiyi mademki derleyici bizim için eğer biz yazmazsak kopya atama operatör fonksiyonunu kendisi yazıyor, bu durumda bu operatör fonksiyonunu yazmamız gereken
	yerler var mıdır? İşte "bir sınıf için ne zaman kopya yapıcı fonksiyonu yazılması gerekse o sınıf için aynı zamanda kopya atama operatör fonksiyonun da aynı 
	gerekçelerle" yazılması gerekmektedir. Yani örneğin sınıfın gösterici veri elemanları olduğu durumda bizim o sınıf için hem kopya yapıcı fonksiyonu hem de 
	kopya atama operatör fonksiyonunu "içerik kopyalaması yapacak biçimde" yazmamız gerekir. 
	
	Daha önce yazmış olduğumuz String sınıfınının aşağıdaki ver elamanlarına sahip olduğunu varsayalım:

	class String {
		//...
	private:
		char *m_str;
		size_t m_size;
	};

	Eğer bu sınıf için biz kopya atama operatör fonksiyonunu yazmazsak önemli sorunlar ortaya çıkar. Örneğin:

	String s{"ankara"};

	{
		String k{"izmir"};

		k = s;

		k.idsp();
	}
	s.disp();


	Burada k = s işleminde iki sorun oluşacaktır. Birincisi s'in m_str veri elemanı k'nın m_str elemanına atanmasıyla k'nın m_str elemanının daha önce gösterdiği
	dinamik alanın boşaltılma olanağı ortadana kalkacaktır. Dolayısıyla bu durum bir "bellek sızıntısına (memory leak)" yol açacaktır. İkinci sorun daha önce kopya 
	yapıcı fonksiyonda ele aldığımız sorundur. Yani iki nesnenin m_str veri elemanları aynı nesneyi gösterir. Bu durumda birisi çağrılan yıkıcı fonksiyon diğerinin
	kullandığı alanı da free hale getirecektir. Bu da kodda ileride tanımsız davranış oluşturacaktır. 

	Tabii bir sınıf için kopya yapaıcı fonksiyonun yazılmasına gerek yoksa kopya atama operatör fonksiyonunun da yazılmasına gerek yoktur. Örneğin:

	class Complex {
		//...
	private:
		double m_real;
		double m_imag;
	};


	Complex x{3, 2};
	Complex y;

	y = z;

	Böylesi bir sınıf için kopya yapıcı fonksiyonun ve kopya atama operatör fonksiyonunun programcı tarafındna yazılmasına gerek yoktur. Zaten derleyicinin 
	kendisinin yazacağı kopya yapıcı fonksiyon ve kopya atama operatör fonksiyonu istenilen şeyi yapacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın aşağıdaki parametrik yapılara sahip olan "operator =" isimli operatör fonksiyonlarına "kopya atama operatör fonksiyonlzrı (copy assignment operator)"
	denilmektedir (sınıfın isminin T olduğunu varsayıyoruz):

	T 
	T &
	const T &
	volatile T &
	const volatile T &

	Kopya atama operatör fonkdiyonu tipik olarak const T & parametreli biçimde yazılmaktadır. Zaten bir sınıf için biz kopya atama operatör fonksiyonunu yazmamışsak
	const T & parametreli kopya atama operatör fonksiyonu yazılmaktadır. (Bu kuralın bazı ayrıntıları vardır.)
	Kopya atama operatör fonksiyonunun geri dönüş değeri herhangi bir türden olabilirse de "onun kendisi sınıfı türünden bir referansa geri dönmesi" en normal 
	durumdur. Bunun ayrıntıları operatör fonksiyonlarının anlatıldığı bölümde ele alınacaktır. 

	Kopya atama operatör fonksiyonunun yazılmasında dikkat edilecek bazı noktalar vardır. Örneğin programcılar geneillikle fonksiyonun başında aşağıdaki gibi 
	bir kontrol uygularlar:

	T &T::operator =(const T &r)
	{
		if (this == &r)
			return *this;
		//...
	}

	Bu kontrol bir nesnenin kendisinin kendisine atanması durumunda oluşabilecek anomaliyi ortadan kaldırmak için yapılmaktadır. Kopya atama operatör fonksiyonları
	*this biçiminde bir ifadeyle geri döndürülmelidir. Örneğin:

	T &T::operator =(const T &r)
	{
		if (this == &r)
			return *this;

		//...

		return *this;
	}

	this anahtar sözcüğünü biz henüz görmedik. Dolayısıyla fonksiyonun bu kısımları üzerinde açıklama yapmayacağız. Ancak kopya atama operatör fonksiyonunun 
	geri kısmı içerik kopyalaması yapacak biçimde yazılmalıdır. 

	Örneğin daha önce yazmış olduğumuz kapasiteli String sınıfında kopya atama oprratör fonksiyonu tipik olarak aşağıdaki gibi yazılmalıdır:

	class String {
		//...
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	//...

	String &String::operator =(const String &r)
	{
		if (this == &r)
			return *this;

		delete[] m_str;						// 1
		m_str = new char[r.m_capacity];		// 2
		strcpy(m_str, r.m_str);				// 3
		m_size = r.m_size;					// 4
		m_capacity = r.m_capacity;			// 4

		return *this;
	}

	Aşağıdaki gibi bir atama yapmış olalım:

	String s{"ankara"};
	String k{"izmir"};

	k = s;

	Buradaki k = s işleminin eşdeğeri şöyledir:

	k.operator =(s);

	O halde kopya atama operatör fonksiyonu içerisinde doğrudan kullandığımız veri elemanları k'nın veri elemanları r referansıyla kullandığımız veri elemanları 
	ise s'nin veri elemanlarıdır. Şimdi yapılanları adım adım açıklayaliım:

	1) delete[] m_str;

	Burada k için daha önceden tahsis edilmiş olan alan "sızıntı oluşmasında diye" free hale getirilmiştir. 

	2) m_str = new char[r.m_capacity];

	r'nin kapsitesi kadar k için alan tahsis edilmiştir. 

	3) strcpy(m_str, r.m_str);	

	Burada içerik kopyalaması yapılmaktadır. 

	4) m_size = r.m_size; m_capacity = r.m_capacity

	k nesnesinin ywni size ve capacity değerleri olması gerektiği gibi güncellenmiştir.

	Burada yazmış olduğumuz kopya atama operatör fonksiyonunu daha önce yazmış olduğumuz kopya yapıcı fonksiyon ile karşılaştırınız:

	String::String(const String &r)
	{
		m_str = new char[r.m_size + DEF_CAPACITY];
		strcpy(m_str, r.m_str);
		m_size = r.m_size;
		m_capacity = r.m_size + DEF_CAPACITY;
	}

	//...

	String s("ankara");
	String k(s);

	Burada kopya yapıcı fonksiyon içerisinde doğrudan kullandığımız veri elemanları henüz yaratılmış olan nesnenin veri elemanlarıdır. Dolayısıyla bizim yeni 
	yaratılan nesnenin m_str elemanı için bir delete işlemi yapmamıza gerek yoktur.
	
	Kopya atama operatör fonksiyonu hakkında bu noktada bu kadar bilgiyi yeterli görüyoruz. Ayrıntılar operatör fonksiyonlarının anlatıldığı bölümde ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Referanslarla ilgili overload resolution süreci hakkında daha önce görmüş olduğumuz bazı hatırlatmaları yapmak istiyoruz. Örneğin:
		
	void foo(int &r)			// 1
	{
		cout << "foo: int &" << endl;
	}

	void foo(int &&r)			// 2
	{
		cout << "foo: int &&" << endl;
	}

	Burada iki foo fonksiyonu vardır. Biri sol taraf değeri referansı diğeri sağ taraf değeri referansı parametresine sahipt.r Bu fonksiyonu aşağıdaki gibi 
	çağırmış olalım:

	foo(10);

	Burada tereddüt edilecek bir şey yoktur. Zaten sol taraf değeri referans parametreli fonksiyon "uygun fonksiyon (viable function)" deildir. Dolayısıyla burada
	sağ taraf değeri referans parametreli fonksiyon çağrılacaktır. Şimdi fonksiyonu şöyle çağırmış olalım:

	int a = 10;
	
	foo(a);

	Burada da tereddüt edilecek bir durum yoktur. Çünkü burada zaten sağ taraf değeri referans parametreli foo fonksiyonu "uygun (viable)" fonksiyn değildir. Dolayısıyla
	sol taraf değeri referans parametreli foo çağrılacaktır. Şimdi fonksiyonlar şöyle olsun:

	void foo(const int &r)			// 1
	{
		cout << "foo: int &" << endl;
	}

	void foo(int &&r)				// 2
	{
		cout << "foo: int &&" << endl;
	}

	Fonksiyonu şöyle çağırmış olalım:

	foo(10);

	Burada her iki fonksiyon da "uygun (viable)" fonksiyonlardır. Ancak overload resolution kuralı gereği bu tür durumlarda sağ taraf değeri referans parametreli 
	fonksiyonun daha iyi dönüşüm sunduğu kabul edilmektedir. Dolayısıyla burada sağ taraf değeri referans parametreli fonksiyon çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sağ taraf değeri referansına (rvalue reference) bir sağ taraf değerinin bind edilmesi gerektiğini anımsayınız. C++11 ile birlikte "value kategori" ismi 
	altında terimlerin aşağıdaki gibi değiştirildiğini daha önce ifade etmişk:

		glvalue  rvalue
		 /  \     / \
		/    \   /   \
	lvalue	xvalue	prvalue

	Sol taraf değeri referansına sol taraf değerinin bind edilmesi gerekir. Yani biz sol taraf değeri referansına "xvalue" bind edemeyiz. Ancak sağ taraf değeri 
	referansına "xvalue" ve "prvalue" bind edebiliriz. Çünkü hem "xvalue" hem de "prvalue" sağ taraf değeri kabul edilmektedir. Pekiyi nedir bu xvalue?

	xvalue terimi "expiring value" sözcüklerden kısaltılarak uydrulmuştur. "expiring" sözcüğü "vakti dolan, yok olmak üzere olan" gibi anlamlara gelmektedir. 
	Geçici nesneler, fonksiyonların geri dönüş değerleri, sabitler "prvalue" kabul edilmektedir. Nesne belirten ifadeler ise "lvalue" kabul edilmektedir. 
	Pekiyi hangi ifadeler "xvalue" kabul edilmektedir?

	C++'ta xvalue belirten üç ifade vardır:

	1) Bir ifade eğer sağ taraf türünden referansa dönüştürülürse artık ifade xvalue belirtir. Örneğin:

	int a = 10;

	Burada a lvalue belirtir. Ancak (int &&)a ya da static_cast<int &&>(a) ifadeleri xvalue belirtir.(Bir nesneyi sol taraf değeri referansına dönüştürürsek bu 
	xvalue belirtmez lvalue belirtir.)

	2) Bir fonksiyonun geri dönüş değeri sağ taraf değeri türünden referans ise böyle bir fonksiyon çağrıldığında bu çağrı xvalue belirtmektedir. Örneğin:

	int &&foo()
	{
		//...
	}

	Burada foo() çağrısı xvalue belirtir. Fonksiyonun geri dönüş değeri referans değilse o çağrının prvalue belirttiğini anımsayınız. Örneğin:

	int foo()
	{
		//...
	}

	Burada foo() çağrısı rvalue belirtir. Benzer biçimde fonksiyonun geri dönüş değeri sol taraf değeri referansıysa bu fonksiyonun çağrısı lavlue belirtir. 
	Örneğin:

	int &foo()
	{
		//...
	}

	Burada foo() çağrısı lvalue belirtmektedir. 

	3) Bir fonksiyonda return ifadesinde parametre bir yerel değişken ya da parametre değişkeni varsa bu return ifadesindeki değişken artık xvalue belirtmektedir. 
	Bu özel bir durumdur. Örneğin:

	T foo()
	{
		T a;

		//...

		return a;
	}
	
	Burada a yerel değişkeni hayatını kaybetmek üzeredri. İşte return ifadesinde hayatını kaybetmek üzere olan bir lavlue kullanılırsa artık bu lavlue belirtmez
	xvalue belirtir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Elimizde bir sol taraf değeri varsa biz onu nasıl bir sağ taraf değeri referansına bind edebiliriz? İşte akla gelen en makul yol onu sağ taraf değeri referansına
	dönüştürmektir. Örneğin:

	void foo(int &&r)
	{
		r = 20;
	}
	//...

	int a = 10;

	foo(static_cast<int &&>(a));		// geçerli

	Burada static_cast<int &&>(a) ifadeis ile artık a nesnesi bir lvalue olmaktan çıkıp bir rvalue haline getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &&r)
{
	r = 20;
}

int main()
{
	int a = 10;

	foo(static_cast<int &&>(a));

	cout << a << endl;			// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte lvalue ifadesini sağ taraf değeri referansına dönüştüren move isimli standart bir fonksiyon kütüphaneye eklenmiştir. Bu fonksiyonun prototipi
	<utility> isimli başlık dosyasındadır. move fonksiyonu bir taşıma yapmamaktadır. Bu fonksiyonun tek yaptığı şey lvalue ifadesini sağ taraf değeri referansına 
	dönüştürerek ondan bir xvalue edilmesini sağlamaktır. Dolayısıyla elimizde bir lvalue varsa biz onu sağ taraf değeri referansına bind edeceksek tür dönüştürmesi 
	yerine zaten bu işlemi yapan move fonksiyonundan faydalanabiliriz. Örneğin.

	#include <utility>

	void foo(int &&r)
	{
		r = 20;
	}
	//...

	int a = 10;

	foo(move(a));			// geçerli

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu noktada bir anımsatma da yapmak istiyoruz. İster sol taraf değeir referansı olsun isterse sağ taraf değeri referansı olsun bir referansı ilkdeğer verdikten
	sonra kullandığımızda artık o ifade bir sol taraf değeri (lvalue) anlamına gelmektedir. Örneğin:

	int &&r = 10;		// geçerli, r'nin içerisinde geçici olarak yaratılan int nesnenin adresi var
	int &k = r;			// geçerli, r kullanılırken artık sol taraf değeri belirtmektedir. Örneğin:

	void foo(int &r)
	{
		//...
	}

	void foo(int &&r)
	{
		//...
	}

	//...

	int &&r = 10;

	foo(r);		// int & parametreli foo fonksiyonu çağrılır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													49. Ders 12/02/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi move fonksiyonu "bir şeyi taşımamaktadır" yalnızca lvalue ifadesini xvalue (yani rvalue) haline getirmektedir. Bir lvalue 
	ifadesinin sağ taraf değeri referansına dönüştürülmesi ile move fonksiyonuna sokulması arasında bazı küçük farklılıklar vardır. Bu konu şablonların ele 
	alındığı bölümde açıklanacaktır. 
	
	Biz bir kodda move fonksiyonunun çağrıldığını gördüğümüzde "move fonksiyonuna parametre olarak geçilen nesnenin yaşamını kaybetmek üzere olduğunu dolayısıyla
	kaynakların onun içerisinden alınarak başka nesneye aktarılmasının istendiğini" anlamalıyız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önce aşağıdaki veri elemanlarına sahip bir String sınıfı yazmıştık:

	class String {
		//...
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	Bir String nesnesi yaratıldığında onun için m_capacity kadar yer tahsis edilip string'in karakterleri o alan kopyalanıyordu. Biz bu String sınıfı için kopya
	yapıcı fonksiyonunu da yazmıştık. Şimdi bir öğrencinin bilgilerini tutan bir Student sınıfını aşağıdaki gibi yazmak isteyelim:

	class Student {
	public:
		Student(const String &name, int no) : m_name(name), m_no(no)
		{}
		void disp() const;
		//...
	private:
		String m_name;
		int m_no;
	};

	Şimdi de aşağıdaki gibi Student sınıfı türünden bir nesne yaratalım:

	Student student{String("Ali Serce", 123)};

	student.disp();

	Student sınıfının yapıcı fonksiyonu bizden bir String referansı istediği için biz de pratik bir biçimde geçici nesne yaratıp oonu referansa bind ettik.
	Bu kodda hiçbir problem yoktur. Her nae kadar bu kodda problem yoksa da burada programcıları rahatsız eden bir durum vardır. Geçici String nesnesinin yaratılıp
	hemen kopya yapıcı fonksiyonu ile Student nesnesinin m_name veri elemanın kopyalnması gereksiz bir işlem gibidir. Çünkü burada hem String türünden geçici 
	nesnenin yaratılması sırasında tahsisat yapılmış, hem de onun kopya yapıcı fonksiyonu ile m_name veri elemanına kopyalnması sırasında tahsisat yapılmıştır. 
	Üstelik de bu geçici nesne bu kopyalamadan sonra hemen yok edilmektedir. İşte C++11'e kadar yukarıdaki etkinlik problemi için bir şey yapılamıyordu. C++11
	ile birlikte sağ taraf değeri referansları ve "taşıma semantiği (move semantic)" denilen mekanizma ile buradaki rahatsız edici durum giderilmiştir. 

	Taşıma semantiği hayatını kaybetmek üzere olan (xvalue) nesnenin kaaynaklarını çalarak başka nesnede kullanma sürecini belirtmektedir. Yukarıdaki örnekte 
	Önce giçi string nesnei yaratılacak ve aşağıdaki gibi bir durum oluşacaktır:

	m_str    ---------> xxxxxxxxxx\0________________
	m_size (yazının uzunluğu)
	m_capacity (toplam tahsis edilen alan)

	Bu nesne Student sınıfının m_name elemanına kopya yapıcı fonksiyonu yoluyla kopyalnırken geçici nesnenin m_str göstericisinin gösterdiği yerin gereksiz bir 
	kopyasında oluşturulmaktadır. Burada gereksiz dememizin nedeni zaten bu geçici nesnenin biraz sonra yok edilecek olmasındadır. İşte taşıma semantiği sayesinde
	bu kopyalama (artık buna taşıma diyeceğiz) elimine edilebilmektedir. Student nesnesinin m_name elemanının m_str göstericisi geçici yaratılan nesnenin m_str
	veri elemanı için tahsis edilen alanı doğrudan kendi bünyesine geçirerek kullanabilir. Çünkü zaten bu geçici nesne biraz hayatını kaybedecek dolayısıyla o 
	alana gereksimi olmayacaktır. Bu süreci beyin ölümü gerçekleşen kişinin organlarınının alınarak başka kişiye aktarılmasına benzetebiliriz. 

	Taşıma semantiği "taşıma yapıcı fonksiyonu (move constructor)" ve "taşıma atama operatör fonksiyonu (move assignment operator)" denilen fonksiyonlar yoluyla
	yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın sınıf ismi T olmak üzere aşağıdaki parametre yapısına sahip yapıcı fonksiyonlarına "taşıma yapıcı fonksiyonları (move constructors)" denilmektedir:
	
	- T && 
	- const T &&
	- volatile T &&
	- const volatile T &&

	Taşıma yapıcı fonksiyonlarının const parametreli olmasının anlamı yoktur. Dolayısıyla taşıma yapıcı fonksiyonları tipik olarak T && parametreli biçimde 
	karşııza çıkmaktadır. 

	Taşıma yapıcı fonksiyonları C++11 ile birlikte dile eklenmiştir. Zaten C++11 ile birlikte "sağ taraf değeri referanslarının" dile eklenmesinin asıl nedeni 
	"taşıma semantiği (move semantics)" denilen bu durumun sağlanması içindir. Örneğin:

	class Sample {
	public:
		Sample() = default;				// default constructor
		Sample(const Sample &r);		// copy constructor
		Sample(Sample &&r);				// move constructor (C++11 ile birlikte eklendi)
		//...
	};

	Pekiyi sınıfların taşıma yapıcı fonksiyonları ne zaman çağrılmaktadır? İşte taşıma yapıcı fonksiyonları bir sınıf türünden nesneyi aynı sınıf türünden bir 
	sağ taraf değeri referansı ile yaratmak istediğimizde çağrılır. Örneğin:

	Sample s;
	Sample k{s};		// k için kopya yapıcı fonksiyonu çağrılır

	Burada s bir lvalue ifadesidir. Dolayısıyla zaten overload resolution işleminde tek uygun fonksiyon const Sample & parametreli kopya yapıcı fonksiyonudur. 
	Dolayısıyla burada k için sınıfın kopya yapıcı fonksiyonu çağrılacaktır. Örneğin:

	Sample k{Sample()};		// Sample() ifadesi prvalue olduğundan burada k için taşıma yapıcı fonksiyonu çağrılır

	Burada Sample() ifadesi ile bir geçici nesne oluşturulmuştur. Geçici nesneler "prvalue" kabul edilmektedir. Dolayısıyla hem const Sample & parametreli hem de 
	Sample && parametreli yapıcı fonksiyonlar uygun fonksiyonlardır. Ancak daha önce de belirttiğimiz gibi bu durumda sağ taraf değeri referansı parametresine sahip 
	olan fonksiyon const sol taraf değeri referansına sahip olan fonksiyondan daha iyi bir dönüştürme sunmaktadır. Dolayısıyla burada k nesnesi için taşıma yapıcı
	fonksiyonu çağrılacaktır. Buradan özetle şunu söyleyebiliriz: "Sınıfın hem kopya yapıcı fonksiyonu hem de taşıma yapıcı fonksiyonu varsa eğer nesne aynı sınıf 
	türünden sol taraf değeri ile yaratılıyorsa kopya yapıcı fonksiyonu, sağ taraf değeri ile yaratılıyorsa taşıma yapıcı fonksiyonu" çağrılır. 

	Taşıma yapıcı fonksiyonunun geçmişe doğru uyumu bozmadan eklendiğine dikkat ediniz. Yani yukarıdaki örnekte Sample sınıfının taşıma yapıcı fonksiyonu olmasaydı 
	yine her şey C++11 öncesinde olduğu gibi işleyecekti. Örneğin:

	class Sample {
	public:
		Sample() = default;				// default constructor
		Sample(const Sample &r);		// copy constructor
		//...
	};

	Sample s;
	Sample k{s};			// k için kopya yapıcı fonksiyonu çağrılır
	Sample r{Sample()};		// r için kopya yapıcı fonksiyonu çağrılır

	Yukarıdaki Student sınıfına aşağıdaki gibi bri yapıcı fonksiyon daha ekleyelim:

	class Student {
	public:
		Student(const String &name, int no) : m_name(name), m_no(no)
		{}
		Student(String &&name, int no) : m_name(move(name)), m_no(no)			
		{}
		void disp() const;
		//...
	private:
		String m_name;
		int m_no;
	};

	Şöyle bir kod söz konusu olsun:

	String name{"Ali Serce"};
	int no = 123;
	//...
	Student student{name, no};
	//...

	Burada student nesnesi için "const String &, int" parametreli yapıcı fonksiyon çağrılacaktır. Dolayısıyla butadaki name Student sınıfının m_name veri elemanına
	kopya yapıcı fonksiyonu yoluyla aktarılacaktır. Şimdi kod aşağıdaki gibi olsun:
		
	String name{"Ali Serce"};
	int no = 123;
	//...
	Student student{move(name), no};
	//...
	
	Burada artık student nesnesi için sınıfın "String &&, int" parametreli yapıcı fonksiyonu çalıştırılacaktır. Bu fonksiyon da sınıfın m_name veri elemanını taşıma 
	yapıcı fonksiyonu yoluyla oluşturacaktır. Yani bu kodu yazan kişi name isimli nesneyi kullanmış ancak daha sonra tekrar kullanmayacağı için onun kaynaklarını transfer 
	etmek istemiştir. Tabii buradaki name yerel değişkeninin kaynakları transfer edildiğinde artık bu yerel değişkenin kod içerisinde kullanılmaması uygun olur. Başka bir
	deyişle bizim "kaynaklarını çaldığımız nesneyi artık kullanmamamız" gerekir. 
		
	Aşağıdaki gibi bir fonksiyon olsun:

	Student foo()
	{
		String name{"Ali Serce"};
		int no = 123;

		//...

		return Student(name, no);
	}

	Burada C++17 ve sonrasında "copy elision" zorunlu olduğu için return ifadesindeki geçici nesne aslında geri dönüş değeri için oluşturulacak nesne biçiminde
	yaratılacaktır. Ancak buarada yine yaratılacak Student nesnesi için onun m_name elemanı name yerel değişkeninden kopyalanarak oluşturulacaktır. Halbuki 
	fonksiyon aşağıdaki gibi yazılsaydı name yerel değişkeni içerisindeki kaynaklar çalınıp kullanılabilirdi:

	Student foo()
	{
		String name{"Ali Serce"};
		int no = 123;

		//...

		return Student(name, no);
	}

	Yukarıdaki Student sınıfının aşağıdaki yapıcı fonksiyonuna dikkat ediniz:

	Student(String &&name, int no) : m_name(move(name)), m_no(no)			
	{}

	Burada MIL sentaksında biz move fonksiyonunu kullanmasaydık "sağ taraf değeri referansını ilkdeğer verdikten sonra kullandığımızda o sol taraf değeri 
	belirtirtecekti" dolayısıyla burada move fonksiyonu çağrılmasaydı yine String sınıfının kopya yapıcı fonksiyonu çalıştırılacaktı. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi biz sınıfımız için taşıma yapıcı fonksiyonunu nasıl yazmalıyız? Yukarıda da belirttiğimiz gibi bizim taşıma yapıcı fonksiyonunda yaşamını yitirmek 
	üzere olan nesnenin kaaynaklarını çalmamız ancak onu da "geçerli (valid/consistent)" bırakmamız gerekir. İşte yaşamını kaybetmek üzere olan nesnenin kaynaklarını
	çaldıktan sonra onu geçerli halde bırakabilmek için onun veri elemanlarının değiştirilmesi gerekmektedir. Zaten sırf bunun için C++11 ile "sağ taraf değeri
	referansları" konusu eklenmiştir. Burada "hem geçici nesneyi kullanmak hem de onu güncelemmek"" gerekmektedir.

	Yazmış olduğumuz String sınıfını yeniden anımsayalım:

	class String {
		//...
		String(String &&r) noexcept;	// move constructor
		//...
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	Bu sınıf için taşıma yapıcı fonksiyonu şöyle yazılabilir:

	String::String(String &&r)
	{
		m_str = r.m_str;
		m_size = r.m_size;
		m_capacity = r.m_capacity;
		r.m_str = nullptr;
	}

	Taşıma yapıcı fonksiyonu şöyle bir bağlamda kullanılmış olsun:

	String s{"ankara"};
	//...
	String k{move(s)};		// k için taşıma yapıcı fonksiyonu çağrılacak

	Buarada taşıma yapıcı fonksiynu içerisindeki doğrudan kullandığımız veri elemanları yaratılmakta oaln k nesnesinin veri elemanlarıdır. r referansı ile 
	kullandığımız veri elemanları ise s nesnesinin veri elemanlarıdır. Taşıma yapıcı fonksiyonun son satırına dikkat ediniz:

	r.m_str = nullptr;

	Burada biz s nesnesinin m_str veri elemanına NULL adres yerleştiriyoruz. İçerisinde null adres bulunan bir gösterici delete edildiğinde bu işlem bir etkiye
	yol açmamaktadır. (Yani String sınıfının yıkıcı fonksiyonu içerisinde delete işlemi yaparken NULL adres kontrolünü yapmamıza gerek yoktur.)

	Aşağıdaki Student sınıfı örneğini çalıştırarak deneyiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// app.cppp

#include <iostream>
#include "String.hpp"

using namespace std;
using namespace CSD;

class Student {
public:
	Student(const String &name, int no) : m_name(name), m_no(no)
	{}
	Student(String &&name, int no) : m_name(move(name)), m_no(no)
	{}

	String name() const { return m_name; }
	int no() const { return m_no; }

	void disp() const;
private:
	String m_name;
	int m_no;
};

void Student::disp() const
{
	cout << m_name.c_str() << ", " << m_no << endl;
}

int main()
{
	String name{"Ali Serce"};
	int no = 123;

	name.disp();
	cout << no << endl;

	Student student(move(name), no);	// name nesnesinin kaynakları çalınarak student nesnesinin m_name elemanına aktarılmıştır

	student.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															50. Ders 14/02/2024 - Çarşamba 	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taşıma yapıcı fonksiyonu genellikle "nexcept" exception belirleyicisi ile bildirilmktedir. noexcept belirleyicisi "exception" konusu ile ilgilidir. Exception
	konusu ileride ayrı bir başlık altında ele alınacaktır. noexcept belirleyicisi ilgili fonksiyonun "bir exception fırlatmayacağını" belirtmektedir. Bu belirleyici
	sayesinde ilgili sınıfı kullanan başka sınıflar "yüksek exception garantisi (strong exception guarantee)" verebilmektedir. Taşıma semantiği çoğu kez zaten 
	bir exception oluşmadan gerçekleştirilmektedir. Dolayısıyla taşıma yapıcı fonksiyonlarında noexcept belirleyicisinin kullanılması genellikle olağan bir durumdur. 
	Ancak bazı özel durumlarda taşıma işlemleri de exception oluşmasına yol açabilmektedir. Bu durumda taşıma yapıcı fonksiyonunda noexcept belirleyicisi 
	kullanılmamalıdır. Biz bu konu görülene kadar taşıma yapıcı fonksiynlarında "noexcept" belirleyicisini kullanacağız. Örneğin:
	
	class String {
		//...
		String(String &&r) noexcept;	// move constructor
		//...
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	String::String(String &&r) noexcept
	{
		m_str = r.m_str;
		m_size = r.m_size;
		m_capacity = r.m_capacity;
		r.m_str = nullptr;
	}

	noexcept belirleyicisi hem prototipte hem de tanımlamada bulundurulmak zorundadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz daha önce "copy elision" kavramından bahsetmiştik. Ancak o zaman henüz taşıma yapıcı fonksiyonunu görmemiştik. C++11 ile birlikte taşıma yapıcı fonksiyonu
	ve taşıma semantiği dile eklenince "copy elision" kavramının da ismi "copy/move elisin" haline getirildi. Yani C++11 ve sonrasında yalnızca kopya yapıcı 
	fonksiyonunun elimine edilmesi değil eğer varsa taşıma yapıcı fonksiyonun da elimine edilmesi söz konusu olmaktadır. Bundan sonra biz de "copy elision" terimi 
	terine "copy/move elision" terimini kullanacağız. 
	
	Bazen copy/move elision işlemi ve taşıma semantiği konusu yeni başlayanlara karışık gelebilmektedir. Örneğin T bir sınıf belirtmek üzere aşağıdaki fonksiyonu
	inceleyinic:

	T foo()
	{
		T a;
		//...

		return a;
	}

	Anımsanacağı gibi bu return işleminde copy/move elision işlemi "istağe bağlı (optional)" durumdadır. Bu özel duruma NRVO (Named Return Value Optimization)
	dendiğini anımsayınız. Eğer burada derleyici copy/move elision yaparsa aslında a yerel nesnesini doğrudan geri dönüş değeri için kullanacağı nesne biçiminde 
	yaratır. Dolayısıyla return işlemi sırasında kopya da taşıma yapıcı fonksiyonları çağrılmaz. Şimdi derleyicinin böyle bir optimizasyonu yapmadığını dolayısıyşa 
	copy/move elision işlemini uygulamadığını düşünelim. Bu durumda return işlemi sırasında yaratılacak geçici nesne için T sınıfının hangi yapıcı fonksiyonu çağrılacaktır?
	Biz daha önce return ifadesinde bir yerel değişken ya da parametre değişkeninin ismi varsa bu değişkenin xvalue belirttiğini söylemiştik. O halde return işlemi 
	ile yaratılacak geçici T nesnesi için "eğer varsa T sınıfının taşıma yapıcı fonksiyonu" çağrılacaktır. Tabii eğer T sınıfının taşıma yapıcı fonksiyonu yoksa
	bu geçici T nesnesi için yine T sınıfının kopya yapıcı fonksiyonu çağrılacaktır. 

	Aslında return ifadesindeki nesnenin xvlaue belirtmesi C++14 ile birlikte dile eklendi. C++11'de buradaki nesne lvalue belirtmekteydi. Dolayısıyla programcının 
	geri dönüş değeri olarak yaratılacak nesne için taşıma yapıcı fonksiyonunun çağrılmasını sağlaması için move fonksiyonu kullanması gerekiyordu. Örneğin:

	T foo()
	{
		T a;
		//...

		return move(a);		// C++14 ve sonrasında move işlemine gerek yok, çünkü artık a zaten xvalue belirtiyor.
	}

	C++14 ve sonrasında move işlemine gerek yok, çünkü artık a zaten xvalue belirtmektedir.

	Şimdi foo fonksiyonunun aşağıdaki gibi kullanıldığını varsayalım:

	T foo()
	{
		T a;
		//...

		return a;
	}

	T t{foo()};

	Burada C++17 ve sonrasında kesinlikle t nesnesi için copy/move elision uygulanacaktır. Dolayısıyla aslında foo fonksiyonunun geri dönüş değeri doğrudan 
	t üzerinde oluşturulacaktır. Tabii C++17 öncesinde copy/move elisin bu durumda isteğe bağlı olduğu için eğer derleyici bu eleminasyonu yapmazsa t nesnesi 
	için T sınıfının varsa taşıma yapıcı fonksiyonunu çağıracaktı. Fakat mevcut satndartlarda yukarıdaki gibi kod aşağıdaki seçeneklerden biri biçiminde el alınmak 
	zorundadır:

	1) Eğer derleyici NRVO uygulamazsa bu durumda a yerel nesnesi için default yapıcı fonksiyon çağrılacaktır. return ifadesiyle doğrudan t için taşıma yapıcı 
	fonksiyonu çağrılacaktır. Tabii yerel a nesnesi için yıkıcı fonksiyon da çağrılacaktır. 

	2) Eğer derleyici NRVO uygularsa burada a yerel değişkeni doğrudan t üzerinde yaratılacaktır. Yani aslında foo içerisinde kullanılan a t nesnesi olacaktır. 
	Dolayısıyla burada yalnızca a nesnesi için default yapıcı foknksiyon çalıştırılmış olacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	NRVO ile geri dönüş değerindeki copy/move elision işleminin derleyiciler tarafından nasıl gerçekleştirildiğini merak edebilirsiniz. Örneğin:
	
	T foo()
	{
		T a;
		//...

		return a;
	}

	T t{foo()};

	Burada a yerel nesnesi doğrudan t üzerinde oluşturulacaktır. Pekiyi derleyici foo fonksiyonunu bağımsız bir biçimde derlerken buradaki a'nın aslında t olduğunu
	nereden bilecektir? İşte pek çok derleyici aslında bu tür durumlarda fonksiyona gizlice bu t nesnesinin adresini parametre olarak aktarmaktadır. Yani aslında
	derleyici yerel değişken a yerine ona parametre olarak geçirilen t'yi kullanmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taşıma semantiğinde taşınan nesnede değişiklik yapıldığını anımsayınız. O halde const sınıf nesneleri taşınamazlar. Örneğin:
	
	void foo(String k)
	{
		//...
	}
	//...

	const String s{"ankara"};
	//...

	foo(move(s));

	Burada s nesnesinin artık kullanılmayacağından dolayı foo fonksiyonun parametre değişkenine taşınmak istedndiğini düşünelim. Bu durumda amaçladığımız şey k 
	nesnesi için String sınıfının taşıma yapıcı fonksiyonunun çağrılmasıdır. Ancak bu durumda taşıma yapıcı fonksiyonu s üzerinde değişiklik yapmak isteyeceğinden
	zaten bunu yapamayacaktır. Pekiyi bu durum error mu oluşturacaktır? Aslında bu durumda move fonksiyonunun çağrılması geçerlidir. Ancak taşıma semantiği yerine 
	kopyalama semantiği devreye girecektir. Yani burada move çağrısının bir etkisi olmayacaktır. move fonksiyonu bir lvalue değerini T && türüne dönüştürerek 
	ondan bir xvalue oluşturmayı hedeflamektedir. Ancak bunu yaprken de const'luğu korumaktadır. Dolayısıyla yukarıdaki foo çağrısının eşdeğeri şöyşedir:

	foo(static_cast<const String &&>(s));

	Böyle bir çağrıda artık String sınııfnın taşıma yapıcı fonksiyonu "uygun (viable)" fonksiyon olmaz. Dolayısıyla k nesnesi için String sınıfının kopya yapıcı 
	fonksiyonu çağrılır. Başka bir deyişle burada move çağrısının aslında bir etkisi yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların kopya yapıcı fonksiyonları ve taşıma yapıcı fonksiyonları açıkça defaulted ya da deleted yapıabilir. Örneğin:
	
	class Sample {
	public:
		Sample() = default;
		Sample(const Sample &r) = delete;
		//...
	};

	Burada biz Sample sınıfı için kopya yapıcı fonksiyonunu yazmasaydık onu derleyici "memberwise copy" yapacak biçimde yazacaktı. Ancak biz bunu açıkça "deleted"
	hale getirdik. Dolayısıyla derleyic artık kopya yapıcı fonksiyonu bizim için yazmayacaktır. Örneğin:

	Sample s;
	Sample k(s);		// geçersiz! kopya yapıcı fonksiyonu yok!
	
	Açıkça silinmiş fonksiyonlar yine "overload resolution" işlemine sokulmaktadır. Ancak overload resolution işleminde eğer seçilirlerse "error" oluşturacaklardır. 
	Örneğin:

	class Sample {
	public:
		Sample() = default;
		Sample(const Sample &r);
		Sample(const Sample &&r) = delete;
		//...
	};
	//...

	Sample s;
	Sample k(move(s));		// geçersiz! burada move constructor seçilir ancak o da deleted yapılmıştır
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi biz yazmadığımız zaman taşıma yapıcı fonksiyonu otomatik olarak derleyici tarafından yazılmakta mıdır? İşte aslınd akopya yapıcı fonksiyonunun ve 
	taşıma yapıcı fonksiyonunun derleyici tarafından yazılmasına ilişkin bazı ayrıntılar vardır. 

	1) Mevcut standartlara göre "eğer programcı kendi sınıfı için taşıma yapıcı fonksiyonu ya da taşıma atama operatör fonksiyonu (bunu henüz görmedik)" yazmışsa
	(tanımlamışsa)bu durumda derleyici kopya atama operatör fonksiyonunu kendisi yazmamaktadır. (Standart terminolojisi ile ifade edilirse bu durumda kopya yapıcı 
	fonksiyonu "deleted" olmaktadır.) Eğer programcı kendi sınıfı için taşıma yapıcı fonksiyonu ya da taşıma atama operatör fonksiyonu yazmamışsa bu durumda derleyici
	kopya yapıcı fonksiyonunu "memberwise copy" yapacak biçimde kendisi yazmaktadır. (Standart terminolojisi ile ifade edilirse bu durumda kopya yapıcı fonksiyonu
	"defaulted" olmaktadır.) C++20 ile birlikte "eğer sınıfın kopya atama operatör fonksiyonu ya da	yıkıcı fonksiyonu programcı tarafından yazılmışsa ilerideki 
	C++ versiyonlarında kopya yapıcı fonksiyonunun derleyici tarafından yazılmayabileceği belirtilmiştir. Yani şimdilik biz sınıfımız için kopya atama operatör
	fonksiyonu ya da yıkıcı fonksiyonu yazmış olsak bile derleyici kopya yapıcı fonksiyonu kendisi yazmaktadır. Ancak sonraki versiyonlarda bu özel durum söz konusu 
	olduğunda derleyicinin kopya yapıcı fonksiyonu yazmayacağı standartlara eklenebilir. Bu tür durumlara standartlarda bir özelliğin "deprecated" yapılması 
	denilmektedir. 

	2) Mevcut standartlara göre eğer programcı sınıfı için kopya yapıcı fonksiyonu, kopya atama operatör fonksiyonunu, taşıma yapıcı fonksiyonunu ve yıkıcı fonksiyonu 
	yazmamışsa bu durumda derleyici sınıf için taşıma yapıcı fonksiyonunu kendisi yazmaktadır. (Standart terminolojisi ile ifade edilirse bu durumda taşıma yapıcı 
	fonksiyonu "defaulted" olmaktadır. Eğer programcı sınıfı için bu fonksiyonlardan herhangi birini yazarsa bu durumda taşıma yapıcı fonksiyonu "deleted" değil 
	"bildirilmemiş gibi (undeclared)" olmaktadır.

	Yukarıdaki kurallar ne anlama gelmektedir? 

	- Biz bir sınıf için taşıma yapıcı fonksiyonunu yazmışsak muhtemelen sınıfımızın kopya yapıcı fonksiyonuna da ihtiyacı olacaktır. Bu durumda derleyicinin 
	kopya yapıcı fonksiyonunu kendisinin yazması yanlışlıklara yol açabilecektir. (Derleyicinin "defaulted" yaptığı kopya yapıcı fonksiyonu memberwise copy yaptığı 
	için böcekler oluşabilecektir.) Aynı durum taşıma atama operatör fonksiyonu için de geçerlidir. 

	- Biz sınıfımız için kopya yapıcı fonksiyonu ya da kopya atama opreatör fonksiyonunu yazmışsak muhtemelen taşıma yapıcı fonksiyonuna da gereksinimimz olacaktır.
	Benzer sebeple bu durumda da derleyicinin taşıma yapıcı fonksiyonunu bizim için yazması böcek oluşmasına yol açabilecektir.

	- Biz bir sınıf için yıkıcı fonksiyon yazmışsak muhtemelen sınıfımızda yok edilecek bazı kaynaklar bulunmaktadır. Bu kaynakların bulunması da taşıma ve 
	kopyalamanın da gerekmesi anlamına gelmektedir. Bu nedenle yıkıcı fonksiyonun yazılmış olması derleyici tarafından kopya yapıcı fonksiyonun (bu durum henüz 
	deprecated)	ve taşıma yapıcı fonksiyonunun yazılmamasına yol açmaktadır. (eğer derleyici bu durumda bunları yazsaydı derleyicinin yaptığı memberwise-copy 
	işlemi yine böcek oluşmasına yol açabilirdi.)

	Derleyicinin kendisinin yazdığı taşıma yapıcı fonksiyonu T && parametresine sahiptir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi taşıma yapıcı fonksiyonu için yukarıda belirtitğimiz koşulların sağlanmış olduğunu düşünelim. Derleyicinin kendisinin yadzığı taşıma yapıcı fonksiyonu 
	ne yapmaktadır? İşte derleyicinin kendisinin yazdığı taşıma yapıcı fonksiyonu tıpkı kopya yapıcı fonksiyonu gibi sınıfın karşılıklı veri elemanlarını ilkdeğer
	veriliyormuş gibi birbirine kopyalamaktadır. Ancak derleyicinin yazdığı taşıma yapıcı fonksiyonu sanki bu işlemi move fonksiyonu ile yapıyormuş gibi bir etki 
	oluşturmaktadır. Özetle derleyicinin kendisinin yazdığı taşıma yapıcı fonksiyonu default olarak sınıfın karşılıklı veri elemanlarını taşımaktadır. Örneğin:

	class Student {
	public:
		Student(const String &name, int no) : m_name(name), m_no(no)
		{}
		String name() const { return m_name; }
		int no() const { return m_no; }

		void disp() const;
	private:
		String m_name;
		int m_no;
	};

	Buradaki Student sınıfı için derleyici hem kopya yapıcı fonksiyonunu hem de taşıma yapıcı fonksiyonunu kendisi yazacaktır. Derleyicinin kendisini yazdığı bu 
	fonksiyonlar tamamen aşağıdaki gibi olacaktır:

	Student::Student(const Student &r) : m_name(r.name), m_no(r.m_no)
	{}

	Student::Student(Student &&r) : m_name(move(r.name)), m_no(move(r.m_no))
	{}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															51. Ders 19/02/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz kopya yapıcı fonkdiyonunu gördükten sonra kopya atama operatör fonksiyonu hakkında da temel bilgiler vermiştik. Aynı sınıf türünden iki nesne biribirine
	atandığında sınıfın kopya atama operatör fonksiyonu çağrılıyordu. İşte nasıl kopya yapıcı fonksiyonu ile ilişkili kopya atama operatör fonksiyonu varsa benzer
	biçimde taşıma yapıcı fonksiyonu şle ilişkili olan "taşıma atama operatör fonksiyonu (move assignment operator" denilen bir fonksiyon da bulunmaktadır. 

	T bir sınıf belirtmek üzere sınıfın T &&, const T &&, volatile T && ve const volatile T && parametreli "operator =" isimli fonksiyonlarına" taşıma atama 
	operatör fonksiyonları denilmektedir. Pratikte en fazla kullanılan taşıma atama operatör fonksiyonu T && parametreli olandır. Biz taşıma atama operatör 
	fonksiyonunu hemen her zaman bu parametrik yapıya sahip bir biçimde görürüz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesine aynı sınıf türünden bir sağ taraf değeri (rvalue) atanmak istendiğinde sınıfın taşıma atama operatör fonksiyonu çağrılmaktadır. Örneğin:

	T a;
	//...

	a = T();

	Burada T() bir "prvalue" durumundadır. Yani bir sağ taraf değeridir. İşte bu durumda T sınıfının taşıma atama operatör fonksiyonu çağrılacaktır. Tabii sınıfın
	hem kopya atama operatör fonksiyonu hem de taşıma atama operatör fonksiyonu bir arada bulunabilir. (Bütüm fonksiyonlarda olduğu gibi atama operatör fonksiyonları 
	da "overload" edilmektedir.) Bu durumda "overload resolution" kuralları devreye girer ve uygun atama operatör fonksiyonu seçilir. Örneğin:

	class T {
	public:
		T &operator =(const T &);
		T &operator =(T &&) noexcept;
		//...
	};
	//...

	T a;
	T b;

	a = b;			// kopya atama operatör fonksiyonu çağrılacak
	a = T();		// taşıma atama operatör fonksiyonu çağrılacak

	Yukarıdaki örnekte a = b işleminin eşdeğeri şöyledir:

	a.operator =(b);

	Burada b bir lvalue belirttiğine göre zaten yalnızca kopya atama operatör fonksiyonu uygun fonksiyon durumundadır. Dolayısıyla kopya atama operatör fonksiyonu
	çağrılacaktır.a = T() işleminin ise eşdeğeri şöyledir:

	a.operator=(T());

	Burada her iki atama operatör fonksiyonu da uygun fonksiyonlardır. Ancak anımsanacağı gibi T && parametreli fonksiyon daha iyi dönüştürme sağlamaktadır. 
	Dolayısıyla burada taşıma atama operatör fonksiyonu çağrılacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taşıma atama operatör fonksiyonuna taşıma yapıcı fonksiyonu ile aynı nedenden dolayı gereksinim duyulmaktadır. Zaten sınıfın taşıma yapıcı fonksiyonu varsa
	taşıma atama operatör fonksiyonun da olmasını bekleriz. Bir nesneye aynı sınıf türünden bir sağ taraf değeri atandığında söz konusu sağ taraf değeri zaten
	atama sonrasında yaşımını yitireceğinden dolayı onun kaynakları atanan nesne tarafından çalılanbilir. Böylece gereksiz bir kopyalamanın önüme geçilmiş olur. 
	Tabii tıpkı taşıma yapıcı fonksiyonunda olduğu gibi taşıma atama operatör fonksiyonu da C++'a C++11 ile sokulmuştur. C++11 öncesinde böylesi bir iyileştirme 
	yapılamıyordu. Dolayısıyla bu tür durumlarda kopyalama yapılıyordu.

	Pekiyi taşıma atama operatör fonksiyonu nasıl yazılmalıdır? Aslında daha önceden de belirttiğimiz gibi operatör fonksiyonları ayrı bir başlık altında 
	değerlendireceğimiz bir konudur. Biz burada bu fonksiyonun yazımına ilişkin reçete vereceğiz. Taşıma atama operatör fonksiyonun da geri dönüş değeri 
	kendi sınıfı türünden referans parametreli olmalıdır. Bu fonksiyonları da *this ifadesiyle geri döndürmeliyiz. Bunun dışında kaynak çalma süreci taşıma 
	yapıcı fonksiyonunda olduğu gibidir. Ancak bir atama işlemi söz konusu olduğu için atamadaki hedef nesnenin atama öncesindeki bazı kaynaklarının boşaltılması
	da gerekebilecektir. Örneğin String sınıfı için taşıma atama operatör fonksiyonu şöyle yazılabilir:

	class String {
	public:
		//...
		String &operator =(String &&r) noexcept;
		//...
	private:
		char *m_str;
		size_type m_size;
		size_type m_capacity;
	};

	String &String::operator =(String &&r) noexcept
	{
		if (this == &r)
			return *this;

		delete[] m_str;				// hedefin eskidne gösterdiği yer delete ediliyor

		m_str = r.m_str;			// kaynak nesnenin kaynakları çalınıyor
		m_size = r.m_size;
		m_capacity = r.m_capacity;

		r.m_str = nullptr;			// kaynak nesnenin geçerli bir durumda bırakılması gerekir

		return *this;
	}

	Burada önce atamanın yapıldığı hedef nesnesin daha önce gösterdiği alan delete edilmiş sonra kaynak nesnenin gösterdiği alan ondan çalınmıştır. Tabii 
	kaynak nesnenin m_str elemanına nullptr yerleştirilerek onun geçerli bir durumda kalması sağlanmıştır. Aslında bu işlem nesnelerin m_str veri elemanlarının
	karşılıklı biçimde yer değiştirilmesiyle de sağalanabilirdi. İki nesneyi karşılıklı yer değiştirmek için C++'ın standart kütüphanesinde swap isimli bir 
	fonksiyon şablonu bulunmaktadır. Yukarıdaki taşıma atama operatör fonksiyonu aşağıdaki gibi de yazılabilirdi:

	String &String::operator =(String &&r) noexcept
	{
		if (this == &r)
			return *this;

		swap(m_str, r.m_str);

		m_size = r.m_size;
		m_capacity = r.m_capacity;

		return *this;
	}

	Burada biz kaynak nesne ile hedef nesnenin m_str elemanlarını yer değiştirdik. Dolayısıyla bizim artık hedef nesnenin m_str elemanını delete etmemize gerek 
	kalmamıştır. Nasıl olsa kayna nesne yok edilirken bu alanı delete edecektir. Burada bir noktaya dikkatinizi çekmek istiyoruz. Biz yukarıdaki kodda yalnızca 
	nesnelerin m_str elemanlarını yer değiştirdik. Bu durumda kaynak nesnenin m_size ve m_capacity elemanları olması gereken değerde olmayacaktır. Pekiyi bu 
	durum bir sorun oluşturur mu? Aslında buradaki kaynak nesnenin yalnızca "destruct edilebilmesi" yeterlidir. Ancak nesnenin bu haliyle "destruct" edilebildiği 
	halde "geçerli" bir durumda olmadığına dikkat ediniz. Kaynak nesne geçici bir nesne ise zaten bu işlemden sonra yok edilecektir. Ancak kaynak nesne move 
	ile taşınmışsa hala yaşamaya devam ediyor olabilir. Biz daha önce taşınan nesnenin bir daha kullanılmaması gerektiğini belirtmiştik. İşte eğer burada kaynak 
	nesne move ile taşınmışsa onun daha sonra kullanılması soruna yol açabilir. Tabii bu tür durumlarda nesneyi tam geçerli durumda bırakmak için diğer elemanlar 
	da swap edilebilir. Örneğin:

	String &String::operator =(String &&r) noexcept
	{
		if (this == &r)
			return *this;

		swap(m_str, r.m_str);
		swap(m_size, r.m_size);
		swap(m_capacity, r.m_capacity);

		return *this;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz daha önce "kendi sınıfımız için kopya atama operatör fonksiyonunu yazmazsak bu operatör fonksiyonunun sınıfın karşılıklı veri elemanlarını birbirine 
	atayacak biçimde derleyici tarafından yazıldığını" belirtmiştik. Pekiyi ya taşıma atama operatör fonksiyonunu yazmazsak ne olur? İşte kopya atama operatör 
	fonksiyonunun ve taşıma atama operatör fonksiyonun derleyici tarafından yazılıp yazılmayacağına ilişkin bazı ince kurallar bulunmaktadır:

	1) Eğer sınıfımız için biz "taşıma yapıcı fonksiyonu ya da taşıma atama operatör yazmışsak bu durumda kopya atama operatör fonksiyonu "deleted" yapılmaktadır. 
	Ancak bu iki fonksiyonu da sınıfımızda yazmamışsak kopya atama operatör fonksiyonu "defaulted" yapılmaktadır. Yani derleyici tarafından sınıfın karşılıklı veri 
	elemanlarının birbirine atanmasını sağlamaktadır. Ancak bu defaulted durum mevcut standartlarda "deprecated" durumdadır. Yani sonraki standartlarda sınıfın 
	kopya yapıcı fonksiyonun ya da yıkıcı fonksiyonunun olması durumunda kopya atama operatör fonksiyonunun "deleted" olabielceği belirtilmiştir.

	2) Eğer sınıfımız için biz "kopya yapıcı fonksiyonunu" ya da "kopya atama operatör fonksiyonunu" ya da "taşıma yapıcı fonksiyonunu" ya da yıkıcı fonksiyonu 
	yazmışsak taşıma atama operatör fonksiyonu derleyici tarafından yazılmamaktadır. (Derleyici bu fonksiyonu "deleted" yapmamaktadır. "undeclared" yapmaktadır.)
	Eğer bu fonksiyonların hiçbiri yazılmadıysa bu durumda taşıma atama operatör fonksiyonu derleyici tarafından sınıfın karşılıklı veri elemanlarını move ile 
	atayacak biçimde (yani taşıyacak biçimde) yazılmaktadır.

	Örneğin:

	class Student {
	public:
		Student(const String &name, int no) : m_name(name), m_no(no)
		{}

		String name() const { return m_name; }
		int no() const { return m_no; }

		void disp() const;
	private:
		String m_name;
		int m_no;
	};

	Buradaki Student sınıfı için derleyici aşağıdaki özel fonksiyonlrın hepsini kendisi default işlem yapacak biçimde yazacaktır:

	- Kopya yapıcı fonksiyon
	- Taşıma yapıcı fonksiyon
	- Kopya tama operatör fonksiyonu
	- Taşıma atama operatör fonksiyonu

	Yani bu sunı için bizim fonksiyonları yazmamıza hiç gerek yoktur. Örneğin:

	Student x{"Ali Serce",123};
	//...

	x = Student{"NecatiErgin, 456"};

	Burada derleyicinin yazdığı taşıma atama operatör fonksiyonu çağrılacak ve zaten sınıfın m_name ve m_no elemanları taşınacaktır. Yani burada m_name için
	kaynaklar kaynak nesneden çalınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte hangi "özel üye fonksiyonların (special member function)" derleyici tarafından "ne zaman" yazılıp yazılmayacağı konusu iyice karmaşık hale
	gelmiştir. Programcıların yukarıdaki kuralları akılda tutması zor olabilmektedir. Bu nedenle bazı kitaplarda yer alan aşağıdaki tabloyu vermek istiyoruz.
	Bir özel üye fonksiyonun "deleted" yapılmasıyla "hiç yazılmaması (not declared)" arasında küçük bir farklılık vardır. Bir özel üye fonksiyon "deleted" ise
	"isim aramasında o fonksiyon seçilirse" error oluşmaktadır. Halbuki bir özel fonksiyon "not declared" ise isim aramsına zaten o fonksiyon girmeyecektir. 
	Dolayısıyla ona rakip olan fonksiyon seçilecektir. Örneğin taşıma atama operatör fonksiyonun "deleted" olduğunu varsayalım:

	T a;

	a = T(b);		// geçersiz! derleme sırasında error oluşur

	Şimdi de taşıma atama operatör fonksiyonun "not declared" olduğunu varsayalım:

	T a;

	a = T(b);		// geçerli, kopya atama operatör fonksiyonu en uygun fonksiyon olarak seçilir.


							default constructor		destructor			copy constructor	copy assignment		move constructor		move assignment 

nothing						default					    default             default             default                 default				default

any constructor				not declared				default				default             default                 default				default

default constructor			user declared				default				default             default                 default				default

destructor					default						user declared		default				default 				not declared        not declared
																			(deprecated)		(deprecated)

copy constructor			not declared				default				user declared		default					not declared		not decalred
																								(deprecated)

copy assignment				default						default				default				user declared			not declared		not declared
																			(deprecated)

move constructor			not declared				default				deleted				deleted					user declared		not declared

move assignment				not declared				default				deleted				deleted					not declared		user declared

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Özel üye fonksiyonlar ister "defaulted" ister "deleted" isterse "not declared" olsun. Biz onları istediğimiz zaman ""= default", "= delete"sentaksıyla 
	defaulted ya da deleted hale getirebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														52. Ders 21/02/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Kopya yapıcı fonksiyonu, taşıma yapıcı fonksiyonu, kopya atama operatör fonksiyonu ve yaşıma atama operatör fonksiyonu konularını pekiştirebilmek için 
	bir Matrix sınıfı örneği vermek istiyoruz. Örneğimizdkei Matrix sınıfının bildirimi şöyledir:

	class Matrix {
	public:
		Matrix();
		Matrix(size_t rowsize, size_t colsize);
		Matrix(const Matrix &r);
		Matrix(Matrix &&r) noexcept;
		~Matrix();
		void disp() const;
		Matrix add(const Matrix &r) const;
		Matrix sub(const Matrix &r) const;
		Matrix mul(const Matrix &r) const;
		Matrix matmul(const Matrix &r) const;
		Matrix div(const Matrix &r) const;
		double &at(size_t row, size_t col);
		const double &at(size_t row, size_t col) const;

		Matrix &operator =(const Matrix &r);
		Matrix &operator =(Matrix &&r) noexcept;
	private:
		double *m_matrix;
		size_t m_rowsize;
		size_t m_colsize;
	};

	Buradaki Matrix sınıfı double türden satır ve sütun uzunluğu belirli olan bir matrisin bilgilerini tutup onun üzerinde işlemler yapmaktadır. Matrisin elemanları
	tek boyutlu bir dizi biçiminde tutulmaktadır. SInıfın add, sub, mul ve div fonksiyonları matrisin karşılıklı elemaları üzerinde işlem yapmaktadır. matmul ise
	matris çarpımını gerçekleştirmektedir. Aşağıdaki koda dikkat ediniz:

	Matrix x{3, 2}, y{3, 2}, z;

	z = x.add(y);

	Burada x.add(y) işleminden bir rvalue elde edilecektir. Dolayısıyla atama işlemi "taşıma atama operatör fonksiyonuyla" gerçekleştirilecektir. Örneğin:

	Matrix z{x.add(y)};

	Burada C++17 ve sonrasında "copy/move elision" zorunlu hale getirildiğinden add fonksiyonunun geri dönüş değeri doğrudan z nesnesi üzerinde oluşturulacaktır. 
	Sınıfın add üye fonksiyonun nasıl yazıldığına dikkat ediniz:

	Matrix Matrix::add(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] + r.m_matrix[i];
	
		return result;
	}

	Burada return ifadesindeki result nesnesi "xvalue" biçimindedir. Dolayısıyla geri dönüş değeri için sınıfın taşıma yapıcı fonksiyonu çağrılacaktır. Bu durumda 
	sınıfta taşıma yapıcı fonksiyonu olmasaydı kopya yapıcı fonksiyonu çağrılacaktı. Tabii aslında bu durumda derleyicimiz NRVO ile "copy/move" elision işlemini de
	isteğe bağlı bir biçimde yapabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// matrix.hpp

#ifndef MATRIX_HPP_
#define MATRIX_HPP_

#include <cstddef>

namespace CSD
{
	class Matrix {
	public:
		Matrix();
		Matrix(size_t rowsize, size_t colsize);
		Matrix(const Matrix &r);
		Matrix(Matrix &&r) noexcept;
		~Matrix();
		void disp() const;
		Matrix add(const Matrix &r) const;
		Matrix sub(const Matrix &r) const;
		Matrix mul(const Matrix &r) const;
		Matrix matmul(const Matrix &r) const;
		Matrix div(const Matrix &r) const;
		double &at(size_t row, size_t col);
		const double &at(size_t row, size_t col) const;

		Matrix &operator =(const Matrix &r);
		Matrix &operator =(Matrix &&r) noexcept;
	private:
		double *m_matrix;
		size_t m_rowsize;
		size_t m_colsize;
	};
}

#endif

// matrix.cpp

#include <iostream>
#include <cstring>
#include "matrix.hpp"

using namespace std;

namespace CSD 
{
	Matrix::Matrix() : m_matrix(nullptr), m_rowsize(0), m_colsize(0)
	{}

	Matrix::Matrix(size_t rowsize, size_t colsize) 
	{
		m_matrix = new double[rowsize * colsize];
		m_rowsize = rowsize;
		m_colsize = colsize;
	}

	Matrix::Matrix(const Matrix &r)
	{
		m_matrix = new double[r.m_rowsize * r.m_colsize];
		memcpy(m_matrix, r.m_matrix, r.m_rowsize * r.m_colsize * sizeof(double));
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;
	}

	Matrix::Matrix(Matrix &&r) noexcept
	{
		m_matrix = r.m_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		r.m_matrix = nullptr;
	}

	Matrix::~Matrix()
	{
		delete[] m_matrix;
	}

	void Matrix::disp() const
	{
		for (size_t row = 0; row < m_rowsize; ++row) {
			for (size_t col = 0; col < m_colsize; ++col)
				cout << m_matrix[row * m_colsize + col] << ' ';
			cout << endl;
		}
	}

	Matrix Matrix::add(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] + r.m_matrix[i];
	
		return result;
	}

	Matrix Matrix::sub(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] - r.m_matrix[i];

		return result;
	}

	Matrix Matrix::mul(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] * r.m_matrix[i];

		return result;
	}

	Matrix Matrix::matmul(const Matrix &r) const
	{
		if (m_colsize != r.m_rowsize)
			throw invalid_argument("matrix size mismatch");

		Matrix result{m_rowsize, r.m_colsize};
		double total;

		for (size_t i = 0; i < m_rowsize; ++i)
			for (size_t k = 0; k < r.m_colsize; ++k) {
				total = 0;
				for (size_t j = 0; j < m_colsize; ++j)
					total += m_matrix[i * m_colsize + j] * r.m_matrix[j * r.m_colsize + k];
				result.m_matrix[i * result.m_colsize + k] = total;
			}

		return result;
	}

	Matrix Matrix::div(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] / r.m_matrix[i];

		return result;
	}

	double &Matrix::at(size_t row, size_t col)
	{
		if (row >= m_rowsize || col >= m_colsize)
			throw invalid_argument("invalid index");

		return m_matrix[row * m_colsize + col];
	}

	const double &Matrix::at(size_t row, size_t col) const
	{
		if (row >= m_rowsize || col >= m_colsize)
			throw invalid_argument("invalid index");

		return m_matrix[row * m_colsize + col];
	}

	Matrix &Matrix::operator =(const Matrix &r)
	{
		if (this == &r)
			return *this;

		if ((m_rowsize != 0 && m_colsize != 0) 
			&& (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize))
				throw invalid_argument("invalid matirx dimensions");

		double *new_matrix = new double[r.m_rowsize * r.m_colsize];
		
		delete[] m_matrix;

		memcpy(new_matrix, r.m_matrix, r.m_rowsize * r.m_colsize * sizeof(double));
		m_matrix = new_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		return *this;
	}

	Matrix &Matrix::operator =(Matrix &&r) noexcept
	{
		if (this == &r)
			return *this;

		if ((m_rowsize != 0 && m_colsize != 0)
			&& (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize))
			throw invalid_argument("invalid matirx dimensions");
		
		delete[] m_matrix;
		
		m_matrix = r.m_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		r.m_matrix = nullptr;
		
		return *this;

	}
}

// app.cpp

#include <iostream>
#include "matrix.hpp"

using namespace std;
using namespace CSD;

int main()
{
	Matrix x{3, 2}, y{2, 4};

	x.at(0, 0) = 1;
	x.at(0, 1) = 2;
	x.at(1, 0) = 3;
	x.at(1, 1) = 4;
	x.at(2, 0) = 5;
	x.at(2, 1) = 6;

	y.at(0, 0) = 1;
	y.at(0, 1) = 2;
	y.at(0, 2) = 3;
	y.at(0, 3) = 4;
	y.at(1, 0) = 5;
	y.at(1, 1) = 6;
	y.at(1, 2) = 7;
	y.at(1, 3) = 8;

	x.disp();
	cout << "-------------" << endl;
	y.disp();
	cout << "-------------" << endl;
	
	Matrix result;

	result = x.matmul(y);
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													53. Ders 26/02/2024 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte bazı programlama dillerinde var olan sınıf nesnelerine küme parantezi ile ilkdeğer verme imkanı da dile eklenmiştir. Örneğin:

	vector<int> v{1, 2, 3, 4, 5};

	Burada dinamik büyütülen diziyi temsil eden vector isimli bir şablon sınıf türünden bir nesne yaratılmıştır. Ancak nesnenin aynı zamanda küme parantezleri 
	içerisindeki ddeğerleri tutması da sağlanmıştır. C++ standartlarında nesnelere bu biçimde küme parantezleriyle ilkdeğer verilmesine genel olarak 
	"list initialization" denilmektedir. Bu özelliğin uygulanabilmesi için initializer_list isimli bir sınıf şablonu da C++11 ile standartlara eklenmiştir. 
	initializer_lits sınıfı bir şablon sınıf olduğu için açısal parantezler içerisinde tür belirten bir ifadenin bulundurulması gerekmektedir. Örneğin:

	initialzier_list<int> il;

	initializer_list nesnesi yaratılırken açısal parantezler içerisinde belirtilen tür bu nesnenin "hangi türden elemanları" tutacağını belirtmektedir. 
	BuYukarıdaki örnekte il nesnesi "int" türden elemanlara ilişkindir. initialzier_list sınıfı <initializer_list> isimli bir başlık dosyasında bildirilmiştir. 
	Dolayısıyla bu sınıfı kullanabilmek için bu başlık dosyasının include edilmesi gerekir. initializer_list sınıfının üç public üye fonksiyonu vardır: size, 
	begin ve end. size üye fonksiyonu bize dizinin uzunluğunu belirten size_t türünden bir değer geri döndürür. begin üye fonksiyonu dizinin ilk elemanın 
	adresini, end üye fonksiyonu ise "dizinin son elemanından sonraki" adresi geri döndürmektedir.
	
	Bir initializer_list nesnesi default yapıcı fonksiyonla yaratılabilir. Örneğin:

	initialzier_list<int> il;

	Bu durumda nesne boş diziyi belirtmektedir. Dolayısıyla size üye fonksiyonu 0 değerini verecektir. begin ve end üye fonksiyonları da tipik olarak nullptr
	değerlerini verir. Ama aslında initializer_list nesneleri küme parantezleriyle ilkdeğer verilerek yaratılır. Örneğin:

	initialzier_list<int> il = {10, 20, 30, 40, 50};

	Burada ilkdeğer verilirken '=' atmonun bulundurulup bulundurulmaması arasında bir farklılık yoktur. Yani yukarıdaki ilkdeğer verme aşağıdaki ile tamamen 
	eşdeğerdir:

	initialzier_list<int> il{10, 20, 30, 40, 50};

	Pekiyi burada ne olmaktadır? Bu durumda derleyici "ilgili türden const bir dizi oluşturur ve küme parantezi içerisinde belirtilen elemanları tek tek bu diziye 
	yerleştirir. Sonra da initializer_list nesnesinin veri elemanlarına bu diziyi belirtecek biçimde ilkdeğerlerini verir. Yani artık buradaki il nesnesi ile size 
	üye fonksiyonunu çağırırsak küme parantezleri içerisinde yazdığımız elemanların sayısını elde ederiz. begin üye fonksiyonunu çağırırsak oluşturulan dizinin 
	başlangıç adresini (yani oluşturulan dizinin ilk elemanının adresini), end üye fonksiyonu çağırırsak oluşturulan dizinin son elemanından sonraki adresi 
	elde ederiz. Burada nesnenin elemanlarına değerlerini derleyicinin yerleştirdiğine dikkat ediniz. Tabii bize arayüz olarak size, begin ve end üye fonksiyonları 
	verilmiştir. Standartlar sınıfın private bölümünde nelerin olduğunu açıklamamaktadır. Ancak tipik olarak sınıfta iki private veri elemanı bulundurulmaktadır. 
	Bu iki eleman ilgili dizinin başını ve sonunu tutan iki gösterici olabileceği gibi, ilgili dizinin başına tutan bir gösterici ile dizinin uzunluğunu tutan 
	size_t tütünden bir nesne de olabilir. 

	initializer_list sınıfının begin ve end üye fonksiyonları const bir adres vermektedir. Bu fonksiyonlar aynı zamanda constexpr fonksiyonlardır. size üye 
	fonksiyonu da constexpr bir fonksiyondur. 

	Bir initializer_list nesnesi küme parantezleriyle ilkdeğer verilerek oluşturulduğunda derleyicinin küme parantezleri içerisindeki değerleri ilgili türden
	const bir dizinin içerisine yerleştirdiğini belirtmiştik. Bu dizi derleyici tarafından yaratılmaktadır. Bu nedenle "geçici bir nesne (temporaray object)"
	niteliğindedir. Standartlara göre küme parantezleri ile initializer_list nesnesine ilkdeğer veridliğinde derleyici tarafından yaratılan sont türden bu 
	geçici dizi initializer_list nesnesi yaşadığı sürece yaşamakta bu nesne yaşamını kaybettiğinde bu dizi de yaşamını kaybatmektedir. Başka bir deyişle bu dizinin
	ömrü inializer_list nesnesinin ömrü kadardır. Örneğin:

	initializer_list<int> il{10, 20, 30, 40, 50};

	Burada 10, 20, 30, 40, 50 değerlerini tutan dizi il nesnesi yaşadığı sürece yaşamını devam ettirecektir. 

	Anımsanacağı gibi C++11 ve sonrasında bütün küme parantezleri ile ilkdeğer verme işleminde "narrowing conversion" kuralı uygulanmaktadır. Örneğin:

	initializer_list<int> il = {10, 20, 30.2, 40, 50};		// geçersiz!		

	Ancak örneğin:

	initializer_list<double> il = {10, 20, 30.2, 40, 50};		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Mademki biz initializer_list sınıfının begin ve end fonksiyonları ile derleyici tarafından yaratılan dizinin başlangıç ve bitiş adreslerini elde edebiliyoruz, 
	o halde bu dizinin elemanlarına da erişebiliriz. Örneğin:

	initializer_list<int> il = {10, 20, 30, 40, 50};
	const int *pi1, *pi2;

	pi1 = il.begin();
	pi2 = il.end();

	while (pi1 != pi2) {
		cout << *pi1 << " ";
		++pi1;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <initializer_list>

using namespace std;

int main()
{
	initializer_list<int> il = {10, 20, 30, 40, 50};
	const int *pi1, *pi2;

	pi1 = il.begin();
	pi2 = il.end();

	while (pi1 != pi2) {
		cout << *pi1 << " ";
		++pi1;
	}
	cout << endl;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	initializer_list sınıfının begin ve end üye fonksiyonlarının olması nedeniyle bu sınıf iteratör desteğine sahiptir. Dolayısıyla aralık tabanlı for döngülerinde
	kullanılabilmektedir. Örneğin:

	initializer_list<int> il = {10, 20, 30, 40, 50};
	
	for (int x : il)
		cout << x << " ";
	cout << endl;

	Burada değişken bir referans olabilir ancak begin üye fonksiyonu const bir adres geri döndürüğü için referansın da const olması gerekir. Örneğin:

	for (const int &x : il)		// referansın const olması gerekir
		cout << x << " ";
	cout << endl;

	Benzer biçimde yukarıdaki örnekte auto belirleyicisi kullanılırsa referans olmadığı durumda x int türden referans olduğu durumda const int & türünden olacaktır. 
	Örneğin:
		
	for (auto &x : il)			// burada x const int & türünden
		cout << x << " ";
	cout << endl;
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonun parametre değişkeni initializer_list türünden olabilir. Bu durumda fonksiyon doğrudan küme parantezleri ile çağrılabilir. Örneğin:

	void foo(initializer_list<int> il)
	{
		for (auto x : il)
			cout << x << " ";
		cout << endl;
	}

	int main()
	{
		foo({10, 20, 30, 40, 50});
		
		return 0;
	}

	Burada yapılan işlemin aşağıdakinden bir farkı yoktur:

	initializer_list<int> il = {10, 20, 30, 40, 50};

	Benzer biçimde fonksiyonun geri dönüş değeri de initializer_list türünden olabilir. Örneğin:

	iinitializer_list<int> foo()
	{
		//...
	}

	Standartlara göre initializer_list nesnesine küme parantezleriyle ilkdeğer verildiğinde bu işlem sanki bir referansa geçici bir nesneyle ilkdeğer veriliyormuş
	gibi ele alınmaktadır. Yani bu durumda yaratılan geçici dizi yukarıda da belirttiğimiz gibi initializer_list nesnesi yaşadığı sürece yaşamaktadır. Aşağıdaki 
	kodu inceleyiniz:

	const int &foo()
	{
		return 10;
	}

	int x;

	x = foo();

	C++'ta fonksiyonun içerisinde yaratılmış olan geçici nesneler fonksiyon çağrısı bittikten sonra "referansa bind edilseler bile" yok edilmektedir. Dolayısıyla 
	yukarıda kod tanımsız davranışa yol açacaktır. Şimdi aşağıdaki kodu inceleyiniz:

	initializer_list<int> foo()
	{
		return {10, 20, 30, 40, 50};
	}

	initializer_list nesnesine küme paranteziyle değer atamaının bir referansa geçici nesneyle değer atamaktan bir farkı yoktur. Burada da küme parantezleri 
	içerisindeki değerlerin yerleştirildiği geçici dizi fonksiyon bittiğinde yok edilecektir. Dolayısıyla burada da aynı biçimde bir hata yapılmıştır. Örneğin:

	initializer_list<int> foo(initializer_list<int> il)
	{
		return il;
	}

	auto result = foo({10, 20, 30, 40, 50});

	Bu kod da benzer bir soruna yol açacaktır. Fonksiyonun parametre değişkeni yok edildiğinde derleyici tarafından yaratılan geçici dizi de yok edilecektir. 
	Dolayısıyla benzer bir durum oluşacaktır.

	initializer_list türünden referanslar tanımlanabilir. Ancak initializer_list nesneleri zaten çok az veri elemanına sahiptir. Dolayısıyla onların adres yoluyla
	fonksiyonlara aktarılması ile değer yoluyla fonksiyonlara aktarılması arasında bir performans kazancının sağlanması beklenmemelidir. Örneğin:

	void foo(const initializer_list<int> &il)
	{
		//...
	}
	//...

	foo({10, 20, 30, 40, 50});

	Bu çağrı geçerlidir. Burada yine derleyici bir geçici dizi ve bir de geçici initializer_list nesnesi oluşturup onun adresini parametre değişkenine aktaracaktır. 
	Dolayısıyla burada bir performans kazancı söz konusu olmayacaktır. Çünkü burada zaten derleyici yine bir initializer_list nesnesini kendisi oluşturmaktadır. 
	Yani burada yine aslında bir nesnin yaratılması söz konusu olmaktadır. Yani yukarıdaki kodrun eşdeğeri aslında şöyle olmaktadır:

	foo(initializer_list<int>({10, 20, 30, 40, 50}));
	
	Bu nedenle pratikte programcılar initializer_list türünden referanslar yerine doğrudan initializer_list nesnelerin kendisini kullanmayı tercih etmektedir. Yukarıda 
	da belirtitğimiz gibi genel initializer_list nesneleri zaten az yer kapladığı için onların fonksiyonlara adres yoluyla aktarılmasıyla değer yoluyla aktarılması 
	arasında önemli bir performans farkı yoktur. Örneğin:

	void foo(initializer_list<int> &il)
	{
		//...

	}
	//...

	initializer_list<int> il = {10, 20, 30, 40, 50};
	//...
	foo(il);

	Burada foo fonksiyonunun parametresinin referans yapılması önemli bir performans kazancı oluşturmayacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi biz iç içe küme parantezleriyle bir nesneye ilkdeğer vermek istersek buradaki initilizer_list türü ne olacaktır? Örneğin:

	initializer_list<?> ils = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}};		

	Barada ? yerine biz int yerleştiremeyiz. İşte bu tür durumlarda initializer_list türünün kendisi de initializer_list türünden olmalıdır. Örneğin:

	initializer_list<<initializer_list<int>> ils = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}};		// geçerli

	Burada ils nesnesi aslında initializer_list nesnelerinin bulunduğu bir diziyi belirtmektedir. Dolayısıyla biz burada ils nesnesini aralık tabanlı for 
	döngüsüyle dolaşırsak initializer_list<int> nesnelerini elde ederiz. Onu da dolaşırsak int nesnelerini elde ederiz. Örneğin:

	initializer_list<initializer_list<int>> ils  = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

	for (initializer_list<int> il : ils) {
		for (int x : il)
			cout << x << " ";
		cout << endl;
	}

	Aşağıda bu duruma ilişkin bir örnek verilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <initializer_list>

int main()
{
	initializer_list<initializer_list<int>> ils  = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

	for (initializer_list<int> il : ils) {
		for (int x : il)
			cout << x << " ";
		cout << endl;
	}
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli birden fazla initializer_list parametresine sahip fonksiyon olabilir. Bu durumda overload resolution işleminde küme parantezleri içerisindeki 
	değerlerin türlerine bakılır. Bu türle tam uyuşum sağlayan fonksiyon varsa doğal olarak o seçilecektir. Örneğin:

	void foo(initializer_list<int> il)
	{
		cout << "initializer_list<int>" << endl;
	}

	void foo(initializer_list<double> il)
	{
		cout << "initializer_list<double>" << endl;
	}

	Burada foo fonksiyonunu şöyle çağırmış olalım:

	foo({10, 20, 30, 40, 50});		// initilaizer_list<int> parametreli olan fonksiyon çağrılır

	initializer_list<int> parametresine sahip olan fonksiyon çağrılacaktır. Fonksiyonu şöyle çağırmış olalım:

	foo({10.1, 20.2, 30, 40, 50});		// ambiguity error

	Burada verilen ilkdeğerlerin türlerinin bir kısmı int bir kısmı double biçimdedir. Dolayısıyla ambiguity oluşacaktır. Çünkü burada derleyici 
	initializer_list<int> ve initializer_list<double> arasında bir seçim yapamamktadır. Buradaki overload resolution sürecinde şöyle bir kural vardır:
	Küme parantezi içerisindeki her değer initializer_list<T> parametresindeki T türüne otomatik dönüştürülmeye çalışılır. Buradaki en kötü kalitedeki dönüştürme
	overload resolution işleminde otomatik dönüştürme kategorisi olarak ele alınmaktadır. Burada önemli olan noktalardan biri de şudur: Normalde küme 
	parantezleri "daraltıcı dönüştürmelere (narrowing conversions)" izin vermemektedir. Ancak overload resolution işleminde daraltıcı dönüştürme uygulayan
	fonsiyonlar da sanki "uygun (viable)" fonksiyon gibi en uygun fonksiyonun seçimindeki yarışa sokulmaktadır. Eğer bu yarışta daraltıcı dönüştürme uygulayan 
	fonksiyon seçilirse bu durumda error oluşur. Başka bir deyişle "daraltıcı dönüştümenin uygulanıp uygulanmadığına en uygun fonksiyon seçildikten sonra"
	bakılmaktadır. Örneğin:

	void foo(initializer_list<int> il);
	void foo(initializer_list<double> il);
	//...

	foo({1, 2, 3.14, 4, 5});				// ambiguity error

	Burada her fonksiyon da aday ve uygun kabul edilmektedir. Birinci fonksiyon için elemanlardan int türüne en kötü dönüştürme "standart dönüştürme 
	(standart conversion)", ikinnci fonksiyon için de elemanlardan double türüne en kötü dönüştürme standart dönüştürmedir. Bu durumda her iki fonksiyon 
	da eşit iyilikte ya da kötülüktedir. Örneğin:

	foo({1.1, 2.2, 3.3f, 4.4, 5.5});		// initializer_list<double>

	Burada birinci fonksiyon için en kötü dönüştürme "standart dönüştürme", ikinci fonksiyon için en kötü dönüştürme "double türüne yükseltme (floating point 
	promotion)" biçimindedir. Dolayısıyla burada initializer_list<double> parametresine sahip olan fonksiyon seçilecektir. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

	Tabii initializer_list nesnesine boş küme parantezleri ile de ilkdeğer verilebilir. Bu durumda nesnenin size üye fonksiyonu 0 değerini verecektir. Standartlar 
	bu durumda begin ve end üye fonksiyonlarının hangi değeri vereceği konusunda bir şey söylememiştir. Ancak tipik olarak bu fonksiyonlar nullptr ile geri dönerler. 
	Tabii bizim size değeri 0 iken begin fonksiyonunun geri döndürdüğü adrese erişmememiz gerekir. Örneğin:

	initialzier_list<int> il = {};		// geçerli

	cout << il.size() << endl;			// 0

	Aralık tabanlı for düngüsünde doğrudan küme parantezi içerisinde değerler kullanılabilir. Bu durumda bu küme aparantezi içerisindeki değerler derleyici tarafından 
	initilizer_list nesnesine dönüştürülmektedir. Örneğin:
	
	for (int x : {10, 20, 30, 40, 50})
		cout << x << " ";
	cout << endl;
	
	Burada derleyici küme parantezi içerisindeki değerlerden initilizer_list<int> nesnesi oluşturmaktadır. Böylesi bir durumda yukarıdaki overload resolution
	işlemindeki gibi küme parantezleri içerisindeki değerlerin hepsinin uygun türden olması gerekmektedir. Örneğin:

	for (double x : {10.2, 20.2, 30.3, 40.4, 50.4})		// geçerli
		cout << x << " ";
	cout << endl;
	
	Burada derğerlerin hepsi double türdendir. Ancak örneğin:

	for (double x : {10, 20, 30.3, 40, 50})		// geçersiz!
		cout << x << " ";
	cout << endl;
	
	Burada küme parantezi içerisindeki bazı değerler int türden bazı değerler double türündendir. Dolayısıyla burada yaratılacak nesnesin initilizer_list<int> 
	türünde mi olacağı yoksa initializer_list<double> türünden mi olacağı belirsizdir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın initializer_list<T> ya da const/volatile initializer_list<T> & parametreli yapıcı fonksiyonuna "initializer_list yapıcı fonksiyonu" denilmektedir. 
	Bu biçimdeki sınıf nesneleri yaratılırken bunlara küme parantezleri içerisinde ilkdeğer verilebilir. Örneğin:

	Sample s{10, 20, 30, 40, 50};

	Burada Sample sınıfının eğer uyguna initializer_list parametreli yapıcı fonksiyonu çağrılabilir. Örneğin:

	class Sample {
	public:
		Sample(initializer_list<int> il);
		//...
	};

	Sample s{10, 20, 30, 40, 50};

	Burada s nesnesi için Sample sınıfının initilizer_list<int> parametreli yapıcı fonksiyonu çağrılacaktır. 

	initializer_list nesnesine küme parantezleri içerisinde ilkdeğer verilirken yaratılan geçici dizinin ömrünün initializer_list nesnesi kadar olduğunu anımsayınız. 
	Bu durumda yukarıdaki örnekteki Sample sınıfının initializer_list parametreli yapıcı fonksiyonu bu dizideki değerleri uygun bir yere kopyalamalıdır. Aksi 
	takdirde yapıcı fonksiyondan çıkıldığında söz konusu bu geçici dizi de yok edilecektir. Aşağıdaki örnekte initializer_list nesnesinin belirttiği geçici dizideki 
	değerler dinamik olarak tahsis edilmiş başka bie alana kopyalanmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstddef>
#include <initializer_list>

using namespace std;

class Sample {
public:
	Sample(initializer_list<int> il);
	~Sample();
	void disp() const;
private:
	int *m_pi;
	size_t m_size;
};

Sample::Sample(initializer_list<int> il)
{
	m_pi = new int[il.size()];

	const int *pi = il.begin();
	for (int i = 0; i < il.size(); ++i)
		m_pi[i] = pi[i];
	m_size = il.size();
}

Sample::~Sample()
{
	delete[] m_pi;
}

void Sample::disp() const
{
	for (size_t i = 0; i < m_size; ++i)
		cout << m_pi[i] << " ";
	cout << endl;
}

int main()
{
	Sample s{10, 20, 30, 40, 50};

	s.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz daha önce sınıf türünden nesneleri yaratırken yapıcı fonksiyona geçirilecek değerleri unifiorm initializer sentaks ismiyle küme parantezleri içerisinde 
	vermiştik. Pekiyi bu durumda sınıfın hem initializer_list parametreli hem de diğer tür parametreli yapıcı fonksiyonları aynı anda bulunuyorsa ne olacaktır? 
	Örneğin:

	class Sample {
	public:
		Sample(int a, int b);
		Sample(initializer_list<int> il);
		//...
	};

	Sample s{10, 20};

	Burada her iki yapıcı fonksiyon da aday ve uygun fonksiyonlardır. Ancak "overload resolution" kuralına göre burada initilzier_list parametreli yapıcı fonksiyonun 
	daha iyi bir dönüştürme sunduğu kabul edilmektedir. DOlayısıyla burada initializer_list parametreli yapıcı fonksiyon çağrılacaktır. Ancak standartlar küme 
	parantezlerinin içi boşsa nesnenin "value-initialize" edileceğini belirtmektedir. Yani bu özel durumda sınıfın hem default yapıcı fonksiyonu hem de initilizer_list 
	parametreli yapıcı fonksiyonu varsa default yapıcı fonksiyon çağrılacaktır. Örneğin:

	class Sample {
	public:
		Sample();
		Sample(initializer_list<int> il);
		//...
	};

	Sample s{};		// burada default yapıcı fonksiyon çağrılır

	Burada default yapıcı fonksiyon çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														54. Ders 28/02/2024 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir bir sınıf türünden nesneye doğrudan küme parantezleri ile değer atamak isteyebiliriz. Örneğin:

	VArray va{1, 2, 3, 4, 5};
	//...

	va = {10, 20, 30};

	Burada nesne initializer_list parametreli yapıcı fonksiyon ile yaratılmı sonra da ona küme parantezleri ile yeni değer atanmıştır. Her ne kadar biz henüz
	operatör fonksiyonlarını görmediysek de konuda bir bütünlük sağlamak amacıyla burada initializer_list parametreli atama operatör fonksiyonlarından da 
	bahsedeceğiz. Yukarıdaki atamaya dikkat ediniz:

	va = {10, 20, 30};

	Bunun eşdeğeri aşağıdaki gibidir:

	va.operator =({10, 20, 30});

	O halde burada operator = fonksiyonunun paramtresi initializer_list sınıfı türünden olmalıdır. İşte eğer sınıfımızın initializer_list parametreli atama
	operatör fonksiyonu varsa biz o sınıf türündne nesneye küme parantezleriyle değer atayabiliriz. Daha önce yazmış olduğumuz VArray sınıfını anımsayınız. 
	Aşağıda bu sınıf için kopya, taşıma atama operatör fonksiyonlarını ve initializer_list parametreli atama operatör fonksiyonlarını veriyoruz:

	class VArray {
	public:
		//...
		VArray &operator =(const VArray &va);
		VArray &operator =(VArray &&va) noexcept;
		VArray &operator =(std::initializer_list<double> il);
		//...
	private:
		double *m_v;
		size_t m_size;
	};

	VArray &VArray::operator =(const VArray &va)
	{
		if (&va == this)
			return *this;

		delete[] m_v;
		m_v = new double[va.m_size];
		memcpy(m_v, va.m_v, sizeof(double) * va.m_size);
		m_size = va.m_size;

		return *this;
	}

	VArray &VArray::operator =(VArray &&va) noexcept
	{
		if (&va == this)
			return *this;

		delete[] m_v;
		m_v = va.m_v;
		m_size = va.m_size;
		va.m_v = nullptr;

		return *this;
	}

	VArray &VArray::operator =(initializer_list<double> il)
	{
		delete[] m_v;

		m_size = il.size();
		m_v = new double[m_size];
		memcpy(m_v, il.begin(), m_size * sizeof(double));

		return *this;
	}

	Aşağıda VArray sınıfının güncellenmiş halini veriyoruz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// varray.hpp

#ifndef VARRAY_HPP_
#define VARRAY_HPP_

#include <cstddef>
#include <initializer_list>

namespace CSD
{
	class VArray {
	public:
		VArray();
		VArray(size_t size);
		VArray(const double *v, size_t size);
		VArray(std::initializer_list<double> il);
		VArray(const VArray &va);
		VArray(VArray &&r) noexcept;
		~VArray();
		VArray add(const VArray &va) const;
		VArray add(double d) const;
		VArray sub(const VArray &va) const;
		VArray sub(double d) const;
		VArray mul(const VArray &va) const;
		VArray mul(double d) const;
		VArray div(const VArray &va) const;
		VArray div(double d) const;
		VArray pow(double d) const;	
		double sum() const;
		double mean() const;

		VArray &operator =(const VArray &va);
		VArray &operator =(VArray &&va) noexcept;
		VArray &operator =(std::initializer_list<double> il);

		size_t size() const { return m_size; }

		void disp() const;
	private:
		double *m_v;
		size_t m_size;
	};
}

#endif

// varray.cpp

#include <iostream>
#include <stdexcept>
#include <cstring>
#include <cmath>
#include "varray.hpp"

using namespace std;

namespace CSD
{
	VArray::VArray() : m_v(nullptr), m_size(0)
	{}

	VArray::VArray(size_t size)
	{
		m_v = new double[size];
		m_size = size;
	}

	VArray::VArray(const double *v, size_t size) : VArray(size)
	{
		::memcpy(m_v, v, sizeof(double) * size);
	}

	VArray::~VArray()
	{
		delete[] m_v;
	}

	VArray::VArray(initializer_list<double> il)
	{
		m_v = new double[il.size()];
		m_size = il.size();

		size_t i = 0;
		for (auto val : il)
			m_v[i++] = val;
	}

	VArray::VArray(const VArray &va)
	{
		m_v = new double[va.m_size];
		m_size = va.m_size;

		::memcpy(m_v, va.m_v, sizeof(double) * m_size);
	}

	VArray::VArray(VArray &&r) noexcept
	{
		m_v = r.m_v;
		m_size = r.m_size;

		r.m_v = nullptr;
	}

	VArray VArray::add(const VArray &va) const
	{
		if (m_size != va.m_size)
			throw invalid_argument("Varrays must be the same size");

		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] + va.m_v[i];

		return result;
	}

	VArray VArray::add(double d) const
	{
		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] + d;

		return result;
	}

	VArray VArray::sub(const VArray &va) const
	{
		if (m_size != va.m_size)
			throw invalid_argument("Varrays must be the same size");

		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] - va.m_v[i];

		return result;
	}

	VArray VArray::sub(double d) const
	{
		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] - d;

		return result;
	}

	VArray VArray::mul(const VArray &va) const
	{
		if (m_size != va.m_size)
			throw invalid_argument("Varrays must be the same size");

		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] * va.m_v[i];

		return result;
	}

	VArray VArray::mul(double d) const
	{
		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] * d;

		return result;
	}

	VArray VArray::div(const VArray &va) const
	{
		if (m_size != va.m_size)
			throw invalid_argument("Varrays must be the same size");

		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] / va.m_v[i];

		return result;
	}

	VArray VArray::div(double d) const
	{
		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = m_v[i] / d;

		return result;
	}

	VArray VArray::pow(double d) const
	{
		VArray result(m_size);

		for (size_t i = 0; i < m_size; ++i)
			result.m_v[i] = ::pow(m_v[i], d);

		return result;
	}

	double VArray::sum() const
	{
		double total = 0;

		for (size_t i = 0; i < m_size; ++i)
			total += m_v[i];

		return total;
	}

	double VArray::mean() const
	{
		return sum() / m_size;
	}

	VArray &VArray::operator =(const VArray &va)
	{
		if (&va == this)
			return *this;

		delete[] m_v;
		m_v = new double[va.m_size];
		memcpy(m_v, va.m_v, sizeof(double) * va.m_size);
		m_size = va.m_size;

		return *this;
	}

	VArray &VArray::operator =(VArray &&va) noexcept
	{
		if (&va == this)
			return *this;

		delete[] m_v;
		m_v = va.m_v;
		m_size = va.m_size;
		va.m_v = nullptr;

		return *this;
	}

	VArray &VArray::operator =(initializer_list<double> il)
	{
		delete[] m_v;

		m_size = il.size();
		m_v = new double[m_size];
		memcpy(m_v, il.begin(), m_size * sizeof(double));

		return *this;
	}

	void VArray::disp() const
	{
		cout << '[';
		for (size_t i = 0; i < m_size; ++i) {
			cout << m_v[i];
			if (i != m_size - 1)
				cout << " ";
		}
		cout << ']' << endl;
	}
}

// app.cpp

#include <iostream>
#include "varray.hpp"

using namespace std;
using namespace CSD;

int main()
{
	VArray x{1, 2, 3, 4};
	
	x.disp();

	x = {10, 20, 30, 40, 50, 60};		// x.oerator =({10, 20, 30, 40, 50});

	x.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Şimdi de daha önce yazmış olduğumuz Matrix sınıfına initialzier_list parametreli yapıcı fonksiyonu ve atama operatör fonksiyonunu ekleyelim:

	class Matrix {
	public:
		//...
		Matrix(std::initializer_list<std::initializer_list<double>> ils);
		Matrix &operator =(std::initializer_list<std::initializer_list<double>> ils);
		//...
	private:
		double *m_matrix;
		size_t m_rowsize;
		size_t m_colsize;
	};

	Matrix::Matrix(initializer_list<initializer_list<double>> ils)
	{
		size_t colsize = 0;

		for (initializer_list<double> il : ils) {
			if (colsize == 0)
				colsize = il.size();
			if (colsize != il.size())
				throw invalid_argument("invalid matrix dimensions");
		}

		m_rowsize = ils.size();
		m_colsize = colsize;

		m_matrix = new double[m_rowsize * m_colsize];

		if (colsize == 0)
			return;
		
		for (size_t index = 0;  initializer_list<double> il : ils) {
			memcpy(m_matrix + index, il.begin(), m_colsize * sizeof(double));
			index += m_colsize;
		}
	}
	
	Matrix &Matrix::operator =(initializer_list<initializer_list<double>> ils)
	{
		if (ils.size() != m_rowsize)
			throw invalid_argument("matrix size mismatch");

		for (initializer_list<double> il : ils)
			if (il.size() != m_colsize)
				throw invalid_argument("matrix size mismatch");
		
		for (size_t index = 0; initializer_list<double> il : ils) {
			memcpy(m_matrix + index, il.begin(), m_colsize * sizeof(double));
			index += m_colsize;
		}

		return *this;
	}

	initializer_list parametreli yapıcı fonksiyonu yazarken küme parantezleri içerisindeki küme parantezlerinin eşit sayıda elemana sahip olup olmadığını 
	kontrol ettik. Atama işleminde atanan küme parantezli matrisin hedef matrisle aynı boyutlarda olup olmadığını da benzer biçimde kontrol ettik. 
	Sınıfın tüm kodlarını aşağıda veriyoruz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// matrix.hpp

#ifndef MATRIX_HPP_
#define MATRIX_HPP_

#include <cstddef>
#include <initializer_list>

namespace CSD
{
	class Matrix {
	public:
		Matrix();
		Matrix(size_t rowsize, size_t colsize);
		Matrix(const Matrix &r);
		Matrix(Matrix &&r) noexcept;
		Matrix(std::initializer_list<std::initializer_list<double>> ils);
		~Matrix();
		void disp() const;
		Matrix add(const Matrix &r) const;
		Matrix sub(const Matrix &r) const;
		Matrix mul(const Matrix &r) const;
		Matrix matmul(const Matrix &r) const;
		Matrix div(const Matrix &r) const;
		double &at(size_t row, size_t col);
		const double &at(size_t row, size_t col) const;

		Matrix &operator =(const Matrix &r);
		Matrix &operator =(Matrix &&r);
		Matrix &operator =(std::initializer_list<std::initializer_list<double>> ils);
	private:
		double *m_matrix;
		size_t m_rowsize;
		size_t m_colsize;
	};
}

#endif

// matrix.cpp

#include <iostream>
#include <cstring>
#include "matrix.hpp"

using namespace std;

namespace CSD 
{
	Matrix::Matrix() : m_matrix(nullptr), m_rowsize(0), m_colsize(0)
	{}

	Matrix::Matrix(size_t rowsize, size_t colsize) 
	{
		m_matrix = new double[rowsize * colsize];
		m_rowsize = rowsize;
		m_colsize = colsize;
	}

	Matrix::Matrix(const Matrix &r)
	{
		m_matrix = new double[r.m_rowsize * r.m_colsize];
		memcpy(m_matrix, r.m_matrix, r.m_rowsize * r.m_colsize * sizeof(double));
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;
	}

	Matrix::Matrix(Matrix &&r) noexcept
	{
		m_matrix = r.m_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		r.m_matrix = nullptr;
	}

	Matrix::Matrix(initializer_list<initializer_list<double>> ils)
	{
		size_t colsize = 0;

		for (initializer_list<double> il : ils) {
			if (colsize == 0)
				colsize = il.size();
			if (colsize != il.size())
				throw invalid_argument("invalid matrix dimensions");
		}

		m_rowsize = ils.size();
		m_colsize = colsize;

		m_matrix = new double[m_rowsize * m_colsize];

		if (colsize == 0)
			return;
		
		for (size_t index = 0;  initializer_list<double> il : ils) {
			memcpy(m_matrix + index, il.begin(), m_colsize * sizeof(double));
			index += m_colsize;
		}
	}

	Matrix::~Matrix()
	{
		delete[] m_matrix;
	}

	void Matrix::disp() const
	{
		for (size_t row = 0; row < m_rowsize; ++row) {
			for (size_t col = 0; col < m_colsize; ++col)
				cout << m_matrix[row * m_colsize + col] << ' ';
			cout << endl;
		}
	}

	Matrix Matrix::add(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] + r.m_matrix[i];
	
		return result;
	}

	Matrix Matrix::sub(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] - r.m_matrix[i];

		return result;
	}

	Matrix Matrix::mul(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] * r.m_matrix[i];

		return result;
	}

	Matrix Matrix::matmul(const Matrix &r) const
	{
		if (m_colsize != r.m_rowsize)
			throw invalid_argument("matrix size mismatch");

		Matrix result{m_rowsize, r.m_colsize};
		double total;

		for (size_t i = 0; i < m_rowsize; ++i)
			for (size_t k = 0; k < r.m_colsize; ++k) {
				total = 0;
				for (size_t j = 0; j < m_colsize; ++j)
					total += m_matrix[i * m_colsize + j] * r.m_matrix[j * r.m_colsize + k];
				result.m_matrix[i * result.m_colsize + k] = total;
			}

		return result;
	}

	Matrix Matrix::div(const Matrix &r) const
	{
		if (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize)
			throw invalid_argument("invalid matrix dimensions");

		Matrix result{r.m_rowsize, r.m_colsize};

		for (size_t i = 0; i < m_rowsize * m_colsize; ++i)
			result.m_matrix[i] = m_matrix[i] / r.m_matrix[i];

		return result;
	}

	double &Matrix::at(size_t row, size_t col)
	{
		if (row >= m_rowsize || col >= m_colsize)
			throw invalid_argument("invalid index");

		return m_matrix[row * m_colsize + col];
	}

	const double &Matrix::at(size_t row, size_t col) const
	{
		if (row >= m_rowsize || col >= m_colsize)
			throw invalid_argument("invalid index");

		return m_matrix[row * m_colsize + col];
	}

	Matrix &Matrix::operator =(const Matrix &r)
	{
		if (this == &r)
			return *this;

		if ((m_rowsize != 0 && m_colsize != 0) 
			&& (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize))
				throw invalid_argument("invalid matrix dimensions");

		double *new_matrix = new double[r.m_rowsize * r.m_colsize];
		
		delete[] m_matrix;

		memcpy(new_matrix, r.m_matrix, r.m_rowsize * r.m_colsize * sizeof(double));
		m_matrix = new_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		return *this;
	}

	Matrix &Matrix::operator =(Matrix &&r) 
	{
		if (this == &r)
			return *this;

		if ((m_rowsize != 0 && m_colsize != 0)
			&& (m_rowsize != r.m_rowsize || m_colsize != r.m_colsize))
			throw invalid_argument("invalid matrix dimensions");
		
		delete[] m_matrix;
		
		m_matrix = r.m_matrix;
		m_rowsize = r.m_rowsize;
		m_colsize = r.m_colsize;

		r.m_matrix = nullptr;
		
		return *this;

	}

	Matrix &Matrix::operator =(initializer_list<initializer_list<double>> ils)
	{
		if (ils.size() != m_rowsize)
			throw invalid_argument("matrix size mismatch");

		for (initializer_list<double> il : ils)
			if (il.size() != m_colsize)
				throw invalid_argument("matrix size mismatch");
		
		for (size_t index = 0; initializer_list<double> il : ils) {
			memcpy(m_matrix + index, il.begin(), m_colsize * sizeof(double));
			index += m_colsize;
		}

		return *this;
	}
}

// app.cpp

#include <iostream>
#include "matrix.hpp"

using namespace std;
using namespace CSD;

int main()
{
	Matrix m = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

	m.disp();

	m = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}};

	m.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte initializer_list konusu dile eklenince standart kütüphanedeki bazı sınıflara bu kullanımı destekleyecek üye fonksiyonlar yerleştirildi. 
	Örneğin string sınıfının initialzier_list<char> parametreli yapıcı fonksiyonu ve atama operatör fonksiyonu vardır:

	string s{'a', 'b', 'c', 'd', 'e', 'f'};

	cout << s << endl;		// abcdef

	s = {'x', 'y', 'z'};

	cout << s << endl;		// xyz

	Küme parantezleriyle değer verilmesi durumunda initializer_list parametreli fonksiyonların diğer fonksiyonlardan daha iyi dönüştürme sağladığını anımsayınız. 
	Örneğin:

	string s{10, 'a'};

	Burada 10 tane 'a' karakterinden oluşan string elde edilmeyecektir. Çünkü burada initializer_list parametreli yapıcı fonksyon çağrılacaktır. Dolayısıyla 
	buradaki stringin iki elemanı olacak birinci eleman 10 numaralı karakterden ('\n' karakteri) ikinci eleman 'a' karakterinden oluşacaktır. Tabii biz bu 
	tür durumlarda küme parantezleri yerine normal parantezleri kullanırsak bu durumda initializer_list parametreli fonksiyonlar zaten uygun fonksiyonlar 
	olmayacaktır.Örneğin:

	string s(10, 'a');
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s{'a', 'b', 'c', 'd', 'e', 'f'};

	cout << s << endl;

	s = {'x', 'y', 'z'};

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Veri yapıları dünyasında dinamik bir biçimde büyütülen dizilere "dinamik diziler (dynamic array)" denilmektedir. Dinamik dizilerin gerçekleştirimi tipik
	olarak şöyle yapılmaktadır: Önce dizi için makul birt uzunlukta dinamik tahsisat yapılır. Dizi için tahsis edilen alanın uzunluğuna "kapasite (capacity)"
	denilmektedir. Dinamik dizi içerisindeki eleman sayısı da yine tutulmaktadır. Buna İngilizce "size" ya da "count" denilebilmektedir. Dinamik diziye eleman
	eklenirken eleman sona eklenir. size değeri 1 artırılır. size değeri kapasite değerine eriştiğinde yeniden tahsisat (reallocation) yapılarak dizi büyütülür.
	Büyütme genellikle "öncekinin iki katı" olacak biçimde yapılmaktadır. Bu durum eleman ekleme sırasında yeniden tahsisat gibi zaman alıcı bir işlemin logaritmik
	düzeye indirgenmesine yol açmaktadır. Bu tür sistemleri eleman ekelemerin karmaşıklığına İngilizce "amortized constant time" denilmektedir. Dinamik dizilerde 
	elemanlar yine ardışıl olarak saklanır. Dolayısıyla elemana erişim indeks yoluyla çok hızlı (random access) biçimde yapılır. Dinamik dizilerin sayısı baştan 
	bilinmeyen, duruma göre değişebilen elemanların ardışıl bir biçimde saklanmasının gerektiği durumlarda kullanılmaktadır. Örneğin bir dizindeki (directory)
	dosyaları bir diziye yerleştirecek olalım. Biz dizinde kaç tane dosya olduğunu baştan bilmeyiz. Dolayısıyla onları saklamak için dinamik dizi kullanabiliriz. 
	Örneğin bir text dosyada belirli bir sözcüğün geçtiği satırların numaralarını bir dizide saklayacak olalım. Biz baştan o sözcüğün kaç satırda geçtiğini 
	bilmemekteyiz. Bu tür durumlarda durumda dinamik dizilerden faydalanabiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Dinamik diziler C++ standart kütüphanesinde vector isimli bir sınıf şablonuyla temsil edilmiştir. Dolayısıyla programcının dinamik dizileri kendisinin 
	oluşturmasına gerek yoktur. Zaten vector sınıfı tamamen bu gereksinimi etkin bir biçimde karşılamak amacıyla bulunduurlmuştur. vector sınıfı şablon bir 
	sınıf olduğu için vector nesnesinin tutacı elemanların türü nesne yaratılırken açısal parantezler içerisinde belirtilmelidir. Örneğin:

	vector<int> x;
	vector<string> y;

	Burada x nesnesi int değerleri, y nesnesi ise string değerlerini tutabilecek biçimdedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												55. Ders 04/03/2024 - Pazartesi
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir vector nesnesi vector sınıfının çeşitli yapıcı fonksiyonlarıyla yaratılabilmektedir. 
	
	- Sınıfın default yapıcı fonksiyonu boş bir vector nesnesi yaratmaktadır. Örneğin:

	vector<int> v;

	- Sınıfın diğer yapıcı fonksiyonu belli bir miktarda nesneden vector oluşturmaktadır. Bu yapıcı fonksiyonun birinci parametresi vector'e başlangıçta kaç 
	elemanın yerleştirileceğini, ikinci parametresi de bu elemanların hangi değere sahip olacağını belirtmektedir. Örneğin:
	
	vector<int> v(10, 100);

	Burada her biri 100 değerini içeren 10 tane elemandan oluşan bir vector yaratılmıştır. Burada eğer vector elemanları bir sınıf türündense yaratılacak vector 
	elemanları kopya yapıcı fonksiyonu ile yaratılmaktadır. Örneğin:

	vector<Sample> v(10, Sample());

	Fonksiyonun ikinci parametresi default değer almıştır. Bu parametre girilmezse ilgili türden default değerlerle elemanlar yaratılır. (Yani temel türler için,
	0 değerleriyle, sınıf türleri için ilgili sınıfın ydefault yapıcı fonksiyonlarıyla)

	Burada 10 tane vector elemanı için Sample sınıfının kopya yapıcı fonksiyonu çalıştırılacaktır. 

	- Sınıfın belli sayıda elemanını default değerlerle (value-initialize biçiminde) yaratan bir yapıcı fonksiyon da vardır. Örneğin:

	vector<int> v(10);

	Burada 10 tane elemandna oluşan bir vector nesnesi yaratılmıştır. 

	- vector sınıfının initializer_list<T> parametreli yapıcı fonksiyonu da vardır. Bu sayede biz vector nesnesine doğrudan küme parantezleri ile ilkdeğer 
	verebilriz. Bu ilkdeğerler vector elemanlarının değerlerini temsil etmektedir. Örneğin:

	vector<int> v = {10, 20, 30, 40, 50};

	Burada vector int türden olduğu için ilgili yapıcı fonksiyoun parametresi de initializer_list<int> türünden olmaktadır. 

	- vector sınıfın kopya yapıcı fonksiyonu taşıma yapıcı fonksiyonu da bulunmaktadır. Örneğin:

	vector<int> foo()
	{
		vector<int> v{1, 2, 3, 4, 5};

		return v;
	}
	//...

	vector v;
	//...

	v = foo();

	Burada foo fonksiyonu çağrıldığında "copy elision" derleyeciye isteğine bağlı olarak (optional) yaılabilir de yapılmayabilir de. Ancak ""copy elision"
	yapılmayacaksa geri dönüş değeri için vector sınıfının taşıma yapıcı fonksiyonu çağrılacaktır. vector sınıfının taşıma atama operatör fonksiyonu da olduğu 
	için geri dönüş değerinin atanmasında da önemli bir performas kaybı oluşmayacaktır. 

	vector sınıfının initializer_list yapıcı fonksiyonun olması nedeniyle vector nesnesi yaratırken normal parantez ya da küme parantezi kullanımına dikkat 
	ediniz. Örneğin:

	vector<int> v(10, 100);

	Burada her elemanı 100 değerini içeren 10 elemanlı bir vector nesnesi yaratılmıştır. Oysa örneğin:

	vector<int> v{10, 100};

	Burada 10 ve 100 değerine sahip iki elemanlı vector nesnesi yaratılacaktır. Overload resolution işleminde initilizer_list parametreli fonksiyonun daha iyi 
	dönüşüm sağlayacağına dikkat ediniz. 

	vector nesnesi sınıf türünden nesneleri tutuyorsa vector nesnesinin ömrü bittiğinde vector seınıfının yıkıcı fonksiyonu tüm vector elemanları için yıkıcı 
	fonksiyonları çağıracaktır. 

	Aşağıda vector sınıfının yapıcı fonksiyonlarının kullanımına ilişkin bir örnek verilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample() : m_val(0)
	{}
	Sample(int val) : m_val(val)
	{
		cout << "Sample constructor" << endl;
	}
	Sample(const Sample &r) : m_val(r.m_val)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
	int val() const { return m_val; }

private:
	int m_val;
};

int main()
{
	vector<int> a(10, 100);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	vector<int> b = {10, 20, 30, 40, 50};

	for (int x : b)
		cout << x << " ";
	cout << endl;

	Sample s{10};

	vector<Sample> c(10, s);

	for (Sample &x : c)
		cout << x.val() << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector nesnesi içerisindeki elemanların sayısı size üye fonksiyonu ile vector nesnesi için ayrılan kapasitenin o anki değeri de capacity üye fonksiyonu 
	ile elde edilmekltedir. Bu üye fonksiyonlar vector<T>::size_type (yani vector sınıfının içerisinde bildirilmiş olan size_type türü) türündne değer vermektedir. 
	C++ standartları bu size_type türünün "işaretsiz bir tamsayı türü olmak koşulu ile herhangi bir tür olarak typedef edilebileceğini" söylemektedir. Tipik olarak 
	bu tür size_t türü biçiminde typedef edilmektedir. Örneğin:

	vector<int> v = {10, 20, 30, 40, 50};

	cout << v.size() << endl;
	cout << v.capacity() << endl;

	C++ standartları capacity değeri hakkında bir koşul belirtmemektedir. Yani yukarıdaki kodda capacity değeri 5 olmak zorunda değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector'ün sonuna eleman eklemek için push_back fonksiyonu kullanılmaktadır. Eskidne beri var olan push_back fonksiyonu const T & parametreli fonksiyondu.
	Ancak C++11 ile birlikte T && parametreli push_back fonksiyonu da eklenmiştir. Yani eklenmek istenen nesne bir sağ taraf değeri ise o nesne taşınarak 
	eklenmektedir. Başka bir deyişle eklenecek değer eğer bir sınıf türünden sol taraf değeri belirten bir nesne ise vector'e eklenen nesne kopya yapıcı 
	fonksiyonu yoluyla, sağ taraf türünden bir nesneyse taşıma yapıcı fonksiyonu yoluyla yaratılmaktadır. Aşağıdaki örnekte ne kastedildiği daha iyi anlaşılabilir.
	vector sınıfı kapasiteyi büyütürken eski tahsis ettiği yerdeki nesneleri yeni tahsis ettiği alana da yine sınıfın kopya yapıcı fonksiyonu ile kopyalamaktadır. 
	Bu nedenle aşağıdaki kodda fazladan kopya yapıcı fonksiyonların ve yıkıcı fonksiyonların çalıştırıldığını görürseniz şaşırmayınız. 
	Örneğin Microsoft derleyicilerinde aşağıdaki gibi bir çıktı elde edilmiştir:

	Sample int constructor
	copy constructor
	move constructor
	copy constructor
	destructor
	destructor
	destructor
	destructor

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample() : m_val(0)
	{
		cout << "Sample default constructor" << endl;
	}
	Sample(int val) : m_val(val)
	{
		cout << "Sample int constructor" << endl;
	}
	Sample(const Sample &r) : m_val(r.m_val)
	{
		cout << "copy constructor" << endl;
	}

	Sample(const Sample &&r) noexcept : m_val(r.m_val)
	{
		cout << "move constructor" << endl;
	}

	~Sample()
	{
		cout << "destructor" << endl;
	}
	int val() const { return m_val; }

private:
	int m_val;
};

int main()
{
	vector<Sample> v;
	Sample s{10};

	v.push_back(s);				// ekleme kopya yapıcı fonksiyonu yoluyla yaılmaktadır
	v.push_back(move(s));		// ekleme taşıma yapıcı fonksiyonu yoluyla yazılmaktadır
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte vector sınıfına vektöre ekleme yapan emplace_back isimli yeni bir üye fonksiyon daha eklenmiştir. Bu fonksiyon eğer vector'ün şablon 
	parametresi bir sınıf türündense doğrudan o sınıfın yapıcı fonksiyona geçirilecek argümanlarını alır ve eklenecek elemanı tek bir yapıcı fonksiyon çağırarak
	hedefte o argümanlarla yaratır. Örneğin:

	vector<Sample> v;
	Sample s(10, 20);

	v.push_back(s);

	Burada ekleme işlemi iki yapıcı fonksiyonun çağrılması ile gerçekleşecektir. Birinci yapıcı fonksiyon s nesnesinin yaratılması sırasında çağrılan yapıcı 
	fonksiyondur. İkinci yapıcı fonksiyon eklenecek vector elemanı için çağrılan kopya yapıcı fonksiyonudur. Eklemenin aşağıdaki gibi yapılırsa kopya yapıcı 
	fonksiyonu yerine taşıma yapıcı fonksiyonu çağrılır. Ancak yine toplamda iki yapıcı fonksiyon çağrılmış olur:

	vector<Sample> v;
	
	v.push_back(Sample(10, 20));

	Ancak bu işlemi emplace_back i,le yaparsak yalnızca tek bir yapıcı fonksiyon çağrılacaktır:

	vector<Sample> v;
	
	v.emplace_back(10, 20);

	emplace_back fonksiyonuna doğrudan Sample sınıfının yapıcı fonksiyonun argümanlarının aktarıldığına dikkat ediniz. emplace_back bu argümanları alarak 
	tek seferde eklenecek vector elemanını bu değerlerle constryct edecektir. Tabii vector'ün şablon parametresi sınıf türünden değilse push_back ile emplace_back
	arasında bir farklılık kalmamaktadır. 

	Pekiyi emplace_back fonksiyonu neden C++11 ile eklenmiştir? İşte bu fonksiyonun gerçekleştirilebilmesi için dilde "variadic template" ve "forwarding reference"
	denilen özelliklerin bulunuyor olması gerekmektedir. Bu özellikler de C++11 ile dile eklenmiştir. 

	Aşağıdaki örnekte push bakc ile emplace_back arasındaki farklılık açıkça görülmektedir. Bu örneği çalıştırdığınızda aşağıdaki gibi bir çıktı elde edeceksiniz:

	Sample int constructor
	move constructor
	------------
	Sample int constructor
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample int constructor" << endl;
	}

	Sample(const Sample &r) : m_a(r.m_a), m_b(r.m_b)
	{
		cout << "copy constructor" << endl;
	}

	Sample(const Sample &&r) noexcept : m_a(r.m_a), m_b(r.m_b)
	{
		cout << "move constructor" << endl;
	}

private:
	int m_a;
	int m_b;
};

int main()
{
	vector<Sample> x;
	
	x.push_back(Sample(10, 20));		
	
	cout << "------------" << endl;

	vector<Sample> y;

	y.emplace_back(10, 20);

	return 0;
}
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector nesnesinin arasında eleman eklemek için insert üye fonksiyonları kullanılmaktadır. Ancak bu fonksiyonlar insert pozisyonu olarak "iterator" almaktadır.
	vector sınıfının iterator'leri "rastgele erişimli (random access)" iterator'ler olduğu için insert pozisyonu olarak "v.begin() + n" ifadesini geçirmelisiniz. 
	Iterator kavramı ileri ele alınacaktır. Dolayısıyla burada daha fazla açıklama yapmayacağız. Örneğin:

	vector<int> v = {10, 20, 30, 40, 50};

	Burada biz 30 ie 40 arasına 100 değerini insert etmek isteyelim. Bunu şöyle yapabiliriz:

	v.insert(v.begin() + 2, 100);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {10, 20, 30, 40, 50};

	for (int x : v)
		cout << x << " ";
	cout << endl;

	v.insert(v.begin() + 3, 100);

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer vector'ün şablon parametresi bir sınıf türündense budurumda insert işleminde kaydırma yapılırken ilgili sınıfın taşıma atama operatör fonksiyonu 
	(yoksa kopya atama operatör fonksiyonu) çağrılacaktır. Yani bu tür durumlarda yeniden tahsisat yapılırken ya da kaydırma yapılırken aslında sınıfların
	yapıcı ve atama operatör fonksiyonlarının çalıştırılmaktadır. Tabii programcılar genellikle bu durumla ilgilenmezler. Çünkü sınıfları zaten düzgün
	yazılmışsa kopyalama ve atama işlemleri herhangi bir soruna yol açmayacaktır. Aşağıda bu durumu betimlemek için bir örnek veriyoruz. Bu örnekten amacımız
	insert işlemi sırasında nesnelerin yer değiştirmesi dolayısıyla ilgili sınıfların yapıcı ya da atama operatör fonksiyonlarının çalıştırılabileceğinin 
	gösterilmesidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "Sample int constructor" << endl;
	}

	Sample(const Sample &r) : m_a(r.m_a)
	{
		cout << "copy constructor" << endl;
	}

	Sample(const Sample &&r) noexcept  : m_a(r.m_a)
	{
		cout << "move constructor" << endl;
	}

	Sample & operator =(const Sample &r)
	{
		m_a = r.m_a;
		
		cout << "copy assignment operator" << endl;

		return *this;
	}

	Sample & operator =(const Sample &&r) 
	{
		m_a = r.m_a;

		cout << "move assignment operator" << endl;
		
		return *this;
	}

	int a() const { return m_a; }

private:
	int m_a;
};

int main()
{
	vector<Sample> v = {Sample(10), Sample(20), Sample(30), Sample(40), Sample(50)};
	
	for (Sample &s : v)
		cout << s.a() << " ";
	cout << endl;

	cout << "------------------------" << endl;

	v.insert(v.begin() + 2, Sample(100));

	for (Sample &s : v)
		cout << s.a() << " ";
	cout << endl;

	return 0;
}
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector sınıfına C++11 ile birlikte initializer_list parametreli bir insert fonksiyonu da eklenmiştir. Bu fonksiyon birden fazla değerin insert edilmesi 
	için kullanılabilir. Örneğin:

	vector<int> v = {10, 20, 30, 40, 50};

	v.insert(v.begin() + 2, {100, 200, 300, 400, 500});

	Burada tek hamlede küme parantezlerinin içerisindeki tüm değerler insert edilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {10, 20, 30, 40, 50};

	for (int x : v)
		cout << x << " ";
	cout << endl;

	cout << "--------------" << endl;

	v.insert(v.begin() + 2, {100, 200, 300, 400, 500});

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte insert işleminin hedefte gerçekleştirilmesi için emplace fonksiyonu da sınıfa eklenmiştir. Örneğin:

	vector<Sample> v;
	//...

	v.emplace(v.begin(), 100);

	Burada emplace fonksiyonunun ikinci ve sonraki parametreleri yine yapıcı fonksiyona geçirilecek olan argümanları almaktadır. Fonksiyon doğrudan inset edilecek 
	noktada burada belirtilen parametreik yapıya sahip yapıcı fonksiyonu çağırır. Aşağıdaki programla test işlemi yapabilirsiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample(int a) : m_a(a)
	{
		cout << "Sample int constructor" << endl;
	}

	Sample(const Sample &r) : m_a(r.m_a)
	{
		cout << "copy constructor" << endl;
	}

	Sample(const Sample &&r) noexcept : m_a(r.m_a)
	{
		cout << "move constructor" << endl;
	}

	Sample & operator =(const Sample &r)
	{
		m_a = r.m_a;

		cout << "copy assignment operator" << endl;

		return *this;
	}

	Sample & operator =(const Sample &&r)
	{
		m_a = r.m_a;

		cout << "move assignment operator" << endl;

		return *this;
	}

	int a() const { return m_a; }

private:
	int m_a;
};

int main()
{
	vector<Sample> v = {Sample(10), Sample(20), Sample(30), Sample(40), Sample(50)};

	for (Sample &s : v)
		cout << s.a() << " ";
	cout << endl;

	cout << "------------------------" << endl;

	v.emplace(v.begin() + 2, 100);

	for (Sample &s : v)
		cout << s.a() << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	<BURADA KALDIK>	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i)
		v.push_back(i);

	for (int i = 0; i < 100; ++i)
		cout << v[i] << " ";
	cout << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'a eklenen "initializer list yapıcı fonksiyonu yoluyla" biz kme pareantezleri içerisinde elemanları belirterek de bir vektörü 
	oluşturabiliriz. Vektörler aralık tabalı for döngüsüyle dolaşılabilirler. Bu durumda döngünün her yünelenmesinde biz vektörün yeni bir elemanını 
	elde etmiş oluruz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii aralık tabanlı for döngsünde dönü değişkeni bir referans olarak alınabilir burada auto belirleyicisi de kullanılabilir.     
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int &x : v)
		x += 10;
	
	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir vektörde vektöre yerleştirilmiş eleman sayısına "size", vektör için tahsis edilmiş eleman sayısına ise "capacity" denilmektedir. Normalde capacity değeri
	size değerinden büyüktür. Ancak vektöre eleman eklendikçe size değeri artar. size değeri capacity değerine geldiğinde vektör capacity değerini yeniden tahsisat 
	yaparak büyütür. Capacity değerinin ne kadar büyütüleceği standartlarda belirtilmemiş olsa da tipik olarka eskisinin iki katı kadar büyütme uygulanmaktadır. 

	Vektördeki size değeri size üye fonksiyonu ile capacity değeri capacity üye fonksiyonu ile elde edilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	size ve capacity değerinin artışı aşağıdaki gibi gözlemlenebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i) {
		v.push_back(i);
		cout << "size: " << v.size() << ", capacity: " << v.capacity() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında bir vector belli bir size işin başında belirtilerek de yaratılabilir. Tabii bu durumda burada belirtilen miktarda eleman eğer vektör temel türleri 
	tutuyorsa 0'larla sınıf türlerini tutuyorsa onların default yapıcı fonksiyonlarıyla doldurulacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v(10);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Vektöre eleman insert etme iteratör yoluyla yapılmaktadır. Biz enüz iteratör konusunu bilmiyoruz. Ancak eğer vektörün n'inci indeksine
	bir insert yapacaksanız buna ilişkin iteratörü v.begin() + n ifadesi ile oluşturabilirsiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.insert(v.begin() + 3, 100);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Vektörden eleman silme işlemi de iteratör yoluyla yapılmaktadır. Ancak yukarıda da belirttiğimiz gibi pratik bir yöntem olarak iteratör pozisyonu
	v.begin() + n ifadesi ile oluşturulabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.erase(v.begin() + 3);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector sınıfının clear üye fonksiyonu vektördeki tüm elemanları silmek için kullanılmaktadır. Ancak clear işleminden sonra vektörün size değeri 0 olmasına
	karşın, capacity değeri değiştirilmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.clear();

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir vektörün içinin boş olup olmadığı empty üye fonksiyonu ile anlaşılabilir. Tabii aynıişlem v.size() == 0 ile de yapılabilir. C++11 ile birlikte ayrıca
	vektör sınıfına shrink_to_fit fonksiyonu eklenmiştir. Bu fonksiyon capacity değerini size değerine çekmektedir. Yine C++11 ile birlikte vektör sınıfına
	initializer_list atama operatör fonksiyonu eklenmiştir. Dolayısıyla biz bu sayede küme parantezli bir ifadeyi vektör nesnesine atayabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v = {10, 20, 30};		// C++11 ile birlikte

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii vector sınıfında taşıma yapıcı fonksiyonu ve taşıma operatöçr operatör fonksiyonu olduğu için taşıma işlemleri etkin bir biçimde yapılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

vector<int> foo()
{
	vector<int> v = {1, 2, 3, 4, 5};

	return v;		// taşıma yapıcı fonksiyonu çağrılır
}

int main()
{
	vector<int> v;

	v = foo();		// taşıma operatör fonksiyonu çağrılacak

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii vector sınıfı şablon bir sınıf olduğu için aslında herhangi türden bir nesneyi tutabilir.    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> v = {"ali", "veli", "selami"};

	v.push_back("fatma");

	for (auto s : v)
		cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/




/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'ın standart kütüphanesindeki bazı sınıflar için de taşıma yapıcı fonksiyonları eklenmiştir. Örneğin artık string, vector gibi sınıflar
	kaynak taşıması yapabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

string foo()
{
	string s("ankara");

	cout << s << endl;

	return s;			// string sınıfının move constructor'ı çağrılır
}

int main()
{
	string s;

	s = foo();			

	cout << s << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir proje nesne yönelimli olarak modellenecekse önce projedeki kavramlar sınıflarla temsil edilir. Sonra bu kavramlar türünden gerçek nesneler yaratılır ve 
	program sınıflar kullanılarak yazılır. Örneğin bir hastane otomasyonunda "hastane", "doktor", "hemşire", "hasta" vs. gibi kavramlar birer sınıfla temsil edilmelidir. 
	Örneğin hastanemizde 10 doktor varsa biz 10 doktor nesnesi yaratırız. Tüm hastaneyi temsil eden bir tane hastane nesnesi yaratır ız. 

	Ancak sınıflar da mantıksal bakımdan birbirleriyle ilişkili olabilirler. Sınıflar arasında dört temel ilişki biçimi vardır:

	1) İçerme ilişkisi (composition)
	2) Birleşme ilişkisi (aggregation)
	3) Türetme ilişkisi (inheritance)
	4) Çağrışım ilişkisi (association)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden bir nesne başka bir sınıf türünden bir nesnenin bir parçasını oluşturuyorsa bu iki sınıf arasında "içerme ilişkisi (compoistion)" 
	vardır. İçerme ilişkisi bire-bir olabileceği gibi bire-çok biçimde de olabilir. İçerme ilişkisi UML sınıf diyagramlarında içeren sınıf tarafında içi dolu bir 
	baklavacık (dimaond) ile gösterilmektedir. 

	İçerme ilişkisinin iki temel özelliği vardır:

	1) İçerilen nesne tek bir nesne tarafından içerilir. 
	2) İçeren nesne ile içerilen nesnenin ömürleri yaklaşık aynıdır.

	Bu durumda örneğin insan ile böbrek sınıfı arasında içerme ilişkisi vardır. Böbrekle insan aynı zamanda hayata başlarlar ve aynı zamanda yaşamlarını bitiriler. 
	Bir böbrek tek bir insanın böbreğidir. Aynı zamanda başka bir insanın böbreği değildir. Tabii bu tür modellemelerde tipik durumlar dikkate alınmalıdır. 
	Yani örneğin böbrek nakli tipik bir durum değildir. Böbrek naklinin yapılıyor olması bir böbreğin başkaları tarafından da tipik olarak kullanıldığı anlamına 
	gelmez. Örneğin "oda" ile "duvar" arasındaki ilişki içerme ilişkisi değildir. Her ne kadar oda ile duvarın yaşamları aynıysa da duvar yandaki odanın da duvarıdır. İnsan ile Böbrek 
	sınıfları arasındaki içermel ilişkisi bire-iki biçimindedir. Yani bir insanda iki böbrek bulunmaktadır. 

	C++'ta içerme ilişkisi iki biçimde oluşturulabilir:

	1) İçeren sınıfın private bölümünde içerilen sınıf türünden bir veri elemanı alınır. İçeren sınıf nesnesi yaratıldığında içerilen nesne de yaratılmış olacaktır.
	2) İçeren sınıfın private bölümünde içerilen sınıf türünden bir gösterici veri elemanı bulundurulur. İçeren sınıfın yapıcı fonksiyonunda da new operatörüyle bu veri elemanı 
	için dinamik tahsisat yapılır. Tabii bu tahsisat içeren sınıfın yıkıcı fonksiyonunda delete operatörü ile yok edilmelidir. 

	İçerme ilişkisine İngilizce aynı zamanda "has a" ilişkisi de denilmektedir. 

	Aşağıda içerme ilişkisinin birinci birinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
    //...
private:
    Motor m_motor;
    //...
};

int main()
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda da içerme ilişkisinin ikinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
public:
    Araba();
    ~Araba();
private:
    Motor *m_motor;
    //...
};

Araba::Araba()
{
    m_motor = new Motor();
    //...   
}

Araba::~Araba()
{
    //...
    delete m_motor;
}

int main()
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Birleşme (aggregation) ilişkisinde bir sınıf türünden nesne başka bir sınıf türünden nesneyi kullanmaktadır. Ancak kullanılan nesne başka nesneler tarafından da
	kullnılıyor olabilir. Kullanan nesne ile kullanılanılan nesnenin yaşamları aynı olmayabilir. Genel olarak içerme ilişkisine uymayan kullanma ilişkisi birleşme
	ilişkisi biçimindedir. Örneğin Hastana ile Doktor sınıfları arasında, Bilgisayar ile Fare sınıfları arasında birleşme ilişkisi vardır. Birleşme ilişkisi 
	UML sınıf diyagramlarında kullanan sınıf tarafında içi boş bir baklavacık (dimaond) ile gösterilmektedir. Birleşme ilişkisi de bire-bir olabileceği gibi bire-çok
	olabilir. 

	Birleşme ilişkisi C++'ta tipik olarak kullanan sınıf içerisinde kulalnılan sınıfa ilişkin bir gösterici tutularak gerçekleştirilir. Tabii bu gösterici dışsarıda
	yaratılmış olan bir nesneyi gösterecektir. Bu sayede birden fazla nesne gösterici yoluyla aynı nesnesiyi kullanabilmektedir. 

	Birleşme ilişkisine İngilizce'de aynı zamanda "holds a" ilşkisi de denilmektedi. 

	Aşağıdaki örnekte Computer ile Mouse sınıfları arasındaki birleşme ilişkisi görülmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Mouse {
    //...
};

class Computer {
public:
    Computer() : m_mouse(nullptr)
    {
        //...
    }

    void attach_mouse(Mouse *mouse)
    {
        m_mouse = mouse;
    }

    Mouse *detach_mouse()
    {
        Mouse *mouse = m_mouse;
        m_mouse = nullptr;

        return mouse;
    }
private:
    Mouse *m_mouse;
    //...
};

int main()
{
    Computer computer1;
    Computer computer2;
    //...
    Mouse *mouse1 = new Mouse();
    computer1.attach_mouse(mouse1);

    auto mouse = computer1.detach_mouse();
    computer2.attach_mouse(mouse);

    Mouse *mouse2 = new Mouse();
    computer1.attach_mouse(mouse2);

    delete mouse1;
    delete mouse2;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki bir satranç tahtasının NYPT ile modellenmesi örneği verilmiştir. Burada Board sınıfı tahtayıi Square sınıfı tahtanının karelerini ve Figure 
	sınıfı ise satranç taşlarını temsil etmektedir. Board sınıfı ile Square sınıfı arasında "içerme (composition)", Square sınıfı ile Figure sınıfı arasında ise
	"birleşme (aggregation)" ilişkisi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum class Color {
    White, Black
};

enum class Type {
    King, Queen, Rook, Bishop, Knight, Pawn
};

class Figure {
public:
    Figure(Type type, Color color) : m_type(type), m_color(color)
    {}
    Type type() const { return m_type; }
    Color color() const { return m_color; }
    string to_string();
    friend ostream &operator <<(ostream &os, Figure *figure);
    //...
private:
    Type m_type;
    Color m_color;
};

class Square {
public:
    Square() = default;
    Square(Color color) : m_color(color)
    {}
    Color color() const { return m_color; }
    void set_color(Color color) { m_color = color;}
    Figure *figure() const { return m_figure; }
    void set_figure(Figure *figure) { m_figure = figure; }
    //...
private:
    Color m_color;
    Figure *m_figure;
};

string Figure::to_string()
{
    static const char *figure_names[] = {"King", "Queen", "Rook", "Bishop", "Knight", "Pawn"};

    string s;

    s += m_color == Color::Black ? "Black " : "White ";
    s += figure_names[static_cast<int>(m_type)];

    return s;       // move constructor çağrılacak
}

ostream &operator <<(ostream &os, Figure *figure)
{
    os << figure->to_string();

    return os;
}

class Board {
public:
    Board();
    Square &square(int row, int col)
    {
        return m_squares[row][col];
    }
private:
   Square m_squares[8][8];
};

Board::Board()
{
    for (int row = 0; row < 8; ++ row)
        for (int col = 0; col < 8; ++col) {
            m_squares[row][col].set_color((row + col) % 2 == 0 ? Color::Black : Color::White);
            m_squares[row][col].set_figure(nullptr);
        }

    m_squares[0][0].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][0].set_figure(new Figure(Type::Rook, Color::Black));

    m_squares[0][1].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][1].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][2].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][2].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][3].set_figure(new Figure(Type::Queen, Color::White));
    m_squares[7][3].set_figure(new Figure(Type::Queen, Color::Black));

    m_squares[0][4].set_figure(new Figure(Type::King, Color::White));
    m_squares[7][4].set_figure(new Figure(Type::King, Color::Black));

    m_squares[0][5].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][5].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][6].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][6].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][7].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][7].set_figure(new Figure(Type::Rook, Color::Black));

    for (int col = 0; col < 8; ++col) {
        m_squares[1][col].set_figure(new Figure(Type::Pawn, Color::White));
        m_squares[6][col].set_figure(new Figure(Type::Pawn, Color::Black));
    }
}

int main()
{
    Board board;

    cout << board.square(0, 0).figure()->to_string() << endl;

    cout << board.square(0, 5).figure() << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de "kalıtım (inheritance)" bir sınıfa ona dokunmadan ekleme yapmak için kullanılan bir yöntemdir. Elimizde A isimli bir sınıf bulunuyor olsun. 
	Biz bu sınıfa onu bozmadan birkaç üye fonksiyon eklemek isteyelim. İşte bu A sınıfından bir B sınıfını türetiriz. Ekleyeceğimiz üye fonksiyonları bu
	B sınıfına ekleriz. Burada ekleme yapmak istediğimiz A sınıfına "taban sınıf (base class)" eklemelerin yapıldığı B sınıfına da "türemiş sınıf (derived class)"
	denilmktedir. Türemiş sınıf hem taban sınıf gibi davranmakta hem de kendine özgü fazlalıklara sahip olmaktadır. Türemiş sınıftan da sınıflar türetilebilir. 
	Bu durumda türemiş sınıf onun taban sınıflarının tüm işlevselliklerine sahip olur. UML sınıf diyagramlarında türetme ilişkisi "türemiş sınıftan taban sınıfa doğru
	çekilen içi boş bir okla" temsil edilmektedir.

	C++'ta türetme ilişkisine İmgilizce "is a" ilişkisi de denilmektedir. 

	Bir sınıf birden fazla sınıfın taban sınıfı durumunda olabilir. Bu durum tamamen normal bir durumdur. Ancak bir sınıfın birden fazla taban sınıfa sahip olması 
	durumu özel bir durumdur. Buna NYPT'de "çoklu türetme (multiple inheritance)" denilmektedir. Java, C#, Swift gibi dillerin bazılarında çoklu türetme yoktur.
	Ancak C++, Object Pascal, Python gibi dillerde çoklu türetme vardır. 

	Türetmenin en önemli kullanım nedeni sınıfa onu bozmadan eklemeler yapmak ve kod tekrarını ortadan kaldırmaktır. İki sınıf ortak elemanlara sahipse
	bu sınıfların bağımsız yazılması durumunda gereksiz kod tekrarı oluşur. Halbuki bu ortak elemanlar bir taban sınıfta toplanırsa bu kod tekrarı ortadan 
	kaldırılmış olur. Örneğin B isimli bir sınıfta foo, bar ve tar fonksiyonları bulunuyor olsun. C isimli bir sınıfta da foo, bar ve zar fonksiyonları bulunuyor olsun.
	Burada foo ve bar fonksiyonları her iki sınıfta da tekrarlanmaktadır. Biz bu iki fonksiyonu taban bir A sınıfına yerleştirip B ve C'yi bu sınıftan türetirsek 
	kod tekrarını ortadan kaldırmış oluruz. 

	C++'ta türetme işlemleri özel bir setaksla yapılmaktadır. İzleyen bölümde türetme işlemlerinin nasıl yapıldığı açıklanacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Çağrışım ilişkisinde (association) bir sınıf bir sınıfı kullanmaktadır. Ancak bu kulanma onu bünyesine katarak (yani bir veri elemanında saklayarak) yapılmaz.
	Yalnızca üye fonksiyonlar tarafından yapılır. Yani kullanma bazı alanlarla sınırlıdır. Örneğin Hastane sınıfı gerektiğinde reklam yapacaktır. Bunun için sınıfın
	reklam_yap gibi bir üye fonksiyonu reklam şirketini kullanabilir. Bir ticari taksi ile şoför arasında bir birleşme ilişkisi vardır. Bunlarla taksinin sahibi 
	arasında bir birleşme ilişkisi vardır. Ancak taksi ile yolcu arasındaki ilişki yüzeyseldir. Bu ilişki çağrışım ilişkisi biçiminde ifade edilebilir.

	Çağrışım ilişkisi UML sınıf diyagramlarında kullanan sınıftan kullanılan sınıfa doğru ince bir çizgi ve bir okla temsil edilmektedir.  

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta türetme işleminin genel biçimi şöyledir:

	class <türemiş sınıf ismi> : [türetme biçimi] <taban sınıf ismi> {
		//...
	};

	Buradaki türetme biçimi "public", "protected" ya da "private" biçiminde olabilir. Türetme biçimi belirtilmezse türemiş sınıf class anahtar sözcüğü ile oluşturulmuşsa
	"private", struct anahtar anahtar sözcüğü ile oluşturulmuşsa "public" kabul edilir. En yaygın kullanılan türetme biçimi public türetmesidir. Java, C# gibi dillerde
	türetme biçimi yoktur. Ancak o dillerdeki türetme C++'taki "public türetmesi" gibidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türetme işleminde türemiş sınıf hem taban sınıf gibi kullanılabilmekte hem de ek birtakım elemanlara sahip olabilmektedir. Aşağıdaki örnekte B sınıfı A'dan
	türetilmiştir. B sınıfı hem A gibi kullanılabilir hem de kendi elemanlarına sahiptir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;


class A {
public:
	void foo();
	void bar();
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

class B : public A {
public:
	void tar();
	//....
};

void B::tar()
{
	cout << "B::tar" << endl;
}

int main()
{
	B b;

	b.foo();
	b.bar();
	b.tar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf veri elemanları bakımından da taban sınıfı içermektedir. Yani türemiş sınıf türünden bir nesne hem türemiş sınıfın veri elemanlarını hem de taban 
	sınıfın veri elemanlarını içerir. Standartlarda türemiş sınıf nesnesi içerisindeki veri eleman diziliminde taban sınıfın mı yoksa türemiş sınıfın mı
	veri elemanlarının düşük adreste bulundurulacağı konusunda bir belirlemede bulunulmamıştır. Ancak derleyicilerin hemen hepsi türemiş sınıf nesnesi yaratıldığında
	önce taban sınıf veri elemanlarını sonra türemiş sınıf veri elemanlarını ardışıl bir biçimde yerleştimektedir. Örneğin B sınıfı A sınıfından türetilmiş olsun.
	Biz de B sınıfı türünden bir nesne yaratmış olalım. Tipik organizasyon şöyledir:

	A-data-members
	B-data-members

	Dolayısıyla türemiş nesnesinin adresini aldığımızda önce onun taban kısmıyla karşılaşırız. Aşağıdaki örnekte taban ve türemiş sınıf içerisinde ikişer int 
	türen veri elemanı bulundurulmuştur. Bunların sizeof değerlerine dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_x;
	int m_y;
};

class B : public A {
public:
	int m_z;
	int m_k;
};

int main()
{
	B b;

	cout << sizeof b << endl;			// 16

	b.m_x = 10;
	b.m_y = 20;
	b.m_z = 30;
	b.m_k = 40;

	cout << b.m_x << ", " << b.m_y << ", " << b.m_z << ", " << b.m_k << endl;		// 10, 20, 30, 40

	A a;

	cout << sizeof a << endl;		// 8


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıflarda erişim kuralları türetme biçimine göre değişmektedir. Yukarıda da belirttiğimiz gibi en çok kullanılan türetme biçimi "public türetmesisir".

	public türetmesinde taban sınıfın public bölümü türemiş sınıfın public bölümüymüş gibi, taban sınıfın protected bölümü türemiş sınıfın protected bölümüymüş gibi
	işlem görür. Taban sınıfın private bölümü tamamen korunmuştur. Türemiş sınıf tarafından erişilemez. 

	public türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfın yalnızca public bölümündeki elemanlara erişebiliriz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Burada taban sınıfın protected bölümüne kendi sınıfı dışında yalnızca türemiş sınıfın üye fonksiyonları tarafından erişilebildiğine dikkat ediniz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : public A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();		// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// geçerli
	b.zar();		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	protected türetmesinde taban sınıfın public ve protected bölümleri türemiş sınıfın protected bölümüymüş gibi işlem görmektedir. Taban sınıfın private bölümü 
	tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez. 

	protected türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	public ve protected türetmesi arasındaki fark taban sınıfın public bölümüne dışarıdan türemiş sınıf nesnesi, gösterici ve referansı yoluyla erişilebilmesi ancak 
	protected türetmesinde erişilememesidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : protected A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();	// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	// b.foo();		// error!
	b.zar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	private türetmesinde taban sınıfın public ve protected bölümleri türemiş sınııfn private bölümüymüş gibi işlem görmektedir. 

	private türetmesinden çıkan sonuçlar sanki protected türetmesinden çıkan sonuçlarla aynı gibidir:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Her ne kadar protected türetmesiyle private türetmesinden çıkan sonuçlar aynı gibi gözküyorsa da bir dizi türetme yapıldığında arada farklılıklar oluşabilmektedir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme yapıldığında yukarıdaki kurallar geçişli biçimde devam etmektedir. Aşağıdaki gibi bir türetme şeması olsun:

	class A {
		//...
	};

	class B : public A {
		//...
	};

	class C : public B {
		//...
	};

	Burada C sınıfının bir üye fonksiyonu içerisinde biz hem A2nın public ve protected elemanlarını hem de B2nin public ve protected elemanlarını doğrudan
	kullanabiliriz. Yine dışarıdan C nesnesi, göstericisi ya da referansı tyoluyla hem A'nın hem B2nin hem de C'nin public elemanlarına erişebiliriz. 

	Şimdi B sınıfı A'dan private türetilmiş olsun:

	class A {
		//...
	};

	class B : private A {
		//...
	};

	class C : public B {
		//...
	};

	Burada biz artık C'nin üye fonksiyonları içerisinde A'nın public ve protected elemanlaırnı kullanamayız. Şimdi B sınıfı A'dan protected türetilmiş olsun:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	class C : public B {
		//...
	}; 

	Biz burada artık C2nin üye fonksiyonları içerisinde A'nın ve B'nin public ve protected bölümlerindeki elemanları doğrudan kullanabiliriz. 
	Görüldüğü gibi protected ve private türetmesi arasında bu tür durumlarda semantik farklılık oluşmaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tüm bunların ışığı altına sınıfların protected bölümleri için şunlar şöylenebilir: Sınıfın protected bölümü türemiş sınıfların üye fonksiyonları tarafından 
	doğrudan kullanılabilen ancak dışaıdan kullanılamayan bölümüdür. Biz bir elemanı protected bölüme neden yerleştiririz? İşte bizim yazdığımız sınıftan bir türetme
	yapılabileceğini öngörüp türemiş sınıfı yazanlara erişim kolaylığı sağlamak için bazı elemanları protected bölüme yerleştirebilriz. Ancak sınıfın protected 
	bölümünde bir değişiklik yapıldığında yalnızca o sınıfın içinin değil tüm türemiş sınıfların içlerinin yeniden yazılması gerekir. Bu nedenle bazı teorisyenler
	protected bölümün hiç kullanılmaması gerektiğini de düşünmektedir. Tabii bir sınıfta public bölüm gibi protected bölümün de dokümantasyonu yapılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın "taban sınıfları (base classes)" denildiği zaman yukarıya doğru onun bütün taban sınıfları anlaşılır. Bir sınıfın "doğruan taban sınıfları (direct base class)"
	denildiğinde ise o sınıfın hemen bir yukarısındaki taban sınıfları anlaşılır. Bir sınıfın "dolaylı taban sınıfları (indirect base classes)" ise o sınıfın doğurdan 
	taban sınıflarının taban sınıfları anlaşılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta (Java ve C#'ta da böyle) türemiş sınıf türünden bir nesne yaratıldığında türemiş sınıfın uygun yapıcı fonksiyonu çağrılır. Ancak türemiş sınıfın yapıcı 
	fonksiyonu taban sınıfın private bölümüne erişemediğine göre onun taban sınıf elemanlarına ilkdeğer veremez. İşte bunu sağlamak için şöyle bir mekanizma
	bulundurulmuştur: Türemiş sınıfın yapıcı fonksiyonu türemiş sınıfın taban sınıf kısmı için taban sınıfın yapıcı fonksiyonunu çağırmaktadır. Böylece nesnenin taban 
	sınıf kısmı taban sınıfın yapıcı fonksiyonu ile ilkdeğerlenmiş olur. Türemiş sınıfın yapıcı fonksiyonunun taban sınıfın yapıcı fonksiyonunu çağırması 
	türemiş sınıfın yapıcı fonksiyonun ana bloğunun başında derleyicinin yerleştirdiği gizli bir çağırma kodu yoluyla yapılmaktadır. Böylece önce taban sınıf yapıcı 
	fonksiyonu sonra türemiş sınıf yapıcı fonksiyonu çalıştırılmış olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme olduğu durumda her sınıfın yapıcı fonksiyonu kendi sınıfının doğrudan taban sınıfının yapıcı fonksiyonunu çağırmaktadır. Böylece
	aslında yapıcı fonksiyonlar yukarıdan aşağıya doğru çalıştırılmış olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

class C : public B {
public:
	C();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

C::C()
{
	cout << "C constructor" << endl;
}

int main()
{
	C c;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi taban sınıfın birden fazla yapıcı fonksiyonu varsa nesnenin taban sınıf parçası için taban sınıfın hangi yapıcı fonksiyonu çağrılacaktır? İşte bu durum
	daha önce görmüş olduğumuz MIL sentaksıyla belirlenmektedir. MIL sentaksında ':' atomundan sonra taban sınıfın ismi belirtilerek bir argüman listesi 
	girilirse o argüman listesine uygun taban sınıfın yapıcı fonksiyonu çağrılmaktadır. Eğer MIL sentaksında bu biçimde taban sınıf ismi belirtilmediyse bu durumda
	nesnenin taban sınıf parçası için taban sınıfın default yapıcı fonksiyonu çağrılmaktadır. 

	Tabii biz türemiş sınıfın yapıcı fonksiyonunda MIL sentaksında o yapıcı fonksiyonun parametrelerini taban sınıf yapıcı fonksiyonu için argüman olarak kullanabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	A(int x);
	
	int x() const { return m_x; }
private:
	int m_x;
};

class B : public A {
public:
	B();
	B(int x, int y);

	int y() const { return m_y; }
private:
	int m_y;
};

A::A()
{
	m_x = 0;
}

A::A(int a)
{
	m_x = a;
}

B::B()
{
	m_y = 0;
}

B::B(int x, int y) : A(x)
{
	m_y = y;
}

int main()
{
	B b1;

	cout << b1.x() << endl;		// 0
	cout << b1.y() << endl;		// 0

	B b2(10, 20);

	cout << b1.x() << endl;		// 10
	cout << b1.y() << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonlar ters sırada çalıştırılmaktadır. Bu durumda türemiş sınıfın yıkıcı fonksiyonunun ana bloğunun 
	sonunda derleyici tarafından yerleştirilen gizli bir çağırma kodu yoluyla taban sınıfın yıkıcı fonksiyonu çağrılmaktadır. Yani önce türemiş sınıfın sonra taban 
	sınıfın yıkıcı fonksiyonları çalıştırılmış olmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

A::~A() 
{
	cout << "A destructor" << endl;
}

B::B() 
{
	cout << "B constructor" << endl;
}

B::~B() 
{
	cout << "B destructor" << endl;
}

int main()
{
	cout << "main begins..." << endl;
	{
		B b;

		cout << "continues..." << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir sınıf hem başka bir sınıftan türetilmiş olsun hem de sınıfın başka sınıf türünden bir veri elemanı bulunyor olsun. Bu durumda yapıcı ve yıkıcı fonksiyonların
	çağrılma sıraları nasıl olacaktır? İşte her zaman önce taban sınıfın yapıcı fonksiyonu çalıştırılır, sonra elemanlara ilişkin sınıfların yapıcı fonksiyonu çalıştırılır 
	sonra da türemiş sınıfın yapıcı fonksiyonu çalıştırılır.  Tabii yıkıcı fonksiyonların çağrılma sırası ters biçimde olacaktır.

	C++'ta hiçbir zaman MIL sentaksındaki sıranın bir önemi yoktur. Yani örneğin biz MIL sentaksında önce eleman için belitim yapsak bile yine taban sınıfın 
	yapıcı fonksiyonu önce çağrılacaktır. Daha önceden de elemanlar için yapıcı fonksiyonların bildirimdeki sıraya göre çağrıldığını görmüştük.

	Aşağıdaki örnekte B sınıfı A sınıfından türetilmiştir ve X sınıfı türünden bir veri elemanına sahiptir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class X {
public:
	X();
	~X();
	//...

};

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
private:
	X m_x;
	int m_y;
};

X::X()
{
	cout << "X constructor" << endl;
}

X::~X()
{
	cout << "X destructor" << endl;
}

A::A()
{
	cout << "A constructor" << endl;
}

A::~A()
{
	cout << "A destructor" << endl;
}

B::B() : m_x(), A()		// MIL sentaksındaki sıranın hiçbir önemi yok! Yine önce A için yapıcı fonksiyon çağrılır
{
	cout << "B constructor" << endl;
}

B::~B()
{
	cout << "B destructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çoklu türetme durumunda sınıfın doğrudan taban sınıfı birden fazla olabilmektedir. Bu durumda taban sınıfların yapıcı fonksiyonlarının çağrılma sıraları 
	bildirimdeki sıraya göredir. MIL sentaksındaki sıranın bir önemi yoktur. Yine MIL sentaksında belirtilmeyen sınıflar için o sınıfların default yapıcı fonksiyonlarında çağrılmaktadır. 
	Tabii yıkıcı fonksiyonlar yine ters sırada çağrılırlar. Örneğin:

	class A {
		//...
	};

	class B {
		//...
	};

	class C : public A, public B {
		//...
	};

	Burada C'nin yapıcı fonksiyonu şöyle yazılmış olsun:

	C::C(...) : B(...)
	{
		//...
	}

	Burada MIL sentaksında A taban sınıfı belirtilmemiştir. Ancak yine derleyici önce A için default yapıcı fonksiyonu sonra B için belirtilen yapıcı 
	fonksiyonu çağırır.

	Sınıfın temel türlerine ilişkin veri elemanları için de MIL sentaksında ilkdeğer verilebildiğini görmüştük. Bunlar da tamamen sınıfın başka sınıf türünden 
	veri elemanlarıyla aynı hakka sahip olarak bildirimdeki sıraya göre ilkdeğer alırlar. Örneğin C sınıfı şöyle olsun:

	class C : public A, public B {
	public:
		//...
	private:
		int m_x;
		Y m_y;
	};

	C::C(...) : m_y(...), m_x(...), B(...)
	{
		//...
	}

	Burada önce A için default yapıcı fonksiyon çağrılır. Sonra B için belirtilen yapıcı fonksiyon çağrılır. Sonra X için ilkdeğerleme yapılır, sonra
	m_y için Y sınıfının uygun yapıcı fonksiyonu çağrılır. Tabii yıkıcı fonksiyonlar her zaman ters sırada çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir göstericiye (void gösterici dışında) farklı türden bir adres bilgisini doğrudan atayamayız. Ancak C++'ta istisna olarak türemiş sınıf türünden bir adres
	taban sınıf türünden bir göstericiye doğrudan atanabilmektedir. Yani türemiş sınıf adresleri taban sınıf adreslerine doğrudan dönüştürülebilmektedir. Örneğin,
	B sınıfı A sınıfından türetilmiş olsun:

	A *pA;
	B b;

	pA = &b;		// geçerli

	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye atanması sonrasında artık taban sınıf türünden gösterici türemiş sınıf nesnesinin
	taban sınıf kısmını gösteriyor durumda olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;
	A *pA;

	b.m_a = 10;
	b.m_b = 20;

	pA = &b;
	cout << pA->m_a << endl;					// 10

	pA->m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemin tersi geçerli değildir. Yani biz taban sınıf türünden bir nesnenin adresini türemiş sınıf türünden bir göstericiye doğrudan atayamayız.
	Eğer böyle bir şey mümkün olsaydı türemiş sınıf göstericisi yoluyla biz aslında var olmayan elemanlara erişebilirdik. Bu da tanımsız davranışa yol açardı.
	Türemiş sınıf türünden nesnenin adresini taban sınıf türünden göstericiye atayabiliyor olmamız türemiş sınıf nesnesinin taban sınıfı kapsamasından kaynaklanmaktadır.
	Halbuki taban sınıf nesnesi türemiş sınıf nesnesini kapsamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme söz konusu olduğunda türemiş sınıf nesnesinin adresi o türemiş sınıfın büütn taban sınıfları türünden göstericilere atanabilmektedir. Örneğin
	C sınıfı B sınıfından B sınıfı da A sınıfından türetilmiş olsun:

	A
	B
	C

	Biz burada C sınıfı türünden bir nesnenin adresini A sınıfı türünden ya da B sınıfı türünden bir göstericiye atayabiliriz. Yani türemiş sınıf adreslerinden 
	o sınıfın tüm taban sınıflarının adreslerine otomatik (implicit) tür dönüştürmesi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Referanslar da bir çeşit gösterici olduğuna göre türemiş sınıftan taban sınıfa adres dönüştürmeleri referanslar yoluyla da yapılabilmektedir. Yani taban sınıf
	türünden bir referans türemiş sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanabilir. Bu durumda taban sınıf türünden referans türemiş sınıf nesnesinin
	yine taban kısmının adresini tutacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;

	b.m_a = 10;
	b.m_b = 20;

	A &r = b;

	cout << r.m_a << endl;						// 10

	r.m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye ya da referansa atanması bir türetme şeması üzerinde genel işlemleri yapabilen fonksiyonların
	yazılmasını mümkün hale getirmektedir. Aşağıdaki gibi bir türetme şeması olsun:

                           Employee
              Worker        Manager        SalesPerson
			               Executive


	Burada her sınıf aslında Employee sınıfından türetilmiştir. Aşağıdaki gibi bir fonksiyon olsun:

	void disp_employee(const Employee &e);

	Biz bu fonksiyon ile çalışan kişi kim olursa olsun onun temel bilgilerini display edebiliriz. Çünkü bu temel bilgiler zaten Employee sınıfı içerisindedir ve
	her türemiş sınıfın aslında bir Employee kısmı vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// employee.hpp

#ifndef EMPLOYEE_HPP_
#define EMPLOYEE_HPP_

#include <string>

class Employee {
public:
	Employee(const char *name, const char *address, int no);
	
	std::string name() const { return m_name; }
	std::string address() const { return m_address; }
	int no() const { return m_no; }

private:
	std::string m_name;
	std::string m_address;
	int m_no;
};

#endif

// employee.cpp

#include "employee.hpp"

Employee::Employee(const char *name, const char *address, int no)
	: m_name(name), m_address(address), m_no(no)
{
	//...
}

// worker.hpp

#ifndef WORKER_HPP_
#define WORKER_HPP_

#include "employee.hpp"

enum class Shift {
	Morning, Noon, Even
};

class Worker : public Employee {
public:
	Worker(const char *name, const char *address, int no, Shift shift, int overtime);
private:
	Shift m_shift;
	int m_overtime;
};

#endif

// worker.cpp

#include "worker.hpp"

Worker::Worker(const char *name, const char *address, int no, Shift shift, int overtime)
	: Employee(name, address, no)
{
	m_shift = shift;
	m_overtime = overtime;
}

// manager.hpp

#ifndef MANAGER_HPP_
#define MANAGER_HPP_

#include <string>
#include "employee.hpp"

class Manager : public Employee {
public:
	Manager(const char *name, const char *address, int no, const char *department);
	//...
private:
	std::string m_department;
};

#endif

// manager.cpp

#include "manager.hpp"

Manager::Manager(const char *name, const char *address, int no, const char *department)
	: Employee(name, address, no), m_department(department)
{}

// app.cpp

#include <iostream>
#include "employee.hpp"
#include "worker.hpp"
#include "manager.hpp"

using namespace std;


void disp_employee(const Employee &e)
{
	cout << e.name() << ", " << e.address() << ", " << e.no() << endl;
}

int main()
{
	Worker w("Kaan Aslan", "Atasehir", 567, Shift::Morning, 2);
	Manager m("Necati Ergin", "Mecidiyekoy", 678, "Uretim");

	disp_employee(w);
	disp_employee(m);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf nesnesinin adresini taban sınıf türünden gösterici ya da referansa atayabilmemiz için türetme biçiminin "public türetmesi" olması gerekir. 
	Zaten en fazla kullanılan türetme biçiminin "public türetmesi" olduğunu anımsayınız. Örneğin:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	B b;
	A *pa = &b;		// error!

	Eğer böyle bir şeye izin verilseydi o zaman b yoluyla A'nın public bölümüne erişemediğimiz halde bu yolla erişebilir duruma gelirdik.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta derleyici bir isimle karşılaştığında o ismin bir bildirimini bulmak zorundadır. Bir isme ilişkin bildirimin bulunması sürecine standartlarda 
	"isim araması (name lookup)" denilmektedir. İsim araması ikiye ayrılmaktadır:

	1) Niteliksiz isim araması (unqualified name lookup)
	2) Nitelikli isim araması (qualified name lookup)

	Düz yazılan yani ".", "->" ve "::" opereatörü olmadan yazılan isimlerin aranması niteliksiz arama kurallarına göre yapılır. Ancak nokta operatörünün, 
	ok operatörünün ve :: operatörünün sol tarafındak isimlerin aranması niteliksiz, sağ tarafındaki isimlerin aranması nitelikli isim arama kuralına göre yapılmaktadır. İsim araması sırasıyla bazı faaliyet alanlarına sırasıyla bakılarak yapılır. 
	İsim sırasıyla çeşitli faaliyet alanlarınd aranır. İsim bulunursa arama devam ettirilmez. İsim bulunmazsa error oluşur. 

	Niteliksiz isimlerin aranması aşağıdaki sırada yapılmaktadır.

	1) İsim bir fonksiyon içerisinde kullanılmışsa derleyici ismi önce kullanım yerinden yukarıya doğru fonksiyonun yerel blokları içerisinde içten dışa doğru arar. 
	2) İsim bir üye fonksiyonun içerisinde kullanılmışsa o üye fonksiyonun ilişkin olduğu sınıf bildiriminin  her yerinde aranır (fonksiyon inline olarak sınıf içerisinde
	yazılmış olsa da sınıf bildiriminin her yerine bakılır.)
	3) İsim üye fonksiyonun ilişkin olduğu sınıfın taban sınıflarında aşağıdan yukarıya doğru onların sınıf bildirimlerinin her yerinde aranır. Eğer çoklu türetme 
	söz konusuysa ismin taban sınıf kollarından yalnızca birinde bulunuyor olması gerekir. Eğer farklı kollarda isim bulunursa bu durum error oluşturur. İsmin farklı kollardaki bulunduğu düzeyin 
	bir önemi yoktur. Yani çoklu türetmede arama kollarda herhangi bir sırada yapılmamaktadır. Başka bir deyişle bir kolun diğer kola herhangi bir üstünlüğü yoktur.
	4) İsim kullanıldığı fonksiyonun içinde bulunduğu isim alanı içerisinde kullanım yerinden yukarıdaki bölgede aranır.
	5) İsim kullanıldığı isim alanını kapsayan isim alanlarında içten dışa doğru kullanım yerinden yukarıdaki bölgede aranır.
	6) İsim nihayet global isim alanında kullanım yerinden yukarıdaki bölgede aranır.

	C++'ta her zaman önce isim araması yapılır. Sonra erişim kontrolü uygulanır. Yani arama erişilebilen isimler arasında yapılmaz. 

	C++'ta (Java ve C# gibi dillerde böyle değil) bir isim bir sınıfta bulunursa artık isim araması bitirilir. Dolayısıyla bulunan isim bir fonksiyon ismi 
	ise overload resolution işlemine aday fonksiyon olarak ismin bulunduğu sınıftaki aynı isimli fonksiyonlar sokulur. Taban sınıftaki fonksiyonlar artık
	overload resolution işlemine sokulmaz. Yani C++'ta "overload resolution" işlemi yalnızca aynı faaliyet alanındaki fonksiyonlar arasında yapılmaktadır. 

	Yukarıda belirttiğimiz gibi ".", "->" ve "::" operatörlerinin sağ tarafındaki isimler "nitelikli isim araması" kurallarına göre aranmaktadır. Nitelikli isim araması
	aşağıdaki sırada yapılmaktadır:

	1) Nokta ya da ok operatörünün sağındaki isimler solundaki nesne ya da gösterici hangi sınıf türündense o sınıf bildirimi içerisinde sınıf bildiriminin her 
	yerinde aranır. Eğer isim o sınıfta bulunamazsa aşağıdan yukarıya doğru isim o sınıfın taban sınıflarında onların bildirimlerinin her yerinde sırasıyla aranır.
	Ayrıca kapsayan isim alanlarında herhangi bir arama yapılmaz.  
	2) :: operatörünün sağındaki isimler eğer bu operatörün solunda bir isim alanı varsa yalnızca o isim alanında kullanım yerinden yukarıdaki bölgede aranır.
	Kapsayan isim alanlarına bakılmaz. Eğer :: operatörünün solunda bir sınıf ismi varsa isim o sınıf bildiriminde aranır, bulunamazsa taban sınıfların bildirimlerinde de 
	aşağıdan yukarıya doğru aranır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public: 
	void foo(double a)
	{
		cout << "A::foo double" << endl;
	}
	void foo(const char *name)
	{
		cout << "A::foo const char *" << endl;
	}
};

class B : public A {
public:
	void foo(int a)
	{
		cout << "B::foo int" << endl;
	}
	void bar()
	{
		foo(10.2);		// dikkat isim isim bulununca artık taban sınıflara bakılmaz!
		foo("ali");		// error! isim bulunuca artık taban sınıflara bakılmazm!
	}
};

int main()
{
	B b;

	b.bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıf ile türemiş sınıfta aynı isimi elemanların bulunduğu durumda isim arama kurallarına göre önce türemiş sınıftaki elemanlara bulunamazsa aşağıdan
	yukarıya doğru taban sınıftaki elemamlara bakılmaktadır. Bu tür durumlarda taban sınıftaki elemanlarına taban sınıf ismi ve çözünürlük operatörü ile erişilebilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// B::foo

	b.A::foo();		// A::foo

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de çokbiçimlilik biyolojiden aktarılmış bir kavramdır. Biyolojide çokbiçimlilik "bir canlının çeşitli doku ve organlarının temel işlevleri aynı kalmak üzere
	onların yaşam koşullarına göre farklılaşması" anlamına gelmektedir. Örneğin "kulak" pek çok canlıda vardır. Temel işlevi duymaktır. Ancak her canlının kulağı az çok 
	diğer canlılardan farklılıklar göstermektedir. 

	Pek çok teorisyene göre bir dilin nesne yönelimli olması için "sınıf", "türetme" dışında çokbiçimliliğe de sahip olması gerekmektedir. Eğer bir dilde sınıf varsa, türetme varsa
	ama çokbiçimlilik yoksa bu dillere "nesne yönelimli (object oriented)" değil "nesne tabanlı (object based)" diller denilmektedir. 
	
	Çokbiçimlilik (polymorphism) NYPT'nin en önemli anahtar kavramlarından biridir. Çeşitli bakış açılarına göre çeşitli biçimlerde tanımlanabilir:

	1) Çokbiçimlilik türden bağımsız kod paraçalarının oluşturulması için kullanılan bir tekniktir. (Yazılım mühendisliği tanımı)
	2) Çokbiçimlilik taban sınııfn belli bir fonksiyonunun türemiş sınıflar tarafından onlara özgü bir biçimde gerçekleştirilmesidir. (Biyolojik tanım)
	3) Çokbiçimlilik önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesi özelliğidir (Aşağı seviyeli tanım)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta çokbiçimlilik sanal fonksiyonlarla (virtual functions) gerçekleştirilmektedir. Yalnızca sınıfların static olmayan üye fonksiyonları sanal yapılabilmektedir. 
	Bir üye fonksiyonu sanal yapabilmek için üye fonksiyon bildiriminde "virtual" anahtar sözcüğünün kullanılması gerekir. virtual anahtar sözcüğü tanımlama sırasında
	kullanılamaz. Yalnızca bildirimde kullanılabnilir. Örneğin:

	class A {
	public:
		virtual void foo();		// sanal fonksiyon
		//...
	};

	void A::foo()				// tanımşama sırasında virtual anahtar sözcüğü kullanılmaz
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki bir sanal fonksiyon türemiş sınıfta "aynı isimle, aynı parametrik yapıyla" ve "aynı geri dönüş değeri türü ile" bildirilirse bu duruma 
	"taban sınıftaki sanal fonksiyonun türemiş sınıfta "override" edilmesi denilmektedir. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir geri dönüş 
	değeri türü ile override edilemez. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir parametrik yapıyla da override edilemez. 

	Taban sınıftaki sanal fonksiyon türemiş sınıfta override edildiğinde override edilmiş olan bu fonksiyon da sanal kabul edilir. Bu fonksiyonun başına
	virtual yazılmasa bile yazılmış kabul edilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	Taban sınıfta sanal olmayan bir fonksiyon türemiş sınıfta aynı biçimde yeniden tanımlanırsa bu bir override işlemi değildir. Override terimi sanal fonksiyonlar
	için kullanılır. Örneğin:

	class A {
	public:
		void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// bu bir override işlemi değil!
		//...
	};

	Taban sınıftaki sanal fonksiyon yanlışlıkla türemiş sınıfta farklı bir parametrik yapıyla (const'luk da dahil olmak üzere) yazılırsa bu durum override anlamına 
	gelmez. Bu konuda dikkat etmek gerekir. Örneğin:

	class A {
	public:
		virtual void foo() const;
		virtual void bar(int a);
		virtual void tar(int a);
		//...
	};

	class B : public A {
	public:
		void foo();			// geçerli ancak bu bir override işlemi değil! çünkü const'luk belirtilmemiş
		void bar();			// geçerli ancak bu bir override işlemi değil! parametrik yapılar farklı
		int tar(int a);		// geçersiz! aynı parametrik yapıyla farklı geri dönüş değeri türüyle override işlemi yapılamaz
		//...
	};

	Override işlemi bir dizi türetmede devam ettirilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Tabii sanallık daha sonra da başlatılabilir. Örneğin:

	class A {
	public:
		void foo();		// sanal değil
		//...
	};

	class B : public A {
	public:
		virtual void foo();				
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Override işlemi için sanal fonksiyonun doğrudan taban sınıfta olması gerekmemektedir. Yani sınııfn doğurdan taban sınıfında değil dolaylı taban sınıflarında 
	sanal yapılmış bir fonksiyon da overrde edilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
	};

	class B : public A {
	public:
		void foo(int a);		// override işlemi değil
	};

	class C : public B {
	public:
		void foo();				// geçerli override işlemi 
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden gösterici ya da referansın "statik" ve "dinamik" türü vardır. Sınıf türünden olmayan değişkenlerin yalnızca statik türleri vardır.
	Bir sınıf türünden gösterici ya da referansın statik türü bildirimde belirtilen türüdür. Dinamik türü ise o gösterici ya da referans bir nesneyi gösteriyorken 
	eğer aslında başka bir nesnenin türemiş sınıf parçasını gösteriyorsa gösterdiği nesnenin bütününün türüne o gösterici ya da referansın dinamik türü denilmektedir. 
	Gösterici ya da referansların statik türleriyle dinamik türlerinin farklılaşması türemiş sınıf nesnesinin adresinin taban sınıf türünden bir gösterici ya da 
	referansa atanmasıyla olur. Aşağıdaki gibi bir türetme şeması olsun:

	A
	B
	C

	C c;
	A *pA;

	pA = &c;

	Burada pA göstericisinin statik türü A'dır. Ancak dinamik trü C'dir. Çünkü pA aslında bütünü C olan bir nesnenin A parçasını göstermektedir. Örneğin:

	B *pB;

	pB = &c;

	Burada pB'nin statik türü B'dir. Ancak dinamik türü C'dir. Aynı durum referanslar için de söz konusudur. Örneğin:

	C c;
	B &b = c;

	Burada b referansının statik türü B, dinamik türü C'dir. Örneğin:

	C *pC;

	pC = &c;

	Burada pC göstericisinin statik türü ile dinamik türü aynıdır ve C'dir. 

	Statik tür değişmez. Ancak dinamik tür değişebilir. Örneğin:

	A
	B
	C

	C c;
	B b;
	A a;
	A *pA;

	pA = &c;		// pA'nın statik türü A, dinamik türü C
	//...
	pA = &b;		// pA'nın statik türü A, dinamik türü B
	//...
	pA = &a;		// pA'nın statik türü A, dinamik türü A

	Örneğin:

	void foo(A &r)
	{
		//...
	}
	//...
	C c;
	B b;
	A a;

	foo(c);			// r referansının dinamik türü A
	foo(b);			// r referansının dinamik türü A
	foo(a);			// r referansının dinamik türü A

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli (polymophic) mekanizma şöyledir: Bir sınıf türünden gösterici ya da referans ile o sınıfın bir üye fonksiyonu çağrılmış olsun. Bu üye fonksiyon 
	isim araması kuralına göre gösterici ya da referansın statik türüne ilişkin sınıfta aranır (tabii o sınıfta bulunamazsa taban sınıflara da bakılır). Sonra bulunan 
	fonksiyonun sanal olup olmadığına bakılır. Eğer bulunan fonksiyon sanal değilse bulunan fonksiyon çağrılır. Eğer bulunan fonksiyon sanal ise o fonksiyonun 
	çağrılmasında kullanılan gösterici ya da referansın dinamik türüne ilişkin override edilmiş sanal fonksiyon çağrılır. Eğer gösterici ya da referansın dinamik türüne 
	ilişkin sınıfta ilgili sanal fonksiyon override edilmemişse yukarıya doğru o sanal fonksiyonun override edilmiş olduğu ilk taban sınıfın sanal fonksiyonu çağrılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo();
	virtual void bar();
};

class B : public A {
public:
	void foo();		// override işlemi değil
	void bar();		// override işlemi
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void B::bar()
{
	cout << "B::bar" << endl;
}

int main()
{
	B b;
	A *pA;

	pA = &b;

	pA->foo();		// A::foo() çağrılır, çünkü foo sanal değil
	pA->bar();		// B::bar çağrlır, çünkü bar sanal

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansın dinamik türüne ilişkin sınıfta fonksiyon override edilmemiştir. Bu durumda yukarıya doğru fonksiyonun override edildiği ilk taban sınıfın
	fonksiyonu çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

int main()
{
	C c;

	A &r = c;		// referansın statik türü A, dinamik türü C

	r.foo();		// B::foo çağrılır, çünkü C'de foo override edilmemiş	

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte test fonksiyonun parametresi taban sınıf türünden bir göstericidir. Bu test fonksiyonu türemiş sınıf türünden nesnelerin adresleriyle çağrılmıştır.
	Çokbiçimli mekanizma gereği dinamik türe ilişkin sınıfların override edilmiş üye fonksiyonlarının çağrıldığına dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
public:
	void foo();
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void C::foo()
{
	cout << "C::foo" << endl;
}

void test(A *pA)
{
	pA->foo();
}

int main()
{
	A a;
	B b;
	C c;

	test(&a);
	test(&b);
	test(&c);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli teknikte ideal olarak kod üzerinde değişiklikler yapılmaz. Her zaman ekleme yöntemi uygulanır. Daha önceki kod sağlam çalışıyorsa ve ekleme işleminden 
	sonra problem oluşmuşsa problem eklenen kısımla ilgilidir. Bu durumda eklenen kısmın test edilmesi yeterlidir. Halbuki biz kodda bir değişiklik yaparsak
	tüm kodun yeniden test edilmesi gerekir. Çünkü yaptığımız değişiklik başka yerleri bozuyor olabilir. 

	İşte çokbiçimlilik türden bağımsız kod parçalarının ekleme yöntemiyle oluşturulması için kullanılan bir tekniktir. NYPT'de değişebilecek öğelere doğrudan değil 
	çokbiçimli olarak erişilir. Örneğin top ile oynanan bir oyun programında top değişebilir bir öğe olsun. Bu durumda biz top kavramını bir sınıfla temsil ederiz. 
	Oyunda "patlak topu", "zıplayan topu", "normal topu" bu top sınıfından türetme yaparak oluştururuz. Oyunda top genel bir kavram olarak Top sınıfıyla temsil edilir. 
	Ancak topun çeşiti eylemleri sanal fonksiyonlarla ifade edilir. Böylece bu top değiştiğinde artık kodda değişiklik yapılması gerekmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayantop gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("patlak");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda oyuna yeni bir top cinsi ekleyecek olalım. Tek yapacağımız şey aslında bu yeni top sınıfını Top sınıfından türetmek ve sanal fonksiyonları 
	bu sınıfta override etmektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

class HafifTop : public Top {
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayan top gidiyor" << endl;
}

void HafifTop::git()
{
	cout << "Hafif top gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else if (isim == "hafif")
		top = new HafifTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("hafif");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki birssanal fonksiyon bazen programcılar tarafından "override" edildi sanılmakta ancak programcı bu işlem sırasında parametre 
	türlerini yanlış yazdığı için aslında override işlemi yapılamamaktadır. İşte bu tür hataları engellemek için C++11 ile birlikte C++'a override anahtar sözcüğü 
	de eklenmiştir. Fonksiyonun parametre parantezinden sonra "override" anahtar sözcüğü yazılırsa bu durumda eğer taban sınıfta override edilecek bir sanal fonksiyon yoksa
	derleme aşamasında error oluşmaktadır. Örneğin:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(int a) override;		/* derleme sırasına error oluşacak */
		//...
	};

	Yine C++11 ile birlikte zaten Java ve C# gibi dillerde olan "final override" kavramı da C++'a eklenmiştir. Eğer fonksiyonun parametre parantezinden sonra "final" 
	anahtar sözcüğü getirilirse bu durumda o sanal fonksiyon artık daha fazla override edilemez. Edilmeye çalışılırsa derleme zamanı sırasında error oluşur. Örneğim:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(long a) override final;		// foo artık daha fazla override edilemez!
		//...
	};

	class C : public B {
	public:
		void foo(long a);		// compile time error!
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli uygulamalarda çoğu kez taban sınıf aslında türden bağımsız işlem yapmak için bulundurulmaktadır. Aslında o taban sınıf türünden bir nesne yaratılmamaktadır.
	İşte bu tür durumlarda taban sınıftaki sanal fonksiyonların boşuna gövdeye sahip olması gerekmez. Eğer taban sınıftaki sanal fonksiyonun gövdeye sahip olması istenmiyorsa
	fonksiyonun parametre parantezinden sonra "= 0" sentaksı kullanılır. Yalnızca sanal fonksiyonlarda bu sentaks kullanılabilmektedir. Bu tür fonksiyonlara C++'ta
	"saf sanal fonksiyonlar (pure virtual functions)" denilmektedir. En az bir saf sanal fonksiyona sahip olan sınıfa da "soyut sınıf (abstract class)" denir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class A {
public:
	virtual void foo() = 0;		// pure virtual
	//...
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

class C : public A {
public:
	void foo()
	{
		cout << "C::foo" << endl;
	}
};

class D : public A {
public:
	void foo()
	{
		cout << "D::foo" << endl;
	}
};

int main()
{
	vector<A *> v{new B(), new C(), new D(), new C()};

	for (A *pa : v)
		pa->foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Soyut sınıflar türünden nesneler yaratılmaz. Ancak göstericiler ve referanslar tanımlanabilir. Örneğin A bir soyut sınıf olsun B de bu soyut sınıftan türetilmiş
	soyut olmayan (somut (concrete) de diyebiliriz) bir sınıf olsun:

	A a;	// error! soyut sınıf türündne nesne yaratılamaz.
	A *pa;	// geçerli, soyut sınıf türünden gösterici yaratılabilir. 

	Bir soyut sııf türündne gösterici ya da referansa tipik olarak o sınıftan türetilmiş bir sınıf nesnesinin adresi atanabilir. Örneğin:

	A *pa;
	B b;

	pa = &b;		// geçerli
	A &r = b;		// geçerli

	pa->foo();		// B::foo çağrılır
	r.foo();		// B::foo çağrılır

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir soyut sınıftan türetme yapıldığında türemiş sınıfın taban soyut sınıftaki tüm saf sanal fonksiyonları override etmesi beklenir. Eğer türemiş sınıf taban 
	sınıftaki tüm saf sanal fonksiyonları override etmezse bu durumda tüemiş sınıf da soyut olur, türemiş sınıf türünden de nesneler yaratılmaz. Örneğin:

	class A {
	public:
		//...
		virtual void foo() = 0;
		virtual void bar() = 0;
		//...
	};

	Burada A soyut (abstract) bir sınıftır. A sınıfı türünden nesneler yaratamayız. Şimdi A sınıfından B sınıfını türetelim:

	class B : public A {
	public:
		//...
		void foo() override		// yalnızca foo override edilmiş olsun
		{
			//...
		}
		//...
	};

	Burada B sınıfında yalnızca foo override edildiği için B sınıfı da soyuttur ve B sınıfı türünden de nesneler yaratamayız. 

	A soyut sınıfındaki saf sanal fonksiyonların bir bölümü ondan türetilmiş B sınıfında override edilmiş olsun. Bu duurmda B de soyut bir sınıftır. Ancak geri 
	kalan saf sanal fonksiyonlar B'den türetilmiş  C override edilirse C artık soyut olmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo() = 0;
	virtual void bar() = 0;
	//...
};

class B : public A {
public:
	void foo() override 
	{
		//...
	}
	//...
};

class C : public B {
public:
	void bar() override
	{
		//...
	}
};

int main()
{
	A *pa = new C();		// geçerli, C soyut değil somut'
	//...

	delete pa;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Saf sanal fonksiyonların kullanılmasına yönelik Tetris örneğinin basit biimi aşağıdaki gibi olabilir. Bu örnekte taban Shape sınıfı "şekil kavramını"
	temsil etmektedir. Bu Shape sınıfından sınıflar türetilmiş ve sanal fonksiyonlar override edilmiştir. Shape sınıfı türünden hiçbir nesne yaratılmayacağı için
	Shape sınıfı soyut bir sınıf yapılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <cstdlib>
#include <Windows.h>
#include <conio.h>

using namespace std;

class Shape {
public:
	virtual void move_down() = 0;
	virtual void move_left() = 0;
	virtual void move_right() = 0;
	virtual void rotate() = 0;

private:
	//...
};

class BarShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class TShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class ZShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class SquareShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class LShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class Tetris {
public:
	Tetris();
	void run();
private:
	Shape *get_random_shape();		// static olabilir ancak henüz görmedik
	//...
};

void BarShape::move_down()
{
	cout << "Barshape move down" << endl;
}

void BarShape::move_left()
{
	cout << "Barshape move left" << endl;
}

void BarShape::move_right()
{
	cout << "Barshape move right" << endl;
}

void BarShape::rotate()
{
	cout << "Barshape rotate" << endl;
}

void TShape::move_down()
{
	cout << "TShape move down" << endl;
}

void TShape::move_left()
{
	cout << "TShape move left" << endl;
}

void TShape::move_right()
{
	cout << "TShape move right" << endl;
}

void TShape::rotate()
{
	cout << "TShape rotate" << endl;
}

void ZShape::move_down()
{
	cout << "ZShape move down" << endl;
}

void ZShape::move_left()
{
	cout << "ZShape move left" << endl;
}

void ZShape::move_right()
{
	cout << "ZShape move right" << endl;
}

void ZShape::rotate()
{
	cout << "ZShape rotate" << endl;
}

void SquareShape::move_down()
{
	cout << "SquareShape move down" << endl;
}

void SquareShape::move_left()
{
	cout << "SquareShape move left" << endl;
}

void SquareShape::move_right()
{
	cout << "SquareShape move right" << endl;
}

void SquareShape::rotate()
{
	cout << "SquareShape rotate" << endl;
}

void LShape::move_down()
{
	cout << "LShape move down" << endl;
}

void LShape::move_left()
{
	cout << "LShape move left" << endl;
}

void LShape::move_right()
{
	cout << "LShape move right" << endl;
}

void LShape::rotate()
{
	cout << "LShape rotate" << endl;
}

Tetris::Tetris()
{
	srand(time(NULL));
}

void Tetris::run()
{
	Shape *pshape;
	int ch;

	for (;;) {
		pshape = get_random_shape();
		for (int i = 0; i < 25; ++i) {
			pshape->move_down();
			Sleep(500);
			if (_kbhit()) {
				ch = _getch();
				switch (ch) {
					case 'a':				// move left
						pshape->move_left();
						break;
					case 'd':				// move right
						pshape->move_right();	
						break;
					case 's':				// rotate
						pshape->rotate();
						break;
					case 'q':
						goto EXIT;
				}
			}

		}
	}
EXIT:
	;
}

Shape *Tetris::get_random_shape()
{
	Shape *pshape;

	switch (rand() % 5) {
		case 0:
			pshape = new TShape();
			break;
		case 1:
			pshape = new ZShape();
			break;
		case 2:
			pshape = new SquareShape();
			break;
		case 3:
			pshape = new LShape();
			break;
		case 4:
			pshape = new BarShape();
			break;
	}

	return pshape;
}

int main()
{
	Tetris tetris;

	tetris.run();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında sınıf (class) ve üye fonksiyon (member function), veri elemanı (data member) gibi kavramlar yapay kavramlardır. İşlemcilerimiz prosedürel teknikte
	kodladığımız programları çalıştırmaya uygundur. Nesne yönelimli teknik yapay bir kavramdır. Gerçek makinenin çalışması C'deki gibidir, C++'taki gibi değildir. 
	Bu nedenle C++'ta bir sınıf aslında derlendiğinde C gibi kodlar üretilmektedir. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi de makinede 
	mümkün değildir. Dolayısıyla sınıf faaliyet alanı da yapay bir kavramdır. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi aslında derleyicilerin
	üye fonksiyonlara gizlice geçirdikleri bir parametre yoluyla sağlanmaktadır. Derleyiciler üye fonksiyonun çağrılmasında kullanılan nesnenin adresini üye fonksiyona
	gizlice (genellikle birinci parametre olarak) geçirirler ve veri elemanına erişmeyi bu gizli parametre yoluyla yaparlar. Bu gizlice geçirilen parametreye 
	this göstericisi denilmektedir. Aşağıdaki gibi bir sınıf söz konusu olsun:


	class Sample {
	public:
		void set_val(int val);
		void disp();
	private:
		int m_val;
	};

	void Sample::set_val(int val)
	{
		m_val = val;
	}

	void Sample::disp()
	{
		cout << m_val << endl;
	}

	int main()
	{
		Sample s;

		s.set_val(10);
		s.disp();

		return 0;
	}

	Aslında bu kod derlendiğinde makine kodları incelendiği zaman bu kodların tamamen C gibi ve aşağıdakine benzer olduğu görülür:

	#include <stdio.h>

	using namespace std;

	struct Sample {
		int m_val;
	};

	void Sample_set_val(struct Sample *this, int val)
	{
		this->m_val = val;
	}

	void Sample_disp(struct Sample *this)
	{
		printf("%d\n", this->m_val);
	}

	int main()
	{
		struct Sample s;

		Sample_set_val(&s, 10);
		Sample_disp(&s);

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    this göstericisi üye fonksiyonlara gizlice geçiriliyor olsa da üye fonksiyon içerisinde açıkça kullanılabilir. this hangi sınıfın üye fonksiyonu içerisinde kullanılıyorsa
	o sınıf türünden bir gösterici belirtmektedir. Bir üye fonksiyon içerisinde sınıfın m_val gibi bir veri elamanına doğrudan m_val ismiyle erişmekle this->m_val 
	biçiminde erişmek arasında hiçbir performans farklılığı yoktur. Zaten programcı bu elemana m_val biçiminde eriştiğinde aslında derleyici ürettiği kodda buna
	this->m_val gibi erişmektedir. 

	foo gibi bir üye fonksiyon içerisinde bar üye fonksiyonun aşağıdaki gibi çağrıldığını düşünelim:

	void Sample::foo()
	{
		//...
		bar();
		//...
	}

	Aslında bu çağrı tamamen this->bar() gibi yapılmaktadır. Yani bar fonksiyonuna geçirelecek this göstericisi aslında foo fonksiyonun this göstericisidir. 

	void Sample::foo()
	{
		//...
		this->bar();		// bar(); ile eşdeğer
		//...
	}

	const bir üye fonksiyon aslında ona gizlice geçirilen this göstericisinin const olduğu (gösterdiği yer const olduğu) bir fonksiyondur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir üye fonksiyonun geri dönüş değeri kendi sınıfı türünden bir sol taraf değeri referansı olur. Fonksion da *this ifadesiyle geri döner. Bu durumda *this
	üye fonksiyonun çağrıldığı nesnedir. Dolayısıyla fonksiyon da aslında bize bu nesneyi geri döndürür. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample &foo();
	void bar();
	//...
};

Sample &Sample::foo()
{
	cout << "Sample::foo" << endl;

	return *this;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;

	s.foo().bar();		// s.foo(); s.bar(); ile eşdeğer etki

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir sınıfın üye fonksiyonları ve veri elemanları static olabilir ya da olmayabilir. Biz şimdiye kadar hep static olmayan (nonstatic)  üye fonksiyonlarını
	ve veri elemanlarını kullandık. Gerçekten de static üye fonksiyonlar ve veri elemanları seyrek kullanıldığı için "üye fonksiyon" denildiğinde özellikle static'lik 
	belirtilmediyse static olmayan üye fonksiyon anlaşılmalıdır. Benzer biçimde "veri elemanı" denildiğinde de özellikle static'lik belirtilmediyse static olmayan
	veri elemanı anlaşılmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı global fonksiyonlar belli bir konuyla ilgili iş yapıyor olabilirler. Bu durumda o global fonskiyonların o konuya ilişkin sınıf ile ilişkilendirilmeleri 
	iyi bir tekniktir. Örneğin bir yılın artık yıl olup olmadığını belirleyen isleap isimli bir fonksiyon mantıksal ilgi nedeniyle Date sınıfın static bir üye fonksiyonu
	yapılmalıdır. static üye fonksiyonlar sınıfın veri elemanlarını kullanamazlar. Eğer sınıfın veri elemanlarını kullanmayan fonksiyonlar sınıfın static olmayan 
	bir üye fonksiyonu olarak yazılırsa bu durumda gereksiz biçimde onun bir nesne ile çağrılma zorunluluğu ortaya çıkar. Halbuki bu fonksiyonlar sınıfın veri elemanlarını zaten kullanmamaktadır.
	İşte bir üye fonksiyon static yapılırsa artık o üye fonksiyon bir nesne olmadan sınıf ismi ve :: operatörüyle (tabii public bölümdeyse) çağrılabilmektedir. Bir üye fonksyonu static yapabilmek için
	sınıf bildirimi içerisindeki prototipin önüne "static" anahtar sözcüğü getirilir. static anahtar sözcüğü tanımlamada kullanılamaz. Örneğin:

	class Sample {
	public:
		void foo();
		static void bar();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	int main()
	{
		Sample::foo();		// nesne olmadan sınıf ismiyle çağırabiliriz

		return 0;
	}

	static üye fonksiyonlar nesne ile çağrılmadığı için onlara this parametresi geçirilmez. Dolayısıyla da static üye fonksiyonlar sınıfın static olmayan veri elemanlarını
	ve static olmayan üye fonksiyonlarını kullanamazlar. 

	Aslında static üye fonksiyonlar bir nesne, gösterici ya da referans yoluyla da çağrılabilirler. Bu çağrımada derleyici static üye fonksiyonun çağrıldığı 
	nesnenin türüne bakar ve üye fonksiyonun o sınıf ismi ile çağrıldığını kabul eder. Tabii bu durumda yine this göstericisi fonksiyona geçirilmemektedir. Örneğin:

	Sample::foo();

	Sample s;
	s.foo();		// tamamen Sample::foo() ile eşdeğer

	Sınıfın static üye fonksiyonları const üye fonksiyonlar yapılamaz. Zaten static üye fonksiyonlar sınııfn static olmayan veri elemanlarına erişemedikleri için 
	bunların const yapılmasının bir anlamı da yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }

	static bool isleap(int year);
	static Date today();
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date date;

	cout << (Date::isleap(2000) ? "Artik" : "Artik degil") << endl;
	date = Date::today();

	date.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların static veri elamanlarının toplamda tek bir kopyası bulunur. static veri elemanları sınıf türünden nesnelerin içerisinde yer kaplamazlar. Yani nesnelerin
	bir parçası değillerdir. O sınıf türünden nesne yaratılsa da yaratılmasa da her zaman bu tek kopya yaratılmış bir biçimde bulunur. Sınıf içerisinde bu static
	veri elemanı kullanıldığında her zaman o tek olan kopya kullanılıyor durumdadır. Aslında sınıfın veri veri elemanaları pekala global bir nesne olabilecek durumdadır. 
	Ancak programcı onu global yapmak yerine sınıf ile mantıksal ilişkisi nedeniyle sınıfın içerisine yerleştirmiştir ve static yapmıştır. 

	Sınıfların static veri elemanları ismiyle de kullanılabilmektedir. Çünkü onlar aslında hiçbir nesnenin parçası değildir. 
	Veri elemanını static yapmak için sınıf bildiriminde static anahtar sözcüğü kullanılır. Ancak static veri elemanlarının sınıfın dışında  bir tanımlamasının 
	yapılması gerekir. Bu tanımlama sınıf ismi ve çözünürlük operatörü ile yapılır. Tanımlama sırasında static anahtar sözcüğü kullanılmaz ancak ilkdeğer verilebilir. Örneğin:

	class Sample {
	public:
		//...
		int m_a;
		int m_b;
		static int m_c;
	};

	int Sample::m_c;

	int main()
	{
		Sample::m_c = 10;

		cout << Sample::m_c << endl;

		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

struct Sample {
	//...
	int m_a;
	int m_b;
	static int m_c;
};

int Sample::m_c;

int main()
{
	Sample::m_c = 10;

	cout << Sample::m_c << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın static veri elemanlarının da private bölüme konularak onlara public getter/setter fonksiyonlar ile erişilmesi veri gizlemesi (data hidening) bakımından
	tavsiye edilmektedir. Tabii bu durumda getter/setter fonksiyonların static üye fonksiyon olması anlamlıdır. static üye fonksiyonlar sınıfın diğer static üye 
	fonksiyonlarını doğrudan çağırabilir ve sınıfın static veri elemanlarını doğrudan kullanabilir. Ancak static olmayan elemanlarını kullanamaz. 

	Sınıfın static veri elemanlarına yine o sınıf türünden nesne, gösterici ya da referans yoluyla erişebiliriz. Bu durumda erişimde kullanılan nesne aslında yalnızca
	sınıfın türünü belirtmektedir. Bu biçimde erişimler yanlış anlaşılmaya yol açabilmektedir. Bu nedenle static veri elemanlarına sınıf ismiyle erişmeye gayret etmelisiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a = 0, int b = 0) : m_a(a), m_b(b)
	{
		++m_count;
	}
	static int count() { return m_count; }
	static void set_count(int count) { m_count = count; }

private:
	int m_a;
	int m_b;
	static int m_count;
};

int Sample::m_count;

int main()
{
	Sample s;
	Sample k;
	Sample z;

	cout << Sample::count() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz sınıfın üye fonksiyonlarına ve veri elemanlarına "sınıfın elemanları" diyelim. static olmayan üye fonksiyonlarına ve static olmayan veri elemanlarına da "static olmayan elemanları"
	diyelim. Bu durumda static üye fonksiyonlar sınıfın yalnızca static elemanlarını kullanabilirler. Ancak static olmayan üye fonksiyonlar sınıfın hem static olmayan
	elemanlarını hem de static olan elemanlarını kullanabilirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }
	
	const char *get_day_name() const;

	static bool isleap(int year);
	static Date today();
	
private:
	static long get_total_days(int day, int month, int year);
	static const char *get_day_name(int day, int month, int year);
private:
	int m_day;
	int m_month;
	int m_year;

	static int ms_montab[12];
	static const char *ms_monnames[7];
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

int Date::ms_montab[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const char *Date::ms_monnames[7] = {"Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi"};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << '-' << get_day_name() << endl;
}

const char *Date::get_day_name() const
{
	return get_day_name(m_day, m_month, m_year);
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

long Date::get_total_days(int day, int month, int year)
{
	long total = 0;

	for (int i = 1900; i < year; ++i)
		total += isleap(i) ? 366 : 365;

	ms_montab[1] = isleap(year) ? 29 : 28;
	for (int i = 0; i < month - 1; ++i)
		total += ms_montab[i];

	total += day;

	return total;
}

const char *Date::get_day_name(int day, int month, int year)
{
	auto tdays = get_total_days(day, month, year);

	return ms_monnames[tdays % 7];
}

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date d(23, 4, 1920);

	d.disp();

	cout << d.get_day_name() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Global bir fonksiyon ya da başka bir sınıfın üye fonksiyonu bir sınıfın arkadaş fonksiyonu yapılabilir. Bu durumda arkadaş yapılan fonksiyon özel bir 
	erişim ayrıcalığına sahip olur. Arkadaş fonksiyonlar içeriisinde arkadaş olunan sınıf türünden bir nesne, gösterici ya da referans yoluyla o sınıfın tüm 
	bölümlerine erişebiliriz. friend bildirimi sınıfın herhangi bir bölümünde yapılabilir. Hangi bölümünde yapıldığının bir önemi yoktur. 

	Global bir fonksiyon friend yapıldığında friend bildirimi için o global fonksiyonun prototipinin ya da tanımlamasının görülmüş olması gerekmez. Ancak 
	friend bildirimi dışarısı için bir prototip bildirimi olarak kullanılamaz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend void foo();
private:
	int m_a;
};

void foo()
{
	Sample s;

	s.m_a = 10;					// geçerli çünkü foo friend

	cout << s.m_a << endl;		// geçerli çünkü foo friend
}

int main()
{
	foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Arkadaş sınıf bir sınıfın tüm üye fonksiyonlarının arkadaş olduğu anlamına gelmektedir. Bir sınıfı arkadaş yapabilmek için "friend class" bildirimi gerekir. 
	Örneğin:

	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend class Mample;
	};

	Burada Mample sınıfı Sample sınıfının arkadaş sınıfıdır. Yani Mample içerisindeki foo ve bar üye fonksiyonlarında Sample türünden bir nesne, gösterici ya da referenas 
	yoluyla Sample sınıfının her bölümüne erişilebilir. Arkadaş bildiriminde arkadaş olarak bildirilen sınıf daha sonra bildirilebilir. Örneğin:

	class Sample {
		//...
		friend class Mample;
	};
	
	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	Tabii bunun için friend anahtar sözüğünün yanında class anahtar sçzcüğünün bulundurulması gerekir. Eğer arkadaş sınıf daha yukaıda bildiriliyorsa bu durumda 
	class anahtar sözcüğünün bulundurulması gerekmez. Örneğin:

		class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend Mample;		// geçerli
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend class Mample;
private:
	int m_a;
};

class Mample {
public:
	void foo()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}

	void bar()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}
};

int main()
{
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bir bağlı liste bir sınıfla temsil edilmiş olsun. Onun düğümleri de bir sınıfla temsil edilmiş olabilir. Bu durumda bağlı listenin bu düğümlerin
	private elemanlarına erişmesi gerekebilmektedir. İşte Node sınıfında bağlı sınıfını arkadaş sınıf yapabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// linkedlistint.hpp 

#ifndef LINKEDLISTINT_HPP
#define LINKEDLISTINT_HPP

#include <cstddef>

class Node {
public:
	Node() = default;
	Node(int val) : m_val(val), m_next(nullptr)
	{}
	friend class LinkedListInt;
private:
	Node *m_next;
	int m_val;
};

class LinkedListInt {
public:
	LinkedListInt() : m_head(nullptr), m_tail(nullptr), m_size(0)
	{}
	~LinkedListInt();
	Node *add_tail(int val);
	void disp() const;
	std::size_t size() const { return m_size; }
private:
	Node *m_head;
	Node *m_tail;
	std::size_t m_size;
};

#endif

// linkedlistint.cpp

#include <iostream>
#include "linkedlistInt.hpp"

using namespace std;

Node *LinkedListInt::add_tail(int val)
{
	Node *new_node = new Node(val);

	if (m_head != nullptr)
		m_tail->m_next = new_node;
	else
		m_head = new_node;

	m_tail = new_node;

	++m_size;

	return new_node;
}

void LinkedListInt::disp() const
{
	for (Node *node = m_head; node != nullptr; node = node->m_next)
		cout << node->m_val << " ";
	cout << endl << m_size << " element listed" << endl;
}

LinkedListInt::~LinkedListInt()
{
	Node *node, *temp;

	node = m_head;
	while (node != nullptr) {
		temp = node->m_next;
		delete node;
		node = temp;
	}
}

// app.cpp

#include <iostream>
#include "LinkedListInt.hpp"

using namespace std;

int main()
{
	LinkedListInt lli;

	for (int i = 0; i < 100; ++i)
		lli.add_tail(i);

	lli.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları (operator ovrloading) C++'ın yanı sıra C#, Swift, Python gibi dillerde de olan bir özelliktir. Operatör fonksiyonları sayesinde sınıf nesneleri
	sanki temel türlerden nesnelermiş gibi +, -, * gibi operatörlerle işleme sokulabilmektedir. Operatör fonksiyonları aslında dile ilave bir işlevsel katmaz. 
	Yalnızca okunabilirlilk sağlamaktadır. 

	Operatör fonksiyonları bir sınıfın static olmayan üye fonksiyonları biçiminde yazılabilir ya da global bir fonksiyon biçiminde yazılabilir. Operatör fonksiyonlarının 
	genel biçimi şöyledir:

	<geri dönüş değerini türü> operator <operatör sembolü> ([parametre bildirimi])
	{
		//...
	}

	Operatör fonksiyonları tamamen normal bir fonksiyon gibidir. Bunların tek farkı isimlerinin operator anahtar sözcüğü ve operatör sembolünden oluşmasıdır. 

	Operatör fonksiyonlarının geri dönüş değerleri herhangi bir biçimde olabilir. Ancak operatör fonksiyonlarının parametre sayıları üzerinde kısıt vardır. Şöyle ki:

	- Operatör fonksiyonu iki operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon tek parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon iki parametreye sahip olmak zorundadır. 

	- Operatör fonksiyonu tek operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon sıfır parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon bir parametreye sahip olmak zorundadır. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları olmasaydı biz sınıflar üzerindeki operatörsel işlemleri normal fonksiyonlara yaptırırdık. Örmeğin aynı sınıf üründen iki sınıf nesnesini 
	toplamak için sınıf içerisine add isimli bir static olmayan üye fonksiyon ya da static bir üye fonksiyon yerleştirebilirdik. Gerçekten de örneğin Java'da operatör
	fonksiyonları olmadığı için böyle işlemler üye fonksiyonlarıyla (metotlarla) yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number add(const Number &a) const;
	static Number add(const Number &x, const Number &y);

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
	
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::add(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::add(const Number &x, const Number &y)
{
	Number result;

	result.m_val = x.m_val + y.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a.add(b);	
	c.disp();

	c = Number::add(a, b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşte operatör fonksiyonları aslında yukarıdaki gibi normal fonksiyonlardır. Onların tek farklılıkları isimlerinin operator anahtar sözcüğü ve operatör sembolünden
	oluşmasıdır. Tabii operatör fonksiyonları aslında isimle de çağrılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a + b;	// a.operator +(b)
	c.disp();

	c = a.operator +(b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ derleyicisi bir operatörle karşılaştığında önce operand'ların türlerine bakar. Eğer operand'lar temel türlere ilişkinse işlem öncesi otomatik tür 
	dönüştürmesi yoluyla işlemi yapar. Eğer operand'lardan en az bir tanesi bir sınıf türündense bu işlemi yapabilmek için sınıf içerisinde ve global düzeyde 
	operatör fonksiyonu araştırır. Operatör sembolü @ ile temsil ediliyor olsun:

	1) a @ b gibi bir işlem için derleyici a operand'ının ilişkin olduğu sınıfta a.operator @(b) çağrısına uygun bir @ operatör fonksiyonu araştırır. Aynı zamanda 
	derleyici bu işlemi yapabilecek global düzeyde operator @(a, b) çağrısına uygun bir global operatör fonksiyonu araştırmaktadır. Sınıfın operator @ ve global operator @
	fonksiyonları aday fonksiyonlar olarak seçilir ve "over resolution" işlemine sokulur. 

	2) @a ya da a@ gibi unary bir operatör için derleyici yine sınıfın içerisinde ve global düzeyde operator @ fonksiyonları araştırmaktadır. Sınıfın içerisinde 
	a.operator @() çağrısına uygun ya da global düzeyde operator @(a) çağrısına uygun global operatör fonksiyonlarını aday fonksiyon olarak belirler ve bunları 
	"overload resolution" işlemine sokar.

	Yukarıdaki örnekte:

	c = a + b;

	Burada derleyici bu toplama işlemini yapabilecek Number sınıfında operator + isimli üye fonksiyonu ile global düzeyde operator + isimli global fonksiyonları 
	araştıracaktır. Dolayısıyla derleyici için bu işlem aşağıdakiyle eşdeğer olacaktır:

	c = a.operator +(b);

	C++'ta ".", "::", "?:" ve ".*" operatörlerine ilişkin operatör fonksiyonları zaten hiç yazılamamaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Operatör fonksiyonları kombine edilebilir. Ancak bu duurmda operatör fonksiyonlarının çağrılma sırası operatör nceliklerine göre yapılmaktadır. Operatör
	önceliklerini değiştirmenin bir yolu yoktur. Örneğin:

	result = a + b * c;

	gibi bir işlemde önce b ile c operator * fonksiyonu ile işleme sokulur. Buradan elde edilecek değer a ile toplanır. Yani bu işlemin eşdeğeri şöyledir:

	result = a.operator +(b.operator *(c));

	Örneğin:

	result = a + b + c;

	Bu işlemin de eşdeğeri şöyledir:

	result = a.operator +(b).operator +(c);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator *(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + b * c;		// result = a.operator +(b.operator *(c));
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları anlamlı ve herkes tarafındna tahmin edilebilecek bir işleve sahip olacaksa bulundurulmalıdır. Bazı operatörler varsa onunla ilişkili 
	bazı operatörlerin de sınıfta bulundurulması uygun olur. Örneğin sınıfta '+' operatör fonksiyonu varsa '-' operatör fonksiyonu da sınıfta bulundurulmalıdır.
	'*' operatör fonksiyonu varsa '/' operatör fonksiyonu da sınıfta bulundurulmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + a + a;		
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları da "overload" edilebilirler. Yani farklı parametrik yapılara sahip aynı isimli birden fazla operatör fonksiyonu bir arada bulunabilir. 
	Örneğin iki Number nesnesini toplayan + operatör fonksiyonunun yanı sıra bir Number nesnesi ile bir int değeri toplayan bir + operatör fonksiyonu bir arada 
	bulunabilir. Ancak bazı operatörlerin değişme özelliğinin sağlanması da gerekir. Örneğin bir Number nesnesi ile bir int değeri toplayabiliyorsak, bir int değerle
	bir Number nesnesini de toplayabilmemiz gerekir. Ancak bir int değerle birt Number nesnesini toplayabilen üye operatör fonksiyonu yazmak mümkün değldir. Örneğin:

	int a = 10;
	Number b(20);
	Number result;

	result = a + 10;		// result = a.operator +(10);
	result = 10 + a;		// result = 10.operator +(a); Dikkat! int bir sınıf değil! mümkün değil

	İşte bu tür durumlarda global operatör fonksiyonları ile bu işlemler yapılabilmektedir. C++'ta birkaç operatörün operatör fonksiyonları üye operatör fonksiyonu 
	biçiminde yazılmak zorundadır. Ancak pek çok operatör üye operatör fonksiyonu biçiminde ve global operatör fonksiyonu biçiminde yazılabilmektedir. Bu tür durumlarda
	programcılar genellikle üye operatör fonksiyonu olarak yazabildiklerini üye operatör fonksiyonu olarak, yazamadıklarını da global operatör fonksiyonu olarak 
	yazmalıdırlar.

	Operatör fonksiyonunu global operatör fonksiyonu olarak yazdığımızda artık sınıfın private elemanlarına erişemeyeceğimize dikkat ediniz. Bu durumda mecburen 
	sınıfın getter/setter fonksiyonlarındna faydalanırız. Aslında bu tür fonksiyonların "arkadaş (friend)" yapılması çok karşılaşılan bir durumdur. 

	Tabii aslında bu tür global operatör fonksiyonları bir "sarma (wrapper)" fonksiyon olarak da yazılabilmektedir. Örneğin:

	inline Number operator +(int val, const Number &x)
	{
		return x + val;
	}

	C++'ta dört operatöre ilişkin operatör fonksiyonlarının üye operatör fonksiyonu olarak yazılması zorunlu tutulmuştur. Bunlar "=", "(...)", "[]" ve "->" operatör
	fonksiyonlarıdır. Diğer operatörlerin operatör fonksiyonları üye operatör fonksiyonu ya da global operatör fonksiyonu biçiminde yazılabilirse de programcı 
	mümkün olduğu kadar üye operatör fonksiyonu biçiminde bunları yazmaya çalışmalıdır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	Number operator +(int val) const;
	Number operator -(int val) const;
	Number operator *(int val) const;
	Number operator /(int val) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

Number Number::operator +(int val) const
{
	Number result;

	result.m_val = m_val + val;

	return result;
}

Number Number::operator -(int val) const
{
	Number result;

	result.m_val = m_val - val;

	return result;
}

Number Number::operator *(int val) const
{
	Number result;

	result.m_val = m_val * val;

	return result;
}

Number Number::operator /(int val) const
{
	Number result;

	result.m_val = m_val / val;

	return result;
}

inline Number operator +(int val, const Number &x)
{
	Number result;

	result.set_val(val + x.val());

	return result;		// return x + val;
}

Number operator *(int val, const Number &x)
{
	Number result;

	result.set_val(val * x.val());

	return result;
}

int main()
{
	Number a(1), result;

	result = a + 2;
	result.disp();

	result = 2 + a;
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatör fonksiyonlarının geri dönüş değerleri herhangi bir türden olabilir ancak bunların bool türden olması en uygun durumdur. 
	Karşılaştırma operatör fonksiyonlarının mümkünse hepsi yazılmalıdır. Yani örneğin eğer biz < operatör fonksiyonunu yazmış isek > opertör fonksiyonunu da
	yazmalıyız. == operatör fonksiyonunu yazmış isek != operatör fonksiyonunun da yazılması uygun olur. Yani mümkünse <, >, <=, >=, ==, != operatör fonksiyonlarının
	hepsinin yazılması tavsiye edilmektedir. Tabii bazı sınıflar için örneğin == ve != operatörleri anlamlı iken <, >, <=, >= operatör fonksiyonlaırnın bir anlamı olmayabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    ++ ve -- operatörlerine ilişkin operatör fonksiyonları da yazılabilir. Ancak bu operatörler hem önek (prefix) hem de sonek (postfix) kullanılabildiğinden dolayı
	bunların yazımları için bazı noktalaa dikkat edilmesi gerekir. Birinci nokta önek ++ operatörünün C++'ta nesnenin kendisine ilişkin sol taraf değeri üretmesidir. 
	Bu özelliğin sağlanabilmesi için bu operatör fonksiyonu yazılırken fonksiyonun geri dönüş değerinin türü aynı sınıf türünden bir referans olmalı ve fonksiyon 
	*this ifadesi ile geri dönmelidir. C++'ta bu operatörlerin sonek versiyonları nesne belirtmez bu nedenle bu operatörlerin seonek versiyonları yazılırken geri dönüş değerinin 
	türü kendi sınıfı türünden const bir nesne (referans değil) olmalıdır. Sonek versiyonların nesnenin değerini önce yerel bir nesnede saklayıp artırım ya da eksiltimi nesne üzerinde yapması 
	ve sonra da bu yerel nesneyle geri dönmesi uygun olur. Bu operatörlere ilişkin operatör fonksiyonlarının yazılması sırasında bunların önek ve sonek biçimleri 
	ayrı ayrı yazılır. Sonek biçiminde aslında programcının kullanmayacağı "dummy" bir int parametre bulundurulur. Örneğin:

	class Complex {
		//...
		Complex &operator ++();				// önek
		const Complex operator ++(int);		// sonek
		Complex &operator --();				// önek
		const Complex operator --(int);		// sonek
	};

	Aşağıdak Complex sayı sınıfında bu operatörlerin kullanılmasına ilişkin bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP_
#define COMPLEX_HPP_

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0);
	Complex operator +(const Complex &r) const;
	Complex operator +(double real) const;
	Complex operator -(const Complex &r) const;
	Complex operator *(const Complex &r) const;

	Complex &operator ++();			// prefix
	const Complex operator ++(int);	// postfix

	Complex &operator --();			// prefix
	const Complex operator --(int);	// postfix

	void disp() const;
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

Complex::Complex(double real, double imag)
{
	m_real = real;
	m_imag = imag;
}

void Complex::disp() const
{
	cout << m_real << '+' << m_imag << 'i' << endl;
}

Complex Complex::operator +(const Complex &r) const
{
	Complex result;

	result.m_real = m_real + r.m_real;
	result.m_imag = m_imag + r.m_imag;

	return result;
}

Complex Complex::operator +(double real) const
{
	Complex result;

	result.m_real = m_real + real;
	result.m_imag = m_imag;

	return result;
}

Complex Complex::operator -(const Complex &r) const
{
	Complex result;

	result.m_real = m_real - r.m_real;
	result.m_imag = m_imag - r.m_imag;

	return result;
}

Complex Complex::operator *(const Complex &r) const
{
	Complex result;

	result.m_real = m_real * r.m_real - m_imag * r.m_imag;
	result.m_imag = m_real * r.m_imag + m_imag * r.m_real;

	return result;
}

Complex &Complex::operator ++()
{
	++m_real;

	return *this;
}

const Complex Complex::operator ++(int)	
{
	Complex z = *this;

	++m_real;

	return z;
}

Complex &Complex::operator --()
{
	--m_real;

	return *this;
}

const Complex Complex::operator --(int)
{
	Complex z = *this;

	--m_real;

	return z;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{
	Complex z{3, 2}, k{1, 2};

	z.disp();

	auto result = z-- + k;

	z.disp();
	result.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesini [] operatörüyle kullanabilmek için o sınıfta bir [] operatör fonksiyonunun bulunuyor olması gerekir. a bir sınıf nesnesi olmak 
	üzere a[n] işleminin eşdeğeri a.operator[](n) biçimindedir. Gerçekten de standrat kütüphanedeki vector gibi string gibi sınıflar bu operatör fonksiyonuna sahiptir. 
	[] opeartör fonksiyonu üye operatör fonksiyonu olarak yazılmak zorundadır. 
	
	[] operatörüne ilişkin operatör fonksiyonları yazılırken fonksiyonun bir referansa geri dönmesi gerekir. Çünkü köşeli parantez 
	ifadesine aynı zamanda atama da yapılabilmektedir. const nesnelerle köşeli parantez operatörünün kullanılabilmesi için bu operatör fonksiyonun 
	const bir biçimi de bulundurulmalıdır. Tabii bu biçimin const bir referansa geri dönmesi uygun olur.

	Aşağıdaki örnekte Date sınıfının day, month, year bileşenleri [] operatör fonksiyonu ile elde edilmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date(int day, int month, int year) : m_day(day), m_month(month), m_year(year)
	{}
	void disp() const;
	int &operator[] (size_t index);
	const int &operator[] (size_t index) const;
private:
	int m_day;
	int m_month;
	int m_year;
};

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int &Date::operator[] (size_t index)
{
	if (index == 0)
		return m_day;
	if (index == 1)
		return m_month;
	if (index == 2)
		return m_year;

	throw invalid_argument("index out of range");
}

const int &Date::operator[] (size_t index) const
{
	if (index == 0)
		return m_day;
	if (index == 1)
		return m_month;
	if (index == 2)
		return m_year;

	throw invalid_argument("index out of range");
}

int main()
{
	Date d(12, 11, 2007);

	cout << d[0] << endl;
	cout << d[1] << endl;
	cout << d[2] << endl;

	d[0] = 13;
	d[1] = 6;
	d[2] = 2022;

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    En önemli operatör fonksiyonlarından biri de "atama operatör" fonksiyonudur. Bir atama işleminde sol taraftaki nesne bir sınıf türündense bu duurmda atama 
	işlemi sınıfın "atama operatör fonksiyonu" denilen bir fonksiyon çağrılarak yapılır. Yani a bir sınıf nesnesi olmak üzere:

	a = b;

	işleminin derleyici için eşdeğeri şöyledir:

	a.operator=(b);

	Atama operatör fonksiyonları "overload" edilebilir. Ancak bir sınıfın kendi sınıfı türünden bir nesneyi atamakta kullanılan operatör fonksiyonuna "kopya atama
	operatör fonksiyonu" denilmektedir. Kopya atama operatör fonksiyonu sınıfın ismi T olmak üzere aşağıdkai parametrelere sahip atama operatör fonksiyonlarıdır:

	T &operator =(const T&r);
	T &operator =(T &r);
	T &operator =(volatile T &r);
	T &operator =(const volatile T &r);
	T &operator =(T r);

	Eğer programcı sınıf için kopya atama operatör fonksiyonu yazmamışsa bu fonksiyon derleyici tarafından public inline biçiminde aşağıdaki parametrik 
	yapıyla yazılmaktadır:

	T &operator =(const T&r);

	Bu konuda bazı ayrıntılar da vardır. Derleyicinin yazdığı kopya atama operatör fonksiyonu sınıfın karşılıklı veri elemanlarını biribrine atar (memberwise copy).
	Tabii bir sınıfın gösterici veri elemanı gibi veri elemanları varsa programcı yine kopya atama operatör fonksiyonunu içerik kopyalaması yapacak biçimde kendisi 
	yazmalıdır. 

	Bie sınıf için ne zaman kopya yapıcı fonksiyonu gerekiyorsa o sınıf için aynı zamanda kopya atama operatör fonksiyonu da gerekmektedir. 

	C++11 ile birlikte kopya atama operatör fonksiyonu için bazı ayrıntılar da dile eklenmiştir. Örneğin bir sınıf taşıma yapıcı fonksiyonuna sahipse artık derleyici 
	o sınıf için kopya atama operatör fonksiyonunu "deleted" kabul etmektedir. Yazi yazmamaktadır. Ancak kopya atama operatör fonksiyonu "defaulted" yapılarak 
	derleyici tarafoan yazılması zorlanabilir. Örneğin:

	class T {
	public:
		//...
		T & operator =(const T&) = default;
	};

	Sınıfın kopya atama operatör fonksiyonu tıpkı kopya yapıcı fonksiyonunda olduğu gibi içerik kopyalaması yapmalıdır. 

	C++'ta atama operatöründen elde edilen değer bir nesne belirtmektedir. Ancak C'de nesne belirtmemektedir. Örneğin aşağıdaki ifade C'de geçersiz olduğu halde 
	C++'ta geçerlidir:

	(a = b) = c;		// C'de geçersiz! C++'ta geçerli

	İşte atama operatöründen elde edilen ürünün nesnebelirtmesi için atama operatör fonksiyonunun kendi sınıfı türünden bir referansa geri dönmesi ve return ifadesinde
	de *this bulunması gerekmektedir. 

	Ayrıca a = a gibi bir işlem anlamsız olsa da buna önlem almak gerekebilir. 


	Aşağıdaki örnekte kendi yazdığımız String sınıfına atama operatör fonksiyonlarını ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	String &operator =(const String &r);
	String &operator =(const char *str);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s("ankara");
	String k;

	k = s;		// k.operator =(s);

	s.disp();
	k.disp();

	k = "istanbul";		// s.operator =("istanbul");
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Geçici bir sınıf nesnesinin sağ taraf değeri belirttiğini anımsayınız. Bu durumda biz bir sınıf nesnesine bir geçici nesne atarsak o geçici nesnedeki kaynakları
	etkin biçimde taşıyabiliriz. İşte bu işlem "taşıma atama operatör fonksiyonu (move assignment operator)" ile yapılmaktadır. Örneğin:

	String s;

	s = String("Ankara");

	Burada eğer taşıma atama peratör olmasaydı (C++11 öncesinde durum böyleydi) önce String nesnesi yaratılıp sonra o nesne kopya atama operatör fonksiyonu yoluyla
	s'ye atanacaktı. Halbuki C++'ta bu atama sırasında yine içerik kopyalaması yapılacaktı. Bu atamada aşağıdaki parametrik yapıya sahip taşıma atama operatör fonksiyonu çalıştırılabilmektedir:

	String &operator =(String &&s);

	Genel olarak bir sınıf taşıma yapıcı fonksiyonuna sahipse taşıma atama operatör fonksiyonuna da sahip olmalıdır. Tabii taşıma atama operatör fonksiyonu bir nesnesine aynı sınıf 
	türünden sağ taraf değeri ile atama yapıldığı diğer durumlarda da çağrılmaktadır. Örneğin:

	String foo()
	{
		//...
	}
	//...
	String s;

	s = foo();		// taşıma atama operatör fonksiyonu çağrılır

	Burada yine taşıma atama operatör fonksiyonu çağrılacaktır.

	Aşağıdaki örnekte daha önce yazdığımız String sınıfınına taşıma operatör atama fonksiyonunu ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s;

	s = String("istanbul");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda vector sınıfına benzeyen ama şablon olmayıp yalnızca int türden değerleri tutan örnek bir sınıf oluşturulmuştur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// intvector.hpp

#ifndef INTVECTOR_HPP_
#define INTVECTOR_HPP_

#include <cstddef>

const int DEF_CAPACITY = 4;

class IntVector {
public:
	IntVector();
	IntVector(std::size_t size);
	IntVector(const IntVector &r);
	IntVector(IntVector &&r);
	~IntVector();

	std::size_t size() const { return m_size; }
	std::size_t capacity() const { return m_capacity; }

	void push_back(int val);
	inline int &operator[](std::size_t index);
	inline const int &operator[](std::size_t index) const;

	IntVector &operator =(const IntVector &r);
	IntVector &operator =(IntVector &&r);

	void disp() const;
private:
	int *m_pv;
	std::size_t m_size;
	std::size_t m_capacity;
};

int &IntVector::operator[](std::size_t index)
{
	return m_pv[index];
}

const int &IntVector::operator[](std::size_t index) const
{
	return m_pv[index];
}

#endif

// intvector.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector::IntVector()
{
	m_capacity = DEF_CAPACITY;
	m_size = 0;
	m_pv = new int[DEF_CAPACITY];
}

IntVector::IntVector(std::size_t size)
{
	m_capacity = size;
	m_size = size;
	m_pv = new int[size];
}

IntVector::IntVector(const IntVector &r)
{
	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_capacity = m_size = r.m_size;
}


IntVector::IntVector(IntVector &&r)
{
	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;
}

IntVector::~IntVector()
{
	delete[] m_pv;
}

void IntVector::push_back(int val)
{
	int *pv_new;

	if (m_size == m_capacity) {
		pv_new = new int[m_capacity * 2];
		for (size_t i = 0; i < m_size; ++i)
			pv_new[i] = m_pv[i];
		m_capacity *= 2;
		delete[] m_pv;
		m_pv = pv_new;
	}
	m_pv[m_size++] = val;
}

IntVector &IntVector::operator =(const IntVector &r)
{
	if (this == &r)
		return *this;

	delete[] m_pv;

	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_size = r.m_size;
	m_capacity = r.m_capacity;

	return *this;
}

IntVector &IntVector::operator =(IntVector &&r)
{
	delete[] m_pv;

	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;

	return *this;
}

void IntVector::disp() const
{
	for (size_t i = 0; i < m_size; ++i)
		cout << m_pv[i] << " ";

	cout << endl;
}

// app.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector foo()
{
	IntVector v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	return v;
}

int main()
{	
	IntVector k;

	k = foo();

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Operatör fonksiyonları üye operatör fonksiyonları ya da global operatör fonksiyonları biçiminde yazılabilmektedir. Ancak =, (), ->, [] operatör fonksiyonlarının
	üye operatör fonksiyonu olarak yazılması zorunlu tutulmuştur. Global operatör fonksiyonları özellikle sol tarafı temel türlere ilişkin sağ tarafı bir sınıf türünden 
	olan operatör fonksiyonlarının yazılması için gerekmektedir. Örneğin Number sınıfında bir number nesnesi ile bir int nesneyi toplayan operatör fonksiyonu olsun:

	Number x(10), result;

	result = x + 20;

	Eğer x + 20 gibi bir işlem geçerliyse 20 + x gibi bir işlemin de geçerli olması beklenir. Ancak bu işlemi yapabilecek bir üye operatör fonksiyonu yazılamamaktadır. 
	O halde bu operatör fonksiyonu ancak global operatör fonksiyonu olarak yazılabilir. Genel eğilim operatör fonksiyonlarının mümkün olduğunca üye operatör fonksiyonu 
	olarak yazılmasıdır. Ancak global operatör fonksiyonu gerektiğinde buna benzer olanların da global operatör fonksiyonu olarak yazılması daha güzel bi görüntü 
	vermektedir. Global operatör fonksiyonları sınıfın dışındaki fonksiyonlar olduğu için bunların sınıfın private bölümüne erişebilmesi friend yapılması yaygın 
	bir tekniktir. Hatta bir operatör fonksiyonunun diğer bir operatör fonksiyonu çağırarak yazılması da sık uygulanan bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP_
#define COMPLEX_HPP_

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0);
	Complex operator +(const Complex &r) const;
	Complex operator -(const Complex &r) const;
	Complex operator *(const Complex &r) const;

	Complex &operator ++();			// prefix
	const Complex operator ++(int);	// postfix

	Complex &operator --();			// prefix
	const Complex operator --(int);	// postfix

	void disp() const;


	friend Complex operator +(const Complex &r, double real);

private:
	double m_real;
	double m_imag;
};

Complex operator +(double real, const Complex &r);


#endif

// complex.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

Complex::Complex(double real, double imag)
{
	m_real = real;
	m_imag = imag;
}

void Complex::disp() const
{
	cout << m_real << '+' << m_imag << 'i' << endl;
}

Complex Complex::operator +(const Complex &r) const
{
	Complex result;

	result.m_real = m_real + r.m_real;
	result.m_imag = m_imag + r.m_imag;

	return result;
}

Complex operator +(const Complex &r, double real)
{
	Complex result;

	result.m_real = r.m_real + real;
	result.m_imag = r.m_imag;

	return result;
}

Complex operator +(double real, const Complex &r)
{
	return r + real;
}

Complex Complex::operator -(const Complex &r) const
{
	Complex result;

	result.m_real = m_real - r.m_real;
	result.m_imag = m_imag - r.m_imag;

	return result;
}

Complex Complex::operator *(const Complex &r) const
{
	Complex result;

	result.m_real = m_real * r.m_real - m_imag * r.m_imag;
	result.m_imag = m_real * r.m_imag + m_imag * r.m_real;

	return result;
}

Complex &Complex::operator ++()
{
	++m_real;

	return *this;
}

const Complex Complex::operator ++(int)	
{
	Complex z = *this;

	++m_real;

	return z;
}

Complex &Complex::operator --()
{
	--m_real;

	return *this;
}

const Complex Complex::operator --(int)
{
	Complex z = *this;

	--m_real;

	return z;
}

// app.cpp


#include <iostream>
#include "complex.hpp"

int main()
{
	Complex x(3, 2), result;

	result = x + 3;

	result.disp();

	result = 3 + x;

	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz başından beri ekrana (yani stdout dosyasına) birşeyler yazmak için cout değişkenini, klavyeden (yani stdin dosyasından) bir şeyler okuyabilmek için
	cin nesnesin kullandık. Pekiyi bu bu değişkenler nedir? İşte aslında cout ostream denilen bir sınıf türünden, cin ise istream denilen bir sınıf türündne global 
	nesnelerdir. ostream sınıfı basic_ostream şablon sınıfının char açılımıdır. Benzer biçimde istream sınıfı da aslında basic_istream şablon sınıfının char için 
	açılımıdır. Yani ostream ve istream aslında typedef isimleridir. Biz şablon sınıfları izleyen konularda göreceğiz. Bu nedenle bu sınıfların şablonluk özelliği 
	üzerinde durmayacağız. 

	C++'ın iostream sınıfları şablonluk özelliğini söz konusu etmezsek aşağıdaki biçimde bir türetme şemasına sahiptir. 

              ios_base 
			     |
				 |
                ios
			   /    \
              /      \       
          istream  ostream
	        \        /
	         \      /  
		      \    /
               \  /
			 iostream

	Buradan da görüldüğü gibi iostream sınıfı istream ve ostream sınıfından çoklu türetilmiştir. istream ve ostream sınıflarının ortak elemanları basic_ios 
	sınıfından türetilmiş durumdadır. basic_ios sınıfı da ios_base sınıfındn türetilmiştir. ostream sınıfının bir grup overload edilmiş << operatör fonksiyonu, 
	istream sınıfının da overload edilmiş bir grup >> operatör fonksiyonu bulunmaktadır. cout nesnesi ostream sınıfı türünden olduğna göre viz bu nesneyle 
	yalnızca << operatör fonksiyonlarını, cin nesnesi de istream sınıfı türünden olduğuna göre biz bu nesneyle yalnızca >> ıperatör fonksiyonlarını kullanabiliriz. 
	Şablonluk özelliği bir yana bırakılırsa bu sınıfların aşağıdaki gibi bir yapıya sahip olduğu söylenebilir:

	class ostream : public basic_ios {
	public:
		ostream &operator <<(int a);
		ostream &operator <<(long a);
		ostream &operator <<(double a);
		ostream &operator <<(char a);
		//...
	};

	class istream : public basic_ios {
	public:
		istream &operator >>(int &a);
		istream &operator >>(long &a);
		istream &operator >>(double &a);
		istream &operator >>(char &a);
		//...
	};

	Şimdi cout nesnesinin aşağıdaki gibi kullanıldığını düşünelim:

	cout << a << ", " << b << "\n";

	Bunun eşdeğeri şöyledir:

	cout.operator <<(a).operator <<(", ").operator <<(b).operator <<("\n");

	Bu operatör fonksiyonlarının nesnenin kendisine geri döndüğüne dikkat ediniz. Böylece örneğin cout.operator <<(a) gibi bir çağrıdan cout nesnesinin yine 
	kendisi elde edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda ostream ve istream sınıflarınımn nasıl yazılmış olacbileceğine ilişkin bir örnek verilmiştir. Bu örneğin amacı ostream ve istream sınıflarının
	orijinalini yazmak değildir. Yalnızca ostream ve istream sınıfının nasıl yazılmış olabileceğine ilişkin bir ipucu vermektisr. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>
#include <string>

class ostream {
public:
	ostream &operator <<(int a);
	ostream &operator <<(long a);
	ostream &operator <<(double a);
	ostream &operator <<(char a);
	ostream &operator <<(const char *str);
	ostream &operator <<(std::string &s);
	ostream &operator <<(ostream &(&f)(ostream &));
};

ostream &ostream::operator <<(int a)
{
	std::printf("%d", a);

	return *this;
}

ostream &ostream::operator <<(long a)
{
	std::printf("%ld", a);

	return *this;
}

ostream &ostream::operator <<(double a)
{
	std::printf("%f", a);

	return *this;
}

ostream &ostream::operator <<(char a)
{
	std::printf("%c", a);

	return *this;
}

ostream &ostream::operator <<(const char *str)
{
	std::printf("%s", str);

	return *this;
}

ostream &ostream::operator <<(std::string &s)
{
	std::printf("%s", s.c_str());

	return *this;
}

ostream &ostream::operator <<(ostream &(&f)(ostream &))
{
	return f(*this);
}

ostream &endl(ostream &os)
{
	os << '\n';

	return os;
}

class istream {
public:
	istream &operator >>(int &a);
	istream &operator >>(long &a);
	istream &operator >>(double &a);
	//...
};

istream &istream::operator >>(int &a)
{
	scanf("%d", &a);

	return *this;
}

istream &istream::operator >>(long &a)
{
	scanf("%ld", &a);

	return *this;
}

istream &istream::operator >>(double &a)
{
	scanf("%lf", &a);

	return *this;
}

ostream cout;
istream cin;

int main()
{	
	int a;
	double b;

	cin >> a >> b;

	cout << "a = " << a << ", b = " << b << endl;
	cout << "this is a test" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar bir sınıf yazdığımızda o sınıfın içerisindeki bilgileri ekrana (stdout dosyasına) yazdırmak için sınıfta disp isimli fonksiyonlar 
	bulundurduk. Aslında C++'ta sınıf nesnesinin içerisindeki bilgilerin ekrana yazdırılması cout yoluyla yapılmalıdır. Yani cout nesnesi ile biz nasıl 
	int, long gibi temel türlere ilişkin bilgileri yazdırabiliyorsak kendi sınıfımıza ilişkin bilgileri yazdırabilmeliyiz. 

	Kendi sınıflarımıza ilişkin nesneleri ekrana (stdout dosyasına) yazdırabilmemiz mecburen global bir operatör fonksiyonu yazmamız gerekir. Örneğin:

	Sample s;

	cout << s;		// cout.operator(s)

	Burada biz ostream sınıfının içerisine fonksiyonumuzu yerleştiremeyeceğimize göre mesburen bu işlemi yapan bir global operatör fonksiyonu yazmalıyız. 
	Yazacağımız global operatör fonksiyonunun birinci parametresi ostream & türünden olmalıdır. İkinci parametresi ise kendi sınıfımız türünden const bir referans
	olabilir. Kombine edilebilirliği sağlamak için bu operatör fonksiyonun çağırısından bizim yine ostream nesnesinin kendisini elde etmemiz gerekir. Bu durumda 
	fonksiyonun geri dönüş değeri ostream & olmalıdır. Tabii bu global operatör fonksiyonun friend yapılması uygun olur. Özetle Smaple sınıfı için yazılacak 
	<< operatör fonksiyonu aşağıdaki gibi olmalıdır:

	class Sample {
		friend ostream &operator <<(ostream &os, const Sample &s);
		//...
	};

	ostream &operator <<(ostream &os, const Sample &s)
	{
		//...

		return os;
	}

	Aşağıda Complex sınıfı için bu operatör fonksiyonun yazımını görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z(3, 2);

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de String sınıfımız için bu operatör fonksiyonunu yazalım.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>
#include <ostream>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor
	~String();

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	friend std::ostream &operator <<(std::ostream &os, const String &r);
	
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

String::~String()
{
	delete[] m_str;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

ostream &operator <<(ostream &os, const String &r)
{
	os << r.m_str;

	return os;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s{"ankara"};

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Kendi sınıflarımızı cin ile okumasını yapmak çoğu kez mümkün olmaz. Çünkü sınıf nesneleri bileşik türlerdir. Bunların basit bir biçimde klavyeden (stdin dosyasından)
	mümkün olmayabilir. Ancak biz yine de burada Sample sınıfı için bunun nasıl yapılacağının ipucunu vermek istiyoruz.

	class Sample {
		friend istream &operator >>(istream &is, Sample &r);
		//...
	};

	istream &operator >>(istream &is, Sample &r)
	{
		//...

		return is;
	}

	Aşağıda Complex sınıfı için bir örnek verilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>
#include <istream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
	friend std::istream &operator >>(std::istream &is, Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

istream &operator >>(istream &is, Complex &r)
{
	is >> r.m_real >> r.m_imag;

	return is;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z;

	cout << "Bir karmaşık sayıyı gercek ve sanal kisimlarini belirterek giriniz:";
	cin >> z;

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bir sınıf nesnesi sanki bir fonksiyonmuş gibi fonksiyon çağırma operatörüyle kullanılabilir. Bunun için sınıfın fonksiyon çağırma operatör fonksiyonun
	yazılmış olması gerekir. a bir sınıf türünden nesne olmak üzere:

	a(...)

	ifadesinin eşdeğeri:

	a.operator()(...)

	biçimindedir. Bir sınıf nesnesinin bir fonksiyon gibi kullanılmasına İngilizce "function object" ya da kısaca "functor" denilmektedir. C++'ın standart kütüphanesinde
	bir fonksiyon isteyen şablon sınıflar bu biçimde functor nesnelerini de kabul ederler. Sınıflar durumsal bilgileri tutabildikleri için yetenekli fonksiyonların yazılmasına
	izin vermektedir. Fonksiyon çağırma operatör fonksiyonu üye operatör fonksiyonu olarak yazılmak zorundadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// app.cpp

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(const char *str) : m_str(str)
	{}
	void operator()(int a, int b) const;
private:
	string m_str;
};

void Sample::operator()(int a, int b) const
{
	cout << m_str << ": " << a << ", " << b << endl;
}

int main()
{
	Sample s("test");

	s(10, 20);		// s.operator()(10, 20)

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bir gösterici gibi davranan sınıflara "akıllı gösterici (smart pointer)" sınıfları denilmektedir. C++11 ile birlikte C++'a unique_ptr gibi, shared_ptr 
	gibi smart pointer sınıfları eklenmiştir. Bir sınıfın bir gösterici gibi davranmasının bazı faydaları söz konusu olabilir. Ancak en önemli fayda otomatik boşaltımın
	sağlanmasıdır. Programcı smart pointer sınıfı için bir nesneyi dinamik olarak tahsis eder. Ancak bunun delete edilmesi sınıfın yıkıcı fonksiyonu yoluyla otomatik 
	yapılır. Tabii standart kütüphanedeki unique_ptr gibi shared_ptr gibi sınıflar şablon olarak yazılmıştır. 

	* operatörü bir sol taraf değeri ürettiğine göre bu operatöre ilişkin operatör fonksiyonunun bir referansa geri dönmesi uygun olur.

	Aşağıda int türünden bir göstericiyi taklit eden bir smart pointer sınıfı örneği verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class IntPtr {
public:
	IntPtr(int *pi) : m_pi(pi)
	{}
	~IntPtr()
	{
		delete m_pi;
	}
	int &operator *()
	{
		return *m_pi;
	}
	const int &operator *() const
	{
		return *m_pi;
	}
	int *release()
	{
		auto temp = m_pi;
		m_pi = nullptr;

		return  temp;
	}
	void reset(int *pi)
	{
		delete m_pi;

		m_pi = pi;
	}
private:
	int *m_pi;
};


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    -> operatör fonksiyonu bir sınıf türünden gçstriciyi taklit eden sınıflar için kullanılmaktadır. -> operatör fonksiyonu üye fonksiyon biçiminde yazılmak zorundadır. 
	-> operatör fonksiyonu bir sol taraf değeri ile değil bizzat sınıf türünden bir adresle geri dönmelidir. Çünkü s bir smart pointer nesnesi olmak üzere:

	s->a

	gibi bir işlemin C++ operatör fonksiyonu eşdeğeri aslında şöyledir:

	s.operator->()->a 

	Aşağıda string sınıfı türünden göstericiyi temsil eden örnek bir smart pointer sınıfı verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class StringPtr {
public:
	StringPtr (string *ps) : m_ps(ps)
	{}
	~StringPtr()
	{
		delete m_ps;
	}
	string &operator *() const
	{
		return *m_ps;
	}
	string *operator ->() const
	{
		return m_ps;
	}
private:
	string *m_ps;
};

int main()
{
	StringPtr ss(new string("ankara"));
	string s;

	cout << *ss << endl;

	s = (*ss).substr(0, 3);
	cout << s << endl;

	s = ss->substr(0, 3);		// s = ss.operator->()->substr(0, 3)
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte şablon tabanlı unique_ptr ismiyle genel bir smart pointer sınıfı standart kütüphaneye eklenmiştir. unique_ptr sınıfı (ismi üzerinde) 
	bir nesneyi gösteren tek bir smart pointer nesnesinin olmasını hedefleyen bir sınıftır. uniqe_ptr bir göstericiyi taklit eder. Ancak o göstericinin gösterdiği 
	yeri gösteren başka bir	uniqe_ptr nesnesinin bulunamayacağını da garanti etmektedir. Başka bir deyişle hiçbir zaman iki unique_ptr nesnesi aslında aynı dinamik alanı gösteremez. 

	uniqe_ptr nesnesi dinamik tahsis edilmiş bir nesnenin adresiyle yaratılmalıdır. Örneğin:

	unique_ptr<int> pi(new int);
	unique_ptr<string> ps(new string("ankara"));

	unique_ptr sınıfının yapıcı fonksiyonu "explicit" olduğu için (explicit yapıcı fonksiyonlar ileride ele elınacaktır) biz nesneyi '=' ile llkdeğer vererek yaratamayız. 
	Örneğin:

	unique_ptr<int> pi = new int;		// error!
	unique_ptr<int> pi(new int);		// geçerli
	unique_ptr<int> pi{new int};		// geçerli

	unique_ptr sınıfının * ve -> operatörleri overload edilmiştir. Örneğin:

	unique_ptr<string> ps(new string("ankara"));
	string result;

	cout << *ps << endl;

	result = ps->substr(0, 3);
	cout << result;

	Sınıfın yıkıcı fonksiyonu tabii dinamik alanı delete etmektedir. Sınıfın kopya yapıcı fonksiyonu ve kopya operatör fonksiyonu "deleted" biçimdedir. Yani aşağıdaki 
	gibi biz unique_ptr nesnesinin kopyasını çıkartamayız:

	unique_ptr<int> p1(new int);		// geçerli
	unique_ptr<int> p2(p1);				// error!

	p2 = p1;							// error!

	Sınıfın release isimli üye fonksiyonu sınıfın tuttuğu adresini geri dönüş değeri olarak verir. Ancak sınıfın içerisindeki göstericiye null adres atar. Yani release
	işleminden sonra artık sınıf o dinamik nesneyi göstermez hale gelr. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.release();				// us artık dinamik nesneyi göstermiyor, s artık dinamik nesneyi gösteriyor

		cout << *s << endl;	

		delete s;						// delete etmek bizim sorumluluğumuzda

		return 0;
	}

	sınıfın reset üye fonksiyonu bizden yeni bir nesneyi parametre olarak alır. Eskisini delete eder. Artık nesne yeni dinamik nesneyi gösterir duruma gelir. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
	
		us.reset(new string("izmir"));

		cout << *us << endl;

		return 0;
	}

	reset fonksiyonuu default argümanla çağırırsak nesnin içerisindeki göstericiye null adres atanır. Tabii yine nesne daha önce gösterdiği dinamik nesneyi delete 
	edecektir. Örneğin:

	unique_ptr<string> us(new string("ankara"));

	us.reset();		// artık us bir nesneyi göstermiyor, eski alan delete edildi

	Nesneyi transfer etmek için release ile reset beraber kullanılmalıdır. Örneğin:

		#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us1(new string("ankara"));
		unique_ptr<string> us2;

		us2.reset(us1.release());		// transfer etmenin normal yöntemi

		cout << *us2 << endl;

		return 0;
	}

	Sınıfın get üye fonksiyonu sınıfın tuttuğu nesne adresini bize verir. get fonksiyonu sahipliği release gibi bırakmamaktadır. Dolayısıyla get kullanırken dikkat ediniz. 
	Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.get();		// us nesnenin adresini tutmaya devam ediyor 

		cout << *us << endl;

		return 0;
	}

	unique_ptr sınıfının kopya yapıcı fonksiyonu yoktur ancak taşıma yapıcı fonksiyonu vardır. Benzer biçimde sınıfın kopya atamam operatör fonksiyonu yoktur, 
	ancak taşıma atama operatör fonksiyonu vardır. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	unique_ptr<string> foo()
	{
		unique_ptr<string> us(new string("ankara"));

		return us;			// geçerli, çünkü sınıfın taşıma yapıcı fonksiyonu vardır
	}

	int main()
	{	
		unique_ptr<string> us(foo());

		cout << *us << endl;		// ankara
	
		us = unique_ptr<string>(new string("izmir"));		// geçerli, sınıfın taşıma atama operatör fonksiyonu var

		cout << *us << endl;		// izmir

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	uniqe_ptr sınıfının "deleter" denilen ikinci bir şablon parametresi daha vardır. Deleter nesneyi yok ederken çağrılacak fonksiyonu belirtir. Bu şablon parametresi
	default durumda delete operatörü ile silme yapan bir sınıfı argüman olarak almıştır. Programcı isterse silme işlemini kendi belirlediği bir fonksiyonla ya
	da bir sınıfla yapabilir. Tabii böyle bir sınıf yazılırken sınıfın fonksiyon çağırma operatör fonksiyonunun yazılmış olması gerekir. Bu konu izleyen bölümde 
	ele alınacaktır. Aşağıda deleter kullanımına ilişkin bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <memory>

using namespace std;

void foo(int *pi)
{
	cout << "foo called" << endl;

	delete pi;
}

int main()
{
	unique_ptr<int, void (*)(int *)> a(new int, foo);

	*a = 10;

	cout << *a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne sanki bir fonksiyonmuş gibi fonksiyon çağırma operatörleriyle çağrılma işlemine sokulabilir. Örneğin:

	Sample s;

	s(...);

	Bu durumda sınıfın "fonksiyon çağırma operatör fonksiyonu" denilen operatör fonksiyonu çalıştırılır. Fonksiyon çağırma operatör fonksiyonun geri dönüş değeri 
	ve parametreleri herhangi türden olabilir. Bu durumda örneğin:

	s(....)

	işleminin eşdeğeri:

	s.operator()(....)

	biçimindedir. 

	Bu biçimdeki bir sınıf nesnesinin sanki bir fonksiyon gibi kullanılmasına "fonksiyon nesneleri (function object)" ya da kısaca "functor" denilmektedir. 
	Fonksiyon nesneleri gerçekte bir fonksiyon değil sınıf olduğu için çağrılar arasında durumsal bilgileri tutabilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(const char *msg) : m_msg(msg)
	{}

	int operator()(int a, int b);
private:
	string m_msg;
};

int Sample::operator()(int a, int b)
{
	cout << m_msg << endl;

	return a + b;
}

int main()
{
	Sample s("this is a test");
	int result;

	result = s(10, 20);		// result s.opereator()(10, 20);
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon nesneleri C++ standart kütüphanesinde algoritmalar tarafından kullanılabilmektedir. Böylece bu algoritmalar durumsal bilgiyi tutabilir duruma 
	gelirler. Örneğin for_each fonksiyonu bir dizilimin her elemanı için bir fonksiyonun çağrılmasını sağlar. Dolayısıyla bir for_each fonksiyonuna çağrılam 
	özelliği olan bir fonksiyon nesnesini verebiliriz. Fonksiyon nesnesi de bu çağrılar arasında durumsal bir bilgi oluşturabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void foo(int a)
{
	cout << a * a << endl;
}

class Sample {
public:
	Sample()
	{
		m_total = 0;
	}

	void operator()(int a)
	{
		m_total += a;
	}
	int total() const { return m_total; }
private:
	int m_total;
};

int main()
{
	vector<int> v{1, 2, 3, 4, 5};
	Sample s;

	for_each(v.begin(), v.end(), foo);
	for_each(v.begin(), v.end(), s);

	cout << s.total() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ve delete operatörlerinde de bizim istediğimiz bir fonksiyonun çağrılmasını sağlayabiliriz. Böylece programcı tahsisat işlemlerinde araya girebilir. Ya da 
	tahsisat işlemlerinin kendi istediği gibi yapılmasını sağlayabilir.

	new operatör fonksiyonun paramtreik yapısı aşağıdaki gibi olmalıdır:

	void *operator new(size_t size);
	void *operator new[](size_t size);

	Fonksiyonun normal ve köşeli parantezli biçimleri olduğunda dikkat ednizi. delete işleminde çağrılacak operator delete fonksiyonun da parametrik 
	yapısı şöyle olmalıdır:

	void operator delete(void *ptr);
	void operator delete[](void *ptr);

	Aslında standart kütüphanede new ve delete işlemleri sırasında çağırlan operator new ve operator delete fonksiyonları bulunmaktadır. Eğer programcı kendisi 
	bu fonksiyonları yazarsa kütüphanedekiler değil de programcının yazdığı fonksiyonlar devreye girer. Eğer programcı bunları yazmasa kütüphanedekiler devreye girer.

	new ve delete operatörlerinin "placement" denilen verisyonları da vardır. placement versiyonlarda new operatörü bir tahsisat yapmaz. Yalnızca programcının verdiği bir adresi
	sınıfın yapıcı fonksiyonunu çağırmak için kullanmaktadır. placement new operatörlerinin ayrı bir gösteri gösterici parametresi daha vardır. Parametrik yapıları şöyledir:

	void *operator new(size_t size, void *ptr);
	void *operator new[](size_t size, void *ptr);

	Placement new operatörü tipik olarak zaten tahsis edilmiş bir alan için sınıfın yapıcı fonksiyonun çağrılması amacıyla kullanılır. Placement new operatörü 
	ile tahsis edilmiş olan alan için delete operatörü çağrılmamlıdır. Çünkü delete operatörü operator delete fonksiyonun çalıştırılmasına yol açar. 
	placement biçime aktarılan adresinin boşaltılması programcının sorumluluğunda olmalıdır Tabii programcı bir sınıf nesnesi söz konusu olduğunda bu nesne için
	yıkıcı fonksiyonun çağrılmasını isteyebilir. Bu durumda yıkıcı fonksiyon açıkça çağrılabilir. Örneğin:

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;s
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *s;
	char buf[sizeof(Sample)];

	s = new (buf)Sample(10, 20);
	cout << s->m_a << ", " << s->m_b << endl;

	s->~Sample();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Mademki aslında new işlemi ile tahsisatlar operator new fonksiyonlarıyla yapılmaktadır. O halde programcı operator new fonksiyonlrını tahsisat fonksiyonları olarak da
	doğrudan çağırabilir. Aynı durum operator delete için de geçerlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = static_cast<int *>(operator new[](sizeof(int) * 10));

	for (int i = 0; i < 10; ++i)
		pi[i] = i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << endl;

	operator delete[](pi);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir sınıf nesnesi için operator new fonksiyonuyla tahsisat yapılmış sonra bu tahsis edilen alan için placement new yoluyla yapıcı 
	fonksiyon çağrılmıştır. Burada yine yıkıcı fonksiyon programcının kendisi tarafından çağrılmaktadır. Tahsisat operator delete fonksiyonuyla free hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl; 
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *ps;

	ps = static_cast<Sample *>(operator new(sizeof Sample));

	ps = new (ps)Sample(10, 20);

	cout << ps->m_a << ", " << ps->m_b << endl;

	ps->~Sample();

	operator delete(ps);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizması (exception handling) özellikle nesne yönelimli programlama dillerinde karşılaşılan bir hata kontrol mekanizmasıdır. C gibi klasik prosedürel 
	dillerde hata kontrolleri programcı açısından yorucu olabilmektedir. Programcı başarısız olabilecek her fonksiyonun başarısını kontrol etmek durumunda kalır.
	İç içe fonksiyonlarda iç bir fonksiyonda hata olşuştuğunda programcının içerden dışa doğru başsrıszlıkla geri dönmesi gerekmeketdir. Bu da programın çok kontrollü bir 
	biçimde oluşturulmasına yol açmaktadır. Bu bakımdan da okunabilirliği azaltmaktadır. İşte exception mekanizması bu srunları çözmek amacıyla bulundurulmaktadır. 
	Exception mekanizmasının sağladığı avantajlar şunlardır:

	- Programın daha az kontrollü bir biçimde oluşturulması sağlamak ve okunabilirliği artırmak.
	- Kod ile hata ele alımını biribirinden ayırmak
	- Tam bir hata kontrolü sağlama
	- İç içe çağırmalarda kolay bir hata kontrolü sağlamak"
	- Bir hata oluştuğunda hatanın nedenini de iletmek.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türü başka bir türe (örneğin temel türlere) dönüştürülmek istenebilir. Bunun için "tür dönüştürme operatör fonksiyonları" kullanılmaktadır. Tür 
	dönüştürme operatör fonksiyonlarının genek biçimi şöyledir:

	[explicit] operator <tür>()

	Tür dönüştürme operatör fonksiyonlarında geri dönüş değerinin türü yazılmaz. Zaten operatör anahtar sözcüğünün yanındaki tür fonksiyonun geri dönüş 
	değerinin türü anlamına gelmektedir. C++11 ile birlikte explicit tür dönüştürme operatörü de dile eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta exception mekanizması için try, throw ve catch anahtar sözcükleri kullanılmaktadır. try anahtar sözcüğünü bir blok izelemek zorundadır. Buna "try bloğu"
	denir. try bloğu tek başına bulunmaz. try bloğunu bir ya da birden fazla catch bloğu izlemek zorundadır. Örneğin:

	try {
		// try bloğu
	}
	catch ([parametre bildirimi]) {
		//...
	}
	catch ([parametre bildiriiş]) {
		//...
	}
	catch ([parametre bildirimi]) {
		//...
	}

	catch parantezlerinin içerisinde "catch parametresi" denilen bir bildirim bulunur. catch parametresi bir tane olmak zorundadır. catch bölümü tek parametreye sahip 
	bir fonksiyon gibi de düşünülebilir. Bir try bloğunun aynı parametrik yapıya sahip olan birden fazla catch bölümü olamaz. Yani catch parametrelerinin 
	türlerinin farklı olması gerekir. catch parametrelerinde yalnıca tür de belirtilebilir. Örneğin:

	int main()
	{
		try {
			//...
		}
		catch (int) {
			//...

		}
		catch (long) {
			//...
		}

		return 0;
	}

	Program akış bakımından try bloğunun içerisindeyken bir exception oluşursa akış bir goto işlemi gibi tek hamlede try bloğunun uygun catch bloğuna 
	aktarılır. O catch bloğu çalıştırılır ve akış catch bloklarının sonundan devam eder. Yani catch blokları exception oluştuğunda hatanın ele alınacağı yerlerdir. 

	Exception'ı asıl oluşturan deyim throw deyimidir. throw deyiminin genel biçimi şöyledir:
	
	throw [ifade];

	Programın akışı throw deyimini gördüğünde akış en son girilen try bloğunun ifadesinin türü ile aynı türden olan catch bloğuna aktarılır. Bu işlem bir goto 
	gibi yapılmaktadır. Artık akış catch bloğundadır. Yalnızca o catch bloğu çalıştırılır. Diğer catch blokları atlanır ve akış catch bloklarının sonundan devam eder.
	throw ifadesinin değeri catch parametresine atanmaktadır. catch parametreleri herhangi bir türden olabilirse de genellikle uygun olan onların bir sınıf türünden 
	olmasıdır. Programın akışı catch bloğuna girdikten sonra hiç exception oluşmayabilir. Bu durumda akış try bloğundan çıkar, catch blokları atlanır ve akış 
	catch bloklarının sonundan devam eder. Yani catch blokları "exception oluşursa" devreye girmek üzere bulundurulur.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void tar(int a)
{
	cout << "tar begins..." << endl;

	if (a < 0)
		throw 10;

	cout << "tar ends..." << endl;
}

void bar(int a)
{
	cout << "bar begins..." << endl;

	tar(a);

	cout << "bar ends..." << endl;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	bar(a);

	cout << "foo ends..." << endl;

}

int main()
{
	cout << "main begins..." << endl;

	try {
		foo(-10);
	}
	catch (int a) {
		cout << "exception caught: int a = " << a << endl;

	}
	catch (long a) {
		cout << "exception caught: long a = " << a << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir exception fırlatıldığında bu exception'ı yakalayacak uygun türde bir catch bloğunun olması gerekir. Eğer böyle bir catch bloğu yoksa ya da programcı 
	bir try bloğu içerisinde bile değilse derleyici tarafından std::terminate isimli fonksiyon çağrılır. Bu terminate fonksiyonu da kendi içerisinde std::abort 
	isimli fonksiyonu çağırmaktadır. İşte abort fonksiyonu da programı sonlandırır. Programcı set_terminate fonksiyonu ile bu tür durumlarda kendi 
	fonksiyonunun çağrılmasını sağlayabilmektedir. 

	std::terminate --> std::abort

	Yani biz oluşan bir exception'ı yakalamazsak programmız sonlandırılmaktadır. 

	throw ifadesiyle catch poarametresinin türünün tam olarak uyuşması gerekir. Overload resolution kuralları burada işletilmemektedir. (Örneğin throw ifadesi 
	char türdense bu int parametreli bir catch bloğu tarafından yakalanamaz.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında throw işlemi temel türlerle değil sınıf türleriyle yapılır. Çünkü sınıflar bilgi tutabilirler. Üstelik de her sınıf farklı tür belirttiğine göre farklı
	sınıf türlerine ilişkin catch blokları bulundurulabilmektedir. Tipik olarak programcı throw işlemini yapmadan önce bir sınıf türünden nesne yaratır. Bu nesnenin
	içini oluşan problemlemli durumları betimleyen bilgilerle doldurur. Sonra bu sınıf ile throw eder. Bunu yakalayn kişi de oluşan exception hakkında bilgileri 
	bu nesneden elde eder. 

	Aşağıdaki örnekte InvalidArgument isimli bir exception sınıfı yazılmıştır. throw işlemş sırasında bu sınıf türünden bir nesne yaratıldığına ve throw işleminin 
	bu nesne yapıldığına dikkat ediniz. Exception yine InvalidArgument parametreli bir catchbloğu tarafından yakalanmıştırç Bu catch bloğu exception nesnesinin içerisindeki 
	bilgileri ekrana (stdout dosyasına) yazdırmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf ile throw işlemi yapılırken önemli bazı noktalar vardır. Bunlar üzerinde duralım:

	1) throw ifadesinin catch parametresine aktarılması doğrudan değil geçici bir nesne yoluyla yapılmaktadır. Örneğin:

	throw ifade;

	Burada önce ifadenin türünden geçici bir nesne yaratılır. Böylece ifade önce geçici bir nesneye atanır. Bu geçici nesnenin yaratılması ve atama işlemi 
	ilkdeğer verme işlemi gibi yapılmaktadır. Derleyicinin yarattığı bu geçici nesneye "exception nesnesi" de denilmektedir. Eğer ifade bir sınıf türündense 
	bu geçici nesne de aynı sınıf türünden olacaktır. Bu durumda geçici nesne için kopya yapıcı fonksiyonu ya da taşıma yapıcı fonksiyonu çağrılacaktır. 
	Tabii daha önce görmüş olduğumuz"copy elision" kuralları burada da geçerli olacaktır. Örneğin:

	ExceptionTest et;
	...

	throw et;

	Buradaki işlem aslında şununla eşdeğerdir:

	ExceptionTest temp = et;		// kopya yapıcı fonksiyon devreye girer.

	Tabii burada NRVO biçiminde zorunlu olmayan bir "copy elision" devreye girebilecektir. Yani aslında derleyici isterse buradaki et nesnesini zaten geçiçi nesne 
	gibi yaratıp hiç kopya yapıcı fonksiyonu çağırmayabilir. Ancak buradaki "copy elision" zorunlu değil isteğe bağlıdır. 

	Eğer throw ifadesi geçici bir sınıf nesnesi ise C++17 ile birlikte "copy elision" işleminin zorunlu olarak yapıldığını anımsayınız. Örneğin:

	throw ExceptionTest();		// C++17 ile birlikte geçici nesne için "copy elision" zorunlu

	Burada artık C++17 ile birliklte derleyici zorunlu bir biçimde ExceptionTest() işlemi ile geçici sınıf nesnesini zaten kendi alanında yaratıp 
	kopya yapıcı fonksiyonu hiç çağırmaz. 

	2) Derleyicinin oluşturduğu geçici nesne catch parametresine atanmaktadır. Bu atama işlemi de fonksiyon çağırma gibi yani ilkdeğer verme biçiminde yapılmaktadır. 
	Örneğin:

	ExceptionTest et;
	...

	throw et;
	//...
	catch (ExceptionTest e) {
		//...
	}

	Burada aslında şu biçimde işlemler yapılmaktadır:

	ExceptionTest temp = et;
	ExceptionTest e = et;

	Burada hiç "copy elision" yapaılmazsa catch parametresi için de kopya yapıcı fonksiyonu çalıştırılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	InvalidArgument ia("Value must not be negative", 1234);

	cout << "foo begins..." << endl;

	if (a < 0)
		throw ia;

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıf nesneleriyle throw işlemi sırasında kopya yapıcı fonksiyonun çalıştırılmasını elimine etmek için throw edilecek nesnenin geçici nesne biçiminde yaratlması 
	yoluna gidilebilir. Bu durumda C++17 ve sonrasında "copy elision" zorunlu olduğu için derleyicinin yaratacağı geçici nesne için kopya yapıcı fonksiyonu çağrılmayacaktır. 
	(Aslında programcının yarattığı geçici nesne doğrudan derleyicinin yaratacağı geçici exception nesnesi gibi olacaktır.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;

}

int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++ programcıları genellikle catch parametresini bir sınıf türünden referans biçiminde alırlar. Bu durumda hiç olmazsa catch parametresi için kopya 
	yapıcı fonksiyonu çalıştırılmaz. C++ standartlarında istisna olarak her ne kadar derleyicinin yarattığı exception nesnesi bir geçici nesne olsa da bunun 
	"sol taraf değeri (lvalue)" belirttiği söylenmiştir. Yani bu durumda catch parametresinin const bir sol taraf değeri referansı olması gerekmez. Ancak tabii
	genel olarak programcılar bu referansı const yaparlar. Burada derleyicinin yaratacağı geçici nesne catch parametresindeki referansın ömrü kadar olacaktır. Yani
	catch bloğu bittiğinde bu geçici nesne yok edilecektir. 

	Genellikle exeption'alrın ele alınması eğer throw ifadesi bir sınıf türndense bu biçimde yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument &ia) {			// bu referans istenirse const olmayabilir
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen programcılar fırlatacakları sınıf nesnesini heap'te new operatörü ile tahsis edip onunla throw işlemi yaparlar. Bu durumda tabii derleyicinin yaratacağı geçici
	exception nesnesi bir gösterici olur ve kopya yapıcı fonksiyonunun çağrılması söz konusu olmaz. Bu durumda catch parametrerisi de aynı sınıf türünden bir gösterici olmalıdır. 
	Ancak bu yakalama biçiminde nesnenin heap'ten delete edilemsi exception'ı yakalayan tarafından yapılmalıdır. Bu biçimde her ne kadar kopya yapıcı fonksiyonları 
	çağrılmıyorsa da new ve delete işlemi de göreli bir zaman kaybına yol açmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw new InvalidArgument("Value must not be negative", 1234);		

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument *pia) {			
		cout << *pia << endl;

		delete pia;				// delete etme sorumluluğu exception'ı yakalayan koda ait
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında programcının throw etmek için kendi exception sınıflarını yazmasına gerek kalmayabilmektedir. Çünkü C++'ın standart kütüphanesinde zaten çeşitli sorunlu durumlar
	için oluşturulmuş olan hazır exception sınıfları bulunmaktadır. Standart kütüphanedeki bu exception sınıflarının hepsi en tepedeki "exception" isimli bir sınıftan 
	türetilmiştir. Bu exception sınıfından temelde iki önemli türemiş kol ayrılmaktadır: logic_error ve runtime_error. logic_error sınıfı programdaki birtakım ön koşulların
	ihlal edilmesi durumu için düşünülmüştür. runtime_error ise programın çalışması sırasında karşılaşılan sorunlar için oluşturulmuştur. Bu logic_error ve runtime_error
	sınıflarından da sınıflar türetilmiştir. Örneğin invalid_argument isimli sınıf tipik olarak programcılar tarafından bir fonksiyonun argümanının yanlış bir biçimde 
	geçilmesi durumu için kullanılmaktadır. out_of_range ise belli bir aralıkta olması gereken değerin o aralıkta olmaması durumlarında kullanılmaktadır. 

	En tepedeki exception sınıfının what isimli sanal const char * türüyle geri dönen (yani bir yazının adresiyle geri dönen) bir üye fonksiyonu vardır. Bu sanal 
	fonksiyon türemiş sınıflarda override edilmiştir. exception sınıfından türetilmiş olan sınıfların hepsinin bir error yazısını parametre olarak alan bir yapıcı 
	fonksiyonu bulunmaktadır. Zaten bu what fonksiyonları da bu yapıcı fonksiyon ile verilen yazıyı bize geri vermektdir. 


	Aşağıdaki örnekte foo fonksiyonunun parametresi negatif olmamalıdır. foo fonksiyonunu yazan kişi işin başında bu parametreyi kontorl etmiş, eğer parametre negatif ise
	invalid_argument nesnesi ile hata mesajını da belirterek thwor işlemi yapmıştır. Fonksiyon çağrısında da exception ele alınmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must not be negative!");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart exception sınıfları aslında C++'ın kendi standart kütüphanesi tarafından da kullanılmaktadır. Örneğin new operatör tahsisatı yapamazsa bad_alloc isimli
	exception sınıfından türetilmiş olan bir sınıf nesnesi ile throw eder. Ya da örneğin string sınıfında string içeriisndeki belli indekste bulunan karaktere erişme 
	işlemi at fonksiyonuyla yapılıyorsa bu at fonksiyonu erişlen indeks geçersizse out_of_range türüyle throw etmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	char ch;

	try {
		ch = s.at(10);			// sınır kontrolü yapılıyor, sınır ihlalinde std::out_of_range ile throw edilmektedir. 
	}
	catch (const out_of_range &oor) {
		cout << oor.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Programcı C++'ın standart excepion sınıflarını hiç kullanmayıp kendi exception sınıflarını da yazabilir. Aslında Qt gibi, MFC gibi pek çok yaygın 
	sınıf kütüphanesi hiç C++'ın standart exception sınıflarını kullanmadan kendi exception sınıflarını tanımlayarak throw işlemini bunlarla yapmaktadır. 

	Tabii programcı C++'ın standart exception sınıflarını kullanırken o sınıflardan türetme yaparak da kendi exception sınıflarını oluşturabilir. Aşağıda örnekte
	logic_error sınıfınından NegativeERror isimli bir exception sınıfı türetilmiş ve kodda bu sınıf kullanılmıştır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

class NegativeError : logic_error {
public:
	NegativeError(const char *msg, int errcode) : logic_error(nullptr), m_msg(msg), m_errcode(errcode)
	{}

	const char *what() const noexcept override
	{
		string err("Error: " + m_msg + ", Error Code: " + to_string(m_errcode));

		return err.c_str();
	}
private:
	string m_msg;
	int m_errcode;

};

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw NegativeError("value must not be negative!", 123);

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const NegativeError &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıfa ve türemiş sınıfa ilişkin catch blokları birlikte bulundurulabilir. Bu durumda türemiş sınıfa ilişkin catch bloğunun taban sınıfa ilişkin catch 
	bloğunun yukarısında konumlandırılması zorunludur. Böylece türemiş sınıf türünden bir nesne ile throw işlemi yapıldığında bu türemiş sınıf parametreli catch bloğu 
	tarafından taban sınıf türünden bir nesne ile throw yapıldığında bu da taban sınıf türünden catch bloğu tarafından yakalanır. Örneğin B sınıfı A sınıfından türetilmiş olsum:

	try {
		//...
	}
	catch (B &r) {
		//...
	}
	catch (A &r) {
		//...
	}

	Burada catch bloklarının sırası böyle olmak zorundadır.Çünkü catch blokları yukarıdan aşağıya sırasıyla taranmaktadır. Eğer taban ısının catch bloğu yukarıya 
	yazılabilseydi tüm exception'ları bu catch bloğu yakalardı.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir kod parçasında çok değişik türlerle throw işlemi yapılabilmektedir. Bu durumda bu türlerin hepsi için catch bloklarının bulundurulması yorucu bir işlemdir. 
	İşte programcılar bu nedenle exception sınıflarını bir taban sınıftan türetilmiş sınıflar biçiminde oluşturlar ve yalnızca taban sınıfa ilişkin catch bloğu ile exception'ı yakalayabilirler. 

	Aşağıda bu duruma bir örnek verilmiştir. Standart exception sınıflarındaki what fonksiyonunun sanal bir fonksiyon olduğunu ve türemiş sınıflarda override 
	edildiğini anımsayınız. Dolayısıyla aslında çağrılan what fonksiyonları çokbiçimli mekanizmadan dolayı exception nesnesine ilişkin sınıfın fonksiyonu olacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int size)
{
	if (size < 0)
		throw invalid_argument("size must not be negative!");
	if (size > 100)
		throw range_error("parameter is too big");
	if (size == 0) 
		throw length_error("size must not be zero");

	cout << "success" << endl;
}

int main()
{
	int size;

	cout << "Bir değer giriniz:";
	cin >> size;

	try {
		foo(size);
	}
	catch (const exception &r) {
		cout << r.what() << endl;		// what sanal bir fonksiyon
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizmasında diğer bir catch bloğu da "ellipsis (...)" parametreli catch bloğudur. Bu catch bloğu tüm exception'ları yakalar (yani "catch all" 
	gibi bir anlamı vardır). Ancak eğer ellipsis parametreli catch bloğu yerleştirileckse catch bloklarının sonuna yerleştirilmelidir. Böylece eğer exception
	daha yukarıdaki catch blokları tarafından yakalanmamışsa kesinlikle ellipsis parametreli catch bloğu tarafından yakalanacaktır. Tabii exception ellipsis 
	parametreli catch bloğu tarafından yakalandığında biz artık excepion nesnesini elde edemeyiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a) 
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must be positive or zero");

	if (a > 100)
		throw range_error("parameter is too big");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(110);
	}
	
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}
	catch (...) {			// catch all
		cout << "another error occurred!" << endl;
	}
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta özel bir throw deyimi de yanında ifade olmadan throw; biçiminde kullanılan throw deyimidir. Buna "rethow" denilmektedir. Bu biçimdeki throw deyimleri ancak
	catch bloğu içerisinde kullanılabilir. Bu biçimdeki throw deyimleri "exception'ın orijinali hangi nesne ile fırlatılmışsa aynı nesne ile onu yeniden fırlatma" anlamına gelmektedir. Örneğin:

	try {
		foo(-10);
	}
	catch (exception &r) {
		//...
		throw;
	}

	Burada exception yakalandığında birtakım işlemler yapılıp rethow uygulanmıştır. Bu rethow işlemi orijinal exception nesnesi ne ise onunla yeniden throw etmek anlamına 
	gelir. Böylece exception bu try bloğunu akş bakımından içeren başka bir catch bloğu tarafındna yakalanabilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Akış bir fonksiyonda ilerlerken bir throw işlemi oluşursa akış tamamen başka bir yere aktarılabilmektedir. Bu durum o fonksiyon içeisinde yapılan tahsisatlar ve
	yaratılan sınıf nesneleri için önemlidir. Çünkü throw işlemi yapılmadan önce çeşitli sınıf nesneleri yaratılmış olabilir. Bu sınıf nesnelerinin yıkıcı fonksiyonlarında 
	çeşitli boşaltım işlemleri yapılmış olabilir. İşte bu olumsuzlukları ortadan kaldırmak için "stack unwinding" denilen bir mekanizma bulunmaktadır. Bir throw işlemi
	gerçekleştiğinde o zaman kadar yaratılmış olan yerel sınıf nesneleri için yıkıcı fonksiyonlar ters sırada çağrılmaktadır. Böylece kaynaklar throw işlemi sırasında 
	başarılı bir biçimde boşaltılmış olur. Tabii bu mekanizmasının derleyici tarafından sağlanmasının birtakım zamansal maaliyetleri vardır. Bu nedenle bazı kritik uygulamalarda 
	programcılar exception mekanizmasını hiç kullanmak istemeyebilirler. 

	throw işlemi oluştuğunda yalnızca try bloğuna girildikten sonra yaratılmı ve yapıcı fonksiyonu tam olarak çalıştırılmış nesneler için yıkıcı fonksiyonlar ters sırada 
	çalıştırılmaktadır. new ile dinamik bir biçimde yaratılmış nesneler yıkıcı fonksiyonlar çalıştırılmaz ve bu nesneler için delete işlemi otomatik olarak uygulanmaz. 
	Bu nesnelerin boşaltımından programcı sorumludur. Bir yapıcı fonksiyonun içerisinde throw işlemi uygulanırsa o zamana kadar yapıcı fonksiyonu tam olarak çalıştırılmış
	nesneler ve alt nesneler için yıkıcı fonksiyon çalıştırılmaktadır.

	Aşağıdaki örnek "stack unwinding" mekanizmasını açıklamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);
	Sample *ps;

	ps = new Sample(60);		// dikkat bellek sızıntısı oluşacak!

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    throw işlemi yapıldığında new ile dinamik biçimde yaratılmış sınıf nesneleri için yıkıcı fonksiyonların çağrılmadığına dikkat ediniz. O halde programcının throw öncesinde
	bu dinamik nesneleri delete etmesi gerekir. Ancak bunun takip edilmesi kolay değildir. İşte bu nedenden dolayı "smart pointer" sınıfları bellek sızıntısını engellemek
	amacıyla kullanılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <memory>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);

	unique_ptr<Sample> ps(new Sample(60));		

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta "exception specification" denilen özellik bir fonksiyonun hangi exception'larla dışarıya throw yapabileceğini belirtmek kullanılıyordu. Örneğin:
	
	void foo(int a) throw(std::invalid_argument)
	{
		//...
	}

	Buarada foo fonksiyonu yalnızca dışarıya invalid_argument sınıfı ile throw yapabilmektedir. Exception specification ilk standartlardan beri bulunan bir özellikse de 
	zamanla "faydasının zararından az olduğu" fikri belirginleşmiştir. Bu nedenle C++11'de "deprecated" yapılmış ve C++17'de de kaldırılmıştır. Exception specification
	Java'da yoğun biçimde kullanılmaktadır. C++11 ile birlikte exception specification özelliğinin çok kısıtlı bir biçimi olan noexcept belirleyicisi dile eklenmiştir. 
	noexcept belirleyicisi "fonksiyonun bir tür ile throw etmeyeceğini" anlatmaktadır. Tabii eğer fonksiyonda bu belirleyici yoksa bu durum "fonksiyonun herhangi bir türle
	throw edebileceği" anlamına gelir. noexcept belirleyicisi fonksiyonun parametre parantezinden sonraya yerleştirilir. Örneğin:

	void foo(int a) noexcept
	{
		//...
	}

	Eğer noexcept belirleyicisi kullanıldığı halde fonksiyonun dışına throw işlemi yapılırsa bu durumda derleyici tarafından std::unexpected isimli fonksiyon çağrılır. 
	Bı fonksiyon kendi içerisinde std::terminate fonksiyonunu bu da std::abort fonksiyonu çağıracaktır:

	unexpected --> terminate --> abort

	Yani kısaca biz noexcept ile verdiğimiz sözü tutmazsak programımız abort ile sonlandırılır. noexcept anahtar sözcüğü hem prototipte hem de
	tanımlama sırasında bulundurulmak zorundadır. Ancak overload bakımından fonksiyonun imzasını değiştirmez.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void bar(int a)
{
	if (a < 0)
		throw invalid_argument("parameter is invalid");
}

void foo(int a) noexcept
{
	bar(a);		// std::unexpected --> std::terminate --> std::abort
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	noexcept belirleyicisinde parantezler içerisinde true ve false sabitleri kullanılabilmektedir. Örneğin:

	void foo() noexcept(true);

	Buradaki true fonksiyonun hiçbir biçimde dışarıya exception fırlatmayacağı anlamına gelir. Zaten default durum da böyledir. Dolayısıyla aşağıdaki iki bildirim 
	eşdeğerdir:

	void foo() noexcept;
	void foo() noexcept(true);

	false ise fonksiyonun dışarıya exception throw edebileceğini belirtir. Dolayısıyla aşağıdaki iki bildirim de eşdeğerdir:

	void foo() noexcept(false);
	void foo();

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında fonksiyon içerisinde bir exception oluşursa akış throw işlemi ile birlikte fonksiyondan aniden çıkacaktır. Bu durumda fonksiyon içerisinde
	o ona kadar yapılmış olan tahsisatlar boşaltılamayabilir. Bu duruma fonksiyonun "exception güvenliliği (exception safety)" denilmektedir. Örneğin:

	try {
		foo();		// foo'da exception oluşursa sızıntı oluşur mu?
	}
	catch (exception &e) {
		//...
	}

	Bir fonksiyon için dört tür exception güvenliği söz konusu olabilir. Bunlar kötüden iyiye doğru aşağıdaki gibi sıralanabilirler:

	1) No Guarantee: Böyle fonksiyonlarda exception oluşursa bellek sızıntısı (memory leak) ya da kaynak sızıntısı (resource leak) oluşabilir. Şüphesiz böyle 
	fonksiyonların yazılmaması gerekir. Tabii bazen böyle fonksiyonların bir biçimde yazılması söz konusu olabilmektedir. Örneğin:

	void foo(int a)
	{
		int *pi, *pc;

		pi = new int[10];
		pc = new char[100];		// Tahsisat yapılamazsa std::bad_alloc excepton'ı oluşabilir

		// ...

		delete[] pi;
	}

	2) Basic Guarantee: Burada ilgili fonksiyon içerisinde bir exception oluştuğunda "bellek sızıntısı" ya da "kaynak sızıntısı" olmayacağı garanti edilir. Ancak
	bu bir üye fonksiyon ise ilgili sınıf nesnesinin durumu programcının fonksiyonu çağırmadan önceki durumuyla aynı olmayabilir. Fakat nesne "geçerli" ve "destruct"
	edilebilir bir biçimde bırakılmıştır. Örneğin:

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		//...
	}

	Burada eğer "basic guarantee" söz konusu ise foo fonksiyonunun içersinde exception oluşursa herhangi bir sızıntı olmamalıdır. Ayrıca buradaki s nesnesi 
	foo fonksiyonu çağrılmadan önceki durumunda olmayabilir ancak "destruct" edilebilir bir durumda olmalıdır. Yani "destructor" çağrıldığında nesne geri bırakım
	işlemlerini yapabilmelidir. Basic guarantee sağlayabilmek için programcı koduna dikkat etmelidir. Bir problem karşısında geri bırakımı yapıp rethow işlemi uygulayabilir. 
	Örneğin:

	void foo()
	{
		// kaynak tahsisatı yapılıyor olsun

		try {
			// exception'a yol açabilecek başka işlemler
		}
		catch (...) {
			// kaynaklar boşaltılıyor
			throw;
		}
		//...
	}

	Basic guarantee oluşturmak için dinamik bellek tahsisatlarında bellek sızıntısına karşı "smart pointer" sınıfları da kullanılabilir. Örneğin:

	void foo(int a)
	{
		//...

		unique_ptr<int> pi(new int[10]);
		unique_ptr<char> pi(new char[100]);		// artık burada exception oluşursa stack unwinding sırasında pi tahsisatı boşaltılacak
				
		// ...
	}

	3) Strong Guarantee: Burada bir üye fonksiyon çağrıldığında eğer üye fonksiyonun içerisinde exception oluşmuşsa akış fonksyondan çıktığında nesnenin durumu 
	(yani onun içerisindeki veri elemanlarının değerleri) bu üye fonksiyon çağrılmadan önceki değerlerdedir. Başka bir deyişle üye fonksiyonda exception oluşması
	nesne üzerinde hiçbir etki yaratmaz. Tabii sınızntı vs. gibi durumlar da oluşmaz. Örneğin.

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		s'in durumu foo'nun çağrılmadan önceki durumu ile tamamen aynıdır. 
		//...
	}

	Tabii "strong guarantee" oluşturmak hem zahmetli hem de zordur. C++'ın standart kütüphanesindeki pek çok sınıfın üye fonksiyonu "strong guarantee" oluşturmaktadır. Örneğin
	vektörde biz push_back yaptıpımızda bir exception oluşursa vector nesnemiz push_back yapmadan önceki durumla aynı durumda olur. Yani psuh_back fonksiyonu bize "strong guarantee"
	vermektedir. 

	4) No Throw Guarantee: Burada fonksiyon zaten dışarıya throw işlemi yapmayacağına ilişkin söz vermiştir. Dolayısıyla bir exception fırlatmayacaktır. O zaman 
	olabilecek en iyi durum budur. Böyle fonksiyonların programcılar tarafından noexcept belirleyicisi ile belirtilmesi iyi bir tekniktir. Örneğin:

	void foo() noexcept;

	Burada artık biz bu fonksiyonu zaten try-cath içerisinde çağırmak zorunda da değiliz. Çünkü fonksiyon zaten dışarıya throw işlemi yapmayacaktır. Dolaısıyla da bir 
	sızıntı söz konusu olmaz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önce yazmış olduğumuz String sınıfı aslında exception güvenliliği bakımından sorunluydu. O sınıfın atama operatör fonksiyonları herhangi bir exception
	garantisi vermiyordu. Ancak diğer fonksiyonlarda bir problem yoktu. Eski atama operatör fonksiyonları şöyle yazIlmıştı:

	String &String::operator =(const String &r)
	{
		if (this == &r)		/* nesne kendisine atanmış mı? */
			return *this;

		delete[] m_str;

		m_len = r.m_len;
		m_str = new char[m_len + 1];
		strcpy(m_str, r.m_str);

		return *this;
	}

	String &String::operator =(const char *str)
	{
		delete[] m_str;

		m_len = strlen(str);
		m_str = new char[m_len + 1];
		strcpy(m_str, str);

		return *this;
	}

	String &String::operator =(String &&r)
	{
		delete m_str;

		m_len = r.m_len;
		m_str = r.m_str;

		r.m_str = nullptr;

		return *this;
	}

	Bu fonksiyonlar yukarıdaki haliyle exception güveli değildir. Yani "basic guarantee" bile vermemektedir. Burada new işlemi başarısız olursa sızıntı oluşmaz ancak
	nesne kararlı bir durumda kalmamaktadır. "strong guarantee" nesnenin işlem öncesindeki durum ile aynı durumda olması anlamına gelmekteydi. Yukarıdaki atama operatör fonksiyonlarını
	"strong guarantee" verecek biçimde düzenlemenin en kolay yolu "copy and swap idiom" denilen kalıbın uygulanmasıdır. Bu kalıpta önce yerel bir nesne kopya yapıcı fonksiyonu ile
	yaratılır, sonra yerel nesne ile asıl nesnenin veri elemanları yer değiştirilir. Bunun için genellikle sınıfta swap isimli bir üye fonksiyon bulundurulur. Örneğin String 
	sınıfı için bu swap fonksiyonu şöyle olabilir:

	void String::swap(String &r) noexcept
	{
		std::swap(m_str, r.m_str);
		std::swap(m_len, r.m_len);
	}

	fonksiyonundaki içerisinde swap fonksiyonları standart kütüphenedeki template tabanlı swap fonksiyonlarıdır. ""copy  and swap idiom" aşağıdaki gibi uygulanabilir:

	String &String::operator =(const String &r)
	{
		String temp(r);		// exception safe

		swap(temp);
	
		return *this;
	}

	String &String::operator =(const char *str)
	{
		String temp(str);		// exception safe

		swap(temp);

		return *this;
	}

	String &String::operator =(String &&r) noexcept
	{
		swap(r);

		return *this;
	}

	Pekiyi bu fonksiyonlar neden "strong guarantee" vermektedir. Adım adım inceleyeim:

	1) Eğer yerel nesne üzerindeki kopya yapıcı fonksiyonunda exception oluşursa henüz asıl nesnede bir değişiklik yapılmadığı için "strong guarantee" bozulmaz.
	2) swap işlemi asıl nesneyle yerel nesnenin elemanlarını yer değiştirmektedir. Dolayısıyla swap zaten noexcept bir fonksiyondur. Yani "no throw guarantee" vermektedir. 
	3) return *this işleminde de artık exception oluşturacak bir durum yoktur. 

	Aşağıdaki kullanıma dikkat ediniz. 

	int main()
	{
		String s{"ankara"};
		String k;

		cout << s << endl;

		try {
			k = s;
		}
		catch (...) {
			//...
		}
		cout << k << endl;

		return 0;
	}

	Burada k = s işleminde bir exception oluşsa bile arık k'da hiçbir değişiklik olmayacaktır. Yani biz k'nın önceki hali ne ise onu öyle kullanmaya devam edebiliriz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Özetle programcı bir global fonksiyon ya da üye fonksiyon yazarken satır satır hangi noktalarda exception oluşabileceğini dikkate almalıdır. Mümkünse 
	fonksiyonlarınıza "strong guarantee" vermeye çalışın. Mümkün değilse ya da efektif değilse o zaman "basic guarantee" vermeye çalışın. Zaten throw etmeyecek 
	fonksiyonlarda mutlaka noexcept belirleyicisini kullanın.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı fonksiyonlar değişik türler için içi aynı olacak biçimde yeniden yazılmak zorundadır. Örneğin int bir dizinin en büyük elemanına geri dönen bir fonksiyon 
	yazmak isteyelim:

	int getmax(const int *pi, size_t size)
	{
		int max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Şimdi biz double bir diziin en büyük elemanını elde etmek istesek aynı fonksiyondan double için bir tane daha yazmak zorundayız:

	double getmax(const double *pi, size_t size)
	{
		double max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Görüldüğü gibi burada iki fonksiyonun içi tamamen ayndır. Yalnızca tür farklılığı yüzünden programcı yeniden aynı fonksiyondan yazmak zorunda kalmıştır. 
	Tabii aslında bazen tek bir fonksiyn farklı türlerele çalışabilir hale de getirilebilir. Ancak bu tür fonksiyonlar "kullanımı zor" ve "yavaş" olma eğilimindedir. Örneğin:

	void *getmax(const void *pi, size_t size, size_t width, int (*cmp)(const void *, const void *))
	{
		const void *max = pi;
		const const char *pc = reinterpret_cast<const char *>(pi);

		for (size_t i = 1; i < size; ++i)
			if (cmp(pc + (i * width), max) > 0)
				max = pc + (i * width);

		return const_cast<void *>(max);
	}

	İşte şablon (template) "içi aynı olan fakat parametrik türleri" farklı olan fonksiyonların ve sınıfların kullanılan her tür için yazılmasını 
	kolaylaştırmak amacıyla oluşturulmuş bir mekanizmadır. 

	Şablon mekanizmasının Java ve C# gibi dillerdeki mantıksal benzerine "generic" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şablon mekanizması ikiye ayrılmaktadır:

	1) Fonksiyon şablonları (function templates)
	2) Sınıf şablonları (class templates)

	Fonksiyon şablonları tek bir fonksiyonun şablon olarak yazılması anlamına gelir. Sınıf şablonları ise bir sınıfın hepsinin şablon olarak yazılması anlamına gelir. 
	Biz önce fonksiyon şablonları üzerinde sonra sınıf şablonları üzerinde duracağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyon şablonlarnda fonksiyon bildiriminde önce "şablon bildirim" yapılmak zorundadır. Şablon bildirimi template anahtar sözcüğünden sonr açısal parantezler 
	içerisinde şablon parametreleri belirtilerek yapılır. Şablon parametreleri aslında tür belirten parametrelerdir (tür belirtmeyen şablon parametreleri de olabilir). 
	Tür belirten şablon parametrelerinden önce "class" ya da "typename" anahtar sözcükleri getirilir. Bu iki anahtar sözcük arasında hiçbir farklılık ypktur. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Burada template parametresinin ismi T'dir. template parametreleri herhangi bir biçimde isimlendirilebilir. Ancak genellikle programcılar tek karakterli T, K
	gibi harfleri tercih etmektedir. Templatae parametrelerinden önce class anahtar sözcüğü yerine typename anahtar sözcüğü de kullanılabilirdi. Örneğin:

	template <typename T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Buradaki T template parametresi bir tür belirtmektedir. Yani programcı fonksiyonunu sanki T diye semblik bir türe dayalı olarak yazmaktadır. Bu T ismi tür belirten
	bir sözcük olarak fonksiyonun şablonunun her yerinde ekullanılabilir. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		T max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Artık bir fonksiyon şablonu yazıldığında bu fonksiyon şablonu çağrılınca derleyici çağrılma ifadeisndeki argümanların türlerine bakarak template parametresinin (örneğimizde T)
	hangi tür olması gerektiğini anlamaya çalışır. Template parametresinin türünü çağrılma ifadesine göre tespit edilmesi sürecine "template argument deduction" denilmektedir. 
	Derleyici bu tespiti yaptıktan sonra gerçekten bu şablona bakarak ilgili tür için fonksiyonu yazar. Derleyicinin şablona bakarak ilgili fonksiyonu türe dayalı oalrak yazmasına ise
	"template instantiation" denilmektedir. Biz "instantiation" sözcüğü yerine "template fonksiyonun açılması" deyieceğiz. Örneğin:

	int a[5] = {34, 23, 12, 67, 43};
	
	int result;
	
	result2 = getmax(a, 5);

	Burada derleyici getmax fonksiyonun birinci argümanınınint * türündeb olduğunu görür. Bu durumda T türünün int olması gerektiğini anlar ve template fonksiyonu bizim 
	için aşağıdaki gibi açar (instantiate eder):

	int getmax(const int *p, size_t size)
	{
		int max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Derleyici her farklı tür için bu açımı kendisi yapmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <class T>
T getmax(const T *p, size_t size)
{
	T max = p[0];

	for (size_t i = 1; i < size; ++i)
		if (max < p[i])
			max = p[i];

	return max;
}

int main()
{
	int a[5] = {34, 23, 12, 67, 43};
	double b[5] = {34.2, 45.4, 65.6, 21.3, 12.5};
	
	int result1;
	double result2;

	result1 = getmax(a, 5);
	cout << result1 << endl;

	result2 = getmax(b, 5);
	cout << result2 << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin iki nesnenin içerisindeki değeir yer değiştiren swap isimli bir fonksiyon yazılabilir. Zaten standart kütüphanede böyle bir fonksiyon vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

template <typename T>
void swap(T &a, T &b)
{
	T temp(a);

	a = b;
	b = temp;
}

int main()
{
	int a = 10, b = 20;
	double x = 12.3, y = 2.4;

	swap(a, b);
	std::cout << "a = " << a << ", b = " << b << std::endl;

	swap(x, y);
	std::cout << "x = " << x << ", y = " << y << std::endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir değerin mutlak değerine geri dönen bir fonksiyon template olarak yazılabilir 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon şablonları derleyici tarafından her derleme işleminde görülmelidir. Bu nedenle fonksiyon şablonları kütüphaneler içerisine yerleştirilemez. Onların 
	tipik olarak başlıkd osyalarına yerleştirilmesi uygun olur. Böylece derleyici derleme işlemi sırasında onların kodunu görecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi tamamen şablon esasına dayandırılmıştır. Orada pek çok hazır fonksiyon ve sınıf bulunmaktadır. Bu hazır fonksiyonlar ve sınıflar 
	"iteratör (iterator)" denilen bir kavram kullanılarak gerçekleştirilmiştir. İteratör "bir gösterici gibi davranan gerçek bir gösterici ya da sınıftır". 
	Standart kütüphanedeki fonksiyon şablonları bir dizi alacakları zaman onun başlangıç ve bitiş bitiş iteratörlerini bizden isterler. Başlangıç iteratörü dizinin ilk 
	elemanın adresidir. Ancak eğer bir sınıf söz konusuysa bu iteratör bir nesne durumunda olabilir. Bitiş iteratörü dizinin son elemanından sonraki elemanın adresidir. 
	Eğer biz C++'ın standart kütüphanesindeki fonksiyon şablonlarını dizi için kullanacaksak başlangıç iteratörünü dizinin başlangıç adresi olarak bitiş iteratörünü dizinin 
	son elemanından sonraki adres olarak vermeliyiz. Bu fonksiyonlar itertaörleri ilerleterek veri yapısının tüm elemanlarına erişirler. Örneğin <algorithm> başlık dosyasındaki
	copy isimli fonksiyon şablonu bizden bir dizinin ilk elemanın ve sondan bir sonraki elemanının adresini alarak oradaki tüm elemanları başka bir adresten itibaren kopyalar. 
	Bu fonksiyon aşağıdaki gibi yazılmıştır:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD 
{
	template<class InputIt, class OutputIt>
	OutputIt copy(InputIt first, InputIt last, OutputIt dest)
	{
		while (first != last) {
			*dest = *first;
			++first;
			++dest;
		}

		return dest;
	}
}

int main()
{
	int a[5] = {1, 2, 3, 4, 5};
	int b[5];

	CSD::copy(a, a + 5, b);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin standart kütüphanedeki find fonksiyonu türden bağımsız arama yapan genel bir fonksiyondur. Bizden dizinin ilk elemanının ve son elemanından sonraki elemanın adresini 
	ve aranacak değeri parametre olarak alır. Eğer değeri dizide bulursa bulduğu yerin adresiyle (iteratörüyle) geri döner. Bulamazsa son elemandan sonraki elemanın adresiyle 
	(yani end iteratörüyle) geri dönmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	double *result;

	result = find(a, a + 5, 9);

	if (result == a + 5)
		cout << "cannot find item" << endl;
	else
		cout << "found: " << *result << endl;


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin sort isimli fonksiyon şablonu yine bizden bir dizinin ilk elemanın ve son elemanından sonraki elemanın adresini alarak o diziyi sıraya dizmektedir. 
	Biz bu fonksion şablonu yoluyla aslında her türden diziyi sıraya dizebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	
	sort(a, a + 5);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon şablonu çağrılırken şablon türleri açısal parantezler içerisinde açıkça (explicit) da belirtilebilmektedir. Bu durumda şablon parametreleri 
	argümanlardan hareketle belirlenmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << a << endl;
}

int main()
{
	foo(10);			// T = int
	foo(1.2);			// T = double
	foo<double>(100);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Açısal parantezler içerisinde şablon parametrelerinin açıkça belirtilmesi bazen gerekebilmektedir. Örneğin fonksiyonun şablonunun şablon parametresine 
	ilişkin bir parametre değişknei olmayabilir. Bu durumda derleyici şablonm parametresini otomatik belirleyemez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo()
{
	T a();

	cout << a << endl;
}

int main()
{
	foo();			// error!
	foo<int>()

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bazen şablon parametresi fonksiyonun geri dönüş değerinde olabilir. Bu durumda da otomatik türs belirlemesi yapılamaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T foo()
{
	cout << "foo" << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>();
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı ilk n tane şablon parametresini açıkça belirtip geri kalanlarını derleyicinin tespit etmesini isteyebilir. 
	Aşağıdaki örnekte T şablon parametresi açıkça belirtilmiş ancak K şablon şablon parametresi derleyici tarafından belirlenmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K>
T foo(K a)
{
	cout << a << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>(12.3);		// T = int, K = double
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında şablon parametreleri default değerler de alabilmektedir. Eğer bir şablon parametresi otomatik belirlenemiyorsa verilen default değerler 
	kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K = int>
K foo(T a)
{
	cout << a << endl;

	return K();
}

int main()
{
	int result;

	result = foo(10.2);		// T = double, K = int
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir şablon fonksiyon ile aynı isimli normal fonksiyon bir arada bulunabilir. Bu durumda overload resolution işleminde normal fonksiyon eğer argüman türleri
	tam olarak uyum sağlıyorsa tercih edilmektedir. Ancak argüman türleri tam olarak uyum sağlamıyorsa fonksiyon şablonu tercih edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << "template function: " << a << endl;
}

void foo(int a)
{
	cout << "non-template function: " << a << endl;
}

int main()
{
	foo(12.3);			// şablon olan 
	foo(100);			// normal fonksiyon

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın tamamı da şablon olarak yazılabilir. Böyle sınıflara "sınıf şablonları (class templates)" denilmektedir. Sınıf şablonları yazılırken 
	yine bir şablon bildirimi ile başlanır. Sonra normal sınıf bildirimi ile devamö edilir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Şablon parametresi tür belirten bir sözcük olarak sınıf bildirimin her yerinde ve tüm üye fonksiyonlarda kullanılabilir. 

	Bir sınıf şablonu mutlaka şablon parametresi açısal parantezler içerisinde belirtilerek kullanılmak zorundadır. Sınıf şablonlarında fonksiyon şablonlarında 
	olduğu gibi "otomatik şablon parametresinin tespiti" yapılmamaktadır. Şablon parametresinin mutlaka açısal parantezler içerisinde belirtilmesi gerekmektedir. 
	Örneğin:

	Sample<int> s(10);

	Bir sınıf şablonunun üye fonksiyonları sınıf içerisinde inline olarak tanımlanabilir. Ancak bu üye fonksiyonlar sınıfın dışında tanımlanacaksa şablon bildirimi
	biçiminde tanımlanmalıdır. Çünkü şablon bir sınıfın üye fonksiyonları şablon fonksiyonlar gibidir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	Aslında sınıf şablonunun üye fonksiyonları dışarıda yazılırken şablon parametrelerinin isimlerinin uyuşması gerekmemektedir. Ancak bu uyuşumu sağlamak iyi bir tekniktir. 
	Yani aslında biz foo üye fonksiyonunu şöyle de tanımlayabilirdik:

	template <typename K>
	void Sample<K>::foo()
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(T val);
	void disp() const;
private:
	T m_val;
};

template <class T>
Sample<T>::Sample(T val)
{
	m_val = val;
}

template <typename T>
void Sample<T>::disp() const
{
	cout << m_val << endl;
}

int main()
{
	Sample<int> s(10);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonu aslında eğer o sınıf programda hiç kullanılmamışsa hiç "instantiate" edilmemektedir. (Biz "instantiate" sözcüğü yerine "açım", "açılma" 
	sözcüklerini de kullanıyoruz). Tabii bir sınıf şablonu açılırken aslında derleyici onun tüm üye fonksiyonlarını açmaz. Yalnızca kullanılan üye fonksiyonlarını 
	açar. 

	Aşağıdaki örnekte standart vector sınıfının birkaç fonksiyonu taklit edilmiştir. Tabii bu örnek orijinal vector sınıfının bir gerçekleştirimi değildir. 
	Orijinal vector sınıfında exception durumu için "strong guarantee" verilmektedir. Biz aşağıdaki örnekte herhangi bir exception garantisi vermiyoruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// myvector.hpp

#ifndef MYVECTOR_HPP_H
#define MYVECTOR_HPP_H

#include <cstddef>

const int DEF_CAPACITY = 4;

template <typename T>
class myvector {
public:
	using size_type = std::size_t;

	myvector()
	{
		m_vector = new T[DEF_CAPACITY];
		m_size = 0;
		m_capacity = DEF_CAPACITY;
	}
	~myvector()
	{
		delete[] m_vector;
	}
	void push_back(const T &r);
	size_type size() const { return m_size; }
	size_type capacity() const { return m_capacity; }
	T &operator[](size_t index)
	{
		return m_vector[index];
	}
	const T &operator[](size_t index) const
	{
		return m_vector[index];
	}
private:
	T *m_vector;
	size_type m_size;
	size_type m_capacity;
};

template <typename T>
void myvector<T>::push_back(const T &r)
{
	if (m_size == m_capacity) {
		T *new_vector = new T[m_capacity * 2];
		for (size_type i = 0; i < m_size; ++i)
			new_vector[i] = m_vector[i];
		delete[] m_vector;
		m_vector = new_vector;
		m_capacity *= 2;
	}

	m_vector[m_size++] = r;
}

#endif

// app.cpp

#include <iostream>
#include "myvector.hpp"

using namespace std;

int main()
{
	myvector<int> mv;

	for (myvector<int>::size_type i = 0; i < 10; ++i)
		mv.push_back(i);

	for (myvector<int>::size_type i = 0; i < mv.size(); ++i)
		cout << mv[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir sınıf şablonundan türetilebilir. Tabii bu durumda taban sınıf belirtilirken şablon parametresinin açısal parantezler içerisinde belirtilmesi gerekir. 
	örneğin:

	template <typename T>
	class A {
		//...
	};

	class B : public A<int> {
		//...
	};

	Burada B sınıfı A sınıfının int açılımından türetilmiştir. 

	Tabii bir sınıf şablonu normalk bir sınıftan da türetilebilir. Örneğin:

	class A {
		//...
	};

	template <typename T>
	class B : public A {
		//...
	};

	Bu duurmda B'nin her bir açılımı A'dan türetilmiş olmaktadır. Örneğin:

	B<int> x;
	B<double> y;
	...

	Bir sınıf şablonu başka bir sınıf şablonundan da türetilebilir. Örneğin:

	template <typename T>
	class A {
		//...
	};

	template <typename T>
	class B : public A<T> {
		//...
	};

	Burada B hangi tür ile açılırsa aslında o A'nın aynı türden açılımından türetilmiş olur. Örneğin:

	B<int> b;

	Burada B<int> sınıfı A<int> sınıfındna türetilmiştir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Normal bir sınıfın bir üye fonksiyonju bir fonksiyon şablonu olabilir. Sınıfın içerisindekli fonksiyon şablonlarına C++'ta "member template" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	template <typename T>
	void foo(T a);				// member template
};

template <typename T>
void Sample::foo(T a)
{
	//...
}

int main()
{
	Sample s;

	s.foo(100);		// T = int
	s.foo(12.3);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonun iye fonksiyonlarının zaten şablon fonksiyonlar gibi ele alındığını belirtmiştik. Ancak bir sınıf şablonunun belli üye fonksiyonları da
	ekstra biçimde şablon olabilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();

		template <typename K>
		vaid bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	template <typename T>
	template <typename K>
	void Sample<T>::bar(K a)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	void foo();

	template <typename K>
	void bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
	//...
};

template <typename T>
void Sample<T>::foo()
{
	//...
}

template <typename T>
template <typename K>
void Sample<T>::bar(K a)
{
	//...
}

int main()
{
	Sample<int> s;

	s.foo();
	s.bar(12.3);		// T = int, K = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir sınıf şablonunun özel bir tür için başka bir versiyonun yazılması istenebilir. Buna "özelleştirme (specialization)" denilmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	template <>
	class Sample<bool> {
		//...
	};

	Burada Sample sınıfının bool için özelleştirildiğini görüyorsunuz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T> 
class Sample {
public:
	void foo()
	{
		cout << "general template foo" << endl;
	}
};

template<>
class Sample<bool> {
public:
	void foo()
	{
		cout << "bool specialization foo" << endl;
	}
};

int main()
{
	Sample<int> s;
	Sample<bool> k;

	s.foo();
	k.foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonunun her farklı türdne açımı farklı bir tür belirtmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample<int> x;
	Sample<double> *y;

	y = &x;		// error! türler farklı

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Şablon fonksiyon ya da sınıf bildirimini gören derleyici hata kontrolünü iki aşamada yapmaktadır:

	1) Fonksiyon ta da sınıfı gördüğü aşamada. Burada henüz bir açım yapılmamıştır. Şablonb parametresi ne olursa olsun kodun geçerli olması gerekir. 
	örneğin aşağıdaki şablon bildiriminde daha açım yapılmadan derleyici error durumunu tespit edebilirr:

	template <typename T>
	void foo(T a)
	{
		xxxxxx		// böyle bir değişken yok! şablon parametresi ne olursa olsun burada bir error söz konusudr.
	}

	2) Açım (instantiation) sırasında. Şablonb parametrelerinin açım sırasında fonksiyon ya da sınıf şablonlarının koduna uygun olması gerekir. Örneğin iki değerin
	küçüğünü veren aşağıdaki gibi bir fonksiyon şablonu olsun:

	template <typename T>
	T minval(const T &a, const T &b)
	{
		if (a < b)
			return a;

		return b;
	}

	Burada bu fonksiyonu biz int türüyle açabiliriz. Ancak < operatör fonksiyonu olmayan bir sınıfla açmaya çalışsak açım sırasında error oluşacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T minval(const T &a, const T &b)
{
	if (a < b)
		return a;

	return b;
}

class Number {
public:
	Number() = default;
	Number(int a) : m_a(a)
	{}
	bool operator <(const Number &r) const
	{
		return m_a < r.m_a;
	}
	friend ostream &operator <<(ostream &os, const Number &n)
	{
		os << n.m_a;

		return os;
	}
private:
	int m_a;
};

int main()
{
	int x;

	x = minval(10, 20);
	cout << x << endl;

	Number y;
	Number a(10), b(20);

	y = minval(a, b);

	cout << y << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablocu her zaman kullanılırken açım türü belirtilerek kullanılmalıdır. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample s;			// error!
	Sample<int> k;		// geçerli

	Ancak istisna olarak bir sınıf şablonu sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde açım türü belirtilmeden kullanılabilir. Bu durumda
	açım türünün şablon türleri olduğu kabul edilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		Sample a;		// geçerli, Sample<T> ile eşdeğer.
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesi hep fonksiyon ve sınıf şablonlarından oluşmaktadır. Örneğin aslında string sınıfı diye bir sınıf yoktur. Sınııfn asıl hali, 
	string'in karakterlerinin hangi türle ifade edileceğini de belirten şablon basic_string<T> sınıfıdır. string ismi aslında aşağıdaki gibi bir typedef 
	ismidir:

	typedef basic_string<char> string;

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede veri yapılarını temsil eden bir grup sınıfa "nesne tutan sınıflar (container classes)" denilmektedir. Biz daha önce nesne tutan sınıf olarak 
	vector<T> sınıfını görmüştük. Diğer önemli bir nesne tutan sınıf da list<T> isimli sınıftır. list sınıfı "bağlı liste (linked list)" denilen veri yapısını 
	gerçekleştirmek için kullanılmaktadır. Bağlı listeler önceki elemanın sonraki elemanını, sonraki elemanın da önceki elemanını gösterdiği özel veri yapılarıdır. 
	Bağlı listenin elemanları bellekte ardışıl bulunmaz. Bağlı listelerde belli bir elemana erişmek için önceki elemanları da dolaşmak gerekir. 

	list<T> nesnesinin sonuna eleman eklemek için yine push_back fonksiyonu kullanılmaktadır. list nesnesinin elemanları aralık tabanlı for döngüleriyle dolaşılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    list nesnesinin elemanları iteratör yoluyla da dolaşılabilmektedir. Daha önceden de belirttiğimiz gibi "iteratör" bir gösterici gibi kullanılan nesnelerdir. 
	Nesnenin başlangıç iteratörü begin üye fonksiyonuyla son elemandan sonraki iteratörü end üye fonksiyonuyla elde edilmektedir. list sınıfının kullandığı iteratörün
	türü sınıf içerisinde list<T>::iterator typedef ismiyle temsil edilmektedir. iteratör yoluyla list nesnesinin dolaşılmasının tipik kalıbı şöyledir:

	for (list<T>::iterator iter = a.begin(); iter != a.end(); ++iter) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (list<int>::iterator iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	for (auto iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede özel algoritmik bir yapı ile elemanları tutan bir grup nesne tutan sınıf da vardır. Bunlara İngilizce "associative containers" denilmektedir.
	Bunların listesi şöyledir:

	map<Key, Value>
	set<T>
	multimap<Key, Value>
	multiset<T>
	unordered_map<Key, Value>
	unordered_set<T>
	unordered_multimap<Key, Value>
	unordered_multiset<Key>

	Bu sınıfların aslında başka default değer alan şablon parametreleri de vardır. 

	map sınıfı en fazla kullanılan "associative container" sınıftır. Sınıf ahanat değer çiftlerini tutar. Anahtar verildiğinde değeri hızlı bir biçimde verir. 
	Sınıf iteratör yoluyla dolaşıldığında sıralı bir biçimde dolaşılmaktadır. Tipik olarak "dengelenmiş ikili ağaç (balanced binary tree)" biçiminde gerçekleştirilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	string result;

	result = m[420];
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir map nesnesi iteratör yoluyla dolaşılırken anahtar-değer çiftleri pair isimli bir sınıf nesnesi olarak elde edilir. pair<T, K> iki şablon parametresine
	sahip bir sınıftır. Sınıfın first veri elemanı nesnein ilk elemanını, secod veri elemanı ise ikinci elemanını belirtmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	for (map<int, string>::iterator iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	for (auto iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Son yıllarda "lambda ifadeleri (lambda expressions)" pek çok programlama diline sokuldu. Aslında lambda ifadelerine benzer yapılar "fonksiyonel (functional)"
	programlama modeline sahip dillerde zaten uzun süredir kullanılıyordu. Ancak son yıllarda klasik programlama dilleri de fonksiyonel öğeleri 
	bünyesine katmaya çalışmıştır. Dolayısıyla bu lambda ifadeleri bu baağlamda pek çok programlama diline eklenmiştir. Lambda ifadeleri C++11 ile birlikte C++'a
	da eklenmiş durumdadır. 

	Lambda ifadelerinden amaç bir fonksiyonu hem tanımlayıp hem de aynı noktada kullanmaya olanak sağlamaktır. Dolayısıyla lambda fonksiyonlar ifadelerin içerisinde
	bulunabilirler. Lambda fonksiyonla bize şu iki avantajı sunmaktadır:

	1) Bir fonksiyonu o anda yazıp ifade içerisinde kullanmak kodu daha kısa ve öz gösterebilmektedir. Hem programcı için pratik bir kullanım sunarlar 
	hem de az tuşa basarak benzer işlemleri yapmayı sağlarlar. 

	2) Lambda fonksiyonlar bir çeşit "iç fonksiyon (nested function)" gibi kullanılabilmektedir. Dolayısıyla bir lambda fonksiyon içerisinde biz dış fonksiyonun yerel 
	değişkenlerini kullanabiliriz. 

	C++'ta lambda ifadelerinin genel biçimi şöyledir:

	<[[capture_listesi]]> [(parametre_listesi)] [-> <geri_dönüş_değerinin_türü] 
	{
		//...
	}

	Bir lambda ifadesi kullanıldığında derleyici aslında lambda ifadesi için bir sınıf oluşturmaktadır. Ancak oluşturduğu sınıfın ismini programcı bilmemektedir. 
	Lambda kodları bu sınıfın fonksiyon çağırma operatör fonksiyonu içerisine yerleştirilmektedir. Dolayısıyla programcı eğer lambda ifadesini bir yere 
	atayacaksa onun ürünü bilmediğine göre auto tür belirleyicisini kullanmalıdır. Örneğin:

	auto f = [] (int a) -> int { return a * a; };
	int result;

	result = foo(10);

	Aslında burada arka plana şunlar yapılmaktadır:

	class compiler_generated_name {
	public:
		int operator ()(int a)
		{
			return a * a;
		}
		//...
	};
	int result;

	auto f = compiler_generated_name();
	
	result = f(10);

	cout << result << endl;

	Yani aslında biz bir lambda ifadesi yazdığımızda bir sınıf oluşturmuş ve aynı zamanda o sınıf türünden bir nesne yaratmış oluruz. Sonra bu lambda 
	ifadesi çağrıldığında aslında sınıfın fonksiyon çağırma operatör fonksiyonu çalıştırılmış olur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi fonksiyon yerine lambda ifadeleri kullanmanın uygun olacağı yerler nelerdir? İşte büyük ölçüde lambda ifadeleri C++'ın standart kütüphanesindeki 
	"algoritma (algorithm)" denilen fonksiyonlarla birlikte kullanılmaktadır. Thread'ler gibi konularda da lambda ifadeleri kimi zaman kullanılabilmektedir. 
	C++'ın <algoritm> başlık dosyasında pek çok temel işlemi yapan şablon fonksiyonun bulunduğunu sçylemiştik. Bu şablon fonksiyonlar "iterator" denilen kavram kullanılarak 
	oluşturulmuştu. İteratör "gösterici gibi davranan" şeyler anlamına geliyordu. Yani iteratör gerçek bir gösterici olabilirdi ya da gösterici gibi davranan (yani * ve/veya
	-> operatör fonksiyonları bukunan) sınıf nesneleri olabilirdi. <algoritm> başlık dosyasındaki şablon fonksiyonlar bizden bir dizilimi başlangıç ve bitiş 
	iteratörleri yoluyla almaktadır. Bitiş iteratörler her zaman dizilimdeki son elemandan sonraki olmayan elemanı temsil etmektedir. C++'ın standart nesne 
	tutan sınıfları (container classes) bize başlangıç ve bitiş iteratörlerini begin ve end üye fonksiyonarıyla vermektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi for_each isimli şablon fonksiyon bir dizilimin her elemanı için bir fonksiyonu çağırıyordu. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

void foo(int a)
{
	cout << a *  a << " ";
}

int main()
{
	int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	for_each(a, a + 10, foo);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşte yukarıdaki örnekte kullandığımız fonksiyon lambda ifadesi olarak hemen yazılıp ifadenin içerisinde kullanılabilmektedir.   
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	for_each(a, a + 10, [](int a) {cout << a * a << " "; });

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Benzer biçimde örneğin üç parametreli sort fonksiyonunda yer değiştirme yapılıp yapılmayacağına yönelik fonksiyon lambda biçiminde yaızlabilir. Aşağıdaki 
	örnekte şehir isimleri alfabetik sıraya göre değil sözcük uzunluklarına göre sıraya dizilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> cities = {"ankara", "izmir", "adana", "gaziantep", "eskisehir", "van", "manisa"};

	sort(cities.begin(), cities.end(), [](const string &s1, const string &s2) { return s1.size() < s2.size(); });

	for (auto &city : cities)
		cout << city << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	<algorithm> başlık dosyasında find fonksiyonun yanı sıra find_if isimli bir fonksiyon da vardır. Bu fonksiyonun üçüncü parametresi bir fonksiyon almaktadır.
	Bu fonklsiyonun tel parametresi olamlıdır (unary predicate). Fonksiyon bool bir değere geri dönmelidir. Fonksiyon eğer elemanı bulmuşsa ture değerine bulamamışsa
	false değerine geri dönecek biçimde yazılmalıdır. Bu üçüncü fonksiyonu biz lambda ifadesi olarak girebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> cities = {"ankara", "izmir", "adana", "gaziantep", "eskisehir", "van", "manisa"};

	auto result = find_if(cities.begin(), cities.end(), [](const string &s)-> bool {return s.size() == 3; });

	if (result == cities.end())
		cout << "cannot find!" << endl;
	else
		cout << *result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer lambda fonksiyonun parametresi yoksa lambda ifadesi yaılırken parametre parantezleri parantezler hiç  kullanılmayabilir. örneğin:

	auto f = [] -> int { return 10; };

	cout << f() << endl;

	
	Yani yukarıdaki lambda ifadesi aşağıdaki ile eşdeğerdir:

	auto f = [] () -> int { return 10; };

	Lambda ifadeleride geri dönüş değeri de belirtilmeyebilir. Bu durumda geri dönüş değeri return ifadesinin değeir türünden olur. Örneğin:

	auto f = [] { return 10; };

	Burada geri dönüş değeri int türdendir. Tabii bu durumda lambda ifadesindeki tüm return deyimlerinin aldığı ifadelerin aynı türden olması gerekir. Örneğin:

	auto f = [](int a) { return a * a; }

	Burada a * a ifadesi int türden olduğuna göre geri dönüş değerinin türü belirtilmemiş olsa da int türden kabul edilmektedir. 

	Lambda ifadelerinde global değişkenler doğrudan klullanılabilir. Örneğin:

	#include <iostream>

	using namespace std;

	int a = 10;

	int main()
	{
		auto f = [] { return a * a; };

		cout << f() << endl;

		return 0;
	}

	Lambda ifadelerinde ifadenin yazıldığı fonksiyondaki yerel değişkenler de kullanılabilir. Ancak bu durumda ifanin yazıldığı fonksiyonun hangi yerel 
	değişkenlerinin kullanılacağı köşeli parantez içerisindeki "capture istesinde" aralarına ',' atomu konularak belirtilmelidir. 

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, b] { return a * b; };

		cout << f() << endl;

		return 0;
	}

	Capture listesindeki elemanalrın lambda ifadesi ile belirtilen sınıf nesnesine aktarımı lambda ifadesi görüldüğünde yapılmaktadır, fonksiyon çağrıldığında değil. 
	Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, b] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 200

		return 0;
	}

	Capture işlemi referans yoluyla da yapılabilir. Bu durumda capture değilen değişken isminin soluna & atomu getirilir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, &b] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 20

		return 0;
	}

	Bu örnekte a kopyalama yoluyla b ise referans yoluyla capture edilmiştir. Dolayısıyla lambda ifadesi içerisinde kullanılan b aslında adresi ile alınan nesneye 
	erişmek anlamındadır. 

	[=] sentaksı kopyalama yoluyla otomatik capture anlamına gelmektedir. Yani bu durumda derleyici lambda ifadesini inceler. eğer orada üst fonksiyonun 
	yerel değişkenleri kullanılmışsa o değişkenleri otomatik olarak capture eder. Bu capture işlemi lambda ifadesinin bulunduğu yerde kopyalaa yoluyla
	yapılmaktadır. Öreğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [=] { return a * b; };

		cout << f() << endl;		

		return 0;
	}

	Otomatik capture işleminin bir diğer yolu da [&] sentaksıdır. Bu durumda yine derleyici lambda ifadesini inceler. Bu ifadede üst fonksiyonun kullanılan değişkenlerini
	otomatik adres yoluyla capture eder. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [&] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 2

		return 0;
	}

	Otomatik capture işleminin  diğer bir yolu [=, liste] ya da [&, liste] sentaksıdır. Burada listede belirtilen değişkenler sol tarafta belirtilen 
	kopyalama ya da adres aktarımının tersi olarak belirtilmek zorundadır ve onlar bu biçimde aktarılırlar. Örneğin:

	auto f = [&, b] { return a * b * c; };

	Burada b kopyalanarak capture edilmektedir. Ancak a ve c adres yoluyla capture edilmektedir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20, c = 30;

		auto f = [&, b] { return a * b * c; };

		a = 1, b = 2, c = 3;

		cout << f() << endl;		// 60

		return 0;
	}


	Ancak şöyle bir capture ifadesi oluşturulamaz:

	auto f = [&, &b] { return a * b * c; };			// error!

	Zaten tüm kullanlanlar otomatik adres yoluyla captue edileceğine göre b'nin de yine adres yoluyla capture edilmesinin bir anlamı yoktur. Aynı 
	sektaktik biçim otomatik = sentalsında da benzer biçimde uygulanmaktadır. Örneğin:

	auto f = [=, &b] { return a * b * c; };

	Burada a ve c kopyalanarak b ise adres yoluyla capture edilmektedir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20, c = 30;

		auto f = [=, &b] { return a * b * c; };

		a = 1, b = 2, c = 3;

		cout << f() << endl;		// 600

		return 0;
	}

	Tabii aşağıdaki capture listesi yine hatalıdır:

	auto f = [=, b] { return a * b * c; };		// error!

	Burada zaten b kopyalanarak capture edilmektedir. Onun ayrıca capture listesinde kopyalarak capture edileceğinin belirtilmesi anlamsızdır ve geçersizdir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Thread'ler konusu oldukça detaya sahip olan ayrı bir biçimde ele alınması gereken ir konudur. Thread'ler işletim sistemini çekirdekleri (kernels) tarafından 
	oluşturulan bir mekanizmadır. Dolayısıyşa farklı işletim sistemlerinde thread'ler konusunda o işletim sistemine özgü farklılıklar çsz konusudur. Bugün en önemli 
	iki platform Microsoft Windows ve UNIX/Linux platformudur. Bu iki işletim sistemi grubu biribirinden tamamen farklıdır. Dolayısıyla bu iki işletim sisteminin
	sunduğu sistem fonksiyonları da birbirlerinden farklıdır. Thread'ler konusu bu nedenle işletim sistemi bağımlı bir konudur. Bukonuyu işletim sistem sisteminden 
	bağımsız hale getirebilmek için yani "cross platform" bir biçimde ele alabilmek için çeşitli kütüphaneler kullanılabilmektedir. 

	Windows'ta aşağı seviyeli thread işlemleri Windows'un sistem fonksiyonlarını çağıran "Windows API fonksiyonlarıyla" gerçekleştirilmektedir. Benzer biçimde
	UNIX/Linux dünyasında thread işlemleri o sistemlerdeki sistem fonksiyonlarını çağıran POSIX fonksiyonlarıyla gerçekleştirilmektedir. Java ve .NET gibi ortamlar
	thread işlemleri için kendi thread sınıflarını bulundurmuşlardır. Bu thread sınıfları Windows ortamlarındda Windows'un API fonksiyonları kullanılarak UNIX/Linux ortamlarında 
	POSIX fonksiyonları kullanrak yazılmışlardır. Ancak bu kısım framework tarafından halledildiği için bu ortamlar cross platform thread işlemlerine olanak sağlamaktadır. 
	Yine bazı framework'ler kendi thread sınıflarına sahiptir ve onlar da cross platform thread işlemlerine olabak vermektedir. Örneğin Qt kütüphanesindeki QThread 
	sınıfı yine Windows sistemlerinde Windows'un API fonksiyonlarını çağıracak biçimde UNIX/Linux sistemlerinde POSIX fonksiyonlarını çağıracak biçimde cross-paltform 
	olarak yazılmıştır. 

	C standartlarında 2011 yılna kadar thread'ler hiç söz konusu edilmemiştir. C11 ile birlikte C'ye "optional" yalın bir thread kütüphanesi eklenmişse de bu kütüphane 
	Microsoft ve GNU ve cland derleyicileri tarafından desteklenmemektedir. C++'a thread kütüphanesi C++11 ile birlikte eklenmiştir. Dolayısıyla artık cross-platform 
	thread işlemleri C++'ın standart kütüphanesi yoluyla yapılır duruma gelmiştir. Şüphesiz C++'ın standart thread kütüphanesi de Windoes'ta Windows'un API fonksiyonları
	kullanılarak UNIX/Linux ve Mac sistemlerinde POSIX fonksiyonları kullaılarak yazılmış durumdadır. Ancak C++ programcısı thread'leri hep aynı biçimde kullanır. 
	İşletim sistemi farklılığı kütüphane tarafından gerçekleştirim sırasında kendi içerisinde halledilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşletim sistemlerinde çalışmakta olan programalara "proses (process)" denilmektedir. Proses çalışmakta olan programın bütün her şeyini anlatan bir kavramdır. 
	Yani onun yetki derecesini, çalışma dizininin, bellekteki yükleme adresini, açtığı dosyaları vs. Ancak prosesin akışlarına "thread" denilmektedir. Eskiden thread'ler 
	yoktu. Thread'ler 90 yılların ortalarına doğru işletim sistemlerine girmiştir. Microsoft'un ilk thread'li işletim sistemi Windows NT (1993)'dir. Sonra bunu 
	Windows 95 (1995) izlemiştir. UNIX/Linux dünyasına da thread'ler 90'lı yılların ortalarında girmiştir. 

	Thread'ler proseslerin bağımsız çizelgelenen akışlarıdır. Modern işletim sistemleri genellikle "zaman paylaşımlı (time sharing)" bir thread çizelgelemesi kullanmaktdır. 
	Yani işletim sistemi bir thread'i alır onu belli bir süre çalıştırır sonra onun çalışmasına ara verir. Diğer thread'i alır onu da belli bir süre çalıştırır. 
	Hep böyle thread'leir parça parça çalıştırıp durdurarak çalıştırmaktadır. Kullanıcı sanki programlarını "hep çalışıyormuş zanneder" aslında programlar hep çalışmamaktadır. 
	İşletim sistemleri onları zaman paylaşımlı bir biçimde çalıştırmaktadır. Bir thread'in parçalı çalışma süresine "quanta süresi (time quantum)" denilmektedir. 
	Thread'in quanta süresi çeşitli faktörlere bağlı olarak değişebilmekle birlikte Windows'ta tipik olarak 20 ms. UNIX/Linxu ve Mac sistemlerinde 60 ms. kadardır. 
	Çok işlemcili ya da çok çekirdekli sistemlerde prensip değişmez. İşletim sistemleri her işlemci ya da çekirdek için ayrı bir kuyruk oluşturur o kuyrukta yine
	zaman paylaşımlı bir çalışma uygular. Çok işlemci ya da çekirdeğin bulunduğu durumda işler bu işlemciler ve çekirdekler tarafından paylaşıldığı için 
	toplamda daha hızlı bir çalışma söz konusu olur. 

	Thread'in parçalı çalışma süresi dolduğunda thread akışı zorla işletim sistemi tarafından alınmaktadır. Bu zorla akışın alınmasına İngilizce "preemption" denilmetedir. 
	Bu tür işletim sistemlerine ise "preemptive" işletim sistemleri denir. Akışın quanta süresi dolduunda zorla alınması donanım kesmeleri yoluyla yapılmaktadır. 
	Artık işlemcilerde de işlemcisnin kendi içerisinde bu amaçla timer devreleri bulundurulmaktadır. 

	Bir proses çalışmaya tek bir thread'le başlar. Buna prosesin "ana thread'i (main thread)" denilmektedir. Örneğin C'de main'den giren akış ana thread akışıdır. 
	Diğer thread'ler programcı tarafından yaratılmaktadır. Tabii yukarıda da belirtildiği gibi aslında thread'lerin yaratılması işletim sisteminin sistem fonksiyonları ile 
	yapılmaktadır. Ancak bu sistem fonksiyonlarını çağıran çeşitli kütüphaneler ve arayüzler oluşturulmuştur. C++'ın thread ktüphanesi de neticede aslında i,şletim sisteminin
	sistem fonksiyonlarıı çağırmaktadır. Ancak yukarıda da sözünü ettiğimiz gibi C++'ın standart kütüphanesi bu bağlamda "portable" bir arayüz sunmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın thread kütüphanesindeki sınıfların ve fonksiyonların önemli bölümü <thread> başlık dosyası içerisidedir. Thread'ler thread isimli sınıf yoluyla yaratılmaktadır. 
	thread sınıfı türünden bir nesne yaratıldığında thread de yaratılmış olur. Thread nesnesi yaratılır yaratılmaz thread akışı da başlatılmaktadır. 
	Bir thread yaratıldığında thread akışı belli bir fonksiyondan başlatılmaktadır. İşte thread yaratılırken programcı thread akışının başlatılacağı fonksiyonu da 
	verir. Thread fonksiyonu herhangi bir prototipe sahip olabilir. Zaten threda sınıfı da fonksiyonları şablon olan bir sınıftır. thread sınıfının kendisi şablon sınıf değildir. 
	Ancak fonksiyonlarının bazıları şablon fonksiyonlardır. 

	Bir thread nesnes yaratıldıktan sonra mutlaka bu nesne ile join ya da detach üye fonksiyonlarının çağrılması gerekir. Eğer bu fonksiyonlar çağrılmazsa thread 
	nesnesi faaliyet alanını bitirdiğinde thread sınıfının yıkıcı fonksiyonu std::terminate fonksiyonunu çağırır. Bu fonksiyon da std::abort fonksiyonunu çağırarak 
	prosesi sonlandırır. 

	Aşağıda thread yaratma işlemine bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>

using namespace std;

void thread_proc()
{
	cout << "thread is running..." << endl;
}

int main()
{
	thread t(thread_proc);

	//...

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir therad akışı yaratılmış ve sonra hem main thread'te hem de yaralıan thread'te birer saniye beklenerek birlikte çalışma sağlanmışır. 
	Bir saniye beklemek için C++11 ile C++'a eklenen chrono kütüphanesinden (duration isimli sınıftan) faydalanılmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc()
{
	for (int i = 0; i < 10; ++i) {
		cout << "mythread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc);

	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	thread sınıfının yapıcı fonksiyonları şablon fonksiyon durumundadır. Dolayısıyşla programcı thread fonksiyonu olarak herhangi bir fonksiyonu geçirebilir. 
	Hatta örneğin fonksiyonu taklit eden (function object) yani fonksiyon çağırma operatör fonksiyonu bulunan bir sınıf nesnesini de bu bağlamda kullanabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

class MyThreadClass {
public:
	void operator ()()
	{
		for (int i = 0; i < 10; ++i) {
			cout << "mythread: " << i << endl;
			this_thread::sleep_for(milliseconds(1000));
		}
	}
};

int main()
{
	MyThreadClass mtc;
	thread t(mtc);
	
	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Thread akışının başlatılacağı fonksiyon parametreli olabilir. Bu durumda parametreler thread sınıfının yapıcı fonksiyonunda thread fonksiyonu belirtildikten snra bir liste biçiminde 
	beirtilir. Bunu sağlamak için C++11 ile birlikte "variadic template" konusu standartlara eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    join isimli üye fonksiyon thread akışı bitene kadar onu çağıran thread'i bloke ederek bekletir. Yani biz join fonksiyonunu çağırdığımızda eğer thread henüz bitmemişse bitene 
	kadar join içerisinde beklemiş oluruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	t.join();
	
	cout << "ok" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    detach fonksiyonu thread akışı ile nesne arasında ilişkiyi kesmektedir. Yani detach yaptığımızda thread akışı devam eder ancak thread nesnesi ile bu akışın bir ilgisi 
	kalmaz. Yani biz yaratttığımız thread akışının sahipliğini bırakmış oluruz. 

	Aşağıdaki kodda thread'in ekrana yazacağı yazılar görülmeeyecektir. Bunun nedenini sonraki kısımda ele alacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;

using namespace std::chrono;
void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	t.detach();
	
	cout << "ok" << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

