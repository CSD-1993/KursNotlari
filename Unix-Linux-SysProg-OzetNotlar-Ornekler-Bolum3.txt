/*--------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                UNIX/Linux Sistem Programlama Kursunda Yapılan Örnekler ve Özet Notlar
                                                      3. Bölüm

                                                Eğitmen: Kaan ASLAN

            Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
            Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

            Aslan, K. (2025), "UNIX/Linux Sistem Programlama Kursu, Sınıfta Yapılan Örnekler ve Özet Notlar", 
                C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                          Son Güncelleme: 20/08/2025 - Çarşamba

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin bir parçası gibi işlev gören, herhangi bir koruma engeline takılmayan, kernel mode'da çalışan özel olarak 
    hazırlanmış modüllere (yani kod parçalarına) Linux dünyasında "çekirdek modülleri (kernel modules)" denilmektedir. Çekirdek 
    modülleri eğer kesme gibi bazı mekanizmaları kullanıyorsa ve bir donanım aygıtını yönetme iddiasındaysa bunlara özel olarak 
    "aygıt sürücüleri (device drivers)" da denilmektedir. Nasıl bir masaüstü bilgisayara kart taktığımızda artık o kart donanımın 
    bir parçası haline geliyorsa çekirdek modülleri ve aygıt sürücüleri de install edildiklerinde adeta çekirdeğin bir parçası 
    haline gelmektedir. Her aygıt sürücü bir çekirdek modülüdür ancak her çekirdek modülü bir aygıt sürücü değildir. Bu nedenle
    biz yalnızca "çekirdek modülü" dediğimizde genel olarak aygıt sürücüleri de dahil etmiş olacağız.

    Biz bu bölümde Linux sistemleri için çekirdek modüllerinin ve aygıt sürücülerinin nasıl yazılacağını ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri ve aygıt sürücüler genel bir konu değildir. Her işletim sisteminin o sisteme özgü bir aygıt sürücü mimarisi
    vardır. Hatta bu mimari işletim sisteminin versiyonundan versiyonuna da değişebilmektedir. Bu nedenle aygıt sürücü yazmak
    genel bir konu değil, o işletim sistemine hatta işletim sisteminin belirli versiyonlarına özgü bir konudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinde ve aygıt sürücülerde her türlü fonksiyon kullanılamaz. Bunları yazabilmek için özel başlık dosyalarına 
    ve ve amaç dosyalara gereksinim duyulmaktadır. Bu nedenle ilk yapılacak şey bu başlık dosyalarının ve kütüphanelerin ilgili 
    sisteme yüklenmesidir.

    Genellikle bir Linux sistemini yüklediğimizde zaten çekirdek modüllerini ve aygıt sürücüleri oluşturabilmek için gereken 
    başlık dosyaları ve diğer gerekli öğeler "/usr/src" dizini içerisindeki "linux-headers-$(uname -r)" dizininde yüklü biçimde 
    bulunmaktadır. Ancak bunlar yüklü değilse Debian tabanlı sistemlerde bunları şöyle yükleyebilirsiniz:

    $ sudo apt install linux-headers-$(uname -r)

    Tabii programcı o anda çalışılan çekirdeğin kodlarının hepsini de kendi makinesine indirmek isteyebilir. Bunun için aşağıdaki 
    komut kullanılabilir:

    $ sudo apt-get install linux-source

    Bu indirmeler "/usr/src" dizinine yapılmaktadır.

    Ayrıca "/lib/modules/$(uname -r)" isimli dizindeki "build" isimli dizin de çekirdek kaynak kodlarının bulunduğu dizine ya da 
    aygıt sürücülerin derlenmesi için gereken öğelerin bulunduğu dizine (tipik olarak "linux-headers-$(uname -r)" dizinine) 
    sembolik link yapılmış durumdadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünde biz user mod için yazılmış kodları kullanamayız. Çünkü orası ayrı bir dünyadır. Ayrıca biz çekirdek 
    modüllerinde çekirdek içerisindeki her fonksiyonu da kullanamayız. Yalnızca bazı fonksiyonları kullanabiliriz. Bunlara 
    "çekirdek tarafından export edilmiş fonksiyonlar" denilmektedir. "Çekirdek tarafından export edilmiş fonksiyon" kavramıyla 
    "sistem fonksiyonu" kavramının bir ilgisi yoktur. Sistem fonksiyonları kullanıcı modundan (user mode) çağrılmak üzere tasarlanmış 
    ayrı bir grup fonksiyondur. Oysa çekirdek tarafından export edilmiş fonksiyonlar kullanıcı modundan çağrılamazlar. Yalnızca 
    çekirdek modüllerinden çağrılabilirler. Buradan çıkan sonuç şudur: Bir çekirdek modülü yazılırken ancak çekirdeğin export 
    ettiği fonksiyonlar ve nesneler kullanılabilmektedir. Tabii çekirdeğin kaynak kodları çok büyüktür ancak buradaki kısıtlı 
    sayıda fonksiyon export edilmiştir. Benzer biçimde programcının oluşturduğu bir çekirdek modül içerisindeki belli fonksiyonları 
    da programcı export edebilir. Bu durumda bu fonksiyonlar da başka çekirdek modüllerinden kullanılabilirler. O halde özetle:

    1) Çekirdek modülleri yalnızca çekirdek içerisindeki export edilmiş fonksiyonları kullanabilir.
    2) Kendi çekirdek modülümüzde biz de istediğimiz fonksiyonu export edebiliriz. Bu durumda bizim çekirdek modülümüz çekirdeğin
    bir parçası haline geldiğine göre başka çekirdek modülleri de bizim export ettiğimiz bu fonksiyonları kullanabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mademki çekirdek modülleri işletim sisteminin çekirdek kodlarındaki fonksiyonları ve nesneleri kullanabiliyor o zaman 
    çekirdek modülleri o anda çalışılan çekirdeğin yapısına da bağlı durumdadır. Bu nedenle işletim sistemlerinde "çekirdek 
    modülü yazmak" ya da "aygıt sürücü yazmak" biçiminde genel bir konu yoktur. Her işletim sisteminin çekirdek modül ve aygıt 
    sürücü mimarisi diğerlerinden farklıdır. Dolayısıyla çekirdek modüllerinin ve aygıt sürücülerinin yazılması spesifik bir 
    işletim sistemi için geçerli olabilecek platform oldukça bağımlı bir konudur. Hatta işletim sistemlerinde bazı versiyonlarda 
    genel aygıt sürücü mimarisi bile değiştirilebilmektedir. Dolayısıyla bu tür durumlarda eski aygıt sürücüler yeni versiyonlarda, 
    yenileri de eski versiyonlarda çalışamamaktadır. Örneğin Linux'ta çekirdek versiyonları arasında çekirdekteki export edilmiş 
    bazı fonksiyonlar isim ya da parametrik yapı olarak değiştirilmiş durumdadır. Bu nedenle Linux çekirdeğinin belli bir 
    versiyonu için yazılmış olan aygıt sürücüler başka bir versiyonunda geçersiz hale gelebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin ve aygıt sürücülerin yazımı için programcının çekirdek yapısını ana hatlarıyla bilmesi gerekmektedir. 
    Çünkü bunları yazarken çekirdeğin içerisindeki çeşitli veri yapıları ve export edilmiş fonksiyonlar kullanılmaktadır. 

    Linux çekirdek modülleri ve aygıt sürücüleri hakkında yazılmış birkaç kitap vardır. Bunların en klasik olanı "Linux Device 
    Drivers (3. Edition)" kitabıdır. Ancak bu kitaptaki bazı içerikler güncel çekirdeklerle uyumsuz hale gelmiştir. Bu konudaki 
    resmi dokümanlar ise "kernel.org" sitesindeki "documentation" kısmında bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü derlemek ve link etmek maalesef sanıldığından daha zordur. Her ne kadar çekirdek modülleri ELF object 
    dosyaları biçimindeyse de bunlarda özel bazı "bölümler (sections)" bulunmaktadır. Dolayısıyla bu modüllerin derlenmesinde 
    özel "gcc" seçenekleri devreye sokulmaktadır. Çekirdek modüllerinin link edilmeleri de bazı kütüphane dosyalarının devreye 
    sokulmasıyla yapılmaktadır. Dolayısıyla bir çekirdek modülünün manuel biçimde "build edilmesi" için bazı ayrıntılı bilgilere 
    gereksinim duyulmaktadır. İşte çekirdek modüllerinin build edilmesinde çekirdeğin KBuild sistemi devreye sokulmaktadır. Bu 
    nedenle çekirdek modüllerinin build edilmesi için çekirdek kaynak kodlarındaki birtakım başlık dosyalarının ve Make dosyalarının 
    build işleminin yapılacağı makinede bulunması gerekir. Biz yukarıda bu dosyalara "/lib/modules/$(uname -r)/build" dizini 
    yoluyla erişilebileceğini belirtmiştik. Bu dizin aslında Linux kaynak kod ağacının bulunduğu dizini belirtmektedir. Ancak
    yukarıda da belirttiğimiz gibi çekirdek modüllerinin ve aygıt sürücülerin derlenmesi için Linux'un tüm kaynak kodlarına
    gerek yoktur. Yalnızca başlık dosyaları ve make dosyalarının bulunması yeterlidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri o anda çalışılan host sistem için derlenebileceği gibi gömülü bir sistem için de derlenebilir. Eğer 
    derleme gömülü sistem için yapılacaksa şüphesiz çapraz derleyicilerin de ilgili sistemde kurulu olması gerekir. Yukarıda 
    da belirttiğimiz gibi çekirdek modüllerinin derlenmesi için ilgili çekirdeğe yönelik başlık dosyaları ve çeşitli make 
    dosyaları gibi bazı öğelerin de bulunuyor olması gerekir. Eğer derleme bir gömülü sistem için yapılacaksa o gömülü sistemdeki 
    çekirdeğe ilişkin bu dosyalar da host makinede bulunuyor olmalıdır. Örneğin biz masaüstü bilgisayardaki Mint dağıtımında 
    çalışıyor olalım. Bu sistemin kendisi için çekirdek modülü derleyeceksek zaten tüm gerekli öğeler hazır durumdadır.
    Ancak biz bu makinede BeagleBone Black için çekirdek modülü ve aygıt sürücü derlemesi yapacaksak çapraz derleyicimizin ve 
    BeagleBone Black'teki çekirdeğe yönelik temel başlık dosyalarının ve Make dosyalarının bulunuyor olması gerekecektir. Tabii 
    BeagleBone Black'teki çekirdek sürümüne ilişkin çekirdek kaynak kodları bu makineye çekerek bu gereksinimi karşılayabiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Masaüstü bir sistem için çekirdek modül derlemesinde kullanılabilecek minimal bir Makefile dosyası aşağıdaki gibi olabilir:

    obj-m += generic.o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Burada önce "/lib/modules/$(uname -r)/build" dizinindeki "Makefile" dosyası çalıştırılmış ondan sonra çalışma bu yazdığımız 
    make dosyasından devam ettirilmiştir. Özetle bu make dosyası aslında çekirdeğin build sistemini kullanarak "generic.c" isimli 
    dosyanın derlenmesini ve çekirdek modülü biçiminde link edilmesini sağlamaktadır. Bu make dosyasını şöyle de düzenleyebilirdik:

    obj-m += generic.o

    KDIR := /lib/modules/$(shell uname -r)/build
    PWD := $(shell pwd)

    all:
        make -C ${KDIR} M=${PWD} modules
    clean:
        make -C ${KDIR} M=${PWD} clean

    Çekirdek modül birden fazla kaynak dosyadan oluşturulabilir. Bu durumda ilk satır şöyle oluşturulabilir:

    obj-m += a.o b.o c.o...

    Eğer bu dosyaları birden fazla satırda ayrı ayrı belirtirsek bu durumda birden fazla modül dosyası oluşturulacaktır:

    obj-m += a.o
    obj-m += b.o
    obj-m += c.o
    ...

    Bizim oluşturduğumuz Makefile dosyasındaki "all" hedefine dikkat ediniz:

    $ make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules

    make programının -C seçeneği Makefile dosyasını aramadan önce bu seçeneğin argümanında belirtilen dizine geçiş yapmaktadır.
    Dolayısıyla aslında yukarıdaki satırla "/lib/modules/$(shell uname -r)/build" dizinindeki Makefile dosyası çalıştırılacaktır.
    Buradaki M=${PWD} derlenecek kaynak dosyaların o anda çalışılan dizinde aranacağını belirtmektedir. Böylece çekirdeğin 
    KBuild sistemi yalnızca bizim dosyalarımızı derleyecektir.

    Makefile oluştururken bir noktaya dikkat ediniz. Make dilinde hedeflerin aşağısındaki yapılacak işlemler bir tab içeriden 
    yazılmaktadır. Bazı text editörler TAB tuşuna basıldığında dosyaya TAB karakter yerine belli miktar (tipik olarak 4) SPACE
    karakteri basmaktadır. TAB yerine n tane SPACE karakterinin basılması make dosyalarında bir derleme sorununa yol açacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

# Makefile

obj-m += generic.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerini va aygıt sürücüleri derlerken iki noktaya dikkat etmelisiniz:

    1) Kullandığınız çekirdek kodları hedef makinenin çekirdek sürümüne uygun olmalıdır. Eğer bu koşul sağlanmazsa çekirdekler
    arasında farklılıklar söz konusu olabileceği için derlenmiş olan çekirdek modül dosyası hedef sisteme başarılı bir biçimde
    yüklenemeyebilir. Tabii Linux çekirdeğindeki değişiklikler daha önce yazılmış olan her çekirdek modülünü ve aygıt sürücüyü
    geçersiz hale getirmemektedir. Örneğin minör numara değişikliklerinde genellikle bir sorun oluşmamaktadır. Ancak ne olursa 
    olsun derleme yapılırken hedef sistemdeki çekirdeğe uygun kaynak dosyaların kullanılması şiddetle tavsiye edilmektedir. 
    Örneğin biz 6.9.2 çekirdeğinde çalışan makine için aygıt sürücüsü yazacaksak derleme yaptığımız makinede kullanacağımız 
    çekirdek kaynak kodlarının da bu 6.9.2 çekirdeğine ilişkin olması gerekir. Biz eski bir çekirdeğin kaynak kodlarıyla yeni 
    bir çekirdek için aygıt sürücü derlemeye çalışmamalıyız. Tabii eski bir versiyon kullanılarak derleme yapılırsa çoğu 
    durumda bir sorun ortaya çıkmayabilecektir. Ancak sorunun ortaya çıkma olasılığı da vardır.

    2) Kullanılan araç zincirinin de (yani derleyici, linker gibi programların da) çekirdeğin derlenmiş olduğu sistemle uyumlu
    olmasına dikkat ediniz. Eğer bu temel araçların versiyonlarında geçmişe doğru uyumu bozabilecek değişiklikler söz konusuysa
    yine derleme işlemi başarısız olabilir ya da çekirdek modülü yüklenirken sorun oluşabilir. Aslında çekirdeğin KBuild sistemi 
    çekirdek konfigürasyon dosyası yoluyla bu kontrolü yapabilmektedir. Ancak bu kontrol bypass da edilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii aslında make dosyası parametrik biçimde de oluşturabilmektedir:

    obj-m += $(file).o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Bu durumda make programı çalıştırılırken bu parametrenin değeri de belirtilmelidir. Örneğin:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi en basit bir kernel modülü oluşturup bunu bir başlangıç noktası olarak kullanalım. Bu modülümüze "helloworld" ismini
    verelim:

    /* helloworld.c */

    #include <linux/module.h>
    #include <linux/kernel.h>

    MODULE_LICENSE("GPL");

    int init_module(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void cleanup_module(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    Bu kernel modül aşağıdaki gibi build edilebilir:

    $ make file=helloworld

    Build işlemi bittiğinde kernel modül "helloworld.ko" dosyası biçiminde oluşturulacaktır. Burada "ko" uzantısı "kernel 
    object" sözcüklerinden kısaltılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülü, çekirdeğin içerisine "insmod" isimli programla yerleştirilmektedir. Tabii bu programın sudo ile "root" 
    önceliğinde çalıştırılması gerekmektedir. Örneğin:

    $ sudo insmod helloworld.ko

    Artık çekirdek modülümüz çekirdeğin içerisine yerleştirilmiştir. Yani modülümüz adeta çekirdeğin bir parçası gibi işlev 
    görecektir.

    Çekirdek modülleri istenildiği zaman "rmmod" isimli programla çekirdekten çıkartılabilirler. Bu programın da yine sudo 
    ile "root" önceliğinde çalıştırılması gerekir. Örneğin:

    $ sudo rmmod helloworld.ko

    rmmod komutu kullanılırken ".ko" dosya uzantısı da belirtilmeyebilir. Örneğin:

    $ sudo rmmod generic

    Aşağıda örnek için gerekli olan dosyalar verilmiştir. make işlemi şöyle yapılabilir:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

int init_module(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void cleanup_module(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Modüller "modprobe" isimli programla da yüklenebilir. Ancak modprobe programı yüklenecek modülleri "/lib/modules/$(uname -r)"
    dizininde aramaktadır. Dolayısıyla biz kendi derlediğimiz modülleri bu dizine yerleştirmemişsek yüklemeyi modprobe ile 
    yapamayız. Ancak çekirdek derlenirken oluşturulmuş olan modüller bu dizinde olduğu için bunları modprobe ile yükleyebiliriz. 
    modprobe programı yüklenecek aygıt sürücünün yalnızca ismini almaktadır. Çünkü zaten arama işlemini kendisi yapmaktadır. 
    Örneğin:

    $ modprobe g_ether

    insmod programının yüklenecek aygıt sürücü dosyasının tüm yol ifadesini aldığına dikkat ediniz. modprobe programında dosyanın 
    ".ko" uzantısı da belirtilmemektedir. Halbuki insmod programında bu uzantının da belirtilmesi gerekmektedir. modprobe aslında 
    "modules.dep" isimli bir dosyaya başvurmaktadır. Bu dosya çekirdek kaynak kodlarının kök dizininde çekirdek modülleri derlenirken 
    oluşturulmaktadır. Bu dosya içerisinde bağımlılık bilgileri vardır. Bir çekirdek modülü yazılırken başka bir çekirdek modülünün 
    içerisindeki fonksiyonlar kullanılmış olabilir. Bu durumda kullanan modülün yüklenmesi için önce onun kullandığı modülün 
    yüklenmesi gerekir. İşte bu biçimde durum karmaşık bir hal alabilmektedir. "modules.dep" dosyası içerisinde bir modülün 
    yüklenebilmesi için hangi modüllerin de yüklenmesi gerektiği bilgileri bulunmaktadır. Eğer biz kendi çekirdek modülümüzün de 
    modprobe ile yüklenmesini istiyorsak önce onu "/lib/modules/$(uname -r)/kernel" dizininin içerisindeki dizinlerden birine 
    yerleştirip sonra bu "modules.dep" dosyasının güncellenmesini sağlamamız gerekir. Bu işlem "depmod" programıyla "-a" seçeneği 
    kullanılarak yapılmaktadır:

    $ sudo depmod -a

    Kendi çekirdek modülünüzü ya da aygıt sürücünüzü örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc" dizinine yerleştirebilirsiniz.
    Tabii aygıt sürücü geliştirirken ikide bir modülü buraya yerleştirmenin bir anlamı yoktur. Bu nedenle geliştirme aşamasında 
    genellikle "insmod" programı kullanılmaktadır.

    modprobe ile yüklenen aygıt sürücü "modeprobe -r" ile boşaltılabilir. Örneğin:

    $ modprobe -r g_ether

    Tabii boşaltım sırasında yine eğer aygıt sürücünün bağımlı olduğu çekirdek modülleri başka modüller tarafından kullanılmıyorsa
    onlar da çekirdekten çıkartılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem açılır açılmaz otomatik olarak bir çekirdek modülünün ya da aygıt sürücünün yüklenmesi için birkaç yöntem kullanılabilmektedir. 
    "/etc/modules" dosyası "klasik sysvinit" ve "systemd" init tarafından işletilmektedir. Dolayısıyla bu dosyanın içerisine bir 
    satıra çekirdek modülünüzün ismini (yalnızca ismini) yazarsanız sistem açıldığında çekirdek modülü de otomatik yüklenmiş olur. 
    Ancak init programları bu dosyada belirtilen çekirdek modüllerini modprobe ile yüklemektedir. Dolayısıyla sizin de çekirdek 
    modülünüzü "/lib/modules/$(uname -r)/kernel" içerisindeki bir dizine (örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc"
    dizinine) yerleştirip "sudo depmod -a" komutunu uygulamanız gerekir. Eğer systemd init sistemi ile çalışıyorsanız yüklemeyi 
    yapacak bir "servis birim dosyası" oluşturabilirsiniz. Örneğin.

    [Unit]
    Description=Modül Yükleme Servisi
    After=network.target

    [Service]
    Type=oneshot
    ExecStart=/sbin/modprobe <modül_adı>
    RemainAfterExit=true

    [Install]
    WantedBy=multi-user.target

    Diğer bir yöntem de klasik systemvinit ve systemd tarafından bakılan "/etc/rc.local" dosyasının içerisine yükleme komutunu 
    yazmaktır. Örneğin:

    "sudo insmod /path/hellowold.ko"

    Tabii burada modprobe da kullanılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                128. Ders 17/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    En basit bir çekirdek modülünde aşağıdaki iki temel dosya include edilmelidir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    Bu iki dosya "/lib/modules/$(uname -r)/build/include" dizini içerisindedir. (Bu dizinin çekirdek kaynak kodlarındaki "include"
    dizini olduğuna dikkat ediniz. Bu iki başlık dosyası "libc" ve POSIX kütüphanelerinin başlık dosyalarının bulunduğu "/usr/include" 
    içerisinde değildir.) Yukarıda kullandığımız make dosyası include dosyalarının bu dizinde aranmasını sağlamaktadır.

    Eskiden çekirdek modüllerine modül lisansının eklenmesi zorunlu değildi. Ancak belli bir zamandan sonra bu zorunlu hale
    getirilmiştir. Modül lisansı MODULE_LICENSE isimli makro ile belirtilmektedir. Bu makro <linux/module.h> dosyası içerisinde
    bildirilmiştir. Tipik modül lisansı aşağıdaki gibi "GPL" biçiminde oluşturulabilir:

    MODULE_LICENSE("GPL");

    Bir çekirdek modülü yüklendiğinde çekirdek modülü içerisinde belirlenmiş olan bir fonksiyon çağrılır (bu fonksiyon C++'taki 
    "constructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi init_module biçimindedir. Bu fonksiyonun geri 
    dönüş değeri int türdendir ve parametresi yoktur. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif 
    hata koduna (negatif errno değerine) geri dönmelidir. Bu fonksiyon başarısızlıkla geri dönerse modülün yüklenmesinden 
    vazgeçilmektedir. Benzer biçimde bir modül çekirdek alanından boşaltılırken de yine bir fonksiyon çağrılmaktadır. (Bu 
    fonksiyon da C++'taki "destructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi cleanup_module biçimindedir. 
    Bu fonksiyonun geri dönüş değeri ve parametresi void biçimdedir.

    Çekirdek modülleri tıpkı daha önce görmüş olduğumuz daemon'lar gibi ekrana değil log dosyalarına yazarlar. Bunun için çekirdek 
    içindeki printk isimli fonksiyon kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                129. Ders 22/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    helloworld modülünde kullanmış olduğumuz printk fonksiyonu "çekirdeğin printf fonksiyonu" gibi düşünülebilir. printk fonksiyonunun 
    genel kullanımı printf fonksiyonu gibidir. Default durumda bu fonksiyon mesajların "/var/log/syslog" dosyasına yazdırılmasını 
    sağlamaktadır. printk fonksiyonunun prototipi <linux/kernel.h> dosyası içerisindedir. printk fonksiyonunun örnek kullanımı 
    şöyledir:

    printk(KERN_INFO "This is test\n");

    Mesajın solundaki KERN_XXX biçimindeki makrolar aslında bir string açımı yapmaktadır. Dolayısıyla yan yana iki string 
    birleştirildiği için mesaj yazısının başında küçük bir önek bulunur. Bu önek (yani bu makro) mesajın türünü ve aciliyetini 
    belirtmektedir. Tipik KERN_XXX makroları şunlardır:

    KERN_EMERG
    KERN ALERT
    KERN_CRIT
    KERN_ERR
    KERN_WARN
    KERN_NOTICE
    KERN_INFO
    KERN_DEBUG

    Bu makroların tipik yazım biçimi şöyledir:

    #define KERN_SOH        "\001"        /* ASCII Start Of Header */
    #define KERN_SOH_ASCII    '\001'

    #define KERN_EMERG        KERN_SOH "0"        /* system is unusable */
    #define KERN_ALERT        KERN_SOH "1"        /* action must be taken immediately */
    #define KERN_CRIT        KERN_SOH "2"        /* critical conditions */
    #define KERN_ERR        KERN_SOH "3"        /* error conditions */
    #define KERN_WARNING    KERN_SOH "4"        /* warning conditions */
    #define KERN_NOTICE        KERN_SOH "5"        /* normal but significant condition */
    #define KERN_INFO        KERN_SOH "6"        /* informational */
    #define KERN_DEBUG        KERN_SOH "7"        /* debug-level messages */

    Ancak bu makrolarda çeşitli çekirdek versiyonlarında değişiklikler yapılabilmektedir. C'de aralarında hiçbir operatör 
    bulunmayan iki string'in derleyici tarafından birleştirildiğini anımsayınız. Bu durumda aslında örneğin:

    printk(KERN_INFO "Hello World...\n");

    ile aşağıdaki çağrı eşdeğerdir:

    printk("\0017Hello World...\n");

    Ancak yukarıda da belirttiğimiz gibi bu makrolar üzerinde değişiklikler yapılabilmektedir. Dolayısıyla makroların kendisinin 
    kullanılması gerekir.

    Aslında KERN_XXX makroları ile printk fonksiyonunu kullanmak yerine pr_xxx makroları da kullanılabilir. Şöyle ki:

    printk(KERN_INFO "Hello World...\n");

    ile

    pr_info("Hello World...\n");

    tamamen eşdeğerdir. Diğer pr_xxx makroları şunlardır:

    pr_emerg
    pr_alert
    pr_crit
    pr_err
    pr_warning
    pr_notice
    pr_info
    pr_debug

    printk fonksiyonunun yazdıklarını "/var/log/syslog" dosyasına bakarak görebiliriz. Örneğin:

    $ tail /var/log/syslog

    Ya da "dmesg" programı ile de aynı bilgi elde edilebilir.

    En çok kullanılan log düzeyini belirten makrolar KERN_INFO, KERN_ERR ve KERN_WARNING makrolarıdır. Çekirdek modülü ya da 
    aygıt sürücü içerisinde bazı durumlara yönelik bilgi vermek için KERN_INFO, hatalı bir durumlar karşılaştığında KERN_ERR 
    ve bir uyarı oluşturulacağı zaman KERN_WARNING kullanılmaktadır. Diğer makrolar geliştiriciler tarafından çok seyrek 
    kullanılmaktadır.

    Çekirdek modülleri çekirdeğin içerisine yerleştirildiği için çekirdek modüllerinde biz kullanıcı modundaki (user mode'daki) 
    kütüphaneleri kullanamayız. (Örneğin çekirdek modunda standart C fonksiyonlarını ve POSIX fonksiyonlarını kullanamayız.) 
    Çünkü standart C fonksiyonları ve POSIX fonksiyonları "kullanıcı modundaki (user mode)" programlar için oluşturulmuş kütüphanelerin 
    içerisindedir. Biz çekirdek modüllerinin içerisinde yalnızca "export edilmiş çekirdek fonksiyonlarını" kullanabiliriz.

    Çekirdek modülleri içerisinde kullanılabilecek export edilmiş çekirdek fonksiyonları "Linux Kernel API" ismi altında 
    "kernel.org" tarafından dokümante edilmiştir. Örneğin bu fonksiyonların dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://docs.kernel.org/core-api/kernel-api.html

    Ancak maalesef bu export edilmiş fonksiyonlar hakkında ayrıntılı açıklamalar bulmak zordur. Bu nedenle bazen çekirdek 
    kaynak kodlarına başvurmak da gerekebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir anda yüklenmiş olan çekirdek modülleri "/proc/modules" dosyasından elde edilebilir. "/proc/modules" bir text 
    dosyadır. Dosyanın her satırında bir çekirdek modülünün bilgisi vardır. Örneğin:

    $ cat /proc/modules
    helloworld 16384 0 - Live 0x0000000000000000 (OE)
    vmw_vsock_vmci_transport 32768 2 - Live 0x0000000000000000
    vsock 40960 3 vmw_vsock_vmci_transport, Live 0x0000000000000000
    snd_ens1371 28672 2 - Live 0x0000000000000000
    snd_ac97_codec 131072 1 snd_ens1371, Live 0x0000000000000000
    gameport 20480 1 snd_ens1371, Live 0x0000000000000000
    ac97_bus 16384 1 snd_ac97_codec, Live 0x0000000000000000
    binfmt_misc 24576 1 - Live 0x0000000000000000
    intel_rapl_msr 20480 0 - Live 0x0000000000000000
    ...

    Yüklü modüllerin bilgileri "lsmod" isimli bir yardımcı programla da görüntülenebilmektedir. Tabii aslında "lsmod" 
    "/proc/modules" dosyasını okuyup onu daha anlaşılır biçimde görüntülemektedir. Örneğin:

    $ lsmod
    Module                  Size  Used by
    helloworld             16384  0
    btrfs                1564672  0
    blake2b_generic        20480  0
    xor                    24576  1 btrfs
    zstd_compress         229376  1 btrfs
    raid6_pq              122880  1 btrfs
    ufs                   106496  0
    qnx4                   16384  0
    hfsplus               118784  0
    hfs                    65536  0
    ...
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında init_module ve cleanup_module fonksiyonlarının ismi değiştirilebilir. Fakat bunun için bildirimde bulunmak gerekir. 
    Bildirimde bulunmak için ise module_init(...) ve module_exit(...) makroları kullanılmaktadır. Bu makrolar kaynak kodun 
    herhangi bir yerinde bulundurulabilir. Ancak makro içerisinde belirtilen fonksiyonların daha yukarıda bildirilmiş olması 
    gerekmektedir. Bu makrolar tipik olarak kaynak kodun sonuna yerleştirilmektedir. Örneğin:

    #include <linux/module.h>
    #include <linux/kernel.h>

    int helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    Aşağıda örnek bütünsel olarak verilmiştir. make işlemi şöyle yapılabilir:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Genellikle çekirdek modülü içerisindeki global değişkenlerin ve fonksiyonların "içsel bağlamaya (internal linkage)" sahip 
    olması tercih edilmektedir. Bu durum birtakım isim çakışmalarını da engelleyecektir. Biz de genel olarak örneklerimizde 
    zorunlu olmadıkça fonksiyonları hep static biçimde tanımlayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin init ve cleanup fonksiyonlarında fonksiyon isimlerinin soluna __init ve __exit makroları getirilebilmektedir. 
    Bu makrolar <linux/init.h> dosyası içerisindedir. Bu dosya da <linux/module.h> dosyası içerisinde include edilmiştir. 
    __init makrosu ilgili fonksiyonu ELF dosyasının özel bir bölümüne (section) yerleştirir. Modül yüklendikten sonra bu bölüm 
    çekirdek alanından atılmaktadır. __exit makrosu ise çekirdeğin içine gömülmüş modüllerde fonksiyonun dikkate alınmayacağını 
    (dolayısıyla hiç yüklenmeyeceğini) belirtir. Ancak sonradan yüklemelerde bu makronun bir etkisi yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerine 2003 yılında 2.6 çekirdekleriyle birlikte "sysfs (kısaca sys)" isimli bellek tabanlı yeni bir dosya sistemi
    daha eklenmiştir. Bu dosya sistemi de tıpkı proc dosya sistemi gibi çekirdeğin içinde bulunduğu durumu dış dünyaya bildirmek 
    ve çekirdek davranışının dışarıdan değiştirilmesine olanak sağlamak amacıyla oluşturulmuştur. Ancak "sysfs" dosya sistemi 
    daha "nesne yönelimli" bir tasarıma sahiptir. Yani birtakım olgular dizinlerle onların özellikleri de o dizinler içerisindeki 
    dosyalarla temsil edilmektedir. Bu bakımdan "sysfs" dosya sistemi "proc" dosya sisteminin bazı eksikliklerini tamamlamaktadır. 
    sysfs dosya sistemine "/sys" dizini yoluyla erişilmektedir.

    insmod ile yüklediğimiz her modül için "/sys/module" dizinin içerisinde ismi modül ismiyle aynı olan bir dizin yaratılmaktadır. 
    "/proc/modules" dosyası ile bu dizini karıştırmayınız. "/proc/modules" dosyasının satırları yüklü olan modüllerin isimlerini 
    ve bazı temel bilgilerini tutmaktadır. Modüllere ilişkin asıl önemli bilgiler ise çekirdek tarafından "/sys/module" dizininde 
    tutulmaktadır. sysfs dosya sistemi de proc dosya sistemi gibi çekirdek tarafından bellek üzerinde oluşturulan ve içeriği çekirdek
    tarafından güncellenen bir dosya sistemidir. Örneğin "helloworld.ko" modülünü yükledikten sonra bu dizin aşağıdaki gibi bir 
    içeriğe sahip olacaktır:

    $ ls /sys/module/helloworld -l
    toplam 0
    -r--r--r-- 1 root root 4096 Mar 22 21:25 coresize
    drwxr-xr-x 2 root root    0 Mar 22 21:25 holders
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initsize
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initstate
    drwxr-xr-x 2 root root    0 Mar 22 21:25 notes
    -r--r--r-- 1 root root 4096 Mar 22 21:25 refcnt
    drwxr-xr-x 2 root root    0 Mar 22 21:25 sections
    -r--r--r-- 1 root root 4096 Mar 22 21:25 srcversion
    -r--r--r-- 1 root root 4096 Mar 22 21:25 taint
    --w------- 1 root root 4096 Mar 22 21:22 uevent
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nasıl kullanıcı modu programlarında main fonksiyonuna komut satırı argümanları geçirilebiliyorsa benzer biçimde çekirdek 
    modüllerine de argüman (ya da parametre diyebiliriz) geçirilebilmektedir. Bu konuya genel olarak "çekirdek modül parametreleri" 
    denilmektedir.

    Çekirdek modüllerine parametre geçirme işlemi insmod komutu ile modül yüklenirken komut satırında modül isminden sonra 
    "değişken=değer" çiftleriyle yapılmaktadır. Örneğin:

    $ sudo insmod helloworld.ko number=10 msg="\"This is a test\"" values=10,20,30,40,50

    Bu örnekte number parametresi int bir değerden, msg parametresi bir yazıdan values parametresi ise birden fazla int değerden 
    oluşmaktadır. Bu tür parametrelere modülün dizi parametreleri denilmektedir.

    Çekirdek modüllerine geçirilen parametreleri modül içerisinde almak için module_param ve module_param_array isimli makrolar 
    kullanılır. module_param makrosunun üç parametresi vardır:

    module_param(name, type, perm);

    name parametresi ilgili değişkenin ismini belirtmektedir. Biz makroyu çağırmadan önce bu isimde bir global değişkeni tanımlamalıyız. 
    Ancak buradaki değişken isminin komut satırında verilen parametre (argüman da diyebiliriz) ismi ile aynı olması gerekmektedir. 
    type ilgili parametrenin türünü belirtir. Bu tür şunlardan biri olabilir:

    int
    long
    short
    uint
    ulong
    ushort
    charp
    bool
    invbool

    Buradaki charp char türden adresi, invbool ise geçirilen argümanın bool bakımdan tersini temsil etmektedir. module_param
    makrosunun perm parametresi "/sys/modules/<modül ismi>" dizininde yaratılacak olan "parameters" dizininin erişim haklarını 
    belirtir. Bu makrolar global alanda herhangi bir yere yerleştirilebilir.

    Örneğin kernel modülümüzde count ve msg isimli iki parametre olsun. Bunlara ilişkin module_param makroları şöyle oluşturulmalıdır:

    int count = 0;
    char *msg = "Ok";

    module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
    module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    char * türünden modül parametresi için makrodaki türün "charp" biçiminde olduğuna dikkat ediniz. Buradaki gösterici const 
    olamamaktadır. Bizim bir parametre için module_param makrosunu kullanmış olmamız modül yüklenirken bu parametrenin belirtilmesini 
    zorunlu hale getirmemektedir. Bu durumda bu parametreler default değerlerde kalacaktır. Yukarıdaki parametreleri helloworld 
    modülüne aşağıdaki gibi geçirebiliriz:

    $ sudo insmod helloworld.ko count=100 msg="\"this is a test\""

    Burada neden iç içe tırnakların kullanıldığını merak edebilirsiniz. Kabuk üzerinde tırnaklar "boşluklarla ayrılmış olan yazıların 
    tek bir komut satırı argümanı olarak ele alınacağını belirtmektedir. Ancak bizim ayrıca yazısal argümanları modüllere parametre 
    yoluyla aktarırken onları tırnaklamamız gerekir. Bu nedenle iç içe iki tırnak kullanılmıştır.

    Modül parametreleri kernel tarafından "/sys/module" içerisindeki modül ismine ilişkin dizinin altındaki parameters dizininde 
    dosyalar biçiminde dış dünyaya sunulmaktadır. İşte makrodaki erişim hakları buradaki parametre dosyalarının erişim haklarını 
    belirtmektedir. Kernel modül root kullanıcısı tarafından yüklendiğine göre bu dosyaların da kullanıcı ve grup id'leri root 
    olacaktır. Örneğin helloworld modülü için bu dosyalar "/sys/module/helloworld/parameters" dizini içerisindedir:

    $ ls -l /sys/module/helloworld/parameters
    toplam 0
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 count
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 msg

    Bu dosyalar doğrudan kernel modüldeki parametre değişkenlerini temsil etmektedir. Yani örneğin biz buradaki count dosyasına
    başka bir değer yazdığımızda kernel modülümüzdeki count değeri de değişmiş olacaktır. Tabii yukarıdaki erişim haklarıyla biz
    dosyaya yazma yapamayız. Bu erişim haklarıyla yazma yapabilmemiz için yazmayı yapan programın root olması gerekir. Terminalden 
    bu işlem aşağıdaki gibi yapılabilir:

    $ sudo bash -c "echo 200 > /sys/module/helloworld/parameters/count"

    yada

    $ echo 200 | sudo tee /sys/module/helloworld/parameters/count

    Burada işlemi aşağıdaki gibi yapamayacağımıza dikkat ediniz:

    $ sudo echo 200 > /sys/module/helloworld/parameters/count

    Çünkü burada her ne kadar echo programı root önceliğinde çalıştırılıyorsa da dosyayı açan kullanıcı root değildir. Çünkü 
    > işareti ve onun sağının sudo ile bir ilgisi yoktur.

    Bu denemeyi aşağıdaki modülle yapabilirsiniz. Modülü önce insmod ile aşağıdaki gibi yükleyiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\""

    Sonra "/sys/module/helloworld/parameters" dizinine geçip aşağıdaki komutları uygulayınız:

    $ echo 500 | sudo tee count
    $ echo "this is a new message" | sudo tee msg

    Modülü "rmmod" ile çekirdek alanından çıkarttıktan sonra yeniden "dmesg" yapınız. Artık modül içerisindeki parametrelerin
    aşağıdaki gibi değiştiğini göreceksiniz:

   [ 7668.582978] count = 500, msg=this is a new message
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
    printk(KERN_INFO "count = %d, msg=%s\n", count, msg);
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                130. Ders 24/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

//*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülene birden fazla değer de bir dizi gibi aktarılabilir. Bunun için module_param_array makrosu kullanılmaktadır. 
    module_param_array makrosu da şöyledir:

    module_param_array(name, type, nump, perm)

    Makronun birinci ve ikinci parametreleri yine değişken ismi ve türünü belirtir. Tabii buradaki değişken isminin bir dizi 
    ismi olarak, türün de bu dizinin eleman türü olarak girilmesi gerekmektedir. Üçüncü parametre toplam kaç değerin modüle dizi 
    biçiminde aktarıldığını belirten int bir nesnenin adresini (ismini değil) alır. Son parametre yine oluşturulacak dosyanın 
    erişim haklarını belirtmektedir. Örneğin:

    static int values[5];
    static int size;

    module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    module_param_array makrosuyla bir diziye değer aktarırken değerlerin virgüllerle ayrılmış bir biçimde girilmesi gerekmektedir.
    Örneğin:

    $ sudo insmod helloworld.ko values=1,2,3,4,5

    Burada eğer verilen değerler dizinin uzunluğundan fazla olursa zaten modül yüklemesi başarısız olmaktadır. Yani "insmod" 
    bir hata mesajı ile işlemini sonlandıracaktır. Tabii verilen değerlerin dizinin uzunluğundan daha az olabilir. Girilen değerlerin
    sayısı zaten örneğimizde size nesnesine yerleştirilecektir.

    Aşağıdaki örnekte üç parametre komut satırından çekirdek modülüne geçirilmiştir. Komut satırındaki isimlerle programın içerisindeki 
    değişken isimlerinin aynı olması gerektiğini anımsayınız. Dizi elemanlarını virgüllerle belirtirken yanlışlıkla virgüllerin 
    arasına boşluk karakterleri yerleştirmeyiniz. Programı şöyle make yapabilirsiniz:

    $ make file=helloworld

    Yüklemeyi şöyle yapabilirsiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\"" values=10,20,30,40,50
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";
static int values[5];
static int size;

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    int i;

    printk(KERN_INFO "Hello World...\n");

    printk(KERN_INFO "count = %d\n", count);
    printk(KERN_INFO "msg = %s\n", msg);
    printk(KERN_INFO "Values:\n");
    for (i = 0; i < size; ++i)
        printk(KERN_INFO "%d ", values[i]);
    printk(KERN_INFO "\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

/*--------------------------------------------------------------------------------------------------------------------------
    errno değişkeni aslında "libc" kütüphanesinin (libc standart C ve POSIX kütüphanesidir) içerisinde tanımlanmış bir değişkendir. 
    Çekirdek modunda yani çekirdeğin içerisinde errno isimli bir değişken yoktur. Bu nedenle çekirdekteki fonksiyonlar pek çok 
    POSIX fonksiyonunda olduğu gibi başarısızlık durumunda -1 ile geri dönüp errno değişkenini set etmezler. Çekirdek içerisindeki 
    fonksiyonlar başarısızlık durumunda negatif errno değeri ile geri dönerler. Örneğin "open" POSIX fonksiyonu "sys_open" isimli 
    çekirdek içerisinde bulunan sistem fonksiyonunu çağırdığında onun negatif bir değerle geri dönüp dönmediğine bakar. Eğer "sys_open" 
    fonksiyonu negatif değerle geri dönerse bu durumda bu değerin pozitiflisini errno değişkenine yerleştirip -1 ile geri dönmektedir. 
    Başka bir deyişle aslında bizim çağırdığımız int geri dönüş değerine sahip POSIX fonksiyonları sistem fonksiyonlarını çağırıp 
    o fonksiyonlar negatif bir değerle geri dönmüş ise bir hata oluştuğunu düşünerek o negatif değerin pozitiflisini errno değişkenine 
    yerleştirip -1 ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta bir kernel modül artık user mode'dan kullanılabilir hale getirildiyse buna "aygıt sürücü (device driver)" denilmektedir. 
    Aygıt sürücüler open fonksiyonuyla bir dosya gibi açılırlar. Bu açma işleminden bir dosya betimleyicisi elde edilir. Bu 
    dosya betimleyicisi read, write, lseek, close gibi fonksiyonlarda kullanılabilir. Aygıt sürücülere ilişkin dosya betimleyicileri
    bu fonksiyonlarla kullanıldığında aygıt sürücü içerisindeki belirlenen bazı fonksiyonlar çağrılmaktadır. Yani tersten gidersek 
    biz örneğin aygıt sürücümüze ilişkin dosya betimleyicisi ile read ve write fonksiyonlarını çağırdığımızda aslında aygıt 
    sürücümüzdeki belli fonksiyonlar çalıştırılmaktadır. Böylece aygıt sürücü ile user mode arasında veri transferleri yine 
    dosyalarda olduğu gibi dosya fonksiyonlarıyla yapılabilmektedir. Ayrıca user mode'dan aygıt sürücümüzdeki herhangi bir 
    fonksiyonu da çağırabiliriz. Bunun için ioctl isimli bir POSIX fonksiyonu (tabii bu POSIX fonksiyonu sys_ioctl isimli sistem 
    fonksiyonunu çağırmaktadır) kullanılmaktadır. Aygıt sürücü içerisinde fonksiyonlara birer kod numarası atanır. Sonra ioctl 
    fonksiyonunda bu kod numarası belirtilir. Böylece akış user mode'dan kernel mode'a geçerek belirlenen fonksiyonu kernel 
    mode'da çalıştıracaktır.

    Özetle bir aygıt sürücüsü kernel mode'da çalışmaktadır. Biz aygıt sürücüsünü open fonksiyonu ile açıp elde ettiğimiz betimleyici 
    ile read, write, lseek ve close fonksiyonlarını çağırdığımızda aygıt sürücü içerisindeki ilgili fonksiyon çalıştırılmaktadır. 
    Aygıt sürücüsü içerisindeki herhangi bir fonksiyon ise user mode'dan ioctl isimli fonksiyonla çalıştırılmaktadır. Tabii user 
    mode programlar aygıt sürücü içerisindeki kodları read, write, lseek, close, ioctl gibi fonksiyonlar yoluyla çalıştırdıklarında 
    proses user mode'dan geçici süre kernel mode'a geçer, ilgili kodlar kernel mode'da koruma engeline takılmadan çalıştırılır. 
    Fonksiyonların çalışması bittiğinde proses yine user mode'da döner.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda ele aldığımız konuyu şöyle özetleyebiliriz:

    1) Bir çekirdek fonksiyonu tamsayı türlerine ilişkin bir değere geri dönüyorsa geri dönüş değerinin negatif olması 
    fonksiyonun başarısız olduğunu gösterir. Bu negatif değerin pozitiflisi errno değerini vermektedir.

    2) Bir çekirdek fonksiyonu bir adrese geri dönüyorsa fonksiyonun başarısı verilen adresin değerine bağlıdır. Eğer verilen 
    adres çok bir büyük bir adresse fonksiyon başarısız olmuştur. Bu kontrol IS_ERR inline fonksiyonuyla yapılmaktadır.

    3) Adrese geri dönen çekirdek fonksiyonu eğer başarısızsa negatif errno değeri PTR_ERR inline fonksiyonuyla elde edilir.

    4) Biz negatif bir errno değerini bir adres gibi geri döndüreceksek bunun için ERR_PTR inline fonksiyonunu kullanmalıyız.

    5) Biz de çekirdek modüllerini ve aygıt sürücülerini yazarken çekirdekte uygulanan bu biçime (convention) uymalıyız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü yazarken o modül ile ilgili önemli bazı belirlemeler "modül makroları" denilen MODULE_XXX biçimindeki 
    makrolarla yapılmaktadır. Her ne kadar bu modül makrolarının bulundurulması zorunlu değilse de şiddetle tavsiye edilmektedir. 
    En önemli üç makronun tipik kullanımı şöyledir:

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("Kaan Aslan");
    MODULE_DESCRIPTION("General Character Device Driver");

    Modül lisansı herhangi bir açık kaynak kod lisansı olabilir. Tipik olarak "GPL" tercih edilmektedir. MODULE_AUTHOR makrosu 
    ile modülün yazarı belirtilir. MODULE_DESCRPTION modülün ne iş yapacağına yönelik kısa bir başlık yazısı içermektedir.

    Bu makrolar global alanda herhangi bir yere yerleştirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                131. Ders 29/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi kullanıcı modundaki programlar aygıt sürücülerle dosya sistemi yoluyla iletişim kurmaktadır. 
    Aygıt sürücüler sanki birer dosyaymış gibi açılırlar ve birer dosyaymış gibi işleme sokulurlar. Peki aygıt sürücüleri açmak 
    için yol ifadesi olarak (yani dosya ismi olarak) ne kullanılmaktadır? İşte aygıt sürücüler dosya sisteminde bir dizin girişiyle 
    temsil edilmektedir. O dizin girişi open fonksiyonuyla ile açıldığında aslında o dizin girişinin temsil ettiği aygıt sürücü 
    açılmış olur. Bu biçimdeki aygıt sürücüleri temsil eden dizin girişlerine "aygıt dosyaları (device files)" denilmektedir. 
    Aygıt dosyaları diskte bir dosya belirtmemektedir. Çekirdek içerisindeki aygıt sürücüyü temsil eden bir dizin girişi belirtmektedir. 
    Aygıt dosyalarının i-node tablosunda bir i-node elemanı vardır ancak bu i-node elemanı diskte bir yer değil çekirdekte bir 
    aygıt sürücü belirtmektedir.

    Peki bir aygıt dosyası nasıl yaratılmaktadır ve nasıl bir aygıt sürücüyü temsil eder hale getirilmektedir? İşte her aygıt 
    sürücünün majör ve minör numarası vardır. Bu majör ve minör numarayı aygıt sürücüye erişmek için kullanılan bir adres gibi 
    düşünebilirsiniz. Aynı zamanda aygıt dosyalarının da majör ve minör numaraları vardır. Bir aygıt sürücünün majör ve minör 
    numarası bir aygıt dosyasının majör ve minör numarasıyla aynıysa bu durumda o aygıt dosyası o aygıt sürücüyü temsil eder.
    Yani o aygıt dosyası açıldığında o aygıt sürücüyle iletişim kurulacaktır.

    Aygıt dosyaları özel dosyalardır. Bir dosyanın aygıt dosyası olup olmadığı "ls -l" komutunda dosya türü olarak 'c' (karakter 
    aygıt sürücüsü) ya da 'b' (blok aygıt sürücüsü) ile temsil edilmektedir. Anımsanacağı gibi dosya bilgileri stat, fstat, lstat 
    POSIX fonksiyonlarıyla elde ediliyordu. İşte struct stat yapısının dev_t türünden st_rdev elemanı eğer dosya bir aygıt dosyasıysa 
    dosyanın majör ve minör numaralarını belirtir. Biz de <sys/stat.h> dosyasındaki S_ISCHR ve S_ISBLK makrolarıyla ilgili dosyanın 
    bir aygıt dosyası olup olmadığını öğrenebiliriz.

    Yukarıda da belirttiğimiz gibi aygıt sürücüler "karakter aygıt sürücüleri (character device driver)" ve "blok aygıt sürücüleri
    (block device driver)" olmak üzere ikiye ayrılmaktadır. Karakter aygıt sürücüleri daha yaygın kullanılmaktadır. Biz kursumuzda
    önce karakter aygıt sürücülerini sonra blok aygıt sürücülerini ele alacağız. Blok aygıt sürücüleri tipik olarak disk gibi 
    medyalara erişmek amacıyla kullanılan aygıt sürücülerdir. Bunlar aktarım işlemini blok blok yaparlar. Bu işlemlerin daha 
    etkin gerçekleştirilmesi için çekirdeğin "buffer cache" (ya da yeni ismiyle "page cache") alt sistemleri devreye sokulmaktadır. 
    Karakter aygıt sürücüleri blok blok aktarım yapmayan aygıtlarla iletişim kuran aygıt sürücülerdir. Örneğin seri porttan bilgi 
    okuyan seri porta bilgi yazan aygıt sürücüler karakter aygıt sürücüleridir. Fakat RAM Disk oluşturan aygıt sürücüleri blok
    aygıt sürücüleridir. Karakter aygıt sürücülerinin yazımı blok aygıt sürücülerinden daha kolaydır.

    O halde şimdi bizim bir aygıt dosyasını nasıl oluşturacağımızı ve aygıt sürücüye nasıl majör ve minör numara atayacağımızı 
    bilmemiz gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt dosyaları mknod isimli POSIX fonksiyonuyla (bu fonksiyon Linux'ta doğrudan sys_node isimli sistem fonksiyonunu 
    çağırmaktadır) ya da komut satırından mknod komutuyla (bu komut da mknod fonksiyonu ile işlemini yapmaktadır) yaratılabilir. 
    mknod fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mknod(const char *pathname, mode_t mode, dev_t dev);

    Fonksiyonun birinci parametresi yaratılacak aygıt dosyasının yol ifadesini, ikinci parametresi erişim haklarını ve üçüncü 
    parametresi de aygıt dosyasının majör ve minör numaralarını belirtmektedir. Aygıt dosyasının majör ve minör numaraları dev_t 
    türünden tek bir değer ile belirtilmektedir. dev_t türü POSIX standartlarına göre herhangi bir tamsayı türü olabilmektedir. 
    Biz majör ve minör numaraları kullanııc modu programlarında makedev isimli makroyla oluştururuz. Bir dev_t türünden değerin 
    içerisinden major numarayı almak için major makrosu, minor numarayı almak için ise minor makrosu bulunmaktadır:

    #include <sys/sysmacros.h>

    dev_t makedev(unsigned int maj, unsigned int min);
    unsigned int major(dev_t dev);
    unsigned int minor(dev_t dev);

    Yani aslında majör ve minör numaralar dev_t türünden bir değerin belli bitlerinde bulunmaktadır. Ancak majör ve minör 
    numaraların dev_t türünden değerin hangi bitlerinde bulunduğu sistemden sisteme değişebileceği için bu makrolar kullanılmaktadır.

    Ancak çekirdek kodlamasında dev_t nesnesini oluşturmak için büyük harflerle isimlendirilmiş aşağıdaki makrolar kullanılmaktadır:

    #include <linux/fs.h>

    MKDEV(major, minor)
    MAJOR(dev)
    MINOR(dev)

    Linux'ta son versiyonlar da dikkate alındığında dev_t 32 bitlik işaretsiz bir tamsayı türündendir. Bu 32 bitin yüksek anlamlı 
    12 biti majör numarayı, düşük anlamlı 20 biti ise minör numarayı temsil etmektedir. Ancak programcı bu varsayımlarla 
    kodunu düzenlememeli yukarıda belirtilen makroları kullanmalıdır.

    mknod fonksiyonunun ikinci parametresindeki erişim haklarına aygıt dosyasının türünü belirten aşağıdaki sembolik sabitlerden 
    biri de bit OR operatörü ile eklenmelidir:

    S_IFCHR (Karakter Aygıt Sürücüsü)
    S_IFBLK (Blok Aygıt Sürücüsü)

    Aslında mknod fonksiyonu ile Linux sistemlerinde isimli boru dosyaları, UNIX domain soket dosyaları ve hatta normal dosyalar 
    da yaratılabilmektedir. Bu durumda fonksiyonun aygıt numarasını belirten üçüncü parametresi fonksiyon tarafından dikkate 
    alınmamaktadır. Bu özel dosyalar için erişim haklarına eklenecek makrolar da şunlardır:

    S_IFREG (Disk dosyası yaratmak için)
    S_IFIFO (İsimli boru dosyası yaratmak için)
    S_IFSOCK (UNIX domain soket dosyası yaratmak için)

    Aslında mknod fonksiyonu aygıt dosyaları yaratmak için kullanılıyor olsa da yukarıda belirttiğimiz özel dosyaları da 
    yaratabilmektedir. Tabii zaten isimli boru dosyasını yaratmak için mkfifo fonksiyonu, normal dosyaları yaratmak için 
    open fonksiyonu kullanılabilmektedir.

    mknod fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Ayrıca mknod POSIX fonksiyonunun mknodat isimli at'li bir versiyonu da bulunmaktadır:

    #include <fcntl.h>

    int mknodat(int fd, const char *path, mode_t mode, dev_t dev);

    Bu at'li versiyon daha önce görmüş olduğumuz at'li fonksiyonlar gibi çalışmaktadır. Yani fonksiyon ilgili dizine ilişkin 
    dosya betimleyicisini ve göreli yol ifadesini parametre olarak alır. O dizinden göreli biçimde yol ifadesini oluşturur. 
    Yine fonksiyonun birinci parametresine AT_FDCWD özel değeri geçilebilir. Bu durumda fonksiyon at'siz versiyondaki gibi 
    çalışır. Diğer at'li fonksiyonlarda olduğu gibi bu fonksiyonun da ikinci parametresindeki yol ifadesi mutlak ise birinci 
    parametresindeki dizin hiç kullanılmamaktadır.

    mknod ve mknodat fonksiyonları prosesin umask değerini dikkate almaktadır. Bu fonksiyonlarla aygıt dosyası yaratabilmek için
    (diğer özel dosyalar için gerekmemektedir) prosesin uygun önceliğe sahip olması gerekmektedir.

    Aşağıdaki aygıt dosyası yaratan mymknode isimli bir fonksiyon yazılmıştır. Fonksiyonun genel kullanımı şöyledir:

    ./mymknod [-m ya da --mode <erişim hakları>] <path> <c ya da b> <majör numara> <minör numara>

    Örnek bir çalıştırma şöyle olabilir:

    $ sudo ./mymknode -m 666 mydriver c 25 0

    Programı sudo ile çalıştırmayı unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* mymknod.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <getopt.h>
#include <sys/sysmacros.h>

bool ismode_correct(const char *mode);
void exit_sys(const char *msg);

int main(int argc, char *argv[])        /* ./mymknod [-m <mode>] <path> <type> <major> <minor> */
{
    int m_flag;
    int err_flag;
    char *m_arg;
    int result;
    int mode;
    dev_t dev;

    struct option options[] = {
        {"mode", required_argument, NULL, 'm'},
        {0, 0, 0, 0}
    };

    m_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt_long(argc, argv, "m:", options, NULL)) != -1) {
        switch (result) {
        case 'm':
            m_flag = 1;
            m_arg = optarg;
            break;
        case '?':
            if (optopt == 'm')
                fprintf(stderr, "option -m or --mode without argument!...\n");
            else if (optopt != 0)
                fprintf(stderr, "invalid option: -%c\n", optopt);
            else
                fprintf(stderr, "invalid long option!...\n");

            err_flag = 1;
            break;
        }
    }
    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (m_flag) {
        if (!ismode_correct(m_arg)) {
            fprintf(stderr, "incorrect mode argument!...\n");
            exit(EXIT_FAILURE);
        }
        sscanf(m_arg, "%o", &mode);
    }
    else
        mode = 0644;

    if (argv[optind + 1][1] != '\0') {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }
    if (argv[optind + 1][0] == 'c')
        mode |= S_IFCHR;
    else if (argv[optind + 1][0] == 'b')
        mode |= S_IFBLK;
    else {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }

    dev = makedev(atoi(argv[optind + 2]), atoi(argv[optind + 3]));

    umask(0);
    if (mknod(argv[optind + 0], mode, dev) == -1)
        exit_sys("mknod");

    return 0;
}

bool ismode_correct(const char *mode)
{
    if (strlen(mode) > 3)
        return false;

        while (*mode != '\0') {
        if (*mode < '0' || *mode > '7')
            return false;
        ++mode;
    }

    return true;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıda yazdığımız mymknod programının aynısı zaten mknod isimli kabuk komutu biçiminde bulunmaktadır. Bu komutun
    genel biçimi şöyledir:

    sudo mknod [-m ya da --mode <erişim hakları>] <dosya ismi> <c ya da b> <majör numara> <minör numara>

    Örneğin:

    $ sudo mknod devfile c 25 0

    mknod komutunu sudo ile çalıştırmayı unutmayınız. Yukarıdaki komut uygulandığında oluşturulan dosya şöyle olacaktır:

    crw-rw-rw- 1 root root 25, 0 Mar 29 22:05 mydriver
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünün karakter aygıt sürücüsü haline getirilebilmesi için öncelikle bir aygıt numarasıyla (majör ve minör 
    numara ile) temsil edilip çekirdeğe kaydettirilmesi (register ettirilmesi) gerekmektedir. Bu işlem tipik olarak 
    register_chrdev_region isimli çekirdek fonksiyonuyla yapılır. Fonksiyonun prototipi şöyledir:

    #include <linux/fs.h>

    int register_chrdev_region(dev_t from, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt sürücünün majör ve minör numaralarına ilişkin dev_t türünden değeri almaktadır. Bu 
    parametre için argüman genellikle MKDEV makrosuyla oluşturulmaktadır. MKDEV makrosu majör ve minör numarayı argüman olarak alıp 
    bunlardan dev_t türünden aygıt numarası oluşturmaktadır. Fonksiyonun ikinci parametresi ilk parametrede belirtilen minör numaradan 
    itibaren kaç minör numaranın kaydettirileceğini belirtmektedir. Örneğin biz majör = 20, minör = 0'dan itibaren 5 minör numarayı 
    kaydettirebiliriz. Fonksiyonun son parametresi proc ve sys dosya sistemlerinde görüntülenecek olan aygıt sürücünün ismini 
    belirtmektedir. Çekirdek modüllerinin isimleri çekirdek modül dosyasından gelmektedir. Ancak karakter aygıt sürücülerinin isimlerini 
    biz istediğimiz gibi verebiliriz. Tabii her aygıt sürücü bir çekirdek modülü biçiminde yazılmak zorundadır.

    register_chrdev_region fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. 
    Fonksiyon tipik olarak çekirdek modülünün "init" fonksiyonunda çağrılır. Eğer fonksiyon başarısız olursa init fonksiyonu da 
    bu fonksiyonun geri döndürdüğü değerle geri döndürülür. Örneğin:

    static int __init generic_init(void)
    {
        int result;

        printk(KERN_INFO "generic-char-driver module initialization...\n");

        if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
            printk(KERN_ERR "cannot register device!...\n");
            return result;
        }

        return 0;
    }

    Sistemde zaten yüklü olan aynı majör numaraya ilişkin bir aygıt sürücü varsa ya da fonksiyona girilen aygıt numarası geçersiz
    ise fonksiyon başarısız olabilir.

    register_chrdev_region fonksiyonu ile register ettirilmiş olan majör ve minör numaralar unregister_chrdev_region fonksiyonuyla 
    geri bırakılmalıdır. Aksi halde modül çekirdek alanından "rmmod" komutuyla atılsa bile bu aygıt numaraları tahsis edilmiş bir 
    biçimde kalmaya devam edecektir. Bu da önemli sorunlar doğurabilir. unregister_chrdev_region fonksiyonunun prototipi şöyledir:

    #include <linux/fs.h>

    void unregister_chrdev_region (dev_t from, unsigned count);

    Fonksiyonun birinci parametresi aygıt sürücünün register ettirilmiş olan majör ve minör numarasını, ikinci parametresi ise yine 
    o noktadan başlayan kaç minör numaranın unregister ettirileceğini belirtmektedir. Bu fonksiyon da tipik olarak aygıt sürücünün
    cleanup fonksiyonunda (exit fonksiyonunda) çağrılmalıdır. Örneğin:

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "generic-char-driver exit...\n");

        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
    }

    Bir aygıt sürücü register_chrdev_region fonksiyonuyla majör ve minör numarayı register ettirdiğinde artık "/proc/devices" 
    dosyasında bu aygıt sürücü için bir satır yaratılır. Aygıt sürücü unregister_chrdev_region fonksiyonuyla yok edildiğinde 
    "/proc/devices" dosyasındaki satır silinir. Örneğin aygıt sürücümüzü yükledikten sonra "/proc/devices" dosyasının içeriği 
    aşağıdakine benzer görüntülenecektir:

    Character devices:
    1 mem
    4 /dev/vc/0
    4 tty
    4 ttyS
    5 /dev/tty
    5 /dev/console
    5 /dev/ptmx
    5 ttyprintk
    6 lp
    7 vcs
    10 misc
    13 input
    14 sound/midi
    14 sound/dmmidi
    21 sg
    29 fb
    89 i2c
    99 ppdev
    108 ppp
    116 alsa
    128 ptm
    130 generic-char-driver
    136 pts
    ...

    Buradan da görüldüğü gibi aygıt sürücümüz "generic-char-driver" ismiyle 130 majör numaraya sahip olacak biçimde yüklenmiştir.

    Aşağıdaki örnekte çekirdek modülünün init fonksiyonunda register_chrdev_region fonksiyonu Majör = 139, Minor = 1 olacak 
    biçimde bir aygıt numarası çekirdeğe kaydettirilmiştir. Bu kayıt modülün exit fonksiyonunda unregister_chrdev_region fonksiyonu 
    ile silinmiştir. çekirdek modülünü aşağıdaki gibi derleyebilirsiniz:

    $ make file=generic-char-driver

    Modülü install ettikten sonra "/proc/modules" ve "/proc/devices" dosyalarına bakınız. "proc/devices" dosyasında aygıt
    sürücünün belirlediğimiz isimle ve majör numarayla kaydettirildiğini göreceksiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                132. Ders 05/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki aygıt sürücümüzü belli bir majör ve minör numarayla sisteme register ettirdikten sonra ne yapacağız? İşte aygıt 
    sürücüleri kabaca bir grup fonksiyondan oluşan modüller biçiminde düşünebiliriz. Aygıt sürücü içerisindeki fonksiyonlar 
    kullanıcı modunda bazı işlemler sonucunda çekirdek tarafından çağrılmaktadır. Örneğin:

    - Programcı aygıt sürücüye ilişkin aygıt dosyasını open fonksiyonu ile açtığı zaman aygıt sürücü içerisindeki "open" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile read işlemi yaptığında aygıt sürücü içerisindeki "read" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile write işlemi yaptığında aygıt sürücü içerisindeki "write" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile close işlemi yaptığında aygıt sürücü içerisindeki "close" 
    fonksiyonu çağrılır.

    Buradaki aygıt sürücü içerisindeki open, read, write, close fonksiyonlarına aygıt sürücüyü yazanlar istedikleri ismi verebilmektedir.
    Tabii yukarıda belirtmediğimiz ancak konular içerisinde göreceğimiz başka işlemler sonucunda yine aygıt sürücünün o işlemlere
    ilişkin fonksiyonları çağrılmaktadır. Aynı zamanda aygıt sürücüleri yazanlar dosya işlemleriyle doğrudan ilgili olmayan 
    aygıt sürücü fonksiyonlarına numaralar atayarak onların kullanıcı modundan ioctl isimli POSIX fonksiyonuyla (tabii bu POSIX 
    fonksiyonu da sys_ioctl isimli sistem fonksiyonunu çağırmaktadır) çağrılmasını sağlayabilmektedir. Tabii şüphesiz aygıt sürücü 
    içerisindeki bu fonksiyonlar çekirdek modunda çalıştırılmaktadır. Zaten aygıt sürücü yazmanın ana nedenlerinden biri kullanıcı
    modunda yapılamayan işlemlerin çekirdek modunda yapılmasını sağlamak içindir.

    Ancak aygıt sürücüleri yalnızca kullanıcı modundan çekirdek modunda çalışacak fonksiyon çağırma mekanizması olarak düşünmemek 
    gerekir. Aygıt sürücüler birtakım kesmelere o anda yanıt verebilmektedir. Dolayısıyla aynı zamanda onları çekirdek modunda 
    çalışan birer program gibi de düşünebiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülü bir aygıt numarasıyla ilişkilendirdikten sonra artık ona gerçek anlamda bir karakter aygıt sürücü kimliğinin 
    kazandırılması gerekir. Bu işlem struct cdev isimli bir yapının içinin doldurularak sisteme eklenmesi (yerleştirilmesi) 
    ile yapılmaktadır. Linux çekirdeği tüm çekirdek modüllerini ve aygıt sürücülerini çeşitli veri yapılarıyla tutmaktadır. 
    Aygıt sürücü yazan programcılar çekirdeğin bu organizasyonunu bilmek zorunda değillerdir. Ancak bazı işlemleri tam gerektiği 
    gibi yapmak zorundadırlar. (Linux çekirdeğinin aygıt sürücü mimarisi oldukça karmaşıktır. Bu konu "Linux Kernel" kursunda ele 
    alınmaktadır.)

    cdev aşağıdaki gibi bir yapıdır:

    #include <linux/fs.h>

    struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;
        struct list_head list;
        dev_t dev;
        unsigned int count;
    };

    Bu türden bir yapı nesnesi programcı tarafından global olarak (statik ömürlü olarak) tanımlanabilir ya da alloc_cdev isimli 
    çekirdek fonksiyonuyla çekirdeğin heap sistemi (slab allocator) kullanılarak dinamik bir biçimde tahsis edilebilir. (İşletim 
    sistemlerinin çekirdeklerinin ayrı bir heap sistemi vardır. Linux çekirdeğinde spesifik türden nesnelerin hızlı tahsis edilmesi 
    için "slab allocator" denilen bir heap sistemi kullanılmaktadır.) Bu yapı nesnesini yerel bir nesne biçiminde oluşturmayınız. 
    Çünkü yerel değişkenler fonksiyon sonlandığında yok edilirler. Halbuki bu yapı nesnesinin aygıt sürücü yüklü olduğu sürece 
    bellekte bulunuyor olması gerekir.

    Eğer cdev türünden bu yapı nesnesi programcı tarafından global bir biçimde tanımlanacaksa yapının elemanlarına ilk değer 
    vermek için cdev_init fonksiyonu çağrılmalıdır. Eğer cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde tahsis edilecekse 
    artık yapı elemanlarına ilkdeğerlerin verilmesi işlemi cdev_init fonksiyonuyla yapılmaz. Çünkü zaten cdev_alloc bu işlemi 
    kendi içerisinde yapmaktadır. Fakat yine de programcının bu durumda manuel olarak yapının bazı elemanlarına değer ataması 
    da gerekmektedir. Bu iki yoldan biriyle oluşturulmuş olan cdev yapı nesnesi cdev_add isimli fonksiyonla çekirdeğin veri 
    yapılarına yerleştirilmelidir. Tabii aygıt sürücü boşaltılırken bu yerleştirme işlemi cdev_del fonksiyonuyla geri alınmalıdır. 
    cdev_del fonksiyonu, struct cdev yapısı cdev_alloc ile tahsis edilmişse aynı zamanda onu free hale de getirmektedir. Özetle 
    çekirdek modülümüzün tam bir karakter aygıt sürücüsü haline getirilmesi için şunlar yapılmalıdır:

    1) struct cdev isimli bir yapı türünden nesne global olarak (statik ömürlü olarak) tanımlanmalı ya da cdev_alloc fonksiyonu 
    ile çekirdeğin heap sistemi içerisinde tahsis edilmelidir. Eğer bu nesne global olarak tanımlanacaksa nesneye cdev_init 
    fonksiyonu ile ilkdeğerleri verilmelidir. Eğer nesne cdev_alloc fonksiyonu ile çekirdeğin heap alanında tahsis edilecekse 
    bu durumda ilkdeğer verme işlemi bu fonksiyon tarafından yapılmaktadır. Ancak programcının yine yapının bazı elemanlarını 
    manuel olarak doldurması gerekmektedir.

    2) Oluşturulan bu struct cdev nesnesi cdev_add çekirdek fonksiyonu ile çekirdeğe eklenmelidir.

    3) Çekirdek modülü çekirdek alanından atılırken modülün exit fonksiyonunda cdev_add işleminin geri alınması için cdev_del 
    fonksiyonunun çağrılması gerekmektedir.

    cdev_init fonksiyonunun parametrik yapısı şöyledir:

    #include <linux/cdev.h>

    void cdev_init(struct cdev *cdev, const struct file_operations *fops);

    Fonksiyonun birinci parametresi ilk değer verilecek global cdev nesnesinin adresini alır. İkinci parametre ise file_operations 
    türünden bir yapı nesnesinin adresi almaktadır. file_operations isimli yapı birtakım fonksiyon adreslerinden oluşmaktadır. 
    Yani yapının tüm elemanları birer fonksiyon göstericisidir. Bu yapı kullanıcı modundaki program tarafından ilgili aygıt 
    dosyası açılıp çeşitli işlemler yapıldığında çağrılacak fonksiyonların adreslerini tutmaktadır. Örneğin kullanıcı modundaki 
    program open, close, read, write yaptığında çağrılacak fonksiyonlarımızı burada belirtiriz. file_operations büyük bir yapıdır:

    struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out,
                    loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
    };

    Bu yapının yalnızca bazı elemanlarına atama yapabiliriz. Bunun için gcc eklentilerinden faydalanılabilir. (Bu eklentiler 
    C99 ile birlikte C'ye eklenmiştir.) Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp);
    static int generic_release(struct inode *inodep, struct file *filp);

    struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release
    };

    Yapının owner elemanına THIS_MODULE makrosunun atanması iyi bir tekniktir. Biz burada "aygıt sürücümüz open fonksiyonuyla 
    açıldığında generic_open isimli fonksiyon çağrılsın", aygıt sürücümüz close fonksiyonu ile kapatıldığında "generic_release 
    isimli fonksiyonumuz çağrılsın" demiş olmaktayız.

    Yukarıda da belirttiğimiz gibi cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde de tahsis edilebilir. cdev_alloc 
    fonksiyonunun prototipi şöyledir:

    #include <linux/cdev.h>

    struct cdev *cdev_alloc(void);

    Fonksiyon başarı durumunda cdev yapısının adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Yukarıda da belirttiğimiz
    gibi cdev yapısı cdev_alloc fonksiyonu ile tahsis edilmişse cdev_init yapılmasına gerek yoktur. Ancak bu durumda programcının 
    manuel olarak yapının owner ve ops elemanlarına değer ataması gerekir. Örneğin:

    struct cdev *g_cdev;
    ...
    if ((gcdev = cdev_alloc()) == NULL) {
        printk(KERN_ERROR "cannot allocate cdev!...\n");
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    cdev_alloc fonksiyonu başarısız olduğunda bunu çağıran fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygun olur. ENOMEM 
    errno değeri bellek yetersizliği nedeniyle başarısızlık oluştuğunu belirtmektedir. cdev yapı nesnesi başarılı bir biçimde 
    oluşturulduktan sonra artık bu yapının çekirdek modülü içerisine yerleştirilmesi gerekir. Bu da cdev_add fonksiyonuyla 
    yapılmaktadır. cdev_add fonksiyonunun prototipi de şöyledir:

    #include <linux/cdev.h>

    int cdev_add(struct cdev *devp, dev_t dev, unsigned count);

    Fonksiyonun birinci parametresi cdev türünden yapı nesnesinin adresini almaktadır. Fonksiyonun ikinci parametresi aygıt sürücünün 
    majör ve minör numaralarını, üçüncü parametresi ise ilgili minör numaradan itibaren kaç minör numaranın kullanılacağı belirtmektedir.
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        ...
        return result;
    }

    Aygıt sürücü boşaltılırken cdev_add ile yapılan işlemin geri alınması gerekir. Bu da cdev_del fonksiyonuyla yapılmaktadır. 
    (cdev_alloc işlemi için bunu free hale getiren ayrı bir fonksiyon yoktur. cdev_alloc ile tahsis edilen alan cdev_del fonksiyonu 
    tarafından otomatik olarak free hale getirilmektedir.)

    #include <linux/cdev.h>

    void cdev_del(struct cdev *devp);

    Fonksiyon parametre olarak cdev yapısının adresini almaktadır.

    Buradaki önemli bir nokta şudur: cdev_add fonksiyonu cdev nesnesinin içini çekirdekteki uygun veri yapısına kopyalamamaktadır. 
    Bizzat bu nesnenin adresini kullanmaktadır. Yani çekirdek modülü var olduğu sürece bu cdev nesnesinin de yaşıyor olması gerekir.
    Bu da cdev nesnesinin ve file_operations nesnesinin global biçimde (ya da statik ömürlü biçimde) tanımlanmasını gerektirmektedir.

    Aşağıda bu işlemlerin yapıldığı örnek bir karakter aygıt sürücüsü verilmiştir. Bu aygıt sürücü majör=130, minör=0 aygıtını 
    kullanmaktadır. Dolayısıyla aşağıdaki programın testi için şöyle bir aygıt dosyasının yaratılmış olması gerekir. Yaratımı
    aşağıdaki gibi yapabilirsiniz:

    $ sudo mknod mydriver -m 666 c 130 0

    Bu aygıt sürücü insmod ile yüklendiğinde artık biz kullanıcı modunda "mydriver" dosyasını açıp kapattığımızda file_operations
    yapısına yerleştirdiğimiz generic_open ve generic_release fonksiyonları çağrılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda biz cdev nesnesini global olarak tanımladık. Aşağıda ise cdev nesnesinin cdev_alloc fonksiyonu ile 
    dinamik biçimde tahsis edilmesine bir örnek veriyoruz. cdev_alloc fonksiyonu ile tahsis edilmiş alanların zaten cdev_del 
    fonksiyonu ile geri bırakıldığını belirtmiştik. Ancak cdev_add fonksiyonu başarısız olursa cdev_del fonksiyonunun çağrılması
    anlamsız olacağı için cdev_alloc fonksiyonu ile tahsis edilmiş olan alan kfree fonksiyonuyla serbest bırakılmıştır. kfree
    fonksiyonu çekirdek heap sistemine ilişkin genel bir bir fonksiyondur. Çekirdek heap sistemine "dilimli tahsisat sistemi 
    (slab allocator)" denilmektedir. Bu konu ileride ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev *g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_ERR "cannot allocate cdev!...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device..\n");
        kfree(g_cdev);
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                133. Ders 07/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek kodlarının ve aygıt sürücü kodlarının çekirdek modunda (kernel mode) çalıştığını belirtmiştik. Çekirdeğin bulunduğu
    bellek alanı ile kullanıcı proseslerinin bulunduğu bellek alanı birbirlerinden izole edilmiştir. Daha önceden de belirttiğimiz 
    gibi kullanıcı modunda çalışan prosesler çekirdek alanına erişemezler. Çünkü çekirdek kendisini sayfa tabanlı koruma mekanizması 
    yoluyla sıradan proseslerden korumaktadır. Fakat bazı durumlarda çekirdek alanı alanı kullanıcı proseslerinin bulunduğu kullanıcı 
    alanı arasında veri transferlerinin yapılması gerekebilmektedir. Örneğin sys_read sistem fonksiyonu çekirdek tarafından okunan 
    bilgileri kendisini çağıran prosesin kullanıcı alanına aktarmaktadır. sys_write fonksiyonu ise bunun tersini yapmaktadır.

    Çekirdek alanı ile kullanıcı alanı arasında memcpy fonksiyonu ile transfer yapmaya çalışmak uygun değildir. Bunun birkaç 
    nedeni vardır. Bu tür transferlerde çekirdek modunda çalışan kodların kullanıcı alanındaki adresin geçerliliğini kontrol 
    etmesi gerekir. Aksi takdirde çekirdek modunda geçersiz bir alana kopyalama yapmak sistemin çökmesine yol açabilmektedir. 
    Örneğin biz sys_read sistem fonksiyonu ile dosyadan belirttiğimiz adrese aktarım yapmak isteyelim. Eğer biz kendi prosesimize 
    ilişkin bir adres vermek yerine çekirdeğin çalıştığı alana ilişkin bir adres verirsek tüm sistem çökebilir. İşte sys_read 
    fonksiyonu aktarımı yapmadan önce verilen adresin gerçekten prosesin adres alanı içerisindeki bir adres olup olmadığını 
    kontrol etmektedir. Ayrıca kullanıcı alanına ilişkin prosesin sayfa tablosunun bazı bölümleri o anda RAM'de olmayabilir 
    (yani swap out yapılmış olabilir). Böyle bir durumda işleme devam etmek çekirdek tasarımı bakımından sorun oluşturmaktadır. 
    Eğer böyle bir durum varsa çekirdek kodlarının önce sayfa tablosunu RAM'e geri yükleyip işlemine devam etmesi gerekmektedir.

    İşte yukarıda açıklanan bazı nedenlerden dolayı çekirdek alanı ile kullanıcı alanı arasında aktarım işlemi için özel çekirdek 
    fonksiyonları kullanılmaktadır. Yani biz kullanıcı modunda çalışan programlar ile çekirdek modülümüz arasında aktarımları 
    özel bazı çekirdek fonksiyonlarıyla yapmalıyız. Bu amaçla kullanılan çeşitli çekirdek fonksiyonları ve makroları bulunmaktadır. 
    En temel iki fonksiyon copy_to_user ve copy_from_user fonksiyonlarıdır. Bu fonksiyonların prototipleri şöyledir:

    #include <linux/uaccess.h>

    unsigned long copy_to_user(void *to, const void *from, unsigned len);
    unsigned long copy_from_user(void *to, const void *from, unsigned len);

    Fonksiyonların birinci parametreleri kopyalamanın yapılacağı hedef adresi belirtmektedir. Yani copy_to_user için birinci 
    parametre user alanındaki adres, copy_from_user için birinci parametre çekirdek alanındaki adrestir. İkinci parametre kaynak 
    adresi belirtmektedir. Bu kaynak adres copy_to_user için çekirdek alanındaki adres, copy_from_user için kullanıcı alanındaki 
    adrestir. Son parametre aktarılacak byte sayısını belirtmektedir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık 
    durumunda aktarılamayan byte sayısına geri dönerler. Çekirdek mod programcılarının bu fonksiyonlar başarısız olursa kendi
    fonksiyonlarını -EFAULT (Bad address) ile geri döndürmesi uygun olur. (Örneğin sys_read ve sys_write fonksiyonlarına 
    biz geçersiz bir user mode adresi verirsek bu sistem fonksiyonları da -EFAULT değeri ile geri dönmektedir. Bu hata kodunun 
    yazısal karşılığı "Bad address" biçimindedir.) Örneğin:

    if (copy_to_user(...) != 0)
        return -EFAULT;

    Bazen kullanıcı alanındaki adresin geçerliliği zaten daha önceden sınanmıştır. Bu durumda yeniden geçerlilik sınaması yapmadan 
    yukarıdaki işlemleri yapan __copy_to_user ve __copy_from_user fonksiyonları kullanılabilir. Bu fonksiyonların parametrik 
    yapıları copy_to_user ve copy_from_user fonksiyonları ile aynıdır. Aralarındaki tek fark ise bu fonksiyonların adres geçerliliğine 
    ilişkin sınama yapmamalarıdır:

    #include <linux/uaccess.h>

    unsigned long __copy_to_user(void *to, const void *from, unsigned len);
    unsigned long __copy_from_user(void *to, const void *from, unsigned len);

    Bazı durumlarda programcı 1 byte, 2 byte, 4 byte, 8 byte'lık verileri transfer etmek isteyebilir. Bu küçük miktardaki verilerin 
    transfer edilmesi için daha hızlı çalışan özel iki makro bulundurulmuştur: put_user ve get_user. Bu makroların parametrik 
    yapısı şöyledir:

    #include <linux/uaccess.h>

    put_user(x, ptr);
    get_user(x, ptr);

    Burada x aktarılacak nesneyi belirtir. (Bu nesnenin adresini programcı almaz, makro içinde bu işlem yapılmaktadır.) ptr 
    ise aktarım adresini belirtmektedir. Aktarım ikinci parametrede belirtilen adresin türünün uzunluğu kadar yapılmaktadır. 
    Başka bir deyişle biz makroya hangi türden nesne verirsek zaten makro o uzunlukta aktarım yapmaktadır.

    Makrolar başarı durumunda 0, başarısızlık durumunda negatif hata koduna geri dönerler. Kullanımları şöyle olabilir:

    if (put_user(...) != 0)
        return -EFAULT;

    Bu makroların da geçerlilik kontrolü yapmayan __put_user ve __get_user isimli versiyonları vardır:

    #include <linux/uaccess.h>

    __put_user(x, ptr);
    __get_user(x, ptr);

    Örneğin biz çekirdek modülümüzdeki 4 byte'lık int bir x nesnesinin içerisindeki bilgiyi puser ile temsil edilen kullanıcı 
    alanındaki adrese kopyalamak isteyelim. Bu işlemi şöyle yaparız:

    int x;
    int *puser;
    ...
    if (put_user(x, puser) != 0)
        return -EFAULT;

    Nihayet kullanıcı alanındaki adresin geçerliliği de access_ok isimli makroyla sorgulanabilmektedir. Makro şöyledir:

    #include <linux/uaccess.h>

    access_ok(type, addr, size);

    Buradaki type sınama geçerliliğinin türünü belirtmektedir. Okuma geçerliliği için bu parametre VERIFY_READ, yazma geçerliliği 
    için VERIFY_WRITE ve hem okuma hem de yazma geçerliliği için VERIFY_READ|VERIFY_WRITE biçiminde girilmelidir. İkinci 
    parametre geçerliliği sınanacak adresi ve üçüncü parametre de o adresten başlayan alanın uzunluğunu belirtmektedir. 
    Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri dönmektedir. Örneğin biz 
    kullanıcı alanında puser adresiyle başlayan 100 byte'lık alanın yazma bakımından geçerli bir alan olup olmadığını sınamak 
    isteyelim. Bu sınamayı çekirdek modülümüzde şöyle yapabiliriz:

    if (access_ok(VERIFY_WRITE, puser, 100)) {        // adres geçerli
        ...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar aygıt dosyası open ile açıldığında ve close ile kapatıldığında aygıt sürücümüz içerisindeki fopen ve release 
    fonksiyonlarımızın çağrılmasını sağladık. Şimdi de aygıt dosyası üzerinde read ve write fonksiyonları uygulandığında aygıt 
    sürücümüzdeki read ve write fonksiyonlarının çağrılması üzerinde duracağız.

    Aygıt dosyası open POSIX ile açılıp read POSIX fonksiyonu ile okunduğunda aygıt sürücümüz içerisinde belirlediğimiz "read" 
    fonksiyonumuz, write POSIX fonksiyonu çağrıldığında da aygıt sürücümüz içerisinde belirlediğimiz write fonksiyonumuz çağrılmaktadır. 
    Bunu sağlamak için file_operations yapısının read ve write elemanlarına çağrılacak fonksiyonların adreslerini girmeliyiz. 
    Karakter aygıt sürücülerinin read ve write fonksiyonlarının prototipleri aşağıdaki gibi olmak zorundadır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

    Aygıt sürücüsü için read ve write fonksiyonları yukarıdaki prototipe uygun bir biçimde tanımlandıktan sonra bunların adresleri 
    aşağıdaki gibi file_operations türünden yapı nesnesinin read ve write elemanlarına atanmalıdır:

    static struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release,
        .read = generic_read,
        .write = generic_write,
    };

    Artık aygıt dosyası üzerinde read POSIX fonksiyonu çağrıldığında aygıt sürücümüzdeki generic_read fonksiyonu, write POSIX 
    fonksiyonu çağrıldığında da aygıt sürücümüzdeki generic_write POSIX fonksiyonu çağrılacaktır.

    Aygıt sürücümüzdeki read ve write fonksiyonlarının birinci parametresi açılmış dosyaya ilişkin struct file nesnesinin adresini 
    belirtir. Bu nesneye "dosya nesnesi (file object)" de denilmektedir.

    Anımsanacağı gibi bir dosya açıldığında çekirdek sys_open fonksiyonunda bir dosya nesnesi (struct file) tahsis edip bu dosya 
    nesnesinin adresini dosya betimleyici tablosundaki bir slota yerleştirip onun indeksini dosya betimleyicisi olarak geri 
    döndürüyordu. İşte bu read ve write fonksiyonlarının birinci parametreleri bu dosya nesnesinin adresini belirtmektedir. 
    Çekirdek açık dosya ilgili her türlü işlemi bu dosya nesnesindeki bilgilerden hareketle yapmaktadır.

    Dosya Betimleyici Tablosu

    0   ---------> Dosya Nesnesi
    1   ---------> Dosya Nesnesi
    2   ---------> Dosya Nesnesi
    3   ---------> Dosya Nesnesi
    4   ---------> Dosya Nesnesi
    5   ---------> Dosya Nesnesi
    ...

    Daha önceden de belirttiğimiz gibi file yapısı içerisinde dosya göstericisinin konumu, dosyanın erişim hakları, referans sayacının 
    değeri, dosyanın açış modu ve açış bayrakları ve başka birtakım bilgiler bulunmaktadır. Linux çekirdeğinin 2.4.30'daki 
    sürümündeki file yapısı şöyledir:

    struct file {
        struct list_head        f_list;
        struct dentry            *f_dentry;
        struct vfsmount            *f_vfsmnt;
        struct file_operations    *f_op;
        atomic_t                f_count;
        unsigned int            f_flags;
        mode_t                    f_mode;
        loff_t                    f_pos;
        unsigned long            f_reada, f_ramax, f_raend, f_ralen, f_rawin;
        struct fown_struct        f_owner;
        unsigned int            f_uid, f_gid;
        int                        f_error;

        size_t                    f_maxcount;
        unsigned long            f_version;

        // needed for tty driver, and maybe others
        void                    *private_data;

        // preallocated helper kiobuf to speedup O_DIRECT
        struct kiobuf            *f_iobuf;
        long                    f_iobuf_lock;
    };

    Biz burada bilerek sadelik sağlamak için eski bir çekirdeğin file yapısını verdik. Yeni çekirdeklerde buna birkaç eleman daha 
    eklenmiştir. Ancak temel elemanlar yine aynıdır. Biz aygıt sürücümüzün read ve write fonksiyonlarında söz konusu aygıt 
    dosyasının birtakım özelliklerine erişmek istediğimizde bu yapıyı kullanırız.

    Aygıt sürücüdeki read ve write fonksiyonlarının ikinci parametresi kullanıcı alanındaki transfer adresini belirtir. Kullanıcı 
    modunda read POSIX fonksiyonu çağrıldığında aygıt sürücüdeki read fonksiyonunun copy_to_user gibi bir fonksiyonla bu adrese
    transfer yapması gerekir. Benzer biçimde kullanıcı modunda write POSIX fonksiyonu çağrıldığında da aygıt sürücü içerisindeki 
    write fonksiyonunun kullanıcı modundaki bu adresten copy_from_user gibi bir fonksiyonla transfer yapması gerekir. Aygıt 
    sürücüdeki read ve write fonksiyonlarının üçüncü parametreleri okunacak ya da yazılacak byte miktarını belirtmektedir. Son 
    parametre ise dosya göstericisinin konumunu belirtir. Ancak bu parametre file yapısı içerisindeki f_pos elemanının adresi 
    değildir. Çekirdek tarafından aygıt sürücünün read ve write fonksiyonları çağrılmadan önce file yapısı içerisindeki f_pos 
    elemanının değeri başka bir nesneye atanıp o nesnenin adresi read ve write fonksiyonlarına geçirilmektedir. read ve write 
    fonksiyonları sonlandığında çekirdek adresini geçirdiği nesnenin değerini file yapısının f_pos elemanına kendisi yerleştirmektedir.
    Yani aygıt sürücümüzdeki read ve write fonksiyonları içerisinde biz her zaman dosya göstericisinin konumunu bu parametrenin
    gösterdiği nesneden alıp bu parametrenin gösterdiği yerdeki nesneyi güncellemeliyiz.

    Aygıt sürücü içerisindeki read ve write fonksiyonları başarı durumunda transfer edilen byte sayısına, başarısızlık durumunda 
    negatif errno değerine geri dönmelidir.

    Biz aygıt sürücümüz için read ve write fonksiyonlarını yazarken read ve write fonksiyonları içerisinde transfer edilen byte 
    miktarı kadar dosya göstericisini ilerletmemiz gerekir. Bu işlem yukarıda da belirttiğimiz gibi fonksiyonların son parametresi 
    olan off göstericisinin gösterdiği yerin güncellenmesi ile yapılmalıdır. Örneğin n byte transfer edilmiş olsun. Bu durumda 
    dosya göstericisinin konumu aşağıdaki gibi güncellenebilir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        ...
        *off += n;
        ...

        return n;
    }

    Yukarıda da belirttiğimiz gibi aygıt sürücünüzün read ve write fonksiyonlarında dosya göstericisini konumlandırmak için 
    file yapısının f_pos elemanını güncellemeyiniz. Dosya göstericisinin konumlandırılması her zaman read ve write fonksiyonlarının 
    son parametresi yoluyla yapılmaktadır. Çekirdeğin dosya göstericisini nasıl güncellediğine ilişkin aşağıdaki gibi bir 
    temsili kod örneği verebiliriz:

    loff_t off;
    ...
    off = filp->f_pos;
    read(filp, buf, size, &off);
    filp->f_pos = off;

    Aşağıda aygıt sürücüye read ve write fonksiyonları içi boş bir biçimde yerleştirilmiştir. Kullanıcı mode'undan read ve 
    write yapıldığında aygıt sürücümüzün içerisindeki bu fonksiyonların çalıştığını gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        25
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver module initialization...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_read called...\n");

    return size;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[100];

    if ((fd = open("mydriver", O_RDWR)) == -1)
        exit_sys("open");

    read(fd, buf, 100);
    write(fd, buf, 100);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                134. Ders 19/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücümüzün read fonksiyonunun gerçekten bir dosyadan okuma yapıyormuş gibi davranmasını sağlayalım. Bunun 
    için dosyamızı temsil eden aşağıdaki gibi global bir dizi kullanacağız:

    static char g_file_buf[] = "01234567890ABCDEFGH";

    Buradaki diziyi sanki bir dosya gibi ele alacağız. Aygıt sürücümüzün read fonksiyonu aşağıdaki gibi olacaktır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;
        size_t slen;

        slen = strlen(g_buf);
        esize = *off + size > slen ? slen - *off : size;

        if (copy_to_user(buf, g_buf + *off, esize) != 0)
            return -EFAULT;

        *off += esize;

        return esize;
    }

    Burada önce dosya göstericisinin gösterdiği yerden itibaren "size" kadar byte'ın gerçekten dizi içerisinde olup olmadığına 
    bakılmıştır. Eğer "*off + size" değeri bu dizinin uzunluğundan fazlaysa "size" kadar değer değil, "slen - *off" kadar değer 
    okunmuştur. Aygıt sürücülerin read ve write fonksiyonlarında dosya göstericisinin ilerletilmesi programcının sorumluluğundadır.
    Bu nedenle okuma işlemi yapıldığında dosya göstericisinin konumu aşağıdaki gibi artırılmıştır:

    *off += esize;

    read fonksiyonunun okunabilen byte sayısına geri döndürüldüğüne dikkat ediniz. copy_to_user fonksiyonu ile tüm byte'lar
    kullanıcı alanına kopyalanamamışsa fonksiyon -EFAULT değeri ile geri döndürülmüştür.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[] = "01234567890ABCDEFGH";

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;
    size_t slen;

    slen = strlen(g_file_buf);
    esize = size > slen - *off ? slen - *off : size;

    if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
        return -EFAULT;

    *off += esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
    exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü için write fonksiyonu da tamamen read fonksiyonuna benzer biçimde yazılmaktadır. write fonksiyonu içerisinde
    biz kullanıcı modundaki bilgiyi copy_from_user ya da get_user fonksiyonlarıyla alırız. Yine write fonksiyonu da istenilen 
    kadar byte'ın transfer edilememesi durumunda -EFAULT değeri ile, başarılı sonlanmada ise yazılan (çekirdek alanına yazılan) 
    byte miktarı ile geri dönmelidir.

    Aşağıdaki örnekte aygıt sürücü bellekte oluşturulmuş bir dosya gibi davranmaktadır. Aygıt sürücünün taklit ettiği dosya
    en fazla 4096 byte olabilmektedir:

    #define FILE_BUF_SIZE        4096
    ...
    static char g_file_buf[FILE_BUF_SIZE];

    Ancak buradaki FILE_BUF_SIZE bellek dosyasının maksimum uzunluğunu belirtmektedir. Bellek dosyasının gerçek uzunluğu 
    g_fsize nesnesinde tutulmaktadır. Aygıt sürücünün write fonksiyonu aşağıdaki gibi yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

        if (esize > 0) {
            if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
                return -EFAULT;
            *off += esize;

            if (*off > g_fsize)
                g_fsize = *off;
        }

        return esize;
    }

    Burada yine dosya göstericisinin gösterdiği yerden itibaren yazılmak istenen byte sayısı FILE_BUF_SIZE değerini aşıyorsa 
    geri kalan miktar kadar yazma yapılmıştır. Dosya göstericisinin yine ilerletildiğine dikkat ediniz. Dosya göstericisinin 
    ilerletilmesi her zaman programcının sorumluluğundadır. Aygıt sürücümüzün read fonksiyonu da şöyledir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > g_fsize - *off ? g_fsize - *off : size;

        if (esize > 0) {
            if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
                return -EFAULT;
            *off += esize;
        }

        return esize;
    }

    Burada da dosya göstericisinin gösterdiği yerden itibaren okunmak istenen byte sayısının g_fsize değerinden büyük olup 
    olmadığına bakılmıştır. Yine dosya göstericisi fonksiyon tarafından güncellenmiştir.

    Programın testi için önce aygıt sürücüye aşağıdaki gibi birtakım byte'ları aktarabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Burada -n parametresi '\n' karakterinin dosyaya yazılmasını engellemektedir. Bundan sonra artık yukarıdaki "app.c" programı
    ile testi yapabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundan aygıt dosyası betimleyicisi ile lseek POSIX fonksiyonu çağrıldığında (bu fonksiyon da sys_lseek sistem 
    fonksiyonunu çağırmaktadır) karakter aygıt sürücüsünün file_operations yapısı içerisine yerleştirilen llseek fonksiyonu 
    çağrılmaktadır. llseek fonksiyonunun parametrik yapısı şöyledir:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

    Fonksiyonun birinci parametresi dosya nesnesini, ikinci parametresi konumlandırılmak istenen offset'i, üçüncü parametresi 
    ise konumlandırmanın nereye göre yapılacağını belirtmektedir. Bu fonksiyonu gerçekleştirirken programcı file yapısı 
    içerisindeki f_pos elemanını güncellemelidir. whence parametresi lseek fonksiyonundaki (ya da C'nin fseek fonksiyonundaki)
    orijini belirten parametreyle aynı anlamdadır. Tipik olarak programcı whence parametresini switch içerisine alır. Hedeflenen 
    offset'i hesaplar ve en sonunda file yapısının f_pos elemanına bu hedeflenen offset'i yerleştirir. Hedeflenen offset uygun 
    değilse fonksiyon tipik olarak -EINVAL değeriyle geri döndürülür. Eğer konumlandırma offset'i başarılı ise fonksiyon 
    dosya göstericisinin yeni değerine geri dönmelidir.

    Aşağıda daha önce yapmış olduğumuz bellek dosyası örneğine llseek fonksiyonu da eklenmiştir. Fonksiyon aşağıdaki gibi 
    yazılmıştır:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
    {
        loff_t newpos;

        switch (whence) {
            case 0:
                newpos = off;
                break;
            case 1:
                newpos = filp->f_pos + off;
                break;
            case 2:
                newpos = g_fmem_size + off;
                break;
            default:
                return -EINVAL;
        }

        if (newpos < 0 || newpos > g_fmem_size)
            return -EINVAL;

        filp->f_pos = newpos;

        return newpos;
    }

    Burada önce whence parametresine bakılarak dosya göstericisinin konumlandırılacağı offset belirlenmiştir. Sonra dosya 
    nesnesinin f_pos elemanı güncellenmiştir. Çekirdek kodlarında da kullanıcı modunda kullandığımız SEEK_SET (0), SEEK_CUR (1)
    ve SEEK_END (2) sembolik sabitleri tanımlanmış durumdadır.

    Aşağıdaki örnekte aygıt sürücüyü yükledikten sonra yine onun içerisinde oluşturduğumuz dosyaya komut satırından birşeyler
    yazabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Test programında lseek ile konumlandırma yapıp sonra okuma yaptık. Test kodunu değiştirerek lseek fonksiyonunun 
    çalışıp çalışmadığını kontrol edebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR                25
#define DEV_MINOR                0

#define FILE_MEMORY_MAX_SIZE    4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};
static char g_fmem[FILE_MEMORY_MAX_SIZE];
static size_t g_fmem_size;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver module initialization...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = *off + size > g_fmem_size ? g_fmem_size - *off : size;

    if (copy_to_user(buf, g_fmem + *off, esize) != 0)
        return -EFAULT;

    *off += esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = *off + size > FILE_MEMORY_MAX_SIZE ? FILE_MEMORY_MAX_SIZE - *off : size;

    if (copy_from_user(g_fmem + *off, buf, esize) != 0)
        return -EFAULT;

    *off += esize;

    if (*off > g_fmem_size)
        g_fmem_size = *off;

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = g_fmem_size + off;
            break;
        default:
            return -EINVAL;
    }

    if (newpos < 0 || newpos > g_fmem_size)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    ssize_t result;
    char buf[4096 + 1];

    if ((fd = open("mydriver", O_RDWR)) == -1)
        exit_sys("open");

    if ((result = write(fd, "ankara", 6)) == -1)
        exit_sys("write");

    printf("%jd bytes written\n", (intmax_t)result);

    if ((result = write(fd, "izmir", 5)) == -1)
        exit_sys("write");

    printf("%jd bytes written\n", (intmax_t)result);

    if (lseek(fd, 0, 0) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    printf("%s\n", buf);

    if (lseek(fd, -2, 1) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    if (lseek(fd, -2, 2) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    printf("%s\n", buf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                135. Ders 21/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadarki örneklerimizde aygıt sürücümüzün majör ve minör numarasını baştan belirledik. Bunun en önemli sakıncası 
    belirlediğimiz majör numaralı bir aygıt sürücünün zaten yüklü olarak bulunuyor olmasıdır. Bu durumda aygıt sürücümüz yüklenemeyecektir. 
    Aslında daha doğru bir strateji tersten gitmektir. Yani önce aygıt sürücümüz içerisinde biz boş bir majör numara bulup onu 
    kullanabiliriz. Tabii sonra kullanıcı modundan bu aygıt numarasına ilişkin bir aygıt dosyasını da yaratmamız gerekir.

    Boş bir aygıt numarasını bize veren alloc_chrdev_region isimli bir çekirdek fonksiyonu vardır. Fonksiyonun parametrik yapısı 
    şöyledir:

    int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt numarasının yerleştirileceği dev_t nesnesinin adresini alır. İkinci ve üçüncü parametreler 
    başlangıç minör numarası ve onun sayısını belirtir. Son parametre ise aygıt sürücüsünün "/proc/devices" dosyasında ve "/sys/module" 
    dizininde görüntülenecek olan ismini belirtmektedir. alloc_chrdev_region fonksiyonu zaten register_chrdev_region fonksiyonunun 
    yaptığını da yapmaktadır. Dolayısıyla bu iki fonksiyondan yalnızca biri kullanılmalıdır. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    dev_t g_dev;
    ...

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) != 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    Aygıt sürücülerin majör numaraları birbirinden farklı olmak zorundadır. Biz kullanılan bir majör numaraya ilişkin kullanılmayan 
    bir numara eşliğinde aygıt sürücümüzü register ettiremeyiz.

    Aygıt sürücümüzde alloc_chrdev_region fonksiyonu ile boş bir majör numara numaranın bulunup aygıt sürücümüzün register 
    ettirildiğini düşünelim. Peki biz bu numarayı nasıl bilip de komut satırından bu numaraya uygun aygıt dosyası yaratacağız? 
    İşte bunun için genellikle izlenen yöntem "/proc/devices" dosyasına bakıp oradan majör numarayı alıp aygıt dosyasını yaratmaktır. 
    Tabii bu manuel olarak yapılabilir ancak bir "shell script" ile otomatize de edilebilir. Aşağıdaki bu işlemi yapan "load" 
    isimli bir "shell script" verilmiştir:

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./${module}.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module c $major 0

    Artık biz bu "load" script'i ile aygıt sürücümüzü yükleyip aygıt dosyamızı yaratabileceğiz. Bu script'i "load" ismiyle yazıp 
    aşağıdaki gibi dosyaya "x" hakkı vermelisiniz:

    $ chmod +x load

    Çalıştırmayı komut satırı argümanı vererek aşağıdaki gibi yapmalısınız:

    $ sudo ./load generic-char-driver

    Burada "load" script'i çalıştırıldığında hem aygıt sürücü çekirdek alanına yüklenmekte hem de yüklenen aygıt sürücünün 
    majör numarasıyla (minör numarası da 0 olacak biçimde) "generic-char-driver" isimli aygıt dosyası yaratılmaktadır. Aygıt 
    sürücünün çekirdek alanından atılması manuel bir biçimde "rmmod" komutuyla yapılabilir. Tabii aynı zamanda bu aygıt sürücü 
    için yaratılan aygıt dosyasının da silinmesi uygun olabilir. Yukarıdaki script'te aygıt dosyası zaten varsa aynı zamanda o 
    dosya silinmektedir. Tabii aygıt dosyasını çekirdek alanından atarak silen ayrı bir "unload" isimli script'i de aşağıdaki 
    gibi yazabiliriz:

    #!/bin/bash

    module=$1

    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module

    Tabii yine bu script dosyasının da "x" hakkına sahip olması gerekmektedir:

    $ chmod +x unload

    "unload" script'ini aşağıdaki gibi çalıştırabilirsiniz:

    $ sudo ./unload generic-char-driver

    Aşağıdaki örnekte alloc_chrdev_region fonksiyonuyla hem boş bir aygıt numarası elde edilip hem de bu aygıt numarası register 
    ettirilmiştir. Yükleme işlemi yukarıdaki "load" script'i ile yapılmalıdır. çekirdek modülünün boşaltılması işlemi manuel 
    olarak ya da "unload" script'i ile yapılabilir. Örneğin:

    $ sudo ./load generic-char-driver
    ...
    $ sudo ./unload generic-char-driver
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};

static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize  > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
    case 0:
        newpos = off;
        break;
    case 1:
        newpos = filp->f_pos + off;
        break;
    case 2:
        newpos = g_fsize + off;
        break;
    default:
        return -EINVAL;
    }
    if (newpos < 0 || newpos >= g_fsize)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("generic-char-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (lseek(fd, 5, 0) == -1)
        exit_sys("lseek");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                136. Ders 26/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
     Bizim boru örneğimizde bir proses boruyu yazma modunda açtığında prosesin write fonksiyonuyla yazdıkları aygıt sürücü 
    içerisindeki bir FIFO kuyruk sistemine yazılmaktadır. Diğer proses de read fonksiyonuyla okuma yaptığında aslında bu bu 
    FIFO kuyruk sisteminden okuma yapılmaktadır. Burada yapacağımız gerçekleştirim UNIX/Linux sistemlerindeki "isimli borulara 
    (named pipes)" benzemektedir. Biz bu örneği çeşitli konuları gördükçe geliştireceğiz. Anımsayacağınız gibi UNIX/linux 
    sistemlerindeki boruları kullanırken eğer boru tamamen boşsa karşı taraf boruya en az 1 byte yazana kadar bloke oluşmaktadır. 
    Boru tamamen doluysa yazma sırasında karşı taraf okuma yapıp boruda yazılacak miktar kadar alan açana kadar bloke oluşmaktadır. 
    Ayrıca isimli borularda boruyu bir taraf okuma modunda açmaya çalıştığında diğer taraf boruyu yazma modunda açana kadar, 
    yazma modunda açmaya çalıştığında diğer taraf boruyu okuma modunda açana kadar da bloke oluşmaktadır. Biz bu gerçekleştirimde 
    henüz bloke oluşturmayı görmediğimizden dolayı bu özellikleri sağlamayacağız.

    Boruya ilişkin bir FIFO kuysuk sistemini oluşturabilmek için aşağıdaki nesnelerin tanımlanması gerekmektedir:

    #define PIPE_BUFFER_SIZE        8192

    static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
    static size_t g_head;
    static size_t g_tail;
    static size_t g_count;

    Burada g_pipebuf FIFO kuyruk sistemi için kullanılacak olan tamponu belirtmektedir. Bu tamponun PIPE_BUFFER_SIZE kadar 
    olduğuna dikkat ediniz. g_head kuyruğun başını, g_tail ise sonunu göstermektedir. Kuyruğa yazan taraf g_tail indeksinden 
    itibaren yazmayı yapar, kuyruktan okuma yapan taraf ise g_head indeksinden itibaren okuma yapar. Tabii bu indeksler dizinin
    sonuna geldiğinde yeniden başa geçirilmelidir. g_count ise kuyrukta kaç byte'ın bulunduğunu belirtmektedir. Başlangıçta 
    g_head, g_tail ve g_count 0 değerindedir. Yani kuyruk boştur.

    Aygıt sürücünün write fonksiyonu şöyle yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Burada kullanıcı modundaki proses write işlemi yaptığında bizim yazılmak istenen byte'ları copy_from_user fonksiyonu ile 
    alarak g_pipebuf içerisine g_tail indeksinden itibaren yazmamız gerekir. Ancak burada iki durum söz konusudur. Eğer g_tail 
    indeksi g_head indeksinden büyük ya da ona eşitse iki parçalı bir yazım gerekebilir. Ancak eğer g_tail indeksi g_head 
    indeksinden küçükse yazım tek seferde yapılabilir. Biz kodumuzda önce boru tamponunun dolu olup olmadığına baktık:

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    Boru tamponu tamamen dolu ise fonksiyonu 0 ile geri döndürdük. Kullanıcı modunda write fonksiyonun geri dönüş değerini 0 
    olarak gören programcı borunun dolu olduğunu anlayacaktır. Biz kodumuzda, yazma işlemi sanki iki parça halinde yapılacakmış 
    gibi bu iki parçanın uzunluklarını elde ettik:

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    Tabii eğer g_tail indeksi g_head indeksinin gerisindeyse burada size2 zaten 0 olacaktır. Ayrıca g_tail indeksi g_head indeksinin
    ilerisinde olduğu halde yazılacak miktar PIPE_BUFFER_SIZE - g_tail miktarından küçük ya da ona eşit ise yine size2 0 olacaktır.
    Kopyalama şöyle yapılmıştır:

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    Tabii bu işlemlerden sonra g_tail artık yeni pozisyonuna çekilmeli ve g_count da yazılan miktar kadar artırılmalıdır:

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    write fonksiyonunun başarılı biçimde yazılan byte sayısıyla geri döndüğünü anımsayınız. İsimli borularda aslında yazılmak 
    istenen miktar kadar boruda boş yer yoksa ve blokeli mod söz konusuysa bloke oluştuğunu ancak blokesiz mod söz konusuysa write 
    fonksiyonunun başarısız olduğunu ve errno değerinin EAGAIN ile set edildiğini anımsayınız. Bizim buradaki tasarımımız blokesiz 
    mod gibi de değildir. Biz burada eğer boruda yazmak istenilen miktar kadar yer yoksa yazılabilecek kadar bilgiyi boruya yazmayı 
    tercih ettik.

    Aygıt sürücümüzün read fonksiyonu da benzer biçimde yazılabilir:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Buradaki aygıt sürücümüzde şu kusurlar vardır:

    - Aygıt sürücümüzde read/write fonksiyonlarında hiçbir senkronizasyon uygulamadık. Dolayısıyla eş zamanlı işlemlerde boru 
    mekanizması birbirine girebilir. Örneğin iki farklı proses bu boruya aynı anda yazma yaparsa senkronizasyondan kaynaklanan 
    sorunlar oluşabilir.

    - Bu gerçekleştirimimizde ayrıca iki proses de boruyu kapatsa bile borunun içerisindekiler silinmemektedir. Halbuki 
    orijinal isimli borularda prosesler boruyu kapatınca boru içerisindeki tüm bilgiler silinmektedir.

    - Bu gerçekleştirimimizde sistem genelinde tek bir boru yaratılmaktadır. Yani bizim boru aygıt sürücümüz tek bir boru 
    üzerinde işlemler yapmaktadır. Halbuki orijinal isimli borularda programcılar birbirinden bağımsız istedikleri kadar 
    çok isimli boru yaratabilmektedir.

    Aygıt sürücümüzü önce build edip sonra aşağıdaki gibi yüklemelisiniz:

    $ make file=pipe-driver
    $ sudo ./load pipe-driver

    Buradaki boru aygıt sürücüsünü test etmek için "pwriter" ve "preader" isimli iki program yazılmıştır. "pwriter" programı 
    klavyeden (stdin dosyasından) alınan yazıları boruya yazmakta, "preader" ise klavyeden (stdin dosyasından) alınan uzunlukta 
    byte'ı borudan okumaktadır. Test işlemini yaparken boru uzunluğunu azaltabilirsiniz. Biz örneğimizde boru uzunluğunu 
    8192 aldık.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == 0)
        return 0;

    esize = MIN(size, g_count);

    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        return -EFAULT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            return -EFAULT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;

    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    g_tail = (g_tail + esize) % PIPE_BUFFER_SIZE;
    g_count += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                137. Ders 28/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerdeki kodlar kullanıcı modundan farklı prosesler tarafından kullanılıyor olabilir. Ayrıca ileride göreceğimiz 
    gibi aygıt sürücüler donanım kesmelerini de kullanıyor olabilir. Dolayısıyla aygıt sürücü kodları eş zamanlı (concurrent) 
    erişime uygun biçimde yazılmalıdır. Kullanıcı modundaki bir proses aygıt sürücü içerisindeki bir kaynağı kullanıyorken 
    kullanıcı modundaki diğer prosesin o kaynağın bozulmaması için diğerini beklemesi gerekebilmektedir.

    Çekirdek modunda aygıt sürücü kodları daha önce kullanıcı modunda gördüğümüz senkronizasyon nesnelerini kullanamaz. Çünkü 
    daha önce gördüğümüz senkronizasyon nesneleri user mode'dan kullanılsın diye oluşturulmuştur. Çekirdeğin içerisinde çekirdek
    modundan kullanılabilecek ayrı senkronizasyon nesneleri bulunmaktadır. Bu bölümde aygıt sürücülerin çekirdek modunda 
    kullanabileceği senkronizasyon nesnelerini göreceğiz.

    Çekirdek modu için user mode'dakine benzer senkronizasyon nesneleri kullanılmaktadır. Bunların genel çalışma biçimi kullanıcı
    modundakilere benzemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri Linux çekirdeğine 2.6 versiyonu ile eklenmiştir. Bundan önce mutex işlemleri binary semaphore'larla yapılıyordu. 
    Çekirdeğin mutex mekanizması kullanıcı modundaki mutex mekanizmasına çok benzemektedir. Çekirdek mutex nesnelerinin yine 
    thread temelinde sahipliği vardır. Çekirdek mutex nesneleri thread'i bloke edip onu bekleme kuyruklarında bekletebilmektedir.

    Mutex mekanizması şöyle işletilmektedir: Önce bir mutex nesnesi yaratılır. Kritik koda girişte bu mutex nesnesinin sahipliği
    ele geçirilmeye çalışılır. Mutex'in sahipliğinin ele geçirilmesine "mutex'in kilitlenmesi (mutex lock)" de denilmektedir. Eğer 
    mutex'in sahipliği ele geçirilirse (yani mutex kilitlenirse) sahiplik bırakılana kadar (yani kilit bırakılana kadar) başka bir 
    thread kritik koda giremez. Mutex'in sahipliğini almaya çalışan thread mutex kilitli ise bloke olarak mutex kilidi açılana kadar 
    bekler. Mutex'in sahipliğini almış olan thread kritik koddan çıkarken mutex'in sahipliğini bırakır (yani mutex'in kilidini açar). 
    Böylece blokede bekleyen thread'lerden biri mutex'in sahipliğini alarak kritik koda girer. Kritik kod tipik olarak şöyle 
    oluşturulmaktadır:

     mutex_lock(...)
    ...
    ...    KRİTİK KOD
    ...
    mutex_unlock(...)

    Thread'lerden biri mutex_lock fonksiyonuna geldiğinde eğer mutex kilitlenmemişse mutex'i kilitler ve kritik koda giriş yapar. 
    Eğer mutex zaten kilitlenmişse mutex_lock fonksiyonunda thread bloke edilir ve bekleme kuyruğuna alınır. Kritik koda girmiş
    olan thread mutex_unlock fonksiyonu ile mutex nesnesinin kilidini bırakır. Böylece nesneyi bekleyen thread'lerden biri 
    nesnenin sahipliğini alarak mutex'i kilitler. Birden fazla thread'in mutex_lock fonksiyonunda bloke edilmesi durumunda mutex'in 
    kilidi açıldığında bunlardan hangisinin mutex kilidini alarak kritik koda gireceği konusunda bir garanti verilmemektedir. 
    (İlk bloke olan thread'in mutex kilidini alarak kritik koda gireceğini düşünebilirsiniz, ancak bunun bir garantisi yoktur.)

    Çekirdekteki mutex mekanizmasının tipik gerçekleştirimi şöyledir:

    1) mutex_lock işlemi sırasında işlemcinin maliyetsiz compare/set (compare/exchange) komutlarıyla mutex'in kilitli olup 
    olmadığına bakılır.
    2) Diğer bir işlemcideki thread mutex'i kilitlemişse boşuna bloke olmamak için yine compare/set komutlarıyla biraz spin 
    işlemi yapılır.
    3) Spin işleminden sonuç elde edilemezse bloke oluşturulur.

    Çekirdeğin mutex nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Mutex nesnesi mutex isimli bir yapıyla temsil edilmektedir. Sistem programcısı bu yapı türünden global bir nesne yaratır 
    ve ona ilk değerini verir. DEFINE_MUTEX(name) makrosu hem struct mutex türünden nesneyi tanımlamakta hem de ona ilk değerini 
    vermektedir. Örneğin:

    #include <linux/mutex.h>

    static DEFINE_MUTEX(g_mutex);

    Burada biz hem g_mutex isminde bir global nesne tanımlamış olduk hem de ona ilk değer vermiş olduk. Aynı işlem önce nesneyi 
    tanımlayıp sonra mutex_init fonksiyonunun çağrılmasıyla da yapılabilmektedir. Örneğin:

    static struct mutex g_mutex;
    ...
    mutex_init(&g_mutex);

    DEFINE_MUTEX makrosuna nesnenin adresinin verilmediğine dikkat ediniz. Bu makro ve mutex_init fonksiyonunun prototipleri
    <linux/mutex.h> başlık dosyasında bulunmaktadır.

    Her ne kadar mutex_init bir fonksiyon görünümündeyse de aslında çekirdek kodlarında hem bir makro olarak hem de bir fonksiyon 
    olarak bulunmaktadır. Mevcut Linux çekirdeklerinde fonksiyonların makro gerçekleştirimleri aşağıdaki gibidir:

    #define DEFINE_MUTEX(mutexname)                            \
        struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)

    #define mutex_init(mutex)                \
    do {                            \
        static struct lock_class_key __key;        \
                                \
        __mutex_init((mutex), #mutex, &__key);        \
    } while (0)

    2) Mutex nesnesini kilitlemek için mutex_lock fonksiyonu kullanılır:

    #include <linux/mutex.h>

    void mutex_lock(struct mutex *lock);

    Mutex'in kilitli olup olmadığı ise mutex_trylock fonksiyonuyla kontrol edilebilir:

    #include <linux/mutex.h>

    int mutex_trylock(struct mutex *lock);

    Eğer mutex kilitliyse fonksiyon bloke olmadan 0 değeriyle geri döner. Eğer mutex kilitli değilse mutex kilitlenir ve fonksiyon
    1 değeri ile geri döner.

    Mutex nesnesi mutex_lock ile kilitlenmek istendiğinde bloke oluşursa bu blokeden sinyal yoluyla çıkılamamaktadır. Örneğin 
    mutex_lock ile çekirdek modunda biz mutex kilidini alamadığımızdan dolayı bloke oluştuğunu düşünelim. Bu durumda ilgili prosese 
    bir sinyal gelirse ve eğer o sinyal için sinyal fonksiyonu set edilmişse thread uyandırılıp sinyal fonksiyonu çalıştırılmamaktadır. 
    Ayrıca bu durumda biz ilgili prosese SIGINT gibi, SIGKILL gibi sinyaller göndererek de prosesi sonlandıramayız. İşte eğer mutex'in 
    kilitli olması nedeniyle bloke oluştuğunda sinyal yoluyla thread'in uyandırılıp sinyal fonksiyonunun çalıştırması ya da sinyal 
    fonksiyonu set edilmemişse prosesin sonlandırılması isteniyorsa mutex nesnesi mutex_lock ile değil, mutex_lock_interrupible 
    fonksiyonu ile kilitlenmeye çalışılmalıdır. mutex_lock_interruptible fonksiyonunun prototipi şöyledir:

    #include <linux/mutex.h>

    int mutex_lock_interruptible(struct mutex *lock);

    Fonksiyon eğer mutex kilidini alarak sonlanırsa 0 değerine, bloke olup sinyal dolayısıyla sonlanırsa -EINTR değerine geri 
    dönmektedir. Programcı bu fonksiyonun 0 ile geri dönmediğini ya da -EINTR ile geri döndüğünü tespit ettiğinde ilgili sistem 
    fonksiyonunun yeniden çalıştırılabilirliğini sağlamak için -ERESTARTSYS ile geri dönebilir. Örneğin:

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    3) Mutex nesnesinin kilidini bırakmak için (nesneyi unlock etmek için) mutex_unlock fonksiyonu kullanılmaktadır:

    void mutex_unlock(struct mutex *lock);

    Bu durumda örneğin tipik olarak aygıt sürücü içerisinde belli bir bölgeyi mutex yoluyla koruma şöyle yapılmaktadır:

    DEFINE_MUTEX(g_mutex);
    ...

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    ...
    ... <KRİTİK KOD>
    ...

    mutex_unlock(&g_mutex);

    Mutex nesnesini kilitledikten sonra fonksiyonlarınızı geri döndürürken kilidi açmayı unutmayınız.

    Aşağıdaki örnekte yukarıdaki boru aygıt sürücüsü daha güvenli olacak biçimde mutex nesneleriyle senkronize edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/mutex.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    mutex_unlock(&g_mutex);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    mutex_unlock(&g_mutex);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                138. Ders 03/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdekte de kullanıcı modundakine benzer semaphore nesneleri vardır. Kernel semaphore nesneleri de sayaçlıdır. Yine 
    bunların sayaçları 0'dan büyükse semaphore açık durumdadır, sayaçlar 0 değerinde ise semaphore kapalı durumdadır. Kritik 
    koda girildiğinde yine sayaç 1 eksiltilir. Sayaç 0 olduğunda thread bloke edilir. Yine bloke işleminde biraz spin işlemi 
    yapılıp sonra bloke uygulanmaktadır. Çekirdek semaphore nesneleri şöyle kullanılmaktadır:

     1) Semaphore nesnesi struct semaphore isimli bir yapıyla temsil edilmiştir. Bir semaphore nesnesi DEFINE_SEMAPHORE(name) 
    makrosuyla aşağıdaki gibi oluşturulabilir.

    #include <linux/semaphore.h>

    static DEFINE_SEMAPHORE(g_sem);

    Bu biçimde yaratılan semaphore nesnesinin başlangıçta sayaç değeri 1'dir. Yeni çekirdeklerde (v6.4-rc1 ve sonrası) bu makro 
    iki parametreli olarak da kullanılabilmektedir:

    static DEFINE_SEMAPHORE(g_sem);

    Buradaki ikinci parametre semaphore sayacının başlangıçtaki değerini belirtmektedir.

    Semaphore nesneleri sema_init fonksiyonuyla da yaratılabilmektedir:

    static struct semaphore g_sem;
    ...
    sema_init(&g_sem, 1);

    Fonksiyonun ikinci parametresi başlangıç sayaç numarasıdır.

    2) Kritik kod "down" ve "up" fonksiyonları arasına alınır. "down" fonksiyonları sayacı bir eksilterek kritik koda giriş yapar. 
    "up" fonksiyonu ise sayacı bir artırmaktadır. Fonksiyonların prototipleri şöyledir:

    #define <linux/semaphore.h>

    void down(struct semaphore *sem);
    int down_interruptible(struct semaphore *sem);
    int down_killable(struct semaphore *sem);
    int down_trylock(struct semaphore *sem);
    int down_timeout(struct semaphore *sem, long jiffies);
    void up(struct semaphore *sem);

    Kritik kod "down" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılamamaktadır. Ancak kritik kod 
    "down_interruptible" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılabilmektedir. down_killable
    bloke olmuş thread'in yalnızca SIGKILL sinyalini kabul edip sonlandırılabilmesini sağlamaktadır. down_killable fonksiyonunda 
    eğer thread bloke olursa diğer sinyaller yine blokeyi sonlandıramamaktadır. down_trylock yine nesnenin açık olup olmadığına 
    bakmak için kullanılır. Eğer nesne açıksa yine sayaç 1 eksiltilir ve kritik koda girilir. Bu durumda fonksiyon 0 dışı bir 
    değerle geri döner. Nesne kapalıysa (yani semaphore sayacı 0 ise) fonksiyon bloke olmadan 0 değerine geri döner. down_timeout 
    ise en kötü olasılıkla belli miktar "jiffy" zamanı kadar blokeye yol açmaktadır. ("jiffy" kavramı ileride ele alınacaktır.) 
    Fonksiyon zaman aşımı dolduğundan dolayı sonlanmışsa negatif hata koduna, normal bir biçimde sonlanmışsa 0 değerine geri 
    dönmektedir. down_interruptible fonksiyonu normal sonlanmada 0 değerine, sinyal yoluyla sonlanmada -ERESTARTSYS değeri ile 
    geri döner. Normal uygulama eğer bu fonksiyonlar -ERESTARTSYS ile geri dönerse aygıt sürücüdeki fonksiyonun da aynı değerle 
    geri döndürülmesidir. Zaten çekirdek bu -ERESTARTSYS geri dönüş değerini aldığında asıl sistem fonksiyonunu eğer sinyal için 
    otomatik restart mekanizması aktif değilse -EINTR değeri ile geri döndürmektedir. Bu da tabii POSIX fonksiyonlarının başarısız 
    olup errno değerini EINTR biçiminde set edilmesine yol açmaktadır. up fonksiyonu yukarıda da belirttiğimiz gibi semaphore 
    sayacını 1 artırmaktadır.

    Kernel semaphore nesneleriyle kritik kod aşağıdaki gibi oluşturulmaktadır:

    DEFINE_SEMAPHORE(g_sem);
    ...

    down_interruptible(&g_sem);
    ...
    ... <KRİTİK KOD>
    ...
    up(&g_sem);

    Yukarıdaki boru örneğinde biz mutex nesnesi yerine binary semaphore nesnesi de kullanabilirdik. Aşağıda aynı örneğin 
    binary semaphore ile gerçekleştirimi görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SEMAPHORE(g_sem);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    up(&g_sem);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modunda gördüğümüz diğer senkronizasyon nesnelerinin benzerleri de çekirdek içerisinde bulunmaktadır. Örneğin 
    spinlock kullanımına çekirdek kodlarında ve aygıt sürücülerde sıkça rastlanmaktadır. Anımsanacağı gibi spinlock uykuya 
    dalarak değil, (yani bloke olarak değil) meşgul bir döngü içerisinde kilidin açılmasını bekleyen senkronizasyon nesnelerini 
    belirtiyordu. Spinlock kullanımının çok işlemcili ya da çekirdekli sistemlerde anlamlı olduğunu da belirtmiştik. Spinlock nesneleri 
    küçük kod blokları için ve özellikle çok işlemcili ya da çok çekirdekli sistemlerde kullanılması gereken senkronizasyon nesneleridir. 
    Spinlock nesnesinin kilidini alan thread'in bloke olmaması gerekir. Aksi takdirde istenmeyen sonuçlar oluşabilir. Özetle spinlock 
    nesnesinin kilidini alan thread şu durumlara dikkat etmelidir:

    - Spinlock ile kritik koda giren thread spinlock kilidini uzun süre kapalı tutmamalıdır. Yani spinlock kısa kodlar için 
    uygulanmalıdır.
    - Spinlock ile kritik koda giren thread bloke olmamalıdır.
    - Spinlock ile kritik koda giren thread CPU'yu IRQ'lara açma konusunda dikkatli olmalıdır.

    Linux'ta bir thread spinlock kilidini almışsa artık quanta süresi dolsa bile thread'ler arası geçiş kapatılmaktadır.

    Çekirdekteki spinlock nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Spinlock nesnesi spinlock_t türü ile temsil edilmektedir. Spinlock nesnesini aşağıdaki gibi tanımlayabilirsiniz:

    static spinlock_t g_spinlock;

    Linux'un 2.6.9 çekirdeği ile birlikte spinlock nesnesini tanımlayıp ona ilkdeğer vermek için DEFINE_SPINLOCK makrosu da 
    çekirdeğe eklenmiştir. Bu makro kullanılarak spinlock nesnesi açık bir biçimde şöyle oluşturulabilir:

    #include <linux/spinlock.h>

    static DEFINE_SPINLOCK(g_spinlock);

    spinlock_t nesnesine ilkdeğer verme işlemi spin_lock_init fonksiyonuyla da yapılabilmektedir. spin_lock_init fonksiyonu 
    spinlock_t nesnesine açık olacak biçimde (unlocked) ilkdeğerlerini vermektedir:

    #include <linux/spinlock.h>

    void spin_lock_init(spinlock_t *lock);

    Örneğin:

    spinlock_init(&g_spinlock);

    2) Kritik koda giriş için aşağıdaki fonksiyonlar kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_lock(spinlock_t *lock);
    void spin_lock_irq(spinlock_t *lock);
    void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
    void spin_lock_bh(spinlock_t *lock);

    "spin_lock" fonksiyonu klasik spin yapan fonksiyondur. "spin_lock_irq" fonksiyonu o anda çalışılan işlemci ya da çekirdekteki 
    IRQ'ları (yani donanım kesmelerini) kapatarak kilidi almaktadır. Yani biz bu fonksiyonla kilidi almışsak kilidi bırakana 
    kadar donanım kesmeleri oluşmayacaktır. "spin_lock_irqsave" fonksiyonu kritik koda girerken donanım kesmelerini kapatmakla 
    birlikte önceki bir durumu geri yükleme yeteneğine sahiptir. Aslında bu fonksiyonların bazıları makro olarak yazılmıştır. 
    Örneğin spin_lock_irqsave aslında bir makrodur. Biz bu fonksiyonun ikinci parametresine nesne adresini geçmemiş olsak da 
    bu bir makro olduğu için aslında ikinci parametrede verdiğimiz nesnenin içerisine IRQ durumları yazılmaktadır. spin_lock_bh
    fonksiyonu yalnızca yazılım kesmelerini kapatmaktadır.

    3) Kilidin geri bırakılması için spin_unlock fonksiyonları kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_unlock(spinlock_t *lock);
    void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
    void spin_unlock_irq(spinlock_t *lock);
    void spin_unlock_bh(spinlock_t *lock);

    Yukarıdaki lock fonksiyonlarının hepsinin bir unlock karşılığının olduğunu görüyorsunuz. Biz kilidi hangi lock fonksiyonu 
    ile almışsa o unlock fonksiyonu ile bırakmalıyız. Örneğin:

    spin_lock(&g_spinlock);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock(&g_spinlock);

    Ya da örneğin:

    ...
    unsigned long irqstate;
    ...

    spin_lock_irqsave(&g_spinlock, irqstate);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock_irqrestore(&g_spinlock, irqstate);

    Yine kernel spinlock nesnelerinde de try'lı lock fonksiyonları bulunmaktadır:

    #include <linux/spinlock.h>

    int spin_trylock(spinlock_t *lock);
    int spin_trylock_bh(spinlock_t *lock);

    Bu fonksiyonlar eğer spinlock kilitliyse spin yapmazlar ve 0 ile geri dönerler. Eğer kilidi alırlarsa sıfır dışı bir 
    değerle geri dönerler.

    Her ne kadar yukarıdaki boru sürücüsündeki read ve write fonksiyonlarında kuyruğu korumak için spinlock kullanımı uygun 
    değilse de biz yine kullanım biçimini göstermek için aşağıdaki örneği veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/spinlock.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SPINLOCK(g_spinlock);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    spin_unlock(&g_spinlock);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    spin_unlock(&g_spinlock);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz daha önce user mode'da reader/writer lock nesnelerini görmüştük. Bu nesneler birden fazla thread'in kritik koda okuma
    amaçlı girmesine izin veriyordu. Ancak bir thread kritik koda yazma amaçlı girmişse diğer bir thread'in okuma ya da 
    yazma amaçlı kritik koda girmesine izin vermiyordu. İşte user mode'daki reader/write lock nesnelerinin bir benzeri kernel 
    mode'da reader/writer spinlock nesneleri biçiminde bulunmaktadır. Yine kernel mode'da da kritik koda okuma amaçlı ya da 
    yazma amaçlı giren fonksiyonlar vardır.

    reader/writer spinlock nesneleri rwlock_t türüyle temsil edilmektedir. Bunların yaratılması rwlock_init fonksiyonuyla 
    yapılmaktadır:

    #include <linux/rwlock.h>

    void rwlock_init(rwlock_t *lock);

    reader/writer spinlock nesneleri ile ilgili diğer çekirdek fonksiyonları şunlardır:

    #include <linux/rwlock.h>

    void read_lock(rwlock_t *lock);
    void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void read_lock_irq(rwlock_t *lock);
    void read_lock_bh(rwlock_t *lock);

    void read_unlock(rwlock_t *lock);
    void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void read_unlock_irq(rwlock_t *lock);
    void read_unlock_bh(rwlock_t *lock);

    void write_lock(rwlock_t *lock);
    void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void write_lock_irq(rwlock_t *lock);
    void write_lock_bh(rwlock_t *lock);
    int write_trylock(rwlock_t *lock);

    void write_unlock(rwlock_t *lock);
    void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void write_unlock_irq(rwlock_t *lock);
    void write_unlock_bh(rwlock_t *lock);

    Nesne read amaçlı lock edilmişse read amaçlı unlock işlemi, write amaçlı lock edilmişse write amaçlı unlock işlemi 
    uygulanmalıdır. Fonksiyonların diğer işlevleri normal spinlock nesnelerinde olduğu gibidir.

    Örneğin biz bu fonksiyonlarla okuma yazma işlemlerini aşağıdaki gibi senkronize edebiliriz:

    static DEFINE_RWLOCK(g_rwlock);

    read()
    {
        read_lock(&g_rwlock);
        <okuma işlemi yapılıyor>
        read_unlock(&g_rwlock);
    }

    write()
    {
        write_lock(&g_rwlock);
        <yazma işlemi yapılıyor>
        write_unlock(&g_rwlock);
    }

    Burada artık okuma yapmak isteyen thread read fonksiyonunu çağırdığında read_lock fonksiyonu ile spinlock kilidi alınır, 
    başka bir thread bu kilidi write_lock ile alamaz ve spin yapmaya başlar. Ancak başka bir thread kilidi yine read_lock 
    ile alabilir. Eğer bir thread kilidi write_lock ile almışsa başka bir thread kilidi read_lock ile de write_lock ile de 
    alamaz ve spin yaparak bekler.

    read_lock ve write_lock fonksiyonlarının irq sonekli versiyonları yine akış kritik kodda girdiğinde ilgili CPU ya da 
    çekirdeğin yerel kesmelerini kapatmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki senkronizasyon nesnelerinin benzerlerinin çekirdek içerisinde de bulunduğunu görüyorsunuz. Ancak 
    kullanıcı modundaki her senkronizasyon nesnesinin bir çekirdek mod karşılığı yoktur. Örneğin kullanıcı modundaki "koşul 
    değişkenlerinin (condition variables)" bir çekirdek mod karşılığı bulunmamaktadır. Ayrıca burada ele almadığımız (belki 
    ileride ele alacağımız) yalnızca çekirdek içerisinde kullanılan birkaç senkronizasyon nesnesi daha bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı kullanıcı modunda olduğu gibi aygıt sürücülerde de basit atama, artırma, eksiltme gibi işlemlerin atomic yapılmasını 
    sağlayan özel inline fonksiyonlar vardır. Aslında bu işlemler thread'ler konusunda görmüş olduğumuz gcc'nin built-in atomic 
    fonksiyonlarıyla yapılabilir. Ancak çekirdek içerisindeki fonksiyonların kullanılması uyum bakımından daha uygundur. Bu 
    inline fonksiyonların hepsi nesneyi atomic_t türü biçiminde istemektedir. Bu aslında içerisinde yalnızca int bir nesne olan bir 
    yapı türüdür. Bu yapı nesnesinin içerisindeki değeri alan atomic_read isimli bir inline fonksiyon da vardır. Atomic 
    inline fonksiyonların bazıları şunlardır:

    #include <asm/atomic.h>

    int atomic_read(const atomic_t *v);
    void atomic_set(atomic_t *v, int i);
    void atomic_add(int i, atomic_t *v);
    void atomic_sub(int i, atomic_t *v);
    void atomic_inc(atomic_t *v);
    void atomic_dec(atomic_t *v)
    ...

    Bu fonksiyonların hepsinin atomic_t türünden nesnenin adresini alan bir parametresi vardır. atomic_set fonksiyonunun ikinci 
    parametresi set edilecek değeri almaktadır.

    Yukarıda da belirttiğimiz gibi atomic_t türü aslında int bir elemana sahip bir yapı biçimindedir. atomic_t türünden 
    bir değişkene ilkdeğer vermek için ATOMIC_INIT makrosu da kullanılabilir. Örneğin:

    atomic_t g_count = ATOMIC_INIT(0);

    Yukarıda da belirttiğimiz gibi atomic_t nesnesi içerisindeki değeri atomic_read makrosuyla elde edebiliriz. Örneğin:

    val = atomic_read(&g_count);

    Peki mademki atomic_t türü içerisinde bir int değerin bulunduğu bir yapı belirtiyor bu durumda neden doğrudan int nesne
    kullanılmıyor da içerisinde int bir eleman olan yapı kullanılıyor? İşte bunun amacı bu atomik nesnenin ++, --, += gibi 
    operatörlerle kullanımı konusunda cesareti kırmaktır.

    Bit işlemlerine yönelik atomik işlemler de yapılabilmektedir:

    void set_bit(nr, void *addr);
    void clear_bit(nr, void *addr);
    void change_bit(nr, void *addr);
    test_bit(nr, void *addr);
    int test_and_set_bit(nr, void *addr);
    int test_and_clear_bit(nr, void *addr);
    int test_and_change_bit(nr, void *addr);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                139. Ders 05/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kullanıcı modunda çeşitli fonksiyonların çeşitli koşullar altında blokeye yol açtığını belirtmiştik. Bir thread bloke 
    olduğunda thread belli bir koşul sağlanana kadar ilgili CPU'nun "çalışma kuyruğundan (run queue)" çıkartılır, ismine 
    "bekleme kuyruğu (wait queue)" denilen bir kuyruğa yerleştirilir. Blokeye yol açan koşul ortadan kalktığında ise thread 
    yeniden bekleme kuyruğundan alınarak ilgili CPU'nun çalışma kuyruğuna yerleştirilir. Biz şimdiye kadar kullanıcı modunda 
    hep sistem fonksiyonları yoluyla blokelerin oluştuğunu gördük. Ancak çekirdek modundaki aygıt sürücülerde blokeyi aygıt 
    sürücünün kendisi oluşturmaktadır. Örneğin biz boru aygıt sürücümüzde read işlemi yapıldığında eğer boruda okunacak hiç 
    bilgi yoksa read işlemini yapan user mode'daki thread'i bloke edebiliriz. Boruya bilgi geldiğinde de thread'i yeniden 
    çalışma kuyruğuna yerleştirip blokeyi çözebiliriz. İşte bu bölümde aygıt sürücüde thread'lerin nasıl bloke edileceği ve 
    blokenin nasıl çözüleceği üzerinde duracağız.

    Daha önceden de belirttiğimiz gibi mevcut Linux sistemlerinde her CPU ya da çekirdeğin ayrı bir "çalışma kuyruğu (run queue)" 
    bulunmaktadır. Ancak bir ara O(1) çizelgelemesi ismiyle Linux'ta bu konuda bir değişikliğe gidilmişti ((2.6.0 ile 2.6.22
    arasındaki çekirdekler)O(1) çizelgelemesi tekniğinde toplam tek bir çalışma kuyruğu bulunuyordu. Hangi CPU ya da çekirdeğe 
    atama yapılacaksa bu tek olan çalışma kuyruğundan thread alınıyordu. O(1) çizelgelemesi Linux'ta kısa bir süre kullanılmıştır. 
    Bunun yerine "CFS (Completely Fair Scheduling)" çizelgeleme sistemine geçilmiştir. Bugün ağırlıklı olarak CFS çizelgeleme 
    algoritmasının iyileştirilmiş biçimleri kullanılmaktadır.

    Daha önceden de belirttiğimiz gibi çalışmakta olan bir thread'in bloke olması sırasında thread'in yerleştirileceği tek bir 
    "bekleme kuyruğu (wait queue)" yoktur. Her CPU ya da çekirdek için de ayrı bir bekleme kuyruğu bulundurulmamaktadır. Bekleme 
    kuyrukları ilgili olay temelinde oluşturulmaktadır. Örneğin sleep fonksiyonu dolayısıyla bloke olan thread'ler ayrı bir 
    bekleme kuyruğuna, boru dolayısıyla bloke olan thread'ler ayrı bir bekleme kuyruğuna yerleştirilmektedir. Aygıt sürücüleri 
    yazanlar da kendi olayları için kendi bekleme kuyruklarını yaratırlar. Tabii çekirdekteki mutex ve semaphore fonksiyonları 
    da aslında kendi içerisinde bir bekleme kuyruğu kullanmaktadır. Çünkü bu fonksiyonlar da blokeye yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                140. Ders 10/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi her aygıt sürücü kendi bloke olayları için kendinin kullanacağı bekleme kuyrukları 
    yaratabilmektedir. Çekirdek içerisinde bekleme kuyruklarını yaratan ve yok eden çekirdek fonksiyonları bulunmaktadır. Yine 
    çekirdek içerisinde bir thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştiren, bekleme kuyruğundan çıkartıp 
    çalışma kuyruğuna yerleştiren fonksiyonlar bulunmaktadır.

    Linux'ta bekleme kuyrukları wait_queue_head_t isimli bir yapıyla temsil edilmektedir. Bir bekleme kuyruğu DECLARE_WAIT_QUEUE_HEAD(name) 
    makrosuyla oluşturulabilir. Örneğin:

    #include <linux/wait.h>

    static DECLARE_WAIT_QUEUE_HEAD(g_wq);

    Bu makro hem wait_queue_head_t nesnesini tanımlayıp hem de ona küme parantezleriyle ilkdeğerlerini vermektedir. Alternatif 
    olarak önce nesne tanımlanıp sonra init_waitqueue_head fonksiyonuyla da ilk değer verilebilir. Bu fonksiyon aslında bir 
    makro biçiminde yazılmıştır. Örneğin:

    #include <linux/wait.h>

    static wait_queue_head_t g_wq;
    ...
    init_waitqueue_head(&g_wq);

    Bir thread'i (yani task_struct nesnesini) çalışma kuyruğundan çıkartıp istenilen bekleme kuyruğuna yerleştirme işlemi wait_event 
    makrolarıyla gerçekleştirilmektedir. Temel wait_event makroları şunlardır:

    wait_event(wq_head, condition);
    wait_event_interruptible(wq_head, condition);
    wait_event_killable(wq_head, condition);
    wait_event_timeout(wq_head, condition, timeout);
    wait_event_interruptible_timeout(wq_head, condition, timeout);
    wait_event_interruptible_exclusive(wq_head, condition);

    wait_event makrosu thread'i "uninterruptible" biçimde bekleme kuyruğuna yerleştirir. Bu biçimde bloke olmuş thread'lerin
    blokeleri sinyal dolayısıyla çözülememektedir. wait_event_interruptible makrosu ise aynı işlemi "interruptible" olarak 
    yapmaktadır. Yani sinyal geldiğinde thread bekleme kuyruğundan uyandırılır. wait_event_killable makrosu yalnızca SIGKILL 
    sinyali için thread'i uyandırmaktadır. Yani bu biçimde bekleme kuyruğuna yerleştirilmiş bir thread'in blokesi sinyal geldiğinde 
    çözülmez, ancak SIGKILL sinyali ile thread yok edilebilir. wait_event_timeout ve wait_event_interruptible_timeout makrolarının 
    wait_event makrolarından farkı thread'i en kötü olasılıkla belli bir jiffy zaman aşımı ile uyandırabilmesidir. Jiffy kavramı 
    izleyen bölümlerde ele alınacaktır. Makrolardaki ilk parametre bekleme kuyruğunu belirtmektedir. Bu parametreye argüman hiç 
    adresi alınmadan geçirilmelidir.

    Makrolardaki "condition (koşul)" parametresi bool bir ifade biçiminde oluşturulmalıdır. Bu ifade ya sıfır olur ya da sıfır 
    dışı bir değer olur. Bu koşul ifadesi "uyanık kalmak için bir koşul" belirtmektedir. Yani bu koşul uyandırma koşulu değildir, 
    uyanık kalma koşuludur. Çünkü bu makrolarda koşula bakılması uyumadan önce ve uyandırılma işleminden sonra yapılmaktadır. 
    Yani önce koşula bakılır. Koşul sağlanmıyorsa thread uyutulur. Thread uyandırıldığında yeniden koşula bakılır. Koşul sağlanmıyorsa 
    yeniden uyutulur. Dolayısıyla uyanma işlemi çekirdek kodlarında tıpkı koşul değişkenlerinde (condition variable) olduğu gibi 
    döngü içerisinde yapılmaktadır. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    wait_event(g_wq, g_flag != 0);

    Burada koşul g_flag != 0 biçimindedir. wait_event makroları fonksiyon değil makro biçiminde yazıldığı için bu koşul bu 
    haliyle makronun içinde kullanılmaktadır. (Yani koşul ifadesinin sonucu değil, kendisi makroda kullanılmaktadır.) Makronun 
    içerisinde önce koşula bakılmakta, bu koşul sağlanıyorsa thread zaten uyutulmamaktadır. Eğer koşul sağlanmıyorsa thread 
    uyutulmaktadır. Thread uykudan uyandırıldığında tıpkı koşul değişkenlerinde olduğu gibi yeniden koşula bakılmakta eğer koşul 
    sağlanmıyorsa thread yeniden uyutulmaktadır. wait_event makrosunun geri döndürdüğü bir değer yoktur. wait_event makrosu şöyle 
    çalışmaktadır:

    1) Makro önce koşula bakar, koşul zaten sağlanıyorsa hemen işlemini sonlandırır.
    2) Eğer koşul sağlanmıyorsa thread çalışma kuyruğundan çıkartılıp bekleme kuyruğuna yerleştirilir.
    3) Thread uyandırıldığında aslında çalışma yine wait_event makrosunun içerisinden devam edecektir. Bu noktada makro yeniden 
    koşula bakar, koşulu sağlamayan thread'leri yeniden uyutur.

    Burada en çok tereddüt edilen nokta koşulun ne işe yaradığıdır. wake_up makroları izleyen paragraflarda da göreceğimiz gibi 
    yalnızca koşulu sağlayan thread'leri uyandıramamaktadır. Böyle bir mekanizmanın etkin bir biçimde oluşturulması da mümkün 
    değildir. Bu nedenle wake_up makroları koşula bakmaksızın bekleme kuyruğundaki birden fazla thread'i uyandırır. Uyanan 
    thread'lerin kendileri koşula bakmaktadır.

    wait_event_interruptible makrosunun wait_event makrosundan farkı eğer thread uyutulmuşsa uykudan bir sinyalle uyandırılabilmesidir. 
    Halbuki wait_event ile uykuya dalmış olan thread sinyal oluşsa bile uykudan uyandırılmamaktadır. wait_event_killable ile thread 
    uykuya dalındığında ise yalnızca SIGKILL sinyali ile thread uykudan uyandırılabilmektedir. Tabii programcı wait_event_interruptible
    makrosunun geri dönüş değerine bakmalı, eğer thread sinyal dolayısıyla uykudan uyandırılmışsa -ERESTARTSYS değeriyle kendi 
    fonksiyonundan geri dönmelidir. wait_event_interruptible makrosu eğer sinyal dolayısıyla uyanmışsa -ERESTARTSYS değeri ile, 
    koşul sağlandığından dolayı uyanmışsa 0 değeri ile geri dönmektedir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    if (wait_event_interruptible(g_wq, g_flag != 0) != 0)
        return -ERESTARTSYS;

    Bu tür durumlarda koşulda kullanılan değişkenleri atomic olarak tanımlama iyi bir tekniktir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    static atomic_t g_flag = ATOMIC_INIT(0);
    ...

    if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0)
        return -ERESTARTSYS;

    wait_event_interruptible_exclusive (bunun interrutible olmayan biçimi yoktur) makrosu Linux çekirdeklerine 2.6'nın belli 
    sürümünden sonra sokulmuştur. Yine bu makroyla birlikte aşağıda ele alınan wake_up_xxx_nr makroları da eklenmiştir. Bir 
    prosesin exclusive olarak wait kuyruğuna yerleştirilmesi onlardan belli sayıda olanların uyandırılabilmesini sağlamaktadır.

    Tabii wait_event makroları o andaki thread'i çizelgeden (yani run kuyruğundan) çıkartıp wait kuyruğuna yerleştirdikten 
    sonra "bağlamsal geçiş (context switch)" işlemini de yapmaktadır. Bağlamsal geçiş işlemi sonrasında artık çalışma kuyruğundaki 
    yeni bir thread CPU'ya atanarak çalıştırılır.

    wait_event makrolarının temsili kodunu şöyle düşünebilirsiniz:

    while (koşul_sağlanmadığı_sürece) {
        <thread'i bekleme kuyruğuna ekle>
        ---> <thread uyandırıldığında buradan çalışmaya devam eder>
    }

    Eski çekirdeklerde (yenilerinde de önemli değişiklik yoktur) wait_event makrosu şöyle yazılmıştır:

   #define __wait_event(wq, condition)                 \
    do {                                            \
        wait_queue_t __wait;                        \
        init_waitqueue_entry(&__wait, current);        \
                                                    \
        add_wait_queue(&wq, &__wait);                \
        for (;;) {                                    \
            set_current_state(TASK_UNINTERRUPTIBLE);        \
            if (condition)                            \
                break;                                \
            schedule();                                \
        }                                            \
        current->state = TASK_RUNNING;                \
        remove_wait_queue(&wq, &__wait);            \
    } while (0)

    #define wait_event(wq, condition)                 \
    do {                                            \
        if (condition)                                 \
            break;                                    \
        __wait_event(wq, condition);                \
    } while (0)

    Burada uyandırılan thread aslında schedule fonksiyonunun içerisinde çalışmaya devam edecekir. Koddan da gördüğünüz gibi akış
    schedule fonksiyonundan çıktığında döngü başa saracak ve yeniden koşul kontrol edilecektir.

    Bekleme kuyruğunda blokede bekletilen thread'ler wake_up makrolarıyla uyandırılmaktadır. Uyandırılmaktan kastedilen şey 
    thread'in bekleme kuyruğundan çıkartılıp yeniden çalışma kuyruğuna (run queue) yerleştirilmesidir. wait_event makrolarındaki 
    koşula wake_up bakmamaktadır. wake_up makroları yalnızca thread'i bekleme kuyruğundan çıkartıp çalışma kuyruğuna taşımaktadır. 
    Koşula uyandırılmış thread'in kendisi bakmaktadır. Eğer koşul sağlanmıyorsa thread yeniden uyutulmaktadır. Yani biz koşulu 
    sağlanır duruma getirmeden wake_up işlemi yaparsak thread yeniden uykuya dalacaktır. (Zaten yukarıda da belirttiğimiz gibi 
    yalnızca "koşulu sağlayan thread'i uyandırması" mümkün değildir.)

    En çok kullanılan wake_up makroları şunlardır:

    wake_up(wq_head);
    wake_up_nr(wq_head, nr);
    wake_up_all(wq_head);
    wake_up_interruptible(wq_head);
    wake_up_interruptible_nr(wq_head, nr);
    wake_up_interruptible_all(wq_head);

    Bu makroların hepsi birinci parametre olarak bekleme kuyruğunun adresini almaktadır. Bu makroların çalışmasının anlaşılması 
    için bekleme kuyrukları hakkında biraz ayrıntıya girmek gerekir. Bekleme kuyruğunu temsil eden wait_queue_head_t yapısı şöyle 
    bildirilmiştir:

    struct wait_queue_head {
        spinlock_t lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    Görüldüğü gibi bu bir bağlı listedir. Bağlı liste spinlock ile korunmaktadır. Bu bağlı listenin düğümleri wait_queue_entry
    yapılarından oluşmaktadır.

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    Bu yapının ayrıntısına girmeyeceğiz. Ancak yapıdaki flags elemanına dikkat ediniz. Bekleme kuyruğuna yerleştirilen bir 
    thread'in exclusive bekleme yapıp yapmadığı (yani wait_event_intrerruptible_exclusive ile bekleme yapıp yapmadığı)
    bu flags elemanında saklanmaktadır. Bu wait kuyruğunun bekleyen thread'leri (onların task_struct adreslerini) tutan
    bir bağlı liste olduğunu varsayabilirsiniz. (Yapının private elemanı thread'leri temsil eden task_struct yapı nesnelerinin 
    adreslerini tutmaktadır.) Yani bekleme kuyrukları aşağıdaki gibi düşünülebilir:

    T1 ---> T2 ---> T3 ---> T4 ---> T5 ---> T6 ---> T7 ---> T8 ---> NULL

    Bu thread'lerden bazıları exclusive bekleme yapmış olabilir. Bunları (E) ile belirtelim:

    T1 ---> T2 ---> T3 ---> T4(E) ---> T5 ---> T6(E) ---> T7 ---> T8(E) ---> NULL

    Artık wake_up makrolarını açıklayabiliriz. wake_up makrosu kuyruğun başından itibaren ilk exclusive bekleme yapan thread'e 
    kadar bu thread de dahil olmak üzere tüm thread'leri uyandırmaktadır. Tabii bu thread'lerin hepsi uyandırıldıktan sonra 
    ayrıca koşula da bakacaktır. Örneğimizde wake_up makrosu çağrıldığında T1, T2, T3 ve T4 thread'leri uyandırılacaktır. 
    Görüldüğü gibi wake_up makrosu aslında 1 tane exclusive thread uyandırmaya çalışmaktadır. Ancak onu uyandırırken kuyruğun 
    önündeki exclusive olmayanları da uyandırmaktadır. Tabii bu anlatımdan anlaşılacağı gibi wake_up makrosu eğer kuyrukta hiç 
    exclusive bekleme yapan thread yoksa thread'lerin hepsini uyandırmaktadır.

    wake_up_nr makrosu, wake_up makrosu gibi davranır ancak 1 tane değil en fazla nr parametresiyle belirtilen sayıda exclusive 
    thread'i uyandırmaya çalışır. Başka bir deyişle wake_up(g_wq) çağrısı ile wake_up_nr(g_qw, 1) çağrısı aynı anlamdadır.
    Eğer yukarıdaki örnekte wake_up_nr(g_wq, 2) çağrısını yapmış olsaydık T1, T2, T2, T4, T5, T6 thread'leri uyandırılırdı. 
    Tabii yukarıda da belirttiğimiz gibi bu thread'lerin uyandırılmış olması wait_event makrolarından çıkılacağı anlamına gelmemektedir. 
    Uyandırma işleminden sonra koşula yeniden bakılmaktadır.

    wake_up_all makrosu bekleme kuyruğundaki tüm exclusive thread'leri ve exclusive olmayan thread'leri yani kısaca tüm thread'leri 
    uyandırmaktadır. Tabii yine uyanan thread'ler koşula bakacaktır.

    wake_up_interruptible, wake_up_interruptible_nr ve wake_up_interruptible_all makroları interruptible olmayan makrolar 
    gibi çalışmaktadır. Ancak bu makrolar bekleme kuyruğunda yalnızca "interruptible" wait_event fonksiyonlarıyla bekletilmiş 
    thread'lerle ilgilenmektedir. Diğer thread'ler kuyrukta yokmuş gibi davranmaktadır.

    wake_up makroları birden fazla thread'i uyandırabildiğine göre uyanan thread'lerin yeniden uykuya dalması gerekebilir. 
    Çünkü programcı yalnızca bir thread'in çalışmaya devam etmesini isteyebilir. Bu durumda tıpkı kullanıcı modundaki koşul 
    değişkenlerindeki gibi bir kalıp kullanılabilir:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread gelir */

    mutex_unlock(&g_mutex);

    Burada birden fazla thread uyandırıldığında bunlardan yalnızca biri mutex kilidini alarak kritik koda girmektedir. Eğer 
    kritik kod içerisinde koşul sağlanmaz hale getirilirse bu durumda diğer thread'ler while döngüsü nedeniyle yeniden uykuya 
    dalacaktır.

    Örneğin boru aygıt sürücüsünde okuma yapan thread'ler eğer boruda hiç byte yoksa bloke olmalıdır. O halde buradaki koşul 
    g_count > 0 olmalıdır. Boruya yazan thread g_count değerini güncelledikten sonra eğer g_count önceden sıfırsa wake_up 
    makrolarıyla bekleyen thread'leri uyandırır. Thread'ler uyandıktan sonra yukarıdaki while döngüsünde bunlardan yalnızca 
    biri mutex kildini alır. Mutex kilidini alan thread'de borudan okuma yapar. Eğer okuma sonucunda g_count hala > 0 durumunda
    ise başka bir therad daha okuma yapacaktır. Ta ki g_count değeri 0 olana kadar. Bu durumda diğer thread'ler boruya yeni 
    bir yazma yapılana kadar blokede bekleyeceklerdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücümüzün read ve write fonksiyonları aşağıdaki gibi olsun:

    wait_queue_head_t g_wq;
    atomic_t g_flag;
    ...

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver write...\n");

        atomic_set(&g_flag, 1);
        wake_up_interruptible(&g_wq);

        return 0;
    }

    Burada eğer birden fazla thread read yaparsa exclusive olmayan bir biçimde bekleme kuyruğunda bekleyecektir. write işleminde
    wake_up_interruptible makrosu ile uyandırma yapıldığına dikkat ediniz. Bekleme kuyruğunda exclusive bekleyen thread 
    olmadığına göre burada tüm read yapan thread'ler uyandırılacaktır. Onların koşulları sağlandığı için hepsi read fonksiyonundan
    çıkacaktır. Şimdi bu read fonksiyonunda exclusive bekleme yapmış olalım:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    Artık write fonksiyonunda wake_up makrosu çağrıldığında yalnızca bir tane exclusive bekleme yapan thread uyandırılacağı 
    için read fonksiyonundan yalnızca bir thread çıkacaktır. Test için aşağıdaki kodları kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Birden fazla thread'in uyandırıldığı durumda bunların yalnızca bir tanesinin kritik koda girmesini sağlayan kalıbı 
    anımsayınız:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread  gelir */

    mutex_unlock(&g_mutex);

    Aşağıdaki kodda bu kalıp uygulanmıştır. Böylece her write işlemi yapıldığında yalnızca tek bir thread gerçek anlamda uyanıp
    kritik koda girecektir. Aygıt sürücünün read ve write fonksiyonları aşağıda verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

/* wait-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Wait-Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static wait_queue_head_t g_wq;
static atomic_t g_flag;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "wait-driver module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "wait-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "wait-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver read...\n");

    atomic_set(&g_flag, 0);
    if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
        printk(KERN_INFO "Signal occurred...");
        return -ERESTARTSYS;
    }

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver write...\n");

    atomic_set(&g_flag, 1);
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* blocking-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static int g_flag;
static wait_queue_head_t g_wq;
static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "blocking-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "blocking-driver")) < 0) {
        printk(KERN_ERR "cannot #include <asm/atomic.h> register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "blocking-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "blocking...\n");

    g_flag = 0;

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (g_flag == 0) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, g_flag != 0) < 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
        printk(KERN_INFO "waking up...\n");
    }
    g_flag = 0;
    printk(KERN_INFO "enters critical section...\n");

    mutex_unlock(&g_mutex);

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wake up...\n");
    g_flag = 1;
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                141. Ders 12/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Daha önce görmüş olduğumuz mutex, semaphore, read/write kilitleri gibi 
    senkronizasyon nesnelerinin kendilerinin oluşturduğu bekleme kuyrukları vardır. Bu senkronizasyon nesneleri bloke oluşturmak
    için kendi bekleme kuyruklarını kullanmaktadır. Çekirdek kodları içerisinde bu senkronizasyon nesneleri için oluşturulmuş 
    bekleme kuyruklarını görebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yapmış olduğumuz boru örneğimizi gerçek bir boru haline getirelim. Yani eğer boruda en az 1 byte boş 
    alan kalmadıysa read fonksiyonu blokede en az 1 byte okuyana kadar beklesin. Eğer boruda tüm bilgileri yazacak kadar boş 
    yer kalmadıysa bu kez de yazan taraf blokede beklesin. Burada izlenecek temel yöntem aslında kursumuzda "koşul değişkenleri 
    (condition variable)" denilen senkronizasyon nesnelerindeki yöntemin aynısı olmalıdır. Okuyan thread kuyruktaki byte sayısını 
    belirten g_count == 0 olduğu sürece bekleme kuyruğunda beklemelidir. Tabii bizim kuyruk üzerinde işlem yaptığımız kısımları 
    senkronize etmemiz gerekir. Bunu da bir binary semaphore nesnesi ya da mutex nesnesi ile sağlayabiliriz. Semaphore nesnesini 
    ve bekleme kuyruğunu aşağıdaki gibi yaratabiliriz:

    static wait_queue_head_t g_wq;
    DEFINE_SEMAPHORE(g_sem);

    Okuyan taraf önce semaphore kilidini eline almalı ancak eğer uykuya dalacaksa onu serbest bırakıp uykuya dalmalıdır. Kuyruk 
    üzerinde aynı anda işlemler yapılabileceği için tüm işlemlerin kritik kod içerisinde ele alınması uygun olur. O halde read 
    işlemindeki bloke olmanın tipik çatısı şöyle oluşturulabilir:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruktan okuma işlemleri

    up(&g_sem);

    Burada önce down_interruptible fonksiyonu ile semaphore kilitlenmeye çalışılmıştır. Eğer semaphore zaten kilitliyse semaphore'un 
    kendi bekleme kuyruğunda thread uykuya dalacaktır. Daha sonra g_count değerine bakılmıştır. Eğer g_count değeri 0 ise önce 
    semaphore serbest bırakılıp sonra thread bekleme kuyruğunda uyutulmuştur. Thread bekleme kuyruğundan uyandırıldığında yeniden 
    semaphore kontrolünü ele almaktadır. Tabii eğer birden fazla thread bekleme kuyruğundan uyandırılırsa yalnızca bunlardan biri 
    semaphore kontrolünü ele alacaktır. Semaphore kilidini alan thread bundan sonra kuyruktan bilgiler okunacak ve semaphore 
    kilidini serbest bırakılacaktır. Eğer birden fazla thread bekleme kuyruğundan uyanmışsa bu kez diğer bir thread semaphore 
    kontrolünü ele alacak ve g_count değerine bakacaktır. Yukarıda da belirttiğimiz gibi aslında bu bir "koşul değişkeni" kodu 
    gibidir. Çekirdek içerisinde böyle bir nesne olmadığı için manuel uygulanmıştır.

    Benzer biçimde write işleminin de çatısı aşağıdaki gibidir:

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruğa yazma işlemleri

    up(&g_sem);

    Burada benzer işlemler uygulanmıştır. Eğer kuyrukta yazma yapılmak istenen kadar boş alan varsa akış while döngüsünün 
    içerisine girmeyecektir. (Buradaki while koşulunun "PIPE_BUFFER_SIZE - g_count < size" biçiminde olduğuna dikkat ediniz.) 
    Dolayısıyla yazma işlemi kritik kod içerisinde yapılabilecektir. Ancak kuyrukta yeteri kadar yer yoksa semaphore kilidi 
    serbest bırakılıp thread bekleme kuyruğunda bekletilecektir. Çıkışta benzer işlemler yapılmaktadır.

    Aslında burada spinlock nesneleri de kullanılabilir. Ancak zaten mutex, semaphore ve read/write lock nesneleri kendi içerisinde 
    bir miktar spin yapmaktadır. Spinlock için şu durumları gözden geçirmelisiniz:

    - Spinlock nesnesinde bekleme CPU zamanı harcanarak meşgul bir döngü içerisinde yapılmaktadır. Dolayısıyla spinlock nesneleri 
    kilidin kısa süreli bırakılacağından emin olunabiliyorsa kullanılmalıdır.

    - Spinlock içerisinde bağlamsal geçiş kapatılmakta ve sinyal işlemleri de bekletilmektedir. Yani spinlock beklemelerinin 
    "interruptible" bir biçimi yoktur.

    Örneğimizde kilitli kalınan kod miktarı dikkate alındığında semaphore ya da mutex nesnelerinin kullanılmasının daha uygun 
    olacağı söylenebilir.

    Burada yazma işlemleri için "yazma bekleme kuyruğu" ve okuma işlemleri için "okuma bekleme kuyruğu" biçiminde iki bekleme
    kuyruğu olduğuna dikkat ediniz. Çünkü yazan taraf okuma bekleme kuyruğundaki thread'leri okuyan taraf ise yazma bekleme 
    kuyruğundaki thread'leri uyandırmak isteyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int n_readers;
static int n_writers;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver opened...\n");

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver closed...\n");

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda vermiş olduğumuz blokeli boru aygıt sürücüsü örneği UNIX/Linux sistemlerinde bulunan isimli borulara oldukça 
    benzemektedir. Ancak UNIX/Linux sistemlerindeki isimli boruların yukarıdaki aygıt sürücümüzde olmayan şu ek özellikleri 
    vardır:

    - Anımsanacağı gibi isimli boruyu bir prosesin thread'i O_RDONLY bayrağı ile okuma amaçlı açmak istediğinde eğer bu 
    boruyu herhangi bir prosesin thread'i O_WRONLY bayrağı ile yazma amaçlı açmamışsa okuma amaçlı açmaya çalışan thread boru 
    yazma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Benzer biçimde bir thread isimli boruyu O_WRONLY bayrağı 
    ile yazma amaçlı açmak istediğinde bu boruyu herhangi bir prosesin thread'i O_RDONLY bayrağı ile okuma modunda açmamışsa 
    yazma amaçlı açmaya çalışan thread boru okuma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Bizim aygıt 
    sürücümüzde böyle bir özellik yoktur.

    - İsimli borularda boru boşken okuma yapılmak istendiğinde eğer boruya yazma yapma potansiyelinde hiçbir thread kalmamışsa
    read fonksiyonu blokeye yol açmamakta 0 ile geri dönmektedir. Zaten boru haberleşmesi bu biçimde sonlandırılır. Yani boruya 
    yazan taraf önce boruyu kapatır. Borudan okuyan taraf borudakileri okur. Eğer boruda hiçbir şey kalmazsa read fonksiyonu 
    0 ile geri döner. Okuyan taraf da döngüden çıkarak işlemini sonlandırır. Bizim yukarıdaki boru aygıt sürücümüzde bu özellik 
    yoktur.

    - İsimli borularda borudan okuma yapma potansiyelinde olan hiçbir thread yoksa boruya yazma yapıldığında SIGPIPE sinyali 
    oluşturulmaktadır. Bu sinyal de ele alınmadıysa yazma yapan prosesin sonlanmasına yol açar. Bizim boru aygıt sürücümüzde
    de bu özellik yoktur.

    Peki bu özellikler nasıl sağlanabilir? Bizim open fonksiyonunda bloke oluşturabilmemiz için boruya yazma potansiyelinde 
    olan ve borudan okuma yapma potansiyelinde olan kaç thread'in bulunduğunu tutmamız gerekir. Tüm prosesler aygıt sürücüyü 
    açtığına göre bu işlem aygıt sürücünün open fonksiyonunda ve release fonksiyonunda yapılabilir. Dosya open fonksiyonu 
    ile açıldığında filp parametresinin gösterdiği yerdeki file nesnesinin f_flags elemanı open fonksiyonunda kullanılan açma
    bayrağını belirtmektedir. Biz de iki sayaç alıp kaç thread'in okuma amaçlı kaç thread'in yazma amaçlı olarak boruyu açtığını
    tutabiliriz.

    Aşağıdaki örnekte boru aygıt sürücümüzün yukarıdaki belirtilen eksiklikleri giderilmiştir. Burada aygıt sürücünün open 
    fonksiyonunda bloke işlemi şöyle sağlanmıştır:

    static int pipe_driver_open(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY) {
            ++g_nreaders;
            wake_up_interruptible(&g_writeopen);
            while (g_nwriters == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_readopen, g_nwriters > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }
        else if (accmode == O_WRONLY) {
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            while (g_nreaders == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_writeopen, g_nreaders > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }

        else if (accmode == O_RDWR) {
            ++g_nreaders;
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            wake_up_interruptible(&g_writeopen);
        }
        up(&g_sem);

        return 0;
    }

    Aygıt dosyasının hangi bayrakla açıldığının belirlenmesi için filp göstericisinin gösterdiği yerdeki file nesnesinin 
    f_ops elemanına bakılmıştır. Bu elemanın ilk 2 biti dışındaki bitleri başka bayraklarla ilgili olduğu için önce ilk 
    2 bit maskelenmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    Sonra eğer aygıt dosyası yazma amaçlı açılmışsa okuma amaçlı açış yapılmış mı diye, okuma amaçlı açılmışsa yazma amaçlı
    açış var mı diye bakılmıştır. Kodumuzda open fonksiyonunda bloke oluşturmak için iki ayrı bekleme kuyruğunun daha yaratıldığını 
    görüyorsunuz. Aygıt sürücümüzün release fonksiyonunda bu sayaçlar aşağıdaki gibi eksiltilmiştir:

    static int pipe_driver_release(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY)
            --g_nreaders;
        else if (accmode == O_WRONLY)
            --g_nwriters;
        else if (accmode == O_RDWR) {
            --g_nreaders;
            --g_nwriters;

        }
        up(&g_sem);

        printk(KERN_INFO "pipe-driver closed...\n");

        return 0;
    }

    Aygıt sürücümüzün read fonksiyonunda eğer boruya yazma potansiyelinde olan hiçbir thread kalmamışsa read fonksiyonu 0 ile 
    geri döndürülmüştür:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }
    ...

    Benzer biçimde aygıt sürücümüzün write fonksiyonunda eğer borudan okuma yapma potansiyelinde hiçbir thread kalmamışsa 
    SIGPIPE sinyali oluşturulmuştur:

    ...
    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }
    ...

    Aygıt sürücümüzün release fonksiyonunda da sayaçlar eksiltilmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    Aşağıda örnek bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe_driver-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe_driver-char-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }

    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;

    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                142. Ders 24/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bekleme kuyrukları wait_queue_entry isimli yapı nesnelerinden oluşan bir çift bağlı listedir. wait_queue_head_t 
    yapısı da bağlı listenin ilk ve son elemanlarının adresini tutmaktadır:

    wait_queue_head_t <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry ...

    Çekirdek kodlarında bu yapılar "include/linux/wait.h" dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct wait_queue_head {
        spinlock_t    lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    wait_queue_head yapısının içerisindeki list_head elemanı bağlı listenin ilk ve son elemanlarının adreslerini tutmaktadır. 
    Yapının lock elemanı ise bekleme kuyruğuna erişirken kullanılacak olan spinlock nesnesini belirtmektedir. Biz burada 
    wait_queue_entry yapısının ayrıntılarına girmeyeceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz aygıt sürücü kodumuzda o anda quanta süresini bırakıp çizelgeleyicinin kendi algortimasına göre sıradaki thread'i 
    çizelgelemesini sağlayabiliriz. Bunun için schedule isimli çekirdek fonksiyonu kullanılmaktadır. Bu fonksiyon bloke 
    oluşturmamaktadır. Yalnızca thread'ler arası geçiş (context switch) oluşturmaktadır. schedule fonksiyonu herhangi bir 
    parametre almamaktadır:

    #include <linux/kernel.h>

    void schedule(void);

    Tabii koşullara bağlı olarak biz schedule fonksiyonunu çağırmış olsak bile işletim sistemi başka bir thread olmadığı için 
    ya da thread önceliklerinden dolayı yine bizim thread'imizi çizelgeleyebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları export edilmiş birkaç fonksiyon çağrılarak yazılmıştır. Dolayısıyla wait_event fonksiyonlarını 
    çağırmak yerine programcı daha aşağı seviyeli (zaten wait_event fonksiyonlarının çağırmış olduğu) fonksiyonları çağırabilir. 
    Yani bu işlemi daha aşağı seviyede manuel de yapabilir. Prosesin manuel olarak wait kuyruğuna alınması prepare_to_wait ve 
    prepare_to_wait_exclusive isimli fonksiyonlar tarafından yapılmaktadır:

    #include <linux/wait.h>

    void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
    void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);

    Bu fonksiyonların birinci parametreleri bekleme kuyruğu nesnesinin adresini, ikinci parametreleri bu kuyruğa yerleştirilecek 
    wait_queue_entry nesnesinin adresini almaktadır. Fonksiyonların üçüncü parametreleri TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE 
    biçiminde geçilebilir. Bir wait_queue_entry nesnesi şöyle oluşturulabilir:

    DEFINE_WAIT(wqentry);

    Ya da açıkça tanımlanıp init_wait makrosuyla ilk değerlenebilir. Örneğin:

    struct wait_queue_entry wqentry;
    ...
    init_wait(&wqentry);

    DEFINE_WAIT makrosu global tanımlamalarda kullanılamamaktadır. Çünkü bu makro küme parantezleri içerisinde sabit ifadesi olmayan 
    ifadeler barındırmaktadır. Ancak makro yerel tanımlamalarda kullanılabilir.

    Aslında prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları bekleme kuyruğuna bir wait_queue_entry nesnesi eklemektedir. 
    Yani programcının bunun için yeni bir wait_queue_entry nesnesi oluşturması gerekmektedir. prepare_to_wait_exclusive fonksiyonu 
    exclusive uyuma için kullanılmaktadır.

    prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları şunları yapmaktadır:

    1) Thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştirir. (Çalışma kuyruğunun organizasyonu ve bu işlemin gerçek 
    ayrıntıları biraz karmaşıktır. Biz burada çalışma kuyruğunun organizasyonu üzerinde durmayacağız.)
    2) Thread'in durum bilgisini (task state) state parametresiyle belirtilen duruma çeker.
    3) prepare_to_wait fonksiyonu kuyruk elemanını exclusive olmaktan çıkartırken, prepare_to_wait_exclusive onu exclusive yapar.

    Thread'in çalışma kuyruğundan bekleme kuyruğuna aktarılması onun uykuya dalması anlamına gelmemektedir. Programcı artık thread 
    çalışma kuyruğunda olmadığına göre schedule fonksiyonu ile thread'ler arası geçiş (context switch) uygulamalı ve akış kontrolünü 
    başka bir thread'e bırakmalıdır. Zaten thread'in çalışma kuyruğundan çıkartılması artık yeniden çalışma kuyruğuna alınmadıktan 
    sonra uykuda bekletilmesi anlamına gelmektedir.

    Tabii biz prepare_to_wait ya da prepare_to_wait_exclusive fonksiyonlarını çağırdıktan sonra bir biçimde koşul durumuna bakmalıyız. 
    Eğer koşul sağlanmışsa hiç prosesi uykuya daldırmadan hemen bekleme kuyruğundan çıkarmalıyız. Eğer koşul sağlanmamışsa gerçekten 
    artık schedule fonksiyonuyla "thread'ler arası geçiş" uygulamalıyız. Thread'imiz schedule fonksiyonunu çağırdıktan sonra artık 
    uyandırılana kadar bir daha çizelgelenmeyecektir. Bu da bizim uykuya dalmamız anlamına gelmektedir.

    Peki thread'imiz uyandırıldığında nereden çalışmaya devam edecektir? İşte schedule fonksiyonu thread'ler arası geçiş yaparken 
    kalınan yeri thread'e ilişkin task_struct yapısının içerisine kaydetmektedir. Kalınan yer schedule fonksiyonunun içerisinde 
    bir yerdir. O halde thread'imiz uyandırıldığında schedule fonksiyonunun içerisinden çalışmaya devam edecektir. Sonra schedule 
    fonksiyonu geri dönecek ve thread akışı devam edecektir.

    wake_up fonksiyonları thread'i bekleme kuyruklarından çıkartıp çalışma kuyruğuna eklemektedir. Ancak prepare_to_wait ve 
    prepare_to_wait_exclusive fonksiyonları çağrıldıktan sonra eğer koşulun zaten sağlandığı görülürse bu durumda uyandırma 
    wake_up fonksiyonlarıyla yapılmadığı için bekleme kuyruğundan thread'in geri çıkartılması da programcının sorumluluğundadır. 
    Bu işlem finish_wait fonksiyonu ile yapılmaktadır.

    #include <linux/wait.h>

    void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

    Bu fonksiyon zaten thread wake_up fonksiyonları tarafından bekleme kuyruğundan çıkartılmışsa herhangi bir işlem yapmaz. 
    Bu durumda manuel uyuma şöyle yapılabilir.

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_UNINTERRUPTIBLE);
    if (!condition)
        schedule();
    finish_wait(&wqentry);

    Tabii eğer thread INTERRUPTIBLE olarak uyuyorsa schedule fonksiyonundan çıkıldığında sinyal dolayısıyla da çıkılmış olabilir. 
    Bunu anlamak için signal_pending isimli fonksiyon çağrılır. Bu fonksiyon sıfır dışı bir değerle geri dönmüşse uyandırma 
    işleminin sinyal yoluyla yapıldığı anlaşılır. Bu durumda tabii aygıt sürücüdeki fonksiyon -ERESTARTSYS ile geri döndürülmelidir. 
    signal_pending fonksiyonunun prototipi şöyledir:

    #include <linux/kernel.h>

    int signal_pending(struct task_struct *p);

    Fonksiyon parametre olarak thread'e ilişkin task_struct yapısının adresini almaktadır. Bu durumda INTERRUPTIBLE uyuma aşağıdaki 
    gibi yapılabilir:

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_INTERRUPTIBLE);
    if (!condition)
        schedule();
    if (signal_pending(current))
        return -ERESTARTSYS;
    finish_wait(&wqentry);

    wake_up makrolarının şunları yaptığını anımsayınız:

    1) Wait kuyruğundaki prosesleri çıkartarak run kuyruğuna yerleştirir.
    2) Prosesin durumunu TASK_RUNNING haline getirir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                143. Ders 26/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları yukarıda açıkladığımız daha aşağı seviyeli fonksiyonlar kullanılarak gerçekleştirilmiştir. 
    Mevcut son Linux çekirdeğinde wait_event_interruptible makrosu şöyle yazılmıştır:

    #define wait_event_interruptible(wq_head, condition)                \
    ({                                                                    \
        int __ret = 0;                                                    \
        might_sleep();                                                    \
        if (!(condition))                                                \
            __ret = __wait_event_interruptible(wq_head, condition);        \
        __ret;                                                            \
    })

    Burada gcc'nin bileşik ifade de denilen bir eklentisi (extension) kullanılmıştır. Bu makro ayrıntılar göz ardı edilirse 
    __wait_event_interruptible makrosunu çağırmaktadır. Bu makro şöyle tanımlanmıştır:

    #define __wait_event_interruptible(wq_head, condition)                \
    ___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,            \
              schedule())

    Burada ___wait_event makrosunun interruptible olan ve olmayan kodların ortak makrosu olduğu görülmektedir. Bu 
    makro da şöyle tanımlanmıştır:

    #define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)        \
    ({                                                                            \
        __label__ __out;                                                        \
        struct wait_queue_entry __wq_entry;                                        \
        long __ret = ret;    /* explicit shadow */                                \
                                                                                \
        init_wait_entry(&__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);        \
        for (;;) {                                                                \
            long __int = prepare_to_wait_event(&wq_head, &__wq_entry, state);   \
                                                                                \
            if (condition)                                                        \
                break;                                                            \
                                                                                \
            if (___wait_is_interruptible(state) && __int) {                        \
                __ret = __int;                                                    \
                goto __out;                                                        \
            }                                                                    \
                                                                                \
            cmd;                                                                \
        }                                                                        \
        finish_wait(&wq_head, &__wq_entry);                                        \
    __out:    __ret;                                                                \
    })
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerimize arzu edersek "blokesiz (non-blocking)" okuma yazma desteği de verebiliriz. Tabii bu desteğin verilebilmesi
    için aygıt sürücünün okuma yazma sırasında bloke oluşturması gerekmektedir. Anımsanacağı gibi blokesiz işlem yapabilmek için 
    open POSIX fonksiyonunda fonksiyonun ikinci parametresine O_NONBLOCK bayrağı ekleniyordu. Normal disk dosyalarında O_NONBLOCK 
    bayrağının bir anlamı yoktur. Ancak boru gibi özel dosyalarda ve aygıt sürücülerde daha önceden de belirttiğimiz gibibu bayrak 
    şu anlama gelmektedir:

    1) Okuma sırasında eğer okunacak bir bilgi yoksa read fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner ve errno değeri 
    EAGAIN olarak set edilir.

    2) Yazma sırasında yazma eylemi meşguliyet yüzünden yapılamıyorsa write fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner 
    ve errno değeri yine EAGAIN olarak set edilir.

    Aygıt sürücü açıldığında open fonksiyonunun ikinci parametresi file yapısının (dosya nesnesinin) f_flags elemanına 
    yerleştirilmektedir. Dosya nesnesinin adresinin aygıt sürücüdeki fonksiyonlara filp parametresiyle aktarıldığını anımsayınız. 
    Bu durumda biz aygıt dosyasının blokesiz modda açılıp açılmadığını şöyle test edebiliriz:

    if (filp->f_flags & O_NONBLOCK) {        /* blokesiz modda mı açılmış */

        /* open fonksiyonunda aygıt O_NONBLOCK bayrağı ile açılmış */

    }

    Aygıt sürücümüz blokesiz modda işlemlere izin vermiyorsa biz bu durumu kontrol etmeyebiliriz. Yani böyle bir aygıt sürücüde 
    programcı aygıt sürücüyü O_NONBLOCK bayrağını kullanarak açmışsa bu durumu hiç dikkate almayabiliriz. (Örneğin disk dosyalarında
    blokesiz işlemlerin bir anlamı olmadığı halde Linux çekirdeği disk dosyaları O_NONBLOCK bayrağıyla açıldığında hata ile geri 
    dönmeden bayrağı dikkate almamaktadır.) Eğer bu kontrol yapılmak isteniyorsa aygıt sürücünün açılması sırasında kontrol 
    aygıt sürücünün open fonksiyonunda yapılabilir. Bu durumda open fonksiyonunu -EINVAL değeriyle geri döndürebilirsiniz. Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp)
    {
        if (filp->f_flags & O_NONBLOCK)
            return -EINVAL;

        return 0;
    }

    Peki boru aygıt sürücümüze nasıl blokesiz mod desteği verebiliriz? Aslında bunun için iki şeyi yapmamız gerekir:

    1) Yazma yapıldığı zaman boruda yazılanları alacak kadar yer yoksa aygıt sürücümüzün write fonksiyonunu -EAGAIN değeriyle 
    geri döndürmeliyiz. Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_BUFSIZE - g_count < size) {
        up(&g_sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_wqwrite, PIPE_BUFSIZE - g_count >= size))
            return -ERESTARTSYS;

        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    2) Okuma yapıldığı zaman eğer boruda hiç bilgi yoksa aygıt sürücümüzün read fonksiyonunu -EAGAIN değeriyle geri döndürmeliyiz.
    Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;

        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    read ve write fonksiyonlarının -EAGAIN değeriyle geri döndürülmeden önce aygıt dosyasının blokesiz modda açılıp açılmadığının
    kontrol edilmesi gerektiğine dikkat ediniz.

    Aşağıdaki örnekte boru aygıt sürücüsüne blokesiz okuma ve yazma desteği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                144. Ders 31/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri ve aygıt sürücüler dinamik bellek tahsis etmeye gereksinim duyabilirler. Ancak çekirdek modunda çalışan 
    programlar dinamik tahsisatları malloc, calloc ve realloc gibi standart C fonksiyonlarıyla yapamazlar. Çünkü bu fonksiyonlar 
    kullanıcı modundaki programlar tarafından kullanılacak biçimde prosesin bellek alanında tahsisat yapmak için tasarlanmışlardır. 
    Oysa çekirdeğin ayrı bir heap sistemi vardır. Bu nedenle çekirdek modülleri ve aygıt sürücüler çekirdeğin sunduğu fonksiyonlarla 
    çekirdeğin heap alanında tahsisat yapabilirler. Biz de bu bölümde çekirdeğin heap sistemi üzerinde tahsisatların nasıl 
    yapıldığı üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Linux sistemlerinde proseslerin bellek alanları sayfa tabloları yoluyla izole edilmiştir. Ancak çekirdek 
    tüm proseslerin sayfa tablosunda aynı yerde bulunmaktadır. Başka bir deyişle her prosesin sayfa tablosunda çekirdek hep 
    aynı sanal adreslerde bulunmaktadır. Örneğin sys_open sistem fonksiyonuna girildiğinde bu fonksiyonun sanal adresi her 
    proseste aynıdır.

    32 bit Linux sistemlerinde proseslerin sanal bellek alanları 3 GB kullanıcı (user), 1 GB çekirdek (kernel) olmak üzere 
    iki bölüme ayrılmıştır. 64 bit Linux sistemlerinde ise yalnızca sanal bellek alanının 256 TB'si kullanılmaktadır. Bu 
    sistemlerde kullanıcı alanı için 128 TB, çekirdek alanı için de 128 TB yer ayrılmıştır. 32 bit Linux sistemlerindeki 
    prosesin sanal bellek alanı şöyle gösterilebilir:

    00000000
    ...            USER ALANI (3 GB)
    C0000000
    ...            KERNEL ALANI (1 GB)

    64 bit Linux sistemlerindeki sanal bellek alanı ise kabaca şöyledir:

    0000000000000000
    ...                        USER ALANI (128 TB)
    0000800000000000
    ...                        BOŞ BÖLGE (yaklaşık 16M TB)
    FFFF800000000000
    ..                         KERNEL ALANI (128 TB)
    FFFFFFFFFFFFFFFF
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sistem fonksiyonunun çağrıldığını düşünelim. İşlemci kernel mode'a otomatik olarak geçirilecektir. Bu durumda sayfa 
    tablosu değişmeyecektir. Peki kernel nasıl tüm fiziksel belleğe erişebilmektedir? İşte 32 bitlik sistemlerde proseslerin 
    sayfa tablolarının son 1 GB'yi sayfalandırdığı girişleri tamamen fiziksel belleği eşlemektedir. Başka bir deyişle bu sistemlerde 
    çekirdek alanının başlangıcı olan C0000000 adresi aslında sayfa tablosunda 00000000 fiziksel adresini belirtmektedir. Böylece 
    kernel'ın herhangi bir fiziksel adrese erişmek için yapacağı tek şey bu adrese C00000000 değerini toplamaktır. Bu sistemlerde 
    C0000000 adresinden itibaren proseslerin sayfa tabloları zaten fiziksel belleği 0'dan itibaren haritalandırmaktadır. Ancak 
    32 bit sistemlerde şöyle bir sorun vardır: Sayfa tablosunda C0000000'dan itibaren sayfalar fiziksel belleği haritalandırdığına
    göre 32 bit sistemlerin maksimum sahip olacağı 4 GB fiziksel RAM'in hepsi haritalandırılamamaktadır. İşte Linux tasarımcıları 
    sayfa tablolarında C0000000'dan itibaren fiziksel RAM'in 1 GB'sini değil 896 MB'sini haritalandırmıştır. Geri kalan 128 MB'lik 
    sayfa tablosu alanı fiziksel RAM'de 896MB'nin ötesine erişmek için değiştirilerek kullanılmaktadır. Yani 32 bit sistemlerde 
    kernel fiziksel RAM'in ilk 896 MB'sine doğrudan ancak bunun ötesine sayfa tablosunun son 128 MB'lik bölgesini değiştirerek 
    erişmektedir. 32 bit sistemlerde 896 MB'nin ötesine dolaylı biçimde erişildiği için bu bölgeye "high memory zone" denilmektedir. 
    Tabii 64 bit sistemlerde böyle bir problem yoktur. Çünkü bu sistemlerde yine sayfa tablolarının kernel alanı fiziksel RAM'i 
    başından itibaren haritalandırmaktadır. Ancak 128 TB'lik alan zaten şimdiki bilgisayarlara takılabilecek fiziksel RAM'in 
    çok ötesindedir. Bu nedenle 64 bit sistemlerde "high memory zone" kavramı yoktur.

    Çekirdek kodların kernel alanın başlangıcı PAGE_OFFSET makrosuyla belirlenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz çekirdek modunda kod yazarken belli bir fiziksel adrese erişmek istersek onun sanal adresini bulmamız gerekir. Bu işin 
    manuel yapılması yerine bunun için __va isimli makro kullanılmaktadır. Biz bu makroya bir fiziksel adres veririz o da bize 
    o fiziksel adrese erişmek için gereken sanal adresi verir. Benzer biçimde bir sanal adresin fiziksel RAM karşılığını bulmak 
    için de __pa makrosu kullanılmaktadır. Biz bu makroya sanal adresi veririz o da bize o sanal adresin aslında RAM'deki hangi 
    fiziksel adres olduğunu verir. __va makrosu parametre olarak unsigned long biçiminde fiziksel adresi alır, o fiziksel adrese 
    erişmek için gerekli olan sanal adresi void * türünden bize verir. __pa makrosu bunun tam tersini yapmaktadır. Bu makro bizden 
    unsigned long biçiminde sanal adresi alır. O sanal adrese sayfa tablosunda karşı gelen fiziksel adresi bize verir.

    Çekirdek modunda RAM'in her yerine erişebildiğimize ve bu konuda bizi engelleyen hiçbir mekanizmanın olmadığına dikkat 
    ediniz. Dolayısıyla bir aygıt sürücüler içerisinde RAM'in istediğimiz kısmına erişip oratayı değiştirebiliriz. Ancak bu 
    durum kontrolsüz ve amaçsız bir biçimde yapılırsa bu olumsuzluktan tün sistem etkilenebilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeği için fiziksel RAM temel olarak 3 bölgeye (zone'a) ayrılmıştır:

    ZONE_DMA
    ZONE_NORMAL
    ZONE_HIGHMEM

    ZONE_DMA ilgili sistemde disk ile RAM arasında transfer yapan DMA'nın erişebildiği RAM alanıdır. Bazı sistemlerde DMA tüm 
    fiziksel RAM'in her yerine transfer yapamamaktadır. ZONE_NORMAL doğrudan çekirdeğin sayfa tablosu yoluyla haritalandırdığı 
    fiziksel bellek bölgesidir. 32 bit Linux sistemlerinde bu bölge RAM'in ilk 896 MB'sidir. Ancak 64 bit Linux sistemlerinde 
    bu bölge tüm fiziksel RAM'i içermektedir. ZONE_HIGHMEM ise 32 bit sistemlerde çekirdeğin doğrudan haritalandıramadığı 
    sayfa tablosunda değişiklik yapılarak erişilebilen fiziksel RAM alanıdır. 32 bit Linux sistemlerinde 896 MB'nin yukarısındaki 
    fiziksel RAM bölhesi ZONE_HIGHMEM alanıdır. Yukarıda da belirttiğimiz gibi 64 bit Intel işlemcilerinde ZONE_HIGHMEM biçiminde 
    bir alan zaten yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki programlarda kullandığımız malloc fonksiyonununda en fazla uygulanan tahsisat yöntemi "boş bağlı liste" 
    denilen yöntemdir. Bu yöntemde yalnızca boş alanlar bir bağlı listede tutulmaktadır. Dolayısıyla malloc gibi bir fonksiyon 
    bu bağlı listede uygun bir elemanı bağlı listeyi dolaşarak bulmaktadır. free fonksiyonu da tahsis edilmiş olan alanı bu boş 
    bağlı listeye eklemektedir. Tabii free fonksiyonu aynı zamanda bağlı listedeki komşu alanları da daha büyük bir boş alan 
    oluşturacak biçimde birleştirmektedir. Ancak bu klasik yöntem çekirdek heap sistemi için çok yavaş bir yöntemdir. Bu nedenle 
    çekirdek heap sistemlerinde daha hızlı çalışan tahsisat algoritmaları kullanılmaktadır.

    Eğer tahsis edilecek bloklar eşit uzunlukta olursa bu durumda tahsisat işlemi ve geri bırakma işlemi O(1) karmaşıklıkta 
    yapılabilir. Örneğin heap içerisindeki tüm blokların 16 byte uzunlukta olduğunu düşünelim. Bu durumda 16 byte'lık tahsisat 
    sırasında uygun bir boş alan aramaya gerek kalmaz. Bir bağlı liste içerisinde boş alanlar tutulabilir. Bu boş alanlardan 
    herhangi biri verilebilir. Tabii uygulamalarda tahsis edilecek alanların büyükleri farklı olmaktadır.

    İşte BSD ve Linux sistemlerinde kullanılan "dilimli tahsisat sistemi (slab allocator)" denilen tahsisat sisteminin anahtar 
    noktası eşit uzunlukta olan ve ismine "dilim (slab)" denilen blokların tahsis edilmesidir. Çekirdek içerisinde çeşitli 
    nesneler için o nesnelerin uzunluğuna ilişkin farklı dilimli tahsisat sistemleri oluşturulmuştur. Örneğin bir proses 
    yaratıldığında task_struct yapısı çekirdeğin heap alanında tahsis edilmektedir. İşte dilimli tahsisat sistemlerinden biri 
    (struct task_struct yapısının uzunluğu kadar dilim uzunluklarından oluşan sistemdir. Böylece pek çok çekirdek nesnesi 
    için ayrı dilimli tahsisat sistemleri oluşturulmuştur. Bu durumu özet olarak şöyle düşünebilirsiniz: Çekirdek sanki kendi 
    içerisindeki her veri yapısı için eşit uzunluklarda bloklardan oluşan farklı heap alanı kullanıyor gibidir. 

    Çekirdek içerisindeki veri yapıları için oluşturulmuş olan dilimli tahsisat sistemlerinin dışında ayrıca bir de genel 
    kullanım için blok uzunlukları 32, 64, 96, 128, 192, 256 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, ... biçiminde 
    olan farklı dilimli tahsisat sistemleri de bulundurulmuştur. Böylece çekirdek mod programcısı belli uzunlukta bir alan 
    tahsis etmek istediğinde bu uzunluğa en yakın fakat bu uzunluktan büyük bir dilimli tahsisat sistemini kullanır. Tabii 
    çekirdek modunda çalışam programcılar isterse kendi nesneleri için de o nesnelerin uzunluğu kadar yeni dilimli tahsisat 
    sistemleri de oluşturabilmektedir.

    Burada aklınıza "mademki dilimli tahsisat sistemi çok hızlı bir sistem" o halde neden kullanıcı modundaki malloc gibi 
    fonksiyonlar da aynı mantıkla çalışmıyor" sorusu aklınıza gelebilir. Bunun iki nedeni vardır:

    1) Bu sistem hızlı olmasına karşın bellek harcaması daha yüksektir. Örneğin bu sistemde 600 byte'lık bir tahsisat yapmak 
    istesek bunu 1024'lük dilimlerin bulunduğu sistemden yaparız. Bu da kullanılmayan boş alanlar oluşturur. 

    2) Eğer programcı kendi dilim sistemini oluşturcak olsa bunun da arayüz olarak kullanımı zor olmaktadır. 

    O halde bu dilimli tahsisat sistemi çekirdek için uygun ama kullanıcı modu için pek uygun bir sistem değildir. 

    Aslında dilimli tahsisat sisteminin hazırda bulundurduğu dilimler işletim sisteminin sayfa tahsisatı yapan başka bir tahsisat
    algoritmasından elde edilmektedir. Linux sistemlerinde sayfa temelinde tahsisat yapmak için kullanılan tahsisat sistemine
    "buddy allocator" denilmektedir. (CSD işletim sisteminde buna "ikiz blok sistemi" denilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modunda çekirdek alanında dinamik tahsisat yapmak için kullanılan en genel fonksiyon kmalloc isimli fonksiyondur. 
    Bu fonksiyon aslında parametresiyle belirtilen uzunluğa en yakın önceden yaratılmış olan dilimli tahsisat sisteminden dilim 
    vermektedir (yani blok tahsis etmektedir). Örneğin biz kmalloc fonksiyonu ile 100 byte tahsis etmek istesek 100 byte'lık 
    blokların bulunduğu önceden yaratılmış bir dilimli tahsisat sistemi olmadığı için kmalloc 128 byte'lık bloklara sahip dilimli 
    tahsisat sisteminden bir dilim tahsis ederek bize verecektir. Tabii bu örnekte 28 byte boşuna tahsis edilmiş olacaktır. Ancak 
    çekirdek tahsisat sisteminin amacı en uygun miktarda belleği tahsis etmek değil, talep edilen miktarda belleği daha hızlı 
    tahsis etmektir. kmalloc fonksiyonu ile tahsis edilen dilimler kfree fonksiyonu ile serbest bırakılmaktadır. Fonksiyonların 
    prototipleri şöyledir:

    #include <linux/slab.h>

    void *kmalloc (size_t size, int flags);
    void kfree (const void *objp);

    kmalloc fonksiyonunun birinci parametresi tahsis edilecek byte miktarını belirtir. İkincisi parametresi ise tahsis edilecek 
    zone ve tahsisat biçimi hakkında çeşitli bayrakları içermektedir. Bu ikinci parametre çeşitli sembolik sabitlerden oluşturulmaktadır. 
    Burada önemli birkaç bayrak şunlardır:

    GFP_KERNEL: Çekirdek alanı içerisinde normal tahsisat yapmak için kullanılır. Bu bayrak en sık bu kullanılan bayraktır. Burada 
    eğer RAM doluysa işletim sistemi prosesi bloke ederek swap işlemi ile yer açabilmektedir. Yani bu işlem sırasında akış çekirdek 
    modunda bloke olarak thread bekleme kuyruklarında bekletilebilir. Tahsisat işlemi ZONE_NORMAL alanından yapılmaktadır.

    GFP_NOWAIT: GFP_KERNEL gibidir. Ancak hazırda bellek yoksa thread uykuya dalmaz. Fonksiyon başarısız olur.

    GFP_HIGHUSER: 32 bit sistemlerde ZONE_HIGHMEM alanından tahsisat yapar.

    GFP_DMA: İlgili sistemde DMA'nın erişebildiği fiziksel RAM alanından tahsisat yapar.

    kmalloc fonksiyonu başarı durumunda tahsis edilen alanın sanal bellek adresiyle, başarısızlık durumunda NULL adresle geri
    dönmektedir. Çekirdek modülleri ve aygıt sürücüler dinamik tahsisat başarısız olursa tipik olarak -ENOMEM değerine geri 
    dönmelidir.

    kfree fonksiyonu ise daha önce kmalloc ile tahsis edilmiş olan alanın başlangıç adresini parametre olarak almaktadır.

    Aşağıda daha önce yapmış olduğumuz boru aygıt sürücüsündeki kuyruk sistemini kmalloc fonksiyonu ile tahsis edilip kfree
    fonksiyonu ile serbest bırakılmasına örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE       10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }

    if ((g_pipe = kmalloc(sizeof(struct PIPE), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;

EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kfree(g_pipe);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK) 
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {    
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;
    
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) 
        --g_nreaders;
    else if (accmode == O_WRONLY) 
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;    
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;
    
    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK) 
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail) 
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0) 
        goto EXIT;
    
    if (size2 != 0) 
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0) 
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    
    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head) 
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0) 
        goto EXIT;
    if (size2 != 0) 
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0) 
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return results;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY|O_NONBLOCK)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                145. Ders 02/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi istersek genel amaçlı kmalloc fonksiyonunu kullanmak yerine kendimiz de tam istediğimiz 
    büyüklükte dilimlere sahip olan yeni bir dilimli tahsisat sistemi yaratıp onu kullanabiliriz. Yeni bir dilimli tahsisat 
    sisteminin yaratılması kmem_cache_create fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/slab.h>

    struct kmem_cache *kmem_cache_create(const char *name, unsigned int size, 
            unsigned int align, slab_flags_t flags, void (*ctor)(void *));

    Fonksiyonun birinci parametresi yeni yaratılacak dilimli tahsisat sisteminin ismini belirtmektedir. (Bu isim sys dosya 
    sisteminde bir dizin biçimine görüntülenebilmektedir.) Burada dilimli tahsisat sistemine herhangi bir isim verilebilir. 
    Linux çekirdeğinde dilimli tahsisat sistemleri genellikle "xxx_cachep" biçiminde isimlendirilmektedir. İkinci parametre 
    dilimlerin büyüklüğünü belirtmektedir. Üçüncü parametre ise hizalama değerini belirtir. Bu hizalama değerine 0 geçilirse 
    default hizalama kullanılır. Varsayılan hizalama 32 bit sistemlerde 4 byte, 64 bit sistemlerde 8 byte'tır. Fonksiyonun 
    dördüncü parametresi yaratılacak dilimli tahsisat sistemine ilişkin bazı özelliklerin belirlenmesi için kullanılmaktadır. 
    Buradaki bayrakların önemli birkaç tanesi şöyledir:

    SLAB_NO_REAP: Fiziksel RAM'in dolması nedeniyle kullanılmayan dilimlerin otomatik olarak sisteme iade edileceği anlamına 
    gelir. Uç durumlarda bu bayrak kullanılabilir.

    SLAB_HWCACHE_ALIGN: Bu bayrak özellikle SMP sistemlerinde işlemci ya da çekirdeklerin cache alanları için hizalama yapılmasını
    sağlamaktadır. Yaratım sırasında bu parametreyi kullanabilirsiniz.

    SLAB_CACHE_DMA: Bu parametre DMA alanında (DMA zone) tahsisat için kullanılmaktadır. Daha önceden de belirttiğimiz gibi bazı 
    sistemlerde fiziksel RAM'ın ancak bazı bölglerine DMA tarafından erişilebilmektedir. 

    Fonksiyonun son parametresi dilim sistemi yaratıldığında çağrılacak callback fonksiyonu belirtmektedir. Bu parametre için 
    girilecek fonksiyon her yeni dilim tahsis edildiğinde çağrılmaktadır. Böylece yeni bir dilim tahsis edileceği zaman bu 
    fonksiyon içerisinde o dilime ilkdeğer verilebilir. Bu fonksiyona tahsis edilen dilimin başlangıç adresi geçirilmektedir. 
    Bu parametre NULL da geçilebilir. Bu durumda dilim tahsis edilirken herhangi bir fonksiyon çağrılmaz. kmem_cache_create 
    fonksiyonu başarı durumunda struct kmem_cache türünden bir yapı nesnesinin adresiyle, başarısızlık durumunda NULL adrese 
    geri dönmektedir. Başarısızlık durumunda aygıt sürücü fonksiyonunun -ENOMEM değeri ile geri döndürülmesi uygundur. Fonksiyon 
    şöyle kullanılabilir:

    struct kmem_cache *g_pipe_cachep;

    if ((g_pipe_cachep = kmem_cache_create("pipe_driver_cachep", 
            sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        ...
        return -ENOMEM;
    }

    Yaratılmış olan bir dilim sisteminden tahsisatlar kmem_cache_alloc fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi 
    şöyledir: 
    
    #include <linux/slab.h>

    void *kmem_cache_alloc(struct kmem_cache *cache, int flags);

    Fonksiyonun birinci parametresi yaratılmış olan dilim sisteminin handle değerini, ikinci parametresi ise yaratım bayraklarını 
    almaktadır. Bu bayraklar kmalloc fonksiyonundaki bayraklarla aynıdır. Yani örneğin bu parametreye GFP_KERNEL geçilebilir. 
    Fonksiyon başarı durumunda tahsis edilen dilimin sanal adresine, başarısızlık durumunda NULL adrese geri dönmektedir. 
    Başarısızlık durumunda aygıt sürücüdeki fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygundur. Örneğin:

    if ((g_pipe = (struct PIPE *)kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        ...
        return -ENOMEM;
    }

    kmem_cache_alloc fonksiyonu ile tahsis edilen dinamik alan kmem_cache_free fonksiyonu ile serbest bırakılabilir. Fonksiyonun
    prototipi şöyledir:

    #include <linux/slab.h>

    void kmem_cache_free(struct kmem_cache *cache, const void *obj);

    Fonksiyonun birinci parametresi dilim sisteminin handle değerini, ikincisi parametresi ise serbest bırakılacak dilimin 
    adresini belirtmektedir. Örneğin:

    kmem_cache_free(g_pipe_cachep, g_pipe);

    kmem_cache_create fonksiyonu ile yaratılmış olan dilim sistemi kmem_cache_destroy fonksiyonu ile serbest bırakılabilir. 
    Fonksiyonun prototipi şöyledir.

    #include <linux/slab.h>

    int kmem_cache_destroy(struct kmem_cache *cache);

    Fonksiyon dilim sisteminin handle değerini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    negatif errno değerine geri döner. Örneğin:

    kmem_cache_destroy(g_pipe);

    Peki kmalloc yerine yeni bir dilimli tahsisat sisteminin yaratılması tercih edilmeli midir? Yukarıda da belirttiğimiz
    gibi kmalloc fonksiyonu da aslında önceden yaratılmış belli uzunluktaki dilim sistemlerinden tahsisat yapmaktadır. Ancak 
    "çok sayıda aynı büyüklükte alanların" tahsis edildiği durumlarda programcının belli uzunlukta olan kendi dilim sistemini 
    yaratması, bunun  dışındaki durumlarda genel amaçlı kmalloc fonksiyonunu tavsiye edilmektedir. 

    Tabii kmalloc yerine yeni bir dilimli tahsisat sistemi yaratmanın anlamlı olması için çok sayıda aynı büyüklükte tahsisatın
    yapılıyor olması gerekir. Tek bir tahisat için ya da birkaç tahsisat için yeni bir dilimli tahsisat sistemi yaratmaya hiç 
    gerek yoktur. Doğrudan kmalloc fonksiyonu kullanılabilir. 
    
    Örneğin boru aygıt sürücümüzde yeni bir dilim sisteminin yaratılmasına hiç gerek yoktur. Çünkü zaten boru aygıt sürücüsünde 
    tek bir struct PIPE yapı nesnesi yaratılmaktadır. Ancak biz aşağıdaki bu dilimli tahsisat sistemlerinin nasıl kullanıldığına 
    bir örnek vermek için bu struct PIPE nesnesini kendi yarattığımız dilimli tahsisat sisteminden tahsis ediyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE       1024
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct kmem_cache *g_pipe_cachep;
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }
    if ((g_pipe_cachep = kmem_cache_create("pipe_cachep", sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        printk(KERN_ERR "cannot create pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }
    if ((g_pipe = (struct PIPE *)kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT4;
    }
    g_pipe->head = g_pipe->tail = g_pipe->count = 0;

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
EXIT4:
    kmem_cache_destroy(g_pipe_cachep);
EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kmem_cache_free(g_pipe_cachep, g_pipe);
    kmem_cache_destroy(g_pipe_cachep);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0)
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0)
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kmem_cache_create fonksiyonlarıyla yaratılmış olan dilimli tahsisat sistemlerini proc dosya sistemi ile görüntüleyebiliriz. 
    "/proc/slabinfo" dosyası çekirdek tarafından kullanılan yaratılmış dilimli tahsisat sistemleri hakkında bilgi vermektedir. 
    Ancak bu dosya bizim kmem_cache_create fonksiyonuyla yarattığımız dilimli tahsisat sistemlerini listelememektedir. sys 
    dosya sistemindeki "/sys/kernel/slab" dizini aygıt sürücülerin yaratmış oldukları da dahil olmak üzere bütün dilimli tahsisat 
    sistemleri hakkında bilgiler vermektedir. Burada her kmem_cache_create fonksiyonu ile yaratılmış olan dilimli tahsisat 
    sistemi için ayrı bir dizin bulunmaktadır. Ayrıca çekirdeğin kullandığı dilimli tahsisat sistemlerini canlı olarak görüntülemek 
    için "slabtop" isimli bir utility program da vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'un dosya sistemi için önemli üç yapı vardır. Bunlar file, dentry ve inode yapılarıdır. file isimli yapıya biz "dosya 
    nesnesi" demiştik. Anımsanacağı gibi ne zaman bir dosya açılsa dosya betimleyici tablosunda dosya betimleyicisi denilen 
    bir indeks bu dosya nesnesini gösterir duruma getirilmektedir. Dosya betimleyici tablosuna (file descriptor table) prosesi 
    temsil eden task_struct yapısından erişilmektedir. 

    task_struct ------> dosya betimleyici tablosu

    Dosya Betimleyici Tablosu
    --------------------------

    0 ----> dosya nesnesi (struct file)
    1 ----> dosya nesnesi (struct file)
    2 ----> dosya nesnesi (struct file)
    3 ----> dosya nesnesi (struct file)
    ...

    Dosya nesnesi "açık dosyaların bilgilerini" tutmaktadır. Ne zaman sys_open sistem fonksiyonu çağrılsa sys_open sistem 
    fonksiyonu yeni bir dosya nesnesini (struct file) yaratır, onun adresini dosya betimleyici tablosunda boş bir slota yazar. 
    Bu slotun indeks numarasını dosya betimleyicisi olarak geri döndürür. Aynı dosya ikinci kez kaçılsa bile yeni bir dosya nesnesi 
    (struct file nesnesi) yaratılmaktadır. Daha önce biz bu struct file yapısının içeriğini görmüştük. Bunu yeniden anımsatmak 
    istiyoruz:
   
    struct file {
        union {
            /* fput() uses task work when closing and freeing file (default). */
            struct callback_head     f_task_work;
            /* fput() must use workqueue (most kernel threads). */
            struct llist_node    f_llist;
            unsigned int         f_iocb_flags;
        };

        /*
        * Protects f_ep, f_flags.
        * Must not be taken from IRQ context.
        */
        spinlock_t                f_lock;
        fmode_t                    f_mode;
        atomic_long_t            f_count;
        struct mutex            f_pos_lock;
        loff_t                    f_pos;
        unsigned int            f_flags;
        struct fown_struct        f_owner;
        const struct cred        *f_cred;
        struct file_ra_state    f_ra;
        struct path                f_path;
        struct inode            *f_inode;    /* cached value */
        const struct file_operations    *f_op;
        u64            f_version;
    #ifdef CONFIG_SECURITY
        void            *f_security;
    #endif
        /* needed for tty driver, and maybe others */
        void            *private_data;

    #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct hlist_head    *f_ep;
    #endif /* #ifdef CONFIG_EPOLL */
        struct address_space    *f_mapping;
        errseq_t        f_wb_err;
        errseq_t        f_sb_err; /* for syncfs */
    } __randomize_layout
    __attribute__((aligned(4)));    /* lest something weird decides that 2 is OK */

    Eskiden dosya nesnesi dentry nesnesini, dentry nesnesi de inode nesnesini gösteriyordu. Yani durum şöyleydir:

    File  ──▶ dentry ──▶ inode

    Daha sonraları dosya nesnesinin içerisinden inode nesnesine daha hızlı erişebilmek için dosya nesnesinin içerisine (yani
    file yapısının içerisine) doğrudan bir inode göstericisi daha eklenmiştir. Mevcut durum şöyledir:

    File  ──▶ dentry ──▶ inode
  ╰──────────────────────▶

    inode yapısı dosyanın diskteki bilgilerini tutmaktadır. Yani örneğin aynı dosya üç kez açılsa çekirdek üç farklı file nesnesi 
    inode yapısı dosyanın diskteki bilgilerini tutmaktadır. Yani örneğin aynı dosya üç kez açılsa çekirdek üç farklı file nesnesi 
    oluşturmaktadır. Ancak bu dosya diskte bir tane olduğuna göre çekirdek bunun için toplamda bir tane inode yapısı oluşturacaktır.
    Mevcut çekirdeklerde file yapısının içerisinde dosyanın diskteki bilgilerine ilişkin bu inode yapısına f_inode elemanı yoluyla 
    erişilebilmektedir. Linux işletim sistemi aynı zamanda diskte son erişilen dosyalara ilişkin i-node elemanlarını inode yapısı 
    biçiminde bir cache sisteminde de tutmaktadır. Buna "inode cache" denilmektedir. Örneğin biz "test.txt" isimli bir dosyayı 
    sys_open sistem fonksiyonuyla açmış olalım. İşletim sistemi bunun için bir dosya nesnesi oluşturacak ve bu dosyaya ilişkin 
    inode nesnesi zaten inode cache içerisinde varsa onu cache'ten alıp kullanacaktır. Eğer bu dosyaya ilişkin inode nesnesi 
    "inode cache" içerisinde yoksa işletim sistemi dosyaya ilişkin inode bilgilerini diskten bulup inode nesnesini oluşturacak
    ve "inode cache" içerisine yerleştirecektir. Bu dosya kapatıldığında da işletim sistemi inode yapısını çekirdek alanından 
    atmaz bu inode nesnesi "inode cache" içerisinde kalmaya devam eder. Tabii bu "inode cache" içerisinde belli sayıda inode 
    elemanı tutulmaktadır. Bu cache sistemi dolduğunda LRU (Least Recently Used) algoritmasına göre son zamanlarda en az kullanılan 
    inode elemanı cache'ten atılmaktadır.

    Linux çekirdeğinde dosyanın i-node elemanına erişmekte kullanılan dizin girişleri dentry isimli bir yapıyla temsil edilmiştir. 
    inode yapısı dosyanın diskteki bilgilerini tutarken dentry yapısı dosyanın dizin girişi bilgilerini tutmaktadır. Yukarıda 
    da belirttiğimiz gibi dentry nesnesinin içerisinde inode nesnesinin adresi tutulmaktadır. Örneğin farklı dentry nesneleri 
    aynı inode nesnesini gösteriyor olabilir. Bu tür durumlar "hard link" yoluyla oluşturulmaktadır. Açılmış dosyanın hangi 
    dizinlerin içerisinde bulunduğu bilgisi dentry nesnelerinde tutulmaktadır. Linux işletim sistemi nasıl inode nesnelerini 
    bir cache sisteminde tutuyorsa dentry nesnelerini de ismine "dentry cache" denilen bir cache sistemi içerisinde tutmaktadır. 
    Bir dosyanın open fonksiyonuyla (bu POSIX fonksiyonu doğrudan sys_open sistem fonksiyonunu çağırmaktadır) açıldığını varsayalım. 
    Dosyaya ilişkin dizin girişi bilgilerinin elde edilmesi için ismine "pathname resolution" denilen bir işlem yapılmaktadır. 
    Örneğin biz "/home/kaan/Study/test.txt" dosyasını açmak isteyelim. İşletim sistemi bunun için önce "/home" dizin girişini 
    sonra home  dizininde "kaan" dizin girişini, sonra  "kaan" dizininde "Study" dizin girişini sonra da "Study" dizininde "test.txt" 
    dizin girişini bulacaktır. İşte tüm bu dizin girişleri aynı zamanda "dentry cache" içerisinde de saklanmaktadır. Böylece bu 
    dosyaya bir daha erişilmek istendiğinde doğrudan bu dizin girişi bilgileri "dentry cache" içerisinden elde edilebilmektedir. 
    Linux işletim sistemi her zaman eğer bir dosyanın dentry nesnesi çekirdek içerisindeyse onun tüm yol ifadesine ilişkin dentry 
    nesnelerini de çekirdek içerisinde tutmaktadır. "dentry cache" sistemi de LRU prensibiyle çalışan bir cache sistemidir.  
        
    Daha önceden de gördüğümğz gibi Bir aygıt sürücü üzerinde dosya işlemi yapıldığında çekirdek aygıt sürücü fonksiyonlarına 
    dosya nesnesinin adresini (filp parametre değişkeni) geçirmektedir. Yalnızca aygıt sürücü open fonksiyonuyla açılırken ve 
    close fonksiyonu ile kapatılırken inode nesnesinin adresi de bu fonksiyonlara geçirilmektedir. Aygıt sürücünün fonksiyonlarının 
    parametrik yapılarını aşağıda yeniden veriyoruz:

    int open(struct inode *inodep, struct file *filp);
    int release(struct inode *inodep, struct file *filp);
    ssize_t read(struct file *filp, char *buf, size_t size, loff_t *off);
    ssize_t write(struct file *filp, const char *buf, size_t size, loff_t *off);
    loff_t llseek(struct file *filp, loff_t off, int whence);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücünün majör ve minör numaraları ne anlam ifade etmektedir? Majör numara aygıt sürücünün türünü, minör numara ise 
    aynı türden aygıt sürücülerin farklı örneklerini (instance'larını) belirtmektedir. Başka bir deyişle minör numara aygıt 
    sürücünün yönettiği aygıtların numaralarını belirtmektedir. Örneğin biz yukarıdaki "pipe-driver" aygıt sürücümüzün tek bir 
    boruyu değil on farklı boruyu idare etmesini isteyebiliriz. Bu durumda aygıt sürücümüzün bir tane majör numarası ancak 10 
    tane minör numarası olacaktır. Aygıt sürücülerin majör numaraları aynı ise bunların kodları da aynıdır. O aynı kod birden 
    fazla aygıt için işlev görmektedir. Örneğin seri portu kontrol eden bir aygıt sürücü söz konusu olsun. Ancak bilgisayarımızda 
    dört seri port olsun. İşte bu durumda bu seri porta ilişkin aygıt dosyalarının hepsinin majör numaraları aynıdır. Ancak minör 
    numaraları farklıdır. Ya da örneğin terminal aygıt sürücüsü bir tanedir. Ancak bu aygıt sürücü birden fazla terminali yönetebilmektedir. 
    O halde her terminale ilişkin aygıt dosyasının majör numaraları aynı minör numaraları farklı olacaktır. Örneğin:

    $ ls -l tty1 tty2 tty3 tty4 tty5
    crw--w---- 1 root tty 4, 1 Haz  2 15:05 tty1
    crw--w---- 1 root tty 4, 2 Haz  2 15:05 tty2
    crw--w---- 1 root tty 4, 3 Haz  2 15:05 tty3
    crw--w---- 1 root tty 4, 4 Haz  2 15:05 tty4
    crw--w---- 1 root tty 4, 5 Haz  2 15:05 tty5

    Örneğin diskleri yöneten bir aygıt sürücüsü olsun. Ancak bilgisayarımızda üç farklı fiziksel disk olsun. Bu disklerin 
    yönetimleri aynı biçimde aynı kodlarla yapılmaktadır. Bunları yöneten tek bir aygıt sürücü kodu dolaysıyla majör numarası 
    vardır. Ancak her disk ayrı bir minör numarayla temsil edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                146. Ders 07/06/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir aygıt sürücünün aynı türden birden fazla aygıtı nasıl yönetebileceğini ele alacağız. Birden fazla aygıtı yönetecek 
    (yani birden fazla minör numaraya sahip olan) bir aygıt sürücü nasıl yazılabilir? Her şeyden önce birden fazla minör numara 
    kullanan aygıt sürücüleri yazarken dikkatli olmak gerekir. Çünkü tek bir kod birden fazla aynı türden bağımsız aygıtı idare 
    edecektir. Dolayısıyla bu tür durumlarda bazı nesnelerin senkronize edilmesi gerekebilir.

    Birden fazla minör numara üzerinde çalışacak (yani birden fazla aynı türden aygıt üzerinde çalışacak) aygıt sürücüler tipik 
    olarak şöyle yazılmaktadır:

    1) Aygıt sürücüyü yazan programcı baştan onun kaç minör numaraya ilişkin aygıtı yöneteceğini belirlemelidir. Bunun için 
    default bir değer kullanılabilir. Ancak genellikle aygıt sürücünün kaç minör numaraya ilişkin aygıtı yöneteceği aygıt 
    sürücüye komut satırı argümanlarıyla (yani modül parametreleriyle) geçirilmektedir. Biz de örneğimizde bu yöntemi kullanacağız. 
    Minör numara sayısının aşağıdaki gibi ndevices isimli parametre yoluyla komut satırından aygıt sürücüye aktarıldığını 
    varsayacağız:

    #define DEF_NDEVICES        10
    ...
    static int ndevices = DEF_NDEVICES;
    module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Bu durumda bu aygıt sürücü yüklenirken ndevices parametresi girilmezse DEF_NDEVICES değeri dikkate alınmaktadır. Örneğin 
    bu aygıt sürücüyü 5 aygıtı yönetecek biçimde aşağıdaki gibi yükleyebiliriz:

    ./insmod pipe-driver.ko ndevices=5

    2) Programcının aygıt sürücü için majör ve minör numaraları tahsis etmesi gerekir. Daha önce yaptığımız gibi majör numara 
    alloc_chrdev_region fonksiyonuyla dinamik olarak belirlenebilmektedir. Bu fonksiyon anımsanacağı gibi aynı zamanda belli 
    bir minör numaradan başlayarak n tane minör numarayı da tahsis edebilmektedir. Örneğin:

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    Burada 0'ıncı minör numaradan ndevices tane minör numara için aygıt tahsisatı yapılmıştır. Tabii g_dev nesnesi yalnızca 
    ilk minör numaraya ilişkin (örneğimizde 0) aygıt numarasını tutmaktadır.

    3) Her aygıt bir yapıyla temsil edilmelidir. Bunun için N elemanlı bir yapı dizisi yaratabilirsiniz. Bu dizi global düzeyde 
    tanımlanabileceği gibi kmalloc fonksiyonuyla dinamik biçimde de tahsis edilebilir. Biz örneğimizde her PIPE_DEVICE yapısını 
    ayrı bir kmalloc fonksiyonu ile tahsis ettik. Bunların adreslerini de yine kmalloc fonksiyonuyla tahsis ettiğimiz bir gösterici
    dizisine yerleştirdik. cdev nesnesi kesinlikle aygıtı temsil eden yapının (bizim örneğimizde PIPE_DEVICE yapısının) içerisinde 
    bulundurulmalıdır. Çünkü çekirdek bize bu nesnenin adresini geri verebilmektedir. Biz de bu sayede aygıt yapısına erişebiliriz. 
    Örneğimizdeki aygıtı temsil eden PIPE_DEVICE yapısı şöyledir:
       
    struct PIPE_DEVICE {
        unsigned char buf[PIPE_BUFFER_SIZE];
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Burada görüldüğü gibi her farklı borunun farklı bekleme kuyrukları ve semaphore nesnesi vardır. cdev yapı nesnesinin yapının 
    içerisine yerleştirilmesinin amacı ileride görüleceği gibi bu nenenin adresten hareketle aygıt nesnesinin başlangıç adresinin 
    elde edilmesini sağlamaktır. Bunun nasıl yapıldığı izleyen paragraflarda görülecektir.

    Aygıt nenseleri aşağıdaki gibi tahsis edilmiştir:

    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    

    Burada önce aygıt nesnelerini tutan gösterici dizisi için tahsisat yapımış daha sonra da aygıt nesneleri için tahsisat 
    yapılmıştır. Tabii aslında biz tek hamlede de (yanş tek bir kmalloc ile de) tüm tahsisatı yapabilirdik.

    4) N tane minör numaralı aygıt için cdev_add fonksiyonuyla aygıtlar çekirdeğe eklenmelidir. Örneğin:

        for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }

    Burada yapı dizisinin her elemanındaki elemanlara ilkdeğerleri verilmiştir. Sonra her boru için ayrı bir cdev nesnesi 
    cdev_add fonksiyonu ile eklenmiştir. Eklemelerden biri başarısız olursa daha önce eklenenlerin de cdev_del fonksiyonu 
    ile silindiğine dikkat ediniz.

    5) Aygıt sürücünün exit fonksiyonunda tahsis edilen tüm kaynaklar ters sırada geri bırakılmalıdır. Örneğin:

    static void __exit pipe_driver_exit(void)
    {
        int i;

        for (i = 0; i < ndevices; ++i)
            cdev_del(&g_devices[i]->cdev);
        for (i = 0; i < ndevices; ++i)
            kfree(g_devices[i]);
        kfree(g_devices);

        unregister_chrdev_region(g_dev, ndevices);
        
        printk(KERN_INFO "pipe-driver module exit...\n");
    }

    6) Bizim read, write gibi aygıt sürücü fonksiyonlarında file yapısı türünden adres belirten filp parametre değişkeni 
    yoluyla PIPE_DEVICE yapısına erişmemiz gerekir. Bu işlem dolaylı bir biçimde şöyle yapılmaktadır:
  
    - Önce aygıt sürücünün open fonksiyonunda programcı inode yapısının i_cdev elemanından hareketle cdev nesnesinin içinde 
    bulunduğu yapı nesnesinin başlangıç adresini container_of makrosuyla elde eder. inode yapısının i_cdev elemanı cdev_add
    fonksiyonuyla eklenen cdev yapı nesnesinin adresini tutmaktadır. container_of bir yapının bir elemanın adresini, o elemanın 
    ismini ve yapının ismini alarak yapı nesnesinin başlangıç adresini veren bir makrodur. container_of makrosu C standartlarında 
    bulunan bir makro değildir. Ancak bu makro C standartlarında bulunan offsetof makrosu kullanılarak yazılabilir. Anımsanacağı 
    gibi C'de offsetof makrosu bir yapının bir elemanının yapının başından itibaren kaçıncı offset'te olduğunu bize vermektedir. 
    offsetof makrosu şöyle yazabiliriz:

    #define my_offsetof(type, member)     ((size_t)&((type *)0)->member)

    Burada gerçek anlamda 0 adresine erişim yapılmamaktadır. C standartlarına göre bir gösterici ile onun gösterdiği yere erişilip 
    oranın adresi alındığında derleyici gerçek bir erişim yapmaz. İşte offsetof makrosu kullanılarak container_of makrosu de 
    şöyle yazılabilir:

    #define my_container_of(ptr, type, member)   ((type *)((char *)(ptr) - my_offsetof(type, member)))

    Makronun birinci parametresi yapı elemanın adresini, ikinci parametresi yapının tür ismini, üçüncü parametresi ise adresi 
    verilen yapı elemanının ismini almaktadır. Bu makro yapı nesnesinin bütünsel adresine geri dönmektedir. 

    Yukarıda da belirttiğimiz gibi Programcı cdev nesnesinin adresini inode yapısının i_cdev elemanından geri alabilmektedir. İşte 
    bu adres yoluyla da container_of makrosunu kullanarak aygıt nesnesinin adresini (örneğimizde PIPE_DEVICE nesnesinin adresini) 
    elde eder. İşte programcı aygıt nesnesinin adresini elde ettikten sonra onu file yapısının private_data elemanına yerleştirir. 
    file yapısının private_data elemanı programcının kendisinin yerleştirdiği bilgileri tutmak için bulundurulmuştur. Burada bir 
    noktaya dikkat ediniz: inode nesnesinin adresi yalnızca aygıt sürücünün open ve release fonksiyonlarına geçirilmektedir. read 
    ve write gibi fonksiyonlara file nesnesinin adresi (filp parametresi) geçirilmektedir. O halde programcı aygıt sürücünün open
    fonksiyonu içerisinde aygıt nesnesinin adresini elde edip onu file nesnesinin içerisine yerleştirmelidir. Bu işlemler tipik 
    olarak aşağıdaki gibi yapılabilir:

    static int pipe_open(struct inode *inodep, struct file *filp)
    {
        struct PIPE_DEVICE *pipedev;
        int accmode = filp->f_flags & O_ACCMODE;

        pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
        filp->private_data = pipedev;

        /* ... */

        printk(KERN_INFO "pipe-driver opened...\n");

        return 0;
    }

    7) Aygıt sürücünün read ve write fonksiyonları yazılır.

    8) release (close) işleminde yapılacak birtakım son işlemler varsa yapılır.

    9) Birden fazla minör numara için çalışacak aygıt sürücüler için birden fazla aygıt dosyasının yaratılması gerekir. Yani 
    aygıt sürücü kaç minör numarayı destekliyorsa o sayıda aygıt dosyası yaratılmalıdır. Bu da onları yüklemek için kullandığımız 
    "load" script'inde değişiklik yapmayı gerektirmektedir. N tane minör numaraya ilişkin aygıt dosyası yaratacak biçimde yeni 
    bir "loadmulti" script'i aşağıdaki gibi yazılabilir:

    #!/bin/bash

    module=$2
    mode=666

    /sbin/insmod ./${module}.ko ${@:3} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
        mknod -m $mode ${module}$i c $major $i
    done

    Buradaki "loadmulti" script'i iki komut satırı argümanıyla aşağıdaki örnekteki gibi çalıştırılmalıdır:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Burada "loadmulti" script'i hem aygıt sürücüyü yükleyecek hem de pipe-driver0, pipe-driver1, ..., pipedriver9 biçiminde 
    aygıt dosyalarını yaratacaktır. Aşağıda yaratılmış olan örnek aygıt dosyalarına dikkat ediniz:

    crw-rw-rw- 1 root root  236, 0 Haz  7 22:09 pipe-driver0
    crw-rw-rw- 1 root root  236, 1 Haz  7 22:09 pipe-driver1
    crw-rw-rw- 1 root root  236, 2 Haz  7 22:09 pipe-driver2
    crw-rw-rw- 1 root root  236, 3 Haz  7 22:09 pipe-driver3
    crw-rw-rw- 1 root root  236, 4 Haz  7 22:09 pipe-driver4
    crw-rw-rw- 1 root root  236, 5 Haz  7 22:09 pipe-driver5
    crw-rw-rw- 1 root root  236, 6 Haz  7 22:09 pipe-driver6
    crw-rw-rw- 1 root root  236, 7 Haz  7 22:09 pipe-driver7
    crw-rw-rw- 1 root root  236, 8 Haz  7 22:09 pipe-driver8
    crw-rw-rw- 1 root root  236, 9 Haz  7 22:09 pipe-driver9

    Aygıt dosyalarının majör numaralarının hepsi aynıdır ancak minör numaraları farklıdır. Burada artık adeta birbirinden bağımsız 
    10 ayrı boru aygıtı var gibidir. Ancak aslında tek bir aygıt sürücü kodu bulunmaktadır. Tabii bizim benzer biçimde "unload"
    script'ini de tüm aygıt dosyalarını silecek biçimde düzeltmemiz gerekir. Bunun için "unloadmulti" script'ini aşağıdaki gibi
    yazabiliriz:

    #!/bin/bash

    module=$2

    /sbin/rmmod ./$module.ko || exit 1
    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
    done

    Bu script'te biz önce modülü çekirdekten sonra da "loadmulti" ile yarattığımız aygıt dosyalarını dosya sisteminden silmekteyiz. 
    Script aşağıdaki örnekteki gibi kullanılmalıdır:

    $ sudo ./unloadmulti 10 pipe-driver

    Şimdi ndevices kadar minör numarayı destekleyen aygıt sürücü kodunun tamamını veriyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define DEF_NDEVICES            10
#define PIPE_BUFFER_SIZE           10

#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE_DEVICE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqwriteopen;
    wait_queue_head_t wqreadopen;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    int nreaders;
    int nwriters;
    struct cdev cdev;
};
static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
    int result;
    int i, k;
    dev_t dev;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate pipe device!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    
    
    for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }    
    return 0;

EXIT4:
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
EXIT3:
    kfree(g_devices);
EXIT2:
    unregister_chrdev_region(g_dev, ndevices);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    int i;

    for (i = 0; i < ndevices; ++i)
        cdev_del(&g_devices[i]->cdev);
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
    kfree(g_devices);

    unregister_chrdev_region(g_dev, ndevices);
    
    printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
    filp->private_data = pipedev;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++pipedev->nreaders;
        wake_up_interruptible(&pipedev->wqwriteopen);
        while (pipedev->nwriters == 0) {
            up(&pipedev->sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        while (pipedev->nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --pipedev->nwriters;
                up(&pipedev->sem);
                return -ENXIO;
            }
            up(&pipedev->sem);
            if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++pipedev->nreaders;
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        wake_up_interruptible(&pipedev->wqwriteopen);
    }
    up(&pipedev->sem);

    printk(KERN_INFO "pipe-driver opened...\n");
    
    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --pipedev->nreaders;
    else if (accmode == O_WRONLY)
        --pipedev->nwriters;
    else if (accmode == O_RDWR) {
        --pipedev->nreaders;
        --pipedev->nwriters;
    }
    if (pipedev->nreaders == 0)
        wake_up_interruptible(&pipedev->wqwrite);
    if (pipedev->nwriters == 0)
        wake_up_interruptible(&pipedev->wqread);

    if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

    up(&pipedev->sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    while (pipedev->count == 0) {
        if (pipedev->nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, pipedev->count);
    if (pipedev->head >= pipedev->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
            goto EXIT;

    pipedev->head = (pipedev->head + esize) % PIPE_BUFFER_SIZE;
    pipedev->count -= esize;

    result = esize;

    wake_up_interruptible(&pipedev->wqwrite);
EXIT:
    up(&pipedev->sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (pipedev->nreaders == 0) {
        up(&pipedev->sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - pipedev->count < size) {
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqwrite, PIPE_BUFFER_SIZE - pipedev->count >= size || pipedev->nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
        if (pipedev->nreaders == 0) {
            up(&pipedev->sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - pipedev->count);

    if (pipedev->tail >= pipedev->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
            goto EXIT;

    pipedev->tail = (pipedev->tail + esize ) % PIPE_BUFFER_SIZE;
    pipedev->count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&pipedev->wqread);
    up(&pipedev->sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

//* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                148. Ders 16/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüden bilgi okumak için read fonksiyonun, aygıt sürücüye bilgi göndermek için ise write fonksiyonun kullanıldığını 
    gördük. Ancak bazen aygıt sürücüye write fonksiyonunu kullanmadan bazı bilgilerin gönderilmesi, aygıt sürücüden read 
    fonksiyonunu kullanmadan da bazı bilgilerin alınması gerekebilmektedir. Bazen hiç bilgi okumadan ve bilgi göndermeden aygıt 
    sürüceden bazı şeyleri yapmasını da isteyebiliriz. Bu tür bazı işlemlerin read ve write fonksiyonlarıyla yaptırılması mümkün 
    olsa bile kullanışsızdır.

    Örneğin yukarıdaki boru aygıt sürücümüzde (pipe-driver) biz aygıt sürücüden kullandığı FIFO alanının uzunluğunu isteyebiliriz. 
    Ya da bu alanın boyutunu değiştirmek isteyebiliriz. Bu işlemleri read ve write fonksiyonlarıyla yapmaya çalışsak aygıt 
    sürücümüz sanki boruyu temsil eden kuyruktan okuma yazma yapmak istediğimizi sanacaktır. Tabii yukarıda da belirttiğimiz 
    gibi zorlanırsa bu tür işlemler read ve write fonksiyonlarıyla yine de yapılabilir. Ancak böyle bir kullanımın mümkün hale 
    getirilmesi ve user mode'dan kullanılması oldukça zor olacaktır.

    İşte aygıt sürücüye komut gönderip ondan bilgi almak ya da ona bazı işlemleri yaptırmak için genel amaçlı ioctl isminde 
    özel bir POSIX fonksiyonu bulundurulmuştur. Linux sistemlerinde ioctl fonksiyonu sys_ioctl isimli sistem fonksiyonunu 
    çağırmaktadır. ioctl fonksiyonunun parametrik yapısı şöyledir:

    #include <sys/ioctl.h>

    int ioctl(int fd, unsigned long request, ...);

    Fonksiyonun birinci parametresi aygıt sürücüye ilişkin dosya betimleyicisini belirtir. İkinci parametre ileride açıklanacak 
    olan komut kodudur. Aygıt sürücüsünü yazan programcı aygıt sürücüsünde farklı komutlar için farklı komut kodları (yani 
    numaralar) oluşturur. Sonra bu komut kodlarını switch içerisine sokarak hangi numaralı istekte bulunulmuşsa ona yönelik 
    işlemleri yapar. ioctl fonksiyonu iki parametreyle ya da üç parametreyle kullanılmaktadır. Yani fonksiyonun üçüncü parametresi 
    isteğe bağlıdır. Eğer bir veri transferi söz konusu değilse ioctl genellikle iki argümanla çağrılır. Ancak bir veri transferi 
    söz konusu ise ioctl üç argümanla çağrılmalıdır. Bu durumda üçüncü argüman user mode'daki transfer adresini belirtir. Tabii 
    aslında bu üçüncü parametrenin veri transferi ile ilgili olması dolayısıyla da bir adres belirtmesi zorunlu değildir.

    ioctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner. errno uygun biçimde set 
    edilmektedir. Örneğin:

    if (ioctl(fd, command_code) == -1)
        exit_sys("ioctl");

    Aslında çoğu kez uygulama programcıları ioctl çağrılarını doğrudan yapmamaktadır. Aygıt sürücüleri ayzanlar bu çağrıları 
    yapan daha yüksek seviyeli kütüphaneler (yani API'ler) oluşturup bu kütüphaneleri uygulama programcılarına vermektedir. 
    Yani çoğu kez aşaığıdaki gibi bir katmalı yapı söz konusu olmaktadır:

    +---------------------------+
    | Yüksek Seviyeli Kütüphane |
    +---------------------------+
    |        IOCTL Kodları      |
    +---------------------------+
    |        Aygıt Sürücü       |
    +---------------------------+
    |          Çekirdek         |
    +---------------------------+

    Buradaki "Yüksek Seviyeli Kütüphane" ioctl çağrılarını yapan fonksiyonlardan oluşmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Kullanıcı modundaki bir program aygıt sürücü için ioctl fonksiyonunu çağırdığında akış kullanıcı modundan çekirdke moduna 
    geçer ve aygıt sürücüdeki file_operations yapısının unlocked_ioctl elemanında belirtilen fonksiyon çağrılır. Bu fonksiyonun 
    parametrik yapısı şöyle olmalıdır:

    long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

    Fonksiyonun birinci parametresi yine dosya nesnesinin adresini, ikinci parametresi ioctl fonksiyonunda kullanılan komut 
    kodunu (yani ioctl fonksiyonuna geçirilen ikinci argümanı) ve üçüncü parametresi de ek argümanı (yani ioctl fonksiyonuna 
    geçirilen üçüncü argümanı) belirtmektedir. Tabii programcının eğer ioctl fonksiyonu iki argümanlı çağrılmışsa bu üçüncü 
    parametreye erişmemesi gerekir.

    Bu fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif hata koduna geri dönmelidir. Fakat bazen programcı 
    doğrudan iletilecek değeri geri dönüş değeri biçiminde oluşturabilir. Bu durumda geri dönüş değeri pozitif değer olabilir.
    Örneğin:

    static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
    ...

    static struct file_operations g_fops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .read = generic_read,
        .write = generic_write,
        .release = generic_release,
        .unlocked_ioctl = generic_ioctl
    };
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ioctl işleminde ioctl fonksiyonunun ikinci parametresi olan kontrol kodu dört parçanın bit düzeyinde birleştirilmesiyle
    oluşturulmaktadır. Bu dört parçnın 32 bit içerisindeki bit genişlikleri ve pozisyonları şöyledir:

    31     30 29           22 21            14 13              0
    +--------+---------------+----------------+----------------+
    |  Dir   |     Type      |     Number     |     Size       |
    +--------+---------------+----------------+----------------+
      2 bits      8 bits           8 bits          14 bits 
    
    Ancak bu parçalara ilişkin bitlerin 32 bit içerisinde belli pozisyonlara yerleştirilmesini kolaylaştırmak için _IOC isimli 
    bir makro bulundurulmuştur. Bu makronun parametreleri şöyledir:

    _IOC(dir, type, nr, size)

    Bu makro buradaki parçaları bit düzeyinde birleştirerek 4 byte'lık bir değer vermektedir. Makronun parametrelerini oluşturan 
    dört parçanın anlamları ve bit uzunlukları şöyledir:

    dir (direction): Bu 2 bitlik bir alandır ([30, 31] bitler). Burada kullanılacak sembolik sabitler _IOC_NONE, _IOC_READ, 
    _IOC_WRITE ve _IOC_READ|_IOC_WRITE biçimindedir. Buradaki _IOC_READ aygıt sürücüden bilgi alınacağını _IOC_WRITE ise aygıt 
    sürücüye bilgi gönderileceğini belirtmektedir. Ancak bu yön ioctl sistem fonksiyonu tarafından dosyanın açış moduyla kontrol
    edilmemektedir. Örneğin biz buradaki yönü _IOC_READ|_IOC_WRITE biçiminde vermiş olsak bile aygıt dosyaısnı O_RDONLY modunda 
    açıp bu ioctl işlemini yapabiliriz. Çekirdek hiçbir işlemde bu yön bilgisini kontrol etmemektedir. Eğer programcı böyle bir 
    kontrol yapmak istiyorsa aygıt sürücünün ioctl fonksiyonu içerisinde bunu yapmalıdır. Buradaki sembolil sabitler tipik olarak 
    şu değerlerdedir:

    #define _IOC_NONE       0U
    #define _IOC_WRITE      1U
    #define _IOC_READ       2U
    
    type: Bu 8 bitlik bir alandır ([22, 29] bitleri). Bu alana aygıt sürücüyü yazan istediği herhangi bir byte'ı verebilir. 
    Genellikle bu byte bir karakter sabiti olarak verilmektedir. Buna "magic number" da denilmektedir.

    nr: Bu 8 bitlik bir alandır ([14, 21] bitleri). Programcı tarafından kontrol koduna verilen sıra numarasını temsil etmektedir. 
    Genellikle aygıt sürücü programcıları 0'dan başlayarak her koda bir numara vermektedir.

    size: Bu 14 bitlik bir alandır ([0, 13] bitleri). Bu alan kaç byte'lık bir transferin yapılacağını belirtmektedir. Buradaki 
    size değeri aslında çekirdek tarafından kullanılmamaktadır. Dolayısıyla biz 14 bitten daha büyük transferleri de yapabiliriz.

    Kullanım kolaylığı sağlamak için genellikle _IOC makrosu bir sembolik sabit biçiminde define edilir. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO         _IOC(_IOC_READ, GENERAL_DRIVER_MAGIC, 0, 4)

    Aslında _IOC makrosundan daha kolay kullanılabilen aşağıdaki makrolar da oluşturulmuştur:

    #ifndef __KERNEL__
        #define _IOC_TYPECHECK(t) (sizeof(t))
    #endif

    #define _IO(type,nr)                _IOC(_IOC_NONE,(type),(nr),0)
    #define _IOR(type,nr,size)          _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOW(type,nr,size)          _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOWR(type,nr,size)         _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))

    Bu makrolarda _IOC makrosunun birinci parametresinin artık belirtilmediğine dikkat ediniz. Çünkü makrolar zaten isimlerine
    göre _IOC makrosunun birinci parametresini kendisi oluşturmaktadır. Ayrıca artık uzunluk (size parametresi) byte olarak 
    değil tür olarak belirtilmelidir. Makrolar bu türleri sizeof operatörüne kendisi sokmaktadır. Görüldüğü gibi _IO makrosu 
    veri transferinin söz konusu olmadığı durumda kullanılır. _IOR aygıt sürücüden okuma yapıldığı durumda, _IOW aygıt sürücüye 
    yazma yapıldığı durumda, _IOWR ise aygıt sürücüden hem okuma hem de yazma yapıldığı durumlarda kullanılmaktadır. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO        _IOR(GENERAL_DRIVER_MAGIC, 0, int)

    ioctl için kontrol kodları hem aygıt sürücünün içerisinden hem de user kullanıcı modundan kullanılacağına göre ortak bir 
    başlık dosyasının oluşturulması uygun olabilir. Burada ioctl kontrol kodları bulundurulabilir. Örneğin boru aygıt sürücümüz 
    için "pipe-driver.h" dosyası aşağıdaki gibi düzenlenebilir:

    /* ioctl-driver.h */

    #ifndef IOCTL_DRIVER_H_
    #define IOCTL_DRIVER_H_

    #include <linux/stddef.h>
    #include <linux/ioctl.h>

    #define GENERIC_DRIVER_MAGIC        'g'
    #define IOC_GENERIC_TEST            _IO(GENERIC_DRIVER_MAGIC, 0)

    #endif

    Aygıt sürücüdeki ioctl fonksiyonunu yazarken iki noktaya dikkat etmek gerekir:

    1) ioctl fonksiyonunun üçüncü parametresi unsigned long türden olmasına karşın aslında genellikle kullanıcı modunda çalışan 
    programcı buraya bir nesnesin adresini geçirmektedir. Dolayısıyla bu transfer adresine aktarım gerekmektedir. Bunun için 
    copy_to_user, copy_from_use, put_user, get_user gibi "adresin geçerliliğini sorguladıktan sonra transfer yapan fonksiyonlar" 
    kullanılabilir.

    2) Kullanıcı modunda çalışan programcının olmayan bir komut kodu girmesi durumunda ioctl fonksiyonu -ENOTTY değeri ile 
    geri döndürülmelidir. Bu tuhaf hata kodu (TTY teletype terminal sözcüklerinden kısaltmadır) tarihsel bir durumdan 
    kaynaklanmaktadır. Bu hata kodu için kullanıcı modunda "Inappropriate ioctl for device" biçiminde bir hata yazısı elde 
    edilmektedir.

    Kullanıcı modundaki ioctl fonksiyonu başarı durumunda 0 değerine geri döndüğü için aygıt sürücüdeki ioctl fonksiyonu da 
    genel olarak başarı durumunda 0 ile geri döndürülmelidir. Yukarıda da belirttiğimiz gibi olmayan bir ioctl kodu için aygıt 
    sürücüdeki fonksiyonun -ENOTTY ile geri döndürülmesi uygundur. Bazı aygıt sürücülerinde başarı durumunda aygıt sürücüden 
    bilgi ioctl fonksiyonunun üçüncü parametresi yoluyla değil geri dönüş değeri yoluyla elde edilmektedir. Bu durumda aygıt 
    sürücüdeki ioctl fonksiyonu pozitif değerle de geri döndürülebilir. Ancak bu durum seyrektir. Biz veri transferinin ioctl 
    fonksiyonunun üçüncü 
    parametresi yoluyla yapılmasını tavsiye ediyoruz.

    Aygıt sürücüdeki ioctl fonksiyonu tipik olarak bir switch deyimi ile gerçekleştirilmektedir. Örneğin:

   static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
        printk(KERN_INFO "generic_ioctl...\n");

        switch (cmd) {
            case IOC_GENERIC_TEST1:
                result = ioctl_generic_test1(filp, arg);
                break;
            case IOC_GENERIC_TEST2:
                result = ioctl_generic_test2(filp, arg);
                break;
            case IOC_GENERIC_TEST3:
                result = ioctl_generic_test3(filp, arg);
                break;
            case IOC_GENERIC_TEST4:
                result = ioctl_generic_test4(filp, arg);
                break;
            case IOC_GENERIC_TEST5:
                result = ioctl_generic_test5(filp, arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada switch deyiminin default bölümünde fonksiyonun -NOTTY değeri ile geri döndürüldüğüne dikkat ediniz. Tabii fonksiyon
    üçüncü parametresi ile belirtilen transfer adresi geçersiz bir adresse yine -EFAULT değeri ile geri döndürülmelidir.

    Aşağıda iskelet bir ioctl örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* ioctl-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include "ioctl-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("ioctl-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static long ioctl_generic_test1(struct file *filp, unsigned long arg);
static long ioctl_generic_test2(struct file *filp, unsigned long arg);
static long ioctl_generic_test3(struct file *filp, unsigned long arg);
static long ioctl_generic_test4(struct file *filp, unsigned long arg);
static long ioctl_generic_test5(struct file *filp, unsigned long arg);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.write = generic_write,
	.release = generic_release,
    .unlocked_ioctl = generic_ioctl
};

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "ioctl-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "ioctl-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

	return 0;
}

static void __exit generic_exit(void)
{
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "ioctl-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver read...\n");

	return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver write...\n");

	return 0;
}

static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
    printk(KERN_INFO "generic_ioctl...\n");

    switch (cmd) {
        case IOC_GENERIC_TEST1:
            result = ioctl_generic_test1(filp, arg);
            break;
        case IOC_GENERIC_TEST2:
            result = ioctl_generic_test2(filp, arg);
            break;
        case IOC_GENERIC_TEST3:
            result = ioctl_generic_test3(filp, arg);
            break;
        case IOC_GENERIC_TEST4:
            result = ioctl_generic_test4(filp, arg);
            break;
        case IOC_GENERIC_TEST5:
            result = ioctl_generic_test5(filp, arg);
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

long ioctl_generic_test1(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST1\n");

    return 0;
}

long ioctl_generic_test2(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST2\n");

    return 0;
}

long ioctl_generic_test3(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST3\n");

    return 0;
}

long ioctl_generic_test4(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST4\n");

    return 0;
}

long ioctl_generic_test5(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST5\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* ioctl-driver.h */

#ifndef GENERIC_DRIVER_H_
#define GENERIC_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define GENERIC_DRIVER_MAGIC		'g'
#define IOC_GENERIC_TEST1		    _IO(GENERIC_DRIVER_MAGIC, 0)
#define IOC_GENERIC_TEST2		    _IO(GENERIC_DRIVER_MAGIC, 1)
#define IOC_GENERIC_TEST3		    _IO(GENERIC_DRIVER_MAGIC, 3)
#define IOC_GENERIC_TEST4		    _IO(GENERIC_DRIVER_MAGIC, 4)
#define IOC_GENERIC_TEST5		    _IO(GENERIC_DRIVER_MAGIC, 5)

#endif
    
/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "ioctl-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
		
	if ((fd = open("ioctl-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_GENERIC_TEST1) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST2) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST3) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST4) == -1)
        exit_sys("ioctl");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                149. Ders 23/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/


    Bu örnek için yukarıda vermiş olduğumuz boru aygıt sürücüsünde bazı değişiklikler yaptık. Bu değişiklikler şunlardır:

    - Artık borunun uzunluğu PIPE_DEVICE yapısının içerisinde tutulmaya başlanmıştır:

    struct PIPE_DEVICE {
        unsigned char *buf;
        size_t bufsize;
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Buradaki bufsize elemanı ilgili borunun uzunluğunu belirtmektedir. Default uzunluk PIPE_DEF_BUFFER_SIZE değeri kadardır. 
    Bu değer örneğimizde test için kolaylık sağlamak amacıyla 10 olarak alınmıştır. Bu değişiklik sayesinde artık her minör 
    numaraya ilişkin  boru uzunlukları farklılaşabilecektir.

    - ioctl işlemleri farklı proseslerden aynı anda yapılabileceği için işlemlerin genel olarak senkronize edilmesi gerekir.

    - Aygıt sürücümüz içerisindeki ioctl fonksiyonu aşağıdaki gibi yazılmıştır:

    static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        struct PIPE_DEVICE *pipedev;
        int result;

        printk(KERN_INFO "ioctl\n");

        pipedev = (struct PIPE_DEVICE *)filp->private_data;

        if (down_interruptible(&pipedev->sem))
            return -ERESTARTSYS;

        switch (cmd) {
            case IOC_PIPE_GETNDEVICES:
                result =  put_user(ndevices, (size_t *)arg);
                break;
            case IOC_PIPE_GETCOUNT:
                result =  put_user(pipedev->count, (size_t *)arg);
                break;
            case IOC_PIPE_GETBUFSIZE:
                result = put_user(pipedev->bufsize, (size_t *)arg);
                break;
            case IOC_PIPE_SETBUFSIZE:
                result = set_bufsize(pipedev, arg);
                break;
            case IOC_PIPE_PEEK:
                result = read_peek(pipedev, arg);
                break;
            default:
                result = -ENOTTY;
        }

        up(&pipedev->sem);

        return result;
    }

    Burada biz ioctl fonksiyonun hemen başında bir kritik kod oluşturduk. Tabii kritik kodun mümkün olduğunca küçük bir kod
    parçasını içermesini sağlamalısınız. Ancak buradaki örneğimizde tüm fonksiyonu kilitlemenin önemli bir sakıncası yoktur. 
    set_busize fonksiyonu borunun kullandığı tamponu büyütme ya da küçültme işlevini yerine getirmektedir. peek_read fonksiyonu 
    ise borudan bilgiyi atmadan okuma yapmaktadır. Normal olarak borudan read fonksiyonu ile okuma yapıldığında okunanlar borudan 
    atılmaktadır. Ancak bu ioctl kodu ile borudan okuma yapıldığında okunanlar borudan atılmamaktadır. Bu ioctl kodu için aşağıdaki 
    gibi bir yapı oluşturulmuştur:

    struct PIPE_PEEK {
        size_t size;
        void *buf;
    };

    Yapının size elemanı kaç byte peek işleminin yapılacağını, buf elemanı ise peek edilen byte'ların yerleştirileceği adresi
    belirtmektedir. Tabii boruda mevcut olan byte sayısından daha fazla byte peek edilmek istenirse boruda olan kadar byte peek 
    edilmektedir. Peek edilen byte sayısı aygıt sürücü tarafından yapının size elemanına aktarılmaktadır. 

    Aygıt sürücümüzü yine "loadmulti" script'i ile aşağıdaki gibi yükleyebilirsiniz:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Aygıt sürücünün çekirdekten atılması da yine "unloadmulti" script'i ile aşağıdaki gibi yapılabilir:

    $ sudo ./unloadmulti 10 pipe-driver

    Buradaki aygıt sürücünün testi için üç ayrı program kullandık. "pipe-ioctl-test.c" programı bu IOCTL komutlarını aygıt 
    sürücüye yollamaktadır. Tabii test işlemini yalnızca bu programı değil başka bir termianlden daha önce yazmış olduğumuz 
    "pwriter" ve "preader" programlarını da çalıştırmalısınız. 

    Aşağıda tüm kodlar verilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	return 0;

EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static void __exit pipe_driver_exit(void)
{
	int i;

    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

void exit_sys(const char *msg);
void disp_pipe_info(int fd);

int main(int argc, char *argv[])
{
	int fd;
	struct PIPE_PEEK pp;
	unsigned char pbuf[1024];

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	printf("Press ENTER to continue...\n");
	getchar();

	disp_pipe_info(fd);

	if (ioctl(fd, IOC_PIPE_SETBUFSIZE, 20ul) != 0) 
		exit_sys("ioctl");

	disp_pipe_info(fd);

	printf("number opf bytes to peek?");
	scanf("%zu", &pp.size);
	pp.buf = pbuf;

	if (ioctl(fd, IOC_PIPE_PEEK, &pp) != 0) 
		exit_sys("ioctl");

	pbuf[pp.size] = '\0';
	printf("Peek bytes: %s\n", pbuf);

	close(fd);

	return 0;
}

void disp_pipe_info(int fd)
{
	size_t ndevices, count, bufsize;

	if (ioctl(fd, IOC_PIPE_GETNDEVICES, &ndevices) != 0) 
		exit_sys("ioctl");
	printf("number of pipe: %zu\n", ndevices);

	if (ioctl(fd, IOC_PIPE_GETCOUNT, &count) != 0) 
		exit_sys("ioctl");
	printf("number of bytes in pipe: %zu\n", count);

	if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &bufsize) != 0) 
		exit_sys("ioctl");
	printf("pipe buffer size: %zu\n", bufsize);
	
	printf("---------------------------\n");
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte boru aygıt sürücüsü için birkaç ioctl komutu uygulanmıştır. Buradaki IOCTL kodları şöyle oluşturulmuştur:

    #define PIPE_DRIVER_MAGIC           'p'
    
    #define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
    #define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
    #define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
    #define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
    #define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

    Bu komut kodlarının ne yaptıklarını şöyle açıklayabiliriz:
    
    IOC_PIPE_GETCOUNT: Aygıt sürücünün kulllanabildiği boru sayısını (yani minör numara miktarını) elde etmek için 
    kullanılmaktadır.

    IOC_PIPE_GETCOUNT: Boruda o anda bulunan byte sayısını elde etmek için kullanılmaktadır.
    
    IOC_PIPE_GETNDEVICES: Kullanılmakta olan borunun uzunluğunu elde etmek için kullanılmaktadır. 

    IOC_PIPE_SETBUFSIZE: Kullanılmakta olan borunun uzunluğunu (yani buffer uzunluğunu) değiştirmekte kullanılmaktadır.

    IOC_PIPE_PEEK: Borudan okuma yapmakta kullamılır. Ancak okunanlar borudan atılmaz. 

     Bu örnek için yukarıda vermiş olduğumuz boru aygıt sürücüsünde bazı değişiklikler yaptık. Bu değişiklikler şunlardır:

    - Artık borunun uzunluğu PIPE_DEVICE yapısının içerisinde tutulmaya başlanmıştır:

    struct PIPE_DEVICE {
        unsigned char *buf;
        size_t bufsize;
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Buradaki bufsize elemanı ilgili borunun uzunluğunu belirtmektedir. Default uzunluk PIPE_DEF_BUFFER_SIZE değeri kadardır. 
    Bu değer örneğimizde test için kolaylık sağlamak amacıyla 10 olarak alınmıştır. Bu değişiklik sayesinde artık her minör 
    numaraya ilişkin  boru uzunlukları farklılaşabilecektir.

    - ioctl işlemleri farklı proseslerden aynı anda yapılabileceği için işlemlerin genel olarak senkronize edilmesi gerekir.

    - Aygıt sürücümüz içerisindeki ioctl fonksiyonu aşağıdaki gibi yazılmıştır:

    static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        struct PIPE_DEVICE *pipedev;
        int result;

        printk(KERN_INFO "ioctl\n");

        pipedev = (struct PIPE_DEVICE *)filp->private_data;

        if (down_interruptible(&pipedev->sem))
            return -ERESTARTSYS;

        switch (cmd) {
            case IOC_PIPE_GETNDEVICES:
                result =  put_user(ndevices, (size_t *)arg);
                break;
            case IOC_PIPE_GETCOUNT:
                result =  put_user(pipedev->count, (size_t *)arg);
                break;
            case IOC_PIPE_GETBUFSIZE:
                result = put_user(pipedev->bufsize, (size_t *)arg);
                break;
            case IOC_PIPE_SETBUFSIZE:
                result = set_bufsize(pipedev, arg);
                break;
            case IOC_PIPE_PEEK:
                result = read_peek(pipedev, arg);
                break;
            default:
                result = -ENOTTY;
        }

        up(&pipedev->sem);

        return result;
    }

    Burada biz ioctl fonksiyonun hemen başında bir kritik kod oluşturduk. Tabii kritik kodun mümkün olduğunca küçük bir kod
    parçasını içermesini sağlamalısınız. Ancak buradaki örneğimizde tüm fonksiyonu kilitlemenin önemli bir sakıncası yoktur. 
    set_busize fonksiyonu borunun kullandığı tamponu büyütme ya da küçültme işlevini yerine getirmektedir. peek_read fonksiyonu 
    ise borudan bilgiyi atmadan okuma yapmaktadır. Normal olarak borudan read fonksiyonu ile okuma yapıldığında okunanlar borudan 
    atılmaktadır. Ancak bu ioctl kodu ile borudan okuma yapıldığında okunanlar borudan atılmamaktadır. Bu ioctl kodu için aşağıdaki 
    gibi bir yapı oluşturulmuştur:

    struct PIPE_PEEK {
        size_t size;
        void *buf;
    };

    Yapının size elemanı kaç byte peek işleminin yapılacağını, buf elemanı ise peek edilen byte'ların yerleştirileceği adresi
    belirtmektedir. Tabii boruda mevcut olan byte sayısından daha fazla byte peek edilmek istenirse boruda olan kadar byte peek 
    edilmektedir. Peek edilen byte sayısı aygıt sürücü tarafından yapının size elemanına aktarılmaktadır. 

    Aygıt sürücümüzü yine "loadmulti" script'i ile aşağıdaki gibi yükleyebilirsiniz:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Aygıt sürücünün çekirdekten atılması da yine "unloadmulti" script'i ile aşağıdaki gibi yapılabilir:

    $ sudo ./unloadmulti 10 pipe-driver

    Buradaki aygıt sürücünün testi için üç ayrı program kullandık. "pipe-ioctl-test.c" programı bu IOCTL komutlarını aygıt 
    sürücüye yollamaktadır. Tabii test işlemini yalnızca bu programı değil başka bir termianlden daha önce yazmış olduğumuz 
    "pwriter" ve "preader" programlarını da çalıştırmalısınız. 

    Aşağıda tüm kodlar verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	return 0;

EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static void __exit pipe_driver_exit(void)
{
	int i;

    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* pipe-ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

void exit_sys(const char *msg);
void disp_pipe_info(int fd);

int main(int argc, char *argv[])
{
	int fd;
	struct PIPE_PEEK pp;
	unsigned char pbuf[1024];

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	printf("Press ENTER to continue...\n");
	getchar();

	disp_pipe_info(fd);

	if (ioctl(fd, IOC_PIPE_SETBUFSIZE, 20ul) != 0) 
		exit_sys("ioctl");

	disp_pipe_info(fd);

	printf("number opf bytes to peek?");
	scanf("%zu", &pp.size);
	pp.buf = pbuf;

	if (ioctl(fd, IOC_PIPE_PEEK, &pp) != 0) 
		exit_sys("ioctl");

	pbuf[pp.size] = '\0';
	printf("Peek bytes: %s\n", pbuf);

	close(fd);

	return 0;
}

void disp_pipe_info(int fd)
{
	size_t ndevices, count, bufsize;

	if (ioctl(fd, IOC_PIPE_GETNDEVICES, &ndevices) != 0) 
		exit_sys("ioctl");
	printf("number of pipe: %zu\n", ndevices);

	if (ioctl(fd, IOC_PIPE_GETCOUNT, &count) != 0) 
		exit_sys("ioctl");
	printf("number of bytes in pipe: %zu\n", count);

	if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &bufsize) != 0) 
		exit_sys("ioctl");
	printf("pipe buffer size: %zu\n", bufsize);
	
	printf("---------------------------\n");
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                150. Ders 28/06/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Anımsanacağı gibi proc dosya sistemi disk tabanlı bir dosya sistemi değildir. proc dosya sistemi çekirdek çalışması sırasında 
    çekirdeğin dış dünyaya bilgi vermesi için bazen de davranışını dış dünyadan gelen bilgilerle değiştirebilmesi için tasarlanmıştır 
    Daha sonraları benzer amaçlarla sys isimli bir dosya sistemi de Linux'a eklenmiştir.

    proc dosya sistemi yalnızca çekirdek tarafından değil aygıt sürücüler tarafından da kullanılabilmektedir. Ancak bu dosya 
    sisteminin içerisinde kullanıcı modundan dosyalar ya da dizinler yaratılamamaktadır. proc dosya sistemindeki tüm girişlerin 
    dosya uzunlukları 0 biçiminde rapor edilmektedir. proc dosya sisteminin bütün kontrolü çekirdek tarafından çekirdeğin
    içerisindeki fonksiyonlarla sağlanmaktadır. Yani proc dosya sistemi çekirdeğin bir parçasını oluşturmaktadır.

    proc dosya sisteminin kullanımına yönelik çekirdek fonksiyonları çekirdeğin versiyonları ile zaman içerisinde birkaç kez 
    değiştirilmiştir. Dolayısıyla eski çekirdeklerde çalışan kodlar yeni çekirdeklerde derlenmeyecektir. Biz kursumuzda bu 
    fonksiyonların son hallerini ele alıp açıklayacağız.

    Aygıt sürücümüz proc dosya sisteminde bir dosya yaratmış olsun. Kullanıcı modundan bu dosya üzerinde open, read, write, 
    lseek, close gibi işlemler yapıldığında aslında aygıt sürücümüzün belirlediği fonksiyonlar çağrılmaktadır. Yani örneğin 
    biz kullanıcı modundan proc dosya sistemi içerisindeki bir dosyadan okuma yapmak istediğimizde aslında onu oluşturan 
    aygıt sürücünün içerisindeki bir okuma fonksiyonu çağrılmaktadır. Bu fonksiyon bize okuma sonucunda elde edilecek bilgileri 
    vermektedir. Benzer biçimde proc dosya sistemindeki bir dosyaya kullanıcı modundan yazma yapılmak istendiğinde aslında 
    o dosyayı yaratan aygıt sürücünün bir yazma fonksiyonu çağrılmaktadır. Yani proc dosya sistemi aslında bilgileri statik 
    biçimde tutan dosyalardan oluşmamaktadır. Dosyada bulunduğu varsayılan bilgiler talep edildiğinde aygıt sürücüler 
    tarafından kullanıcıya verilmektedir. 

    Aslında proc dosya sistemi üzerinde işlemler yapmak için bir aygıt sürücüsü oluşturulması zorunlu değildir. Çekirdek 
    modlleri de proc dosya süstemi üzerinde aşağıda açıklayacağımız biçimde işlemler yapabilir. Ancak biz temel örneklerimizi 
    yine de bir karakter aygıt sürücüsü üzerinde vereceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    proc dosya sisteminde bir dosya yaratabilmek için proc_create isimli fonksiyon kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_create(const char *name, umode_t mode, 
        struct proc_dir_entry *parent, const struct proc_ops *proc_ops);

    Fonksiyonun birinci parametresi proc dosya sisteminde yaratılacak olan dosyanın ismini belirtir. İkinci parametresi ise 
    erişim haklarını belirtmektedir. Bu parametre 0 geçilirse default erişim hakları kullanılır. Üçüncü parametre dosyanın 
    hangi dizinde yaratılacağını belirtmektedir. Bu parametre NULL geçilirse dosya ana "/proc" dizini içerisinde yaratılır. 
    proc dosya sistemi içerisinde dizinlerin nasıl yaratıldığını izleyen paragraflarda açıklayacağız. Son parametre proc dosya 
    sistemindeki ilgi dosyaya yazma ve okuma gibi işlemler yapıldığında çağrılacak fonksiyonları belirtmektredir. Aslında 
    Linux'un 3.10 çekirdeklerine kadarki çekirdeklerde bu fonksiyonun son parametresi proc_ops yapısını değil, file_operations 
    yapısını kullanıyordu. Dolayısıyla çekirdeğinizdeki fonksiyonun son parametresinin ne olduğuna dikkat ediniz. proc_ops 
    yapısı şöyle bildirilmiştir:

    #include <linux/proc_fs.h>

    struct proc_ops {
        unsigned int proc_flags;
        int    (*proc_open)(struct inode *, struct file *);
        ssize_t    (*proc_read)(struct file *, char __user *, size_t, loff_t *);
        ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
        ssize_t    (*proc_write)(struct file *, const char __user *, size_t, loff_t *);
        /* mandatory unless nonseekable_open() or equivalent is used */
        loff_t    (*proc_lseek)(struct file *, loff_t, int);
        int    (*proc_release)(struct inode *, struct file *);
        __poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
        long    (*proc_ioctl)(struct file *, unsigned int, unsigned long);
    #ifdef CONFIG_COMPAT
        long    (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
    #endif
        int    (*proc_mmap)(struct file *, struct vm_area_struct *);
        unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    };

    proc_ops yapısının elemanlarına ilişkin fonksiyon göstericilerinin türlerinin file_operations yapısındaki elemanlara ilişkin
    fonksiyon göstericilerinin türleri ile aynı olduğuna dikkat ediniz. Bu fonksiyonların kullanımı tamamen aygıt sürücü 
    için oluşturduğumuz file_operations yapısı ile aynı biçimdedir.

    proc dosya sistemi genel olarak text tabanlı bir dosya sistemi biçiminde düşünülmüştür. Yani buradaki dosyalar genel olarak 
    text içeriğe sahiptir. Siz de aygıt sürücünüz için proc dosya sisteminde dosya oluşturacaksanız onların içeriğini text 
    olarak oluşturmalısınız. (proc dosya sisteminde binary bir dosya içeriği oluşturmak mümkündür. Ancak kullanıcıların beklentisi
    bu yönde değildir.)

    proc_create fonksitonu başarı durumunda yaratılan dosyanın bilgilerini içeren proc_dir_entry türünden bir yapı nesnesinin 
    adresiyle, başarısızlık durumunda NULL adresle geri dönmektedir. Bu durumda çağıran fonksiyonun -ENOMEM gibi bir hata 
    değeriyle geri döndürülmesi yaygındır.

    proc dosya sisteminde yaratılan dosya remove_proc_entry fonksiyonuyla silinebilmektedir. Fonksiyonun parametrik yapısı 
    şöyledir:

    #include <linux/proc_fs.h>

    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi silinecek dosyanın ismini, ikinci parametresi dosyanın içinde bulunduğu dizine ilişkin 
    proc_dir_entry nesnesinin adresini almaktadır. Yine bu parametre NULL adres girilirse dosyanın ana "/proc" dizininde
    olduğu kabul edilmektedir. 

    proc dosya sisteminde yarattığınız dosyaları aygıt sürücüyü kaldırırken silmeyi unutmayınız. Aksi takdirde bu dosyalar 
    kullanılırken tüm sistem çökebilir. 

    Aşağıdaki örnekte proc dosya sisteminde dosya yaratan iskelet bir aygıt sürücü programı verilmiştir. Bu aygıt sürücüde 
    "/proc"  dizininde "proc-driver" isminde bir dosya yaratılmaktadır. Aygıt sürücüyü install ettikten sonra "/proc" 
    dizininde bu dosyanın yaratılıp yaratılmadığını kontrol ediniz. Biz bu örnekte ilgili dosyaya yazma yapılmasını da 
    sağladık. Örneğimizde bu dosya okunduğunda aslında aygıt sürücümiz içerisindeki int türdne g_val değişkeninin içerisindeki 
    değer sanki bir yazıymış gibi okunmaktadır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32];
        size_t esize, left;

        sprintf(valbuf, "%d\n", g_val);
        left = strlen(valbuf) - *off;
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf + *off, esize) != 0) 
            return -EFAULT; 
        *off += esize;

        return esize;
    } 
    
    Benzer biçimde bu dosyaya yazma yapıldığında yazılan karakterler önce bir diziye yazılmış sonra g_val global değişkenine
    akratılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32 + 1];
        size_t esize;
        int val;
        int result;

        if (*off > 0)
            return 0;

        esize = size > 32 ? 32 : size;

        if (copy_from_user(valbuf, buf, esize) != 0) 
            return -EFAULT; 
        valbuf[esize] = '\0'; 
        if ((result = kstrtoint(valbuf, 10, &val)) != 0)
            return result;
            
        g_val = val;

        *off += esize;

        return esize;
    }

    Buradaki örnekte write işleminde dosya göstericisinin konumunun hiç dikkate alınmadığına dikkat ediniz. Yani örneğimizde
    parçalı yazıma olanak verilmemiştir. Gerçekten de aygıt sürücüleri yazanlar bu tür durumlarda parçalı yazmaya hatta 
    parçalı okumaya izin vermemektedir. 

    Test sırasında yazma işlemini aşağıdaki örnekte olduğu gibi yapmayı unutmayınız:

    echo "1000" | sudo tee /proc/proc-driver
---------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
 #include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    if (proc_create("proc-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create proc-driver file!..\n");
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
        
    g_val = val;

    *off += esize;

    return esize;
}

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                                151. Ders 30/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosyayı proc dosya sisteminin kök dizininde yarattık. İstersek proc dizininde bir dizin yaratıp 
    dosyalarımızı o dizinin içerisinde de oluşturabilirdik. Eğer aygıt sürücü içerisinde proc dosya sisteminde çok fazla dosya 
    yaratılacaksa bunların proc dizinin kökünde değil ayrı bir dizinde yaratılması daha iyi bir tekniktir.
    
    proc dosya sisteminde bir dizin yaratmak için proc_mkdir fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi yaratılacak dizinin ismini, ikinci parametresi dizinin hangi dizin içerisinde yaratılacağını 
    belirtir. Bu parametre NULL geçilirse dizin proc dosya sisteminin kök dizininde yaratılır. Buradan aldığımız geri dönüş 
    değerini proc_create fonksiyonunun parent parametresinde kullanırsak ilgili dosyamızı bu dizinde yaratmış oluruz. Tabii 
    benzer biçimde dizin içerisinde dizin de yaratabiliriz. proc_mkdir fonksiyonu başarısızlık durumunda NULL adrese geri 
    dönmektedir. Başarısızlık durumunda çağıran fonksiyonun yine -ENOMEM değeriyle geri döndürülmesi uygundur. Örneğin:

    struct proc_dir_entry *pdir;
    ...

    if ((pdir = proc_mkdir("procfs-driver", NULL)) == NULL) 
        return -ENOMEM;

    if (proc_create("info", 0, pdir, &g_proc_ops) == NULL) {
        ...
        return -ENOMEM;
    }

    Dizinlerin silinmesi yine remove_proc_entry fonksiyonuyla yapılmaktadır. Tabii dizin içerisindeki dosyaları silerken 
    remove_proc_entry fonksiyonunda dosyanın hangi dizin içerisinde olduğu belirtilmelidir. Bu fonksiyon ile dizin silinirken 
    dizinin içi boş değilse bile o dizin ve onun içindeki girişlerin hepsi silinmektedir. (Halbuki disk tabanlı dosya sistemlerinde 
    ancak içi boş olan dizinler silinebilmektedir.) Ayrıca kök dizindeki girişleri silmek için proc_remove fonksiyonu da 
    bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    void proc_remove(struct proc_dir_entry *de);

    Bu fonksiyon parametre olarak proc_create ya da proc_mkdir fonksiyonunun verdiği geri dönüş değerini alır. proc dosya 
    sisteminin kök dizininde silme yapılmak isteniyorsa aşağıdaki her iki çağrım eşdeğerdir:

    remove_proc_entry("file_name", NULL);
    proc_remove(pde);

    Aşağıdaki örnekte "proc-driver" isimli aygıt sürücüsünde önce proc dosya sisteminin kök dizininde "proc-driver" isimli 
    dizin yaratılmış onun da içerisinde "val" isimli bir dosya yaratmıştır. Sonra da bu dosyadan okuma yapıldığında aygıt 
    sürücü içerisindeki g_val değişkenindeki değer verilmiştir. Bu dosyaya yazma yapıldığında ise yazılan değer g_val 
    değişkenine yerleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;
    struct proc_dir_entry *dir;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {    
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT1;
    }

    if ((dir = proc_mkdir("proc-driver", NULL)) == NULL) {
        printk(KERN_ERR "cannot create proc-driver directory!..\n");
        result = -ENOMEM;
        goto EXIT2;
    }

    if (proc_create("val", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, dir, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create val file!..\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    return 0;

EXIT3:
    remove_proc_entry("proc-driver", NULL);
EXIT2:
    cdev_del(g_cdev);
EXIT1:
   unregister_chrdev_region(g_dev, 1);

    return result;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
    
    g_val = val;

    *off += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module


/*--------------------------------------------------------------------------------------------------------------------------
                                                152. Ders 06/07/2024 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                153. Ders 07/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yazmış olduğumuz boru aygıt sürücüsüne proc dosya sistemi desteği verelim. Bunun için proc dosya 
    sisteminde    aşağıdaki gibi bir dizin ve dosya yapısı kullanacak olalım:

    /proc
        pipe-driver <DIR>
            pipe-0 <DIR>
                bufsize
                count
            pipe-1 <DIR>
                bufsize
                count
            pipe-2 <DIR>
                bufsize
                count
            pipe-3 <DIR>
                bufsize
                count
            ...
        
    Örneğimizde "/proc" dizinin kök dizininde "pipe-driver" isimli bir dizin, bu dizinin içerisinde de minör numara kadar 
    "pipe-N" dizinleri yaratılacaktır. Her "pipe-N" dizinin içerisinde "bufsize" ve "count" isminde iki dosya bulundurulacaktır.
    "bufsize" dosyası read/write, count dosyası ise read-only biçimde olacaktır. Böylece bir kişi hiç ioctl yapmadan boruların 
    uzunluklarını alıp değiştirebilecek ve bir borunun içerisinde kaç byte olduğunu anlayabilecektir. 

    Yukarıdaki gibi bir örnek için proc dosya sistemi desteğini sağlarken sorun oluşturabilecek iki önemli nokta vardır:

    1) Birden fazla proc dosyasıyla işlem yaparken her dosya için ayrı bir proc_read, proc_write fonksiyonu oluşturmak oldukça
    zahmetlidir. İdeal olan durum tek bir proc_read, proc_write fonksiyonu yazıp bu fonksiyonun birden fazla dosya üzerinde 
    işlem yapabilmesini sağlamaktır. 

    2) Boru aygıt sürücüsü örneğimizde birden fazla minör numaraya ilişkin birden fazla boru söz konusudur. Dolayısıyla bizim 
    kod içerisinde bir biçimde hangi boru üzerinde işlem yapıldığını bilmemiz gerekir. 

    İşte proc dosya sisteminde bir dosya yaratmak için kullandığımız proc_create fonksiyonunun proc_create_data isimli bir
    biçimi de vardır. proc_create_data fonksiyonunun prototipi şöyledir:

    struct proc_dir_entry *proc_create_data(const char *name, umode_t mode, struct proc_dir_entry *parent, 
        const struct proc_ops *proc_ops, void *data);

    Linux çekirdeğinin 5.17 versiyonundan öncesinde buradaki data adresi proc_dir_entry yapısı içerisindeki data elemanına 
    yerleştiriliyordu. Bu versiyonlarda inode nesnesi yoluyla proc dosyasına ilişkin proc_dir_entry yapısına ise PDE_DATA 
    isimli fonksiyonla erişiliyordu. Erişimde kullanılan fonksiyonları ver yapıları aşağıda veriyoruz:

    void *PDE_DATA(const struct inode *inode)
    {
        return __PDE_DATA(inode);
    }

    static inline void *__PDE_DATA(const struct inode *inode)
    {
        return PDE(inode)->data;
    }

    static inline struct proc_dir_entry *PDE(const struct inode *inode)
    {
        return PROC_I(inode)->pde;
    }

    static inline struct proc_inode *PROC_I(const struct inode *inode)
    {
        return container_of(inode, struct proc_inode, vfs_inode);
    }

    struct proc_inode {
        struct pid *pid;
        unsigned int fd;
        union proc_op op;
        struct proc_dir_entry *pde;
        struct ctl_table_header *sysctl;
        struct ctl_table *sysctl_entry;
        struct hlist_node sibling_inodes;
        const struct proc_ns_operations *ns_ops;
        struct inode vfs_inode;
    } __randomize_layout;

    file yapısından inode yapısına daha hızlı erişimi sağlamak için belli bir versiyondan sonra file yapısının içerisine
    f_inode elemanının eklendiğinden bahsetmiştik. Bu işlemin geçmişe ve geleceğe doğru uyumu koruyarak yapılmasını sağlamak 
    için ise file_inode fonksiyonu bulundurulmuştur. Bu fonksiyonunun mevcut çekirdeklerdeki tanımlması şöyle yapılmıştır:

    static inline struct inode *file_inode(const struct file *filp)
    {
        return filp->f_inode;
    }

    O halde 5.17 öncesi çekirdeklerde verilen bu adres filp göstericisi yoluyla şöyle elde edilmektedir:

    data = PDE_DATA(file_inode(filp));

    Ancak 5.17 çekirdeğinden itibaren artık proc_create_data fonksiyonuna verilen data adresi doğrudan i_node nesnesinin
    i_private elemanına yerleştirilmektedir. Dolayısıyla yeni çekirdeklerde artık proc_create_data fonksiyonuna geçirilen 
    data parametresine şöyle erişilmektedir:

    data = file_inode(filp)->i_private;

    Aslında yeni çekirdeklerde inode nesnesinin adresinden hareketle inonde nesnesinin i_private elemanını veren pde_data 
    isimli ayrı bir fonksiyon da bulunmaktadır:

    static inline void *pde_data(const struct inode *inode)
    {
        return inode->i_private;
    }

    O halde yeni çekirdeklerde proc_create_data fonksiyonuna girilen data adresi şöyle de elde edilebilmektedir:

    data = pde_data(file_inode(filp));

    Örneğimizde proc_create_data fonksiyonuna aşağıdaki yapı türünden nesnenin adresi geçirilmiştir:

    struct PROC_FILE_INFO {
        struct PIPE_DEVICE *pipedev;
        int procfile;	
    };

    Yapının procfile elemanı hangi proc dosyasının kullanıldığını belirtmektedir. Bu değerin 0 olması bufsize dosyasının 
    1 olması ise count dosyasının kullanıldığı anlamına gelmektedir:

    for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

    Örneğimizdeki proc_read fonksiyonu şöyle yazılmıştır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        ssize_t result;
        size_t esize, left;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) 								// bufsize
            sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
        else if (pfi->procfile == 1) 
            sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
        else {										
            result = 0;
            goto EXIT;
        }

        left = strlen(valbuf);
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf, esize) != 0)  {
            result = -EFAULT; 
            goto EXIT;
        }
        *off += esize;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda parçalı okumaya izin verilmemektedir. proc_write fonksiyonu da benzer biçimde yazılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        size_t esize;
        ssize_t  result;
        int val;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) { 								// bufsize
            esize = size > 32 ? 32 : size;
            if (copy_from_user(valbuf, buf, esize) != 0) {
                result = -EFAULT; 
                goto EXIT;
            }
            valbuf[esize] = '\0'; 
            if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
                goto EXIT;
            if ((result = set_bufsize(pfi->pipedev, val)) != 0)
                goto EXIT;
            *off += esize;
        }
        else 									
            result = 0;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda da parçalı okumaya izin verilmediğine dikkat ediniz. Örneğin tüm kodlarını aşağıda veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int create_proc_files(void);
static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

struct PROC_FILE_INFO {
	struct PIPE_DEVICE *pipedev;
	int procfile;	
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;
struct PROC_FILE_INFO *g_proc_info;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	if (create_proc_files() != 0)
		goto EXIT6;

	return 0;

EXIT6:
	for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[k]->cdev);
EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static int create_proc_files(void)
{
	struct proc_dir_entry *pdir1, *pdir2;
	int i;
	char pname[16];
	struct PROC_FILE_INFO *pfi;

	if ((pdir1 = proc_mkdir("pipe-driver", NULL)) == NULL)
		return -1;

	if ((g_proc_info = (struct PROC_FILE_INFO *)kmalloc(sizeof(struct PROC_FILE_INFO) * ndevices * 2, GFP_KERNEL)) == NULL)
		goto EXIT1;

	for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

	return 0;

EXIT2:
	kfree(g_proc_info);
EXIT1:
	remove_proc_entry("pipe-driver", NULL);

	return -1;
}

static void __exit pipe_driver_exit(void)
{
	int i;

	kfree(g_proc_info);
	remove_proc_entry("pipe-driver", NULL);
    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;
		
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}


static int proc_open(struct inode *inodep, struct file *filp)
{
    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	ssize_t result;
	size_t esize, left;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) 								// bufsize
		sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
	else if (pfi->procfile == 1) 
		sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
	else {										
		result = 0;
		goto EXIT;
	}

	left = strlen(valbuf);
  	esize = size > left ? left : size;

	if (copy_to_user(buf, valbuf, esize) != 0)  {
		result = -EFAULT; 
		goto EXIT;
	}
	*off += esize;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
    
	return result;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	size_t esize;
	ssize_t  result;
	int val;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) { 								// bufsize
		esize = size > 32 ? 32 : size;
		if (copy_from_user(valbuf, buf, esize) != 0) {
			result = -EFAULT; 
			goto EXIT;
		}
    	valbuf[esize] = '\0'; 
    	if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
        	goto EXIT;
		if ((result = set_bufsize(pfi->pipedev, val)) != 0)
			goto EXIT;
		*off += esize;

	}
	else 									
		result = 0;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
	
    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde aygıt sürücülerde zamanlama işlemlerinin nasıl yapılacağı üzerinde duracağız. Aygıt sürücülerde zamanlama 
    işlemleri bazı uygulamalarda kritik önemde olabilmektedir. Örneğin programcının bir IO port'una bir bilgi gönderdikten 
    sonra diğerini göndermek için belli bir süre beklemesi gerekebilir. Bazen programcı belli bir süre sonra birtakım işlemlerin 
    yapılmasını isteyebilir. Masaüstü Linux sistemleri "katı gerçek zamanlı (hard real time)" işlemler için uygun olmasa da bazı 
    "gevşek gerçek zamanlı (soft real time)" işlemlere olanak sağlayabilmektedir. Gerçek zamanlı işlemlerde kritik zamanlamalar 
    söz konusu olabilmektedir. İşte Linux'ta bu tür bekleme işlemleri çekirdeğin sunduğu mekanizmalar yoluyla yapılmaktadır. 

    Linux çekirdeğinde zamanlama işlemleri iki yolla gerçekleştirilmektedir:

    1) Periyodik donanım kesmeleri yoluyla
    2) İşlemcilerin sunduğu TSC (time stamp counter) mekanizması yoluyla

    Uzun süreli zamanlama işlemlerinde periyodik donanım kesmelerinden kısa süreli zamanlama işlemlerinde ise işlemcilerin sunduğu 
    TSC mekanizmasından faydalanılmaktadır. 

    Zamanlama işlemleri için periyodik donanım kesmeleri oluşturan devrelerden faydalanılmaktadır. Örneğin klasik PC mimarisinde 
    CPU üzerinde periyodik kesme oluşturmak için Intel'in 8254 "Programmable Interval Timer (PIT)" denilen entegre devresi 
    kullanılıyordu. Bugün Intel tabanlı PC'lerde hala bu donanım birimi bulundurulmaktadır. Ancak belli bir zamandan sonra 
    PC board'larına daha yüksek çözünürlüklü periyodik donanım kesmesi oluşturmak için chipset'ler içerisine yeni donanım 
    birimleri de eklenmiştir. Periyodik donanım kesmesi oluşturmak için kullanılan bu yüksek çözünürlüklü birimlere "HPET (High 
    Precision Event Timer)" de denilmektedir. 
    
    Belli bir süreden sonra Intel ve ARM işlemcilerine CPU içerisine de periyodik kesme oluşturan zamanlayıcı devreler eklenmiştir. 
    Bunlara PC mimarisinde "APIC Timer (Advanced Progammable Interrupt Controller Timer)" ya da "yerel timer (local timer)" 
    denilmektedir. Çok çekirdekli işlemcilerde her çekirdeğin ayrı bir "yerel timer" devresi bulunmaktadır. Bugünkü çok çekirdekli 
    sistemlerde thread'ler arası geçiş (context switch) bu yerel timer devrelerinin oluşturduğu kesmeler yoluyla gerçekleştirilmektedir. 
    
    Gömülü sistemlerde CPU'nun dışındaki periyodik kesme oluşturan donanım birimleri genellikle SoC içerisinde bulunmaktadır.
    Tabii ARM tabanlı gömülü sistemlerde aynı zamanda tıpkı Intel işlemcilerinde olduğu gibi CPU içerisinde de periyodik donanım 
    kesmeleri oluşturacak ayrı yerel timer devreleri vardır. Bu yerel timer devrelerine "ARM Generic Timer" da denilmektedir. 

    Özetle bugünkü Linux sistemlerinin çalıştırıdığı masaüstü sistemlerinde ve ARM tabanlı gömülü sistemlerde genel olarak olarak 
    iki zamanlayıcı devre bulunmaktadır:

    1) Global Timer devresi
    2) Her CPU'nun ya da çekirdeğin içerisindeki yerel timer devresi

    Global timer devresi Linux tarafından genel zamanlama işlemleri için, yerel timer devreleri ise ilgili çekirdekteki 
    thread'ler arası geçiş (context switch) işlemlerini sağlamak için kullanılmaktadır.
    
    Bugünkü Linux sistemlerinde bu global ve yerel timer devrelerinin hepsi 1 milisaniye, 4 milisaniye ya da 10 milisaniyeye 
    kurulmaktadır. Eskiden ilk Linux çekirdeklerinde 10 milisaniyelik periyotlar kullanılıyordu. Sonra bilgisayarlar hızlanınca 
    1 milisaniye periyot yaygın olarak kullanılmaya başlandı. Ancak bugünlerde 4 milisaniye periyotları kullanan çekirdekler 
    de yaygın biçimde bulunmaktadır. Aslında timer frekansı çekirdek konfigüre edilirken kullanıcılar tarafından da değiştirilebilmektedir. 
    (Anımsanacağı gibi çekirdek derlenmeden önce çekirdeğin davranışları üzerinde etkili olan parametrelerin belirlenmesi sürecine 
    "çekirdeğin konfigüre" edilmesi denilmektedir.) Ancak bu timer frekansı çekirdek boot parametreleri yoluyla değiştirilememektedir. 

    proc dosya sistemine belli bir çekirdek verisyonundan sonra "timer_list" isimli bir giriş de eklenmiştir. Bu dizin girişi 
    okunduğunda o sistemdeki çekirdeğin kullandığı timer devrelerine ilişkin bilgiler elde edilmektedir. Yine Linux'un kullandığı 
    timer kaynakları hakkında bilgiler sys dosya sisteminin içerisinden "/sys/devices/system/clocksource" dizininden de elde 
    edilebilmektedir. Bu dosyaların ayrıntılı formatları için Linux dokümanlarına başvurabilirsiniz. (İçerik olarak çekirdek 
    versiyonları arasında farklılıklar da söz konusu olabilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                154. Ders 12/07/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Global timer kesmelerine (PC mimarisinde IRQ0) ilişkin kesme kodları çekirdek içerisindeki jiffies isimli bir global değişkeni 
    artırmaktadır. Böylece eğer timer kesme periyodu biliniyorsa iki jiffies değeri arasındaki farka bakılarak bir zaman ölçümü 
    mümkün olabilmektedir. Tabii buradaki hesabın çözünürlüğü ancak global timer devresinin periyodu kadardır.

    Timer frekansı Linux çekirdeği içerisindeki HZ isimli sembolik sabitle belirtilmiştir. Timer frekansı çekirdek konfigüre 
    edilirken CONFIG_HZ konfigürasyon parametresi yoluyla değiştirilebilmektedir. Yukarıda da belirttiğimiz gibi genellikle 
    timer frekansı 1000 (1 ms) , 250 (4 ms) ya da 100 (10 ms) olmaktadır. (Ancak değişik mimarilerde farklı değerlerde olabilir.) 
    Örneğin kursun yapıldığı sanal makinede timer periyodu 1 milisaniyedir. Bu da saniyede 1000 kez timer kesmesinin oluşacağı 
    anlamına gelmektedir. Başka bir deyişle bu makinede HZ sembolik sabiti 1000 olarak define edilmiştir. Çekirdeğin CONFIG_HZ
    konfigürasyon parametresi değiştirildiğinde bu değişiklik HZ sembolik sabitine de yansıtılmaktadır. Çekirdek kodlarında 
    aşağıdaki gibi bir #define işlemi bulunmaktadır:

    #define HZ  CONFIG_H

    Ancak bazı özel ve uç durumlarda CONFIG_HZ değeri HZ değeri ile olmayabilmektedir. Ancak burda bu durum hakkında açıklama
    yapmayacağız.

    İşte global timer kesmesi her oluştuğunda işletim sisteminin kesme kodu (interrupt handler) devreye girip "jiffies" isimli 
    global değişkeni 1 artırmaktadır. Bu jiffies değişkeni unsigned long türdendir. Bilindiği gibi unsigned long türü 32 
    bit Linux sistemlerinde 4 byte, 64 bit Linux sistemlerinde 8 byte'tır. 32 bit Linux sistemlerinde ayrıca jiffies_64 isimli 
    bir değişken de bulunmaktadır. Bu değişken hem 32 bit sistemde hem de 64 bit sistemde 8 byte'tır. Aslında 32 bit sistemlerde 
    zaten jiffies değişkeni jiffies_64 değişkeninin düşük anlamlı 4 byte'ı durumundadır. 32 bit sistemde jiffies değişkeni 4 
    byte olduğu için bilgisayar çok uzun süre açık kalırsa taşma (overflow) oluşabilmektedir. Ancak 64 bit sistemlerde taşma 
    mümkün değildir. 32 bit sistemlerde jiffies_64 değeri çekirdek tarafından iki ayrı makine komutuyla güncellenmektedir. 
    Çünkü 32 bit sistemlerde 64 bit bir değeri belleğe tek hamlede yazmak mümkün değildir. Bu nedenle jiffies_64 değerinin 
    taşma durumunda yanlış okunabilme olasılığı vardır. Ayrıca bu jiffies_64 değeri okunurken de global timer kesmesi oluşabilir. 
    Overlow durumunda Hem 32 bit hem 64 bit sistemlerde 64 bitlik jiffies değerini düzgün bir biçimde okuyabilmek için get_jiffies_64 
    isimli fonksiyon bulundurulmuştur:

    #include <linux/jiffies.h>

    u64 get_jiffies_64(void);

    Biz 32 bit sistemde de olsak bu fonksiyonla 64 bitlik jiffies değerini düzgün bir biçimde okuyabiliriz. Bu fonksiyon düzgün
    okuma için gereken senkronizasyonu sağlamaktadır.

    Aşağıdaki örnekte çekirdek modülü içerisinde proc dosya sisteminde "jiffy-module" isimli bir dizin, bu dizinin içerisinde 
    de "jiffy" ve "hertz" isimli iki dosya yaratılmıştır. "jiffy" dosyası okunduğunda o anki jiffies değeri, "hertz" dosyası 
    okunduğunda ise timer frekansı elde edilmektedir. Çekirdek modülünü aşağıdaki gibi derleyip yükleyebilirsiniz:

    $ make file=jiffy-module
    $ sudo insmod jiffy-module.ko

    Boşaltımı da şöyle yapabilirsiniz:

    $ sudo rmmod jiffy-module.ko
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer 64 bit sistemde çalışıyorsak jiffies değerinin taşması (overflow olması) mümkün değildir. 
    Ancak 32 bit sistemlerde HZ değeri 1000 ise 49 günde taşma meydana gelebilmektedir. Aygıt sürücü programcısı bazen geçen 
    zamanı hesaplamak için iki noktada jiffies değerini alıp aradaki farka bakmak isteyebilmektedir. Ancak bu durumda 32 bit 
    sistemlerde "overflow" olasılığının ele alınması gerekir. İşaretli sayıların ikili sistemdeki temsiline dayanarak iki jiffies 
    arasındaki fark aşağıdaki gibi tek bir ifadeyle de hesaplanabilmektedir:

    unsigned long int prev_jiffies, next_jiffies;
    ...
    net_jiffies = (long) next_jiffies - (long) prev_jiffies;

    Çekirdek içerisinde iki jiffy değerini alarak bunları öncelik sonralık ilişkisi altında karşılaştıran aşağıdaki makrolar 
    bulunmaktadır:

    #include <linux/jiffies.h>

    time_after(jiffy1, jiffy2)
    time_before(jiffy1, jiffy2)
    time_after_eq(jiffy1, jiffy2)
    time_before_eq(jiffy1, jiffy2)

    Bu fonksiyonların hepsi bool bir değere geri dönmektedir. Bu fonksiyonlar 32 bit sistemlerde taşma durumunu da dikkate 
    almaktadır. time_after fonksiyonu birinci parametresiyle belirtilen jiffy değerinin ikinci parametresiyle belirtilen jiffy 
    değerinden sonraki bir jiffy değeri olup olmadığını belirlemekte kullanılmaktadır. Diğer fonksiyonlar da bu biçimde birinci 
    parametredeki jiffy değeri ile ikinci parametredeki jiffy değerini karşılaştırmaktadır. Tabii aslında eğer jiffies değerini 
    get_jiffies_64 fonksiyonuyla elde ediyorsanız yukarıdaki fonksiyonları kullanmanıza hiç gerek kalmaz.

    Çekirdek içerisinde jiffies değerini çeşitli biçimlere dönüştüren aşağıdaki fonksiyonlar da bulunmaktadır:

    #include <linux/time.h>

    unsigned long msecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);

    Bu işlemin tersini yapan da üç fonksiyon vardır:

    unsigned int jiffies_to_msecs(const unsigned long j);
    unsigned int jiffies_to_usecs(const unsigned long j);
    unsigned int jiffies_to_nsecs(const unsigned long j);

    Bu fonksiyonlar HZ sembolik sabitinin değerini dikkate almaktadır. HZ değerinin genel olarak CONFIG_HZ değeri ile aynı 
    olduğunu anımsayınız.

    Ayrıca jiffies değerini saniye ve nanosaniye biçiminde ayırıp bize struct timespec64 biçiminde bir yapı nesnesi olarak veren 
    jiffies_to_timespec64 isimli bir fonksiyon da vardır. Bunun tersi timespec64_to_jiffies fonksiyonuyla yapılmaktadır.

    timespec64 yapısı da şöyledir:

    struct timespec64 {
        time64_t    tv_sec;             /* seconds */
        long        tv_nsec;            /* nanoseconds */
    };

    Eski çekirdeklerde bu fonksiyonların yerine aşağıdaki fonksiyonlar bulunuyordu:

    #include <linux/time.h>

    unsigned long timespec_to_jiffies(struct timespec *value);
    void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
    unsigned long timeval_to_jiffies(struct timeval *value);
    void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);

    Aşağıdaki örnekte proc dosya sisteminde "jiffy-module" dizini içerisinde ayrıca "difference" isimli bir dosya da yaratılmıştır. 
    Bu dosya her okunduğunda önceki okumayla aradaki jiffies farkı yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static struct proc_ops g_procops_difference = {
    .proc_read = proc_read_difference,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("difference", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_difference) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    static char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off)
{
    char valbuf[64 + 1];
    static unsigned long long prev_jiffies;
    unsigned long long net_jiffies;
    struct timespec64 ts;
    size_t left, esize;

    if (*off > 0)
        return 0;

    if (prev_jiffies == 0)
        prev_jiffies = get_jiffies_64();

    net_jiffies = get_jiffies_64() - prev_jiffies;
    jiffies_to_timespec64(net_jiffies, &ts);

    sprintf(valbuf, "%llu seconds + %llu nanoseconds\n", 
        (unsigned long long)ts.tv_sec, (unsigned long long)ts.tv_nsec);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    prev_jiffies = jiffies;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde bazen belli bir süre bekleme yapmak gerekebilir. Biz kursumuzda daha önce user modda bekleme yapan 
    fonksiyonları görmüştük. Ancak o fonksiyonlar çekirdek modunda kullanılamamaktadır. Çekirdek modunda çekirdeğin sağladığı 
    olanaklarla bekleme yapılabilmektedir.

    Eğer bekleme süresi kısa ise bekleme işlemi meşgul bir döngü ile yapılabilir. Örneğin:

    while (time_before(jiffies, jiffies_target))
        schedule();

    Burada o anki jiffies değeri hedef jiffies değerinden küçükse schedule fonksiyonu çağrılmıştır. schedule fonksiyonu thread'i 
    uykuya yatırmamaktadır. Yalnızca thread'ler arası geçiş (context switch) oluşmasına yol açmaktadır. Yani bu fonksiyon uykuya 
    dalmadan CPU'yu bırakmak için kullanılmaktadır. schedule fonksiyonunu çağıran thread çalışma kuyruğunda (run queue) kalır. 
    Yine çalışma sırası ona geldiğinde kaldığı yerden çalışmaya devam eder. Ancak meşgul bir döngü içerisinde schedule işlemi 
    yine önemli bir CPU zamanın harcanmasına yol açmaktadır. Bu nedenle uzun beklemelerin yukarıdaki gibi yapılması tavsiye 
    edilmemektedir. Uzun beklemelerin uykuya dalarak yapılması gerekir.

    Uzun beklemeler bir wait kuyruğu oluşturulup wait_event_timeout ya da wait_event_interruptible_timeout fonksiyonlarıyla 
    koşul 0 yapılarak gerçekleştirilebilir. Ancak bunun için bir wait kuyruğunun oluşturulması gerekir. Bu işlemi zaten kendi 
    içerisinde yapan özel fonksiyonlar vardır.

    schedule_timeout fonksiyonu belli bir jiffy zamanı geçene kadar thread'i çekirdek tarafından bu amaçla oluşturulmuş olan 
    bir wait kuyruğunda bekletir.

    #include <linux/sched.h>

    signed long schedule_timeout(signed long timeout);

    Fonksiyon parametre olarak beklenecek jiffy değerini alır. Eğer fonksiyon sinyal dolayısıyla sonlanırsa kalan jiffy sayısına, 
    zaman aşımının dolması nedeniyle sonlanırsa 0 değerine geri dönmektedir. schedule_timeout fonksiyonu başarısız olmaz. Fonksiyonu 
    kullanmadan önce prosesin durum bilgisini set_current_state isimli fonksiyonla değiştirmek gerekir. Değiştirilecek durum 
    TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE olabilir. Bu işlem yapılmazsa bekleme gerçekleşmemektedir. Örneğin bu fonksiyonla
    thread'i 10 saniye bekletmek isteyelim:

    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(10 * HZ);

    Uzun beklemeyi kendi içerisinde schedule_timeout kullanarak yapan üç yardımcı fonksiyon da vardır:

    #include <linux/delay.h>

    void msleep(unsigned int msecs);
    unsigned long msleep_interruptible(unsigned int msecs);
    void ssleep(unsigned int secs);

    Buradaki mseel ve msleep_interruptible mili saniye cinsinden, ssleep ise saniye cinsinden bekleme yapmaktadır. Yukarıda 
    da belirttiğimiz gibi bu fonksiyonlar aslında schedule_timeout fonksiyonu klullanılarak yazılmıştır. Örneğin msleep 
    fonksiyonu tanımlanmıştır:

    void msleep(unsigned int msecs)
    {
        unsigned long timeout = msecs_to_jiffies(msecs);

        while (timeout)
            timeout = schedule_timeout_uninterruptible(timeout);
    }

    Aşağıdaki örnekte "jiffy-module" dizinindeki "sleep" dosyasından okuma yapıldığında 10 saniye bekleme oluşacaktır.

    $ cat /proc/jiffy-module/sleep
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops = {
    .proc_read = proc_read,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("sleep", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    msleep_interruptible(10000);

    /*
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(10 * HZ);
    */

    printk(KERN_INFO "sleep file read...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                155. Ders 14/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde kısa beklemelerim yapılması gerekebilmektedir. Çünkü bazı donanım aygıtlarının programlanabilmesi 
    için bazı beklemelere gereksinim duyulabilmektedir. Kısa beklemeler meşgul döngü yoluyla yani hiç sleep yapılmadan sağlanmaktadır. 
    Ayrıca kısa bekleme yapan fonksiyonlar atomiktir. Atomiklikten kastedilen şey thread'ler arası geçiş (context switch) 
    mekanizmasının kapatılmasıdır. Yani kısa bekleme yapan fonksiyonlar bu bekleme sırasında thread'in quanta süresi bitse bile 
    bundan etkilenmemektedir. Tabii bu fonksiyonlar thread'ler arası geçiş işlemini o işlemci ya da çekirdek için kapatırlar. 
    Ancak donanım kesmeleri bu süre içerisinde oluşabilmektedir. Yani bir donanım kesmesi oluşursa buradaki bekleme belirlenen 
    süreyi aşabilir. Bu tür durumlarda programcının kendisinin donanım kesmelerini ilgili CPU ya da çekirdek için kapatması gerekir. 

    Kısa süreli döngü içerisinde bekleme yapan fonksiyonlar şunlardır:

    void ndelay(unsigned int nsecs);
    void udelay(unsigned int usecs);
    void mdelay(unsigned int msecs);

    Burada delay nanosaniye cinsinden bekleme yapmak için, udelay mikrosaniye cinsinden bekleme yapmak için, mdelay ise 
    milisaniye cinsinden bekleme yapmak için kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeklerine belli bir versiyondan sonra bir timer mekanizması da eklenmiştir. Bu sayede aygıt sürücü programcısı 
    belli bir zaman sonra belirlediği bir fonksiyonun çağrılmasını sağlayabilmektedir. Bu mekanizmaya "kernel timer" mekanizması 
    denilmektedir. Maalesef "kernel timer" mekanizması da birkaç kere arayüz olarak değiştirilmiştir. Bu mekanizma kullanılırken 
    dikkat edilmesi gereken bir nokta çağrılacak callback fonksiyonun bir proses bağlamında çağrılmadığıdır. Yani callback fonksiyon 
    çağrıldığında biz current makrosu ile o andaki prosese erişemeyiz. O anda çalışan prosesin kullanıcı alanına ilişkin kopyalamalar 
    yapamayız. Çünkü callback fonksiyon timer kesmeleri tarafından çağrılmaktadır. Dolayısıyla callback fonksiyon çağrıldığında
    o anda hangi prosesin thread'inin çalışmakta olduğu değişebilir.

    Son Linux çekirdeklerindeki kernel timer kullanımı aşağıdaki adımlardan geçilerek sağlanmaktadır:

    1) struct timer_list türünden bir yapı nesnesi statik düzeyde tanımlanır ve bu yapı nesnesine ilk değeri verilir. DEFINE_TIMER
    makrosu ile hem tanımlama hem de ilkdeğer verme işlemi birlikte yapılabilir. Makro şöyledir:

    #include <linux/time.h>

    #define DEFINE_TIMER(_name, _function)

    Örneğin:

    DEFINE_TIMER(g_mytimer, timer_proc);

    Ya da alternatif olarak struct timer_list nesnesi yaratılıp timer_setup makrosuyla da ilkdeğer verilebilir. Makronun 
    parametrik yapısı şöyledir:

    #include <linux/time.h>

    #define timer_setup(timer, callback, flags)

    Makronun birinci parametresi timer nesnesinin adresini almaktadır. İkinci parametresi çağrılacak fonksiyonu belirtir. 
    flags parametresi 0 geçilebilir.

    Örneğin:

    static struct timer_list g_mytimer;
    ...

    timer_setup(&g_mytimer, timer_proc, 0);

    Buradaki callback fonksiyonunun parametrik yapısı şöyle olmalıdır:

    void timer_proc(struct timer_list *tlist);

    2) Tanımlanan struct timer_list nesnesi add_timer fonksiyonu ile çekirdek içerisindeki bir bağlı listeye yerleştirilir. 
    Çekirdek timer nesnelerine bu bağlı listeden hareketle erişmektedir. add_timer fonksiyonunun prototipi şöyledir:

    #include <linux/time.h>

    void add_timer(struct timer_list *timer);

    3) Daha sonra callback fonksiyonun ne zaman çağrılacağını belirlemek için mod_timer fonksiyonu kullanılır. Fonksiyonun 
    prototipi şöyledir:

    #include <linux/time.h>

    int mod_timer(struct timer_list *timer, unsigned long expires);

    Buradaki expires parametresi jiffy türündendir. Ancak bu parametre hedef jiffy değerini içermelidir. (Yani jiffies + 
    gecikme jiffy değeri)

    4) Timer nesnesinin silinmesi için del_timer ya da del_timer_sync fonksiyonu kullanılmaktadır:

    #include <linux/time.h>

    int del_timer(struct timer_list * timer);
    int del_timer_sync(struct timer_list * timer);

    del_timer fonksiyonu eğer timer fonksiyonu o anda başka bir işlemcide çalışıyorsa asenkron biçimde silme yapar. Yani 
    fonksiyon sonlandığında henüz silme gerçekleşmemiş fakat göreli bir süre sonra gerçekleşecek olabilir. Halbuki del_timer_sync 
    fonksiyonu geri dönünce timer silinmesi gerçekleşmiş olur. Eğer timer silinmezse modül çekirdekten atıldığında tüm sistem 
    çökebilir.

    Normal olarak belirlenen fonksiyon yalnızca 1 kez çağrılmaktadır. Ancak bu fonksiyonun içerisinde yeniden mod_timer 
    çağrılarakçağırmayı periyodik hale getirilebilir.

    Aşağıda kernel timer kullanımına basit bir örnek verilmiştir. Bu örnekte her 5 saniyede bir belirlenen callback fonksiyon
    çağrılmıştır. Çekirdek modülünün init ve exit fonksiyonları şöyle yazılmıştır:

    static void timer_proc(struct timer_list *tlist);

    static struct timer_list g_mytimer;
    ...

    static int __init timer_init(void)
    {
        timer_setup(&g_mytimer, timer_proc, 0);
        add_timer(&g_mytimer);
        mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);

        printk(KERN_INFO "timer-module module init...\n");

        return 0;
    }

    static void __exit timer_exit(void)
    {
        del_timer(&g_mytimer);

        printk(KERN_INFO "timer-module module exit...\n");
    }

    Callback fonksiyon da şöyle yazılmıştır:

    static void timer_proc(struct timer_list *tlist)
    {
        printk(KERN_INFO "timer_proc called...\n");

        mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/* timer-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/timer.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("timer module");

static void timer_proc(struct timer_list *tlist);

static struct timer_list g_mytimer;

static int __init timer_init(void)
{
    timer_setup(&g_mytimer, timer_proc, 0);
    add_timer(&g_mytimer);
    mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);

    printk(KERN_INFO "timer-module module init...\n");

    return 0;
}

static void __exit timer_exit(void)
{
    del_timer(&g_mytimer);

    printk(KERN_INFO "timer-module module exit...\n");
}

static void timer_proc(struct timer_list *tlist)
{
    printk(KERN_INFO "timer_proc called...\n");

    mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);
}

module_init(timer_init);
module_exit(timer_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                156. Ders 19/07/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bizim şimdiye kadar yazmış olduğumuz çekirdek modüllerindeki ve aygıt sürücülerdeki kodlarımız aşağıdaki durumlarda çalışma
    fırsatı bulmaktadır:

    1) Modül yüklenirken ve çekirdek alanından atılırken
    2) Aygıt sürücü üzerinde aygıt dosyası yoluyla dosya işlemleri yapılırken
    3) Kullanıcı modundan ioctl işlemleri yoluyla
    4) proc ve sys dosya sistemlerindeki dosyalar yoluyla
    5) En son gördüğümüz timer mekanizması yoluyla

    Bunların yanı sıra henüz görmediğimiz aşağıdaki iki durumda da çekirdek modülümüzdeki ya da aygıt sürücümüzdeki kodlar 
    çalışma fırsatı bulabilmektedir:

    6) Çekirdek thread'leri (kernel therads) yoluyla
    7) Donanım kesmeleri yoluyla

    Biz bu bölümde "çekirdek thread'leri" üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Önceki konularda da Linux sistemlerinde çekirdek mode'da çalışan işletim sistemine ait thread'lerin olduğundan bahsetmiştik. 
    Bu thread'ler çalışma kuyruğunda (run queue) bulunan ve uykuya dalabilen işletim sisteminin bir parçası durumundaki 
    thread'lerdir. İşletim sistemine ait bu thread'ler çeşitli işlemlerden sorumludurlar. Linux işletim sisteminde çekirdek 
    thread'leri genellikle "kullanıcı modundaki daemon"larda olduğu gibi sonu 'd' ile bitecek biçimde isimlendirilmiştir. Ancak 
    çekirdeğe ait olan bu thread'lerin ismi 'k' (kernel'dan geliyor) ile başlatılmıştır. Örneğin "kupdated", "kswapd", "keventd" 
    gibi. Bu thread'ler yukarıda da belirttiğimiz gibi Linux işletim sisteminin bir parçası durumundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşte çekirdek modülleri ve aygıt sürücüler de isterlerse arka planda çekirdek modunda çalışacak thread'ler yaratabilirler. 
    Bu tür thread'lere İngilizce "kernel threads" denilmektedir. Biz kurusumuzda bunlara "çekirdek modunda çalışan thread'ler"
    ya da "çekirdek thread'leri" diyeceğiz. 
    
    Çekirdek modunda çalışan thread'ler herhangi bir proses ile ilişkisiz biçimde çalıştırılmaktadır. Bu nedenle bunlar içerisinde 
    copy_to_user ya da copy_from_user gibi fonksiyonlar kullanılamaz. Çekirdek modunda çalışan thread'ler de diğer kullanıcı 
    modunda çalışan thread'lerde olduğu gibi aynı "çalışma kuyruğu (run queue)" içerisinde zaman paylaşımlı biçimde çalıştırılmaktadır.
    
    Çekirdek thread'leri sırasıyla şu adımlarlardan geçilerek kullanılmaktadır:

    1) Önce çekirdek thread'i aygıt sürücü içerisinde yaratılır. Yaratılma modülün init fonksiyonunda yapılabileceği gibi aygıt 
    sürücü ilk kez açıldığında open fonksiyonunda ya da belli bir süre sonra belli bir olay gerçekleştiğinde de yapılabilmektedir. 
    Çekirdek thread'leri kthread_create fonksiyonuyla yaratılmaktadır:

    #include <linux/kthread.h>

    struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char *namefmt);

    Fonksiyonun birinci parametresi thread akışının başlatılacağı fonksiyonun adresini almaktadır. Bu fonksiyon void * türünden 
    parametreye ve int geri dönüş değerine sahip olmak zorundadır. Fonksiyonun ikinci parametresi thread akışı başlatıldığında 
    thread fonksiyonuna geçirilecek parametreyi belirtmektedir. Eğer bir thread fonksiyonuna bir parametre geçirilmek istenmiyorsa 
    bu parametre için NULL adres girilebilir. Fonksiyonun üçüncü parametresi proc dosya sisteminde (dolayısıyla "ps" komutunda) 
    görüntülenecek ismi belirtir. Fonksiyon başarı durumunda yaratılan thread'in task_struct adresine, başarısızlık durumunda 
    negatif errno değerine geri dönmektedir. Adrese geri dönen diğer çekirdek fonksiyonlarında olduğu gibi fonksiyonun başarılı
    olup olmadığı IS_ERR makrosuyla test edilmelidir. Eğer fonksiyon başarısız olmuşsa negatif errno değeri PTR_ERR makrosuyla 
    elde edilebilir. Örneğin:

    static struct task_struct *g_kthread;

    g_kthread = kthread_create(...);
      if (IS_ERR(g_kthread)) {
        printk(KERN_ERR "cannot create kernel thread!..\n");
        return PTR_ERR(g_kthread);
    }

    Anımsanacağı gibi Linux sistemlerinde prosesler ve thread'ler task_struct yapısıyla temsil ediliyordu. İşte bu fonksiyon 
    da başarı durumunda çekirdek tarafından yaratılan task_struct nesnesinin adresini bize vermektedir.

    Çekirdek thread'leri bu fonksiyonla yaratıldıktan sonra hemen çalışmaa başlamazlar. Onları çalıştırmak için wake_up_process 
    fonksiyonun çağrılması gerekir. Fonksiyonun prototipi şöyledir:

    #include <linux/kthread.h>

    int wake_up_process(struct task_struct *tsk);

    Fonksiyon ilgili çekirdek thread'in task_struct adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda negatif errno değerine geri döner. Tabii bir çekirdek thread'i başarılı bir biçimde yaratılmışsa ve bu fonksiyona 
    onun task_struct adresi geçilmişse thread'in çalışmaya başlatılmasında bir sorun oluşmaz. Böylesi bir hata durumu zaten 
    sistemdeki ciddi sorunlara işaret etmektedir. Bu nedenle wake_up_process fonksiyonunun geri dönüş değerini kontrol etmeyebilirsiniz. 
    Çekirdek thread'in yaratılır yaratılmaz çalıştırılamsı doğru tekniktir. Henüz çalıştırılmamış ancak task_struct yapısı 
    tahsis edilmiş olan çekirdek thread'lerinin task_struct yapısını geri bırakmak için put_task_struct fonksiyonu kullanılmalıdır. 

    Aslında yukarıdaki işlemi tek hamlede yapan kthread_run isimli bir fonksiyon da vardır:

    #include <linux/kthread.h>

    struct task_struct *kthread_run(int (*threadfn)(void *data), void *data, const char *namefmt);

    kthread_run mevcut çekirdeklerde bir makro biçiminde şöyle yazılmıştır:

    #define kthread_run(threadfn, data, namefmt, ...)			   \
    ({									   \
        struct task_struct *__k						   \
            = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
        if (!IS_ERR(__k))						   \
            wake_up_process(__k);					   \
        __k;								   \
    })

    Makroda gcc derleyicilerinin "ifadesel deyim (expression statement)" eklentisinin kullanıldığına dikkat ediniz.

    2) Çekirdek thread'i kthread_stop fonksiyonuyla herhangi bir zaman yok edilebilir. Eğer çekirdek thread modülün init 
    fonksiyonunda yaratılmışsa yok edilmesi de tipik olarak modülün exit fonksiyoununda yapılmaktadır. Fonksiyonun prototipi 
    şöyledir:
    
    #include <linux/kthread.h>

    int kthread_stop(struct task_struct *ts);

    Fonksiyon çekirdek thread'in task_struct nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısız
    durumunda negatif errno değerine geri döner. Fonksiyonun normal koşullarda başarısız olması söz konusu değildir. Yani 
    başarı kontrolü hiç yapılmayabilir. Örneğin:

    kthread_stop(g_kthread);
    
    Fonksiyon thread fonksiyonu sonlanana kadar blokeye yol açmaktadır. Fonksiyon başarı durumunda thread fonksiyonunun exit 
    koduyla (yani thread fonksiyonunun geri dönüş değeri ile) geri dönmektedir. Genellikle programcılar thread fonksiyonlarını 
    başarı durumunda sıfır, başarısızlık durumunda sıfır dışı bir değerle geri döndürmektedir. Burada önemli bir nokta kthread_stop 
    fonksiyonunun çekirdek modunda çalışan thread'i zorla sonlandırılmadığıdır. Çekirdek thread'in sonlandırılması zorla yapılmaz. 
    kthread_stop fonksiyonu çekirdek thread'ine ilişkin task_struct yapısı içerisindeki bir bayrağı set eder. Çekirdek thread'i 
    de tipik olarak bir döngü içerisinde "bu bayrak set edilmiş mi" diye bakar. Eğer bayrak set edilmişse kendini sonlandırır. 
    Çekirdek thread'in bu bayrağa bakması kthread_should_stop fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/kthread.h>

    bool kthread_should_stop(void);

    Fonksiyon eğer bu bayrak set edilmişse sıfır dışı bir değere, set edilmemişse 0 değerine geri dönmektedir. Tipik olarak 
    thread fonksiyonu aşağıdaki gibi bir döngüde yaşamını geçirmektedir:

    while (!kthread_should_stop()) {
        ...
    }

    Tabii aslında biz kthread_create fonksiyonu ile bir çekirdek thread yaratmak istediğimizde thread çekirdek içerisindeki 
    başka bir fonksiyondan başlatılır. Bizim kthread_create fonksiyonuna verdiğimiz fonksiyon da aslında bu fonksiyon 
    tarafından çağrılmaktadır. Dolayısıyla bizim thread fonksiyonumuz bittiğinde akış yine çekirdek içerisindeki fonksiyona 
    döner. O fonksiyonda da yaratılmış thread kaynakları otomatik boşaltılmaktadır. Yani biz bir thread'i yarattığımız zaman 
    onun yok edilmesi thread fonksiyonu bittiğinde otomatik yapılmaktadır. Ancak thread akışı bittiğinde thread'e ilişkin 
    task_struct yapısı otomatik yok edilmez. task_struct yapısının yok edilmesi kthread_stop fonksiyonu tarafından yapılmaktadır.

    Çekirdek thread'inde thread'in sonlandırılması fonksiyonun bitmesi beklenmeden do_exit fonksiyonuyla da sağlanabilmektedir. 
    Aslında do_exit fonksiyonu prosesleri sonlandıran sys_exit fonksiyonunun doğrudan çağırdığı taban bir fonksiyondur.

    #include <linux/kernel.h>

    void do_exit(long code);

    Fonksiyon thread'in exit kodunu parametre olarak almaktadır. Çekirdek thread do_exit fonksiyonuyla kendini sonlandırmışsa 
    task_struct yapısı tread'in exit kodunu iletmek için sistem tarafından tutulur. kthread_stop fonksiyonu da bu task_struct 
    yapısını serbest bırakmaktadır. Zaten bir çekirdek thread'inin thread fonksiyonu sonlandığında da bu fonksiyon çağrılmaktadır. 
    Fakat çekirdeğin belli bir versiyonundan sonra (muhtemelen 2.6'lı çekirdeklerde olmalı) bu do_exit fonksiyonu artık export 
    edilmemektedir. Dolayısıyla bu fonksiyonu yalnızca eski çekirdek versyionlarında kullanabilirsiniz.

    Aşağıdaki örnekte modül ün init fonksiyonunda edilirken çekirdek thread yaratılmış, modülün exit fonksiyonunda da kthread_stop 
    ile çekirdek thread'in sonlanması beklenmiştir. kernel-thread içerisinde msleep fonksiyonu ile 1 saniyelik beklemeler 
    yapılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/* kernel-thread-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/syscalls.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("kernel thread module");

int kernel_thread_proc(void *data);

static struct task_struct *g_kthread;

static int __init generic_init(void)
{
    g_kthread = kthread_create(kernel_thread_proc, NULL, "my-kernel-thread");
    if (IS_ERR(g_kthread)) {
        printk(KERN_ERR "cannot create kernel thread!..\n");
        return PTR_ERR(g_kthread);
    }
    wake_up_process(g_kthread);

    printk(KERN_INFO "kernel-thread-module init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    int ecode;
    
    ecode = kthread_stop(g_kthread);
    printk(KERN_INFO "kernel thread exited with %d code\n", ecode);;

    printk(KERN_INFO "kernel-thread-module module exit...\n");
}

int kernel_thread_proc(void *data)
{
    int count = 0;

    while (!kthread_should_stop()) {
        printk(KERN_INFO "kernel thread running: %d\n", count);
        ++count;
        msleep_interruptible(1000);            
    }

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                157. Ders 21/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemcinin çalıştırmakta olduğu koda ara vererek başka bir kodu çalıştırması ve çalıştırma bittikten sonra kaldığı yerden 
    devam etmesi sürecine "kesme (interrupt)" denilmektedir. Kesmeler oluşma biçimine göre üçe ayrılmaktadır:

    1) Donanım Kesmeleri (Hardware Interrupts)
    2) İçsel Kesmeler (Internal Interrupts)
    3) Yazılım Kesmeleri (Software Interrupts)

    Kesme denildiğinde akla (default olarak) donanım kesmeleri gelmektedir. Donanım kesmeleri pek çok CPU'da CPU'nun bir ucunun 
    (genellikle bu uca INT ucu denilmektedir) elektriksel olarak dışsal bir birim tarafından uyarılmasıyla oluşmaktadır. Yani 
    donanım kesmeleri o anda çalışmakta olan koddan bağımsız bir biçimde dış dünyadaki birimler tarafından oluşturulmaktadır. 
    PC terminolojisinde donanım kesmesi oluşturan kaynaklara IRQ (Interrupt Request) da denilmektedir. İçsel kesmeler CPU'nun 
    kendi çalışması sırasında kendisinin oluşturduğu kesmelerdir. Intel bu tür kesmelerin önemli bir bölümünü "fault" olarak 
    isimlendirmektedir. Örneğin fiziksel RAM'de olmayan bir sayfaya erişildiğinde CPU "page fault" denilen içsel bir kesme 
    oluşturmaktadır. Yazılım kesmeleri ise programcının program koduyla oluşturduğu kesmelerdir. Her türlü CPU'da yazılım kesmesi 
    oluşturulamamaktadır. Bir kesme oluştuğunda çalıştırılan koda "kesme kodu (interrupt handler)" denilmektedir.

    Geleneksel sistemlerde donanım kesmesi oluşturan elektronik birimlerin hepsi doğrudan CPU'nun INT ucuna bağlanmamaktadır. 
    Çünkü bunun pek çok sakıncası vardır. Genellikle bu amaçla bu işe aracılık eden denetleyiciler kullanılmaktadır. Bu 
    denetleyicilere genel olarak "kesme denetleyicileri (interrupt controllers)" denilmektedir. Bazı mimarilerde kesme 
    denetleyicisi işlemcinin içerisinde bulunur. Bazı mimarilerde ise dışarıda ayrı bir birim olarak bulunmaktadır. Tabii 
    artık pek çok entegre devre "SoC (System on Chip)" adı altında tek bir entegre devrenin içerisine yerleştirilmiş durumdadır. 
    Kesme denetleyicileri de bu SoC'ların içerisinde bulunabilmektedir. Kesme denetleyicilerinin temel işlevleri şöyledir:

    1) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunları sıraya dizebilmektedir.
    2) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunlara öncelikler verebilmektedir.
    3) Belli birimlerden gelen kesme isteklerini kesme denetleyicisi görmezden gelebilmektedir. Buna ilgili IRQ'nun disable 
    edilmesi de denilmektedir.
    4) Kesme denetleyicileri çok çekirdekli donanımlarda kesmenin belli bir çekirdekte çalıştırılabilmesine de olanak 
    sağlayabilmektedir.

    Modern CPU'larda her CPU'nun (ya da çekirdeğin) içerisinde ayrı bir kesme denetleyicisi de bulunmaktadır. Genellikle bu 
    yerel kesme denetleyicileri CPU'nun bir ucu ile değil bellek tabanlı IO işlemleriyle (Yani adeta belli bir bölgesine bir 
    şey yazılarak) tetiklenmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün kullandığımız PC'lerde (laptop ve notebook'lar da dahil olmak üzere) eskiden kesme denetleyicisi olarak bir tane 
    Intel'in 8259 (PIC) denilen entegre devresi kullanılıyordu. Bunun 8 girişi bulunuyordu. Yani bu kesme denetleyicisinin 
    uçları 8 ayrı donanım birimine bağlanabiliyordu.
          
          | (INT ucu CPU'ya bağlanır) 
      <8259 (PIC)>
    | | | | | | | |
    0 1 2 3 4 5 6 7

    Bu uçlara IRQ uçları deniliyordu ve bu uçlar değişik donanım birimlerine bağlıydı. Böylece bir donanım birimi kesme oluşturmak
    isterse kesme denetleyicisinin ilgili ucunu uyarıyordu. Kesme denetleyicisi de CPU'nun INT ucunu uyarıyordu. İlk PC'lerde 
    toplam 8 IRQ vardı. Ancak 80'li yılların ortalarında PC mimarisinde değişiklikler yapılarak kesme denetleyicisinin sayısı 
    ikiye yükseltildi. Böylece IRQ uçlarının sayısı da 15'e yükseltilmiş oldu. (Intel'in iki 8259 işlemcisini kaskat bağlayabilmek 
    için birinci kesme denetleyicisinin (Master PIC) bir ucunun ikinci kesme denetleyicisinin INT ucuna bağlanması gerekmektedir.
    İşte PC mimarisinde birinci kesme denetleyicisinin 2 numaralı ucu ikinci kesme denetleyicisine bağlanmıştır. Böylece toplam
    IRQ'ların sayısı 16 değil, 15 olmaktadır.)

    | (INT ucu CPU'ya bağlanır)     |
      <8259 (PIC)>                     <8259 (PIC)>
    | | X | | | | |                 | | | | | | | |

    0 1 2 3 4 5 6 7                 8 9 10 11 12 13 14 15

    Ancak zamanla 15 IRQ ucu da yetersiz kalmaya başlamıştır. Yukarıda da belirttiğimiz gibi çok çekirdekli sistemlerde her 
    çekirdeğin (yani CPU'nun) ayrı bir INT ucu vardır. Yani bu çekirdekler diğerlerinden bağımsız kesme alabilmektedir. İşte 
    zamanla Intel'in klasik 8259 kesme denetleyicisi daha gelişmiş olan ve ismine IOAPIC denilen kesme denetleyicisi ile 
    değiştirilmiştir. Bugün kullandığımız Intel tabanlı bilgisayar mimarisinde artık IOAPIC kesme denetleyicileri bulunmaktadır. 
    Bu yeni kesme denetleyicisinin 24 IRQ ucu vardır. IOAPIC birden fazla çekirdeğin bulunduğu durumda tek bir çekirdeğe değil, 
    tüm çekirdeklere bağlanmaktadır. Dolayısıyla istenilen bir çekirdekte kesme de oluşturabilmektedir. IOAPIC devresinin 
    bazı uçları bazı donanım birimlerine bağlı biçimdedir. Ancak bazı uçları boştadır. Bugün kullanılan ve ismine PCI ya da 
    PCI-X denilen genişleme yuvalarının bazı uçları bu IOAPIC ile bağlantılıdır. Dolayısıyla genişleme yuvalarına takılan 
    kartlar da IRQ oluşturabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün Pentium ve eşdeğer AMD işlemcilerinin içerisinde (her çekirdeğin içerisinde) aynı zamanda ismine "Local APIC" denilen 
    bir kesme denetleyicisi de vardır. Bu local APIC iki uca sahiptir. Local APIC içerisinde aynı zamanda bir timer devresi de 
    bulunmaktadır. Bu timer devresi periyodik donanım kesmesi oluşturmak için kullanılmaktadır. Intel ve AMD çekirdeklerinin 
    içerisinde bulunan APIC devresinin en önemli özelliği kesmeleri artık uçlarla değil, veri yoluyla (data bus) oluşturabilmesidir.
    Bu özellik sayesinde hiç işlemcinin INT ucu uyarılmadan çok fazla sayıda kesme sanki belleğe bir değer yazıyormuş gibi 
    oluşturulabilmektedir. Bu tekniğe "Message Signaled Interrupt (MSI)" denilmektedir. Gerçekten de bugün PCI slotlara takılan 
    bazı kartlar kesmeleri doğrudan belli bir çekirdekte MSI kullanarak oluşturmaktadır.

    O halde kullandığımız Intel tabanlı PC mimarisindeki bugünkü durum şöyledir:

    - Bazı donanım birimleri built-in biçimde IOAPIC'in uçlarına bağlı durumdadır. Bu uçlar geçmişe doğru uyumu korumak için
    eski 8259 kesme denetleyicisindeki uçlar kullanılarak donanım birimleriyle bağlanmıştır.

    - Bazı PCI kartlar slot üzerindeki 4 IRQ hattından (INTA, INTB, INTC, INTD) birini kullanarak kesme oluşturmaktadır. Bu 
    hatlar IOAPIC'in bazı uçlarına bağlıdır.

    - Bazı PCI kartlar ise doğrudan modern MSI sistemini kullanarak (yani IOAPIC'i pass geçerek) bellek işlemleriyle doğrudan 
    ilgili çekirdekte kesme oluşturabilmektedir.

    Bir aygıt sürücü programcısı mademki birtakım kartlar için onu işler hale getiren temel yazılımları da yazma iddiasındadır. 
    O halde o kartın kullandığı kesmeler için de kesme kodlarını (interrupt handlers) yazabilmelidir. Tabii işletim sisteminin 
    aygıt sürücü  mimarisinde bu işlemler de özel çekirdek fonksiyonlarıyla yapılmaktadır. Yani kesme kodu yazmanın belli bir 
    kuralı vardır.

    Peki bugünlerde kullandığımız Intel tabanlı çok çekirdekli masaüstü sistemlerinde IOAPIC yoluyla oluşturulan kesme hangi 
    çekirdek tarafından ele alınmaktadır? İşte bugünlerde kullanılan IOAPIC devreleri bu bakımdan şu özelliklere sahiptir:

    1) Kesme IOAPIC tarafından donanım biriminin istediği bir çekirdekte oluşturulabilmektedir.
    2) Kesme IOAPIC tarafından en az yüklü çekirdeğe karar verilerek orada oluşturulabilmektedir.
    3) Kesme IOAPIC tarafından döngüsel bir biçimde (yani sırasıyla her bir çekirdekte) oluşturulabilmektedir.

    IOAPIC'in en az yüklü işlemciyi bilmesi mümkün değildir. Onu ancak işletim sistemi bilebilir. İşte işlemcilerin local 
    APIC'leri içerisinde özel bazı yazmaçlar vardır. Aslında IOAPIC bu yazmaçtaki değerlere bakıp en düşüğünü seçmektedir. 
    Bu değerleri de işletim sistemi set etmektedir. İşletim sisteminin yaptığı bu faaliyete "kesme dengeleme (IRQ balancing)" 
    denilmektedir. Linux sistemlerinde bir süredir kesme dengelemesi işletim sisteminin çekirdek thread'i (irqbalance) tarafından 
    yapılmaktadır. Böylece Linux sistemlerinde aslında donanım kesmeleri her defasında farklı çekirdeklerde çalıştırılıyor 
    olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ARM işlemcilerinde de genel çalışma biçimi beznerdir. Yine bazı SBC'lerde kullanılan SoC'lar içerisinde IOAPIC benzeri 
    bir kesme denetleyicisi bulunmaktadır. Bu SoC'ların bazı uçları donanım kesmelerini tetiklemek için kullanılmaktadır. 
    Ancak ARM işlemcileri tıpkı Intel işlemcilerinde eolduğu gibi bellek tabanlı kesme oluşturma yeteneğine de sahiptir. 
    Bu sistemlerde de işletim sistemi tarafından aracılık edilen bir "kesme dengelemesi (IRQ load balancing)" uygulanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Pek çok CPU ailesinde toplam oluşturulabilecek donanım kesmelerinin maksimum bir sayısı vardır. Örneğin Intel mimarisinde 
    toplam kesme sayısı 256'yı geçememektedir. Yani bu mimaride en fazla 256 farklı kesme oluşturulabilmektedir. Bu mimaride 
    her kesmenin bir numarası vardır. (PC mimarisindeki IRQ numarası ile kesme numarasının bir ilgisi yoktur. IRQ numarası 
    kesmenin kesme denetleyicisinin hangi ucu uyarılarak oluşturulduğunu belirtmektedir. Biz örneğin PIC ya da IOAPIC'i 
    programlayarak belli bir IRQ için belli numaralı bir kesmenin oluşmasını sağlayabiliriz. Örneğin timer (IRQ-0) için 8 
    numaralı kesmenin çalışmasını sağlayabiliriz. Peki bir IRQ oluşturulduğunda CPU ya da çekirdek kaç numaralı kesme kodunun 
    çalıştırılacağını nereden anlamaktadır? İşte PC mimarisinde PIC ya da IOAPIC CPU'nun INT ucunu uyararak kesme oluştururken 
    veri yolunun ilk 8 ucundan kesme numarasını da CPU'ya bildirmektedir. Local APIC sisteminde ise zaten oluşturulacak kesmenin 
    numarası özel bir bellek adresine yazılarak belirtilir.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanılan CPU mimarisi ne olursa olsun Linux sistemlerinde donanım kesmeleri hakkında bilgi "/proc/interupts" dosyası 
    yoluyla elde edilebilmektedir. Bu dosyanın içeriği Linux çekirdeği tarafından sürekli güncellenmektedir. Dosyanın görünümü
    şöyledir:

              CPU0       CPU1       CPU2       CPU3       
    0:         35          0          0          0   IO-APIC    2-edge      timer
    1:       1961      11907      18985      29237   IO-APIC    1-edge      i8042
    8:          1          0          0          0   IO-APIC    8-edge      rtc0
    9:          0          0          0          0   IO-APIC    9-fasteoi   acpi
    12:     178947     224775     288118     227366   IO-APIC   12-edge      i8042
    14:          0          0          0          0   IO-APIC   14-edge      ata_piix
    15:          0          0          0          0   IO-APIC   15-edge      ata_piix
    16:          0     633539          0          0   IO-APIC   16-fasteoi   vmwgfx, snd_ens1371
    17:     616310          0          0          0   IO-APIC   17-fasteoi   ehci_hcd:usb1, ioc0
    18:      13489     180886     461460     275687   IO-APIC   18-fasteoi   uhci_hcd:usb2
    19:          0          0        153     532269   IO-APIC   19-fasteoi   ens33, ens37
    24:          0          0          0          0  PCI-MSI-0000:00:15.0    0-edge      PCIe PME, pciehp
    25:          0          0          0          0  PCI-MSI-0000:00:15.1    0-edge      PCIe PME, pciehp
    26:          0          0          0          0  PCI-MSI-0000:00:15.2    0-edge      PCIe PME, pciehp
    27:          0          0          0          0  PCI-MSI-0000:00:15.3    0-edge      PCIe PME, pciehp
    28:          0          0          0          0  PCI-MSI-0000:00:15.4    0-edge      PCIe PME, pciehp
    29:          0          0          0          0  PCI-MSI-0000:00:15.5    0-edge      PCIe PME, pciehp
    30:          0          0          0          0  PCI-MSI-0000:00:15.6    0-edge      PCIe PME, pciehp
    31:          0          0          0          0  PCI-MSI-0000:00:15.7    0-edge      PCIe PME, pciehp
    32:          0          0          0          0  PCI-MSI-0000:00:16.0    0-edge      PCIe PME, pciehp
    33:          0          0          0          0  PCI-MSI-0000:00:16.1    0-edge      PCIe PME, pciehp
    34:          0          0          0          0  PCI-MSI-0000:00:16.2    0-edge      PCIe PME, pciehp
    35:          0          0          0          0  PCI-MSI-0000:00:16.3    0-edge      PCIe PME, pciehp
    36:          0          0          0          0  PCI-MSI-0000:00:16.4    0-edge      PCIe PME, pciehp
    37:          0          0          0          0  PCI-MSI-0000:00:16.5    0-edge      PCIe PME, pciehp
    38:          0          0          0          0  PCI-MSI-0000:00:16.6    0-edge      PCIe PME, pciehp
    .......

    Buradan IPAPIC yoluyla oluşturulan timer kesmesinin hep ilk çekirdek tarafından işlendiği görülmektedir. Çıktıdak, "PCI-MSI" 
    memory-mapped kesme oluşturma mekanizmasını belirtmektedir. Bazı donanım kesmelerinin IRQ dengelemesi yapılarak farklı
    çekirdeklerde çalıştırıldığına dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
                                                158. Ders 28/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücüler içerisinde kesmelerin nasıl ele alınacağı üzerinde duralım. Bir donanım kesmesi oluştuğunda 
    aslında işletim sisteminin kesme kodu (interrupt handler) devreye girmektedir. Ancak işletim sisteminin kesme kodu istek 
    doğrultusunda aygıt sürücülerin içerisindeki fonksiyonları çağırabilmektedir. Farklı aygıt sürücüler aynı IRQ için istekte
    bulunabilir. Bu durumda işletim sistemi IRQ oluştuğunda farklı aygıt sürücülerdeki fonksiyonları belli bir düzen içerisinde
    çağırmaktadır.

    Aygıt sürücü programcısı bir kesme oluştuğunda aygıt sürücüsünün içerisindeki bir fonksiyonunun çağrılmasını istiyorsa 
    önce onu request_irq isimli çekirdek fonksiyonuyla register ettirmelidir. request_irq fonksiyonunun prototipi şöyledir:

    #include <linux/interrupt.h>

    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev_id);

    Fonksiyonun birinci parametresi IRQ numarasını belirtmektedir. Yukarıda da belirttiğimiz gibi her donanım kesmesinin bir 
    IRQ numarası vardır. Bu numara aygıt sürücüsünü yazanlar tarafından bilinmelidir. ikinci parametresi IRQ oluştuğunda 
    çağrılacak fonksiyonu belirtmektedir. Bu fonksiyonun geri dönüş değeri irqreturn_t türünden parametreleri de sırasıyla 
    int ve void * türündendir. Örneğin:

    irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...
    }

    Buradaki irqreturn_t türü bir enum türü olarak typedef edilmiştir. Bu enum türünün elemanları şunlardır:

    enum irqreturn {
        IRQ_NONE           = (0 << 0),      /* 0 */
        IRQ_HANDLED        = (1 << 0),      /* 1 */
        IRQ_WAKE_THREAD    = (1 << 1),      /* 2 */
    };

    typedef enum irqreturn irqreturn_t;

    request_irq fonksiyonunun üçüncü parametresi bazı bayraklardan oluşmaktadır. Bu bayrak 0 geçilebilir ya da örneğin 
    IRQF_SHARED geçilebilir. Diğer seçenekler için dokümanlara başvurabilirsiniz. IRQF_SHARED aynı kesmenin birden fazla 
    aygıt sürücü tarafından kullanılabileceği anlamına gelmektedir. (Tabii biz IRQ'yu ilk register ettiren değilsek daha 
    önce register ettirenlerin bu bayrağı kullanmış olması gerekir. Aksi halde biz de bu bayrağı kullanamayız.) IRQ'yu 
    ilk kez biz register ettiriyorsak ve bu bayrağı kullanmazsak IRQ başka aygıt sürücüler tarafından kullanılamaz. 
    Fonksiyonun dördüncü parametresi "/proc/interrupts" dosyasında görüntülenecek ismi, son parametre ise programcının 
    kesme oluştupunda çağrılacak kesme koduna geçirilmesini istediği nesnenin adresini belirtmektedir. Aygıt sürücü 
    programcıları bu parametreye tipik olarak aygıt yapısını girerler. Bu parametre IRQ oluştuğunda çağrılacak olan 
    fonksiyona ikinci parametre olarak geçilmektedir. Bu parametre NULL adres biçiminde geçilememektedir. Fonksiyon 
    başarı durumunda 0 değerine, başarısızlık durumunda negatif hata değerine geri dönmektedir. Örneğin:

    if ((result = request_irq(1, my_irq_handler, IRQF_SHARED, "my_irq", NULL)) != 0) {
        ...
        return result;
    }

    Bir kesme kodu request_irq fonksiyonuyla register ettirilmişse bunun geri alınması free_irq fonksiyonuyla yapılmaktadır:

    #include <linux/interrupt.h>

    const void *free_irq(unsigned int irq, void *dev_id);

    Fonksiyonun birinci parametresi silinecek irq numarasını, ikinci parametresi irq_reuest fonksiyonuna girilen son parametreyi 
    belirtir.  Bu parametrenin neden bu fonksiyona geçirildiğinin bazı ayrıntıları vardır. Fonksiyon başarı durumunda irq_request 
    fonksiyonunda verilen isme, başarısızlık durumunda NULL adrese geri dönmektedir. Geri dönüş değeri bir hata kodu içermemektedir. 
    Örneğin:

    if (free_irq(1, NULL) == NULL)
        printk(KERN_INFO "cannot free IRQ\n");

    Aslında her şey uygun yapılmışsa free_irq fonksiyonun da başarısız olması beklenmez. Bu nedenle eğer her şeyi düzgün 
    aptığınızı düşünüyorsanız bu fonksiyonun geri dönüş değerini kontrol etmeyebilirsiniz. 

    Peki IRQ fonksiyonundan (IRQ handler) hangi değerle geri dönülmelidir? Aslında programcı bu fonksiyondan ya IRQ_NONE 
    değeri ile ya da IRQ_HANDLED değeri ile geri döner. Eğer programcı kesme kodu içerisinde yapmak istediği şeyi yapmışsa
    fonksiyondan IRQ_HANDLED değeri ile yapamamışsa ya da yapmak istememişse fonksiyondan IRQ_NONE değeri ile geri döner. 
    Bazen programcı bir kesmeyi ele almak ister ancak bu kesme programcının ilgilendiği durumun dışında başka nedenlerle de 
    tetikleniyor olabilir. İşte programcı eğer gerçekten kesmeyi ele alıp işlemişse kesme kpdundan IRQ_HANDLED değeri ile 
    işlememişse IRQ_NONE değeri ile geri dönmelidir. Örneğin:

    static irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...

        return IRQ_HANDLED;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen sistem programcısı belli bir IRQ'yu belli süre için disable etmek isteyebilir. Bunun için disable_irq ve enable_irq 
    isimli iki çekirdek fonksiyonu kullanılmaktadır. Bu fonksiyonlar mevcut çekirdeklere kesme denetleyicisi yoluyla (örneğin 
    PC mimariisndeki IOAPIC) disable işlemi yapmaktadır. Bu disable işlemi yapıldığında dışsal birim kesme denetleyicisini 
    kesme için uyarsa bile kesme denetleyicisi bu isteği dikkate almamaktadır. Fonksiyonların prototipleri şöyledir:

    #include <linux/interrupt.h>

    void disable_irq(unsigned int irq);
    void enable_irq(unsigned int irq);

    Fonksiyonlar IRQ numarasını parametre olarak alır. 

    Bazen aygıt sürücü içerisinde kritik birtakım işlemler yapılıyor olabilir. Bu işlemler yapılırken bir kesmenin araya girmesi 
    istenmeyebilir. Çünkü böyle bir durumda oluşcak gecikme olumsuz sonuçlar doğurabilir. İşte bu tür durumlarda yalnızca belli 
    bir IRQ'nun değil tüm IRQ'ların disable edilmesi gerekebilmektedir. Bu tür işlemler kesme denetleyicisi yoluyla değil CPU'nun 
    "kesme bayrağının (interrupt flag)" disable edilmesiyle yapılmaktadır. İşlemcilerde CPU'yu kesmelere kapatan ve açan özel 
    makine komutları vardır. (Örneğin Intel işlemcilerinde CLI (Clear Interrupt Flag) makine komutu CPU'yu kesmelere kapatmakta 
    STI (Set Interrupt Flag)" makine komutu ise CPU'yu kesmelere açmaktadır.) CPU kesmelere kapatılmışsa kesme denetleyicisi 
    CPU'yu uyarsa bile (ya da bellek tabanlı kesmeler programlama yoluyla bu işlemi yapsa bile) CPU kesme istedğini dikkate 
    almamaktadır. Yani CPU'nun içerisinde bu bakımdan "ana bir şalter" görevini yapan bir mekanizma vardır. Modern işlemciler 
    birden fazla çekirdek (core) içerebilmektedir. Burada sözünü ettiğimiz kesme bayrağı o çekirdeğe ilişkin kesme bayrağıdır. 
    Yani biz bir çekirdeği kesmelere kapatırsak diğer çekirdekler kesme almaya devam ederler. Ancak bu işlemi biz kesme 
    denetleyicisi yoluyla yaparsak ilgili IRQ için kesme denetleyicisi kesme oluşturmayacaktır. Tabii ilgili çekirdek kesmelere 
    kapatıldığında artık "thread'ler arası geçiş (context switch)" de yapılmayacaktır. Dolayıısyla aygıt sürücünüzde ilgili 
    çekirdeği kesmelere kapatırsanız onu açmayı unutmamalısınız. Atomik işlemler bu sayede yapılabilmektedir. İşte program kodunun 
    yürütüldüğü çekirdeği kesmelere kapatmak için local_irq_disable, açmak için de local_irq_enable fonksiyonları kullanılmaktadır:

    #include <linux/irqflags.h>

    void local_irq_disable(void);
    void local_irq_enabled(void);

    Bu fonksiyonlar hangi CPU mimarisinde çalışılıyorsa o mimariye özgü makine komutlarını kullanmaktadır. Ayrıca bu fonksiyonların 
    aşağıdaki bayraklı biçimleri de vardır:

    #include <linux/irqflags.h>

    void local_irq_save(flags);
    void local_irq_restore(flags);

    Aslında bunlar birer makro olarak yazılmıştır. local_irq_save ilgili çekirdeği kesmelere kapatmakla birlikte bu işlemden 
    önce tüm CPU bayraklarını da bize vermektedir. Biz de bayrakları aynı konumla local_irq_restore fonksiyonu ile geri 
    yükleyebiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilgisayar sistemlerinde dışsal bir olayın gerçekleşip gerçekleşmediğini anlamının iki temel yöntemi vardır:

    1) Yoklama (polling) yöntemi 
    2) Kesme (interrupt) yöntemi 

    Yoklama tekniğinde bir döngü içerisinde dışsal aygıta başvurularak "olay gerçekleşti mi" diye sorulur. Eğer olay gerçekleştiyse
    işlem yapılır. Ancak bu yöntem meşgul bir döngü (busy loop) oluşturmaktadır. Dolayısıyla önemli bir CPU zamanının harcanmasına 
    yol açabilmektedir. (Tabii bu tür yoklamalarda kritik bir durum söz konusu değilse döngü içerisine beklemeler yerleştirilebilir. 
    Bu önlem CPU kullanım oranını düşürecektir.)

    Kesme tekniğinde programcı sürekli yoklama yapmaz. Kodun akışı devam eder. Olay gerçekleştiğinde bir donanım kesmesi oluşturulur.
    Programcı da kesmeyi ele alır ve gerekli işlemi yapar. Tabii kesme yöntemi bir aygıt sürücüsü yoluyla kullanılmaktadır. 
    
    Örneğin gömülü aygıtımıza bir ısı sensörü yerleştirmiş olalım. Isı belli bir kritik düzeye geldiğinde birtakım işlemlerin 
    yapılması gerekiyor olsun. İşte yoklama yönteminde bir döngü içerisinde (muhtemelen bunun için bir thread kullanılacaktır)
    sürekli olarak ısı sensörüne bakmak gerekir. Ancak kesme tekniğinde donanım tasarımcısı zaten ısı kritik düzeye geldiğinde 
    kesme oluşturacak biçimde donanımı tasarlamıştır. Sistem programcısı da olay gerçekleştiğinde kesmeyi ele alarak gereken 
    işlemleri yapar. Yoklama yöntemini aygıt sürücü içerisinde kullanacaksanız "çekirdek thread'lerinden faydalanmalısınız.
    Klavye ve fare gibi dışsal birimler kesme yönetiminin kullanıldığı tipik birimelerdir. Biz kalvyeden bir tuşa bastığımızda 
    ve elimizi tuştan çektiğimizde donanım kesmesi oluşturulur. İşletim sisteminin kesme kodu basılan ve çekilen tuşun 
    bilgilerini alarak kullanır. Aynı durum fare için de söz konusudur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Donanımsal kesme mekanizmasının tipik örneklerinden biri klavye kullanımıdır. PC klavyesinde bir tuşa basıldığında klavye 
    içerisindeki işlemci (keyboard encoder - Eskiden Intel 8048 ya da Holtek HT82K629B kullanılıyordu) basılan ya da çekilen 
    tuşun klavyedeki sıra numarasını (buna "scan code" denilmektedir) dış dünyaya DATA ve CLOCK uçlarıyla seri bir biçimde 
    kodlamaktadır. Bu bilgi PS2 soketli klavyelerde bilgisayarın içerisindeki klavye denetleyicisine (Intel 8042) gelir. Klavye 
    denetleyicisi (keyboard controller) bu scan kodu kendi içerisinde bir yazmaçta saklar. Kesme denetleyicisinin (PIC ya da 
    IOAPIC'in) 1 numaralı ucu klavye denetleyicisine bağlıdır ve kesme denetleyicisi bu uçtan IRQ1 kesmesini oluşturulmaktadır. 
    Dolayısıyla biz bir tuşa bastığımızda ve oarmağımızı tuştan çektiğimizde otomatik olarak basılan tuşa ilişkin klavye scan 
    kodu bilgisayar tarafına iletilir ve IRQ1 kesmesi oluşturulur. IRQ1 kesme kodu birincil olarak işletim sistemi tarafından 
    ele alınmaktadır. İşletim sistemi de bu IRQ oluştuğunda aygıt sürücülerin belirlediği fonksiyonları çağırmaktadır. Yukarıda 
    da belirttiğimiz gibi klavyede yalnızca bir tuşa basılınca değil, parmak tuştan çekildiğinde de yine klavye işlemcisi 
    (keyboard encoder) çekilen tuşun scan kodunu klavye denetleyicisine gönderip IRQ1 kesmesinin oluşmasına yol açmaktadır. 
    Yani hem tuşa basıldığında hem de parmak tuştan çekildiğinde IRQ1 oluşmaktadır. Klavye terminolojisinde parmağın tuşa 
    basılmasıyla gönderilen scan koda "make code", parmağın tuştan çekilmesiyle gönderilen scan koduna koda ise "break code" 
    denilmektedir. Bugün PC'lerde kullandığımız klavyelerde parmak tuştan çekildiğinde önce PC tarafında bir F0 byte'ı ve sonra 
    da tuşun scan kodu gönderilmektedir. Örneğin parmağımızı "A" tuşuna basıp çekelim. Şu scan kodlar bilgisayar tarafına 
    gönderilecektir:

    <A'nın scan kodu> <F0> <A'nın scan kodu>

    Scan kod aslında tuşun klavyenin kaç numaralı tuşu olduğunu belirten bir sayıdır. Klavyennin üzerindeki harflerin üretilen 
    scan code ile hiçbir ilgisi yoktur. Mrneğin Türkçe Q klavye ile F kalvye ve İngilizce klavye aynı tuşlar için aynı kodları 
    göndermektedir. 

    Ctrl, Shift, Alt, Caps-Lock gibi tuşların da diğer tuşlardan bir farkı yoktur. Örneğin biz önce Ctrl tuşuna sonra A tuşuna 
    basmış olalım ve sonra parmağımızı önce A tulundan sonra da Ctrl tuşundan çekmiş olalım. Klavye işlemcisi bilgisayar tarafına 
    şu kodları gönderecektir:

    <Ctrl'nin scan kodu> <A'nın scan kodu> <F0> <A'nın scan kodu> <F0> <Ctrl'nin scan kodu>

    İşte Ctrl tuşuna basıldığını fark eden işletim sistemi bir bayrağı (flag) set eder, parmak bu tuştan bırakıldığında da bu 
    bayrağı reset eder. Böylece diğer tuşlara basıldığında bu bayrağa bakılarak Ctrl tuşu ile bu tuşa birlikte basılıp basılmadığı 
    anlaşılmaktadır.

    Klavye içerisindeki işlemcinin "typematic" denilen bir özelliği vardır. Klavyeden bir tuşa basılıp parmak tuşta bekletilirse 
    belli bir periyotta o tuş için sürekli scan code gönderilmektedir. Örneğin biz parmağımızla 'A' tuluna basalım. Biraz bekleyip 
    parmağımızı çekelim klavye içerisindeki klavye işlemcisi dış dünyaya şöyle kodlar göncerecektir:

    <A'nın scan kodu> <A'nın scan kodu> <A'nın scan kodu> ... <A'nın scan kodu> F0 <A'nın scan kodu>

    Typematic yapılırken ilk basmadan typematic'e kadar olan bekleme süresi ve typematic periyodu klavye içerisindeki işlemci 
    programlanarak ayarlanabilmektedir. Örnğin PS2 klavyelerde biz Windows'tan bu ayarı değiştrdiğimizde Windows o anda 
    klavye içerisindeki işlemciyi programlar, aynı zamanda bu ayarı da saklar. Bilgisayar yeniden açıldığında klavye içerisindeki 
    işlemciyi bu ayarla yeniden programlar. Tabii PS2 kalvyeyi çıkartıp yeniden taktığımızda PS2 sistemi "plug and play" olmadığı
    için ayar default duruma gelecektir. (Ancak USB klavyeleri çıkartıp taktığımızda işletim sistemi bunu anlayıp klavye takıldığında
    klavye içerisindeki işlemciyi yeniden programlamaktadır.)

    Peki biz Linux'ta stdin dosyasından (0 numaralı betimleyici) okuma yaptığımızda neler olmaktadır? İşte aslında işletim 
    sistemi bir tuşa basıldığında basılan tuşları klavye denetleyicisinden alır ve onları bir kuyruk sisteminde saklar. Terminal 
    aygıt sürücüsü de bu kuyruk sistemine başvurur. Kuyrukta hiç tuş yoksa thread'i bu amaçla oluşturulmuş bir wait kuyruğunda 
    bekletir. Klavyeden bir tuşa basılınca da wait kuyruğunda bekleyen thread'leri uyandırır. Yani okuma yapıldığında o anda 
    klavyeden okuma yapılmamaktadır, kuyruklanmış olan tuşlar okunmaktadır.

    Yukarıda da belirttiğimiz gibi klavyedeki tuşların üzerinde yazan harflerin hiçbir önemi yoktur. Yani İngilizce klavye 
    ile Türkçe klavye aynı tuşlar için aynı scan kodlarını göndermektedir. Basılan tuşun hangi tuş olduğu aslında dil ayarlarına 
    bakılarak işletim sistemi tarafından anlamlandırılmaktadır.

    Klavye ile bilgisayar arasındaki iletişim tek yönlü değil çift yönlüdür. Yani klavye denetleyicisi de (PC tarafındaki 
    denetleyici) isterse klavye içerisindeki işlemciye komutlar gönderebilmektedir. Aslında klavye üzerindeki ışıkların 
    yakılması da klavyenin içerisinde tuşa basılınca yapılmamaktadır. Işıklı tuşlara basıldığında gönderilen scan kod klavye 
    denetleyicisi tarafından alınır eğer bu tuş ışıklı tuşlardan biri ise işletim sistemi klavye denetleyicisine "ışık yakma 
    emri" verir. Klavye denetleyicisi de klavye içerisindeki klavye işlemcisine "falanca tuşun ışığı yak" komutunu göndermektedir. 
    Özetle yeniden ifade edersek klavyedeki ışıklar klavye devresi tarafından ilgili tuşlara basılınca yakılmamaktadır. Karşı 
    taraftan emir geldiğinde yakılmaktadır. Tasarımın bu biçimde yapılmış olması çok daha esnek bir kullanım oluşturmaktadır.

    Burada önemli bir noktayı vurgulamak istiyoruz. Bugün artık bilgisayarlarda eski PS2 soketleri bulunmamaktadır. Klavyeler 
    de USB portundan bilgisayara bağlanmaktadır. USB portlarının işleyişi ve USB aygıt sürücüleri farklı bir konudur. Biz 
    yukarıda PC mimarisindeki klasik PS2 soketli klavyelerdeki durumu açıkladık. Neyse ki sanal makineler default durumda 
    ana bilgisayarda (host) USB klavye kullanılıyor olsa bile sanki PS2 klavye kullanılıyormuş gibi bir etki oluşturmaktadır. 
    Bu nedenle siz aşağıda vereceğimiz örneği USB klavye kullanılan ana makinede kullanamazsınız.

    Aşağıdaki örnekte klavyeden tuşa basıldığında ve çekildiğinde oluşan 1 numaralı IRQ ele alınıp işlenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static int g_count;
    
static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1,  &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "irq-driver exit...\n");
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    ++g_count;
    printk(KERN_INFO "IRQ1 ocurred: %d\n", g_count);

    return IRQ_HANDLED;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                                159. Ders 02/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    CPU ile RAM arasında veri transferi aslında tamamen elektriksel düzeyde 1'lerle 0'larla gerçekleşmektedir. CPU'nun adres 
    uçları (address bus) RAM'in adres uçlarına bağlanır. Bu adres uçları RAM'den transfer edilecek bilginin fiziksel adresini 
    belirtmek için kullanılmaktadır. CPU'nun veri uçları (data bus) ise bilginin alınıp gönderilmesinde kullanılmaktadır. 
    İşlemin okuma mı yazma mı olduğu genellikle R/W biçiminde isimlendirilen ayrı bir kontrol ucuyla belirlenmektedir. Ayrıca 
    CPU ile RAM arasındaki iletişimde başka kontol uçları da kullanılmaktadır. CPU ile RAM arasındaki bağlantıyı aşağıdaik 
    şekille özetleyebiliriz:
    
        CPU
      ┌──────┐
      │      │
      │      │
      │      │
      └─┬─┬──┘
        │ │
        │ └────────────► Kontrol Yolu
        │
        ├──────────────► Adres Yolu
        │
        └──────────────► Veri Yolu
                      │
                   Memory Controller
                      │
               ┌─────────────┐
               │             │
               ▼             ▼
            RAM Slot 1    RAM Slot 2

    
    Örneğin 32 bit Intel işlemcilerinde MOV EAX, [XXXXXXXX] komutu RAM'deki XXXXXXXX adresinden başlayan 4 byte bilginin CPU 
    içerisindeki EAX yazmacına çekileceği anlamına gelmektedir. Bu makine komutu işletilirken CPU önce erişilecek adres olan 
    XXXXXXXX adresini adres uçlarına elektriksel olarak kodlar. RAM bu adresi alır, bu adresten başlayan 4 byte'lık bilgiyi 
    veri uçlarına elektriksel olarak bırakır. CPU'da bu uçlardan bilgiyi yine elektriksel olarak alır ve EAX yazmacına yerleştirir. 
    CPU'nun adres uçları RAM'in adres uçlarına, CPU'nun veri uçları ise RAM'in veri uçlarına bağlıdır. Transfer 
    yönü R/W ucuyla belirlenmektedir.  
    
    Eskiden RAM'ler CPU'lardan daha hızlıydı. 80'li yılların ortalarına doğru CPU hızları RAM'leri yakaladı ve onları geçti. 
    Bugün kullanılan CPU'lar RAM'lerden çok daha hızlıdır. Bu nedenle CPU RAM'den bir bölgenin içeriğini istediğinde RAM 
    onu verene kadar CPU beklemektedir. İşte bu bekleme süresini azaltmak için DRAM belleğin en çok erişilen kısımları SRAM 
    denilen daha hızlı RAM'lerde tutulmaya başlanıştır. Eskiden cache amacıyla kullanılan bu SRAM bellekler board üzerinde 
    bulunuyordu. Belli bir zamandan sonra CPU'nun içerisine de cache bellek yerleştirilmeye başlandı. Bugün tipik olarak 
    bilgisayar sistemlerinde L1, L2, L3 ismiyle üç kademe cache sistemleri bulundurulmaktadır. Böylece CPU RAM'den bir bölgeyi 
    okumak istediğinde önce kendi içerisindeki L1 cache belleğe, sonra sırasıyla L2 ve L3 cache belleklere başvurmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Bir bilgisayar sisteminde yalnızca CPU değil, aynı zamanda yerel birtakım olaylardan sorumlu yardımcı işlemciler de bulunmaktadır. 
    Bu yardımcı işlemcilere genellikle "controller (denetleyici)" denilmektedir. Örneğin klasik PC donanımında "Kesme Denetleyicisi 
    (Intel 8259-PIC)", "Klavye Denetleyicisi (Intel 8042-Keyboard Controller)", "UART Denetleyicisi (Intel 8250/NS 16550-UART)" 
    gibi pek çok işlemci vardır. Bu işlemcilere komutlar tıpkı CPU/RAM haberleşmesinde olduğu gibi elektriksel düzeyde CPU'nun 
    adres uçları ve veri uçları yoluyla gönderilmekte ve bu işlemcilerden bilgiler yine tıpkı RAM'de olduğu gibi adres uçlarıyla 
    ve veri uçlarıyla alınmaktadır. Yani CPU'nun adres uçları ve veri uçları yalnızca RAM'e değil yardımcı işlemcilere de bağlıdır. 
    
    Bilgisayar sistemindeki yerel işlemlerden sorumlu yerel işlemciler yukarıda da belirttiğimiz gibi CPU tarafından elektriksel 
    olarak programlanmaktadır. Tabii aslında CPU programcının komutlarını çalıştırır. O halde yardımcı işlemcileri de programlayan 
    aslında sistem programcısıdır. Peki CPU yardımcı işlemcilere nasıl erişmektedir? İşte bilgisayar donanım tasarımında bu
    erişim iki farklı teknikle yapılabilmektedir:

    1) Port-Mapped IO (PMIO)
    2) Memory-Mapped IO (MMIO)

    İşlemcinin yardımcı işlemcilere erişimi aynı zamanda CPU mimarisi ile de ilgilidir. Örneğin Intel işlemcileri hem "port-mappped
    IO" tekniğinin hem de "memory-mapped IO" tekniğinin kullanımına izin verecek biçimde tasarlanmıştır. Ancak ARM işlemcileri 
    yalnızca "memory-mapped IO" tekniğinin kullanımına izin vermektedir. 

    Peki "port-mapped IO" tekniğinde CPU yardımcı işlemciye nasıl erişmektedir? İşte nasıl RAM'de her byte'ın bir adresi varsa
    yardımcı işlemcilerin de ismine "port numarası" denilen donanımsal bir adresi vardır. CPU "bu yardımcı işlemcilere onların 
    port adreslerini kullanarak erişmektedir. Bazı yardımcı işlemciler tek bir port adresine sahiptir. Bazılarının ise birden 
    fazla port adresi bulunabilmektedir. Peki CPU hem RAM'e hem de yardımcı işlemcilere adres ve veri uçlarıyla bağlı olduğuna 
    göre bu durumda elektriksel düzeyde bir iletişim çatışması oluşmaz mı? İşte "port-mapped IO" tekniğini kullanan işlemcilerde 
    genellikle IO/Mem biçiminde isimlendirilen bir kontrol ucu daha vardır. Bu uç yardımcı işlemcilere erişimde aktive edilirken 
    RAM erişimlerinde aktive edilmemektedir. Böylece RAM ve yardımcı işlemciler iletişimin kendileri ile yapılıp yapılmadığını 
    bu uca bakarak anlayabilmektedir. "Port-mapped IO" kullanan CPU'larda yardımcı işlemcilere bilgi gönderip onlardan bilgi 
    almak için özel makine komutları bulunmaktadır. Örneğin Intel işlemcilerinde IN, OUT, INS, OUTS makine komutları bu amaçla 
    kullanılmaktadır. 

    Memory-mapped IO tekniğinde "sanki RAM'in bir kısmı çıkartılmış da onun yerine oraya yardımcı işlemci" yerleştirilmiş 
    gibi bir durum oluşturulmaktadır. Böylece CPU sanki RAM'deki bir bölgeye erişiyormuş gibi yardımcı işlemcilere erişmektedir. 
    Bu teknik çeşitli avantajlar sağlamaktadır:

    1) Bu teknikle yardımcı işlemcilere normal bellek komutlarıyla erişilebilmektedir. Hatta C'de bir gösterici ile bile yardımcı 
    işlemcilere komut gönderilmesi onlardan bilgilerin alınması mümkün olmaktadır.
    
    2) Bu tekniğin uygulanması donanım tasarımcıları ve sistem programcıları için daha kolaydır ve temikle daha genel bir çözüm
    oluşturulabilmekltedir.

    3) Intel gibi bazı CPU mimarilerinde "port-mapped IO" için belli sayıda port adresi kullanılabilmektedir. Ancak "memory-mapped
    IO" tekniğinde istenildiği kadar port adresi kullanılabilmektedir.

    Ancak "memory-maped IO"tekniği fiziksel RAM'in ilgili kısımlarını kullanılamaz hale getirmektedir. Bu teknikte RAM'in bazı 
    bölgelerinde adeta RAM yok gibidir bu bölgeler yardımcı işlemcilere bağlıdır. 
   
    Peki biz sistem programcısı olarak ilgilendiğimiz yardımcı işlemci eğer "port-mapped IO" kullanıyorsa yardımcı onun port 
    numaralarını nasıl öğrenebiliriz? Benzer biçimde eğer yardımcı işlemci "memory-mapped IO" kullanıyorsa onun bellek adreslerini 
    nasıl öğrenebiliriz? Kurusumuzda daha önce kendini tanıtabilen aygıtların olabildiğinden bahsetmiştik. PC mimarisinde ACPI 
    denilen arayüz sayesinde sistem BIOS yardımcı işlemcilerin hangi port numaralarını kullandığını öğrenip bunu ACPI tablosuna
    yazabilmektedir. Gömülü sistemlerde ise bunun için "aygıt ağaçlarının (device trees)" kullanıldığını anımsayınız. İşte Linux
    işletim sistemi ACPI tablosundan ya da aygıt ağacından bu bilgileri alarak "/proc/ioports" ve "/proc/iomem" dosyaları yoluyla 
    bu bilgileri dış dünyaya vermektedir. Tabii aslında yardımcı işlemcilerin kullandığı default port numaraları ve bellek adresleri 
    çoğu kez zaten sistem programcısı tarafından biliniyor durumdadır. Bu default port numaraları ve default adresler bu tür 
    yardımcı işlemcilere ilişkin çeşitli kaynaklarda belirtilebilmektedir. 

    O halde bizim bir yardımcı işlemciyi programlayabilmemiz için şu bilgileri edinmiş olmamız gerekmektedir:

    1) Yardımcı işlemci "port-mapped IO" mu yoksa "memory-mapped IO" mu kullanmaktadır?
    2) Yardımcı işlemcinin port numaraları (ya da "memory-mapped IO" söz konusu ise bellek adresleri) nedir?
    3) Bu yardımcı işlemcinin hangi portuna (ya da "memory-mapped IO" söz konusu ise hangi adrese) hangi değerler gönderildiğinde 
    bu işlemci ne yapmaktadır?
    4) İşlemci bize bilgi verecekse bunu hangi portu okuyarak (ya da "memory-mapped IO" söz konusu ise hangi adresi okuyarak) 
    vermektedir? Verilen bilginin biçimi nedir?     
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki yardımcı işlemcilerin programlanması "kullanıcı modunda (user mode)" yapılabilir mi? Bunun için aygıt sürücüsü yazmaya
    gerek var mı? Aslında Linux işletim sisteminde yardımcı işlemciler üzerinde basit IO işlemlerinin yapılabilmesini sağlamak
    için "/dev/port" ve "/dev/mem" aygıt sürücüleri hazır bulundurulmuştur. Ancak bu aygıt sürücüler yoluyla donanım aygıtlarını
    programlamak karmaşık işlemlerde hem yavaş hem de eksik kontrol sağlamaktadır. Bu nedenle donanım aygıtları genellikle 
    çekirdek modunda çalışan aygıt sürücüler yoluyla doğrudan programlanmaktadır. 

    "/dev/port" aygıt sürücüsü oldukça basit bir tasarıma sahiptir. Programcı bu dosyayı açar. Sonra lseek fonksiyonuyla dosya
    göstericisini hangi port ile ilgileniyorsa o port numarasına konumlandırır. Bu konumlandırmadan sonra bu dosyadan read ve 
    write yapıldığında aygıt sürücünün read ve write fonksiyonları aslında "port-mapped IO" için gereken IN, OUT gibi makine 
    komutlarını kullanmaktadır. read ve write işlemi dosya göstericisinin konumunu ilerletmektedir. Aynı porttan işlem yapılırken 
    dikkat etmek gerekir. 
    
    "/dev/mem" aygıt sürücüsü ise "memory mapped IO" tekniğini kullanan aygıtların kullanıcı modunda programlanmasını sağlamaktadır. 
    Bu aygıt sürücü fiziksel RAM'i adeta bir dosya gibi göstermektedir. Tabii bu aygıt sürücüyle "memory-mapped IO" işlemi 
    için mmap fonksiyonu ile "memory mapping" yapmak gerekir. Yani adreste bu dosya bellek tabanlı biçimde açılır.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki yardımcı işlemcileri programlarken onlara tek hamlede kaç byte bilgi gönderip onlardan kaç byte bilgi okuyabiliriz?
    İşte bazı işlemciler (özellikle eskiden tasarlanmış olanlar) byte düzeyinde programlanmaktadır. Bazıları ise WORD düzeyinde 
    bazıları ise DWORD düzeyinde programlanabilmektedir. O halde bizim bir haberleşme portuna 1 byte, 2 byte, 4 byte gönderip 
    alabilmemiz gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki bir yardımcı işlemci çekirdek modunda aygıt sürücüler içerisinde programlanabiliyorsa kullanıcı mode programlar 
    bu yardımcı işlemciyi nasıl kullanmaktadır? İşte tipik olarak kullanıcı modundaki programlar read/write işlemleri ile ve 
    ioctl işlemleriyle aygıt sürücünün kodlarını çalıştırırlar. Aygıt sürücüler de bu kodlarda ilgili yardımcı işlemciye komutlar 
    yollayabilir. Tabii karmaşık yardımcı işlemciler için aygıt sürücüleri yazanlar faydalı işlemlerin daha kolay yapılabilmesi 
    için daha yüksek seviyeli fonksiyonları bir API kütüphanesi yoluyla da sağlayabilmektedir. Bunu şekilsel olarak şöyle 
    gösterebiliriz:

    Kütüphane fonksiyonları -----> read/write ve ioctl ----> çekirdek modundaki aygıt sürücücü kodları
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Port-mapped IO işlemlerinde kullanılması gereken işlemcilerin IN, OUT gibi makine komutları "özel (privileged)" komutlardır. 
    Bunlar kullanıcı modundan kullanılırsa işlemci koruma mekanizması gereği bir içsel kesme oluşturur, işletim sistemi de 
    bu kesme kodunda prosesi sonlandırır. Dolayısıyla bu komutları kullanarak donanım aygıtlarıyla konuşabilmek için çekirdek 
    modunda çalışan aygıt sürücülerin yazılması gerekmektedir. 

    Aygıtlara erişmekte kullanılan komutlar CPU mimarisine göre değişebildiğinden Linux çekirdeğinde bunlar için ortak arayüze 
    sahip inline fonksiyonlar bulundurulmuştur. Bu fonksiyonlar şunlardır:

    #include <asm/io.h>

    unsigned char inb(int addr);
    unsigned short inw(int addr);
    unsigned int inl(int addr);

    void outb(unsigned char b, int addr);
    void outw(unsigned short b, int addr);
    void outl(unsigned int b, int addr);

    inb haberleşme portlarından 1 byte, inw 2 byte, inl 4 byte okumak için kullanılmaktadır. Benzer biçimde haberleşme portlarına 
    outb 1 byte, outw 2 byte ve outl de 4 byte göndermektedir. Bir aygıtın portlarına kaç byte'lık komutların göndeirleceği ve 
    ondan kaç byte'lık okuma yapılacağı o aygıtın donanım tasarımını yapanlar tarafından belirlenmektedir. Eski yardımcı işlemciler
    1 byte komutlar kullanıyordu. Daha sonra 2 byte kullanan ve 4 byte kullanan yardımcı işlemciler de geliştirildi. Tek hamlede 
    8 byte (qword) gönderme ve almaya izin veren yardımcı işlemciler çok seyrek kullanılmaktadır. 

    Bazı mimarilerde bir bellek adresinden başlayarak belli bir sayıda byte'ı belli bir porta gönderen ve belli bir porttan 
    yapılan okumaları belli bir adresten itibaren belleğe yerleştiren özel makine komutları vardır. Bu komutlara string komutları 
    denilmektedir. (Intel'de string komutları yalnızca IO işlemleri ile ilgili değildir.) İşte bu komutlara sahip mimarilerde 
    bu string komutlarıyla IN, OUT yapan çekirdek fonksiyonları da bulundurulmuştur:

    #include <asm/io.h>

    void insb(unsigned long addr, void *buffer, unsigned int count);
    void insw(unsigned long addr, void *buffer, unsigned int count);
    void insl(unsigned long addr, void *buffer, unsigned int count);

    void outsb(unsigned long addr, const void *buffer, unsigned int count);
    void outsw(unsigned long addr, const void *buffer, unsigned int count);
    void outsl(unsigned long addr, const void *buffer, unsigned int count);

    insb, insw ve insl sırasıyla 1 byte 2 byte ve 4 byte'lık string fonksiyonlarıdır. Bu fonksiyonlar birinci parametresiyle 
    belirtilen port numarasından 1, 2 ya da 4 byte'lık bilgileri ikinci parametresinde belirtilen adresten itibaren belleğe 
    yerleştirirler. Bu işlemi de count kere tekrar ederler. Yani bu fonksiyonlar porttan count defa okuma yapıp okunanları 
    buffer ile belirtilen adresten itibaren belleğe yerleştirmektedir. outsb, outsw ve outsl fonksiyonları ise bu işlemin 
    tam tersini yapmaktadır. Yani bellekte bir adresten başlayarak count tane byte'ı birinci parametresiyle belirtilen porta 
    göndermektedir.

    Bazı sistemlerde aygıtlar (yani tardımcı işlemciler) yavaş kalabilmektedir. Eğer bus çok hızlı, aygıt yavaş ise o aygıt 
    portlarına peşi sıra bilgiler gönderilip alınırken sorunlar oluşabilmektedir. Bunun için bilgiyi porta gönderdikten ya da 
    bilgiyi porttan aldıktan sonra kısa bir süre bekleme yapmak gerekebilir. İşte bu nedenle yukarıdaki fonksiyonların bekleme 
    yapan p'li (pause) versiyonları da bulundurulmuştur.

    #include <asm/io.h>

    unsigned char inb_p(int addr);
    unsigned short inw_p(int addr);
    unsigned int inl_p(int addr);

    void outb_p(unsigned char b, int addr);
    void outw_p(unsigned short b, int addr);
    void outl_p(unsigned int b, int addr);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                160. Ders 04/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir haberleşme portu ile çalışmadan önce o portun boşta olup olmadığını belirlemek gerekebilir. Çünkü başka aygıtların 
    kullandığı portlara erişmek sorunlara yol açabilmektedir. Tabii eğer biz ilgili portun kullanılmasının bir soruna yol 
    açmayacağından eminsek başkalarının kullandığı portları doğrudan kullanabiliriz. Çekirdek bu bakımdan bir kontrol 
    yapmamaktadır. Kullanmadan önce bir portun başkaları tarafından kullanılıp kullanılmadığının sorgulanması için request_region 
    isimli çekirdek fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

    Fonksiyonun birinci parametresi kullanılmak istenen port numarasının başlangıç numarasını, ikinci parametresi ilgili 
    port numarasından itibaren ardışıl kaç port numarasının kullanılacağını, üçüncü parametresi ise "/proc/ioports" dosyasında 
    görüntülenecek ismi belirtmektedir. Fonksiyon başarı durumunda portları betimleyen resource isimli yapının başlangıç 
    adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Örneğin:

    if (request_region(PORT_START, NPORTS, "myports) == NULL) {
        ...
    }

    Eğer talep edilen port'ları başka bir aygıt sürücü daha önce request_region fonksiyonu ile elde etmişse request_region 
    fonksiyonu başarısız olmaktadır. Yukarıda da belirttiğimiz gibi aslında bu fonksiyon hiç çağrılmadan port kullanılabilir. 
    Ancak bu mekanizma bir çeşit anlaşma sağlamaktadır. 
        
    request_region fonksiyonu ile tahsis edilen port numaraları release_region fonksiyonu ile serbest bırakılmalıdır:

    #include <linux/ioport.h>

    void release_region(unsigned long start, unsigned long n);

    Yukarıda da belirttiğimiz gibi portların kullanılması için bu biçimde tahsisat yapma zorunluluğu yoktur. Ancak programcı 
    programlanabilir IO portları söz konusu olduğunda ilgili port numaralarını başkalarının kullanmadığından emin olmak için 
    bu yöntemi izlemelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    PC'lerdeki klavye denetleyicisinin (klavye içerisindeki değil, PC tarafındaki denetleyicinin (orijinali Intel 8042)) 
    60H ve 64H numaralı iki portu vardır. 60H portu hem okunabilir hem de yazılabilir durumdadır. 60H portu 1 byte olarak 
    okunduğunda son basılan ya da çekilen tuşun klavye scan kodu elde edilmektedir. Yukarıda da belirttiğimiz gibi klavye 
    terminolojisinde tuşa basılırken oluşturulan scan koduna "make code", parmak tuştan çekildiğinde oluşturulan scan koduna 
    ise "break code" denilmektedir. Klavye içerisindeki işlemcinin (keyboard encoder) break code olarak önce bir F0 byte'ını 
    sonra da make code byte'ını gönderdiğini belirtmiştik. İşte PC içerisindeki klavye denetleyicisi bu break kodu aldığında 
    bunu iki byte olarak değil, yüksek anlamlı biti 1 olan byte olarak saklamaktadır. Böylece biz 60H portunu okuduğumuzda 
    onun yüksek anlamlı bitine bakarak okuduğumuz scan kodunun make code mu yoksa break code mu olduğunu anlayabiliriz.

    Klavye denetleyicisinin 60H portuna gönderilen 1 byte değere "keyboard encoder command" denilmektedir. Bu 1 byte'lık komut 
    klavye denetleyicisi tarafından klavye içerisindeki işlemciye gönderilir. Ancak bu 1 byte'tan sonra bazı komutlar parametre 
    almaktadır. Parametreler de komuttan sonra 1 byte olarak aynı port yoluyla iletilmektedir.

    Aşağıdaki aygıt sürücü örneğinde klavyeden tuşlara basıldığında basılan ve çekilen tuşların make ve break code'ları 
    yazdırılmaktadır. Ancak burada bir noktayı belirtmek istiyoruz. Biz bu örnekte IRQ1 kesme kodunda 60h protunu okuduğumuzda 
    Linux çekirdeği de bu portu okuduğu için klavye denetleyicisinin tasarımından dolayı bazı çalışma sorunları ortaya 
    çıkabilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>
#include <asm/io.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Keyboard Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static unsigned char g_keymap[128] = {
    [30] = 'A',
    [31] = 'S',
    [32] = 'D',
    [33] = 'F',
};
  
static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "keyboard-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "keyboard-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "keyboard-driver init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1,  &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "keyboard-driver exit...\n");
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    unsigned char code;
    char *code_type;

    code = inb(0x60);

    code_type = code & 0x80 ? "Break code: " : "Make code: ";

    if (g_keymap[code & 0x7F])
        printk(KERN_INFO "%s %c (%02X)\n", code_type, g_keymap[code & 0x7F], code);
    else
        printk(KERN_INFO "%s %02X\n", code_type, code);

    return IRQ_HANDLED;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                                161. Ders 09/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kesme kodları bazen bilgiyi bir kaynaktan alıp (örneğin network kartından, seri porttan, klavye denetleyicisinden) onu 
    bir yere (genellikle bir kuyruk sistemi) yerleştirip, uyuyan thread'leri uyandırmaktır. Örneğin bir thread'in klavyeden 
    bir tuşa basılana kadar bekleyeceğini düşünelim. Bu durumda thread işletim sistemi tarafından bir bekleme kuyruğuna alınır. 
    Klavyeden bir tuşa basıldığında oluşan IRQ içerisinde bu bekleme kuyruğunda bekleyen thread'ler uyandırılır.

    Aşağıda örnekte aygıt sürücüye aygıt sürücünün bir IOCTL komutunda thread bloke edilmiştir. Sonra klavyeden bir tuşa 
    basıldığında thread uykudan uyandırılıp basılmış olan tuşuna scan kodu IOCTL kodu tarafından thread'e verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.h */

#ifndef KEYBOARDDRIVER_H_
#define KEYBOARDDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY            _IOR(KEYBOARD_MAGIC, 0, int)

#endif

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/interrupt.h>
#include <asm/io.h>
#include "keyboard-driver.h"

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Keyboard Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};

static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irkeyboard-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "keyboard-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "keyboard-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            if (copy_to_user((void *)arg, &g_key, sizeof(int)) != 0)
                return -EFAULT;

            return g_key;
        default:
            return -ENOTTY;
    }
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "keyboard-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* kdtest.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int key;

    if ((fd = open("keyboard-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (ioctl(fd, IOC_GETKEY, &key) == -1)
        exit_sys("ioctl");

    printf("Scan code: %d (%02x)\n", key, key);

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte IOC_SETLIGHTS ioctl komutu ile 8042 klavye denetleyicisine komut gönderme yoluyla klavye ışıkları yakılıp 
    söndürülmektedir. Klavyede üç ışıklı tuş vardır: Caps-Lock, Num-Lock ve Scroll-Lock. Bu ışıkları yakıp söndürebilmek için 
    önce 60H portuna 0xED komutu gönderilir. Sonra yine 60H portuna ışıkların durumunu belirten 1 byte gönderilir. Bu byte'ın 
    düşük anlamlı 3 biti sırasıyla Scroll-Lock, Num-Lock ve Caps-Lock tuşlarının ışıklarını belirtmektedir:

    7 6 5 4 3 CL NL SL
    x x x x x x  x  x

    60H portuna komut göndermeden önce 64H portundan elde edilen değerin 2 numaralı bitinin 0 olması gerekmektedir. Ayrıntılı 
    bilgi için http://www.brokenthorn.com/Resources/OSDev19.html sayfasını inceleyebilirsiniz.

    Aşağıdaki aygıt sürücüde IOC_SETLIGHTS IOCTK komutunda klavye ışıklarının yakılıp söndürülmesi sağlanmıştır. Burada
    "kdtest.c" isimli user mode program bir komut satırı argümanı almış ve o komut satırı argümanındaki sayıyı yukarıda 
    anlattığımız gibi klavye denetleyicisine göndermiştir. Artık pek çok klavyede Scroll-Lock ve Num-Lock tuşlarının ışıkları
    bulunmamaktadır. Programın Caps-Lock ışığını yakmasını istiyorsanız 4 argümanıyla (CL bitinin 2 numaralı bit olduğuna 
    dikkat ediniz) söndürmek istiyorsanız 0 argümanıyla çalıştırabilirsiniz. Örneğin:

    $ ./kdtest 4
    $ ./kdtest 0
---------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.h */

#ifndef KEYBOARDDRIVER_H_
#define KEYBOARDDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY            _IOR(KEYBOARD_MAGIC, 0, int)

#endif

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/interrupt.h>
#include <asm/io.h>
#include "keyboard-driver.h"

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};

#ifndef IRQDRIVER_H_
#define IRQDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY            _IOR(KEYBOARD_MAGIC, 0, int)

#endif

static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "keyboard-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "keyboard-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "keyboard-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            if (copy_to_user((void *)arg, &g_key, sizeof(int)) != 0)
                return -EFAULT;

            return g_key;

        case IOC_SETLIGHTS:
            while ((inb(0x64) & 2) != 0)
                ;
            outb(0xED, 0x60);
            while ((inb(0x64) & 2) != 0)
                ;
            outb(arg, 0x60);
            break;
        default:
            return -ENOTTY;
    }
    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "keyboard-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* kdtest.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-driver.h"

#define CAPS_LOCK           0x04
#define NUM_LOCK            0x02
#define SCROLL_LOCK         0x04

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    int key;
    int keycode;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    keycode = atoi(argv[1]);

    if ((fd = open("keyboard-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (ioctl(fd, IOC_SETLIGHTS, keycode) == -1)
        exit_sys("ioctl");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
     Şimdi de Intel tabanlı masaüstü bilgisayarlardaki RTC (Real Time Clock) devresinden zamanı okuyan bir aygıt sürücü yazalım.
    Bugün kullandığımız PC'lerde bilgisayar kapatıldıktan sonra zamanı tutanm ismine "gerçek zaman saati (real time clock)" 
    denilen bir yardımcı işlemci (denetleyici) vardır. Masaüstü bilgisayarlarımızı açarken Del ya da F1 tuşuna basarak çıkarttığımız 
    setup ekranındaki bilgiler de (buna CMOS setup bilgileri de denilmektedir) aslında aynı denetleyicinin içerisindeki bir 
    RAM'de tutulmaktadır. RTC denetleyicisi bir pille beslenmektedir. İşletim sistemleri boot işlemi sırasında RTC denetleyicisine 
    başvurarak tarih ve zamanı alıp sonra da bu tarih ve zamanı bilgisayar açık olduğu sürece güncellemektedir. Yani genellikle 
    RTC denetleyicisine yalnızca açılış sırasında başvurulmaktadır. Tabii biz işletim sisteminde saati ve tarihi ayarladığımızda 
    işletim sistemi de RTC denetleyicisindeki saati yeniden ayarlar. 

    PC'lerimizdek RTC denetleyicisi ile port-mapped IO kullanılarak haberleşilmektedir. RTC denetleyicisinin iki portu vardır. 
    Pc'lerimizde bu portlar 70h ve 71h portlarıdır. RTC 8 bitlik bir denetleyicidir. Dolayısıyla bu portlarla 8 bitlik değerler 
    okunup yazılabilmektedir. 70h portu kontrol portudur, 71h portu ise bilgilerin alındığı ve gönderildiği porttur. Sistem 
    programcısı önce 70h portuna komut göndererek 71h prortunun hangi amaçla kullanılacağını belirler. Sonra 71h portunu okur 
    ya da ona yazma yapar. Biz aşağıdaki örneğimizde 70h portuna komut gönderdikten sonra 71h portunu okuyan bir fonksiyon 
    tanımladık:

    static inline unsigned int rtc_read(unsigned int cmd)
    {
        outb(cmd, 0x70);         
        return inb(0x71);        
    }

    RTC denetleyicisinden saat, dakika ve saniye bilgilerini de şöyle ettik:

    hour = rtc_read(0x04);
    minute = rtc_read(0x02);
    second = rtc_read(0x00);

    RTC denetleyicisi bilgileri binry ta da BCD olarak verebilmektedir. Bu durum ayarlanabilmektedir. RTC denetleyicisinin 
    verdiği bilgilerin binary mi yoksa BCD mi olduğu 70H portuna 0x0B gönderilip 71H protunun okunmasıyla elde edilebilmektedir. 
    Örneğin:

    if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
        ...
    }
    else {
       ...
    }

    Aslında RTC denetleyicisinden bilgi okunurken tesadüfen onun güncelleme işlemine denk gelinirse geçersiz değerler okunabilmektedir.
    Bu nedenle okuma işleminin daha güvenli bir biçimde yapılması gerekir. Ancak biz burada karmaşıklık oluşmasın diye bu durumu 
    göz ardı ediyourz.

    Örneğimizde bir aygıt sürücü oluşturarak aygıt sürücü için ioctl fonksiyonunu yazdık. Aygıt sürücünün iotcl fonksiyonu 
    şöyle yazılmıştır:

    static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;

        switch (cmd) {
            case IOC_RTC_GETTIME:
                result = ioctl_gettime(filp, (struct RTC_TIME *)arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    static inline unsigned int rtc_read(unsigned int cmd)
    {
        outb(cmd, 0x70);         
        return inb(0x71);        
    }

    static inline int bin_to_bcd(int val)
    {
        return (val >> 4 ) * 10 + (val & 0x0F);
    }

    static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct)
    {
        struct RTC_TIME rtm;
        int hour, minute, second;
        
        hour = rtc_read(0x04);
        minute = rtc_read(0x02);
        second = rtc_read(0x00);
        
        if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
            rtm.hour = bin_to_bcd(hour);
            rtm.minute  = bin_to_bcd(minute);
            rtm.second = bin_to_bcd(second);
        }
        else {
            rtm.hour = hour;
            rtm.minute  = minute;
            rtm.second = second;
        }

        if (copy_to_user(rtct, &rtm,  sizeof(rtm)) != 0)
            return -EFAULT;   

        return 0;
    }

    Kullanıcı modundan zaman bilgisi ioctl çağrısı ile elde edilmektedir. Örneğin:

    int fd;
    struct RTC_TIME rtct;
		
	if ((fd = open("rtc-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_RTC_GETTIME, &rtct) == -1)
        exit_sys("ioctl");

    printf("%02d:%02d:%02d\n", rtct.hour, rtct.minute, rtct.second);

    close(fd);
---------------------------------------------------------------------------------------------------------------------------*/

/* rtc-driver.h */

#ifndef RTC_DRIVER_H_
#define RTC_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

struct RTC_TIME {
    int hour;
    int minute;
    int second;
};

#define RTC_DRIVER_MAGIC		    'r'
#define IOC_RTC_GETTIME		        _IOR(RTC_DRIVER_MAGIC, 1, struct RTC_TIME)

#endif

/* rtc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include "rtc-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("rtc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.write = generic_write,
	.release = generic_release,
    .unlocked_ioctl = rtc_driver_ioctl
};

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "rtc-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "rtc-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

	return 0;
}

static void __exit generic_exit(void)
{
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "rtc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "rtc-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "rtc-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "rtc-driver read...\n");

	return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "rtc-driver write...\n");

	return 0;
}

static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;

    switch (cmd) {
        case IOC_RTC_GETTIME:
            result = ioctl_gettime(filp, (struct RTC_TIME *)arg);
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline unsigned int rtc_read(unsigned int cmd)
{
    outb(cmd, 0x70);         
    return inb(0x71);        
}

static inline int bin_to_bcd(int val)
{
    return (val >> 4 ) * 10 + (val & 0x0F);
}

static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct)
{
    struct RTC_TIME rtm;
    int hour, minute, second;
    
    while (rtc_read(0x0A) & 0x80)
        ;

    hour = rtc_read(0x04);
    minute = rtc_read(0x02);
    second = rtc_read(0x00);
    
    if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
        rtm.hour = bin_to_bcd(hour);
        rtm.minute  = bin_to_bcd(minute);
        rtm.second = bin_to_bcd(second);
    }
    else {
        rtm.hour = hour;
        rtm.minute  = minute;
        rtm.second = second;
    }

    if (copy_to_user(rtct, &rtm,  sizeof(rtm)) != 0)
		return -EFAULT;   

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* rtc.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "rtc-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct RTC_TIME rtct;
		
	if ((fd = open("rtc-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_RTC_GETTIME, &rtct) == -1)
        exit_sys("ioctl");

    printf("%02d:%02d:%02d\n", rtct.hour, rtct.minute, rtct.second);

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve işlemciler tarafından yapılan önemli bir optimizasyon temasına "komutların yer değiştirilmesi (instruction 
    reordering)" denilmektedir. Bu optimizasyon hem derleyici tarafından hem de işlemcinin kendisi tarafından yapılabilmektedir. 
    Bu optimizasyonda birbirlerini normal bir durumda etkilemeyecek iki ya da daha fazla ayrı makine komutunun yerleri hız 
    kazancı sağlamak amacıyla yer değiştirilmektedir. Bu tür yer değiştirmeler normal kullanıcı modu programlarında hiçbir 
    davranış değişikliğine dolayısıyla da soruna yol açmazlar ancak işletim sistemlerinin ve aygıt sürücülerinin yazımı sırasında 
    bu duruma dikkat edilmesi gerekir. Bu tür çekirdek kodlamalarında komutların işlemci tarafından yer değiştirilmesi potansiyel 
    sorunların ortaya çıkmasına yol açabilmektedir. Örneğin birbirleriyle alakasız iki adrese yazma yapılması durumunda yazma 
    komutlarının yer değiştirmesi işlemcinin bu işleri daha hızlı yapabilmesine yol açabilmektedir. Fakat IO portları ve 
    memory-mapped IO söz konusu olduğunda bu sıralama değişikliği istenmeyen olumsuz sonuçlar doğurabilmektedir. Yalnızca bu 
    biçimdeki IO işlemlerinde değil aynı zamanda senkronizasyon nesnelerinin gerçekleştiriminde de komutların yer değiştirmesi 
    durumuna dikkat edilmesi gerekir. İşte bu yer değiştirmeyi ortadan kaldırmak için "bellek bariyeri (memory barrier)" koyma 
    yöntemi uygulanmaktadır. İşlemciler bellek bariyerininin yukarısıyla aşağısını yer değiştirmemektedir. Linux çekirdeğinde 
    kullanılan Bariyer fonksiyonları şunlardır:

    #include <asm/system.h>

    void rmb(void);
    void wmb(void);
    void mb(oid);

    rmb fonksiyonunun aşağısındaki kodlar yukarısındaki okuma işlemleri yapıldıktan sonra yapılırlar. wmb fonksiyonunda 
    ise wmb fonksiyonun yukarısındaki yazma işlemleri yapıldıktan sonra aşağıdaki kodlar çalıştırılır. mb fonksiyonu ise 
    hem okuma hem yazma için yukarıdaki ve aşağıdaki kodları birbirlerinden ayırmaktadır. Örneğin:

    ...
    wmb();
    ...

    Burada wmb fonksiyonunun yukarısındaki belleğe yazma işlemleri bittikten sonra altındaki kodlar çalıştırılacaktır. Bellek 
    bariyerleri Intel ve ARM mimarilerinde özel makine komutlarıyla sağlanmaktadır. Bu fonksiyonlar hangi mimari söz konusuysa 
    o mimariye özgü bariyer oluşturan makine komutlarını kullanmaktadır.
    
    Linux çekirdeğinde önceki paragraflarda gördüğümüz port-mapped IO fonksiyonları zaten kendi içlerinde bellek bariyerlerini 
    kullanmaktadır. Bu nedenle bizim aşağıdaki gibi port işlemlerinde ayrıca bariyer kullanmamıza gerek kalmaz:

    outb(cmd, 0x70);         
    inb(0x71);

    Bu fonksiyonlar zaten kendi içlerinde bellek bariyerlerini oluşturdukları için bunların yer değiştirilmesi söz konusu 
    olmamaktadır. Aygıt sürücü programcısı genellikle Linux çekirdek fonksiyonlarını kullanarak kodlama yapmaktadır. Bu 
    fonksiyonlar da zaten kendi içlerinde gerekli yerlere bellek bariyerlerini yerleştirmektedir. Bu nedenle aygıt sürücü 
    programcısı açıkça bellek bariyerlerini kullanmaya çoğu durumda gereksinim duyduymamaktadır. 

    C11 ve C++11 ile birlikte C'ye ve C++'a bellek atomik işlemler yapan ve bellek bariyerlerleri oluşturan fonksiyonlar da 
    eklenmiştir. Böylece artık atomik işlemler ve bellek bariyerleri taşınabilir bir biçimde oluşturulabilir hale gelmiştir. 
    Biz burada bu taşınabilir fonksiyonlar üzerinde durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Memory-mapped IO işlemi pek çok mimaride normal göstericilerle yapılabilmektedir. Yani aslında bu mimarilerde memory-mapped 
    IO için özel çekirdek fonksiyonlarının kullanılmasına gerek olmayabilir. Ancak bazı mimarilerde memory-mapped IO işlemi 
    için özel bazı işlemlerin de yapılması gerekebilmektedir. Bu nedenle bu işlemlerin taşınabilir biçimde yapılabilmesi için 
    özel çekirdek fonksiyonlarının kullanılması tavsiye edilir.

    Tıpkı port-mapped IO işlemlerinde olduğu gibi memory-mapped IO işlemleri için de iki farklı aygıt aynı adres bölgesini 
    kullanmasın diye bir registration işleminin yapılması tavsiye edilmektedir. Bu işlemler request_mem_region ve release_mem_region 
    fonksiyonlarıyla yapılmaktadır. request_mem_region fonksiyonunun prototipi şöyledir:

    #include <linux/ioport.h>

    struct resource *request_mem_region(unsigned long start, unsigned long len, const char *name);

    Fonksiyonun birinci parametresi başlangıç fiziksel bellek adresini, ikinci parametresi alanın uzunluğunu belirtmektedir. 
    Üçüncü parametre ise "/proc/iomem" dosyasında görüntülenecek olan isimdir. Fonksiyon başarı durumunda resource isimli bir 
    yapı nesnesinin adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Daha önce register ettirilmiş olan bellek 
    bölgesini serbest bırakmak için (yani register ettirilmemiş hale getirmek için) release_mem_region fonksiyonu kullanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    void release_mem_region(unsigned long start, unsigned long len);

    Fonksiyonun birinci parametresi başlangıç fiziksel bellek adresini, ikinci parametresi ise uzunluğu belirtmektedir.

    Donanım aygıtının kullandığı bellek adresleri fiziksel adreslerdir. Örneğin aygıt 0xFFFF8000 gibi bir adresi kullanıyorsa 
    bu adres fiziksel adrestir. Halbuki aygıt sürücünün sanal adres yoluyla bu fiziksel adrese erişebilmesi için bu dönüşümü 
    yapacak sayfa tablosu girişlerinin bulunuyor olması gerekir. Çünkü program içerisindeki sanal adresler sayfa tablosu yoluyla 
    fiziksel adreslere dönüştürülmektedir. İşte fiziksel adresler için sayfa tablosunda sanal adres girişlerini oluşturan 
    ioremap isimli bir çekirdek fonksiyonu vardır. Bu çekirdek fonksiyonuna biz fiziksel adresi ve onun uzunluğunu veririz, 
    fonksiyon da sayfa tablosunda bu fiziksel adrese erişmek için gerekli düzenlemeyi yapar ve bize erişimde kullanabileceğimiz 
    sanal adresi verir. ioremap fonksiyonun prototipi şöyledir:

    #include <asm/io.h>

    void *ioremap(unsigned long physical_address, unsigned long size);

    Fonksiyonun birinci parametresi fiziksel adresii ikinci parametresi map edilecek uzunluğu belirtmektedir. Fonksiyon bize 
    bu fiziksel adrese erişmekte kullanılacak sanal adresi vermektedir. Bugünkü mikroişlemciler birden fazla çekirdeğe sahip 
    olabilmektedir. Her çekirdeğin ayrı bir cache'i vardır. (Buna L1 cache ve L2 cache de denilmektedir.) CPU RAM'e erişimi 
    azaltmak için (çünkü RAM göreli olarak yavaştır) okuma ve yazma işlemleri için mümkün olduğunca kendi içerisindeki 
    cache'leri kullanır. Bunun sonucu olarak da aslında biz bir bellek adresine örneğin yazma yaptığımızda CPU aslında yazmayı
    RAM'e değil kendi cache'ine yapıyor olabilir. Tabii bu bilgi bir süre sonra RAM'e aktarılmaktadır. İşte memory-mapped IO 
    tekniğinde donanım aygıtının kullandığı RAM bölümünün CPU tarafından cache'lenmemesi gerekir. Bu işlem sayfa tablşosundaki
    bazı bitler ile sağlanmaktadır. İşte ioremap fonksiyonu bu işlemi de yapmaktadır. Aksi takdirde donanım aygıtına göndermek 
    istediğimiz bilgiler elektirksel olarak oraya gönderilmeyebilecektir. Ayrıca ioremap işleminin CPU cache'lerini devre dışı 
    bırakmayan ioremap_cache isimli bir biçimi de vardır. 

    ioremap işlemini geri almak için iounmap fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <asm/io.h>

    void iounmap(void *addr);

    Fonksiyon sanal bellek adresini parametre almaktadır. Uzunluk bilgisi zaten çekirdek tarafından kaydedildiği için ayrıca
    fonksiyona verilmemektedir. 

    ioremap fonksiyonu ile sanal adres elde edildikten sonra biz C'de göstericilerle doğrudan aygıta erişebilir miyiz? Aslında 
    erişebiliriz. Ancak önceki paragrafta açıkladığımız gibi erişimi sorunsuz yapabilmek için platforma bağlı olarak bellek 
    bariyerlerinin kullanılması gerekir. Bu nedenle erişimin doğrudan göstericilerle değil özel çekirdek fonksiyonlarıyla 
    yapılması tavsiye edilmektedir. Memory-mapped IO ile aygıta erişen çekirdek fonksiyonları çekirdeğin belli bir versiyonundan 
    sonra daha modern hale getirilmiştir. Biz burada daha taşınabilir daha yeni fonksiyonları tanıtacağız. Aşağıdaki fonksiyonlar 
    addr ile belirtilen bellek adresinden 1 byte, 2 byte ve 4 byte okurlar.

    #include <asm/io.h>

    u8   ioread8(const void __iomem *addr);
    u16  ioread16(const void __iomem *addr);
    u32  ioread32(const void __iomem *addr);
    u64  ioread64(const void __iomem *addr);

    Aşağıdaki fonksiyonlar ise addr ile belirtilen bellek adresine 1 byte, 2 byte ve 4 byte bilgi yazmaktadır:

    #include <asm/io.h>

    void iowrite8(u8 value, void __iomem *addr);
    void iowrite16(u16 value, void __iomem *addr);
    void iowrite32(u32 value, void __iomem *addr);
    void iowrite64(u64 value, void __iomem *addr);  

    Bazı platformlarda ioread64 ve iowrite64 fonksiyonları yoktur. Bu platformlarda 32 bitten daha fazla okumalar için izleyen 
    paragraflarda açıklayacağımız memcpy_fromio ve memcpy_toio fonksiyonlarını kullanmalısınız.  

    Bu ioreadxxx ve iowritexxx fonksyonları yerine eskiden readxxx ve writexxx fonksiyonları kullanılıyordu. ioradxxx ve iowritexxx 
    fonksiyonları 2.6 sürümleriyle çekirdeğe eklenmiştir. Ancak eski readxxx ve writexxx fonksiyonları yeni çekirdeklerde de 
    muhafaza edilmektedir. writexxx ve readxxx fonksiyonlarının listesi de şöyledir:

    readb
    readw
    readl
    readq

    writeb
    writew
    wrirel
    writeq 

    Yukarıdaki fonksiyonların rep'li (repetition/tekrar) versiyonları da vardır:

    #include <asm/io.h>

    void ioread8_rep(void *addr, void *buf, unsigned long count);
    void ioread16_rep(void *addr, void *buf, unsigned long count);
    void ioread32_rep(void *addr, void *buf, unsigned long count);

    void iowrite8_rep(void *addr, const void *buf, unsigned long count);
    void iowrite16_rep(void *addr, const void *buf, unsigned long count);
    void iowrite32_rep(void *addr, const void *buf, unsigned long count);

    Bu fonksiyonlar donanım aygıtına ilişkin bellek adresinden belli bir adrese belli miktarda (count parametresi) 
    byte, word ya da dword transfer etmektedir. 

    Tıpkı memcpy fonksiyonunda olduğu gibi memory-mapped aygıt ile bellek arasında blok kopyalaması yapan iki fonksiyon 
    da bulunmaktadır:

    #include <asm/io.h>

    void memcpy_fromio(void *dest, const void *source, unsigned int count);
    void memcpy_toio(void *dest, const void *source, unsigned int count);

    Belli bir memory-mapped IO adresinden itibaren belli bir byte'ı n defa dolduran memset_io isimli bir fonksiyon da vardır:

    #include <asm/io.h>

    void memset_io(void *dest, u8 value, unsigned int count);

    Bu fonksiyonu memset fonksiyonuna benzetebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de Intel tabanlı PC mimarisinde memory-mapped IO örneği verelim. PC mimarisinde geleneksel olarak port-mapped IO 
    kullanılmaktadır. Ancak mimariye sonradan eklenen donanım bileşenleri memory-mapped IO kullanacak biçimde tasarlanmıştır. 
    
    Eskiden PC mimarisinde tek işlemci vardı ve bu işlemcinin içerisinde de APIC (yani kesme denetleyicisi ve timer devresi)
    yoktu. Eski PC'lerde zamanlama amacıyla yalnızca board üzerinde Inetl 8254 PIT (Programmable Interval Timer) devresi 
    kullanılıyordu. Gerçekten de işletim sistemlerinde preemptive bağlamsal geçiş (context switch) işlemini bu timer devresinin
    ürettiği kesme tetikliyordu. Ancak daha sonraları PC mimamrisine HPET (High Precision Event Timer) isimli modern ve yüksek
    çözünürlüklü bir timer devresi eklenmiştir. HPET  denetleyicisi aynı zamanda kesme de oluşturabilmektedir. Bu timer devresine 
    memory-mapped IO tekniğiyle erişilmektedir. Aynı zamanda Linux sistemlerinde HPET denetleyicisine erişmek için "/dev/hpet" 
    isimli bir aygıt sürücü de bulundurulmuştur. Bu aygıt sürücüden okuma yapıldığında aygıt sürücü HPET içerisindeki sayacın 
    değerini bize vermektedir. HPET sayacının frekansı bir IOCTL komut kodu ile elde edilebilmektedir. Ancak son zamanlarda 
    bazı dağıtımlar bu aygıt sürücünün read fonksiyonunun içini silip doğrudan fonksiyonu -EIO hata kodu ile geri döndürmektedir. 
    Dolaysıyla read fonksiyonu da "Input/output error" hata mesajıyla başarısız olmaktadır. Ancak biz yine de aşağıda bir kod 
    parçasının çalışma süresinin bu HPET aygıt sürücüsü yoluyla nasıl hesaplanacağına bir örnek veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/hpet.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct hpet_info info;
    uint64_t start, end;
    double result;
		
	if ((fd = open("/dev/hpet", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, HPET_INFO, &info) == -1) 
        exit_sys("ioctl");
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / info.hi_ireqfreq;
    printf("Elapsed time: %f\n", result);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de biz HPET denetleyicisine ilişkin bir aygıt sürücü yazalım. Aygıt sürücümüzün read fonksiyonu aygıttan 8 byte 
    okunduğunda HPET içeirsindeki sayacın değerini versin. HPET sayacının frekansını almak için de bir ioctl komutu kullanalım.
    HPET denetleyicisinin memory-mapped fiziksel adresi default durumda 0xFED00000 biçimindedir. Ancak PC'lerde plug and play 
    tekniği sayesinde ACPI protokolü tarafından çakışma durumunda bu adres değiştirilebilmektedir. Yani bu denetleyicinin 
    memory-mapped fiziksel adresini elde etmenin en güvenilir yolu ACPI tablosuna başvurmaktır. Çalışan Linux sisteminizde 
    aşağıdaki komut ile dmesg log'larından denetleyicinin adresini elde edebilirsiniz:

    $ dmesg | grep -i hpet

    Örnek çıktı şöyle olabilir:

     0.003467] ACPI: HPET 0x00000000BFEE76F7 000038 (v01 VMWARE VMW HPET 06040000 VMW  00000001)
    [    0.003475] ACPI: Reserving HPET table memory at [mem 0xbfee76f7-0xbfee772e]
    [    0.149999] ACPI: HPET id: 0x8086af01 base: 0xfed00000
    [    0.481936] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns
    [    1.218886] hpet0: at MMIO 0xfed00000, IRQs 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    [    1.218886] hpet0: 16 comparators, 64-bit 14.318180 MHz counter
    [    1.468033] rtc_cmos 00:01: alarms up to one month, y3k, 114 bytes nvram, hpet irqs
    ...

    Aygıt sürücücümüzün 0xFED00000 fiziksel adresine erişebilmesi için ioremap fonksiyonun çağrılması gerekir. Örneğimizde 
    fonksiyon şçyle çağrılmıştır:

    static void *g_hpet_base;;
    ...

    if ((g_hpet_base = ioremap(HPET_BASE_ADDR, 4096)) == NULL) {     
        ...
        return -ENOMEM;
    }
   
    HPET denetleyicisinden sayaç değerini almak için denetleyicinin taban adresinden 0xF0 byte ilerisinden 8 byte'ın okunması 
    gerekir. Bu okuma işlemi aygıt sürücü içerisinde şöyle yapılabilmektedir:

    memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
    
    HPET aygıt sürücüsü kullanıcı modundan her okunduğunda bize 8 byte'lık sayaç değerini verecektir. Dosya göstericisinin 
    kullanılmasına gerek yoktur. Her okumanın dosyanın başından itibaren yapıldığı kabul edilebilir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        u64 count_val;

        if (size < sizeof(count_val))
            return -EINVAL;

        memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
        if (copy_to_user(buf, &count_val , size) != 0)
            return -EFAULT;

        return size;
    }

    Peki elde edilen bu sayaç değerine ilişkin sayaç saniyede kaç kere güncellenmektedir? Yani bu sayacın frekeansı 
    nedir? İşte bu sayacın frekansını almak için örneğimizde IOC_HPET_GETFREQ isimli bir ioctl komutu bulundurulmuştur:

    static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
        u64 cap_id;
        u32 clk_period_fs;
        u64 frequency_hz;

        switch (cmd) {
            case IOC_HPET_GETFREQ:
                memcpy_fromio(&cap_id, (char *)g_hpet_base + HPET_GEN_CAP_ID_OFFSET, sizeof(u64));
                clk_period_fs = cap_id >> 32;      // femtosaniye per tick
                frequency_hz = 1000000000000000ULL / clk_period_fs;
                if (copy_to_user((void *)arg, & frequency_hz, sizeof(u64)) != 0)
                    return -EFAULT;     
                result = 0;         
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada frekansın nasıl alındığını anlamak HPET denetleyicisine ilişkin bazı ayrıntıların bilinmesi gerekmektedir. Biz 
    burada bu ayrıntılara girmeyeceğiz. Frekansı elde etmek için ioctl fonksiyonu uint64_t türünden bir nesnenin adresiyle 
    çağrılmalıdır. Sayaç değeri bu adrese yerleştirilecektir. 

    Aygıt sürücümüz kullanıcı modundan şöyle  kullanılabilir:

    if ((fd = open("hpet-driver", O_RDONLY)) == -1)
		exit_sys("open");
        
    if (ioctl(fd, IOC_HPET_GETFREQ, &freq) == -1) 
        exit_sys("ioctl");
    
    printf("Frequency: %llu\n", freq);
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / freq;
    printf("Elapsed time: %f\n", result);

    Aygıt sürücümüzün tüm kodları aşağıda verilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* hpet-driver.h */

#ifndef HPET_DRIVER_H_
#define HPET_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define HPET_DRIVER_MAGIC		    'h'

#define IOC_HPET_GETFREQ	        _IOR(HPET_DRIVER_MAGIC, 1, unsigned long long)

#endif

/* hpet-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include "hpet-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("hpet-driver");

#define HPET_BASE_ADDR              0xFED00000
#define HPET_GEN_CAP_ID_OFFSET      0x00
#define OFFSET_MAIN_CNT             0xF0

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.release = generic_release,
    .unlocked_ioctl = hpet_driver_ioctl
};

static void *g_hpet_base;

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "hpet-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "hpet-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    if ((g_hpet_base = ioremap(HPET_BASE_ADDR, 4096)) == NULL) {
        cdev_del(&g_cdev);
        unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot remap IO device!...\n");
        return -ENOMEM;
    }
   
	return 0;
}

static void __exit generic_exit(void)
{
    iounmap(g_hpet_base);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "hpet-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "hpet-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "hpet-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    u64 count_val;

    if (size < sizeof(count_val))
        return -EINVAL;

    memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
    if (copy_to_user(buf, &count_val , size) != 0)
        return -EFAULT;

	return size;
}

static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
    u64 cap_id;
    u32 clk_period_fs;
    u64 frequency_hz;

    switch (cmd) {
        case IOC_HPET_GETFREQ:
            memcpy_fromio(&cap_id, (char *)g_hpet_base + HPET_GEN_CAP_ID_OFFSET, sizeof(u64));
            clk_period_fs = cap_id >> 32;      // femtosaniye per tick
            frequency_hz = 1000000000000000ULL / clk_period_fs;
            if (copy_to_user((void *)arg, & frequency_hz, sizeof(u64)) != 0)
                return -EFAULT;     
            result = 0;
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "hpet-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    uint64_t freq;
    uint64_t start, end;
    double result;
		
	if ((fd = open("hpet-driver", O_RDONLY)) == -1)
		exit_sys("open");

        
    if (ioctl(fd, IOC_HPET_GETFREQ, &freq) == -1) 
        exit_sys("ioctl");
    
    printf("Frequency: %llu\n", freq);
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / freq;
    printf("Elapsed time: %f\n", result);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                162. Ders 11/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar karakter aygıt sürücüleri üzerinde durduk. Aygıt sürücülerin çok büyük kısmı karakter aygıt sürücüsü 
    biçiminde yazılmaktadır. Karakter aygıt sürücülerinde aygıttan (yani donanım biriminden)  bilgiler birkaç byte biçiminde 
    azar azar değil blok blok okunmakta ve aygıta bilgiler birkaç byte biçiminde değil blok blok yazılmaktadır. Örneğin seri 
    portu yönten bir aygıt sürücüsü karakter aygıt sürücüsüdür. Çünkü sei porttan bilgiler blok blok değil byte byte edilmektedir. 
    Yardımcı işlemcilere ilişkin aygıt sürücülerinin çoğu da karakter aygıt sürücüsü biçimindedir. Blok aygıt sürücülerinde 
    aygıt bilgileri blok blok alıp vermektedir. Karakter aygıtlarıyla blok aygıtları arasındaki en önemli farklılık iletilen 
    bilginin büyüklüğü ve iletilen bilginin bloklu yapıda olmasıdır. Blok aygıt sürücüleri karakter aygıt sürücülerine göre 
    oldukça seyrek karşımıza çıkmaktadır. Bir aygıt sürücü programcısı çoğu zaman karakter aygıt sürücülerinin yazımıyla uğraşır. 
    Aygıt sürücü programcısı seyrek bir biçimde blok aygıt sürücüleri ile çalışmaktadır. Aygıt sürücülerini konu alan kitaplar 
    da genellikle karakter aygıt sürücülerini ele almaktadır. 

    Biligsayar sistemlerinde karşılaşılan blok aygıtlarının önemli olanları şunlardır:

    - Hard Diskler 
    - SSD Diskler
    - USB bellekler
    - CD/DVD ROM'lar
    - Ramdisk'ler
    - Sanal diskler

    Linux'ta karakter aygıt sürücülerinin mimarisi ve alt sistemleri zaman içerisinde büyük ölçüde oturmuştur. Çekirdekler 
    arasında önemli farklılıklar yoktur. Ancak blok aygıt mimarisi ve alt sistemleri üzerinde maalesef Linux çekirdeklerinde 
    çokça değişiklikler yapılmıştır. Bu nedenle blok aygıt sürücülerini yazanlar versiyon değişikliklerine çok dikkat etmelidir. 
    Linux'un neredeyse her majör numarasında blok aygıt sürücüsüne ilişkin fonksiyonlarda ve veri yapılarında değişiklikler 
    yapılmıştır. Biz kurusumuzda 6'lı çekirdekleri göz önüne alarak konuyu açıklayacağız. Burada verdiğimiz örneklerin eski
    çekirdeklerde çalışmayabileceğini vurgulamak istiyoruz.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri (block device drivers) disk benzeri birimlerden bloklu okuma ve bu birimlere yazma yapabilmek için 
    kullanılan özel aygıt sürücülerdir. Daha önceden de belirttiğimiz gibi disk benzeri birimlerden bir hamlede okunabilecek 
    ya da yazılabilecek bilgi miktarına "sektör" denilmektedir. İşte blok aygıt sürücüleri transferleri byte byte değil blok 
    blok (sektör sektör) yapmaktadır. Örneğin bir diskten 1 byte okuma diye bir şey yoktur ya da bir diske 1 yazma diye bir 
    şey yoktur. Diskteki 1 byte değiştirilecekse önce onun bulunduğu sektör RAM'e okunur, değişiklikler RAM üzerinde yapılır. 
    Sonra o sektör yeniden diske yazılır. Tipik transfer bu adımlardan geçilerek gerçekleştirilmektedir. Sektörler bugün 
    kullandığımız sistemlerde 512 byte uzunluğundadır. 

    Bir Linux sistemini kurduğumuzda "/dev" dizininin altında disklerle işlem yapan aygıt sürücülere yönelik aygıt dosyaları
    da oluşturulmuş durumdadır. Blok aygıt sürücülerine ilişkin aygıt dosyaları "ls -l" komutunda dosya türü 'b' olarak 
    görüntülenmektedir. Örneğin:

    $ ls -l /dev
    ...
    brw-rw----  1 root disk      8,   0 Ağu  7 13:57 sda
    brw-rw----  1 root disk      8,   1 Ağu  7 13:57 sda1
    brw-rw----  1 root disk      8,   2 Ağu  7 13:57 sda2
    brw-rw----  1 root disk      8,   3 Ağu  7 13:57 sda3
    crw-rw----+ 1 root cdrom    21,   0 Ağu  7 13:57 sg0
    crw-rw----  1 root disk     21,   1 Ağu  7 13:57 sg1
    ...

    Burada "sda" aygıt dosyası diske bir bütün olarak erişmek için kullanılırken sda1, sda2, sda3 aygıt dosyaları ise diskteki 
    disk bölümlerine (partition) erişmek için kullanılmaktadır. Bu aygıt dosyalarının majör numaralarının aynı olduğuna ancak 
    minör numaralarının farklı olduğuna dikkat ediniz. Biz bir flash belleği USB soketine taktığımızda burada flash belleğe 
    erişmek için gerekli olan aygıt dosyaları otomatik biçimde oluşturulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri bloklu çalışan aygıtlarda erişimi hızlandırmak için ismine "IO çizelgelemesi (IO Scheduling)" denilen 
    bir yöntem uygulamaktadır. Çeşitli prosesler diskten sektörleri okumak istediğinde ya da sektörleri diske yazmak istediğinde 
    bunlar işletim sistemi tarafından birleştirilerek disk erişimleri azaltılmaktadır. Yani bu tür transferlerde transfer 
    talep edildiği anda değil, biraz bekletilerek (tabii kısa bir zaman) gerçekleştirilebilmektedir. Disk sistemi bilgisayar 
    sistemlerinin en yavaş alt sistemlerinden birini oluşturmaktadır. SSD diskler bile yazma bakımından RAM'e göre neredeyse 
    binlerce kat yavaştır. İşte işletim sistemleri aslında ayrık olan birtakım okuma yazma işlemlerini diskte mümkün olduğunca 
    ardışıl hale getirerek ve gereksiz okuma yazma işlemlerini elimine ederek disk erişiminden kaynaklanan zaman kayıplarını 
    minimize etmeye çalışmaktadır. Peşi sıra blokların ayrı ayrı değil de tek hamlede okunup yazılması disklerde bir zaman 
    kazancı sağlamaktadır. Hard disklerde bu kazanç önemli bir boyuttadır. SSD'lerde de hard diskler kadar önemli boyutta 
    olmasa da bir hız kazancı oluşturmaktadır. Farklı proseslerin sektör okuma istekleri aslında bazen birbirine yakın 
    bölgelerde gerçekleşir. İşte onların yeniden sıralanması gibi faaliyetler IO çizelgeleyicisinin önemli görevlerindendir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıtlarından okumalar ve blok aygıtına yazmalar bir cache sistemi aracılıyla gerçekleştirilmektedir. Bu cache sistemine 
    işletim sistemlerinde "disk cache sistemi" ya da "buffer cache sistemi" denilmektedir. Linux işletim sisteminde eskiden 
    bu cache sistemine "buffer cache" deniliyordu. Daha sonra "page cache" denilmeye başlandı. Page cache sistemi tipik olarak 
    şöyle çalılmaktadır:

    - Bir proses blok aygıtından read fonksiyonu ile okuma yapmak istediğinde işletim sistemi önce okunacak kısmın blok aygıtının 
    neresinde olduğunu hesaplamaktadır. Sonra bu bloğu blok aygırından okuyarak page cache içerisine yazmaktadır. Prosese de 
    page cache içerisinden bilgiler verilmektedir. Böylece aynı disk bloğundan başka bir okuma yapılacağı zaman o blok zaten 
    cache içerisinde olduğu için gereksiz aygıt okuması yapılmayacaktır. Ancak bu bloğa talep yoksa artık bu blok cache'ten 
    atılıp onun yerine aygıttaki başka bir blok cache'e yerleştirilebilmektedir. Page cache sisteminde LRU (Least Recently 
    Used) cache algoritması kullanılmaktadır. Cache terminolojisinde bir bilgi talep edildiğinde eğer o bilgi cache'te varsa 
    buna İngiizce "cache hit", cache'te yoksa buna da "cache miss" denilmektedir. İşletim sisteminin read fonksiyonu her zaman 
    önce page cache'e bakmaktadır. Eğer bilgi page cache'te varsa hiç bloke oluşmadan bilgi ilgili thread'e verilmektedir. 
    Eğer "cache miss" durumu oluşursa ilgili thread bloke edilip "wait kuyruklarında uykuya yatırılır" ve gerçek aygıt okuması 
    yapılır. 

    - Bir proses blok aygıtına write fonksiyonu ile yazmak yapmak istediğinde işletim sistemi eğer o blok cache'te varsa 
    yazmayı doğrudan cache'e yapmaktadır. Eğer ilgili blok cache'te yoksa bu durumda cache'e çekilip yazma cache'e yapılmaktadır. 
    Ancak cache'e yazılan bloklar elektrik kesilmesi gibi durumlarda gerçek aygıta aktarılmamış olacağından dolayı bir bilgi
    kaybı oluşabilecektir. İşte işletim sistemleri bu kayıp olasılığını azaltmak için "gecikmeli yazım (delayed write)" denilen 
    tekniği kullanmaktadır. İşletim sisteminin bir çekirdek thread'i belli periyotlarla page cache'te bozulmuş olan ("dirty" 
    olan) blokları diske yazmaktadır. Yani yazım ilk aşamada cache'e yapılmakta ancak çok da fazla bekletilmeden işletim 
    sistemi tarafından kısa bir süre sonra  aygıta aktarılmaktadır. Gecikmeli yazımın gerekçesi şunlardır:

    1) Yazma işlemi sırasında yazan thread bloke olmadan hemen geri döner. Çünkü yazma aygıta değil cache'e yapılmaktadır.
    2) İşletim sistemi yukarıda sözünü ettiğimiz IO çizelgelemesini cache üzerinde uygulamaktadır. Yani cache'te bozulmuş 
    olan blokları çizelgeleyerek daha etkin bir biçimde blok aygıtına yazabilmektedir. 
    3) Üst üste yazımlarda bu sayede gereksiz yazımlar engellenmiş olur.    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri bazı bakımlardan karakter aygıt aygıt sürücülerine benzese de "IO çizelgelemesi" ve "page cache "
    sistemi yüzünden tasarımsal farklılıklara sahiptir. Karakter aygıt sürücülerinde her read ve write işlemi için bir IO 
    çizelgelemesi ve cache'leme işlemi yapılmadan aygıt sürücünün fonksiyonları çağrılmaktadır. Çünkü karakter aygıt sürücülerinde 
    az miktarda bilgiler aktarılmakta ve disk gibi zaman alıcı işlemlerle uğraşılmamaktadır. Ancak blok aygıt sürücülerinde 
    aktarım isteği çizelgelenerek bazen gecikmelerle yerine getirilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Bir blok aygıt sürücüsü oluşturmak için ilk yapılacak işlem tıpkı karakter aygıt sürücülerinde olduğu gibi blok aygıt 
    sürücüsünün bir isim altında aygıt numarası belirtilerek register ettirilmesidir. Bu işlem register_blkdev fonksiyonuyla 
    yapılmaktadır:

    #include <linux/blkdev.h>

    int register_blkdev(unsigned int major, const char *name);

    Fonksiyonun birinci parametresi aygıtın majör numarasını belirtir. Eğer majör numara olarak 0 geçilirse fonksiyon boş bir 
    majör numarayı kendisi tahsis eder. Fonksiyonun ikinci parametresi ise "/proc/devices" dosyasında görüntülenecek olan 
    ismi belirtmektedir. Fonksiyon başarı durumunda aygıt sürücünün majör numarasına, başarısızlık durumunda negatif errno 
    değerine geri dönmektedir. Örneğin:

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot alloc block driver!...\n");
        return g_major;
    }

    register_blkdev fonksiyonunun yalnızca bir majör numara aldığına dikkat ediniz. Habuki register_chrdev_region fonksiyonunda
    register ettirilecek minör numaralar da belirtiliyordu. Blok aygıt sürücüleri için minör numara tahsisatı disk tahsis 
    edilirken (yani eski versiyonlarda alloc_disk, yeni versiyonlarda blk_alloc_disk fonksiyonunda) yapılmaktadır. 

    Modül boşaltılırken bu işlemin geri alınması için unregister_blkdev fonksiyonu kullanılmaktadır:

    #include <linux/blkdev.h>

    void unregister_blkdev(unsigned int major, const char *name);

    Fonksiyonun parametrik yapısı register_blkdev fonksiyonuyla tamamen aynıdır. Örneğin:

    unregister_blkdev(g_major, "generic-blkdev");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bizim daha önce kullandığımız "load" script'i karakter aygıt dosyası yaratıyordu. Halbuki bizim artık blok aygıt dosyası 
    yaratmamız gerekir. Bunun için "load" ve "unload" script'lerini "loadblk" ve "unloadblk" ismiyle yeniden yazacağız. (Tabii 
    aslında "unload" script'inde değiştirilecek bir şey yoktur. Ancak isimsel uyumluluk bakımından biz her iki dosyayı da 
    yeniden yeni isimlerle oluşturacağız.) Bu iki script'e de "x" haklarının verilmesi gerektiğini anımsayınız.

    $ sudo chmod +x loadblk unloadblk

    /* loadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./$module.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module b $major 0

    /* unloadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
 
    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir blok aygıt sürücüsü register_blkdev fonksiyonuyla register ettirilip unregister_blkdev fonksiyonuyla 
    unregister ettirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/blkdev.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("generic-blkdev");

static int g_major;

static int __init generic_blkdev_init(void)
{
	printk(KERN_INFO "generic-blkdev initialization...\n");

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot register block device!..\n");
        return g_major;
    }

	return 0;
}

static void __exit generic_blkdev_exit(void)
{
	unregister_blkdev(g_major, "generic-bloc-driver");
    
	printk(KERN_INFO "generic-blkdev exit...\n");
}

module_init(generic_blkdev_init);
module_exit(generic_blkdev_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

 /* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                            163. Ders 16/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri için en önemli nesne gendisk isimli nesnesidir. Blok aygıt sürücüsü çekirdekte bu nesne ile temsil 
    edilmektedir. gendisk nesnesi eski çekirdeklere alloc_disk isimli fonksiyonla (aslında bir makro olarak yazılmıştır) tahsis 
    ediliyordu. Ancak 5'li çekirdeklerle birlikte fonksiyonun ismi blk_alloc_disk biçiminde değiştirildi. Ayrıca aşağıdaki 
    fonksiyonların bir bölümünün bulunduğu <linux/genhd.h> dosyası da çekirdeğin 5.18 versiyonunda kaldırılmış buradaki 
    fonksiyonların prototipleri <linux/blkkdev.h> dosyasına taşınmıştır.

    #include <linux/genhd.h>                           /* #include <linux/blkkdev.h> */

    struct gendisk *alloc_disk(int minors);            /* eski çekirdek versiyonları bu fonksiyonu kullanıyor */
    struct gendisk *blk_alloc_disk(int minors);        /* yeni çekirdek versiyonları bu fonksiyonu kullanıyor */

    Fonksiyonlar parametre olarak aygıt sürücünün destekleyeceği minör numara sayısını almaktadır. Fonksiyonların geri dönüş 
    değerleri diski temsil eden gendisk isimli yapı türünden nesnenin adresidir. (Birden fazla minör numaranın söz konusu 
    olduğu durumda geri döndürülen adres aslında gendisk türünden bir dizinin adresidir.) Fonksiyonlar başarısızlık durumunda 
    NULL adrese geri dönmektedir. Başarısızlık durumunda bu fonksiyonları çağıran fonksiyonları -ENOMEM değeri ile geri döndürmek 
    uygun olur. Örneğin:

    static struct gendisk *g_gdisk;

    if ((g_gdisk = blk_alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    disk sözcüğü bu bağlamda aslında fiziksel bir diskten ziyade bir blok aygıtını temsil etmektedir. Blok aygıtları tipik 
    olarak disk biçiminde bulunduğu için disk terimi tercih edilmiştir.

    Son versiyonlarda Linux çekirdeğinin bu blok aygıt sürücülerine ilişkin fonksiyonlarında yine bazı değişiklikler olmuştur. 
    Örneğin 5.14 çekirdeği ile birlikte gendisk tahisatı ile kuyruk tahsisatını birlikte yapan blk_alloc_mq_disk isimli bir 
    fonksiyon eklenmiştir. Bu fonksiyon her iki tahsisatı da birlikte yaptığı için en yeni çekirdeklerde tercih edilebilir. 

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesi henüz add_disk işlemi yapılmamışsa (ya da add_disk başarısız 
    olduğunda) put_disk fonksiyonu ile serbest bırakılır. 

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesinin içinin doldurulması gerekmektedir. Bu yapının doldurulması 
    gereken önemli elemanları şunlardır:

    - Yapının major isimli elemanına aygıt sürücünün majör numarası yerleştirilmelidir. Örneğin:

    g_gdisk->major = g_major;

    - Yapının first_minor elemanına aygıt sürücünün ilk minör numarası yerleştirilmelidir (Tipik olarak 0). Örneğin:

    g_gdisk->first_minor = 0;

    - Yapının minors elemanı first_minor numaradan itibaren kaç minör numaranın kullanılacağını belirtmektedir. Biz tek bir 
    minör numara kullanacaksak buraya 1 değerini yerleştiririz:

    g_gdisk->minors = 1;

    - Yapının disk_name elemanına diske (yani blok aygıtına) ilişkin bir isim yerleştirilir. Örneğin:

    strscpy(g_disk->disk_name, "generic-blkdev", DISK_NAME_LEN);         

    - Yapının flags elemanına duruma göre bazı bayraklar girilebilmektedir. Örneğin bir ramdisk uygulaması için bu bayrak 
    GENHD_FL_NO_PART biçiminde girilebilir. Örneğin:

    g_gdisk->flags = GENHD_FL_NO_PART;

    - Yapının fops elemanına aygıt sürücü açıldığında, kapatıldığında, ioctl gibi işlemler yapıldığında çağrılacak fonksiyonların 
    bulunduğuğu block_device_operations isimli yapı türünden nesnenin adresi atanmalıdır. Yaı şöyle tanımlanmıştır:

    struct block_device_operations {
        void (*submit_bio)(struct bio *bio);
        int (*poll_bio)(struct bio *bio, struct io_comp_batch *iob, unsigned int flags);
        int (*open)(struct gendisk *disk, blk_mode_t mode);
        void (*release)(struct gendisk *disk);
        int (*ioctl)(struct block_device *bdev, blk_mode_t mode, unsigned cmd, unsigned long arg);
        int (*compat_ioctl)(struct block_device *bdev, blk_mode_t mode, unsigned cmd, unsigned long arg);
        unsigned int (*check_events) (struct gendisk *disk, unsigned int clearing);
        void (*unlock_native_capacity) (struct gendisk *);
        int (*getgeo)(struct block_device *, struct hd_geometry *);
        int (*set_read_only)(struct block_device *bdev, bool ro);
        void (*free_disk)(struct gendisk *disk);
        /* this callback is with swap_lock and sometimes page table lock held */
        void (*swap_slot_free_notify) (struct block_device *, unsigned long);
        int (*report_zones)(struct gendisk *, sector_t sector,
                unsigned int nr_zones, report_zones_cb cb, void *data);
        char *(*devnode)(struct gendisk *disk, umode_t *mode);
        /* returns the length of the identifier or a negative errno: */
        int (*get_unique_id)(struct gendisk *disk, u8 id[16],
                enum blk_unique_id id_type);
        struct module *owner;
        const struct pr_ops *pr_ops;        /*
        * Special callback for probing GPT entry at a given sector.
        * Needed by Android devices, used by GPT scanner and MMC blk
        * driver.
        */
        int (*alternative_gpt_sector)(struct gendisk *disk, sector_t *sector);
    };
        
    Bu yapı karakter aygıt sürücülerindeki file_operations yapısına benzetilebilir. Yapının üç önemli elemanı önemli elemanı 
    open ve release ve ioctl elemanlarıdır.  Burada belirtilen fonksiyonlar aygıt sürücü açıldığında, kapatıldığında ve ioctl 
    işlemi yapıldığında çağrılmaktadır. Örneğin:

    static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
    static void generic_blkdev_release(struct gendisk *disk);
    ...

    static struct block_device_operations g_blkdev_ops = {
        .open = generic_blkdev_open,
        .release = generic_blkdev_release
    };

    g_gdisk->fops = &g_blkdev_ops;

    - Eskiden gendisk yapısının queue elemanı için istek kuyruğunu (request queue) programcı yaratıyordu. Ancak blk_alloc_disk 
    fonksiyonu artık bu yaratımı da kendisi yapmaktadır. İstek kuyruğu aygıt sürücüden read/write işlemi yapıldığında çekirdeğin 
    IO çizelgeleyici alt sistemi tarafından optimize edilen işlemlerin yerleştirileceği kuyruk sistemidir. Programcı ileride 
    görüleceği üzere bu kuyruk sisteminden istekleri alarak yerine getirir. Maalesef bu kuyruğun yaratılması ve işleme sokulması 
    için gerekli çekirdek fonksiyonları çekirdeğin çeşitli versiyonlarında çok kereler değiştirilmiştir. Eskiden 4'lü çekirdeklerde 
    istek kuyruğu oluşturmak için blk_init_queue isimli bir fonksiyon kullanılıyordu. Sonra 5'li çekirdeklerle birlikte istek 
    kuyruğu işlemleri üzerinde değişiklikler yapıldı. Artık en yeni çekireklerde bu istek kuyruklarının yaratımı alloc_blk_disk 
    fonksiyonu tarafından ya da alloc_mq_blk_disk fonksiyonu tarafından yapılmaktadır. Son çekirdeklerde blk_alloc_disk 
    fonksiyonu tarafından yaratılan kuyruk nesnesinin bazı elemanlarının da programcı tarafından doldurulması gerekmektedir. 
    Bu işlemler çekirdeğe eklenmiş olan blk_queue_xxx fonksiyonları tarafından yapılmaktadır. Tipik olarak programcı 
    kuyruğun bazı özelliklerini aşağıdaki fonksiyonlarla belirlemelidir. 

    blk_queue_logical_block_size(g_disk->queue, 512);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);    /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);            /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);      /* Max segment boyutu */

    - gendisk yapısının içerisine diskin (blok aygıt sürücüsünün temsil ettiği medyanın) kapasitesi set edilmelidir. Bu işlem 
    set_capacity fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/genhd.h>

    void set_capacity(struct gendisk *disk, sector_t size);

    Fonksiyonun birinci parametresi gendisk yapısının adresini, ikinci parametresi aygıtın sektör uzunluğunu almaktadır. 
    (Aslında 
    bu fonksiyon gendisk yapısının ilgili elemanını set etmektedir.) Fonksiyonun ikinci parametresi aygıt sürücünün temsil 
    ettiği aygıtın sektör uzunluğunu belirtmektedir. Bir sektör 512 byte'tır. Örneğin:

    set_capacity(g_gdisk, 1000);

     - Nihayet gendisk yapısının private_data elemanına programcı kendi belirlediği bir yapı nesnesinin adresini yerleştirebilir. 
    Örneğin daha önce karakter aygıt sürücülerinde yaptığımız gibi bu private_data elemanına gendisk nesnesinin içinde bulunduğu 
    yapı nesnesinin adresini yerleştirebiliriz.

    Aşağıdaki örnekte yukarıda anlatılan kısma kadar olan işlemleri içeren bir blok aygıt sürücü örneği verilmiştir. Örneğin:

    struct BLOCKDEV {
        spinlock_t sl;
        struct gendisk *gdisk;
        struct request_queue *rq;
        size_t capacity;
    };
    static struct BLOCKDEV g_bdev;
    ...
    g_gdisk->private_data = &g_bdev;

    Tabii buradaki örnekte g_bdev zaten global bir nesne olduğu için ona private_data yoluyla erişmeye gerek kalmamaktadır. 
    Ancak aygıt sürücümüz birden fazla minör numarayı destekliyorsa her aygıtın ayrı bir BLOCKDEV yapısı olacağı için ilgili 
    aygıta bu private_data elemanı yoluyla erişebiliriz.

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesi add_disk fonksiyonu ile sisteme eklenmelidir:

    #include <linux/genhd.h>

    void add_disk(struct gendisk *disk);        /* eski çekirdek versiyonlarındaki prototip */

    Bu fonksiyonun geri dönüş değeri 5'li çekirdeklerle birlikte int yapılmıştır:

    int add_disk(struct gendisk *disk);            /* yeni çekirdek versiyonlarındaki prototip */

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. Örneğin:

    if ((result = add_disk(g_gdisk)) != 0) {
        ...
        return result;
    }

    add_disk fonksiyonuyla tahsis edilen ve sisteme yerleştirilen gendisk nesnesi del_gendisk fonksiyonuyla serbest bırakılmaktadır.
    Bu fonksiyon aynı zamanda blk_alloc_disk fonksiyonu ile tahsis edilen alanı da serbest bırakır. 

    #include <linux/genhd.h>

    void del_gendisk(struct gendisk *gdisk);

    Örneğin:

    if ((g_gdisk = alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    if ((result = add_disk(g_bdev->gdisk)) != 0) {
        ...
        return result;
    }
    ...
    del_gendisk(g_gdisk);

    Aşağıda şimdiye kadar görmüş olduğumuz fonksiyonların kullanıldığı bir blok aygıt sürücüsü iskeleti verilmiştir. Ancak 
    aşağıdkai kodda henüz istek kuyruğuna yönelik bir işlem yapılmamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/blkdev.h>

#define TOTAL_CAPACITY      1000

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("generic-blkdev");

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
static void generic_blkdev_release(struct gendisk *disk);

static int g_major;
static struct gendisk *g_disk;
static struct block_device_operations g_blkdev_ops = {
    .owner = THIS_MODULE,
    .open = generic_blkdev_open,
    .release = generic_blkdev_release
};

static int __init generic_blkdev_init(void)
{
	printk(KERN_INFO "generic-blkdev initialization...\n");

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot register block device!..\n");
        return g_major;
    }

    if ((g_disk = blk_alloc_disk(1)) == NULL) {
        printk(KERN_INFO "cannot alloc gendisk!..\n");
        unregister_blkdev(g_major, "generic-blkdev");
        return -ENOMEM;
    }

    g_disk->major = g_major;
    g_disk->first_minor = 0;
    g_disk->minors = 1;
    strscpy(g_disk->disk_name, "generic-blkdev", DISK_NAME_LEN);   
    g_disk->flags = GENHD_FL_NO_PART;
    g_disk->fops = &g_blkdev_ops;

    blk_queue_logical_block_size(g_disk->queue, 512);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);    /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);            /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);      /* Max segment boyutu */
    set_capacity(g_disk, TOTAL_CAPACITY);

    if (add_disk(g_disk) != 0) {
        put_disk(g_disk);
        unregister_blkdev(g_major, "generic-blkdev");
    }

	return 0;
}

static void __exit generic_blkdev_exit(void)
{
    del_gendisk(g_disk);
	unregister_blkdev(g_major, "generic-blkdev");
    
	printk(KERN_INFO "generic-blkdev exit...\n");
}

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode)
{
    printk(KERN_INFO "generic-blkdev opened...\n");
    return 0;
}

static void generic_blkdev_release(struct gendisk *disk)
{
    printk(KERN_INFO "generic-blkdev released...\n");
}

module_init(generic_blkdev_init);
module_exit(generic_blkdev_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------

/*--------------------------------------------------------------------------------------------------------------------------
                                            164. Ders 18/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerinde yukarıda belirtilen işlemlerden sonra artık transfer işleminin yapılması için bulundurulan fonksiyonun
    yazılması aşamasına geldik. Kullanıcı modundaki kodlar tarafından blok transferine yönelik bir istek oluştuğunda (örneğin 
    blok aygıt sürücüsünden bir sektör okunmak istediğinde) çekirdeğin IO çizelgeleyicisi bunları çizelgeleyerek uygun bir 
    zamanda transfer edilebilmesi için bizim belirttiğimiz bir fonksiyonu çağırmaktadır. Biz de bu fonksiyon çağrıldığında 
    fonksiyonun içerisinde aktarımı yapmalıyız. Bu çağırma (callback) mekanizması maalesef Linux çekirdeğinde versiyondan 
    versiyona çok fazla değişikliklere uğratılmıştır. Biz burada 6.8 ve sonrasındaki çekirdekleri dikkate alarak açıklamalar 
    yapacağız. 

    Anımsanacağı gibi kullanıcı modundan blok aygıtı için read/write işlemi yapıldığında aşağıdaki gibi bir süreç oluşmaktadır:

    read/write (kullanıcı modu) ---> sys_read/sys_write (çekirdek modu) ---> Okunacak yer "page cache içerisinde var mı"
    ---> "okunacak yer page cache'te yoksa blok aygıt sürücüsünün fonksiyonunu çağır"
    
    Eğer okunacak ya da yazılacak sektör çekirdeğin "page cache'inde yoksa" çekirdek blok aygıt sürücüsünün block_device_operations
    yapısındaki submit_bio elemanında belirtilen fonksiyonu çağırmaktadır. Bu fonksiyonun parametrik yapısı şöyle olmak 
    zorundadır:

    void submit_bio_proc(struct bio *bio);

    Callback fonksiyonun geri dönüş değerinin void olduğuna, parametresinin ise struct bio türünden bir gösterici olduğuna 
    dikkat ediniz. Çekirdek bu fonksiyonu çağırırken blok aygıtından aktarılacak sektörleri izleyen paragraflarda açıklayacağımız
    biçimde bu göstericinin gösterdiği yerdeki bio yapısına yerleştirmektedir. 
    
    Örneğin bir blok aygıt sürücüsünü kullanıcı modunda open fonksiyonuyla açıp içerisinden 10 byte'ı read fonksiyonuyla okumak 
    isteyelim. Eğer bu aygıt sürücü karakter aygıt sürücüsü olsaydı çekirdek doğrudan aygıt sürücünün read fonksiyonunu çağıracaktı. 
    Aygıt sürücü de istenen 10 byte'ı kullanıcı modundaki adrese aktaracaktı. Halbuki blok aygıt sürücüsü durumunda çekirdek 
    önce bu 10 byte'ın bulunduğu sektörün page cache içerisinde olup olmadığına bakacaktır. Eğer talep edilen yer page cache'te
    yoksa çekirdek blok aygıt sürücüsünün submit_bio fonksiyonunu çağırıp transferin aygıt sürücü tarafından yapılmasını 
    isteyecektir. Anımsanacağı gibi blok aygıtlarından transfer edilecek en küçük birim bir sektördür. Dolayısıyla kullanıcı 
    modundaki program blok aygıtından 10 byte okumak istese bile aslında aygıt sürücü en az 1 sektörlük bilgiyi işletim 
    sisteminin page cache'ine aktaracaktır.     
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek blok aygıt sürücüsünün submit_bio fonksiyonunu çağırdığında bio yapısının içerisinde birden fazla aktarım isteği 
    bulunabilmektedir. bio yapısının içerisinde birtakım gerekli bilgilerin yanı sıra bio_vec isimli yapı türünden bir dizi de 
    vardır. İşte asıl aktarım istekleri bu bio_vec yapısı içerisindedir. O halde blok aygıt sürücüsünü yazan sistem programcısı 
    bu bio_vec dizisini dolaşarak gereken aktarımları yapmalıdır. bio_vec içerisinde aktarılacak alanlara "segment" de denilmektedir. 
    bio_vec yapısı şöyle bildirilmiştir:

    struct bio_vec {
        struct page *bv_page;           /* hangi fiziksel sayfa */
        unsigned int bv_len;            /* bu segmentin uzunluğu (bayt cinsinden) */
        unsigned int bv_offset;         /* sayfa içindeki başlangıç offset’i */
    };

    Yapının bv_page elemanı page cache içerisindeki transfer edilecek sayfaya ilişkin sayfa bilgilerini belirtmektedir. Yapının 
    bv_len elemanı transfer edilecek bilginin uzunluğunu belirtir. Tabii bu uzunluk her zaman sektör katları kadardır. bv_offset 
    elemanı page cache içerisindeki 4K'lık cache page'lerinin içerisindeki aktarım offset'ini belirtmektedir. Çekirdek 4K'lık 
    bir cache sayfasının aygıt sürücüden belli bir kısmını doldurmasını isteyebilir. Burada önemli bir nokta şudur: bio_vec 
    yapısının bv_page elemanından biz 4K'lık sayfanın fiziksel adresini elde etmekteyiz. Bu adresin sanal adrese dönüştürülmesi 
    gerekir. Bunun nasıl yapılacağını izleyen paragraflarda açıklayacağız. 

    Biz bio yapısı içerisindeki bio_vec dizisini dolaşarak aktarım isteklerini ve aktarımın fiziksel RAM'de hangi uzunlukta ve 
    nereye yapılması gerektiğini elde ettik. Peki blok aygıtının neresinin aktarılacağı bilgisi nerededir? İşte bio_vec 
    yapıları her zaman blok aygıtında ardışıl sektörleri belirtmektedir. Örneğin bio yapısı içerisindeki bio_vec dizisi üç 
    elemanlı olsun. Bu üç elemandaki segment uzunlukları şöyle olsun:

    [bio_vec (512), bio_vec(1024), bio_vec(512)]

    Buradaki 512, 1024 ve 512 byte'lık bloklar blok aygıtında ardışıl olmak zorundadır. O halde bizim tek bilmemiz gereken şey 
    blok aygıtındaki başlangıç offset'idir. Bu sistemde her bio_vec için blok aygıtında bir offset belirtilmediğine toplamda 
    blok aygıtı için tek bir offset belirtildiğine dikkat ediniz. Blok aygıtındaki bşalngıç offset değerine bio yapısı 
    yoluyla (loff_t)bio->bi_iter.bi_sector * SECTOR_SIZE ifadesi ile erişilmektedir. 

    bio yapısı içerisindeki bio_vec dizisini dolaşmanın iki yolu vardır: Birincisi doğrudan dizi indekslemesi yapmaktır.
    bi_vec dizisinin adresi nio yapısının bi_io_vec elemanındadır Bu dizideki eleman sayısı da bio yapısının bi_vcnt elemanında 
    bulunmaktadır. O halde gezinti şöyle yapılabilir:

    struct bio_vec *bvec;
    int i;
    ...

    for (i = 0; i < bio->bi_vcnt; ++i) {
        bvec = &bio->bi_io_vec[i];
        ...
    }

    bio_vec dizisi alternatif olarak iteratör yoluylabir makro döngüsüyle de dolaşılabilmektedir. Aslında bazı senaryolarda 
    bu makro döngüsü daha uygun işlev görmektedir. Yani bu makro döngüsünü tercih edebilirsiniz:

    struct bio_vec bvec;
    struct bvec_iter iter;
    ...

    bio_for_each_segment(bvec, bio, iter) {
        ...
    }

    Makroya biz bio_vec türünden bir değişkeni, bio türünden göstericiyi ve iteratör görevini yapan bvec_iter türünden bir 
    değişkeni veririz. Bu makro döngüsü her yinelendiğinde bvec göstericisinin içerisine bio_vec dizisinin sıradaki elemanı
    yerleştirilmektedir.

    submit_bio fonksiyonumuz çekirdek tarafından hem okuma hem de yazma istekleri için çağrılmaktadır. Bu durumda bizim aygıt 
    sürücü içerisinde bu fonksiyonun hangi amaçla çağrıldığını belirlememiz gerekir. Bu belirleme işlemi bio_op fonksiyonuyla 
    yapılmaktadır. Bu makroya bio yapısının adresi argüman olarak verilir. Bu fonksiyon bio yapısının içerisindeki uygun alandan 
    submit_bio fonksiyonunun neden çağrıldığı bilgisini elde edip geri dönüş değeri olarak vermektedir. Mevcut çekirdeklerde 
    bu fonksiyon şöyle yazılmıştır:

    static inline enum req_op bio_op(const struct bio *bio)
    {
        return bio->bi_opf & REQ_OP_MASK;
    }

    Tabii bizim bu fonksiyonun bu bilgiyi nasıl elde ettiğini bilmemize gerek yoktur. Bu fonksiyonun geri dönüş değeri bazı 
    bayraklardan oluşmaktadır. Blok aygıt sürücüsünü yazanlar bu bayrakları ele alıp işleyebilmektedir. Buradaki her bayrağın
    blok aygıtında işlenmesine aslında gerek yoktur. Ancak tipik olarak üç bayrağın submit_bio fonksiyonu içerisinde işlenmesi 
    gerekir:
    
    REQ_OP_READ: Blok aygıtından okuma talep edilmektedir.
    REQ_OP_WRITE: Blok aygıtına yazma talep edilmektedir.
    REQ_OP_DISCARD: Blok aygıtının ilgili yerlerinin 0'lanması talep ediliyor.

    O halde bu işlem aşağıdaki gibi bir switch deyimi ile ele alınabilir:

    switch (bio_op(bio)) {
        case REQ_OP_READ:
            ...
        case REQ_OP_WRITE:
            ...
        case REQ_OP_DISCARD:
            ...
    }

    Diğer bayrakların işlenmemesi genel olarak bir sorun oluşturmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri için en tipik örnek ramdisk aygıt sürücüleridir. Ramdisk aygıt sürücüleri çekirdeğin alanı içerisindeki 
    bir bölgeyi sanki bir diskmiş gibi kullanmaktadır. Biz kurusumuzun başında zaten Linux sistemlerinde hazır bir biçimde 
    bulunan ramdisk dosyas sistemini ve blok aygıt sürücülerini kullanmıştık. 
        
    Ramdisk aygıt sürücümüzde bizim işin başında (yani aygıt sürücümüzün init fonksiyonu içerisinde ramdisk için dinamik bellek 
    tahsisatı yapmamız gerekir. Bu tahsisatı daha önce görmüş olduğumuz kmalloc fonksiyonu ile yapabiliriz. Ancak kmalloc 
    fonksiyonu ardışıl fiziksel bellek tahsis etmektedir. Ancak bu tür uygulamalarda eğer büyük miktarda tahsisatlar yapılacaksa 
    fiziksel ardışıllığa gerek yoktur. Fiziksel bellekte ardışıl olmayacak biçimde (ancak sanal adres alanı içerisinde ardışıllık 
    korunmaktadır) tahsisat yapan vmalloc ve zvalloc fonksiyonları da bulunmaktadır. Her iki fonksiyon da parametre olarak 
    tahsis edilecek byte miktarını almaktadır. zvalloc aynı zamanda tahsis edilen alanı da sıfırlamaktadır. Örneğin:

    ...
    if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
        printk(KERN_INFO "cannot allocate memory!..\n");
        goto EXIT3;
    }
    ...

    vzalloc ile tahsis edilen alan vfree fonksiyonu ile serbest bırakılabilir. Örneğin:

    vfree(g_diskmem);

    Ramdisk aygıt sürücümüzün init fonksiyonu şöyle olabilir:

    static int __init generic_blkdev_init(void)
    {
        printk(KERN_INFO "ramdisk-blkdev initialization with capacity = %d\n", capacity);

        if ((g_major = register_blkdev(0, "ramdisk-blkdev")) < 0) {
            printk(KERN_INFO "cannot register block device!..\n");
            return g_major;
        }

        if ((g_disk = blk_alloc_disk(1)) == NULL) {
            printk(KERN_INFO "cannot alloc gendisk!..\n");
            goto EXIT1;
        }

        g_disk->major = g_major;
        g_disk->first_minor = 0;
        g_disk->minors = 1;
        strscpy(g_disk->disk_name, "ramdisk-blkdev", DISK_NAME_LEN);   
        g_disk->flags = GENHD_FL_NO_PART;
        g_disk->fops = &g_blkdev_ops;

        blk_queue_logical_block_size(g_disk->queue, SECTOR_SIZE);       /* Mantıksal blok boyutu */
        blk_queue_physical_block_size(g_disk->queue, 4096);             /* Fiziksel blok boyutu */
        blk_queue_max_segments(g_disk->queue, 128);                     /* Max segment sayısı */
        blk_queue_max_segment_size(g_disk->queue, 65536);               /* Max segment boyutu */
        set_capacity(g_disk, capacity);

        if (add_disk(g_disk) != 0) {
            printk(KERN_INFO "cannot add disk!..\n");
            goto EXIT2;
        }

        if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
            printk(KERN_INFO "cannot allocate memory!..\n");
            goto EXIT3;
        }

        return 0;
    EXIT3:
        del_gendisk(g_disk);
    EXIT2:
        put_disk(g_disk);
    EXIT1:
        unregister_blkdev(g_major, "ramdisk-blkdev");

        return -ENOMEM;
    }

    Burada blok aygıt sürücüleri için daha önce açıkladığımız tipik işlemler yapılmıştır. Bu işlemler aygıt sürücünün exit 
    fonksiyonunda geri alınmalıdır:

    static void __exit generic_blkdev_exit(void)
    {
        vfree(g_diskmem);
        del_gendisk(g_disk);
        unregister_blkdev(g_major, "ramdisk-blkdev");
        
        printk(KERN_INFO "ramdisk-blkdev exit...\n");
    }

    Tabii aygıt sürücümüzün en önemli fonksiyonu submit_bio fonksiyonudur. sumit_bio fonksiyonunda bizim indeksleme yoluyla
    ya da iteratör yoluyla bio yapısı içerisindeki bio_vec elemanlarını alıp işleme sokmamız gerekir:

    static void submit_bio_proc(struct bio *bio)
    {
        struct bio_vec bvec;
        struct bvec_iter iter;
        sector_t sector;
        size_t offset;
        unsigned int len;
        
        sector = bio->bi_iter.bi_sector;
        
        printk(KERN_INFO "submit_bio_proc called\n");

        bio_for_each_segment(bvec, bio, iter) {
            len = bvec.bv_len;
            offset = (size_t)sector * SECTOR_SIZE;
            ...
        }
        ...
    }

    Burada döngü makrosuna dikkat ediniz:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;
        ...
    }

    Buradaki len çekirdeğin transfer edilmesini istediği uzunluktur. Bu zuunluğun aslında 512'nin (yani sektörün) katları 
    olduğunu belirtmiştirk. offset ise transfer edilecek alanın tam olarak blok aygıtının (örneğimizde ramdisk) neresinden 
    başladığını belirtmektedir. bio_vec içerisindeki segment'lerin sektörleri ardışıl olduğu için biz her yienelmede bu sector 
    değerini artırmalıyız:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;


        ...
        sector += len / SECTOR_SIZE;
    }

    Kullanıcı modundaki program lseek ile dosya göstericisini bizim blok aygıtımızının kapasitesinin ötesine konumlandırıp 
    read/write işlemi yapmış olabilir. Çekirdek burada aygıt kapasitesin kendisi kontrol etmemektedir. Çünkü blok aygıtları
    bu tür durumlarda bazı özel işlemler uygulayabilmektedir. Programcının buradaki offset değerinin kendi blok aygıtının 
    sınırları dışında olup olmadığını kontrol etmesi gerekir. Bu kontrol şöyle yapılabilir:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                    offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }
        ramdisk_addr = g_diskmem + offset;
        ...
        sector += len / SECTOR_SIZE;
    }

    Burada eğer IO isteği blok aygıtımızın sınırları dışına çıkmışsa biz submit IO fonksiyonunu sonlandırdırdık. bio_vec 
    vektörlerinin ardışıl sektörlere ilişkin segment'ler içerdiğini anımsayınız. Bir kere kapasi,te dışına çıkılmışsa döngünün
    diğer bio_vec elemanları da kapasite dışına çıkmış olacaktır. Burada önemli bir nokta fonksiyon başarısız olduğunda 
    bio_io_error(bio) fonksiyonun çağrılması zorunluluğudur. Çünkü submit_bio fonksiyonunun geri dönüş değeri void biçimdedir. 
    Başarısızlık bu fonksiyonla çekirdeğe bildirilmektedir. Bu fonksiyonun prototipi şöyledir:

    void bio_io_error(struct bio *bio);

    Fonksiyon bio yapısının adresini almaktadır. bio yapısının bir elemanına başarısılık bilgisi yerleştirilmektedir. Biz 
    bu aşamada blok aygıtının hangi offset'inden ne kadar byte transfer yapılacağını biliyor durumdayız. Ancak henüz transfer 
    ediecek adres üzerinde (transfer daha önceden de belirtitğimiz gibi "page cache" içerisinde bir yere yapılmaktadır) bir 
    işlem uygulamadık. Şimdi o kısmı halledelim. kmap_local_page isimli çekirdek fonksiyonu bizden bir page yapıs nesnesinin 
    adresini alır, bu page yapısının içerisindeki fiziksel adresi elde eder, sonra o fiziksel adrese erişmek için sayfa 
    tablosunda düzenleme yaparak bize sanal adresi verir. O halde biz bio_vec yapısı içeisindeki fiziksel adrese erişmek için 
    şu üzenlemeyi yapabiliriz:

    cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

    Artık elimizde ramdiskimizdeki transfer adresi ve çekirdeğin page cache sisteminde transfer adresi vardır. Şimdi artık sıra 
    gerçek transfer işlemine gelmiştir. Bizim transferin yönüne bakıp bu işlemi yapmamız gerekir:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                   offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }

        ramdisk_addr = g_diskmem + offset;
        cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

        switch (bio_op(bio)) {
            case REQ_OP_READ:
                memcpy(cache_addr, ramdisk_addr, len);
                break;
            case REQ_OP_WRITE:
                memcpy(ramdisk_addr, cache_addr, len);
                break;
            case REQ_OP_DISCARD:
                memset(ramdisk_addr, 0, len);
                break;
            default:
                break;  
        }
        kunmap_local(cache_addr);

        sector += len / SECTOR_SIZE;
    }

    Tabii transfer işleminden sonra kmap_local_page fonksiyonuyla değiştirilen safta tablosunun eski haline getirilmesi gerekir. 
    Bu işlem kunmap_local fonksiyonuyla yapılmaktadır. Aslında kunmap_local bir makro olarak yazılmıştır. Bu makrı sanal adresi 
    alıp ters işlemi yapmaktadır. 

    Örnel ramdisk aygıt sürücümüzü basit bir programla kullanabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <fcntl.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        int fd;
        unsigned char buf[10];
            
        if ((fd = open("ramdisk-blkdev", O_RDWR)) == -1)
            exit_sys("open");

        if (read(fd, buf, 10) == -1)
            exit_sys("read");
        
        for (int i = 0; i < 10; ++i)
            printf("%02X ", buf[i]);
        printf("\n");

        lseek(fd, 0, 0);

        if (write(fd, "abcdefghij", 10) == -1)
            exit_sys("write");
        

        close(fd);

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Aşağıda aygıt sürücünün tüm kodları verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* ramdisk-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/blkdev.h>
#include <linux/vmalloc.h>

#define DEF_TOTAL_CAPACITY      1000

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("generic-blkdev");

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
static void generic_blkdev_release(struct gendisk *disk);
static void submit_bio_proc(struct bio *bio);

static int g_major;
static struct gendisk *g_disk;
static struct block_device_operations g_blkdev_ops = {
    .owner = THIS_MODULE,
    .open = generic_blkdev_open,
    .release = generic_blkdev_release,
    .submit_bio = submit_bio_proc
};

static int capacity = DEF_TOTAL_CAPACITY;
static u8 *g_diskmem;

module_param(capacity, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init generic_blkdev_init(void)
{
	printk(KERN_INFO "ramdisk-blkdev initialization with capacity = %d\n", capacity);

    if ((g_major = register_blkdev(0, "ramdisk-blkdev")) < 0) {
        printk(KERN_INFO "cannot register block device!..\n");
        return g_major;
    }

    if ((g_disk = blk_alloc_disk(1)) == NULL) {
        printk(KERN_INFO "cannot alloc gendisk!..\n");
        goto EXIT1;
    }

    g_disk->major = g_major;
    g_disk->first_minor = 0;
    g_disk->minors = 1;
    strscpy(g_disk->disk_name, "ramdisk-blkdev", DISK_NAME_LEN);   
    g_disk->flags = GENHD_FL_NO_PART;
    g_disk->fops = &g_blkdev_ops;

    blk_queue_logical_block_size(g_disk->queue, SECTOR_SIZE);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);             /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);                     /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);               /* Max segment boyutu */
    set_capacity(g_disk, capacity);

    if (add_disk(g_disk) != 0) {
        printk(KERN_INFO "cannot add disk!..\n");
        goto EXIT2;
    }

    if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
        printk(KERN_INFO "cannot allocate memory!..\n");
        goto EXIT3;
    }

    return 0;
EXIT3:
    del_gendisk(g_disk);
EXIT2:
    put_disk(g_disk);
EXIT1:
    unregister_blkdev(g_major, "ramdisk-blkdev");

	return -ENOMEM;
}

static void __exit generic_blkdev_exit(void)
{
    vfree(g_diskmem);
    del_gendisk(g_disk);
	unregister_blkdev(g_major, "ramdisk-blkdev");
    
	printk(KERN_INFO "ramdisk-blkdev exit...\n");
}

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode)
{
    printk(KERN_INFO "ramdisk-blkdev opened...\n");

    return 0;
}

static void generic_blkdev_release(struct gendisk *disk)
{
    printk(KERN_INFO "ramdisk-blkdev released...\n");
}

static void submit_bio_proc(struct bio *bio)
{
    struct bio_vec bvec;
    struct bvec_iter iter;
    sector_t sector;
    size_t offset;
    unsigned int len;
    void *ramdisk_addr, *cache_addr;
    
    sector = bio->bi_iter.bi_sector;
    
    printk(KERN_INFO "submit_bio_proc called\n");

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                   offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }

        ramdisk_addr = g_diskmem + offset;
        cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

        switch (bio_op(bio)) {
            case REQ_OP_READ:
                printk(KERN_INFO "submit_bio_proc read called\n");
                memcpy(cache_addr, ramdisk_addr, len);
                break;
            case REQ_OP_WRITE:
                memcpy(ramdisk_addr, cache_addr, len);
                break;
            case REQ_OP_DISCARD:
                memset(ramdisk_addr, 0, len);
                break;
            default:
                break;  
        }
        sector += len / SECTOR_SIZE;

    }
    bio_endio(bio);
}

module_init(generic_blkdev_init);
module_exit(generic_blkdev_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* blkdev.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
	unsigned char buf[10];
		
	if ((fd = open("ramdisk-blkdev", O_RDWR)) == -1)
		exit_sys("open");

	if (read(fd, buf, 10) == -1)
		exit_sys("read");
	
	for (int i = 0; i < 10; ++i)
		printf("%02X ", buf[i]);
	printf("\n");

	lseek(fd, 0, 0);

    if (write(fd, "abcdefghij", 10) == -1)
		exit_sys("write");
	

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte oluşturduğumuz ramdisk blok aygıt sürücüsü bir dosya sistemi ile formatlanarak sanki bir disk bölümüymüş 
    gibi de kullanılabilir. Zaten artık tüm işlemler rad/write gibi dosya fonksiyonlarıyla yapılmaktadır. Ramdisk aygıt sürücümüzü
    mkfs.ext4 programıyla "ext-4" ile aşağıdaki gibi formatlayabiliriz: 

    $ sudo mkfs.ext4 ramdisk-blkdev

    Formatlama işleminden sonra artık sıra blok aygıt sürücümüzün mount edilmesine gelmiştir. Anımsanacağı gibi mount işlemi 
    bir blok aygıt sürücüsü içerisindeki dosya sisteminin dizin ağacının belli bir dizinine monte edilmesi anlamına gelmektedir. 
    Dolayısıyla mount komutunda kullanıcı blok aygıt sürücüsünü ve mount edilecek dizini belirtir. Örneğin:

    $ mkdir ramdisk-drive
    $ sudo mount ramdisk-blkdev ramdisk-drive

    Burada mount noktası (mount point) ramdisk-drive dizinidir. Artık bu dizinin içerisine geçip dosya işlemleri yapabiliriz. 
    Tüm bu işlemler yapılırken aslında arka planda ramdisk aygıt sürücümüzün submit_bio fonksiyonu çağrılacaktır. 
    
    İşlemleri geri almak için önce umount işlemi yapılmalıdır:

    $ sudo umount ramdisk-drive

    Ramdisk aygıt sürücüsü kullanım bittikten sonra çekirdek alanından çıkarılabilir:

    $ sudo ./unloadblk ramdisk-blkdev

    Tabii ramdisk aygıt sürücümüzü unmount ettikten sonra artık onun içeriğine erişemeyiz. Yani yaptığımız her şey kaybolur. 
    Biz aygıt sürücümüzü yeniden yüklesek artık yeniden içi sıfırlarla dolu bir ramdisk oluşturulacaktır. Tabii aygıt sürücümüzü 
    unmount etmeden önce onun içerisindeki bilgileri "dd" programıyla bir dosyada saklayabiliriz:

    $ sudo dd if=ramdisk-blkdev of=ramdisk-drive.dat

    Aygıt sürücümüzü yeniden load ettikten sonra ters işlemi yaparak onun içeriğini oluşturabiliriz:

    dd if=ramdisk-drive.dat of=ramdisk-blkdev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                165. Ders 20/09/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde dosya sistemlerini belli bir derinlikte inceleyeceğiz. Dosya sistemlerini ele almadan önce bilgisayar
    sistemlerindeki disk sistemleri hakkında bazı temel bilgilerin edinilmesi gerekmektedir. Eskiden diskler yerine teyp bantları
    kullanılıyordu. Teyp bantları sıralı erişim sağlıyordu. Sonra manyetik diskler kullanılmaya başlandı. Kişisel bilgisayarlardaki
    manyetik disklere "hard disk" de deniyordu. Bugünlerde artık hard diskler de teknoloji dışı kalmaya başlamıştır. Bugün disk 
    sistemleri için artık flash bellekler (EEPROM bellekler) kullanılmaktadır. Yani SSD (Solid State Disk) diye isimlendirilen 
    bu disk sistemlerinin artık mekanik bir parçası yoktur. Bunlar tamamen yarı iletken teknolojisiyle üretilmiş entegre 
    devrelerdir. Disk sisteminin türü ne olursa olsun bu disk sistemini yöneten ondan sorumlu bir denetleyici birim bulunmaktadır. 
    Buna "disk denetleyicisi (disk controller)" denilmektedir. Kernel mode aygıt sürücüler bu disk denetleyicisini programlayarak
    transferleri gerçekleştirmektedir. Bugünkü disk sistemlerini şekilsel olarak aşağıdaki gibi düşünebiliriz:

    +-------------+       +------------------+       +--------------+       +-----------+
    | Disk Birimi | <---> | Disk Denetleyici | <---> | Aygıt Sürücü | <---> | User Mode |
    +-------------+       +------------------+       +--------------+       +-----------+
                                                            |
                                                            |
                                                     +------------+
                                                     | Disk Cache |
                                                     +------------+

    Örneğin biz user mode'da bir diskten bir sektör okumak istediğimizde bu işlemi yapan blok aygıt sürücüsünden istekte 
    bulunuruz. Blok aygıt sürücüleri disk denetleyicilerini programlar, disk denetleyicileri disk birimine erişir ve transfer
    gerçekleşir. Disk transferleri CPU aracılığıyla değil, "DMA (Direct Memory Access)" denilen özel denetleyicilerle sağlanmaktadır. 
    Yani aygıt sürücü hem disk denetleyicisini hem de DMA'yı programlar ve transfer yapılana kadar bekler. Bu sırada işletim sistemi 
    zaman alacak bu işlemi meşgul bir döngüde beklemez. O anda istekte bulunan thread'i bekleme kuyruğuna yerleştirerek sıradaki
    thread'i çizelgeler.

    İşletim sistemlerinde diskten transfer işlemi yapan blok aygıt sürücüleri ismine "disk cache" ya da "buffer cache" ya da
    "page cache" denilen bir cache sistemi kullanmaktadır. Tabii cache sistemi aslında çekirdek tarafından organize edilmiştir. 
    Blok aygıt sürücüsünden bir sektörlük bilgi okunmak istediğinde aygıt sürücü önce bu cache sistemine bakar. Eğer istenen 
    sektör bu cache sisteminde varsa hiç bekleme yapmadan oradan alıp talep eden thread'e verir. Eğer sektör cache'te yoksa
    blok aygıt sürücüsü disk denetleyicisini ve DMA denetleyicisini programlayarak sektörü önce cache'e transfer eder. Oradan
    talep eden thread'e verir. Bu amaçla kullanılan cache'lerde cache algoritması (cache replacement algorithm) genel olarak 
    LRU (Least Recently Used) algoritmasıdır. Yani son zamanlarda erişilen yerler mümkün olduğunca cache'te tutulmaktadır. İşletim 
    sistemlerinin dosya sistemleri arka planda bu blok aygıt sürücülerini kullanmaktadır. Dolayısıyla tüm dosya işlemleri aslında 
    bu cache sistemi ile gerçekleşmektedir. Yani örneğin bugünkü modern işletim sistemlerinde ne zaman bir dosya işlemi yapılsa o 
    dosyanın okunan ya da yazılan kısmı disk cache içerisine çekilmektedir. Aynı dosya üzerinde bir işlem yapıldığında zaten o 
    dosyanın diskteki blokları cache'te olduğu için gerçek anlamda bir disk işlemi yapılmayacaktır.

    Peki aygıt sürücü bir sektörü yazmak isterse ne olmaktadır? İşte yazma işlemleri de doğrudan değil cache yoluyla 
    yapılmaktadır. Yani sektör önce disk cache'e yazılır. Sonra çizelgelenir ve işletim sisteminin bir kernel thread'i 
    yoluyla belli periyotlarda diske transfer edilir. User mode'dan çeşitli thread'lerin diskten okumalar yaptığını düşünelim.
    Önce bu talepler işletim sistemi tarafından kuyruklanır, çizelgelenir sonra etkin bir biçimde transfer gerçekleştirilir. 
    İşletim sistemlerinin bu kısmına "IO çizelgeleyicisi (IO scheduler)" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün artık SSD (yani elektronik devre biçiminde) diskler yaygın olarak kullanılıyorsa da bir dönem öncesine kadar 
    manyetik tabanlı "hard diskler" yoğun kullanılıyordu. Burada bu hard disklerin genel yapısı üzerinde bazı açıklamalar da
    yapmak istiyoruz.

    Hard disklerde bir eksene monte edilmiş birden fazla yüzey vardır. Bu yüzeylere "platter" denilmektedir. Bir platter'da 
    iki yüz bulunur. Her yüz bir disk kafası ile okunmaktadır. Örneğin bir hard diskte 4 platter varsa toplam 8 tane yüz
    ve 8 tane kafa bulunur. Bilgiler tıpkı eski plaklarda olduğu gibi yuvarlak yollara yazılıp okunmaktadır. Bunlara "track"
    denilmektedir. Dolayısıyla bir track'e bilginin yazılıp okunması için öncelikle kafanın o track hizasına konumlandırılması 
    gerekmektedir. Tabii okuma yazma işlemi disk dönerken yapılmaktadır. Bu durumda manyetik tabanlı bu hard disklerde bir 
    sektörün transfer edilmesi için üç zaman unsuru vardır:

    1) Disk kafasının ilgili track hizasına konumlandırılması için gereken zaman (seek time).
    2) Diskin dönerek kafa hizasına gelmesi için gereken zaman (rotation delay).
    3) Transfer zamanı (transfer time)

    Buradaki en önemli zaman kaybı disk kafasının konumlandırılması sırasındaki kayıptır. Ortalama bir disk 6000 RPM hızında 
    dönmektedir. Yani bir dakikada 6000 tur atmaktadır. İkinci önemli zaman kaybı ilgi sektörün track kafa hizasına gelmesi 
    için harcanan zamandır. Nihayet en hızlı gerçekleşen işlem transfer işlemidir.

    İşletim sistemlerinin eski hard disklerde uyguladığı en önemli optimizasyon işlemi kafa hareketinin azaltılması üzerinedir. 
    Eğer dosyayı oluşturan sektörler birbirine yakınsa daha az kafa hareketi oluşur ve toplam transfer zamanı azaltılmış olur. 
    Tabii dosya sistemlerinde dosyanın parçaları zamanla birbirinden uzaklaşabilmektedir. Bunları birbirine yaklaştıran
    genellikle "defrag" biçiminde isimlendirilen yardımcı programlar vardır.

    Tabii artık şimdilerde kullandığımız SSD disklerde hiçbir mekanik unsur yoktur. Bunlar tamamen flash EPROM teknolojisi ile
    yani yarı iletken teknolojisiyle entegre devre biçiminde üretilmektedir. Bunlar rastgele erişimlidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diskten transfer edilecek en küçük birime sektör denilmektedir. Bir sektör genel olarak 512 byte uzunluğundadır. 
    Örneğin biz bir diskteki 1 byte'ı değiştirmek istesek önce onun içinde bulunduğu sektörü belleğe okuyup değişikliği 
    bellekte yapıp o sektörü yeniden diske yazarız. Disklere byte düzeyinde değil, sektör düzeyinde erişilmektedir.

    Diskteki her sektöre ilk sektör 0 olmak üzere bir numara verilmiştir. Disk denetleyicileri bu numarayla çalışmaktadır. 
    Eskiden disklerdeki koordinat sistemi daha farklıydı. Daha sonra teknoloji geliştikçe sektörün yerini belirlemek için 
    tek bir sayı kullanılmaya başlandı. Bu geçiş sırasında kullanılan bu sisteme LBA (Logical Block Addressing) deniliyordu. 
    Artık ister hard diskler olsun isterse SSD'ler olsun tıpkı bellekte her byte'ın bir numarası olduğu gibi her sektörün de 
    bir sektör numarası vardır. Transferler bu sektör numarasıyla yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında "dosya (file)" kavramı mantıksal bir kavramdır. Diskteki fiziksel birimler sektör denilen birimlerdir. Yani diskler
    dosyalardan oluşmaz sektörlerden oluşur. Dosya bir isim altında bir grup sektörü organize etmek için uydurulmuş bir 
    kavramdır. Aslında dosyanın içindekiler diskte ardışıl sektörlerde olmak zorunda değildir. Kullanıcı için dosya sanki 
    ardışıl byte'lardan oluşan bir topluluk gibidir. Ancak bu bir aldatmacadır. Dosyadaki byte'lar herhangi bir biçimde ardışıl 
    olmak zorunda değildir. Örneğin elimizde 100K'lık bir dosya olsun. Aslında bu 100K'lık dosya diskte 200 sektör içerisindedir. 
    Peki bu dosyanın parçaları hangi 200 sektör içerisindedir? İşte bir biçimde bu bilgiler de disk üzerinde tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk sistemleriyle ilgili programcıların ilk bilmesi gereken işlemler bir sektörün okunmasının ve yazılmasının nasıl 
    yapılacağıdır. Yukarıda bu işlemleri yapan yazılımsal birimin blok aygıt sürücüleri olduğunu belirtmiştik. Aygıt sürücülerin 
    de birer dosya gibi açılıp kullanıldığını biliyoruz. O halde sektör transferi için bizim hangi aygıt sürücüyü kullanacağımızı
    bilmemiz gerekir. UNIX/Linux sistemlerinde bilindiği gibi tüm temel aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini 
    içerisindedir.

    Bir Linux sisteminde "lsblk" komutu ile disklere ilişkin blok aygıt sürücülerinin listesini elde edebilirsiniz. Örneğin:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sr0     11:0    1 1024M  0 rom

    Linux sistemlerinde disklere ilişkin blok aygıt sürücüleri diskin türüne göre farklı biçimlerde isimlendirilmektedir. 
    Örneğin hard diskler ve SSD diskler tipik olarak "sda", "sdb", "sdc" biçiminde isimlendirilmektedir. Micro SD kartlar
    ise genellikle "mmcblk0", mmcblk1", "mmcblk2" gibi isimlendirilmektedir. Örneğin burada "sda" (Solid Disk a) ismi hard
    diski bir bütün olarak ele alan aygıt dosyasının ismidir. Disk, disk bölümlerinden oluşmaktadır. Bu disk bölümlerini sanki 
    ayrı disklermiş gibi ele alan aygıt dosyaları da "sda1", "sda2", "sda3" biçimindedir. Burada "disk bölümü (disk partition)" 
    terimini biraz açmak istiyoruz.

    Bir diskin bağımsız birden fazla diskmiş gibi kullanılabilmesi için disk mantıksal bölümlere ayrılmaktadır. Bu bölümlere
    "disk bölümleri (disk partitions)" denilmektedir. Bir disk bölümü diskin belli bir sektöründen başlar belli bir sektör 
    uzunluğu kadar devam eder. Disk bölümlerinin hangi sektörden başladığı ve hangi uzunlukta olduğu diskin başındaki bir 
    tabloda tutulmaktadır. Bu tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. Disk bölümleme tablosu 
    eskiden diskin ilk sektöründe tutuluyordu. Sonra UEFI BIOS'larla birlikte eski sistemle uyumlu olacak biçimde yeni 
    disk bölümleme tablo formatı geliştirildi. Bunlara "GUID Disk Bölümleme Tablosu (GUID Partition Table)" denilmektedir. 
    Örneğin 3 disk bölümüne sahip bir diskin mantıksal organizasyonu şöyledir:

    Disk Bölümleme Tablosu
    Birinci Disk Bölümü
    İkinci Disk Bölümü
    Üçüncü Disk Bölümü

    İşte "lsblk" yaptığımız Linux sisteminde biz "/dev/sda" aygıt dosyasını açarsak tüm diski tek parça olarak ele alırız. 
    Eğer "/dev/sda1" aygıt dosyasını açarsak sanki Birinci Disk Bölümü ayrı diskmiş gibi yalnızca o bölümü ele alabiliriz. 
    Örneğin "/dev/sda2" aygıt dosyasından okuyacağımız 0 numaralı sektör aslında İkinci Disk Bölümünün ilk sektörüdür. 
    Tabii bu sektör "/dev/sda" aygıt dosyasındaki 0 numaralı sektör değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir diskten bir sektör okumak için yapılacak tek şey ilgili aygıt sürücüyü open fonksiyonuyla açmak 
    dosya göstericisini konumlandırıp read fonksiyonu ile okuma yapmaktır. Biz yukarıda bir diskten okunup yazılabilen en 
    küçük birimin bir sektör olduğunu (512 byte) söylemiştik. Her ne kadar donanımsal olarak bir diskten okunabilecek ya da 
    diske yazılabilecek en küçük birim bir sektör olsa da aslında işletim sistemleri transferleri sektör olarak değil blok 
    blok yapmaktadır. Bir blok ardışıl n tane sektöre denilmektedir. Örneğin Linux işletim sisteminin disk cache sistemi 
    aslında 4K büyüklüğünde bloklara sahiptir. 4K'nın aynı zamanda sayfa büyüklüğü olduğunu anımsayınız. Dolayısıyla biz 
    Linux'ta aslında disk ile bellek arasında en az 4K'lık transferler yapmaktayız. O halde işletim sisteminin dosya sistemi
    ve diske doğrudan erişen sistem programcıları, Linux sistemlerinde diskten birer sektör okuyup yazmak yerine 4K'lık blokları 
    okuyup yazarsa sistemle daha uyumlu çalışmış olur.

    Peki biz ilgili disk aygıt sürücüsünü açıp read fonksiyonu ile yalnızca 10 byte okumak istersek ne olur? İşte bu durumda 
    blok aygıt sürücüsü gerçek anlamda o 10 byte'ın içinde bulunduğu 4K'lık bir kısmı diskten okur onu cache'e yerleştirir 
    ve bize onun yalnızca 10 byte'ını verir. Aynı byte'ları ikinci kez okumak istersek gerçek anlamda bir disk okuması 
    yapılmayacak RAM'de saklanmış olan cache'in içerisindeki bilgiler bize verilecektir. Aşağıda diski bir bütün olarak gören 
    "/dev/sda" aygıt sürücüsü açılıp onun ilk sektörü okunmuş ve içeriği HEX olarak ekrana (stdout dosyasına) yazdırılmıştır. 
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Bu aygıt sürücüyü temsil eden aygıt dosyasına ancak root kullanıcısı 
    erişebilmektedir. Bu dosyaların erişim haklarına dikkat ediniz:

    $ ls /dev/sda* -l
    brw-rw---- 1 root disk 8, 0 Ağu 29 14:56 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ağu 29 14:56 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ağu 29 14:56 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ağu 29 14:56 /dev/sda3

    Bu durumda programınızı sudo ile çalıştırmalısınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    unsigned char buf[512];

    if ((fd = open("/dev/sda", O_RDONLY)) == -1)
        exit_sys("open");

    if (read(fd, buf, 512) == -1)
        exit_sys("read");

    for (int i = 0; i < 512; ++i)
        printf("%02x%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya sistemi (file system) denildiğinde ne anlaşılmaktadır? Bir dosya sisteminin iki yönü vardır: Bellek ve disk. 
    Dosya sisteminin bellek tarafı işletim sisteminin açık dosyalar için kernel alanında yaptığı organizasyonla (dosya betimleyici 
    tablosu, dosya nesnesi vs.) ilgilidir. Disk tarafı ise diskteki organizasyonla ilgilidir. Biz kursumuzda bellek tarafındaki
    organizasyonun temellerini gördük. Şimdi bu bölümde disk üzerindeki organizasyonu ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kavramını diskte oluşturmak için farklı dosya sistemleri tarafından farklı disk organizasyonları kullanılmaktadır. 
    Bugün kullanılan çok sayıda dosya sistemi vardır. Bu sistemlerin her birinin disk organizasyonu diğerinden az çok farklıdır. 
    Ancak bazı dosya sistemlerinin disk organizasyonları birbirine çok benzemektedir. Bunlar adeta bir aile oluşturmaktadır. 
    Örneğin Microsoft'un FAT dosya sistemleri, Linux'un ext dosya sistemleri kendi aralarında birbirine oldukça benzemektedir.

    Microsoft'un dünyanın ilk kişisel bilgisayarlarında kullandığı dosya sistemlerine aile olarak FAT (File Allocation Table) 
    denilmektedir. Bu FAT dosya sistemlerinin kendi içerisinde FAT12, FAT16 ve FAT32 biçiminde varyasyonları vardır. Microsoft 
    daha sonra yine FAT tabanlı ancak çok daha gelişmiş NTFS denilen bir dosya sistemi gerçekleştirmiştir. Bugün Windows 
    sistemlerinde genel olarak NTFS (New Technology File Systems) dosya sistemleri kullanılmaktadır. Ancak Microsoft hala 
    FAT tabanlı dosya sistemlerini de desteklemektedir. Linux sistemlerinde "EXT (Extended File System)" ismi verilen 
    "i-node tabanlı" dosya sistemleri kullanılmaktadır. Bu EXT dosya sistemlerinin EXT2, EXT3, EXT4 biçiminde varyasyonları 
    vardır. Bugünkü Linux sistemlerinde en çok EXT4 dosya sistemi kullanılmaktadır. Apple firması yine i-node tabanlı HFS 
    (Hierarchical File System), HFS+ (Hierarchical File System Plus) ve APFS (Apple File System) isimli dosya sistemlerini 
    kullanmaktadır. Bunlar da aile olarak birbirlerine çok benzemektedir. Bugünkü macOS sistemlerinde genellikle HFS+ 
    ya da APFS dosya sistemleri kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                166. Ders 22/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi UNIX/Linux sistemlerinde Windows sistemlerinde olduğu gibi "sürücü (drive)" kavramı yoktur. Dosya sisteminde
    tek bir "kök dizin (root directory)" vardır. Eğer biz bir dosya sistemine erişmek istiyorsak önce onu belli bir dizinin
    üzerine "mount" ederiz. Artık o dosya sisteminin kökü mount ettiğimiz dizin üzerinde bulunur. Örneğin bir flash belleği 
    USB yuvasına taktığımızda Windows'ta o flash bellek bir sürücü olarak gözükmektedir. Ancak Linux sistemlerinde o flash 
    bellek belli bir dizinin altında gözükür. Yani o dizine mount işlemi yapılmaktadır. Bir dosya sistemi bir dizine mount 
    edildiğinde artık o dizin ve onun altındaki dizin ağacı görünmez olur. Onun yerine mount ettiğimiz blok aygıtındaki dosya
    sisteminin kökü görünür.

    Mount işlemi Linux sistemlerinde aslında bir sistem fonksiyonuyla yapılmaktadır. Bu sistem fonksiyonu "libc" kütüphanesinde
    "mount" ismiyle bulunmaktadır. mount fonksiyonunun prototipi şöyledir:

    #include <sys/mount.h>

    int mount(const char *source, const char *target, const char *filesystemtype, 
        unsigned long mountflags, const void *data);

    Fonksiyonun birinci parametresi blok aygıt dosyasının yol ifadesini, ikinci parametre mount dizinini (mount point)
    belirtmektedir. Üçüncü parametre dosya sisteminin türünü almaktadır. Dördüncü parametre mount bayraklarını belirtmektedir. 
    Bu parametre 0 geçilebilir. Son parametre ise dosya sistemi için gerekebilecek ekstra verileri belirtmektedir. Bu parametre 
    de NULL adres geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Dosya
    sisteminin türünün otomatik tespit eden bazı özel fonksiyonlar bulunmaktadır. Örneğin "libmount" kütüphanesi içerisindeki 
    statfs fonksiyonuyla ya da "libblkid" kütüphanesi içerisindeki fonksiyonlarla bunu sağlayabilirsiniz.

    Tabii bu fonksiyonu çağırabilmek için prosesimizin etkin kullanıcı id'sinin 0 olması ya da prosesimizin uygun önceliğe 
    (appropriate privileges) sahip olması gerekir. mount fonksiyonu POSIX standartlarında yoktur. Çünkü işletim sisteminin
    gerçekleştirimine oldukça bağlı bir fonksiyondur. Tabii kullanıcılar mount işlemini bu sistem fonksiyonu yoluyla değil, 
    "mount" isimli kabuk komutuyla yapmaktadır. mount işlemi için elimizde bir blok aygıt sürücüsüne ilişkin aygıt dosyasının
    bulunuyor olması gerekir. Ancak blok aygıt sürücüleri mount edilebilmektedir. Tabii ilgili blok aygıt sürücüsünün sektörleri 
    içerisinde bir dosya sisteminin bulunuyor olması gerekir. mount isimli kabuk komutunun tipik kullanımı şöyledir:

    sudo mount <blok_aygıt_dosyası> <mount_edilecek_dizin>

    Mount edilecek dizine genel olarak İngilizce "mount point" de denilmektedir. Örneğin bilgisayarımıza bir SD kart okuyucu 
    bağlamış olalım. lsblk yaptığımızda şöyle bir görüntüyle karşılaştığımızı varsayalım:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sdb      8:16   1    0B  0 disk
    sdc      8:32   1 14,8G  0 disk
    ├─sdc1   8:33   1   60M  0 part /media/kaan/72FA-ACF3
    └─sdc2   8:34   1 14,8G  0 part /media/kaan/fa57bb30-99ca-4966-8249-6b0c6c4f4d8d
    sdd      8:48   1    0B  0 disk
    sr0     11:0    1 1024M  0 rom

    Burada taktığımız SD kart "sdc" ismiyle gözükmektedir. "/dev/sdc" aygıt dosyası SD kartı bir bütün olarak görmektedir. 
    Bu SD kartın içerisinde iki farklı disk bölümünün oluşturulduğu görülmektedir. Bu disk bölümlerine ilişkin aygıt dosyaları 
    da "/dev/sdc1" ve "/dev/sdc2" dosyalarıdır. Biz "/dev/sdc" aygıtını mount edemeyiz. Çünkü bu aygıt, diski bir bütün olarak 
    görmektedir. Oysa "/dev/sdc1" ve "/dev/sdc2" aygıtlarının içerisinde daha önceden oluşturulmuş olan dosya sistemleri vardır. 
    Biz bu aygıtları mount edebiliriz. Mount işlemi için sistem yöneticisinin bir dizin oluşturması gerekir. Mount işlemleri 
    için Linux sistemlerinde kök dizinin altında bir "mnt" dizini oluşturulmuş durumdadır. Yani mount edilecek dizini bu dizinin 
    altında yaratabilirsiniz. Tabii böyle bir zorunluluk yoktur. Biz bulunduğumuz dizinde boş bir dizin yaratıp bu dizini 
    mount point olarak kullanabiliriz. Örneğin:

    $ sudo mount /dev/sdc1 mydisk

    mount komutu ilgili blok aygıtındaki dosya sistemini otomatik olarak tespit etmeye çalışır. Genellikle bu tespit otomatik 
    yapılabilmektedir. Ancak bazı özel aygıtlar ve dosya sistemleri için bu belirlemenin açıkça yapılması gerekebilir. Bunun 
    için mount komutunda "-t <dosya_sisteminin_türü> seçeneği kullanılır. Örneğin:

    $ sudo mount -t vfat /dev/sdc1 mydisk

    Burada -t seçeneğine argümanı olarak aşağıdaki gibi dosya sistemleri kullanılabilir:

    ext2
    ext3
    ext4
    ntfs
    vfat
    tmpfs
    xfs
    ...

    Dosya sisteminin otomatik belirlenmesi mount sistem fonksiyonu tarafından yapılmaktadır. mount komutu birtakım işlemlerle
    bunu sağlamaktadır.

    Mount edilmiş olan bir blok aygıtının mount işlemi umount isimli sistem fonksiyonuyla kaldırılabilir. Fonksiyonun prototipi 
    şöyledir:

    #include <sys/mount.h>

    int umount(const char *target);

    Fonksiyon mount dizinini parametre olarak almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri 
    döner. Artık umount yapıldıktan sonra mount point dizinin içeriğine yeniden erişilebilmektedir. Unmount işlemi de yine komut 
    satırından "umount" komutuyla yapılabilmektedir. Komutun genel biçimi şöyledir:

    $ sudo umount <mount_dizini ya da blok_aygıt_dosyası>

    Örneğin:

    $ sudo umount mydisk

    Pek çok UNIX türevi sistemde olduğu gibi Linux sistemlerinde de "otomatik mount" mekanizması bulunmaktadır. Sistem boot
    edildiğinde konfigürasyon dosyalarından hareketle otomatik mount işlemleri yapılabilmektedir. USB aygıtları genel olarak 
    zaten otomatik mount işlemi oluşturmaktadır. "systemd" init sisteminde "mount unit" dosyaları ile otomatik mount işlemleri
    yönetilebilmektedir. Klasik "system5" init sistemlerinde çekirdek yüklendikten sonra "/etc/fstab" dosyasında otomatik 
    mount edilecek blok aygıtları belirtilebilmektedir. "/etc/fstab" dosyasına "systemd" tarafından da açılış sırasında 
    bakılmaktadır.

    Aşağıda mount sistem fonksiyonu çağrılarak mount işlemi yapan bir örnek verilmiştir. Programı aşağıdakine benzer biçimde 
    çalıştırabilirsiniz:

    $ sudo ./mymount /dev/sdc1 mydisk vfat
---------------------------------------------------------------------------------------------------------------------------*/

/* mymount.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mount.h>

void exit_sys(const char *msg);

/* mymount <device> <mount_point> <filesystem_type> */

int main(int argc, char *argv[])
{
    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (mount(argv[1], argv[2], argv[3], 0, NULL) == -1)
        exit_sys("mount");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir dosyayı sanki blok aygıtı gibi gösteren hazır aygıt sürücüler bulunmaktadır. Bunlara "loop" aygıt 
    sürücüleri denilmektedir. Bu aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini içerisinde "loopN" ismiyle (burada N bir 
    sayı belirtiyor) bulunmaktadır. Örneğin:

    $ ls -l /dev/loop*
    brw-rw---- 1 root disk  7,   0 Haz  4 22:31 /dev/loop0
    brw-rw---- 1 root disk  7,   1 Haz  4 22:31 /dev/loop1
    brw-rw---- 1 root disk  7,   2 Haz  4 22:31 /dev/loop2
    brw-rw---- 1 root disk  7,   3 Haz  4 22:31 /dev/loop3
    brw-rw---- 1 root disk  7,   4 Haz  4 22:31 /dev/loop4
    brw-rw---- 1 root disk  7,   5 Haz  4 22:31 /dev/loop5
    brw-rw---- 1 root disk  7,   6 Haz  4 22:31 /dev/loop6
    brw-rw---- 1 root disk  7,   7 Haz  4 22:31 /dev/loop7
    crw-rw---- 1 root disk 10, 237 Haz  4 22:31 /dev/loop-control

    Bir dosyayı blok aygıt sürücüsü biçiminde kullanabilmek için önce "losetup" programı ile bir hazırlık işleminin yapılması 
    gerekir. Hazırlık işleminde "loop" aygıt sürücüsüne ilişkin aygıt dosyası ve blok aygıt sürücüsü olarak gösterilecek dosya 
    belirtilir. Bu işlemin sudo ile yapılması gerekmektedir. Örneğin:

    $ sudo losetup /dev/loop0 mydisk.dat

    Tabii bizim burada "mydisk.dat" isimli bir dosyaya sahip olmamız gerekir. İçi 0'larla dolu 100 MB'lik böyle bir dosyayı
    dd komutuyla aşağıdaki gibi oluşturabiliriz:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada artık "/dev/loop0" aygıt dosyası adeta bir disk gibi kullanılabilir hale gelmiştir. Biz bu "/dev/loop0" dosyasını 
    kullandığımızda bu işlemlerden aslında "mydisk.dat" dosyası etkilenecektir.

    Sıfırdan bir diske ya da bir disk bölümüne bir dosya sistemi yerleştirebilmek için onun formatlanması gerekir. UNIX/Linux
    sistemlerinde formatlama için "mkfs.xxx" isimli programlar bulundurulmuştur. Örneğin aygıtta FAT dosya sistemi oluşturmak 
    için "mkfs.fat" programı, ext4 dosya sistemi oluşturmak için "mkfs.ext4" programı kullanılmaktadır. Örneğin biz yukarıda
    oluşturmuş olduğumuz "/dev/loop" aygıtını ext2 dosya sistemi ile aşağıdaki gibi formatlayabiliriz:

    $ sudo mkfs.ext2 /dev/loop0

    Burada işlemden aslında "mydisk.dat" dosyası etkilenmektedir. Artık formatladığımız aygıta ilişkin dosya sistemini aşağıdaki 
    gibi mount edebiliriz:

    $ mkdir mydisk
    $ sudo mount /dev/loop0 mydisk

    Loop aygıtının dosya ile bağlantısını kesmek için "losetup" programı "-d" seçeneği ile çalıştırılır. Tabii önce aygıtın 
    kullanımdan düşürülmesi gerekir:

    $ sudo umount mydisk
    $ sudo losetup -d /dev/loop0

    Eğer loop aygıt sürücüsünün bir dosyayı onun belli bir offset'inden itibaren kullanmasını istiyorsak losetup programında
    "-o (ya da "--offset") seçeneğini kullanmalıyız. Örneğin bir disk imajının içerisindeki Linux dosya sisteminin disk imajının 
    8192'nci sektöründen başladığını varsayalım. "dev/loop0" aygıt sürücüsünün bu imaj dosyasını bu offset'ten itibaren 
    kullanmasını şöyle sağlayabiliriz:

    $ sudo losetup -o 4194304 /dev/loop0 am335x-debian-11.7-iot-armhf-2023-09-02-4gb.img

    512 * 8192 = 4194304 olduğuna dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                167. Ders 27/09/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda önce FAT dosya sisteminden bahsedeceğiz sonra UNIX/Linux sistemlerindeki i-node tabanlı EXT dosya sistemleri
    üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemi Microsoft tarafından DOS işletim sistemi için geliştirilmiştir. Ancak bu dosya sistemi hala kullanılmaktadır. 
    FAT dosya sistemi o zamanlar teknolojisiyle tasarlanmıştır. Dolayısıyla modern dosya sistemlerinde bulunan bazı özellikler 
    bu dosya sisteminde bulunmamaktadır. FAT dosya sistemi kendi aralarında FAT12, FAT16 ve FAT32 olmak üzere üç gruba ayrılmaktadır.
    Bu sistemlerin arasındaki en önemli fark dosya sistemi içerisindeki FAT (File Allocation Table) denilen tablodaki elemanların
    uzunluklarıdır. FAT12'de FAT elemanları 12 bit, FAT16'da 16 bit ve ve FAT32'de 32 bittir. Microsoft, Windows sistemlerine
    geçtiğinde bu FAT sistemini biraz revize etmiştir. Buna da VFAT denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir disk ya da disk bölümü (Disk Partition) FAT dosya sistemiyle formatlandığında disk bölümünde dört mantıksal bölüm 
    oluşturulmaktadır:

    1) Boot Sektör
    2) FAT Bölümü
    3) Root Dir Bölümü
    4) Data Bölümü

    Bir dosya sisteminin içi boş bir biçimde kullanıma hazır hale getirilmesi sürecine formatlama denilmektedir. Formatlama 
    sırasında ilgili disk ya da disk bölümünde ilgili dosya sistemi için metadata alanlar oluşturulmaktadır.

    Windows'ta ilgili disk ya da disk bölümünü FAT dosya sistemiyle formatlamak için "Bilgisayar Yönetimi / Disk Yönetimi" 
    kısmından ilgili disk bölümü seçilir ve farenin sağ tuşuna basılarak formatlama yapılır. Benzer biçimde formatlama 
    "Bilgisayarım (My Computer)" açılarak orada ilgili disk bölümünün üzerine sağa tıklanarak da yapılabilmektedir.

    Linux sistemlerinde bir blok aygıt sürücüsü ya da doğrudan bir dosya "mkfs.fat" programıyla formatlanabilir. Biz yukarıda 
    da belirttiğimiz gibi bir dosyayı sanki disk gibi kullanacağız. Örneğin "dd" programıyla 50MB'lik içi sıfırlarla dolu 
    bir dosya oluşturalım:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada 512 * 100000 byte'lık (yaklaşık 50 MB) içi sıfırlarla dolu bir dosya oluşturulmuştur. Bu dosyayı "/dev/loop0" 
    blok aygıt sürücüsü biçiminde kullanılabilmesi şöyle sağlanabilir:

    $ sudo losetup /dev/loop0 mydisk.dat

    Şimdi artık "mkfs.fat" programı ile formatlamayı yapabiliriz. Yukarıda FAT'in FAT12, FAT16 ve FAT32 olmak üzere üç 
    türünün olduğunu belirtmiştik. FAT türü "mkfs.fat" programında -F12, -F16 ya da -F32 seçenekleriyle belirtilmektedir. 
    Örneğin biz blok aygıtımızı FAT16 biçiminde şöyle formatlayabiliriz:

    $ sudo mkfs.fat -F16 /dev/loop0

    Aslında "mkfs.xxx" programları blok aygıt dosyası yerine normal bir dosya üzerinde de formatlama yapabilmektedir. Tabii 
    biz kursumuzda bir blok aygıtı oluşturup onu mount edeceğiz. Şimdi biz FAT16 olarak formatladığımız "/dev/loop0" blok 
    aygıtını mount edebiliriz. Tabii bunun için önce bir "mount dizininin (mount point)" oluşturulması gerekmektedir:

    $ mkdir fat16
    $ sudo mount /dev/loop0 fat16

    Artık fat16 dizini oluşturduğumuz FAT dosya sisteminin kök dizinidir. Ancak bu dosya sisteminin tüm bilgileri "mydisk.dat"
    dosyasında bulundurulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemiyle formatlanmış olan bir diskin ya da disk bölümünün ilk sektörüne "Boot Sector" denilmektedir. Dolayısıyla 
    boot sektör ilgili diskin ya da disk bölümünün mantıksal 0 numaralı sektöründedir. Boot sektör isminden de anlaşılacağı 
    gibi 512 byte uzunluğundadır. Bu sektörün iç organizasyonu şöyledir:

    Jmp Kodu | BPB (BIOS Parameter Block) | DOS Yükleyici Programı | 55 AA

    Boot sektörün hemen başında Intel Mimarisinde BPB bölümünü atlayarak DOS işletim sistemini yükleyen yükleyici program 
    için bir jmp komutu bulunmaktadır. Bugün artık DOS işletim sistemi kullanılmadığı için buradaki jmp kodun ve yükleyici 
    programın bir işlevi kalmamıştır. Ancak BPB alanı eskiden olduğu yerdedir ve dosya sistemi hakkında kritik bilgiler bu 
    bölümde tutulmaktadır. Sektörün başındaki Jmp Code tipik olarak "EB 3C 90" makine komutundan oluşmaktadır. Bazı kaynaklar 
    bu jmp kodu da BPB alanına dahil etmektedir. Eğer dosya sisteminde yüklenecek bir DOS işletim sistemi yoksa buradaki 
    yükleyici program yerine format programı buraya ekrana mesaj çıkartan küçük program kodu yerleştirmektedir. Aşağıda 
    "mkfs.fat" programı ile FAT16 biçiminde formatlanan FAT dosya sisteminin boot sektör içeriği görülmektedir:

    $ hexdump -C mydisk.dat -n 512 -v

    00000000  eb 3c 90 6d 6b 66 73 2e  66 61 74 00 02 04 04 00  |.<.mkfs.fat.....|
    00000010  02 00 02 00 00 f8 64 00  20 00 08 00 00 00 00 00  |......d. .......|
    00000020  a0 86 01 00 80 01 29 fa  0b 93 c5 4e 4f 20 4e 41  |......)....NO NA|
    00000030  4d 45 20 20 20 20 46 41  54 31 36 20 20 20 0e 1f  |ME    FAT16   ..|
    00000040  be 5b 7c ac 22 c0 74 0b  56 b4 0e bb 07 00 cd 10  |.[|.".t.V.......|
    00000050  5e eb f0 32 e4 cd 16 cd  19 eb fe 54 68 69 73 20  |^..2.......This |
    00000060  69 73 20 6e 6f 74 20 61  20 62 6f 6f 74 61 62 6c  |is not a bootabl|
    00000070  65 20 64 69 73 6b 2e 20  20 50 6c 65 61 73 65 20  |e disk.  Please |
    00000080  69 6e 73 65 72 74 20 61  20 62 6f 6f 74 61 62 6c  |insert a bootabl|
    00000090  65 20 66 6c 6f 70 70 79  20 61 6e 64 0d 0a 70 72  |e floppy and..pr|
    000000a0  65 73 73 20 61 6e 79 20  6b 65 79 20 74 6f 20 74  |ess any key to t|
    000000b0  72 79 20 61 67 61 69 6e  20 2e 2e 2e 20 0d 0a 00  |ry again ... ...|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Burada yükleyici programın DOS olmaması durumunda ekrana yazdırdığı mesaj görülmektedir. Tabii bu mesajın çıkması için
    bu diskin ya da disk bölümünün aktif disk ya da aktif disk bölümü olması gerekir. Yani bu diskten ya da disk bölümünde 
    boot etme girişimi olmadıktan sonra bu mesaj görülmeyecektir.

    FAT dosya sisteminin en önemli metadata bilgileri boot sektörün hemen başındaki BPB (Bios Parameter Block) alanında 
    tutulmaktadır. Bu bölümün bozulması durumunda dosya sistemine erişim mümkün olamamaktadır. Başka bir deyişle bu dosya 
    sisteminin bozulmasını sağlamak için tek yapılacak şey bu BPB alanındaki byte'ları sıfırlamaktır. Tabii zamanla FAT dosya
    sistemindeki diğer bölümleri inceleyerek bozulmuş olan BPB alanını onaran yardımcı araçlar da çeşitli kişiler ve kurumlar 
    tarafından geliştirilmiştir.

    Boot sektörün sonunda "55 AA" değeri bulunmaktadır. Bu bir sihirli sayı (magic number) olarak bulundurulmaktadır. Bazı 
    programlar ve bazı boot loader'lar kontrolü boot sektöre bırakmadan önce bu sihirli sayıyı kontrol edebilmektedir. Böylece
    rastgele bozulmalarda bu sihirli sayı da bozulacağı için yetersiz olsa da basit bir kontrol mekanizması oluşturulabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                168. Ders 29/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                169. Ders 06/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde en önemli kısım şüphesiz "BPB (BIOS Parameter Block)" denilen kısımdır. BPB hemen boot sektörün 
    başındadır ve FAT dosya sisteminin diğer bölümleri hakkında kritik bilgiler içermektedir. Tabii BPB bölümü 1980'lerin 
    anlayışıyla tasarlanmıştır. Bu tasarımda hatalar DOS'un çeşitli versiyonlarında geçmişe doğru uyumu koruyarak giderilmeye
    çalışılmıştır. Biz burada önce FAT12 ve FAT16 sistemlerinde kullanılan BPB bloğunun içeriğini tek tek ele alacağız. FAT32
    ile birlikte BPB bloğuna eklemeler de yapılmıştır. FAT32 BPB formatını daha sonra ele alacağız.

    Aşağıda FAT12 ve FAT16 sistemlerindeki BPB bloğunun formatı açıklanmaktadır. Tablodaki Offset sütunu Hex olarak ilgili alanın
    Boot sektörün başından itibaren kaçıncı byte'tan başladığını belirtmektedir.

    Offset (Hex)        Uzunluk             Anlamı
    00                  3 Byte              Jmp Kodu
    03                  8 Byte              OEM Yorum Alanı
    0B                  WORD                Sektördeki Byte Sayısı
    0C                  BYTE                Cluster'daki Sektör Sayısı
    0E                  WORD                Ayrılmış Sektörlerin Sayısı
    10                  BYTE                FAT Kopyalarının Sayısı
    11                  WORD                Kök Dizinlerindeki Girişlerin Sayısı
    13                  WORD                Toplam Sektör Sayısı (Eski)
    15                  BYTE                Ortam Belirleyicisi (Media Descriptor)
    16                  WORD                FAT'in Bir Kopyasındaki Sektör Sayısı
    18                  WORD                Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor)
    1A                  WORD                Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor)
    1C                  DWORD               Saklı Sektörlerin Sayısı
    20                  DWORD               Yeni Toplam Sektör Sayısı
    24                  3 Byte              Reserved
    27                  DWORD               Volüm Seri Numarası
    2B                  11 Byte             Volüm İsmi

    - Jump Kodu: Yukarıda da belirttiğimiz gibi BPB bloğunu geçerek yükleyici programa atlayan makine komutlarından oluşmaktadır. 
    Boot loader programlar akışı buradan boot sektöre devretmektedir. Dolayısıyla BPB alanının atlanması gerekmektedir. Burada
    bazen Intel short jump bazen de near jump komutları bulunur. Tipik içerik "EB 3C 90" biçimindedir.

    - OEM Yorum Alanı: Formatlama programının kendine özgü yazdığı 8 byte'lık küçük yazıdır. Buraya eskiden DOS işletim sisteminin 
    versiyon numarası yazılıyordu. Örneğin Windows bu BPB alanın yeni biçiminin tanındığı en eski sistem olan "MSDOS5.0" 
    yazısını buraya yerleştirmektedir. Ancak buraya yerleştirilen yazı herhangi bir biçimde kullanılmamaktadır.

    - Sektördeki Byte Sayısı: Bir sektörde kaç byte olduğu bilgisi burada tutulmaktadır. Tabii bu değer hemen her zaman 512'dir.
    Yani Little Endian formatta hex olarak burada "00 02" değerlerini görmemiz gerekir.

    - Cluster'daki Sektör Sayısı: Dosyaların parçaları disk üzerinde ardışıl bir biçimde konumlandırılmak zorunda değildir. 
    FAT dosya sisteminde bir dosyanın hangi parçasının diskte nerede konumlandırıldığı FAT (File Allocation Table) denilen 
    bir bölümde saklanmaktadır. Eğer bir dosya çok fazla parçaya ayrılırsa hem disk üzerinde daha çok yayılmış olur hem de FAT
    bölümünde bu dosyanın parçalarının yerini tutmak için gereken alan büyür. Bu nedenle dosyaların parçaları sektörlere değil,
    cluster denilen birimlere bölünmüştür. Bir cluster ardışıl n tane sektörün oluşturduğu topluluktur. Örneğin bir cluster'ın
    4 sektör olması demek 4 sektörden oluşması (yani 2K) demektir. Şimdi elimizde 10,000 byte uzunluğunda bir dosya olsun. Bir 
    cluster'ın 1 sektör olduğunu düşünelim. Bu durumda bu 10,000 byte'lık dosya toplamda 10000 / 512 = 19.53125 yani 20 cluster
    yer kaplayacaktır. FAT bölümünde bu 20 cluster 20 elemanlık yer kaplayacaktır. Şimdi bir cluster'ın 4 sektörden oluştuğunu 
    düşünelim. Bu durumda 10,000 byte'lık dosya 10000 / 2048 = 4.8828125 yani 5 cluster yer kaplayacaktır. Bu dosyanın yerini 
    tutmak için FAT bölümünde 5 eleman yeterli olacaktır. Görüldüğü gibi cluster bir dosyanın bir parçasını tutabilen en düşük
    tahsisat birimidir. Halbuki sektör diskten transfer edilecek en küçük birimdir. Sektör yerine dosya sisteminin cluster kavramını
    kullanmasının iki nedeni vardır. Birincisi cluster ardışıl sektörlerden oluştuğu için dosyanın parçaları diskte daha az
    yayılmış olur. İkincisi de dosyanın parçalarının yerlerini tutmak için daha az alan gerekmektedir.

    Peki bir cluster kaç sektörden oluşmalıdır? Eğer bir cluster çok fazla sayıda sektörden oluşursa dosyanın son parçasında 
    kullanılmayan alan (buna "içsel bölünme (internal fragmentation)" da denilmektedir) fazlalaşır diskin kullanım kapasitesi 
    azalmaya başlar. Örneğin bir cluster'ın 32 sektörden (16K) oluştuğunu varsayalım. Bu durumda 1 byte'lık bir dosya bile 
    16K yer kaplayacaktır. Çünkü dosya sisteminin minimum tahsisat birimi 16K'dır. Örneğin bir sistemde 100 tane 1 byte'lık 
    dosyanın diskte kapladığı alanla 1 tane 100 byte'lık dosyanın diskte kapladığı alan kıyaslandığında 100 tane 1 byte'lık 
    dosyanın diskte çok daha fazla yer kapladığı görülecektir. İşte UNIX/Linux sistemlerinde dosyaları tek bir dosyada peşi 
    sıra birleştiren ve bunların yerlerini dosyanın başındaki bir başlık kısmında tutan "tar" isimli bir yardımcı program 
    bulunmaktadır. "tar" programının bir sıkıştırma yapmadığına diskteki kaplanan alanı azaltmak için yalnızca dosyaları 
    uç uca eklediğine dikkat ediniz. Tabii genellikle dosyalar tar'landıktan sonra ayrıca sıkıştırılabilir. Bu sistemlerdeki 
    "tar.gz" gibi dosya uzantıları tar'landıktan sonra zip'lenmiş olan dosyaları belirtmektedir. Peki o halde bir cluster'ın
    kaç sektör olacağına nasıl karar verilmektedir? İşte sezgisel olarak disk hacmi büyüdükçe kaybedilen alanların önemi 
    azalacağı için cluster'ın çok sektörden oluşturulması, disk hacmi azaldıkça az sektörden oluşturulması yoluna gidilmektedir. 
    Format programları bu değerin kullanıcı tarafından belirlenmesine olanak sağlamakla birlikte default değer de önermektedir. 
    Linux'taki "mkfs.fat" programında ise cluster boyutu "-s" seçeneği ile belirlenmektedir. Örneğin:

    $ sudo mkfs.fat -F16 -s 2 /dev/loop0

    Burada bir cluster 2 sektörden oluşturulmuştur.

    İşte BPB bloğunun "0C" offset'inde bir cluster'ın kaç sektörden oluştuğu bilgisi yer almaktadır. İşletim sistemi dosyaların 
    parçalarına erişirken hep bu bilgiyi kullanmaktadır. (Burada değeri disk editörü ile değiştirsek dosya sistemi tamamen 
    saçmalayacaktır.) Yukarıdaki örnek boot sektörde bir cluster 4 sektörden (yani 4K = 2048 byte'tan) oluşmaktadır.

    Ayrılmış Sektörlerin Sayısı: Burada boot sektörü izleyen FAT bölümünün kaçıncı sektörden başladığı bilgisi yer almaktadır. 
    Tabii buradaki orijin FAT disk bölümünün başıdır. Yani boot sektör 0'ıncı sektörde olmak üzere FAT bölümünün kaçıncı sektörden
    başladığını belirtmektedir. Peki neden boot sektör ile FAT arasında boşluk bırakmak gerekebilir? İşte hard disklerde 
    işletim sistemi FAT bölümünü ilk silindire hizalamak isteyebilir. Eğer özel uygulamalarda boot sektör yükleyici programı
    uzunsa yükleyicinin diğer parçaları da burada bulunabilmektedir. Yukarıdaki örnek FAT bölümünün boot sektöründe bu byte'lar
    "04 00" biçimindedir. Little Endian formatta bu değer 4'tür. O halde bu dosya sisteminde FAT bölümü 4'üncü sektörden 
    başlamaktadır.

    FAT Kopyalarının Sayısı: FAT bölümü izleyen paragraflarda da görüleceği gibi FAT dosya sisteminin önemli bir meta-data 
    alanıdır. Bu nedenle bu bölümün backup amaçlı birden fazla kopyasının bulundurulması uygun görülmüştür. Tipik olarak bu 
    alanda 2 değeri bulunur. Yani FAT bölümünün toplamda iki kopyası vardır. FAT bölümünün kopyaları hemen birbirinin peşi 
    sıra dizilmiştir. Yani bir kopyanın bittiği yerde diğeri başlamaktadır.

    Kök Dizinlerindeki Girişlerin Sayısı: FAT dosya sistemindeki bölümlerin dizilimin şöyle olduğunu belirtmiştik:

    Boot Sektör
    FAT ve Kopyaları
    Root Dir Bölümü
    Data Bölümü

    İşletim sisteminin tüm bölümlerin hangi sektörden başladığını ve kaç sektör uzunlukta olduğunu bilmesi gerekir. İşte 
    "Root Dir" bölümü dizin girişlerinden oluşmaktadır. Bir dizin girişi 32 byte uzunluğundadır. Burada toplam kaç giriş 
    olduğu belirtilmektedir. Dolayısıyla "Root Dir" bölümünün sektör uzunluğu buradaki sayının 32'ye bölümü ile hesaplanır. 
    Bizim oluşturduğumuz örnek FAT16 disk bölümünde burada "0x0200" (512) değeri bulunmaktadır. Bu durumda Root Dir bölümünün
    sektör uzunluğu 512 / 32 = 16'dır.

    Toplam Sektör Sayısı (Eski): Bu alanda disk bölümündeki toplam sektör sayısı bulundurulmaktadır. Ancak BPB formatının 
    tasarlandığı 1980'lerin başında henüz hard diskler çok yeniydi ve teknolojinin bu kadar hızlı gelişeceği düşünülmemişti.
    Dolayısıyla toplam sektör sayısı için 2 byte'lık yer o zamanlar için yeterli gibiydi. Toplam sektör sayısı için ayrılan 
    2 byte'lık yerde yazılabilecek maksimum değer 65535'tir. Bu değeri 512 ile çarparsak 33MB'lık bir alan söz konusu olur. 
    Gerçekten de o devirlerde diskler 33MB'den daha yukarıda formatlanamıyordu. DOS 4.01'e kadar 33MB bir üst sınırdı. Ancak 
    DOS 4.01 ile birlikte bu toplam sektör sayısı geçmişe doğru uyum korunarak 4 byte yükseltildi. Dolayısıyla DOS 4.01 ve 
    sonrasında artık disk bölümünün toplam kapasitesi 2^32 * 2^9 = 2TB'ye yükselmiş oldu. 4 byte'tan oluşan yeni toplam sektör
    sayısı alanı boot sektörün "0x20" offset'inde bulunmaktadır. Dosya sistemleri toplam sektör sayısı için önce "0x13" offset'inde 
    bulunan bu alana başvurmaktadır. Eğer bu alanda 0 yoksa bu alandaki bilgiyi, eğer bu alanda 0 varsa "0x20" offset'inden çekilen 
    DWORD bilgiyi dikkate almaktadır.

    - Ortam Belirleyicisi (Media Descriptor): Bu alanda dosya sisteminin konuşlandığı medyanın türünün ne olduğu bilgisi bulunmaktadır. 
    Aslında artık böyle bir bilgi işletim sistemleri tarafından kullanılmamaktadır. Buradaki 1 byte'ın yaygın değerleri şunlardır:

    0xF0: 1.44 Floppy Disk
    0xF8: Hard disk

    Bu alanda artık hep F8 byte'ı bulunmaktadır.

    FAT'in Bir Kopyasındaki Sektör Sayısı: Bu alanda FAT'in bir kopyasının kaç sektör uzunluğunda olduğu bilgisi bulunmaktadır.
    FAT'in default olarak 2 kopyasının olduğunu anımsayınız.

    Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor): Bu alanda diskin bir yüzeyinde kaç sektör dilimi olduğu 
    bilgisi yer almaktadır. Eskiden sektörlerin koordinatları "yüzey numarası, track numarası ve sektör dilimi numarası"
    ile belirtiliyordu. Uzunca bir süredir artık bu sistem terk edilmiştir. Dolayısıyla bu alana başvurulmamaktadır.

    Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor): Burada diskte toplam kaç yüzey (kafa) olduğu bilgisi yer 
    alıyordu. Ancak yine koordinat sistemi uzunca bir süre önce değiştirildiği için bu alan artık kullanılmamaktadır.

    Saklı Sektörlerin Sayısı: Bu alanda FAT dosya sisteminin diskin toplamda kaçıncı sektöründen başladığı bilgisi yer 
    almaktadır. Bu bilgi aynı zamanda Disk Bölümleme Tablosu (Disk Partition Table) içerisinde de yer almaktadır. İşletim 
    sistemleri bu iki değeri karşılaştırıp BPB bloğunun bozuk olup olmadığı konusunda bir karar da verebilmektedir.

    Yeni Toplam Sektör Sayısı: "0x13" offset'indeki WORD olarak bulundurulan eski "toplam sektör sayısı" bilgisinin DWORD olarak
    yenilenmiş biçimi bu alanda tutulmaktadır.

    Volüm Seri Numarası: Bir disk bölümü FAT dosya sistemi ile formatlandığında oraya rastgele üretilmiş olan bir "volüm seri 
    numarası" atanmaktadır. Bu volüm seri numarası eskiden floppy disket zamanlarında disketin değişip değişmediğini anlamak 
    için kullanılıyordu. Bugünlerde artık bu alan herhangi bir amaçla kullanılmamaktadır. Ancak sistem programcısı bu seri 
    numarasından başka amaçlar için faydalanabilir.

    Volüm İsmi: Her volüm formatlanırken ona bir isim verilmektedir. Bu isim o zamanki dosya isimlendirme kuralı gereği 
    8 + 3 = 11 karakterden oluşmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                170. Ders 11/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemine ilişkin bir uygulama yazabilmek için yapılacak ilk şey boot sektörü okuyup buradaki BPB bilgilerini 
    bir yapı nesnesinin içerisine yerleştirmektir. Bu bilgilerden hareketle bizim FAT dosya sistemine ilişkin metadata 
    alanlarının ilgili disk bölümünün kaçıncı sektöründen başlayıp kaç sektör uzunluğunda olduğunu elde etmemiz gerekir. Çünkü
    dosya sistemi ile ilgili işlemlerin hepsinde bu bilgilere gereksinim duyulacaktır. Bu bilgilerin yerleştirileceği yapı 
    şöyle olabilir:

    typedef struct tagBPB {
        uint16_t fatlen;        /* Number of sectors in FAT (A) */
        uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
        uint16_t nfats;            /* Number of copies of FAT (A) */
        uint32_t tsects;        /* Total sector (A) */
        uint16_t bps;            /* Byte per sector(A) */
        uint16_t spc;            /* Sector per cluster(A) */
        uint16_t rsects;        /* Reserved sectors(A) */
        uint8_t mdes;            /* Media descriptor byte(A) */
        uint16_t spt;            /* Sector per track(A) */
        uint16_t rootents;        /* Root entry (A) */
        uint16_t nheads;        /* Number of heads (A) */
        uint16_t hsects;        /* Number of hidden sector( A) */
        uint16_t tph;            /* Track per head (NA) */
        uint16_t fatloc;        /* FAT directory location (NA) */
        uint16_t rootloc;        /* Root directory location (NA) */
        uint16_t dataloc;        /* First data sector location (NA) */
        uint32_t datalen;        /* Number of sectors in Data (NA) */
        uint32_t serial;        /* Volume Serial Number (A) */
        char vname[12];            /* Volume Name (A) */
    } BPB;

    Burada "A" (available) ile belirtilen elemanlar zaten BPB içerisinde olan elemanlardır. "NA" (not available) ile belirtilen 
    elemanlar BPB içerisinde yoktur. Dört işlemle hesaplanarak değeri oluşturulacaktır. Linux'ta boot sektör'ü okuyarak oradaki
    BPB bilgilerini yukarıdaki gibi bir yapıya yerleştiren örnek bir program aşağıda verilmiştir. Derlemeyi şöyle yapabilirsiniz:

    $ gcc -o app fatsys.c app.c

    Programı FAT dosya sistemine ilişkin blok aygıt dosyasının yol ifadesini vererek sudo ile çalıştırabilirsiniz. Örneğin:

    $ sudo ./app /dev/loop0

    Aşağıdakine benzer bir çıktı elde edilecektir:

    Byte per sector: 512
    Sector per cluster: 4
    Number of reserved sectors: 4
    Number of FAT copies: 100
    Number of sectors in Root Dir: 32
    Number of FAT copies: 2
    Number of sectors in volume: 100000
    Media Descriptor: F8
    Number of Root Dir entries: 200
    Number of hidden sectors: 0
    FAT location: 4
    Root Dir location: 204
    Data location: 236
    Volume Serial Number: BC7B-4578
    Volume Name: FAT16
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    BPB bpb;
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

     if ((fd = open(argv[1], O_RDWR)) == -1)
        return -1;

    if (read_bpb(fd, &bpb) == -1)
        exit_sys("read_bpb");

    printf("Byte per sector: %d\n", bpb.bps);
    printf("Sector per cluster: %d\n", bpb.spc);
    printf("Number of reserved sectors: %d\n", bpb.rsects);
    printf("Number of FAT copies: %d\n", bpb.fatlen);
    printf("Number of sectors in Root Dir: %d\n", bpb.rootlen);
    printf("Number of FAT copies: %d\n", bpb.nfats);
    printf("Number of sectors in volume: %u\n", bpb.tsects);
    printf("Media Descriptor: %02X\n", bpb.mdes);
    printf("Number of Root Dir entries: %02X\n", bpb.rootents);
    printf("Number of hidden sectors: %d\n", bpb.hsects);
    printf("FAT location: %d\n", bpb.fatloc);
    printf("Root Dir location: %d\n", bpb.rootloc);
    printf("Data location: %d\n", bpb.dataloc);
    printf("Number of sectors in Data: %d\n", bpb.datalen);
    printf("Volume Serial Number: %04X-%04X\n", bpb.serial >> 16, 0xFFFF & bpb.serial);
    printf("Volume Name: %s\n", bpb.vname);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örnekte FAT dosya sistemine ilişkin tüm önemli alanların yerlerine ve uzunluklarına ilişkin bilgileri 
    elde ederek bir yapıya yerleştirdik. Artık şu bilgilere sahibiz:

    - FAT bölümünün yeri ve uzunluğu (yapının fatloc ve fatlen elemanları)
    - Root DIR bölümünün yeri ve uzunluğu (yapının rootloc ve rootlen elemanları)
    - Data bölümünün yeri ve uzunluğu (yapının dataloc ve datalen elemanları)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                171. Ders 13/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi yukarıdaki yapıyı biraz daha geliştirelim. Bunun için dosya sistemini temsil eden aşağıdaki gibi bir yapı oluşturabiliriz:

    typedef struct tagFATSYS {
        int fd;             /* Volume file descriptor */
        BPB bpb;            /* BPB info */
        uint32_t fatoff;    /* Offset of FAT */
        uint32_t rootoff;   /* Offset of root directory */
        uint32_t dataoff;   /* Offset of DATA */
        uint32_t clulen;    /* Cluster length as bytes */
        /* ... */
    } FATSYS;

    Dosya işlemi yaparken dosya sisteminin belirli bölümlerine konumlandırma yapacağımız için onların offset'lerini de FATSYS 
    yapısının içerisine yerleştireceğiz.

    Dosya sistemini açan ve kapatan aşağıdaki fonksiyonlar oluşturabiliriz:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fd = open(path, O_RDWR)) == -1)
            return NULL;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if (read_bpb(fd, &fatsys->bpb) == -1) {
            free(fatsys);
            return NULL;
        }

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        return fatsys;
    }

    int close_fatsys(FATSYS *fatsys)
    {
        if (close(fatsys->fd) == -1)
            return -1;

        free(fatsys);

        return 0;
    }

    Kullanım şöyle olabilir:

    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    Aşağıda bu değişikliklerin yapıldığı kodlar verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde dosya sistemindeki "Data Bölümü" dosya içeriklerinin tutulduğu bölümdür. İşletim sistemi bu bölümün
    sektörlerden değil cluster'lardan oluştuğunu varsaymaktadır. Anımsanacağı gibi "cluster" bir dosyanın parçası olabilecek 
    en küçük tahsisat birimidir ve ardışıl n sektörden oluşmaktadır. Buradaki n değeri 2'nin bir kuvvetidir (yani 1, 2, 4, 
    8, ... biçiminde). İşte volümün Data bölümündeki her cluster'a 2'den başlanarak (0 ve 1 reserved bırakılmıştır) bir 
    cluster numarası karşı getirilmiştir. Örneğin bir cluster'ın 4 sektörden oluştuğunu düşünelim. Bu durumda Data bölümünün 
    ilk 4 sektörü 2 numaralı cluster, sonraki 4 sektörü 3 numaralı cluster, sonraki 4 sektörü 4 numaralı cluster biçiminde 
    numaralanmaktadır.

    Bizim FAT dosya sistemi üzerinde ilk yapmaya çalışacağımız alt seviye işlemlerden biri belli bir numaralı cluster'ı okuyup 
    yazan fonksiyonları gerçekleştirmektir. Bu fonksiyonların prototipleri şöyle olabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
    int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

    Data bölümünün ilk cluster'ının 2 numaralı cluster olduğunu 0 ve 1 cluster'larının kullanılmadığını anımsayınız. Bu 
    fonksiyonlar basit biçimde şöyle yazılabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return read(fatsys->fd, buf, fatsys->clulen);
    }

    int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return write(fatsys->fd, buf, fatsys->clulen);
    }

    Aşağıda fonksiyonun kullanımına ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        close(fd);
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if (read_cluster(fatsys, 2, buf) == -1)
        exit_sys("read_cluster");

    for (int i = 0; i < fatsys->clulen; ++i)
        printf("%02X%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                172. Ders 18/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde her dosya cluster'lara bölünerek Data bölümündeki cluster'larda tutulmaktadır. Dosyanın parçaları
    ardışıl cluster'larda olmak zorunda değildir. Örneğin bir cluster'ın 4 sektör olduğu bir volümde 10000 byte uzunluğunda 
    bir dosya söz konusu olsun. Bir cluster'ın boyutu 4 * 512 = 2048 byte'tır. O halde bu dosya 5 cluster yer kaplayacaktır. 
    Ancak son cluster'da kullanılmayan bir miktar boş alan da kalacaktır. İşte örneğin bu dosyanın cluster numaraları aşağıdaki
    gibi olabilir:

    2 8 14 15 21

    Görüldüğü gibi dosyanın parçaları ardışıl cluster'larda olmak zorunda değildir. Tabi işletim sistemi genellikle dosyanın 
    parçalarını mümkün olduğu kadar ardışıl cluster'larda saklamaya çalışır. Ancak bu durum mümkün olmayabilir. Belli bir süre 
    sonra artık dosyaların parçaları birbirinden uzaklaşmaya başlayabilir. İşte FAT dosya sisteminde hangi dosyanın hangi 
    parçalarının Data bölümünün hangi cluster'larında olduğunun saklandığı metadata alana FAT (File Allocation Table) denilmektedir.

    FAT bölümü FAT elemanlarından oluşur. FAT'ler 12 bit, 16 bit ve 32 bit olmak üzere üçe ayrılmaktadır. 12 bit FAT'lerde 
    FAT elemanları 12 bit, 16 bit FAT'lerde FAT elemanları 16 bit ve 32 bit FAT'lerde FAT elemanları 32 bit uzunluğundadır. 
    İlk iki cluster kullanılmadığı için FAT'in ilk iki elemanı da kullanılmamaktadır.

    FAT bağlı listelerden oluşan bir metadata alanıdır. Her dosyanın ilk cluster'ının nerede olduğu dizin girişinde tutulmaktadır. 
    Sonra her FAT elemanı dosyanın parçasının hangi cluster'da olduğu bilgisini tutar. Volümde toplan N tane cluster varsa
    FAT bölümünde de toplam N tane FAT elemanı vardır. FAT bölümünde her bir dosya için ayrı bir bağlı liste bulunmaktadır. 
    Bir dosyanın ilk cluster'ı biliniyorsa sonraki tüm cluster'ları bu bağlı liste izlenerek elde edilebilmektedir. Bağlı 
    listenin organizasyonu şu biçimdedir: Dosyanın ilk cluster'ının yerinin 8 olduğunu varsayalım. Şimdi FAT'in 8'inci 
    elemanına gidildiğinde orada 14 yazıyor olsun. 14 numaralı elemanına gittiğimizde orada 18 yazdığını düşünelim. 18 elemana 
    gittiğimizde orada 22 yazdığını düşünelim. Nihayet 22 numaralı elemana gittiğimizde orada FFFF biçiminde özel bir değerin 
    yazdığını varsayalım. Bu durumu şekilsel olarak şöyle gösterebiliriz:

    8 ---> 14 ---> 18 ---> 22 (FFFF)

    Bu durumda bu dosyanın cluster'ları sırasıyla 8 14 18 22 numaralı cluster'lardır. Burada FFFF değeri EOF anlamına özel bir 
    cluster numarasıdır. Yani FAT'teki her FAT elemanı dosyanın sonraki parçasının hangi cluster'da olduğunu belirtmektedir. 
    Böylece işletim sistemi dosyanın ilk cluster numarasını biliyorsa bu zinciri takip ederek onun bütün cluster'larını elde 
    edebilir.

    Örneğin 1 cluster'ın 4 sektör olduğu bir FAT16 sisteminde 19459 byte'lık bir dosya toplam 10 cluster yer kaplamaktadır. 
    Biz bu dosyanın ilk cluster numarasının 4 olduğunu biliyoruz. Aşağıdaki örnek FAT bölümünde bu dosyanın tüm cluster'larının 
    numaraları bağlı liste izlenerek elde edilebilecektir:

    00000800  f8 ff ff ff 00 00 ff ff  05 00 06 00 07 00 08 00  |................|
    00000810  09 00 0a 00 0b 00 0c 00  0d 00 ff ff 00 00 00 00  |................|
    00000820  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000840  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Bu byte'lar bir FAT16 sisteminin FAT bölümüne ilişkin olduğuna göre her bir FAT elemanı 2 byte yer kaplayacaktır. Burada 
    FAT elemanlarının hex karşılıkları şöyledir (Little Endian notasyon kullanıldığına dikkat ediniz):

    0        1      2      3      4      5      6      7      8      9      10     11     12     13
    <FFF8> <FFFF> <0000> <FFFF> <0005> <0006> <0007> <0008> <0009> <000A> <000B> <000C> <000D> <FFFF>

    Burada FAT elemanlarının numaralarını desimal sistemde elemanların yukarısına yazdık. Söz konusu dosyanın ilk cluster 
    numarasının 4 olduğunu bildiğimizi varsayıyoruz. 4 numaralı FAT elemanında 5 (0005) yazmaktadır. O halde dosyanın sonraki 
    cluster numarası 5'tir. 5 numaralı FAT elemanında 6 (0006) yazmaktadır. 6 numaralı FAT elemanında 7 (0007), 7 numaralı FAT 
    elemanında 8 (0008), 8 numaralı FAT elemanında 9 (0009), 9 numaralı FAT elemanında 10 (000A), 10 numaralı FAT elemanında 11 
    (000B), 11 numaralı FAT elemanında 12 (000C), 12 numaralı FAT elemanında 13 (000D), 13 FAT elemanında da özel değer olan 
    65535 (FFFF) bulunmaktadır. Bu özel değer zincirin sonuna gelindiğini belirtmektedir. Bu durumda bu dosyanın tüm parçaları 
    sırasıyla şu cluster'lardadır:

    4 5 6 7 8 9 10 11 12 13

    Burada işletim sisteminin dosyanın parçalarını diskte ardışıl cluster'lara yerleştirdiğini görüyorsunuz. Ancak bu durum 
    her zaman böyle olma zorunda değildir.

    16 bir FAT'te bir FAT elemanında bulunacak değerler şunlar olabilmektedir (değerler Little Endian olarak WORD'e dönüştürülmüştür):

    0000            Boş cluster
    0001            Kullanılmıyor
    0002 -  FFEF    Geçerli, sonraki cluster
    FFF0H - FFF6    Reserved cluster
    FFF7            Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FFF8 - FFFF     Son cluster
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki işletim sistemleri FAT bölümünü nasıl ele alıp işlemektedir? Aslında FAT bölümündeki sektörler zaten çok kullanıldığı 
    için işletim sisteminin aşağı seviyeli disk cache sisteminde bulunuyor durumda olurlar. Ancak işletim sistemleri genellikle 
    FAT elemanları temelinde de bir cache sistemi de oluşturmaktadır. Böylece bir cluster değeri verildiğinde eğer daha önce o 
    cluster ile işlemler yapılmışsa o cluster'ın sonraki cluster'ı hızlı bir biçimde elde edilebilmektedir.

    Biz burada volümü açtığımızda tüm FAT bölümünü okuyup FATSYS yapısının içerisine yerleştireceğiz. Sonra da ilk cluster 
    numarası bilinen dosyaların cluster zincirini elde eden bir fonksiyon yazacağız. open_fatsys fonksiyonunun yeni versiyonu 
    aşağıdaki gibi olabilir:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if ((fd = open(path, O_RDWR)) == -1)
            goto EXIT1;

        if (read_bpb(fd, &fatsys->bpb) == -1)
            goto EXIT2;

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
            goto EXIT2;

        if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
            goto EXIT3;

        if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
            goto EXIT3;

        return fatsys;
    EXIT3:
        free(fatsys->fat);
    EXIT2:
        close(fd);
    EXIT1:
        free(fatsys);

        return NULL;
    }

    İlk cluster numarası bilinen dosyanın cluster zincirini elde eden fonksiyon da aşağıdaki gibi yazılabilir:

    uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            clu = *(uint16_t *)(fatsys->fat + clu * 2);
        } while (clu < 0xFFF8);
        *count = n;

        return chain;
    }

    Bu fonksiyonda dosyanın cluster zinciri için uint16_t türünden dinamik büyütülen bir dizi oluşturulmuştur. Dizi eski 
    uzunluğunun iki katı olacak biçimde büyütülmektedir. Fonksiyon bize hem cluster zincirini vermekte hem de bu zincirin 
    uzunluğunu vermektedir.

    Aşağıda tüm kodlar bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT3;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT3;

    return fatsys;

EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of clusters in file: %u\n", count);
    for (uint16_t i = 0; i < count; ++i)
        printf("%u  ", chain[i]);
    printf("\n");

    freeclu_chain(chain);

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                173. Ders 20/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdi ilk cluster'ını bildiğimiz bir text dosyanın içeriğini yazdırmak isteyelim. Bunun için önce getclu_chain16 
    fonksiyonunu çağırırız. Sonra read_cluster fonksiyonu ile cluster'ları okuyup içini yazdırabiliriz. Ancak burada şöyle 
    bir sorun vardır: Dosyanın son cluster'ı tıka basa dolu değildir. Orada dosyaya dahil olmayan byte'lar da vardır. İşletim 
    sistemi dosyanın uzunluğunu elde edip son cluster'daki dosyaya dahil olmayan kısmı belirleyebilmektedir.

    Aşağıda ilk cluster'ı bilinen bir text dosyanın yazdırılmasına yönelik bir örnek verilmiştir. Burada dosyanın son cluster'ındaki
    dosyaya ait olmayan kısım da yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    for (uint16_t i = 0; i < count; ++i) {
        if (read_cluster(fatsys, chain[i], buf) == -1)
            exit_sys("read_cluster");
        for (int i = 0; i < fatsys->clulen; ++i)
            putchar(buf[i]);
    }

    freeclu_chain(chain);
    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                174. Ders 25/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sisteminin dosya sistemi bize aslında cluster'larda olan dosya parçalarını "dosya" adı altında ardışıl byte 
    topluluğu gibi göstermektedir. Biz işletim sisteminin sistem fonksiyonu ile dosyayı açarız ve read fonksiyonu ile okumayı
    yaparız. Bütün diğer işlemler işletim sisteminin çekirdek kodları tarafından yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda 16 bit FAT için işlemler yaptık. Peki 12 bit ve 32 bit FAT bölümü nasıldır? 32 bit FAT önemli bir farklılığa 
    sahip değildir. Her FAT elemanı 32 bit yani 4 byte uzunluktadır. Dolayısıyla daha büyük bir volüm için kullanılabilir. 
    16 bit FAT'te toplam 65536 FAT elemanı elemanı olabilir (Bazılarının kullanılmadığını da anımsayınız.) Bir cluster en fazla
    64 sektör uzunluğunda olabilmektedir. Bu durumda FAT16 sistemlerinde volümün maksimum uzunluğu 2^16 * 2^6 * 2^9 = 2GB.

    12 bit FAT'ler biraz daha karmaşık görünümdedir. 12 bit 8'in katı değildir ve 3 hex digitle temsil edilmektedir. Bu nedenle
    12 bit FAT'te FAT zinciri izlenirken dikkat edilmelidir. Eğer volüm küçükse (eskiden floppy diskler vardı ve onlar çok 
    küçüktü) FAT12 sistemi FAT tablosunun daha az yer kaplamasını sağlamaktadır.

    FAT12 sisteminde bir FAT elemanı 12 bit olduğu için FAT bölümünde en fazla 2^12 = 4096 FAT elemanı olabilir. Microsoft
    kendi format programında FAT12 volümlerinde bir cluster'ı maksimum 8 sektör olarak almaktadır. Bu durumda FAT12 volümü 
    maksimum 2^12 * 2^3 * 2^9 = 2^24 = 16MB olabilmektedir. Başka bir deyişle Microsoft 16MB'nin yukarısındaki volümleri FAT12
    olarak formatlamamaktadır.

    Aşağıda 12 bit FAT tablosunun baş kısmı görülmektedir:

    00000200  f8 ff ff 00 40 00 05 60  00 07 80 00 09 a0 00 0b  |....@..`........|
    00000210  c0 00 ff 0f 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000220  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000240  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000250  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000270  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    12 bit'in 3 hex digit yani 1.5 byte olduğuna dikkat ediniz. Buradaki 12 bit şöyle elde edilmektedir. Cluster numarası önce 1.5 
    ile çarpılır ve noktalı kısım atılır. (Bu işlem 3 ile çarpılıp 2'ye bölünme biçiminde yapılabilir.) Elde edilen offset'ten WORD 
    bilgi çekilir. Eğer cluster numarası çiftse yüksek anlamlı 4 bit atılır, eğer cluster numarası tek ise düşük anlamlı 4 bit atılır. 
    Yüksek anlamlı 4 bit'in atılması 0x0FFF ile "bit and" işlemi uygulanarak, düşük anlamlı 4 bit'in elde edilmesi sayının 4 kez sağa 
    ötelenerek yapılabilir. Örneğin yukarıdaki FAT bölümünde biz 4 numaralı cluster'ın değerini elde edecek olalım. 4 * 1.5 = 6'dır. 
    6'ıncı offset'ten WORD çekilirse 0x6005 değeri elde edilir. Yüksek anlamı 4 bit atıldığında ise 0x005 değeri elde edilecektir. 
    Şimdi 5 numaralı cluster'ın değerini elde etmek isteyelim. Bu durumda 5 * 1.5 = 7.5 olur. Noktadan sonraki kısım atılırsa 7 elde 
    edilir. 7'nci offset'ten WORD çekildiğinde 0x0060 değeri elde edilecektir. Bu değerin de düşük anlamlı 4 biti atıldığında 0x006 
    değeri elde edilir.

    12 bit FAT sisteminde bir FAT elemanın alabileceği değerler de şöyledir:

    000             Boş cluster
    001             Kullanılmıyor
    002 - FEF       Geçerli, sonraki cluster
    F0H - FF6       Reserved cluster
    FF7             Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FF8 - FFF       Son cluster

    12 bit FAT tablosunda ilk cluster değeri bilinen dosyanın cluster zincirlerini elde etmek için aşağıdaki gibi bir fonksiyon 
    yazılabilir.

    uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, word, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
            clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
        } while (clu < 0xFF8);
        *count = n;

        return chain;
    }

    Fonksiyonda 12 bit FAT değerinin elde edilmesi şöyle yapılmıştır:

    clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                175. Ders 27/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT32 sisteminde her FAT elemanı 32 bittir. Ancak bu sistemde boot sektördeki BPB alanında da farklılıklar vardır. Bu nedenle
    32 bit FAT sistemi FAT12 ve FAT16 ile tam uyumlu değildir. FAT32 için bazı fonksiyonların yeniden yazılması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz FAT dosya sisteminin boot sektörünü, FAT ve Data bölümlerini ele aldık. Ele almadığımız tek bölüm "Root Dir" bölümüdür. 
    Şimdi "Root Dir" bölümü ve dosya bilgilerinin nasıl saklandığı konusu üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Microsoft'un FAT dosya sisteminde ve UNIX/Linux sistemlerinde kullanılan i-node tabanlı dosya sistemlerinde dizinler de 
    tamamen bir dosya gibi organize edilmektedir. Yani dizinler de aslında birer dosyadır. Bir dosyanın içerisinde o dosyanın 
    bilgileri bulunurken bir dizin dosyasının içerisinde o dizindeki dosyalara ilişkin bilgiler bulunmaktadır. Yani dizinler 
    aslında "o dizindeki dosyaların bilgilerini içeren dosyalar" gibidir. Bir dizin dosyası "dizin girişlerinden (directory 
    entry) oluşmaktadır. FAT12 ve FAT16 dosya sistemlerinde bir dizin dosyasındaki dizin girişleri 32 byte uzunluğundaydı. 
    Yani dizin dosyaları 32 byte'lık kayıtların peşi sıra gelmesiyle oluşuyordu. O zamanlarda DOS sistemlerinde bir dosyanın 
    ismi için en fazla 8 karakter, uzantısı için de en fazla 3 karakter kullanılabiliyordu. Dolayısıyla 32 byte'lık dizin 
    girişlerinin 1 byte'ı dosyanın ismi için ayrılmıştı. Sonra Microsoft dosya isimlerini 8+3 formatından çıkartarak onların 
    255'e kadar uzatılmasını sağladı. Ancak bunu yaparken de geçmişe doğru uyumu korumak için birden fazla 32 byte'lık dizin
    girişleri kullandı. Biz önce burada klasik 8+3'lük dizin girişlerinin formatını göreceğiz.

    32 byte'lık klasik dizin girişi formatı şöyledir:

    Offset (Hex)                    Uzunluk                     Anlamı

    00                              8 Byte                      Dosya İsmi (File Name)
    08                              3 Byte                      Dosya Uzantısı (Extension)
    0B                              BYTE                        Dosya Özelliği (Attribute)
    0C                              BYTE                        Kullanılmıyor (Reserved)
    0D                              BYTE                        Yaratılma Zamanının Milisaniyesi
    0E                              WORD                        Dosyanın Yaratılma Zamanı (Creation Time)
    10                              WORD                        Dosyanın Yaratılma Tarihi (Creation Date)
    12                              WORD                        Son Okunma Zamanı (Last Access Time)
    14                              WORD                        Kullanılmıyor (Reserved)
    16                              WORD                        Son Yazma Zamanı (Last Write Time)
    18                              WORD                        Son Yazma Tarihi (Last Write Date)
    1A                              WORD                        İlk Cluster Numarası (First Cluster)
    1C                              DWORD                       Dosyanın Uzunluğu (File Length)

    Aşağıda "x.txt" dosyasının ve "mydir" dizininin 32 byte'lık dizin girişleri görülmektedir.

    58 20 20 20 20 20 20 20  54 58 54 20 00 0b 5d 92  |X       TXT ..].|
    59 59 59 59 00 00 5d 92  59 59 0e 00 0f 00 00 00  |YYYY..].YY......|

    4d 59 44 49 52 20 20 20  20 20 20 10 00 7a f0 96  |MYDIR      ..z..|
    59 59 59 59 00 00 f0 96  59 59 10 00 00 00 00 00  |YYYY....YY......|

    - Dosya İsmi: 32'lik dizin girişlerinin ilk 8 byte'ı dosya isminden oluşmaktadır. Eğer dosya ismi 8 karakterden kısa 
    ise SPACE karakterleriyle (0x20) padding yapılmaktadır. Klasik FAT16 ve FAT12 sistemlerinde dosya isimlerinin ve uzantılarının
    büyük harf - küçük harf duyarlılığı yoktur. Tüm dosyalar bu sistemlerde "büyük harfe dönüştürülerek" dizin girişlerinde 
    tutulmaktadır.

    - Dosya Uzantısı: Dosya uzantısı en fazla 3 karakterden oluşmaktadır. Eğer 3 karakterden kısa ise SPACE karakterleriyle (0x20)
    padding yapılmaktadır.

    - Dosya Özelliği: Bu alanda dosyanın özelliklerine ilişkin bir bit alanı bulundurulmaktadır. Buradaki her bit'in bir 
    anlamı vardır. Özellik byte'ı aşağıdaki bitlerden oluşmaktadır:

    +------------+------------+------------+------------+------------+------------+------------+------------+
    |     7      |     6      |     5      |     4      |     3      |     2      |     1      |     0      |
    +------------+------------+------------+------------+------------+------------+------------+------------+
    |  Reserved  |  Reserved  |  Archive   |    Dir     |   VLabel   |   System   |   Hidden   |  ReadOnly  |
    +------------+------------+------------+------------+------------+------------+------------+------------+

    Eğer ReadOnly biti 1 ise dosya "read-only" biçimdedir. Böyle dosyalara işletim sistemi yazma yapmaz. Hidden biti 1 ise 
    dosya "dir" komutu uygulandığında görüntülenmez. DOS işletim sisteminin kendi dosyalarını System özelliği ile vurgulamaktadır. 
    Yani eğer bir dosya işletim sistemine ilişkin bir dosya ise System biti 1 olur.

    Volüm isimleri boot sektörün yanı sıra kök dizinde bir dosya ismi gibi de tutulmaktadır. Böyle girişlerin VLabel biti 
    1 olur. Eğer bir dizin söz konusu ise Dir biti 1 olmaktadır. FAT dosya sisteminde normal dosyalara "Archive" dosyaları 
    denilmektedir. Bu nedenle bu bit hemen her zaman 1 olarak görülür. Aşağıda "x.txt" ve "mydir" dizin girişlerine ilişkin 
    özellik byte'ının bitleri görülmektedir:

    x.txt (0x20)        0 0 1 0 0 0 0 0
    mydir (0x10)        0 0 0 1 0 0 0 0

    "x.txt" dosyasının özellik bitlerinden yalnızca Archive biti set edilmiştir. "mydir" dizinin de yalnızca "Dir" biti set 
    edilmiştir. İşletim sistemi bir dizin girişinin normal bir dosyaya mı yoksa bir dizin dosyasına mı ilişkin olduğunu özellik
    byte'ının 4 numaralı bitine bakarak tespit etmektedir.

    - Tarih ve Zaman Bilgileri FAT12 ve FAT16 dosya sistemlerinde 2 byte ile kodlanmaktadır. Eskiden DOS sistemlerinde dosyanın 
    yaratılma tarihi, zamanı ve son okunma tarihi tutulmazdı. Bu alanlar "reserved" durumdaydı. Sonra Microsoft bu alanları bu 
    amaçla kullanmaya başladı. Tarih bilgisi byte içerisinde bitsel düzeyde tutulmaktadır. Tarih bilgisinin tutuluş formatı
    şöyledir:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
    y  y  y  y  y  y  y m m m m d d d d d 

    Burada WORD değerin düşük anlamlı 5 biti gün için, sonraki 4 biti ay için ve geri kalan 7 biti yıl için bulundurulmuştur. 
    Tarih bilgisinin yıl alanı için 7 bit ayrıldığına göre buraya nasıl 2024 gibi bir tarih yerleştirilebilmektedir. İşte DOS
    işletim sisteminin ilk versiyonu 1980 yılında oluşturulduğu için buradaki tarih bilgisi her zaman 1980 yılından itibaren 
    bir offset belirtmektedir. Yani örneğin 2024 yılı için buradaki yıl bitlerine 44 kodlanmaktadır. Örneğin bir dosyanın 32'lik
    dizin girişi şöyledir:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Buradaki 0x18'inci offset'ten little endian formatta WORD çekersek 0x5959 değerini elde ederiz. Şimdi bu WORD değeri 2'lik
    sistemde ifade edelim:

    5         9       5       9
    0101    1001    0101    1001

    Şimdi de yukarıda belirttiğimiz gibi sayıyı bit'lerine ayrıştıralım:

    0101100 => 44    1010 => 10     11001 => 25
      yıl             ay             gün

    O halde buradaki tarih 25/10/2024'tür.

    16 bitle (WORD ile) zaman bilgisi de şöyle kodlanmıştır:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
     h  h  h  h  h  m m m m m m s s s s s

    Burada bir noktaya dikkat ediniz: 0 ile 24 arasındaki saatler 5 bit ile tutulabilir. 0 ile 60 arasındaki dakikalar ise 
    ancak 6 bit ile tutulabilir. Burada geriye 5 bit almıştır. Dolayısıyla saniyeleri tutmak için bu 5 bit yeterli değildir. 
    İşte FAT dosya sistemini tasarlayanlar saniyedeki duyarlılığı azaltarak saniye değerinin yarısını buraya yazılması yoluna
    gitmişlerdir. Yani zaman bilgisinin saniye kısmı eski FAT12 ve FAT16 sistemlerinde tam duyarlılıkla tutulamamaktadır. 
    Örneğin yukarıdaki dizin girişinde dosyanın son değiştirilme zamanı için 0x16'ıncı offset'ten WORD çektiğimizde 0xB309
    değerini elde ederiz. Şimdi bu değeri 2'lik sisteme dönüştürelim:

     B       3       0       9
    1011    0011    0000    1001

    Şimdi de bit alanlarını ayrıştıralım:

    10110 => 22     011000 => 24    01001 => 9
      saat            dakika          saniye

    Burada işletim sistemi saniye alanına mevcut saniyenin yarısını yazdığına göre bu dosyanın değiştirilme zamanı 22:24:18
    olacaktır.

    Burada küçük bir noktaya dikkatinizi çekmek istiyoruz: Eskiden dizin girişinin 0x0D numaralı BYTE'ı da "reserved" durumdaydı
    sonra bu byte'a dosyanın yaratılma zamanına ilişkin milisaniye değeri yerleştirildi. Dolayısıyla artık dosyanın yaratılma 
    zamanı saniye duyarlılığında ifade edilebilmektedir. Bu durumda yaratılma zamanındaki saniye 2 ile çarpılıp buradaki 
    milisaniye ile toplanmaktadır. Tabii genel olarak Microsoft'un arayüzü dosyaların zaman bilgilerinin saniyelerini default
    durumda zaten göstermemektedir. Örneğin:

    D:\>dir
    Volume in drive D is YENI BIRIM
    Volume Serial Number is 2C68-EBFD

    Directory of D:\

    25.10.2024  22:24                27 x.txt
    25.10.2024  22:26                 8 con
    25.10.2024  22:26                59 y.txt
    25.10.2024  22:28    <DIR>          mydir
                   3 File(s)             94 bytes
                1 Dir(s)      52.194.304 bytes free

    - İlk Cluster Numarası: Biz daha önce FAT bölümünü incelerken bir dosyanın cluster zincirini elde edebilmek için onun 
    ilk cluster numarasının bilinmesi gerektiğini belirtmiştik. (Bir bağlı listeyi dolaşabilmek için onun ilk düğümünün yerinin
    bilinmesi gerektiğini anımsayınız.) İşte bir dosyanın ilk cluster numarası dizin girişinde saklanmaktadır. Yani işletim 
    sistemi önce dosyanın dizin girişini bulmakta sonra FAT'ten onun cluster zincirini elde etmektedir. Yukarıdaki dosyanın 
    dizin girişini yeniden veriyoruz:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Burada söz konusu dosyanın ilk cluster numarası dizin girişinin 0x1A offsetinden başlayan WORD bilgidir. Bu bilgiyi örnek
    dizin girişinden çektiğimizde 0x006 değerini elde ederiz. Bu durumda bu dosyanın ilk cluster numarası 6'dır.

    - Dosyanın Uzunluğu: Dosyanın uzunluğu dizin girişindeki son 4 byte'lık (DWORD alan) alanda tutulmaktadır. İşletim sistemi
    dosyanın son cluster'ındaki geçerli byte sayısını bu uzunluktan yararlanarak elde etmektedir. Örneğin yukarıdaki dizin 
    girişine ilişkin dosya uzunluğu 0x0000001B = 27'dir. Dizin dosyalarına ilişkin uzunluklar için işletim sistemi hep 0 
    değerini yazmaktadır.

    Dizinler de bir dosya gibi ele alınmaktadır. Dolayısıyla dizinlerin de bir cluster zinciri vardır. Ancak FAT12 ve FAT16
    sistemlerinde kök dizinin yeri ve uzunluğu baştan bellidir. Kök dizin için bir cluster zinciri yoktur. FAT32 dosya sisteminde
    kök dizin de normal bir dizin gibi büyüyebilmektedir. Yani kök dizinin de bir cluster zinciri vardır.

    32'lik bir dizin girişini aşağıdaki gibi bir yapıyla temsil edebiliriz:

    #pragma pack(1)

    typedef struct tagDIR_ENTRY {
        unsigned char name[8];
        unsigned char ext[3];
        uint8_t attr;
        char reserved1[1];
        uint8_t crtime_ms;
        uint16_t crdate;
        uint16_t crtime;
        uint16_t rdtime;
        char reserved2[2];
        uint16_t wrtime;
        uint16_t wrdate;
        uint16_t fclu;
        uint32_t size;
    } DIR_ENTRY;

    #pragma pack()
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki bir dosya silindiğinde ne olur? İşletim sistemi FAT dosya sisteminde bir dosya silindiğinde iki işlem yapar:

    1) Dosyanın silindiğinin anlaşılması için dizin girişindeki dosya isminin ilk karakteri 0xE5 olarak değiştirir. Böylece 
    dizin girişlerini tararken 32'lik girişin ilk karakteri 0xE5 ise o dizin girişini silindiği gerekçesiyle atlamaktadır. 
    Ancak işletim sistemi bu 32'lik dizin girişinin diğer byte'larına dokunmamaktadır.

    2) İşletim sistemi dosyanın cluster zincirini de sıfırlamaktadır. Böylece bu dosyanın FAT'te kapladığı alan artık "boş" 
    gözükecektir. Ancak işletim sistemi dosyanın Data bölümündeki cluster'ları üzerinde herhangi bir işlem yapmaz.

    Peki FAT dosya sisteminde "undelete" yapan programlar nasıl çalışmaktadır? İşte bu programlar dosyanın dizin girişine 
    bakıp onun ilk cluster'ının numarasını elde edip FAT bölümünde tersine bir algoritmayla onun cluster zincirini yeniden 
    oluşturmaya çalışmaktadır. Ancak böyle bir kurtarmanın garantisi yoktur. Çünkü işletim sistemi boşaltılmış cluster'ları 
    başka bir dosya için tahsis etmiş olabilir. Ya da FAT'teki cluster zincirini tahmin eden programlar bu konuda yanılabilmektedir. 
    Ancak ne olursa olsun dosyanın ilk karakteri silindiği için bu karakter kurtarma sırasında kullanıcıya sorulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                176. Ders 01/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT12 ve FAT16 sistemlerinin orijinali yalnızca 8+3'lük dosya isimlerini destekliyordu. Yani bir dosyanın ismi en fazla 
    8 karakterden, uzantısı da en fazla 3 karakterden oluşabiliyordu. 90'lı yılların ortalarına doğru Microsoft FAT dosya 
    sisteminde uzun dosya isimlerinin de kullanılmasına olanak sağlamıştır. Microsoft bunu yaparken geçmişe doğru uyumu 
    mümkün olduğunca korumaya da çalışmıştır. Microsoft'un bu yeni düzenlemesinde 8+3'ten daha uzun dosya isimleri birden fazla
    32'lik girişle temsil edilmektedir. Ancak Microsoft geçmişe doğru uyumu korumak için her uzun dosya isminin bir de 8+3'lük
    kısa ismini oluşturmak istemiştir. Bu durumda uzun dosya isimlerinin kullanıldığı FAT sistemlerinde 8+3'lük alana sığmayan 
    dosya isimleri aşağıdaki formata göre dizin girişlerinde bulundurulmaktadır:

    <32'lik giriş>
    <32'lik giriş>
    ...
    <32'lik giriş>
    <dosyanın 8+3'lük kısa ismi>

    Tabii eğer istenirse (örneğin Linux böyle yapmaktadır) 8+3'lük sınıfı aşmayana dosyalar da sanki uzun isimli dosyalarmış gibi 
    saklanabilmektedir. Burada dosyanın 8+3'lük kısa isminin dışındaki uzun ismi de 32'lik girişlerde ASCII olarak değil, UNICODE
    olarak tutulmaktadır.

    Uzun dosya isimlerine ilişkin girişlerin sonunda 8+3'lük kısa bir girişin de bulundurulduğunu belirtmiştik. Peki bu uzun dosya 
    isminden kısa giriş nasıl elde edilmektedir?

    Uzun dosya isimlerinin tutulduğu 32'lik girişlerin ilk byte'ında önemli bilgiler vardır. Bu byte'a "sıra numarası (sequence 
    number)" denilmektedir. Bu byte bit bit anlamlandırılmaktadır. Byte'ın bitlerinin anlamları şöyledir:

    D L X X X X X X

    Burada en yüksek anlamlı bit olan D biti 32'lik girişin silinip silinmediğini anlatmaktadır. Eğer bu giriş silinmişse bu
    bit 1, silinmemişse 0 olacaktır. 7 numaralı bit (L biti) 32'lik girişlerin aşağıdan yukarıya doğru son giriş olup olmadığını 
    belirtmektedir. Geri kalan 6 bit 32'lik girişlerin sıra numarasını belirtir. Yani her 32'lik girişin bir sıra numarası vardır. 
    Her 32'lik giriş uzun dosya isminin 13 UNICODE karakterini tutmaktadır. Peki biz 32'lik bir girişin eski kısa ismine ilişkin 
    32'lik bir giriş mi yoksa uzun ismin 32'lik girişlerinden biri mi olduğunu nasıl anlayabiliriz? İşte bunun için 32'lik 
    girişin 0x0B offset'inde bulunan özellik byte'ının düşük anlamlı 4 bitine bakmak gerekir. Eğer bu 4 bitin hepsi 1 ise 
    bu 32'lik giriş uzun dosya isminin 32'lik girişlerinden biridir.

    Aşağıda uzun dosya isimlerine ilişkin 32'lik girişlerin genel formatı verilmiştir. Ayrıntılı format için Microsoft'un 
    "FAT File System Specification" dokümanına başvurabilirsiniz.

    Field name        Offset    Size    Description
    LDIR_Ord        0        1        Sequence number (1-20) to identify where this entry is in the sequence of LFN entries to 
                                    compose an LFN. One indicates the top part of the LFN and any value with LAST_LONG_ENTRY 
                                    flag (0x40) indicates the last part of the LFN.
    LDIR_Name1        1        10        Part of LFN from 1st character to 5th character.
    LDIR_Attr        11        1        LFN attribute. Always ATTR_LONG_NAME and it indicates this is an LFN entry.
    LDIR_Type        12        1        Must be zero.
    LDIR_Chksum        13        1        Checksum of the SFN entry associated with this entry.
    LDIR_Name2        14        12        Part of LFN from 6th character to 11th character.
    LDIR_FstClusLO    26        2        Must be zero to avoid any wrong repair by old disk utility.
    LDIR_Name3        28        4        Part of LFN from 12th character to 13th character.

    Biz sonraki örneklerde uzun dosya isimlerini dikkate almayacağız. Onları geçeceğiz. Aşağıda kök uzun dosya isimlerinin 
    ve silinmiş dosya isimlerinin geçilerek kök dosya sistemindeki dosyaların listesini elde eden bir fonksiyon verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8
#define ROOT_DEF_CAPACITY        8
#define DIR_ENTRY_SIZE            32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    uint8_t *rootdir;        /* Root sectors */
    /* ... */
} FATSYS;

#pragma pack(1)

typedef struct tagDIR_ENTRY {
    unsigned char name[8];
    unsigned char ext[3];
    uint8_t attr;
    char reserved1[1];
    uint8_t crtime_ms;
    uint16_t crdate;
    uint16_t crtime;
    uint16_t rdtime;
    char reserved2[2];
    uint16_t wrtime;
    uint16_t wrdate;
    uint16_t fclu;
    uint32_t size;
} DIR_ENTRY;

#pragma pack()

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);
DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if ((fatsys->rootdir = (uint8_t *)malloc(fatsys->bpb.rootlen * fatsys->bpb.bps)) == NULL)
        goto EXIT3;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    if (lseek(fatsys->fd, fatsys->rootoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->rootdir, fatsys->bpb.rootlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    return fatsys;

EXIT4:
    free(fatsys->rootdir);
EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, word, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
        clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
    } while (clu < 0xFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count)
{
    DIR_ENTRY *dent, *temp;
    DIR_ENTRY *dents;
    uint32_t capacity;
    uint16_t n;

    if ((dents = (DIR_ENTRY *)malloc(DIR_ENTRY_SIZE * ROOT_DEF_CAPACITY)) == NULL)
        return NULL;

    n = 0;
    capacity = ROOT_DEF_CAPACITY;
    dent = (DIR_ENTRY *)fatsys->rootdir;
    for (uint16_t i = 0; i < fatsys->bpb.rootents; ++i) {
        if (dent[i].name[0] == 0)
            break;
        if (dent[i].name[0] == 0xE5 || (dent[i].attr & 0XF) == 0x0F)
            continue;

        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(dents, DIR_ENTRY_SIZE * capacity )) == NULL) {
                free(dents);
                return NULL;
            }
            dents = temp;
        }
        dents[n++] = dent[i];
    }
    *count = n;

    return dents;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    uint16_t count;
    uint16_t *chain;
    DIR_ENTRY *dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((dents = get_rootents(fatsys, &count)) == NULL) {
        fprintf(stderr, "cannot get root entries!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < count; ++i) {
        for (int k = 0; k < 8; ++k)
            if (dents[i].name[k] != ' ')
                putchar(dents[i].name[k]);

        if (dents[i].ext[0] != ' ')
                putchar('.');
        for (int k = 0; k < 3; ++k)
            if (dents[i].ext[k] != ' ')
                putchar(dents[i].ext[k]);

        putchar('\n');
    }

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                177. Ders 03/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi bir dizin dosyası içerisindeki 32'lik girişlerini gözden geçirirken dosya isminin ilk karakterini '\0' 
    karakter olarak gördüğünde (yani sayısal 0 değeri) işlemini sonlandırmaktadır. Yani dizin dosyası içerisindeki bütün 
    girişlerin gözden geçirilmesine gerek yoktur. Yukarıda da belirttiğimiz gibi dosya isminin ilk karakteri 0xE5 ise işletim 
    sistemi bu 32'lik girişi de silinmiş dosya olduğu gerekçesiyle geçmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde bir yol ifadesi verildiğinde o yol ifadesinin hedefindeki dosya ya da dizine ilişkin dizin girişinin 
    elde edilmesine "yol ifadelerinin çözümlenmesi (pathname resolution)" denilmektedir. Yol ifadelerinin çözümlenmesi eğer 
    yol ifadesi mutlaksa kök dizinden itibaren, göreli ise prosesin çalışma dizininden itibaren yapılmaktadır. Örneğin FAT 
    dosya sistemine ilişkin "\a\b\c\d.dat" biçiminde bir yol ifadesi verilmiş olsun. Burada hedeflenen "d.dat" dosyasına ilişkin 
    dizin girişi bilgileridir. Ancak bunun için önce kök dizinde "a" girişi, sonra "a" dizininde "b" girişi, sonra "b" dizininde 
    "c" girişi sonra da "c" girişinde "d.dat" girişi bulunmalıdır. Tabii biz burada Windows'taki bir yol ifadesini temel aldık. 
    UNIX/Linux sistemlerinde dosya sistemleri mount edildiği için bu yol ifadesi aslında mount noktasına görelidir.

    İşletim sistemleri bir yol ifadesini çözümlerken yol ifadesindeki tüm yol bileşenlerine ilişkin dizin giriş bilgilerini de 
    bir cache sisteminde saklamaktadır. İşletim sistemlerinin oluşturduğu bu cache sistemine "directory entry cache" ya da kısaca 
    "dentry cache" denilmektedir. Örneğin programcı aşağıdaki gibi bir yol ifadesi kullanmış olsun:

    "\a\b\c\d.dat"

    İşletim sistemi buradaki "a", "b", "c" ve "d.dat" dosyalarına ilişkin dizin giriş bilgilerini bir cache sisteminde saklamaktadır. 
    Böylece benzer yol ifadeleri için hiç disk okuması yapılmadan bu cache sisteminden bu bilgiler elde edilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki FAT dosya sistemi için yol ifadelerini çözen basit yalın bir kodu nasıl yazabiliriz? Bizim bir yol ifadesi verildiğinde 
    o yol ifadesini parse edip oradaki yol bileşenlerini elde edebilmemiz gerekir. Sonra dizinler bir dosya olduğuna göre dizinlere 
    ilişkin cluster zincirinde diğer bileşenin aranması gerekir. İşlemler böyle devam ettirilir. FAT dosya sistemi için yol 
    ifadesini çözümleyen bir fonksiyonun parametrik yapısı şöyle olabilir:

    int resolve_path(FATSYS *fatsys, const char *path, DIRECTORY_ENTRY *de);

    Biz mutlak yol ifadelerini çözümleyecek olalım. Her dizinin bir cluster zinciri vardır. Ancak FAT12 ve FAT16 sistemlerinde 
    kök dizinin bir cluster zinciri yoktur. Kök dizinin yeri ve uzunluğu baştan bellidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                178. Ders 08/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde i-node tabanlı dosya sistemleri kullanılmaktadır. i-node tabanlı dosya sistemlerinin temel 
    organizasyonu FAT dosya sistemlerinden oldukça farklıdır. i-node tabanlı dosya sistemlerinin çeşitli varyasyonu vardır. 
    Linux sistemleri ve BSD sistemleri ağırlıklı olarak "ext (extended file system)" denilen dosya sistemini kullanmaktadır.
    "ext" dosya sistemi ilk kez 1992 yılında tasarlanmıştır. Sonra zaman içerisinde bu dosya sisteminin ext2, ext3 ve ext4 biçiminde 
    çeşitli varyasyonları oluşturulmuştur. Bugün artık genellikle bu ailenin son üyesi olan ext4 dosya sistemi kullanılmaktadır. 
    Ancak yukarıda da belirttiğimiz gibi i-node tabanlı dosya sistemleri bir aile belirtmektedir. Bu ailenin FAT sistemlerinde 
    olduğu gibi genel tasarımı birbirine benzerdir. Biz burada ext dosya sisteminin en uzun süre kullanılan versiyonu olan 
    ext konusunda temel bilgiler vereceğiz. ext2 dosya sisteminin resmi dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://cscie28.dce.harvard.edu/lectures/lect04/6_Extras/ext2-struct.html
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ext2 dosya sistemi üzerinde incelemeler ve denemeler yapmak için yine loop aygıtlarından faydalanabilirsiniz. Bunun için 
    yine önce içi sıfırlarla dolu bir dosya oluşturulur:

    $ dd if=/dev/zero of=ext2.dat bs=512 count=400000

    Sonra loop aygıt sürücüsü bu dosya için hazırlanır:

    $ sudo losetup /dev/loop0 ext2.dat

    Artık aygıt formatlanabilir:

    $ mkfs.ext2 /dev/loop0

    Mount işlemi aşağıdaki gibi yapılabilir:

    $ mkdir ext2
    $ sudo /dev/loop0 ext2
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    i-node tabanlı dosya sistemlerinde volüm kabaca aşağıdaki bölümlere ayrılmaktadır:

    <boot block>>
    <super block>
    <i-node block>
    <data block>

    Boot blok (boot block) işletim sistemini boot eden kodların bulunduğu bloktur. Süper blok (super block) FAT dosya sistemlerindeki 
    boot sektör BPB alanına benzemektedir. Yani burada dosya sistemine ilişkin metadata bilgiler bulunmaktadır. i-node blok 
    i-node elemanlarından oluşmaktadır. Data blok (data block= FAT dosya sistemindeki Data bölümü gibidir. FAT dosya sistemindeki 
    "cluster" yerine i-node tabanlı dosya sistemlerinde "blok (block)" terimi kullanılmaktadır. Bir blok bir dosyanın parçası olabilecek 
    en küçük birimdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Süper blok hemen volümün 1024 byte offset'inde bulunmaktadır. (Yani volümün başında boot sektör programları için 1024 
    byte yer ayrılmıştır.) Süper blok süper blokta belirtilen blok uzunluğu kadar uzunluğa sahiptir. (Ayrıca izleyen paragraflarda 
    da görüleceği gibi ext2 dosya sisteminde her blok grupta süper bloğun bir kopyası da bulunmaktadır.) Yukarıda da belirttiğimiz 
    gibi burada volüm hakkında metadata bilgileri bulunmaktadır. Buradaki alanlar ext2 dokümantasyonunda ayrıntılarıyla açıklanmıştır. 
    Süper blok içerisindeki alanlar aşağıdaki gibidir:

    +-----------------------+-----+-------------------------------------------------------------------------------------------+
    |          Alan         |Boyut|                                         Açıklama                                          |
    |                       |Byte |                                                                                           |
    +-----------------------+-----+-------------------------------------------------------------------------------------------+
    | s_inodes_count        |  4  | Dosya sistemindeki toplam inode sayısı.                                                   |
    | s_blocks_count        |  4  | Dosya sistemindeki toplam blok sayısı.                                                    |
    | s_r_blocks_count      |  4  | Rezerve edilmiş blok sayısı.                                                              |
    | s_free_blocks_count   |  4  | Boş blok sayısı.                                                                          |
    | s_free_inodes_count   |  4  | Boş inode sayısı.                                                                         |
    | s_first_data_block    |  4  | İlk veri bloğunun numarası (bu, kök dizinin bulunduğu blok).                              |
    | s_log_block_size      |  4  | Blok boyutunun logaritmasının değeri (örneğin, 1 KB için 10, 4 KB için 12, vs.).          |
    | s_log_frag_size       |  4  | Parçacık boyutunun logaritması.                                                           |
    | s_blocks_per_group    |  4  | Her blok grubundaki blok sayısı.                                                          |
    | s_frags_per_group     |  4  | Her blok grubundaki fragman sayısı.                                                       |
    | s_inodes_per_group    |  4  | Her blok grubundaki inode sayısı.                                                         |
    | s_mtime               |  4  | Dosya sisteminin son değiştirilme zamanı (Unix zaman damgası).                            |
    | s_wtime               |  4  | Dosya sisteminin son yazılma zamanı (Unix zaman damgası).                                 |
    | s_mnt_count           |  2  | Dosya sisteminin kaç kez bağlandığı (mount) sayısı.                                       |
    | s_max_mnt_count       |  2  | Dosya sisteminin kaç kez daha bağlanabileceği (yani, montaj sayısı aşımı).                |
    | s_magic               |  2  | Süper blok sihirli sayısı (bu, EXT2 dosya sistemini tanımlar ve genellikle `0xEF53`'tür). |
    | s_state               |  2  | Dosya sisteminin durumu (örneğin, temiz mi, hata mı).                                     |
    | s_errors              |  2  | Hata durumunda yapılacak işlem (örneğin, “ignore”, “panic”, vb.).                         |
    | s_minor_rev_level     |  2  | Küçük revizyon seviyesi (EXT2’yi güncelleyen küçük değişiklikler için).                   |
    | s_lastcheck           |  4  | Dosya sisteminin son kontrol tarihi (Unix zaman damgası).                                 |
    | s_checkinterval       |  4  | Dosya sisteminin kontrol edilmesi gereken süre (saniye cinsinden).                        |
    | s_creator_os          |  4  | Dosya sistemini oluşturan işletim sistemi türü (örneğin, Linux, Solaris, vb.).            |
    | s_rev_level           |  4  | EXT2 dosya sistemi revizyon seviyesi.                                                     |
    | s_def_resuid          |  2  | Varsayılan rezerv kullanıcı ID'si (uid).                                                  |
    | s_def_resgid          |  2  | Varsayılan rezerv grup ID'si (gid).                                                       |
    | s_first_ino           |  4  | İlk inode numarası (genellikle kök dizini için).                                          |
    | s_inode_size          |  2  | Inode boyutu (genellikle 128 veya 256 byte).                                              |
    | s_block_group_nr      |  2  | Bu süper blok ile ilişkili blok grubu numarası.                                           |
    | s_feature_compat      |  4  | Uyumluluk özelliklerinin bit maskesi.                                                     |
    | s_feature_incompat    |  4  | Uyumsuz özelliklerin bit maskesi.                                                         |
    | s_feature_ro_compat   |  4  | Okuma-yazma uyumsuz özelliklerinin bit maskesi.                                           |
    | s_uuid                |  16 | Dosya sisteminin benzersiz tanımlayıcısı (UUID).                                          |
    | s_volume_name         |  16 | Dosya sistemi adının (etiketinin) olduğu alan.                                            |
    | s_last_mounted        |  64 | Dosya sisteminin son bağlandığı dizin yolu.                                               |
    | s_algorithm_usage_bmp |  4  | Bloklar ve inode'lar için kullanılan algoritmaların bit maskesi.                          |
    | s_prealloc_blocks     |  1  | Önceden tahsis edilecek blok sayısı.                                                      |
    | s_prealloc_dir_blocks |  1  | Önceden tahsis edilecek dizin blokları sayısı.                                            |
    | s_padding             | 118 | Alanın sonundaki boşluk (süper bloğun uzunluğunu tamamlar).                               |
    +-----------------------+-----+-------------------------------------------------------------------------------------------+

    Buradaki önemli alanlar hakkında kısa bazı açıklamalar yapmak istiyoruz:

    s_inodes_count: Bu alanda dosya sistemindeki toplam i-node elemanlarının sayısı bulunmaktadır. Bir ext2 disk bölümünde en 
    fazla buradaki i-node elemanlarının sayısı kadar farklı dosya bulunabilir.

    s_blocks_count: Burada Data bölümündeki toplam blokların sayısı bulunmaktadır.

    s_r_blocks_count: Burada ayrılmış (reserve edilmiş) blokların sayısı bulunmaktadır.

    s_free_blocks_count: Burada Data bölümünde kullanılmayan boş blokların sayısı tutulmaktadır.

    s_log_block_size: Burada 1024 değerinin 2 üzeri kaçla çarpılacağını belirten değer tutulmaktadır. Yani blok uzunluğu 
    1024 << s_log_block_siz biçiminde hesaplanmaktadır. Örneğin burada 2 değeri yazılıyorsa blok uzunluğu 2^2 * 1024 = 4096 byte'tır.

    s_inode_size: Burada bir i-node elemanının kaç byte olduğu bilgisi yer almaktadır. Örnek dosya sistemimizde i-node elemanları 
    256 byte uzunluğundadır.

    ext2 dosya sisteminin süper blok bilgisi ve bazı önemli alanlarına ilişkin bilgiler "dumpe2fs" isimli utility programla 
    elde edilebilir. Örneğin:

    $ dumpe2fs /dev/loop0

    Aşağıda bir ext2 süper bloğunun örnek bir içeriği verilmektedir:

    00004000  60 c3 00 00 50 c3 00 00  c4 09 00 00 f4 b6 00 00  |`...P...........|
    00000410  55 c3 00 00 00 00 00 00  02 00 00 00 02 00 00 00  |U...............|
    00000420  00 80 00 00 00 80 00 00  b0 61 00 00 51 5c 2e 67  |.........a..Q\.g|
    00000430  51 5c 2e 67 01 00 ff ff  53 ef 00 00 01 00 00 00  |Q\.g....S.......|
    00000440  42 5c 2e 67 00 00 00 00  00 00 00 00 01 00 00 00  |B\.g............|
    00000450  00 00 00 00 0b 00 00 00  00 01 00 00 38 00 00 00  |............8...|
    00000460  02 00 00 00 03 00 00 00  ec 89 02 3e a8 11 4c 01  |...........>..L.|
    00000470  b0 b5 f5 48 1e 30 79 d6  00 00 00 00 00 00 00 00  |...H.0y.........|
    00000480  00 00 00 00 00 00 00 00  2f 68 6f 6d 65 2f 6b 61  |......../home/ka|
    00000490  61 6e 2f 53 74 75 64 79  2f 55 6e 69 78 4c 69 6e  |an/Study/UnixLin|
    000004a0  75 78 2d 53 79 73 50 72  6f 67 2f 44 69 73 6b 49  |ux-SysProg/DiskI|
    000004b0  4f 2d 46 69 6c 65 53 79  73 74 65 6d 73 2f 65 78  |O-FileSystems/ex|
    000004c0  74 32 00 00 00 00 00 00  00 00 00 00 00 00 0c 00  |t2..............|
    000004d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000004e0  00 00 00 00 00 00 00 00  00 00 00 00 6e 47 e8 bc  |............nG..|
    000004f0  81 50 45 f3 bb 96 6c 7c  51 bc e3 8a 01 00 00 00  |.PE...l|Q.......|
    00000500  0c 00 00 00 00 00 00 00  42 5c 2e 67 00 00 00 00  |........B\.g....|

    Burada toplam i-node elemanlarının sayısı 0xC360 (50016) tanedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümünün i-node bloğu i-node elemanlarından oluşmaktadır. Her i-node elemanının ilki 0 olmak üzere bir indeks numarası 
    vardır. Örneğin:

    0       i-node elemanı
    1       i-node elemanı
    2       i-node elemanı
    3       i-node elemanı
    4       i-node elemanı
    ...
    300     i-node elemanı
    301     i-node elemanı
    302     i-node elemanı
    303     i-node elemanı
    304     i-node elemanı
    ...

    Bir dosyanın ismi haricindeki bütün bilgileri dosyaya ilişkin i-node elemanında tutulmaktadır. Zaten stat fonksiyonları 
    da aslında bilgileri bu i-node elemanından almaktadır. Her dosyanın diğerlerinden farklı bir i-node numarası olduğuna 
    dikkat ediniz. Dolayısıyla dosyanın i-node numarası o dosyayı karakterize etmektedir. ("ls" komutunda dosyanın i-node 
    numaralarının -i seçeneği ile elde edildiğini anımsayınız.) Burada hatırlatma yapmak amacıyla stat yapısını yeniden vermek 
    istiyoruz:

    struct stat {
        dev_t     st_dev;     /* ID of device containing file */
        ino_t     st_ino;     /* inode number */
        mode_t    st_mode;    /* protection */
        nlink_t   st_nlink;   /* number of hard links */
        uid_t     st_uid;     /* user ID of owner */
        gid_t     st_gid;     /* group ID of owner */
        dev_t     st_rdev;    /* device ID (if special file) */
        off_t     st_size;    /* total size, in bytes */
        blksize_t st_blksize; /* blocksize for file system I/O */
        blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
        time_t    st_atime;   /* time of last access */
        time_t    st_mtime;   /* time of last modification */
        time_t    st_ctime;   /* time of last status change */
    };

    ext2 dosya sisteminde bir i-node elemanının alanları aşağıdaki gibidir:

    +-------------+------------+----------------------------------------------------------------------------------------------+
    |    Alan     |Boyut (Byte)|                                           Açıklama                                           |
    +-------------+------------+----------------------------------------------------------------------------------------------+
    |i_mode       |     2      | Dosya türü ve izinler (örneğin, `S_IFREG` (normal dosya), `S_IFDIR` (dizin), vs.).           |
    |i_uid        |     2      | Dosya sahibinin kullanıcı kimliği (UID).                                                     |
    |i_size_lo    |     4      | Dosyanın boyutunun alt 32 biti (byte cinsinden).                                             |
    |i_atime      |     4      | Son erişim zamanı (Unix zaman damgası).                                                      |
    |i_ctime      |     4      | Son inode değişiklik zamanı (Unix zaman damgası).                                            |
    |i_mtime      |     4      | Son değişiklik (modifikasyon) zamanı (Unix zaman damgası).                                   |
    |i_dtime      |     4      | Dosyanın silinme zamanı (Unix zaman damgası), eğer geçerliyse.                               |
    |i_gid        |     2      | Dosya sahibinin grup kimliği (GID).                                                          |
    |i_links_count|     2      | Dosyaya bağlı olan hard link (bağlantı) sayısı.                                              |
    |i_blocks     |     4      | Dosyanın disk üzerinde kullandığı blok sayısı (block, 512 byte'lık bloklar).                 |
    |i_flags      |     4      | Dosya bayrakları (örneğin, `i_dirty`, `i_reserved` gibi).                                    |
    |i_osd1       |     4      | Linux spesifik alan (genellikle genişletilmiş özellikler için kullanılır).                   |
    |i_block[15]  | 4 × 15 = 60| Dosyanın bloklarına işaretçi                                                                 |
    |i_generation |     4      | Dosyanın versiyon numarası (özellikle NFS gibi ağ dosya sistemlerinde kullanılır).           |
    |i_file_acl   |     4      | Dosya için ACL (Access Control List) blok numarası.                                          |
    |i_dir_acl    |     4      | Dizin için ACL blok numarası.                                                                |
    |i_faddr      |     4      | Dosyanın "fragman adresi" (bu, çoğu zaman sıfırdır ve eski EXT2 uygulamalarında kullanılır). |
    +-------------+------------+----------------------------------------------------------------------------------------------+

    Biz bu alanların büyük çoğunluğunu aslında stat fonksiyonunda görmüştük. Ancak stat yapısında olmayan bazı elemanlar da 
    burada bulunmaktadır. Biz stat yapısında olmayan bazı önemli elemanlar üzerinde durmak istiyoruz:

    i_dtime: Bu alanda eğer dosya silinmişse dosyanın ne zaman silindiğine yönelik tarih zaman bilgisi tutulmaktadır. Buradaki
    değer 01/01/1970'ten itibaren geçen saniye sayısı cinsindendir.

    i_block ve i_blocks: Bu elemanlar izleyen paragraflarda daha ayrıntılı bir biçimde ele alınacaktır.

    i_flags: Bu alanda ilgili dosyaya ilişkin bazı bayraklar tutulmaktadır.

    i_file_acl: Dosyaya ilişkin "erişim kontrol listesi (access control list)" ile ilgili bilgiler tutulmaktadır.

    i-node elemanında dosyanın isminin tutulmadığına dikkat ediniz. ext2 dosya sisteminde bir i-node elemanının uzunluğu süper
    bloğun s_inode_size elemanında yazmaktadır. Örnek sistemimizde i-node elemanları 256 byte uzunluktadır.

    Peki dosyanın ismi nerededir ve dosyanın i-node numarası nereden elde edilmektedir? Bunu izleyen paragraflarda göreceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                179. Ders 10/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda i-node tabanlı bir disk bölümünün kaba organizasyonunun aşağıdaki gibi olduğunu belirtmiştik:

    <boot block>                    (1024 byte)
    <super block>
    <i-node block>
    <data block>

    Burada sanki süper bloktan hemen sonra i-node blok geliyormuş gibi biz organizasyon resmedilmiştir. Halbuki süper bloktan
    hemen sonra i-node blok gelmemektedir. ext2 dosya sisteminin gerçek yerleşimi aşağıdaki gibidir:

    <boot block>                      (1024 byte)
    <block group>
    <block group>
    <block group>

    Bir disk bölümü aslında blok gruplarından (block groups) oluşmaktadır. Her blok grubu disk bölümüne ilişkin bir bölümü belirtir. 
    Bir blok grubu aşağıdaki gibi bir yapıya sahiptir:

    <super block>
    <block group descriptor table>
    <block bitmap>
    <i-node bitmap>
    <i-node table>
    <data block>

    İşte "blok grup betimleyici tablosu (block group descriptor table)" blok grupları hakkında bilgi veren bir bölümdür. Bir 
    kaç blok bilginin yer aldığı süper bloğun "s_blocks_per_group" elemanında saklanmaktadır. Her blok grupta belli sayıda 
    i-node elemanı vardır. Bir blok gruptaki i-node elemanlarının sayısı süper bloktaki s_inodes_per_group elemanıyla 
    belirtilmektedir. Yani aslında ext2 dosya sisteminde aşağıdaki gibi bir organizasyon söz konusudur:

    <boot block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap>                   (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>
    ...

    Görüldüğü gibi ext2 dosya sisteminde süper bloğun tek bir kopyası yoktur. Her blok grupta süper blok yeniden yer 
    almaktadır. Bir blok grupta ayrı bir i-node tablosunun ve data bölümünün olduğuna dikkat ediniz.

    Peki neden ext2 dosya sisteminde disk bölümü birden fazla blok gruplara ayrılmıştır? İşte bunun nedenlerinden biri 
    güvenliktir. Yani i-node bloklardan biri bozulduğunda diğeri bozulmamış biçimde kalabilir.

    Blok gruplarındaki "blok grup betimleyici tablosu (block group descriptor table)" blok grupları hakkında bazı metadata 
    bilgileri tutmaktadır. Ancak blok grup betimleyicilerinde yalnızca o blok grubuna ilişkin bilgiler değil, tüm blok gruplarına 
    ilişkin bilgiler tutulmaktadır. Yani her blok grubunda yeniden tüm blok gruplarına ilişkin bilgiler tutulmaktadır. 
    Blok grup betimleyici tablosu blok grup betimleyicilerinden oluşan bir dizi gibidir:

    Blok Grup Betimleyici Tablosu

    <block group descriptor>
    <block group descriptor>
    <block group descriptor>
    ...
    <block group descriptor>
    <block group descriptor>

    Bir blok grup betimleyicisinin alanları şöyledir:

    +----------------------+-------------+-----------------------------------------+
    |     Yapı Elemanı     | Boyut (Byte)|                Açıklama                 |
    +----------------------+-------------+-----------------------------------------+
    | bg_block_bitmap      |      4      | Blok haritasının başlangıç adresi       |
    | bg_inode_bitmap      |      4      | Inode haritasının başlangıç adresi      |
    | bg_inode_table       |      4      | Inode tablosunun başlangıç adresi       |
    | bg_free_blocks_count |      2      | Blok grubunda serbest blok sayısı       |
    | bg_free_inodes_count |      2      | Blok grubunda serbest inode sayısı      |
    | bg_used_dirs_count   |      2      | Blok grubundaki kullanılan dizin sayısı |
    | bg_flags             |      2      | Blok grubunun bayrakları (flags)        |
    | bg_reserved          |     12      | Rezerv alan (genellikle sıfırdır)       |
    +----------------------+-------------+-----------------------------------------+

    Blok grup betimleyicisi toplamda 32 byte yer kaplamaktadır. Her blok grubunda blok bitmap'in, i-node bitmap'in ve i-node 
    tablosunun yerinin blok numarası tutulmaktadır. Buradaki blok uzunlukları disk bölümünün başından itibaren yer belirtir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümü içerisindeki blokların numaralandırılması ile ilgili ince bir nokta vardır. Eğer disk bölümündeki blok uzunluğu
    1K yani 1024 byte ise boot blok 0'ıncı bloktadır. Dolayısıyla ilk blok grubundaki süper blok 1'inci bloktadır. Ancak 
    blok büyüklüğü 1024'ten (yani 1K'dan) fazla ise bu durumda boot blok ile süper blok tek blok kabul edilmektedir. Boot blok 
    ile süper bloğun bulunduğu ilk bloğun numarası 0'dır.

    İlk blok grup betimleyici tablosunun yeri de blok grubundaki süper bloktan hemen sonradır. Örneğin dosya sistemindeki 
    blok uzunluğu 4K (4096 byte) ise ilk blok betimleyici tablosunun yeri 4096'ıncı = 0x1000 offset'indedir. (Bu durumda boot blok
    ile süper bloğun 0 numaralı blok biçiminde tek blok olarak ele alındığını anımsayınız.) Bir blok grubunun toplam kapladığı 
    blok sayısı süper blok içerisindeki s_blocks_per_group elemanında tutulmaktadır. Örneğin biz k numaralı blok grubun blok 
    numarasını k * s_blocks_per_group işlemiyle elde edebiliriz.

    Aşağıda örnek bir blok grup betimleyici tablosu verilmiştir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Bir blok grup betimleyicisi 32 byte uzunluktadır. Burada toplam iki blok grup betimleyicisi yani disk bölümünde toplam 
    iki blok grubu bulunmaktadır. Bu iki blok grup betimleyicisini ayrı ayrı aşağıda veriyoruz:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Disk bölümünde toplam kaç blok grubu olduğu süper bloktaki s_blocks_count elemanında yazmaktadır.

    Bir blok grubundaki blok grup betimleyici tablosunun uzunluğu 1 blok kadardır. Blok bitmap'in ve i-node bitmap'in 
    uzunlukları doğrudan süper blokta yazmamaktadır. Bu uzunluklar dolaylı bir biçimde hesaplanmaktadır. Dolayısıyla bir 
    blok gruptaki data alanının başlangıç bloğu da dolaylı bir biçimde hesaplanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                180. Ders 17/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                181. Ders 22/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki bir dosyanın i-node numarası biliniyorsa onun disk bölümündeki yerini nasıl hesaplarız? Burada bizim bu i-node 
    elemanının hangi blok grubunda ve o blok grubunun i-node tablosunda nerede olduğunu belirlememiz gerekir. i-node tablosundaki
    i-node elemanları 1'den başlatılmıştır. Yani bizim elimizde i-node numarası n olan bir dosya varsa aslında bu dosya i-node
    tablosunun n - 1'inci i-node elemanındadır. Çünkü i-node tablosunun ilk i-node elemanının numarası 0 değil, 1'dir.

    Her blok grupta eşit sayıda i-node elemanı bulunmaktadır. Bir blok gruptaki i-node elemanlarının sayısı doğrudan süper 
    bloktaki s_inodes_per_group elemanında belirtilmektedir. Bu durumda ilgili i-node numarasına ilişkin i-node elemanı i-node
    numarası n olmak üzere (n - 1) / s_inodes_per_group işlemiyle elde edilebilir. Tabii bu durumda (n - 1) % s_inodes_per_group 
    ifadesi de i-node elemanının o blok gruptaki i-node tablosunun kaçıncı elemanında olduğunu verecektir. Anımsanacağı gibi her 
    blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtiliyordu.

    Bir blok grubunun toplam kaç tane bloktan oluştuğu süper bloktaki s_blocks_per_group elemanında tutulmaktadır. Dolayısıyla 
    k'ıncı blok grubunun yeri k * s_blocks_per_group değeri ile tespit edilir. Blok numaralarına boot blok dahil değildir. Yani
    ilk blok grubunun süper bloğunun blok numarası 0'dır.

    Bu durumda manuel olarak n numaralı i-node numarasına sahip bir dosyanın i-node elemanına şöyle erişilebilir:

    1) Önce n / s_inodes_per_group ile ilgili i-node elemanının hangi blok grubununda olduğu tespit edilir. Bu değer k olsun.

    2) Bu blok grubunun yeri k * s_blocks_per_group değeri ile elde edilir ve bu bloğa gidilir. Her bloğun başında 1 blokluk 
    süper blok vardır. Süper bloğu blok grup betimleyici tablosu izler. Blok grup betimleyici tablosu blok grup betimleyicilerinden 
    oluşmaktadır. Her blok grup betimleyicisi 32 byte yer kaplamaktadır. Dolayısıyla biz k numaralı blok grubuna ilişkin blok 
    betimleyicisinin yerini k * 32 ile tespit edebiliriz. (Aslında tüm blok gruplarındaki blok grup betimleyici tablolarının 
    birbirinin aynısı olduğunu anımsayınız.)

    3) İlgili blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtilmektedir. 
    Artık biz i-node elemanını burada belirtilen bloktan itibaren n % s_inodes_per_group kadar ilerideki i-node elemanı olarak 
    elde edebiliriz. Bir i-node elemanının uzunluğunun 256 byte olduğunu belirtmiştik.

    Şimdi 12'nci i-node elemanın yerini bu adımlardan geçerek bulmaya çalışalım. Elimizdeki disk bölümünde bir blok grupta 
    toplam 25008 tane i-node elemanı vardır. O halde 12 numaralı i-node elemanı 0'ıncı blok grubunun 11'inci i-node elemanındadır. 
    0'ıncı blok grubu eğer blok uzunluğu 1K'dan fazla ise diskin 0'ıncı bloğundan başlamaktadır. (Tabii 0'ıncı bloğun hemen 
    başında boot blok, ondan 1024 byte sonra da 0'ın blok grubunun süper bloğu bulunmaktadır.) O halde elimizdeki disk bölümünün 
    0'ıncı blok grubunun blok betimleyici tablosu 1'inci bloktadır. Bunun yeri de bir blok 4096 byte olduğuna göre 0x1000 
    offset'indedir. Buradan elde edilen blok grup betimleyici tablosu şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Her blok grup betimleyicisinin 32 byte olduğunu anımsayınız. Bu durumda 0'ıncı blok grup betimleyicisi şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubundaki i-node tablosunun blok numarası blok grup betimleyicisinin 8'inci offset'inde bulunan bg_inode_table
    elemanındadır. Bu elemandaki değer 0x00000010 (16)'dır. O halde bizim 16 numaralı bloğa gitmemiz gerekir. 16 numaralı 
    blok disk bölümünün 16 * 4096 = 65536 (0x10000) offset'indedir. Artık bu offset'te ilgili blok grubundaki i-node elemanları 
    bulunmaktadır. Bir i-node elemanı 256 byte olduğuna göre 11'inci elemanının yeri 11 * 256 = 2816 (0xB00) byte ileridedir. 
    O halde bu tablonun disk bölümünün başından itibarenki yeri 65536 + 2816 = 68352 (0x10B00) offset'indedir. Aşağıda ilgili
    i-node elemanının 256 byte'lık içeriği görülmektedir:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki ilk WORD bilgi (0x81A4) dosyanın erişim haklarını sonraki WORD bilgi (0x0000) kullanıcı id'sini belirtmektedir. 
    Sonraki DWORD bilgi (0x000079C8) de dosyanın uzunluğunu belirtmektedir. Diğer elemanların anlamlarına i-node yapısından 
    erişebilirsiniz.

    i-node tablosundaki ilk n tane i-node elemanı reserved biçimde tutulmaktadır. Bunların sayısı süper bloktaki s_first_ino 
    elemanında belirtilmektedir. Üzerinde çalıştığımız dosya sisteminde s_first_ino değeri 11'dir. Yani ilk 10 i-node elemanı 
    reserve edilmiştir. İlk i-node elemanının numarası 11'dir. Örnek dosya sistemimizdeki durum şöyledir:

    0. Blok Grubunun i-node Tablosu

    <1 numaralı i-node elemanı>
    <2 numaralı i-node elemanı>
    <3 numaralı i-node elemanı>
    ...
    <10 numaralı i-node elemanı>
    <11 numaralı i-node elemanı (ilk reserved olmayan eleman)>
    ...

    Reserve edilmiş ilk i-node elemanlarının anlamları şöyledir:

    +----------------------+-------+-------------------------------+
    |         İsim         | Değer |             Anlamı            |
    +----------------------+-------+-------------------------------+
    | EXT2_BAD_INO         |   1   | Bad blocks i-node             |
    | EXT2_ROOT_INO        |   2   | Root directory i-node         |
    | EXT2_ACL_IDX_INO     |   3   | ACL index inode (deprecated?) |
    | EXT2_ACL_DATA_INO    |   4   | ACL data i-node (deprecated?) |
    | EXT2_BOOT_LOADER_INO |   5   | Boot loader i-node            |
    | EXT2_UNDEL_DIR_INO   |   6   | Undelete directory i-node     |
    +----------------------+-------+-------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                182. Ders 24/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                183. Ders 01/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki ext2 dosya sisteminde bir dosyanın parçalarının (yani bloklarının) nerelerde olduğu bilgisi nerede tutulmaktadır?
    Anımsanacağı gibi FAT dosya sisteminde dosyanın parçalarının (orada block yerine cluster teriminin kullanıldığını anımsayınız)
    diskin hangi cluster'larında olduğu FAT bölümünde saklanıyordu. İşte yalnızca ext2 dosya sisteminde değil, i-node tabanlı 
    dosya sistemlerinde bir dosyanın diskte hangi bloklarda bulunduğu i-node elemanının içerisinde tutulmaktadır. i-node elemanlarının
    genel olarak 128 byte ya da 256 byte uzunlukta olduğunu anımsayınız. Büyük bir dosyanın blok numaralarının bu kadar alana 
    sığmayacağı açıktır. Peki o zaman dosyanın blok numaraları i-node elemanında nasıl tutulmaktadır?

    İşte i-node elemanında dosyanın hangi bloklarda olduğu "doğrudan (direct)", "dolaylı (indirect)", "çift dolaylı (double 
    indirect)" ve "üç dolaylı (triple indirect)"" bloklarda tutulmaktadır. i-node elemanının decimal 40'ıncı offset'inde (i-node 
    elemanının 0x28 offset'indeki "i_blocks" isimli elemanında) 15 elemanlık her biri DWORD değerlerden oluşan bir dizi vardır. 
    Bu diziyi şöyle gösterebiliriz:

    0 <dosyanın 0'ıncı bloğunun numarası>
    1 <dosyanın 1'inci bloğunun numarası>
    2 <dosyanın 2'nci bloğunun numarası>
    3 <dosyanın 3'üncü bloğunun numarası>
    4 <dosyanın 4'üncü bloğunun numarası>
    5 <dosyanın 5'inci bloğunun numarası>
    6 <dosyanın 6'ncı bloğunun numarası>
    7 <dosyanın 7'nci bloğunun numarası>
    8 <dosyanın 8'inci bloğunun numarası>
    9 <dosyanın 9'uncu bloğunun numarası>
    10 <dosyanın 10'uncu bloğunun numarası>
    11 <dosyanın 11'inci bloğunun numarası>
    12 <dolaylı blok numarası>
    13 <çift dolaylı blok numarası>
    14 <üç dolaylı blok numarası>

    Bu durumda eğer dosya 12 blok ya da ondan daha küçükse zaten dosyanın parçalarının blok numaraları bu dizinin ilk 12 
    elemanından doğrudan elde edilmektedir. Eğer dosya 12 bloktan büyükse bu durumda bu dizinin 12'nci indeksindeki elemanda 
    yazan blok numarası dosyanın diğer bloklarının blok numaralarını tutan bloğun numarasıdır. Yani dizinin 12'nci elemanında 
    belirtilen bloğa gidildiğinde bu bloğun içerisinde blok numaraları vardır. Bu blok numaraları da dosyanın 12'nci bloğundan 
    itibaren bloklarının numaralarını belirtmektedir. Örneğin bir blok 4096 byte olsun. Bu durumda bir blokta 1024 tane blok 
    numarası olabilir. 12 blok numarası doğrudan olduğuna göre dolaylı blokla toplam dosyanın 1024 + 12 = 1036 tane bloğunun 
    yeri tutulmuş olacaktır. Peki ya bu sistemde dosya 1036 bloktan daha büyükse? İşte bu durumda çift dolaylı blok numarasına 
    başvurulmaktadır. Çift dolaylı blok numarasına ilişkin bloğa gidildiğinde oradaki blok numaraları dosyanın blok numaraları 
    değil, dosyanın blok numaralarının tutulduğu blok numaralarıdır. Eğer dosya çift dolaylı bloklara da sığmıyorsa üç dolaylı 
    bloğa başvurulmaktadır. Üç dolaylı blokta belirtilen blok numarasında çift dolaylı blokların numaraları vardır. Çift dolaylı
    blokların içerisinde dolaylı blokların numaraları vardır. Nihayet dolaylı blokların içerisinde de asıl blokların numaraları 
    vardır.

    Peki her bloğun 4K uzunluğunda olduğu bir sistemde bir dosyanın i-node elemanında belirtilen maksimum uzunluğu ne olabilir? 
    İşte bu uzunluk aşağıdaki değerlerin toplamıyla elde edilebilir:

    12 tane doğrudan blok = 12 * 4096
    1 tane dolaylı blok = 1024 * 4096
    1 tane çift dolaylı blok = 1024 * 1024 * 4096
    1 tane üç dolaylı blok = 1024 * 1024 * 1024 * 4096

    Toplam = 12 * 4096 + 1024 * 4096 + 1024 * 12024 * 4096 + 1024 * 1024 * 1024 * 4096 = 4448483065856 = 4 TB civarı.

    Şimdi aşağıdaki i-node elemanına bakıp dosya bloklarının yerlerini tespit edelim:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada dosyanın tüm blokları 0x28'inci offset'teki doğrudan bloklarda belirtilmektedir:

    00 08 00 00  => 0x800
    01 08 00 00  => 0x801
    02 08 00 00  => 0x802
    03 08 00 00  => 0x803
    04 08 00 00  => 0x804
    05 08 00 00  => 0x805
    06 08 00 00  => 0x806
    07 08 00 00  => 0x807

    Dosya 0x4 offset'inde belirtilen 0x79C8 = 31176 byte uzunluğundadır. Bu sistemde bir blok 4K olduğuna göre toplam dosyanın
    parçalarının 8 blok olması gerekmektedir. İşte burada söz konusu dosyanın blokları disk bölümünün başından itibaren 
    0x800, 0x801, 0x802, 0x803, 0x804, 0x805, 0x806 ve 0x807'nci bloklardadır. Söz konusu sistemde bir blok 4096 byte 
    olduğuna göre dosyanın ilk bloğunun offset numarası 0x800 * 0x1000 = 0x800000 biçimindedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de ext2 dosya sisteminde dizin organizasyonu üzerinde duralım. Tıpkı FAT dosya sistemlerinde olduğu gibi ext2 
    dosya sisteminde de dizinler birer dosya gibi organize edilmiştir. (Anımsanacağı gibi dizin dosyalarından biz opendir, 
    readdir, closedir fonksiyonlarıyla okuma yapabiliyorduk.) Yani dizinler aslında birer dosya gibidir. Dizin dosyaları 
    "dizin girişleri (directory entries)" denilen girişlerden oluşmaktadır.

    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    ...

    Bir dizin girişin format şöyledir:

    +----------------+--------------+-------------------------+
    | Offset (bytes) | Size (bytes) |        Açıklama         |
    +----------------+--------------+-------------------------+
    |       0        |     DWORD    | i-node numarası         |
    |       4        |     WORD     | Girişin toplam uzunluğu |
    |       6        |     BYTE     | Dosya isminin uzunluğu  |
    |       7        |     BYTE     | Dosyanın türü           |
    |       8        | 0-255 Bytes  | Dosya ismi              |
    +----------------+--------------+-------------------------+

    Aslında buradaki bilgiler Linux'taki readdir POSIX fonksiyonu ile de alınabilmektedir. readdir fonksiyonu POSIX standartlarına
    göre en az iki elemana sahip olmak zorundadır. Bunlar d_ino ve d_name elemanlarıdır. Ancak Linux'taki read bize daha fazla
    bilgi vermektedir. Linux'taki dirent yapısı şöyledir:

    struct dirent {
        ino_t          d_ino;       /* Inode number */
        off_t          d_off;       /* Not an offset; see below */
        unsigned short d_reclen;    /* Length of this record */
        unsigned char  d_type;      /* Type of file; not supported by all filesystem types */
        char           d_name[256]; /* Null-terminated filename */
    };

    Dizin girişleri FAT dosya sistemindeki gibi eşit uzunlukta girişlerden oluşmamaktadır. Bunun nedeni dosya isimlerinin 
    0 ile 255 karakter arasında değişebilmesidir. Dizin girişlerinin hemen başında DWORD bir alanda dosyanın i-node numarası
    belirtilmektedir. Dizinler değişken uzunlukta olduğu için ilgili girişin toplam kaç byte uzunlukta olduğu sonraki WORD 
    elemanda tutulmaktadır. Girişteki dosya isminin uzunluğu ise sonraki BYTE elemanında tutulmaktadır. Dosyanın türü 
    hiç i-node elemanına erişmeden elde edilebilsin diye dizin girişlerinde de tutulmaktadır. Dosya türlerini belirten değerler
    şöyledir:

    +------------------+-------+-------------------+
    |       İsim       | Değer |       Anlamı      |
    +------------------+-------+-------------------+
    | EXT2_FT_UNKNOWN  |   0   | Unknown File Type |
    | EXT2_FT_REG_FILE |   1   | Regular File      |
    | EXT2_FT_DIR      |   2   | Directory File    |
    | EXT2_FT_CHRDEV   |   3   | Character Device  |
    | EXT2_FT_BLKDEV   |   4   | Block Device      |
    | EXT2_FT_FIFO     |   5   | Buffer File       |
    | EXT2_FT_SOCK     |   6   | Socket File       |
    | EXT2_FT_SYMLINK  |   7   | Symbolic Link     |
    +------------------+-------+-------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                184. Ders 06/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki ext2 dosya sisteminde işletim sistemi bir yol ifadesini nasıl çözümlemektedir? Örneğin "/a/b/c.txt" gibi bir yol
    ifadesinde "c.txt" dosyasının i-node elemanına nasıl erişmektedir? İşte kök dizin dosyasının bilgileri 2 numaralı i-node 
    elemanındadır. İşletim sistemi önce kök dizinin i-node elemanını elde eder. Oradan kök dizinin bloklarına erişir. O bloklar 
    içerisinde ilgili girişi arar. İşlemlerini bu biçimde devam ettirir. Örneğin "/a/b/c.txt" dosyasının i-node elemanına 
    erişmek için önce kök dizinde "a" girişini arar. Sonra "a" girişinin dizin olduğunu doğrular. Sonra "a" dizininde "b" 
    girişini arar. "b" girişinin de dosya olduğunu doğrular. Sonra "b" girişinin içerisinde "c.txt" arar ve hedef dosyanın 
    i-node bilgilerine erişir.

    Şimdi adım adım elimizdeki disk bölümünde "/a/b/c.txt" dosyasının yerini bulmaya çalışalım. Tabii buradaki kök dizin 
    aslında mount edilmiş dosya sisteminin köküdür. Biz bu dosya sistemini kursumuzda aşağıdaki noktaya mount ettik:

    "/home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems"

    Kök dizinin i-node elemanı (2 numaralı i-node elemanı) aşağıda verilmiştir:

    00010100  ed 41 00 00 00 10 00 00  a8 69 4c 67 a7 69 4c 67  |.A.......iLg.iLg|
    00010110  a7 69 4c 67 00 00 00 00  00 00 04 00 08 00 00 00  |.iLg............|
    00010120  00 00 00 00 04 00 00 00  2b 06 00 00 00 00 00 00  |........+.......|
    00010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 1c 7e f4 e6  | ......-...-.~..|
    00010190  42 5c 2e 67 00 00 00 00  00 00 00 00 00 00 00 00  |B\.g............|
    000101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada 0x28'inci offset'teki i_blocks elemanının yalnızca ilkinin dolu olduğunu görüyoruz. Demek ki kök dizin tek bir 
    bloktan oluşmaktadır. Kök dizinin blok numarası 0x62B'dir. Şimdi 0x62b bloğunun offset'ini hesaplayalım. Bunun için 
    bu değeri 0x1000 (4096) ile çarpmamız gerekir:

    0x62B * 0x1000 = 0x62B000 (6467584)

    Diskin bu offset'indeki değerler şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00  0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00 0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00 b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|
    0062b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki dizin girişlerini çözelim. Dizin giriş formatını aşağıda yeniden veriyoruz:

    +----------------+--------------+-------------------------+
    | Offset (bytes) | Size (bytes) |        Açıklama         |
    +----------------+--------------+-------------------------+
    |       0        |     DWORD    | i-node numarası         |
    |       4        |     WORD     | Girişin toplam uzunluğu |
    |       6        |     BYTE     | Dosya isminin uzunluğu  |
    |       7        |     BYTE     | Dosyanın türü           |
    |       8        | 0-255 Bytes  | Dosya ismi              |
    +----------------+--------------+-------------------------+

    İlk dizin girişinin i-node numarası 2'dir. Bu girişin uzunluğu 0x0C = 12'dir. O halde bu dizin girişi şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02

    Burada dosya ismi 1 karakter uzunluktadır. Dosya ismi yalnızca 0x2E karakterinde oluşmaktadır. Bu karakter de "." karakteridir.
    Sonraki dizin girişinin i-node numarası yine 2'dir. Girişin uzunluğu yine 0xC = 12'dir. O halde giriş şöyledir:

    0062b000                                       02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00                           |................|

    Buradaki dosya uzunluğunun 2 olduğu görülmektedir. Dosya ismi de 0x2E 0x2E karakterinden oluşmaktadır. Bu da ".." ismidir. 
    Her dizinin ilk iki elemanının bu biçimde olduğunu anımsayınız. Sonraki giriş ise şöyledir:

    0062b010                           0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00              |lost+found......|

    Burada dosya i-node numarası 0x0b = 11'dir. Dizin girişinin uzunluğu 0x14 = 20'dir. Dosya isminin uzunluğu 0xA = 10'dur. 
    Dosya ismi "lost+found" biçimindedir. Sonraki giriş ise şöyledir:

    0062b020                                       0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00              |....stdio.h..a..|

    Buradaki girişin i-node numarası 0xC = 12'dir. Girişin toplam uzunluğu 0x10 = 16'dır. Dosyanın isminin uzunluğu 7'dir. 
    Dosya ismi "stdio.h" biçimindedir. Sonraki giriş ise şöyledir:

    0062b030                                       b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|

    Burada dosyanın i-node numarası 0x61B2 = 25010'dur. Girişin uzunluğu 0xC4 = 196'dır. (Bu değerin çok uzun olması önemli değildir. 
    Çünkü bu dizindeki son dosyadır.) Dosya isminin uzunluğu 1'dir. Dosya türü 0x02'dir. Yani bu giriş bir dizin belirtmektedir. 
    Dosya ismi "a" biçimindedir.

    İşte işletim sistemi 0x61B2 = 25010'ıncı i-node elemanında bu dizinin bilgilerinin olduğunu tespit eder ve o i-node elemanını
    okur. Bu i-node elemanı aşağıdaki gibidir:

    08010100  ed 41 00 00 00 10 00 00  f8 2b 53 67 a7 69 4c 67  |.A.......+Sg.iLg|
    08010110  a7 69 4c 67 00 00 00 00  00 00 03 00 08 00 00 00  |.iLg............|
    08010120  00 00 00 00 02 00 00 00  2b 86 00 00 00 00 00 00  |........+.......|
    08010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010160  00 00 00 00 f9 65 fb 3c  00 00 00 00 00 00 00 00  |.....e.<........|
    08010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 04 7d e1 7b  | ......-...-.}.{|
    08010190  a7 69 4c 67 a0 15 ed 2d  00 00 00 00 00 00 00 00  |.iLg...-........|
    080101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    "a" dizinine ilişkin i-node elemanının 0x28'inci offset'teki blokları bir tanedir ve blok numarası 0x862B = 34547'dir. 
    Bu bloğun offset'i de 34547 * 4096 = 140685312'dir. Dizine ilişkin dizin bloğunun içeriği şöyledir:

    0862b000  b2 61 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |.a..............|
    0862b010  0c 00 02 02 2e 2e 00 00  b3 61 00 00 e8 0f 01 02  |.........a......|
    0862b020  62 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |b...............|
    0862b030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu dizin girişlerine bakıldığında "b" isimli girişin bulunduğu görülmektedir. İşte yol ifadesi bu aşamalardan geçilerek 
    çözümlenmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki bir dosya oluşturulurken boş bloklar nasıl tespit edilmektedir? İşte her blok grup betimleyicisi kendi blok grubundaki 
    boş blokları "block bitmap" denilen tabloda bit düzeyinde tutmaktadır. Blok bitmap tablosu her biti bir bloğun boş mu dolu 
    mu olduğunu tutmaktadır. Blok grup betimleyicisinde yalnızca blok grubunun yeri tutulur. Bunun blok uzunluğu ilgili blok
    gruplarındaki blok sayısına bakılarak tespit edilmelidir. Her blok grubunda eşit sayıda blok bulunur. Bu sayı süper blok
    içerisindeki s_blocks_per_group elemanında saklanmaktadır. Aşağıda bir grup betimleyicisinin blok bitmap tablosunun bir 
    bölümünü görüyorsunuz:

    0000e000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e010  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e020  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e030  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e040  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e050  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e060  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e070  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e080  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e090  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0a0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0b0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0c0  ff ff ff ff ff ff 01 00  00 00 00 00 00 00 00 00  |................|
    0000e0d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e100  ff 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki FF byte'larına dikkat ediniz. FF byte'ı aslında ikilik sistemde 1111 1111 bitlerine karşılık gelmektedir. Yani
    bu bloklar tamamen tahsis edilmiştir. 00 olan byte'lara ilişkin bloklar tahsis edilmemiş durumdadır.

    i-node elemanlarının tahsis edilip edilmediğine yönelik de benzer bir tablo tutulmaktadır. Buna "i-node bitmap" tablosu 
    denilmektedir. Her blok grubunda bir i-node bitmap tablosu bulunur. Bu tablo da bitlerden oluşmaktadır. Her bit ilgili 
    i-node elemanının boş mu dolu mu olduğunu belirtir. i-node bitmap tablosunun yeri de yine blok grup betimleyicisinde 
    tutulmaktadır. Bu tablonun uzunluğu da yine süper bloktaki "bir grup bloğundaki i-node elemanlarının sayısı" dikkate 
    alınarak tespit edilmektedir. Aşağıda örnek bir i-node bitmap tablosunun bir kısmını görüyorsunuz:

    0000f000  ff 0f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubunda toplam 12 i-node elemanı tahsis edilmiş durumdadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosya sistemini tanıyabilmek için manuel işlemler yaptık. Peki bu işlemleri programlama yoluyla 
    nasıl yapabiliriz? Yukarıda açıkladığımız dosya sistemi alanlarına ilişkin yapılar çeşitli kütüphanelerin içerisinde hazır
    bir biçimde bulunmaktadır. Örneğin "libext2fs" kütüphanesi kurulduğunda <extfs/ext2_fs.h> dosyasında tüm yapı bildirimleri
    bulunacaktır. Kütüphanenin kurulumunu şöyle yapabilirsiniz:

    $ sudo apt-get install libext2fs-dev

    Aslında bu kütüphane ve <extfs/ext2_fs.h> başlık dosyası yalnızca ext2 dosya sistemine ilişkin değil, ext2 ve ext4 dosya 
    sistemine ilişkin de yapıları ve fonksiyonları bulundurmaktadır.

    Örneğin <extfs/ext2_fs.h> başlık dosyası içerisindeki süper blok yapısı aşağıdaki gibi bildirilmiştir:

    struct ext2_super_block {
        /*000*/    __u32    s_inodes_count;        /* Inodes count */
            __u32    s_blocks_count;        /* Blocks count */
            __u32    s_r_blocks_count;    /* Reserved blocks count */
            __u32    s_free_blocks_count;    /* Free blocks count */
        /*010*/    __u32    s_free_inodes_count;    /* Free inodes count */
            __u32    s_first_data_block;    /* First Data Block */
            __u32    s_log_block_size;    /* Block size */
            __u32    s_log_cluster_size;    /* Allocation cluster size */
        /*020*/    __u32    s_blocks_per_group;    /* # Blocks per group */
            __u32    s_clusters_per_group;    /* # Fragments per group */
            __u32    s_inodes_per_group;    /* # Inodes per group */
            __u32    s_mtime;        /* Mount time */
        /*030*/    __u32    s_wtime;        /* Write time */
            __u16    s_mnt_count;        /* Mount count */
            __s16    s_max_mnt_count;    /* Maximal mount count */
            __u16    s_magic;        /* Magic signature */
            __u16    s_state;        /* File system state */
            __u16    s_errors;        /* Behaviour when detecting errors */
            __u16    s_minor_rev_level;    /* minor revision level */
        /*040*/    __u32    s_lastcheck;        /* time of last check */
            __u32    s_checkinterval;    /* max. time between checks */
            __u32    s_creator_os;        /* OS */
            __u32    s_rev_level;        /* Revision level */
        /*050*/    __u16    s_def_resuid;        /* Default uid for reserved blocks */
            __u16    s_def_resgid;        /* Default gid for reserved blocks */
            /*
            * These fields are for EXT2_DYNAMIC_REV superblocks only.
            *
            * Note: the difference between the compatible feature set and
            * the incompatible feature set is that if there is a bit set
            * in the incompatible feature set that the kernel doesn't
            * know about, it should refuse to mount the filesystem.
            *
            * e2fsck's requirements are more strict; if it doesn't know
            * about a feature in either the compatible or incompatible
            * feature set, it must abort and not try to meddle with
            * things it doesn't understand...
            */
            __u32    s_first_ino;        /* First non-reserved inode */
            __u16   s_inode_size;        /* size of inode structure */
            __u16    s_block_group_nr;    /* block group # of this superblock */
            __u32    s_feature_compat;    /* compatible feature set */
        /*060*/    __u32    s_feature_incompat;    /* incompatible feature set */
            __u32    s_feature_ro_compat;    /* readonly-compatible feature set */
        /*068*/    __u8    s_uuid[16] __nonstring;        /* 128-bit uuid for volume */
        /*078*/    __u8    s_volume_name[EXT2_LABEL_LEN] __nonstring;    /* volume name, no NUL? */
        /*088*/    __u8    s_last_mounted[64] __nonstring;    /* directory last mounted on, no NUL? */
        /*0c8*/    __u32    s_algorithm_usage_bitmap; /* For compression */
            /*
            * Performance hints. Directory preallocation should only
            * happen if the EXT2_FEATURE_COMPAT_DIR_PREALLOC flag is on.
            */
            __u8    s_prealloc_blocks;    /* Nr of blocks to try to preallocate*/
            __u8    s_prealloc_dir_blocks;    /* Nr to preallocate for dirs */
            __u16    s_reserved_gdt_blocks;    /* Per group table for online growth */
            /*
            * Journaling support valid if EXT2_FEATURE_COMPAT_HAS_JOURNAL set.
            */
        /*0d0*/    __u8    s_journal_uuid[16] __nonstring;    /* uuid of journal superblock */
        /*0e0*/    __u32    s_journal_inum;        /* inode number of journal file */
            __u32    s_journal_dev;        /* device number of journal file */
            __u32    s_last_orphan;        /* start of list of inodes to delete */
        /*0ec*/    __u32    s_hash_seed[4];        /* HTREE hash seed */
        /*0fc*/    __u8    s_def_hash_version;    /* Default hash version to use */
            __u8    s_jnl_backup_type;    /* Default type of journal backup */
            __u16    s_desc_size;        /* Group desc. size: INCOMPAT_64BIT */
        /*100*/    __u32    s_default_mount_opts;    /* default EXT2_MOUNT_* flags used */
            __u32    s_first_meta_bg;    /* First metablock group */
            __u32    s_mkfs_time;        /* When the filesystem was created */
        /*10c*/    __u32    s_jnl_blocks[17];    /* Backup of the journal inode */
        /*150*/    __u32    s_blocks_count_hi;    /* Blocks count high 32bits */
            __u32    s_r_blocks_count_hi;    /* Reserved blocks count high 32 bits*/
            __u32    s_free_blocks_hi;    /* Free blocks count */
            __u16    s_min_extra_isize;    /* All inodes have at least # bytes */
            __u16    s_want_extra_isize;    /* New inodes should reserve # bytes */
        /*160*/    __u32    s_flags;        /* Miscellaneous flags */
            __u16    s_raid_stride;        /* RAID stride in blocks */
            __u16    s_mmp_update_interval;  /* # seconds to wait in MMP checking */
            __u64    s_mmp_block;        /* Block for multi-mount protection */
        /*170*/    __u32    s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
            __u8    s_log_groups_per_flex;    /* FLEX_BG group size */
            __u8    s_checksum_type;    /* metadata checksum algorithm */
            __u8    s_encryption_level;    /* versioning level for encryption */
            __u8    s_reserved_pad;        /* Padding to next 32bits */
            __u64    s_kbytes_written;    /* nr of lifetime kilobytes written */
        /*180*/    __u32    s_snapshot_inum;    /* Inode number of active snapshot */
            __u32    s_snapshot_id;        /* sequential ID of active snapshot */
            __u64    s_snapshot_r_blocks_count; /* active snapshot reserved blocks */
        /*190*/    __u32    s_snapshot_list;    /* inode number of disk snapshot list */
        #define EXT4_S_ERR_START ext4_offsetof(struct ext2_super_block, s_error_count)
            __u32    s_error_count;        /* number of fs errors */
            __u32    s_first_error_time;    /* first time an error happened */
            __u32    s_first_error_ino;    /* inode involved in first error */
        /*1a0*/    __u64    s_first_error_block;    /* block involved in first error */
            __u8    s_first_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        /*1c8*/    __u32    s_first_error_line;    /* line number where error happened */
            __u32    s_last_error_time;    /* most recent time of an error */
        /*1d0*/    __u32    s_last_error_ino;    /* inode involved in last error */
            __u32    s_last_error_line;    /* line number where error happened */
            __u64    s_last_error_block;    /* block involved of last error */
        /*1e0*/    __u8    s_last_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        #define EXT4_S_ERR_END ext4_offsetof(struct ext2_super_block, s_mount_opts)
        /*200*/    __u8    s_mount_opts[64] __nonstring;    /* default mount options, no NUL? */
        /*240*/    __u32    s_usr_quota_inum;    /* inode number of user quota file */
            __u32    s_grp_quota_inum;    /* inode number of group quota file */
            __u32    s_overhead_clusters;    /* overhead blocks/clusters in fs */
        /*24c*/    __u32    s_backup_bgs[2];    /* If sparse_super2 enabled */
        /*254*/    __u8    s_encrypt_algos[4];    /* Encryption algorithms in use */
        /*258*/    __u8    s_encrypt_pw_salt[16];    /* Salt used for string2key algorithm */
        /*268*/    __le32    s_lpf_ino;        /* Location of the lost+found inode */
            __le32  s_prj_quota_inum;    /* inode for tracking project quota */
        /*270*/    __le32    s_checksum_seed;    /* crc32c(orig_uuid) if csum_seed set */
        /*274*/    __u8    s_wtime_hi;
            __u8    s_mtime_hi;
            __u8    s_mkfs_time_hi;
            __u8    s_lastcheck_hi;
            __u8    s_first_error_time_hi;
            __u8    s_last_error_time_hi;
            __u8    s_first_error_errcode;
            __u8    s_last_error_errcode;
        /*27c*/ __le16    s_encoding;        /* Filename charset encoding */
            __le16    s_encoding_flags;    /* Filename charset encoding flags */
            __le32    s_reserved[95];        /* Padding to the end of the block */
        /*3fc*/    __u32    s_checksum;        /* crc32c(superblock) */
    };

    Kütüphane aşağıdaki bağlantıdan indirebileceğiniz pdf dosyasında dokümante edilmiştir:

    https://www.dubeyko.com/development/FileSystems/ext2fs/libext2fs.pdf

    Ayrıca "e2fsprogs" isimli pakette de ext2, ext3 ve ext4 dosya sistemlerine ilişkin pek çok yardımcı program bulunmaktadır.
    Örneğin bizim daha önce kullandığımız "dumpe2fs" programı bu paketin bir parçasıdır. Buradaki programlar "libext2fs" 
    kütüphanesi kullanılarak yazılmıştır. Paket pek çok Linux dağıtımında default biçimde kurulu durumdadır. Eğer dağıtımınızda 
    kurulu değilse bu paketi aşağıdaki gibi kurabilirsiniz:

    $ sudo apt-get install e2fsprogs
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                185. Ders 08/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi "libext2fs" kütüphanesinin basit bir kullanımı üzerinde duracağız. Kütüphanenin temel başlık dosyası <extefs/extfs.h> 
    isimli dosyadır. Bu dosyanın include edilmesi gerekir.

    #include <ext2fs/ext2fs.h>

    Kütüphaneyi kullanan programlar derlenirken link aşamasında "-lext2fs" seçeneğinin bulundurulması gerekir. Örneğin:

    $ gcc -o sample sample.c -lext2fs

    Kütüphane içerisindeki fonksiyonların çoğunun geri dönüş değerleri errcode_t türündendir. errcode_t türü long biçimde 
    typedef edilmiştir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda hata ile ilgili bir değere geri 
    dönmektedir. Hatayı yazdırmak için error_message isimli fonksiyon bulunmaktadır. Bu fonksiyona errcode_t değeri parametre
    olarak verilir, fonksiyon da hata yazısına ilişkin static bir dizinin başlangıç adresine geri döner. Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "%s\n", error_message(err));
        exit(EXIT_FAILURE);
    }

    Bu kütüphane kullanılarak yazılmış programlar genel olarak aygıtlara eriştiği için "sudo" ile çalıştırılması gerekir. 
    Aksi takdirde "Permission denied (EACCESS)" hatası ortaya çıkacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphanenin kullanılması için ilk yapılacak işlem dosya sisteminin ext2fs_open fonksiyonu ile açılmasıdır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs open (const char *name, int args, int superblock, int block size, io_manager manager, ext2_filsys *ret fs);

    Fonksiyonun birinci parametresi dosya sisteminin bulunduğu dosyanın ya da aygıt dosyasının yol ifadesini almaktadır. 
    Parametrelerin çoğu default 0 geçilebilir. Ancak io_manager parametresi için unix_io_manager argümanının girilmesi 
    gerekmektedir. Fonksiyon ext2fil_sys türünden handle belirten bir nesne vermektedir. Bu tür şöyle typedef edilmiştir:

    typedef struct struct_ext2_filsys *ext2_filsys;

    Dosya sistemine ilişkin tüm bilgiler bu struct_ext2_filsys yapısının içerisindedir. Bu yapı şöyle bildirilmiştir:

    struct struct_ext2_filsys {
        errcode_t            magic;
        io_channel            io;
        int                flags;
        char *                device_name;
        struct ext2_super_block    *     super;
        unsigned int            blocksize;
        int                fragsize;
        dgrp_t                group_desc_count;
        unsigned long            desc_blocks;
        struct opaque_ext2_group_desc *    group_desc;
        unsigned int            inode_blocks_per_group;
        ext2fs_inode_bitmap        inode_map;
        ext2fs_block_bitmap        block_map;
        ...
    };

    Örneğin bu yapının super elemanı süper blok bilgilerinin bulunduğu ext2_super_block isimli yapı nesnesinin adresini 
    vermektedir.

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    Açılan dosya sisteminin işlem bitince ext2fs_close fonksiyonu ile kapatılması gerekir. Fonksiyonun prototipi şöyledir:

    errcode_t ext2fs close (ext2_filsys fs);

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    /* ... */

    ext2fs_close(fs);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <ext2fs/ext2fs.h>

int main(void)
{
    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of i-node: %lu\n", (unsigned long)fs->super->s_inodes_count);
    printf("Total Block: %lu\n", (unsigned long)fs->super->s_blocks_count);
    /* ... */

    ext2fs_close(fs);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir numaraya sahip i-node elemanını elde edebilmek için ext2fs_read_inode fonksiyonu kullanılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs_read_inode(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode);

    Fonksiyonun birinci parametresi dosya sistemini temsil eden handle değeridir. İkinci parametre bilgileri elde edilecek 
    i-node elemanın numarasını belirtir. Üçüncü parametre de i-node bilgilerinin yerleştirileceği yapının adresini almaktadır. 
    Örneğin:

    if ((err = ext2fs_read_inode(fs, 13, &inode)) != 0) {
        fprintf(stderr, "cannot read inode!...\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                186. Ders 15/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diske birden fazla bağımsız dosya sisteminin (ve belki de işletim sisteminin) yüklenebilmesi için diskin mantıksal 
    bakımdan parçalara ayrılması gerekmektedir. Diskin mantıksal bakımdan parçalara ayrılmasına ise "disk bölümlemesi" 
    denilmektedir. Disk bölümlemesi aslında disk bölümlerinin hangi sektörden başlayıp kaç sektör uzunluğunda olduğunun 
    belirlenmesi anlamına gelmektedir. Böylece her dosya sistemi başkasının alanına müdahale etmeden yalnızca o disk bölümünü 
    kullanmaktadır.

    Diskteki disk bölümleri hakkında bilgileri barındıran tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. 
    Bugün için iki disk bölümleme tablo formatı kullanılmaktadır:

    1) Klasik (legacy) MBR Disk Bölümleme Tablo Formatı
    2) Modern UEFI BIOS Sistemlerinin Kullandığı GPT (Guid Partition Table) Formatı

    UEFI BIOS'lar GPT disk bölümleme tablosu kullanırken eski sistemler ve gömülü sistemler genel olarak klasik MBR disk 
    bölümleme tablosunu kullanmaktadır. Gömülü sistemler için oluşturduğumuz SD kartlar'daki disk bölümleme tablosu klasik 
    (legacy) disk bölümleme tablosudur. Ancak bugünkü büyük çaplı UEFI BIOS'lar önce GPT disk bölümleme tablosuna bakmakta 
    eğer onu bulamazsa klasik disk bölümleme tablosunu aramaktadır. Yani geçmişe doğru uyum korunmaya çalışılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi disk sistemlerine okuma ve yazma işlemleri blok aygıt sürücüleri tarafından yapılmaktadır. 
    Dolayısıyla bir UNIX türevi sistemde her disk için "/dev" dizininin altında bir blok aygıt dosyası bulunmaktadır. Aynı zamanda 
    her disk bölümü için de bir blok aygıt dosyası bulunur. Böylece bir diskin bütünü üzerinde de yalnızca onun belli bir bölümü 
    üzerinde de çalışılabilir. Daha önceden de kullanmış olduğumuz "lsblk" komutu bize sistemimizdeki diskler ve onların bölümleri 
    hakkında bilgiler vermektedir. Örneğin çalıştığımız sistemde "lsblk" komutunu uyguladığımızda şöyle bir çıktı ile karşılaşmaktayız:

    $ lsblk
    NAME MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
    loop0
        7:0    0 195,3M  0 loop /home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems/ext2
    sda    8:0    0    60G  0 disk
    ├─sda1
    │      8:1    0     1M  0 part
    ├─sda2
    │      8:2    0   513M  0 part /boot/efi
    └─sda3
        8:3    0  59,5G  0 part /
    sr0   11:0    1  1024M  0 rom

    Buradaki "sda" aygıtı bir diski bütün olarak ele almak için kullanılmaktadır. Bu diskin 3 tane disk bölüme vardır. Bu 
    disk bölümleri de "sda1", "sda2" ve "sda3" aygıtlarıdır. Bu aygıtlara ilişkin "/dev" dizini altında aygıt dosyaları 
    bulunmaktadır. Örneğin:

    $ ls -l /dev/sda*
    brw-rw---- 1 root disk 8, 0 Ara  6 15:08 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ara  6 15:08 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ara  6 15:08 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ara  6 15:08 /dev/sda3

    Diskleri temsil eden isimler o diskin türüne göre değişebilmektedir. Normal hard diskler için isimlendirme "sda", "sdb", 
    "sdc" biçiminde yapılmaktadır. Bunların bölümleri de "sda1", "sda2", "sdb1, "sdb2" biçiminde yapılır. MicroSD kartlar 
    "mmcblk0", "mmcblk1", "mmcblk2" biçiminde isimlendirilmektedir. Bunların bölümleri de "mmcblk0p1", "mmcblk0p2", "mmcblk1p1", 
    "mmcblk1p2" biçiminde yapılmaktadır. Eğer disk bir loop aygıtı biçiminde oluşturulmuşsa disk bölümleri "loop0p1", "loop0p2", 
    "loop1p1", "loop1p2" biçiminde isimlendirilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik MBR (legacy) disk bölümlendirmesinde diskin ilk sektörüne (0 numaralı sektörüne) MBR (Master Boot Record) sektörü 
    denilmektedir. MBR sektörünün sonundaki 2 byte MBR'nin bilinçli olarak oluşturulduğunu belirten sihirli bir sayıdan (magic 
    number) oluşmaktadır. Bu sihirli sayı hex olarak 55 AA biçimindedir. Aşağıda "loop0" aygıtı üzerinde oluşturulmuş bir MBR
    sektörü görülmektedir:

    $ sudo hexdump /dev/loop0 -C -v -n 512
    00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  03 74 de d6 00 00 80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Sektörün sonunun 55 AA ile bittiğine dikkat ediniz.

    Klasik MBR Disk Bölümlemesi'nde MBR sektörünün sonundaki 64 byte'a "Disk Bölümleme Tablosu (Disk Partition Table)" denilmektedir. 
    Tabii sektörün sonunda hex olarak 55 AA bulunduğu için disk bölümleme tablosu da bu 55 AA byte'larının hemen gerisindeki 
    64 byte'tadır. O halde MBR sektörünün sonu aşağıdaki gibidir:

    ... <64 byte (Disk Bölümleme Tablosu)> 55 AA

    Yukarıdaki MBR sektörünün son 64 byte'ı ve 55 AA değerleri aşağıda verilmiştir:

                                                         80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Başka bir deyişle Disk Bölümleme Tablosu MBR sektörünün 0x1BE (446) offset'inden başlayıp 64 byte sürmektedir. Disk Bölümleme 
    Tablosu'ndaki her disk bölümü 16 byte ile betimlenmektedir. Dolayısıyla klasik Disk Bölümleme Tablosu 4 disk bölümünü barındırmaktadır. 
    Peki bu durumda 4'ten fazla disk bölümü oluşturulamaz mı? İşte "Genişletilmiş Disk Bölümü (Extended Disk Partition)" kavramı 
    ile bu durum mümkün hale getirilmiştir. Yukarıdaki Disk Bölümleme Tablosu'nun 16 byte'lık disk bölümleri aşağıda verilmiştir:

    80 01 01 00 83 20 0d 13  3f 00 00 00 01 b0 04 00
    00 20 0e 13 83 3e 18 26  40 b0 04 00 c0 af 04 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00

    Disk Bölümleme Tablosu'ndaki 16 byte'lık disk bölümünün içeriği şöyledir:

    +--------------+----------------+---------------------------------------------------------------------+
    | Offset (Hex) |     Uzunluk    |                               Anlamı                                |
    +--------------+----------------+---------------------------------------------------------------------+
    |       0      |     1 BYTE     | Disk Bölümünün Aktif Olup Olmadığı Bilgisi                          |
    |       1      |     3 BYTE     | Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Başlangıç Sektörü |
    |       4      |     1 BYTE     | Sistem ID Değeri                                                    |
    |       5      |     3 BYTE     | Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Bitiş Sektörü     |
    |       8      | 4 BYTE (DWORD) | Disk Bölümünün LBA Sistemindeki Başlangıç Sektörü                   |
    |       C      | 4 BYTE (DWORD) | Disk Bölümündeki Sektör Sayısı (Disk Bölümünün Uzunluğu)            |
    +--------------+----------------+---------------------------------------------------------------------+

    - 4 disk bölümünden yalnızca bir tanesi aktif olabilmektedir. Sistem aktif disk bölümünden boot edilmektedir. Aktif disk 
    bölümü için 0x80 değeri, aktif olmayan disk bölümü için 0x00 değeri kullanılmaktadır.

    - Eskiden diskteki bir sektörün yeri "hangi yüzde (her yüzü bir kafa okuduğu için, hangi kafada), hangi track'te (track'e 
    silindir (cylinder) de denilmektedir) ve hangi sektör diliminde olduğu bilgisiyle ifade ediliyordu. Bu koordinat sistemine
    CHS (Cylinder-Head-Sector) koordinat sistemi deniyordu. Sonra bu koordinat sisteminden vazgeçildi. Sektörün yeri ilk sektör 
    0 olmak üzere tek bir sayıyla temsil edilmeye başlandı.

    - Her disk bölümünde farklı bir işletim sisteminin kullandığı dosya sistemi bulunuyor olabilir. "Sistem ID Değeri" o disk 
    bölümünde hangi işletim sistemine ilişkin bir dosya sisteminin bulunduğunu belirtmektedir. Böylece Disk Bölümleme Tablosu'nu 
    inceleyen kişiler disk bölümlerinin hangi işletim sistemi için oluşturulduğunu anlayabilmektedir. Tüm Sistem ID Değerleri 
    için bunların listelendiği dokümanlara başvurabilirsiniz. Biz burada birkaç System ID değerini verelim:

    0C: Windows FAT32 Sistemi
    0E: Windows FAT Sistemi
    0F: Genişletilmiş Disk Bölümü
    83: Linux Dosya Sistemlerinden Birisi
    82: Linux İçin Swap Alanı Olarak Kullanılacak Disk Bölümü

    - Bir disk bölümü için en önemli iki bilgi onun diskin hangi sektöründen başlayıp kaç sektör uzunlukta olduğudur. Yani disk 
    bölümünün başlangıç sektör numarası ve toplam sektör sayısıdır. İşletim sistemleri böylece kendileri için belirlenmiş olan 
    disk bölümlerinin dışına erişmezler. Yani disk bölümleri adeta disk içerisindeki disklerin yerlerini belirtmektedir.

    - 90'lı yıllarla birlikte diskteki sektörlerin adreslenmesi için CHS sistemi yavaş yavaş bırakılmaya başlanmış LBA (Logical 
    Block Address) denilen sisteme geçilmiştir. Bu sistemde diskin ilk sektörü 0 olmak üzere her sektöre artan sırada bir tamsayı 
    karşılık düşürülmüştür. İşte bu koordinat sistemine LBA denilmektedir. Artık MBR Disk Bölümleri'nde disk bölümünün başlangıç 
    sektörü LBA sistemine göre belirtilmektedir.

    - LBA sisteminde bir disk bölümünde en fazla 2^32 tane sektör bulunabilir. Bir sektör 2^9 (512) byte olduğuna göre MBR
    Disk Bölümleme Tablosu en fazla 2^41 = 2TB diskleri destekleyebilmektedir. Gömülü sistemlerde henüz bu büyüklükte diskler 
    kullanılmadığı için klasik MBR Disk Bölümleme Tablosu iş görmektedir. Ancak masaüstü sistemlerde artık bu sınır aşılmaktadır. 
    İşte UEFI BIOS'lar tarafından kullanılan "GUID Disk Bölümlemesi (GPT)" bu sınırı çok daha ötelere taşımaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk Bölümleme Tablosu manuel bir biçimde oluşturulabilir. Ancak Disk Bölümleme Tablosu üzerinde işlem yapan çeşitli 
    araçlar da vardır. Linux sistemlerinde en yaygın kullanılan iki araç "fdisk" ve "gparted" isimli araçlardır. fdisk komut 
    satırından kullanılabilen basit bir programdır. "gparted" ise GUI arayüzü ile görsel bir biçimde aynı işlemleri yapmaktadır. 
    "fdisk" temel bir araçtır. Dolayısıyla Linux sistemleri kurulduğunda büyük olasılıkla zaten kurulmuş olarak sisteminizde 
    bulunuyor olacaktır. Ancak "gparted" programını Debian tabanlı sistemlerde aşağıdaki gibi siz kurmalısınız:

    $ sudo apt-get install gparted
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                187. Ders 22/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada Linux sistemlerindeki fdisk programının kullanımı üzerinde duracağız. Bu tür denemeleri loop aygıtları üzerinde 
    yapmalısınız. fdisk kullanımını maddeler halinde açıklayalım:

    1) Hangi disk üzerinde işlem yapılacaksa o diske ilişkin aygıt dosyası fdisk programına komut satırı argümanı olarak 
    verilmelidir. Tabii disk aygıt dosyaları "root" kullanıcısına ilişkin olduğu için fdisk programı da genellikle "sudo" 
    ile çalıştırılır. Örneğin önce blok aygıt sürücülerimize bakalım:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    ******************************************************

    Burada "sda" diski bir bütün olarak gösteren aygıt sürücüsüdür. Bu aygıt sürücüye ilişkin aygıt dosyası "/dev/sda" biçimindedir. 
    "sda1", "sda2" ve "sda5" disk üzerindeki disk bölümleridir. Bizim bölümlendirme için diski bir bütün olarak ele almamız gerekir. 
    Bu nedenle "sda" diski için fdisk programı şöyle çalıştırılmalıdır:

    $ sudo fdisk /dev/sda

    Tabi biz örneğimizde loop aygıtı kullanacağız. Bu durumda loop aygıtını şöyle kullanıma hazır hale getirebiliriz:

    ******************************************************
    $ dd if=/dev/zero of=disk.img bs=300M count=1
    1+0 kayıt girdi
    1+0 kayıt çıktı
    314572800 bytes (315 MB, 300 MiB) copied, 1,23241 s, 255 MB/s
    ******************************************************

    Buradan diski temsil eden içi sıfırlarla dolu 300MB'lik bir dosya oluşturduk. Şimdi bu dosyayı "/dev/loop0" aygıt dosyası 
    ile bir blok aygıtı gibi gösterelim:

    $ sudo losetup /dev/loop0 disk.img

    Artık "/dev/loop0" aygıt dosyası sanki bir disk gibi kullanılabilecektir. Bu aygıt üzerinde işlem yaptığımızda işlemden 
    "disk.img" dosyası etkilenecektir.

    Artık blok aygıt sürücülerine baktığımızda "loop0" aygıtını göreceğiz:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0    7:0    0  300M  0 loop
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    *****************************************************

    Artık fdisk programını bu aygıt üzerinde kullanabiliriz:

    $ sudo fdisk /dev/loop0

    2) Artık interaktif bir biçimde disk bölümlendirme işlemleri yapılabilir. Burada tek harfli çeşitli komutlar girildiğinde
    interaktif bir biçimde işlemler yapılmaktadır. Bu komutlardan önemli olanlarını açıklamak istiyoruz:

    - "n" (new) komutu yeni bir disk bölümü oluşturmak için kullanılmaktadır. Bu komut verildiğinde yaratılacak disk bölümünün 
    "primary" bölüm mü "extended" bölüm mü olduğu sorulmaktadır. Primary disk bölümü ana 4'lük girişteki bölümlerdir. Dolayısıyla
    burada genellikle "p" komutu ile "primary" disk bölümü oluşturulur. Sonra bize 4 girişten hangisinin disk bölümü olarak 
    oluşturulacağı sorulmaktadır. Bu durumda sıradaki numarayı vermek (disk tamamen ilk kez bölümlendiriliyorsa 1) uygun olur. 
    Sonra da bize ilgili disk bölümünün hangi sektörden başlatılacağı ve ne uzunlukta olacağı sorulmaktadır. Aşağıda bir örnek 
    görüyorsunuz:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (0 birincil, 0 genişletilmiş, 4 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (1-4, varsayılan 1): 1
    İlk sektör (2048-614399, varsayılan 2048):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-614399, varsayılan 614399): +50M

    Yeni bir disk bölümü 1, 'Linux' tipinde ve 50 MiB boyutunda oluşturuldu.
    ***************************************************************************************

    - "p" (print) komutu oluşturulmuş olan disk bölümlerini görüntülemektedir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M 83 Linux
    **************************************************************************************

    - fdisk yaratılan disk bölümlerinin ID'sini default olarak 0x83 (Linux) yapmaktadır. Eğer disk bölümüne FAT dosya sistemi 
    yerleştirilecekse "t" (type) komutu ile bölüm ID'si değiştirilmelidir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): t
    Seçilen disk bölümü 1
    Hex kod (bütün kodlar için L tuşlayın): c
    'Linux' disk bölümünün tipini 'W95 FAT32 (LBA)' olarak değiştirin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    **************************************************************************************

    Şu anda biz bir FAT disk bölümü yaratmış olduk. Şimdi ikinci Linux dosya sistemleri için ikinci bölümünü de yaratalım:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (1 birincil, 0 genişletilmiş, 3 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (2-4, varsayılan 2):
    İlk sektör (104448-614399, varsayılan 104448):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (104448-614399, varsayılan 614399):

    Yeni bir disk bölümü 2, 'Linux' tipinde ve 249 MiB boyutunda oluşturuldu.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    Artık diskimizde iki disk bölümü vardır.

    - Bir disk bölümünü aktive etmek için "a" komutu (activate) kullanılmaktadır. Örneğin biz FAT32 disk bölümünü aktif disk 
    bölümü haline getirelim:

    **************************************************************************************
    Komut (yardım için m): a
    Disk bölümü numarası (1,2, varsayılan 2): 1

    Disk bölümü 1'de önyüklenebilir bayrağı artık etkin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1 *           2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    - fdisk önce yazılacakları kendi içerisinde biriktirmekte sonra bunları diske yazmaktadır. Biriktirilenlerin diske yazılması 
    için "w" (write) komutu kullanılmaktadır. Örneğin:

    **************************************************************************************
    Komut (yardım için m): w
    Disk bölümleme tablosu değiştirildi.
    Disk bölüm tablosunu yeniden okumak için ioctl() çağrılıyor.
    Disk bölümü tablosu yeniden okunamadı.: Geçersiz bağımsız değişken

    Çekirdek hala eski tabloyu kullanıyor. Yeni tablo bir sonraki yeniden başlatma işleminden sonra ya da partprobe(8) veya 
    kpartx(8)'i çalıştırdığınızda kullanılacak.
    **************************************************************************************

    - Bir disk bölümünü silmek için "d" komutu kullanılmaktadır. Disk bölümlerini silerken dikkat ediniz.

    3) Disk bölümlerini oluşturduktan sonra çekirdeğin onları o anda görmesi için "partprobe" komutu kullanılmalıdır. Örneğin:

    **************************************************************************************
    $ sudo partprobe /dev/loop0
    [sudo] kaan için parola:
    $ lsblk
    NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0       7:0    0  300M  0 loop
    ├─loop0p1 259:0    0   50M  0 part
    └─loop0p2 259:1    0  249M  0 part
    sda         8:0    0   80G  0 disk
    ├─sda1      8:1    0  512M  0 part /boot/efi
    ├─sda2      8:2    0    1K  0 part
    └─sda5      8:5    0 79,5G  0 part /
    sr0        11:0    1 1024M  0 rom
    **************************************************************************************

    Aslında yukarıda yapılan işlemlerin sonucu olarak Disk Bölümleme Tablosu'ndaki iki giriş (32 byte) güncellenmiştir.

    5) fdisk programının başka komutları da vardır. Örneğin disk bölümlendirmesi yapıldıktan sonra bu bölümlendirme bilgileri 
    "O" komutu ile bir dosyaya aktarılabilir. Sonra "I" komutu ile bu dosyadan yükleme yapılabilir. Böylece farklı diskler 
    için aynı işlemlerin daha kolay yapılması sağlanabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz modern Linux sistemlerinde yetki gerektiren programları "sudo" komutuyla ("sudo" bir programdır) çalıştırmaktayız. 
    Bir programı "sudo" ile çalıştırdığımızda yaratılan prosesin etkin kullanıcı id'si 0 ve etkin grup id'si, gerçek kullanıcı 
    id'si ve gerçek grup id'si 0 olur. Kullanıcı id'si sıfır olan kullanıcı genellikle "root" ismiyle bulundurulmaktadır. Pek 
    çok UNIX türevi sistemde aynı zamanda 0 numaralı bir grup da bulunmaktadır. Bu da genellikle "root" biçiminde isimlendirilmektedir. 
    Yani "root" isminde hem bir kullanıcı hem de bir grup bulunmaktadır. Anımsanacağı gibi prosesin etkin grup id'sinin 0 olması 
    hiçbir erişim ayrıcalığı oluşturmamaktadır. Asıl olan "etkin kullanıcı id'sinin" 0 olmasıdır. Anımsanacağı gibi Linux sistemleri 
    install edilirken kurulum sırasında kullanıcının girdiği isimle aynı olan bir kullanıcı ismi ve grup ismi oluşturulmaktadır. 
    Kullanıcı ve grup id'lerinin farklı isim alanlarında olduğunu anımsayınız. Örneğin 1000 numaralı bir kullanıcı id'si de olabilir, 
    bir grup id'si de olabilir. Ancak aynı id'ye sahip birden fazla kullanıcı ya da grup olmamalıdır. (Tabii bu durum aslında 
    yasak değildir. Yani biz örneğin etkin kullanıcı id'si 0 olan başka bir kullanıcı da yaratabiliriz. Çekirdek, isimleri 
    değil numaraları işleme sokmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programı "sudo" ile çalıştırdığımızda çalıştırılan programa ilişkin prosesin etkin ve gerçek kullanıcı id'sinin ve grup
    id'sinin 0 olduğunu belirtmiştik. Yani "sudo" ile bir programı çalıştırdığımızda adeta program "root" kullanıcısı tarafından 
    çalıştırılıyormuş gibi bir etki oluşmaktadır. Linux dağıtımlarının bir bölümünde "root" kullanıcısı ile "login" olma güvenlik
    gerekçesiyle engellenmiştir. Ancak bu dağıtımlarda "root" olarak "bash" komut satırına düşmek istiyorsanız "sudo" ile "bash" 
    programını çalıştırabilirsiniz. Örneğin:

    $ sudo bash

    Bir programı "sudo" ile çalıştırmak istediğimizde bizden önce kendi kullanıcımıza ilişkin parola istenmektedir. Ancak bir 
    süre içerisinde artık "sudo" yapıldığında parola istenmeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Her kullanıcı "sudo" yapamamaktadır. "sudo" yapabilen kullanıcılara "sudoer" denilmektedir. Sistem kurulurken kurulum
    programı tarafından yaratılan kullanıcı "sudoer" durumundadır. Bir kullanıcıyı "sudoer" yapabilmek için en basit yol o 
    kullanıcıyı "/etc/group" dosyasında "sudo" grubuna eklemektir. Örneğin kursun yapıldığı makinedeki "/etc/group" dosyasının 
    "sudo" grup satırı şöyledir:

    sudo:x:27:kaan

    Buradan "sudo" grubunun grup id'sinin 27 olduğu ve "kaan" kullanıcısının bu gruba ek grup (supplementary group) biçiminde 
    dahil olduğu görülmektedir. Şimdi biz "ali" kullanıcısının da "sudo" yapabilmesini istiyorsak "ali" kullanıcı ismini de 
    aşağıdaki gibi satıra eklemeliyiz:

    sudo:x:27:kaan,ali

    Aslında bu işlem komut satırında "usermod" komutu ile "-a" ve "-G" seçenekleri kullanılarak da yapılabilmektedir. Örneğin:

    $ sudo usermod -a -G sudo student

    Tabii bu komutu şöyle de uygulayabilirdik:

    $ sudo usermod -aG sudo student

    Kullanıcıya "sudo" yeteneği verebilmenin diğer bir yolu da "/etc/sudoers" dosyasına yeni bir giriş eklemektir. Biz burada 
    bu yöntem üzerinde durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programı "sudo" ile çalıştırdığımızda üst prosesin çevre değişkenleri default durumda çalıştırılan programa aktarılmamaktadır.
    Örneğin biz kabukta bazı çevre değişkenleri tanımlamış olalım. "sudo" ile bir program çalıştırdığımızda bu çevre değişkenleri 
    default durumda yaratılan prosese aktarılmayacaktır. Bunu basit bir biçimde deneyimleyebiliriz. Bunun için önce komut 
    satırında aşağıdaki gibi çevre değişkenleri oluşturabiliriz:

    $ export XXX=100
    $ export YYY=100

    Şimdi "env" komutunu uygularsak bu çevre değişkenlerinin yaratılmış olduğunu görürüz. Ancak "sudo env" komutunu uyguladığımızda
    bu çevre değişkenleri alt prosese aktarılmayacağı için onları göremeyeceğiz. Ancak kabuğun çevre değişkenleri çalıştırılan 
    programa ilişkin prosese "-E" seçeneği kullanılarak aktarılabilmektedir. Örneğin:

    $ sudo -E env

    Ancak "-E" seçeneği de güvenlik gerekçesiyle PATH çevre değişkenini yaratılan prosese geçirmemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                188. Ders 27/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sudo işlemi konusunda "/etc/sudoers" dosya da etkilidir. Bu dosyaya girişler eklenerek belli bir proses sudoer yapılabilmektedir. 
    Bu dosyanın başındaki aşağıdaki satırlar önemlidir:

    Defaults        env_reset
    Defaults        mail_badpass
    Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
    Defaults        use_pty

    Buradaki "env_reset" satırında "env_reset" yerine "env_keep" getirilirse default olarak burada belirtilen çevre değişkenleri 
    sudo ile çalıştırılan proseslere aktarılmaktadır. Örneğin:

    Defaults    env_keep += "XX YY"

    Burada sudo ile bir program çalıştırıldığında alt prosese XX ve YY çevre değişkenleri aktarılacaktır. env_keep += "*"
    tüm çevre değişkenlerinin aktarılacağı anlamına gelir. Ancak yine PATH çevre değişkeni bunun dışındadır. Örneğin:

    Defaults    env_keep += "*"

    Eğer PATH çevre değişkeninin de yaratılan prosese aktarılması isteniyorsa secure_path satırı kaldırılmalı ya da # ile 
    yorum satırı içerisine alınmalıdır. Örneğin:

    Defaults        env_reset
    Defaults        mail_badpass
    # Defaults      secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
    Defaults        use_pty
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik UNIX tasarımında erişim bakımından "ya hep ya hiç" sistemi uygulanmaktadır. Yani sıradan kullanıcılar sistemle 
    ilgili önemli dosyalara erişemezler ve sistemde davranış değişikliklerine yol açabilecek sistem fonksiyonlarını çağıramazlar. 
    Ancak prosesin kullanıcı id'si 0 ise (yani proses "root" hakkına sahipse) her şeyi yapabilirler. Bazı UNIX türevi sistemlerde 
    bu "ya hep ya hiç" sistemi "yeteneklilik (capability)" denilen kavramla yumuşatılmıştır. Bu sistemlerde çeşitli yetenekler 
    vardır. Bir proses root hakkına sahip olmasa bile bu yeteneklerden bazılarına sahip olabilir. Bu durumda bu yetenekleri 
    gerektiren bazı işlemleri yapabilir.

    Yeteneklilik (capability) konusu POSIX standartlarına sokulmamıştır. POSIX standartları genel olarak "uygun öncelik 
    (appropriate privileges)" terimini kullanmaktadır. Burada uygun öncelik prosesin root önceliğinde olması ya da ilgili 
    işlemi yapacak yeteneğe sahip olması anlamına gelmektedir.

    Yeteneklilik konusu POSIX tarafından standardize edilmiş bir konu olmadığı için farklı UNIX türevi sistemlerde farklı 
    biçimlerde gerçekleştirilmiştir. Ancak bunlar arasında en geniş tasarıma sahip olan Linux sistemleridir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in sahip olabileceği yetenekler proses kontrol bloğunda bitsel bir biçimde tutulmaktadır. Linux'taki yetenekler
    şunlardır:

    CAP_CHOWN: Dosya sahibi ve grup değiştirme yeteneği.
    CAP_DAC_OVERRIDE: Dosya erişim kontrollerini geçme yeteneği (okuma/yazma/çalıştırma).
    CAP_DAC_READ_SEARCH: Dosya okuma ve dizin arama izinlerini geçme yeteneği.
    CAP_FOWNER: Dosya üzerinde, sahibi tarafından yapılan işlemleri yapma yeteneği (örneğin dosyanın erişim özelliklerinin 
    değiştirilmesi gibi)
    CAP_FSETID: Dosyanın UID veya GID’sini değiştirme yeteneği.
    CAP_KILL: Diğer proseslere sinyal gönderme yeteneği.
    CAP_SETGID: Kullanıcı grubunu değiştirme yeteneği.
    CAP_SETUID: Kullanıcı kimliğini değiştirme yeteneği.
    CAP_SETPCAP: Process yetenekliliğini değiştirme yeteneği.
    CAP_SETFCAP: Bir dosyanın yeteneklerini değiştirme yeteneği
    CAP_LINUX_IMMUTABLE: Bir dosyanın değiştirilemez (immutable) hale getirilmesini sağlama yeteneği.
    CAP_NET_BIND_SERVICE: Düşük numaralı portlara (1024'ten küçük) bağlanma yeteneği.
    CAP_NET_BROADCAST: Ağda broadcast (yayın) yapma yeteneği.
    CAP_NET_ADMIN: Ağ ayarlarını yönetme, ağ arayüzlerini yapılandırma yeteneği.
    CAP_NET_RAW: Düşük seviyeli ağ işlemleri yapabilme yeteneği.
    CAP_IPC_LOCK: Bellek üzerinde kilit (lock) işlemleri yapma yeteneği.
    CAP_IPC_OWNER: IPC (Inter-process communication) kaynaklarının sahipliğini değiştirme yeteneği.
    CAP_SYS_MODULE: Linux modüllerini yükleme ve kaldırma yeteneği.
    CAP_SYS_RAWIO: Donanımsal I/O portlarına erişme yeteneği
    CAP_SYS_CHROOT: chroot (root dosya sistemi değiştirme) işlemi yapma yeteneği.
    CAP_SYS_PTRACE: Diğer süreçleri izleme ve kontrol etme yeteneği (örneğin, hata ayıklama).
    CAP_SYS_PACCT: Process accounting verilerini okuma veya yazma yeteneği.
    CAP_SYS_ADMIN: Sistem yöneticisi yetkileri (modül yükleme, dosya sistemi değiştirme vb.).
    CAP_SYS_BOOT: Sistemi yeniden başlatma veya açma yeteneği.
    CAP_SYS_NICE: Diğer proseslerin nice değerini değiştirme yeteneği.
    CAP_SYS_RESOURCE: Sistem kaynaklarını yönetme ve limitlerini ayarlama yeteneği.
    CAP_SYS_TIME: Sistemin saatini değiştirme yeteneği.
    CAP_SYS_TTY_CONFIG: TTY (terminal) ayarlarını değiştirme yeteneği.
    CAP_MKNOD: Aygıt dosyaları oluşturma yeteneği.
    CAP_LEASE: Dosya kiralama (lease) mekanizmasını kullanma yeteneği.
    CAP_AUDIT_WRITE: Audit (denetim) sistemine yazma yeteneği.
    CAP_AUDIT_CONTROL: Audit sistemi yapılandırmalarını değiştirme yeteneği.
    CAP_SETFCAP: Dosya yetenekliliğini (capabilities) ayarlama yeteneği.
    CAP_MAC_OVERRIDE: MAC (Mandatory Access Control) politikalarını geçme yeteneği.
    CAP_MAC_ADMIN: MAC politikalarını yönetme yeteneği.
    CAP_SYSLOG: Sistem günlüklerini (log) okuma veya yazma yeteneği.
    CAP_WAKE_ALARM: Sistemi uyanma alarmıyla uyandırma yeteneği.
    CAP_BLOCK_SUSPEND: Sistemin uykuya geçmesini engelleme yeteneği.
    CAP_AUDIT_READ: Audit verilerini okuma yeteneği.
    CAP_PERFMON: Performans izleme (profiling) yeteneği.
    CAP_BPF: BPF (Berkeley Packet Filter) programlarını yükleme ve çalıştırma yeteneği.
    CAP_CHECKPOINT_RESTORE: Bir süreç için checkpoint alma ve geri yükleme yeteneği.

    Örneğin biz kill fonksiyonuyla kabaca yalnızca kendimizin oluşturduğu proseslere sinyal gönderebiliriz. Ancak eğer prosesimizin
    CAP_KILL yetenekliliği varsa bu durumda tıpkı root prosesi gibi başka proseslere de sinyal gönderebiliriz.

    Linux sistemlerindeki yeteneklilik (capability) konusu maalesef biraz karmaşık bir konudur. İzleyen paragraflarda konunun
    ayrıntılarına gireceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde yeteneklilik proses temelinde değil thread temelinde uygulanmaktadır. Yani prosesin farklı 
    thread'leri farklı yeteneklere sahip olabilmektedir. Ancak pratikte prosesin tüm thread'leri genellikle aynı yeteneklere 
    sahip olur. Yetenekler proses kontrol bloğunda bitsel düzeyde tutulmaktadır. Yani yukarıdaki listedeki CAP_XXX sembolik 
    sabitleri aslında tüm bitleri 0 olan yalnızca tek biti 1 olan sembolik sabitlerdir. Eskiden proses kontrol bloğunda yetenekleri 
    tutan nesneler 32 bitlik nesnelerdi. Sonra çeşitli yetenekler de sisteme eklenince bunlar 64 bite yükseltildiler. Bugünkü
    Linux çekirdeklerinde thread'e ilişkin yetenekler task_struct yapısının cred isimli elemanının gösterdiği struct cred
    yapısında tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in dört grup yetenekleri vardır: Etkin yetenekler (effective capabilities), izin verilen yetenekler (permitted 
    capabilities), aktarılan yetenekler (inheritable capabilities) ve sarmalayan yetenekler (bounding capabilities). Test 
    işlemlerine etkin yetenekler sokulmaktadır. Örneğin thread'imizin başka bir prosese sinyal gönderebilmesi için thread'imizin 
    etkin yetenekleri arasında CAP_KILL bulunuyor olması gerekir. İzin verilen yetenekler (permitted capabilities) etkin yetenekler 
    için bir üst küme oluşturmaktadır. Yani bir thread'in kendisinin etkin yetenekleri ancak izin verilen yetenekleri kadar olabilir. 
    Thread'in bir etkin yetenek kümesinde bir yetenek yoksa ancak izin verilen kümesinde varsa proses izin verilen kümesi içerisindeki 
    o yeteneği etkin kümesine taşıyabilir. Ancak izin verilen kümesini genişletemez. Başka bir deyişle thread'in etkin yetenek 
    kümesi izin verilen yetenek kümesinin bir alt kümesi biçimindedir. Aktarılabilen yetenek kümesi, thread bir programı çalıştırdığında 
    onun izin verilen kümesine dahil edilebilecek yetenekleri belirtmektedir. Benzer biçimde thread'in sarmalayan yetenekleri 
    de izin verilen yeteneklerin belirlenmesi sırasında etki göstermektedir. Bu konu izleyen paragraflarda ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda Linux çekirdeğinin yetenekleri thread temelinde işleme soktuğunu belirttik. Yetenekler fork işlemi sırasında
    ya da pthread_create işlemi sırasında (bu da bir çeşit fork işlemi gibidir) üst thread'ten alt thread'e aktarılmaktadır. 
    Yani aslında default durumda bir prosesin tüm thread'leri aynı yeteneklere sahiptir. Fakat biz istersek prosesin belli bir 
    thread'inin yeteneklerini diğer thread'lere dokunmadan değiştirebiliriz. Üst proses fork uyguladığında onun "etkin", "izin 
    verilen" ve "aktarılan" yeteneklerinin hepsi alt prosese aktarılmaktadır.

    Herhangi bir önceliğe sahip olmayan sıradan proseslerin etkin, izin verilen ve aktarılan yetenek kümesinde hiçbir yetenek 
    yoktur. Örneğin biz bir terminal açıp orada çalışan kabuk programının (bash) yetenek kümelerine baksak bu üç yetenek kümesinin
    de boş küme olduğunu görürüz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde thread'in yeteneklerini elde etmek ve set etmek için sys_getcap ve sys_setcap isimli iki sistem fonksiyonu 
    bulundurulmuştur. Ancak libc kütüphanesinde bu sistem fonksiyonlarını çağıran fonksiyonlar bulunmamaktadır. Eğer bu sistem 
    fonksiyonlarını çağıracaksanız bunların numaralarını belirterek syscall isimli fonksiyonla çağırabilirsiniz. Ancak bu sistem 
    fonksiyonlarının kullanımı biraz zahmetlidir. Bu fonksiyonlar yerine bu sistem fonksiyonları çağrılarak yazılmış olan "libcap" 
    isimli bir kütüphane de bulunmaktadır. Sistem programcıları genellikle sys_getcap ve sys_setcap fonksiyonlarını kullanmak yerine 
    zaten bunları kullanan "libcap" kütüphanesini kullanmayı tercih etmektedir. Ancak bu "libcap" kütüphanesi default durumda 
    genellikle yüklü olmaz. Bu kütüphaneyi Debian türevi sistemlerde aşağıdaki gibi yükleyebilirsiniz.

    $ sudo apt install libcap2 libcap-dev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin yetenek kümeleri "/proc/<pid>/status" dosyasından elde edilebilir. Buradaki yeteneklere ilişkin bilgiler 
    aşağıdaki gibi gözükecektir:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Bu örnekte prosesin bütün yetenek kümesi boştur. Yani proses hiçbir yeteneğe sahip değildir. Anımsanacağı gibi aslında 
    "proc" dosya sisteminde her thread için bir dizin yaratılmaktadır. Yani "/proc/<pid>/status" yol ifadesindeki pid aslında 
    ilgili thread'in gettid fonksiyonu ile elde edilen pid numarasıdır. (POSIX standartlarında thread'lerin pid değerinin 
    olmadığını ancak Linux sistemlerinde Linux çekirdeğinin thread'leri prosesler gibi oluşturduğu için thread'lerin de pid 
    değerlerinin olduğunu anımsayınız. Yine anımsanacağı gibi proc dosya sisteminde ana thread'e ilişkin "task" dizininde 
    prosesin thread'lerinin pid numaraları bulunmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in yetenekleri programlama yoluyla "libcap" kütüphanesindeki cap_get_proc fonksiyonu ile elde edilebilir. Fonksiyon 
    kendisini çağıran thread'in yetenek bilgilerini temsil eden cap_t türünden bir handle değeri ile geri döner.

    #include <sys/capability.h>

    cap_t cap_get_proc(void);

    cap_t türü aşağıdaki gibi bildirilmiştir:

    typedef struct __user_cap_header_struct {
        unsigned int version;        // Yapı versiyonu
        pid_t pid;                    // İlgili işlem ID'si
    } __user_cap_header_t;

    typedef struct __user_cap_data_struct {
        unsigned int effective;        // Etkin yetenekler
        unsigned int permitted;        // İzin verilen yetenekler
        unsigned int inheritable;    // Miras alınan yetenekler
    } __user_cap_data_t;

    typedef struct __user_cap_struct {
        __user_cap_header_t header;    // Başlık bilgisi
        __user_cap_data_t data[2];    // Yetenek verisi (genellikle iki set)
    } *cap_t;

    Örneğin:

    cap_t caps;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("get_cap_proc");

    cap_get_pid fonksiyonu ise pid değeri verilen prosesin (ya da thread'in) yeteneklerini elde etmektedir. Fonksiyonun prototipi
    şöyledir:

    cap_t cap_get_pid(pid_t pid);

    cap_t türünün bir yapı adresini belirttiğine dikkat ediniz. Bu fonksiyonlar kendi içerisinde cap_t türünden bir yapı nesnesini 
    dinamik olarak tahsis edip onun adresiyle geri dönmektedir. Bu dinamik alanın boşaltımı cap_free fonksiyonu ile yapılmalıdır:

    #include <sys/capability.h>

    int cap_free(void *obj_d);

    Aslında cap_free fonksiyonu yalnızca free fonksiyonunu çağırmaktadır.

    Örneğin:

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("get_cap_proc");

    /* ... */

    cap_free(caps);

    Her ne kadar cap_get_pid fonksiyonu sanki proses id alıyor gibiyse de yukarıda da belirttiğimiz gibi yetenekler aslında
    prosese değil thread'e özgüdür. Biz bu fonksiyona bir prosesin pid değerini geçirdiğimizde o prosesin ana thread'ine ilişkin
    yetenekleri elde etmiş oluruz. Belli bir thread'in bilgileri elde edilecekse doğrudan gettid fonksiyonu ile thread'in 
    pid değeri elde edilebilir. cap_get_proc fonksiyonu ise o anda çalışmakta olan thread'in yeteneklerini elde etmekte 
    kullanılmaktadır.

    Thread'in yetenekleri elde edildiğinde onların yazdırılması da bir sorundur. Bu nedenle "libcap" kütüphanesinde cap_to_text
    isimli bir fonksiyon bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <sys/capability.h>

    char *cap_to_text(cap_t caps, ssize_t *length_p);

    Fonksiyonun birinci parametresi cap_t türünden handle değerini, ikinci parametresi verilen yazının uzunluğunun yerleştirileceği
    nesnenin adresini belirtir. İkinci parametre NULL adres geçilebilir. Bu durumda fonksiyon böyle bir yerleştirme yapmaz. 
    Fonksiyon oluşturulan yazının adresine geri dönmektedir. Yine bu adresin de kullanımdan sonra cap_free ile boşaltılması gerekir. 
    Eğer cap_to_text fonksiyonunda yalnızca "=" biçiminde bir yazı elde ediliyorsa bu durum thread'in herhangi bir yeteneğe 
    sahip olmadığı anlamına gelmektedir.

    Aşağıda o anda çalışmakta olan thread'in yetenekleri ekrana yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t caps;
    char *captext;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                189. Ders 05/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in yetenekleri onu yaratan thread'ten aktarılmaktadır. Yani genel olarak bir proses bir thread yarattığında 
    ya da fork işlemi yaptığında yaratılan thread ya da proses bu işlemi uygulayan thread ile aynı yeteneklere sahip olur. 
    Sıradan bir prosesin ya da onun thread'lerinin yeteneklerine baktığımızda tipik olarak şöyle olduğunu görürüz:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Buradan çıkan sonuç şudur: Sıradan bir prosesin ya da thread'in aktarılan, izin verilen ve etkin yetenek kümesi boş 
    kümedir. Yani bu küme hiçbir yeteneği kapsamamaktadır. Ancak sarmalayan yeteneklerin (bounding capabilities) bütün bitlerinin
    1 olduğunu görüyorsunuz. (Her ne kadar burada yüksek anlamlı bitlerin bazılarını 0 görüyor olsanız da zaten Linux o bitleri 
    kullanmamaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Etkin kullanıcı id'si 0 olan proseslerin hiçbir engele takılmadığını anımsayınız. Linux çekirdeği önce prosesin etkin 
    kullanıcı id'sini kontrol etmektedir. Eğer prosesin etkin kullanıcı id'si 0 ise zaten herhangi bir yetenek kontrolü 
    yapmasına gerek kalmamaktadır. Yani yetenekler ancak etkin kullanıcı id'si 0 olmayan prosesler için anlamlı bir özelliktir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki sıradan bir prosesin tüm thread'lerinin yetenekleri boş küme olduğuna göre bu prosesler ve thread'ler nasıl yetenek 
    kazanmaktadır? İşte bunun iki yolu olabilir:

    1) Yetenek kazandırabilecek yeteneğe sahip ya da etkin kullanıcı id'si 0 olan bir proses bir alt proses yaratıp onun 
    yeteneklerini oluşturup sonra kullanıcı id'sini 0 olmaktan çıkartabilir.

    2) Aslında Linux sistemlerinde çalıştırılabilen dosyalara da yetenekler atanabilmektedir. Bir çalıştırılabilen dosya exec
    fonksiyonlarıyla çalıştırıldığında izleyen paragraflarda açıklanacağı gibi otomatik olarak proses bazı yeteneklere sahip
    olabilmektedir. Bu durum aslında daha önce gördüğümüz çalıştırılabilen dosyaların "set-user-id" ve "set-grup-id" bayraklarına
    benzemektedir. Örneğin thread'imizin yetenek kümeleri boş küme olsun. Ama biz "xxx" isimli programı exec fonksiyonlarıyla
    çalıştırmak isteyelim. Bir kez fork yapıp alt proseste exec yaptığımızda artık alt prosesimizin yetenekleri bu "xxx" 
    dosyasında belirtilen yeteneklere sahip olabilmektedir. Yani proseslerin ve thread'lerin yetenekleri aslında genellikle 
    exec işlemi sırasında boş küme olmaktan çıkmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki thread'imize belli bir yeteneği nasıl kazandırabiliriz? Bir thread etkin yeteneklerini ancak izin verilen yetenekler 
    kadar artırabilir. O halde önce thread'imizin izin verilen yeteneklerini artırması gerekir. Bunun için sırasıyla şu işlemler
    yapılmalıdır:

    1) Önce içi boş bir yetenek nesnesi cap_init fonksiyonuyla oluşturulur. cap_init fonksiyonunun prototipi şöyledir:

    #include <sys/capability.h>

    cap_t cap_init(void);

    cap_init fonksiyonu başarısızlık durumunda NULL adrese geri dönmektedir.

    Örneğin:

    cap_t newcaps;

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    2) Bu yetenek nesnesine cap_set_flag fonksiyonu ile çeşitli bayraklar eklenir. Fonksiyonun prototipi şöyledir:

    #include <sys/capability.h>

    int cap_set_flag(cap_t cap_p, cap_flag_t flag, int ncap, const cap_value_t *caps, cap_flag_value_t value);

    Fonksiyonun birinci parametresi yeteneklerin set edileceği nesneyi belirtmektedir. İkinci parametre hangi yetenekler 
    üzerinde işlem yapılacağını belirtir. Bu parametre aşağıdaki sembolik sabitlerden yalnızca birini içerebilir:

    CAP_EFFECTIVE
    CAP_INHERITABLE
    CAP_PERMITTED

    Fonksiyon tarafından set edilecek yetenekler dördüncü parametresi ile belirtilen dizinden elde edilmektedir. Yani programcı 
    cap_value_t türünden bir dizi oluşturup bu dizinin içerisine yetenekleri yerleştirir. Fonksiyonun üçüncü parametresine de
    bu dizinin uzunluğunu geçirir. Fonksiyonun son parametresi aşağıdaki iki değerden biri olarak girilir:

    CAP_CLEAR
    CAP_SET

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};
    ...

    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    3) Oluşturulan yetenekler cap_set_proc fonksiyonu ile o anda çalışan thread'e aktarılır. cap_set_proc fonksiyonunun 
    prototipi şöyledir:

    #include <sys/capability.h>

    int cap_set_proc(cap_t cap_p);

    Fonksiyon hazırlanan capt_t nesnesini parametre olarak alır. Thread'in yeteneklerini set eder. Başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri döner. Örneğin:

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                190. Ders 10/01/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir thread'in yeteneklerini değiştiren örnek bir program verilmiştir. Tabii cap_set_proc fonksiyonunun da kullanılması
    için prosesin uygun önceliğe sahip olması gerekir. (Yani prosesin etkin kullanıcı id'si 0 olmalı ya da ilgili thread yetenek
    değiştirme yeteneği olan CAP_SYS_ADMIN yeteneğine sahip olmalıdır.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");


    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    printf("Ok\n");

    getchar();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda önce thread'in izin verilen ve etkin yetenekleri değiştirilmiş sonra da bu yetenekler elde edilip yazdırılmıştır. 
    Programın çalıştırılması sonucunda aşağıdaki gibi bir çıktı elde edilecektir:

    cap_chown,cap_kill=ep
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t newcaps, caps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};
    char *captext;

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proses root olarak (etkin kullanıcı id'si 0 olarak) çalışıyor olsun. Prosesin etkin kullanıcı id'si seteuid fonksiyonuyla 
    değiştirildiğinde prosesin tüm thread'lerinin etkin yetenekleri sıfırlanmaktadır. Ancak izin verilen yeteneklerine dokunulmamaktadır. 
    Ancak prosesin gerçek kullanıcı id'si ile etkin kullanıcı id'si setuid fonksiyonu ile değiştirildiğinde prosesin tüm 
    thread'lerinin hem izin verilen hem de etkin yetenekleri sıfırlanmaktadır. Bu konudaki ayrıntılar için "capabilities(7)"
    man sayfasına başvurabilirsiniz.

    Aşağıdaki örnekte seteuid fonksiyonundan sonra thread'in etkin yeteneklerinin düşürüldüğüne ilişkin bir örnek verilmiştir.

    Program çalıştırıldığında ekranda şunlar görünecektir:

    cap_chown,cap_kill,cap_setuid=ep
    cap_chown,cap_kill,cap_setuid=p
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_capability(void)
{
    cap_t caps;
    char *captext;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);
}


int main(void)
{
    cap_t newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    disp_capability();

    if (seteuid(1000) == -1)
        exit_sys("seteuid");

    disp_capability();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeği kendi içerisinde aslında hep yetenek kontrolü yapmaktadır. Yani bir prosesin root önceliğinde olması 
    (yani etkin kullanıcı id'sinin 0 olması) aslında izin verilen ve etkin yeteneklerin hepsinin set edildiği anlamına 
    gelmektedir. Dolayısıyla biz bir programı sudo ile çalıştırdıktan sonra onun etkin yeteneklerini değiştirirsek artık 
    proses'in etkin kullanıcı id'si 0 olsa bile proses yetenek kaybedecektir.

    open fonksiyonu tarafından uygulanan erişim kontrollerinin thread yetenekleriyle bir ilgisi yoktur. Yani etkin user id'si 
    0 olan bir root proses yetenek kümesi düşürülse bile yine open fonksiyonunda başarısız olmaz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde yalnızca thread'lerin değil, çalıştırılabilen dosyaların da yetenekleri vardır. Biz daha önce çalıştırılabilen
    bir dosyanın "set-user-id" ve "set-group-id" biçiminde isimlendirilen bayraklarının işlevlerini incelemiştik. Çalıştırılabilen
    bir dosyanın "set-user-id" bayrağı set edilmişse o programı exec yapan prosesin etkin kullanıcı id'si dosyanın kullanıcı
    id'si haline getiriliyordu. Aynı durum "set-group-id" bayrağı için de benzer biçimde işletiliyordu. Çalıştırılabilen bir 
    dosyanın "set-group-id" bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin grup id'si dosyanın grup id'si 
    oluyordu. İşte bu mekanizmanın benzeri yetenek temelinde de oluşturulmuştur. Çalıştırılabilen dosyaların da yetenekleri 
    set edilmiş olabilir. Bu durumda bu dosyalar exec yapıldığında proses otomatik olarak o yeteneğe sahip hale gelmektedir. 
    Örneğin bir program dosyasının CAP_KILL yeteneğinin set edilmiş olduğunu varsayalım. Ancak bu dosyanın etkin kullanıcı id'si 
    root olmasın. Bu dosya çalıştırıldığında ilgili thread CAP_KILL yeteneğine sahip olacaktır. (Program birden fazla thread'e
    sahipse exec işlemiyle yalnızca exec yapan thread'in yaşamına devam ettiğini anımsayınız.) Ancak dosya yetenekleri konusunun 
    da bazı ayrıntıları vardır. Dosya yetenekleri i-node elemanlarının içerisinde tutulmaktadır. Bu nedenle dosya sisteminin 
    de dosya yeteneklerini tutma özelliğine sahip olması gerekir. Örneğin FAT dosya sistemlerinde böyle bir alan bulunmamaktadır.

    Yalnızca çalıştırılabilen dosyalar için yetenek kavramı söz konusudur. Tabii bir text dosyanın içerisinde bir script kodu 
    da bulunabilir. Bu durumda bu dosyalar da çalıştırılabilen dosya olarak ele alınabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyaların yeteneklerini görüntülemek için "libcap" paketinde "getcap" isimli bir yardımcı program da bulunmaktadır. 
    Örneğin "ping" programının CAP_NET_RAW yeteneği vardır. "getcap" ile bu dosyanın yeteneklerini aşağıdaki gibi görüntüleyebiliriz:

    $ /usr/bin/ping cap_net_raw=ep
    /usr/bin/ping cap_net_raw=ep

    Tıpkı thread'ler gibi dosyaların da izin verilen (permitted), etkin (effective) ve aktarılan (inheritable) yetenekleri 
    vardır. Dosyaların yetenekleri "setcap" isimli programla değiştirilebilmektedir. Programın örnek kullanımı şöyledir:

    $ sudo setcap "cap_net_bind_service=pei cap_net_raw=ep" sample

    Burada sample programına çeşitli yetenekler set edilmiştir. Bu yeteneklerin tek bir komut satırı argümanı biçiminde verildiğine
    dolayısıyla da tırnak içerisine alındığına dikkat ediniz. Eğer dosyadan tüm yetenekler silinecekse komut aşağıdaki gibi 
    kullanılabilir:

    $ sudo setcap = sample

    setcap programının kullanımına ilişkin ayrıntılar için man sayfalarına başvurabilirsiniz.

    Örneğin "sample" isimli programımıza izin verilen ve etkin olarak CAP_KILL yeteneğini eklemek isteyelim. Bu işlemi şöyle
    yapabiliriz:

    $ sudo setcap "cap_kill=ep" sample

    Şimdi dosyanın yeteneğini "getcap" komutu ile görüntüleyelim:

    $ getcap sample
    sample cap_kill=ep

    Tabii bir dosyanın yeteneğini değiştirebilmek için ilgili thread'in de CAP_SETPCAP yeteneğine sahip olması gerekir. root 
    prosesleri tüm yeteneklere sahipmiş gibi düşünmeliyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                191. Ders 12/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii aslında dosyaların yeteneklerini elde etmek ve onlara yetenek iliştirmek için Linux çekirdeğinde sistem fonksiyonları 
    bulunmaktadır. "getcap" ve "setcap" programları libcap kütüphanesindeki cap_set_file ve cap_get_file fonksiyonları kullanılarak 
    yazılmıştır. Bu fonksiyonlar da sys_setxattr, sys_fsetxattr, sys_lsetxattr ve sys_getxattr, sys_fgetxattr, sys_lgetxattr sistem 
    fonksiyonları çağrılarak yazılmıştır. Bu sistem fonksiyonları için "libc" kütüphanesinde sarma fonksiyonlar bulunmaktadır. Ancak 
    biz burada bu işlemleri "libcap" kütüphanesindeki cap_set_file ve cap_get_file fonksiyonlarını kullanarak yapacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    cap_get_file fonksiyonunun prototipi şöyledir:

    #include <sys/capability.h>

    cap_t cap_get_file(const char *path_p);

    Fonksiyon dosyanın yol ifadesini alır ve başarı durumunda dosyanın yetenek bilgilerine ilişkin cap_t nesnesine geri döner. 
    Bu nesnenin kullanımı bittikten sonra cap_free fonksiyonu ile boşaltılması gerekmektedir. Fonksiyon başarısızlık durumunda 
    NULL adrese geri dönmektedir. Örneğin:

    cap_t caps;

    if ((caps = cap_get_file("/usr/bin/ping")) == NULL)
        exit_sys("cap_get_file");

    Aşağıda fonksiyonun kullanımına ilişkin örnek bir program verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_cap(cap_t caps)
{
    char *captext;

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
}

int main(int argc, char *argv[])
{
    cap_t caps;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((caps = cap_get_file(argv[1])) == NULL)
        exit_sys("cap_get_file");

    disp_cap(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    cap_set_file fonksiyonunun prototipi de şöyledir:

    #include <sys/capability.h>

    int cap_set_file(const char *path_p, cap_t cap_p);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini, ikinci parametresi dosyaya iliştirilecek yetenekleri belirtmektedir. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Tabii bir dosyaya yetenek set
    edebilmek için ya prosesin root olması (etkin kullanıcı id'sinin 0 olması) ya da prosesin CAP_SETFCAP yeteneğine sahip olması
    gerekmektedir. Örneğin:

    cap_t caps, newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_file(argv[1], newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_file");
    }

    cap_free(newcaps);

    Burada CAP_CHOWN, CAP_KILL, CAP_SETUID yetenekleri "izin verilen" ve "etkin" yetenekler olarak dosyaya iliştirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_cap(cap_t caps)
{
    char *captext;

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
}

int main(int argc, char *argv[])
{
    cap_t caps, newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_file(argv[1], newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_file");
    }

    cap_free(newcaps);

    if ((caps = cap_get_file(argv[1])) == NULL) {
        cap_free(newcaps);
        exit_sys("cap_get_file");
    }

    disp_cap(caps);

    cap_free(caps);
    cap_free(newcaps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Ayrıca açık bir dosya için yetenekleri alan ve set eden aşağıdaki fonksiyonlar da bulunmaktadır:

    #include <sys/capability.h>

    cap_t cap_get_fd(int fd);
    int cap_set_fd(int fd, cap_t caps);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                192. Ders 19/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki çeşitli yeteneklere sahip bir program dosyası exec yapıldığında ne olur? Bu süreç biraz karışıktır. Normal olarak 
    set-user-id ve set-group-id bayraklarında olduğu gibi prosesin dosyada belirtilen yeteneklere sahip olması gerekir. Ancak 
    sürecin açıklayacağımız bazı ayrıntıları vardır.

    Öncelikle aşağıdaki gibi bir deneme yapalım. Sistem zamanını öğrenmek ve ayarlamak için kullanılan "date" programını 
    kendi dizinimize kopyalayalım:

    $ whereis date
    date: /usr/bin/date /usr/share/man/man1/date.1.gz /usr/share/man/man1/date.1posix.gz

    $ cp /usr/bin/date date

    Sistem tarihini değiştirmeye çalışalım:

    $ ./date -s "2025-01-12"
    ./date: tarih ayarlanamadı: İşleme izin verilmedi
    Paz 12 Oca 2025 00:00:00 +03

    Görüldüğü gibi bu işlem için "sudo" gerekmektedir. Şimdi de dosyaya sistem tarihini değiştirmek için gereken cap_sys_time 
    yeteneğini iliştirelim:

    $ sudo setcap cap_sys_time=pe date

    İşlemimizi doğrulayalım:

    $ sudo getcap date
    date cap_sys_time=ep

    Şimdi sistem tarihini değiştirmeye çalışalım:

    $ ./date -s "2025-01-12"
    Paz 12 Oca 2025 00:00:00 +03

    Görüldüğü gibi biz programı çalıştırdığımızda artık prosesimiz dosyada belirtilen CAP_SYS_TIME yeteneğini kazanmıştır.
    Ancak konunun bazı ayrıntıları vardır. İzleyen paragraflarda bu ayrıntılar üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread (proses de diyebiliriz) çalıştırılabilen bir dosyayı exec fonksiyonlarıyla çalıştırdığında thread'in yetenekleri 
    aşağıdaki biçimde değişime uğramaktadır (The Linux Programming Interface kitabından alınma):

    P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)
    P'(effective) = F(effective) & P'(permitted)
    P'(inheritable) = P(inheritable)

    Burada P prosesin exec öncesindeki yeteneklerini, P' exec sonrasındaki yeteneklerini, F dosyanın yeteneklerini, cap_bset 
    ise prosesin çevreleyen yeteneklerini (process bounding capabilities) belirtmektedir.

    Dosyanın etkin yetenekleri eskiden her yetenek için farklı değildi. Bütün yetenekler için tek bir bayrak kullanılıyordu. 
    Ancak bir süredir bu durum değiştirilmiştir. Artık her yetenek için ayrı bir etkinlik bayrağı tutulmaktadır. Prosesin 
    çevreleyen yetenekleri (bounding capabilities) her yetenek için 0/1 biçiminde bitlerden oluşmaktadır. Genellikle prosesin 
    çevreleyen yeteneklerinin bütün bitleri 1 durumundadır. Örneğin sıradan bir programın yeteneklerine "proc" dosya sisteminden 
    baktığımızda şunları görmekteyiz:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Görüldüğü gibi çevreleyen yeteneklerin tüm bitleri 1 durumundadır. (Yüksek anlamlı 0 olan hex digitlere ilişkin bitlerin
    zaten kullanılmadığına dikkat ediniz.)

    Buradaki durumu madde madde şöyle açıklayabiliriz:

    1) exec yapıldıktan sonra prosesin yeni izin verilen yetenekleri şu biçimde oluşturulmaktadır:

    P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)

    Burada bit OR operatörünün solundaki ifade şu anlama gelmektedir: "Prosesin exec öncesindeki aktarılan yetenekleri eğer
    aynı zamanda dosyanın aktarılan yetenekleri içerisinde varsa bu yetenekler alınmaktadır". Bit OR operatörünün sağ tarafındaki
    ifade ise şu anlama gelmektedir: "Dosyanın izin verilen yetenekleri eğer prosesin çevreleyen yeteneklerinde varsa bu 
    yetenekler alınmaktadır. Biz yukarıda prosesin çevreleyen yeteneklerinin genellikle tüm bitlerinin 1 olduğunu belirtmiştik.
    Bu durumda dosyanın izin verilen yeteneklerinin hepsi alınacaktır. Örneğin bizim dizine kopyaladığımız "date" programının 
    yetenekleri şöyledir:

    $ getcap date
    date cap_sys_time=ep

    Yani dosyanın etkin ve izin verilen yetenekleri "cap_sys_time" yeteneğine sahiptir. O halde yukarıdaki satır dikkat alındığında
    exec sonrasında prosesin izin verilen yetenekleri "cap_sys_time" yeteneğini içerecektir.

    2) exec sonrasında prosesin etkin yetenekleri exec sonrasındaki izin verilen yeteneklerinin dosyanın etkin yetenekleriyle
    maskelenmesi sonucunda elde edilmektedir:

    P'(effective) = F(effective) & P'(permitted)

    Dosyanın etkin yeteneklerinin bir şalter görevi gördüğüne dikkat ediniz. Eğer dosyanın etkin yeteneklerindeki bir yetenek
    0 ise bu durumda bu yetenek exec sonrasındaki prosesin etkin yeteneklerine yansıtılmayacaktır.

    Prosesin exec öncesindeki aktarılan yetenekleri ile exec sonrasındaki aktarılan yetenekleri arasında bir farklılık yoktur:

    P'(inheritable) = P(inheritable)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki Linux'taki yetenek konusu neden bu kadar karışık hale getirilmiştir? Tasarımın bu biçimi aslında fazlaca esnek 
    duruma izin vermektedir. Ancak bu esneklikten faydalanma durumu pratikte çokça karşımıza çıkmamaktadır. Burada aslında temel
    kullanım için şunlar söylenebilir:

    1) Bir programı sudo ile çalıştırdığımızda ya da programımızın etkin kullanıcı id'si 0 ise bu durum adeta "tüm etkin 
    yetenekleri set edilmiş" bir proses anlamına gelmektedir.

    2) Çekirdek içerisinde özel bazı durumlarda genel olarak etkin kullanıcı id'sinin 0 olup olmadığı biçiminde değil, thread'in
    ilgili yeteneğe sahip olup olmadığı biçiminde kontroller yapılmaktadır.

    3) Biz çalıştırılabilen bir dosyanın belli bir etkin yeteneğini ve izin verilen yeteneğini set edersek o programı exec ile 
    çalıştırdığımızda o yetenek exec sonrasında prosesimizin izin verilen yeteneklerine ve etkin yeteneklerine otomatik bir 
    biçimde geçer. Tersten gidersek biz bir programın çalıştırılması ile ilgili prosesin bir yetenek kazanmasını istiyorsak
    program dosyası için ilgili yeteneği etkin ve izin verilen biçimde set etmeliyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux'taki sistem fonksiyonlarının nasıl çağrılacağı üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta her sistem fonksiyonunun bir numarası vardır. Linux çekirdeği sistem fonksiyonlarının başlangıç adreslerini 
    bir gösterici dizisinde tutar. Bir sistem fonksiyonu çağrıldığında bu dizinin ilgili numaralı indeksindeki fonksiyonu 
    çağırır. Tabii akış sistem fonksiyonuna geçirilmeden thread'in akışı da user moddan kernel moda geçirilmektedir. Intel 
    sisteminde user moddan kernel moda geçiş 80H kesmesi yoluyla yapılmaktadır. Değişik sistemlerde bu işlemler değişik makine
    komutlarıyla yapıldığı için "libc" kütüphanesi syscall isimli bir sarma fonksiyon bulundurmuştur. Bu fonksiyona programcı 
    sistem fonksiyonunun numarasını ve parametrelerini girer. Fonksiyon sembolik makine dilinde yazılmış makine komutlarından 
    oluşmaktadır. Böylece ilgili sistemde çağrım için gereken işlemler taşınabilir bir biçimde yapılabilmektedir. syscall
    fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    long syscall(long number, ...);

    Fonksiyonun birinci parametresi sistem fonksiyonunun numarasını almaktadır. Diğer parametreler ilgili sistem fonksiyonuna 
    geçirilecek argümanları almaktadır. Fonksiyonun geri dönüş değeri sistem fonksiyonuna bağlı olarak değişebilmektedir. 
    Pek çok sistem fonksiyonunda 0 başarı için kullanılmaktadır. Sistem fonksiyonlarının numaralarını Internet'te pek çok 
    yerde bulabilirsiniz. Aynı zamanda bu numaralar <sys/syscall.h> başlık dosyasında SYS_xxx biçiminde define edilmiştir. 
    Örneğin prosesi sonlandıran sys_exit isimli sistem fonksiyonunun numarası 60'tır. Ancak biz bu numarayı kullanmak yerine 
    SYS_exit ismini de kullanabiliriz. SYS_exit aşağıdaki gibi define edilmiştir:

    #define SYS_exit    60

    Aşağıda sys_exit sistem fonksiyonunun syscall fonksiyonuyla çağrılmasına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

int main(void)
{
    printf("running...\n");

    syscall(SYS_exit, 0);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bazı POSIX fonksiyonları Linux'ta doğrudan belli bir sistem fonksiyonunu çağırmaktadır.
    Örneğin open POSIX fonksiyonu Linux'ta doğrudan sys_open isimli sistem fonksiyonunu; read, write ve close POSIX fonksiyonları 
    doğrudan sys_read, sys_write ve sys_close sistem fonksiyonlarını; exit POSIX fonksiyonu sys_exit sistem fonksiyonunu çağırmaktadır. 
    GNU "libc" kütüphanesinde bazı sistem fonksiyonları için POSIX standartlarında olmayan sarma fonksiyonlar da bulundurulmuştur. 
    Ancak bazı sistem fonksiyonlarını çağıran POSIX fonksiyonları da sarma fonksiyonlar da yoktur. Bu tür durumlarda ilgili 
    sistem fonksiyonu numara belirtilerek syscall fonksiyonuyla çağrılabilir.

    Aşağıdaki örnekte open, read ve close POSIX fonksiyonları yerine doğrudan Linux'taki sistem fonksiyonları çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
    int fd;
    char buf[10];
    long result;

    if ((fd = syscall(SYS_open, "sample.c", O_RDONLY)) == -1) {
        perror("SYS_open");
        exit(EXIT_FAILURE);
    }

    if ((result = syscall(SYS_read, fd, buf, 10)) == -1) {
        perror("SYS_read");
        exit(EXIT_FAILURE);
    }
    buf[result] = '\0';
    puts(buf);

    if ((result = syscall(SYS_close, fd)) == -1) {
        perror("SYS_close");
        exit(EXIT_FAILURE);
    }

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                193. Ders 26/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux kaynak kodlarının derlenmesi ve sistemin yeni çekirdekle açılması üzerinde duracağız. Çekirdek kodlarının
    derlenmesi tüm Linux sistemleri için aynı biçimde yapılmaktadır. Ancak sistemin yeni çekirdekle açılması kullanılan "boot 
    loader" programın ayarlarıyla ilgilidir. Bugün masaüstü bilgisayarlarında ağırlıklı olarak GRUB isimli bootloader 
    kullanılmaktadır. Biz burada bu nedenle sürecin GRUB'ta nasıl yürütüleceğini ele alacağız. Gömülü sistemlerde ise ağırlıklı 
    olarak U-Boot denilen boot loader kullanılmaktadır. Biz kursumuzda U-Boot hakkında bir açıklama yapmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin çekirdeklerini belleğe yükleyip kontrolün çekirdek kodlarına bırakılmasını sağlayan araçlara 
    "önyükleyici (boot loader)" denilmektedir. Microsoft Windows sistemlerinde kendi önyükleyici programını kullanmaktadır. 
    Buna "Windows Boot Manager" ya da kısaca "bootmgr" de denilmektedir. UNIX/Linux dünyasında çeşitli önyükleyici programlar
    kullanılmıştır. Halen en yaygın kullanılan önyükleyici program "grub" isimli programdır. Tabii "grub" aynı zamanda Windows 
    işletim sistemini de yükleyebilmektedir. GRUB önyükleyicisinden önce Linux sistemlerinde uzun bir süre "lilo" isimli 
    önyükleyici kullanılmıştır. Gömülü sistemlerde de çeşitli önyükleyiciler kullanılabilmektedir. Bazı gömülü sistemlerde 
    o gömülü sistemi üreten kurum tarafından oluşturulmuş olan önyükleyiciler kullanılmaktadır. Ancak gömülü sistemlerde en 
    çok kullanılan önyükleyici "U-Boot" isimli önyükleyicidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nasıl C'deki main fonksiyonuna komut satırı argümanları geçiriliyorsa işletim sistem sistemi çekirdeklerine de çeşitli 
    biçimlerde parametreler geçirilebilmektedir. Böylece çekirdek belli bir konfigürasyonla işlev görecek biçimde başlatılabilmektedir.
    Linux çekirdeğini önyükleyici yüklediğine göre çekirdek parametreleri de önyükleyici tarafından çekirdeğe aktarılmaktadır. 
    Linux'ta bu parametreler "grub" önyükleyicisinin başvurduğu dosyalarda belirtilmektedir. GRUB önyükleyicisinin kullanımı
    biraz ayrıntılıdır. Ancak biz burada grub işlemlerini daha basit ve görsel biçimde yapabilmek için "grub-customizer" 
    isimli bir programdan faydalanacağız. Bu programı Debian türevi sistemlerde aşağıdaki gibi yükleyebilirsiniz:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update
    $ sudo apt-get install grub-customizer

    Peki neden işletim sistemini yüklemek için ayrı bir programa gereksinim duyulmuştur? Eskiden işletim sistemleri doğrudan
    BIOS kodları tarafından yüklenebiliyordu. Ancak zamanla işletim sistemleri parametreler alacak biçimde geliştirildi. 
    Önyükleyiciler birden fazla çekirdeğin bulunduğu durumlarda basit ayarlarla sistem yöneticisinin istediği çekirdekle 
    boot işlemini yapabilmektedir. Diskte birden fazla işletim sisteminin bulunduğu durumlarda sistemin istenilen bir işletim 
    sistemi tarafından boot edilmesini sağlayabilmektedir. Örneğin makinemizde hem Windows hem de Linux aynı anda bulunuyor 
    olabilir. Önyükleyicimiz bize bir menü çıkartıp hangi işletim sistemi ile boot işlemini yapmak istediğimizi sorabilir. 
    Eskiden nispeten basit olan boot prosedürleri zamanla daha karmaşık hale gelmiştir. Önyükleyici programlara gereksinim 
    duyulmaya başlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki neden biz Linux çekirdeğini kaynak kodlardan yeniden derlemek isteyebiliriz? İşte bunun tipik nedenleri şunlar olabilir:

    - Bazı çekirdek modüllerinin ve aygıt sürücülerinin çekirdek imajından çıkartılması ve dolayısıyla çekirdeğin küçültülmesi için.
    - Yeni birtakım modüllerin ve aygıt sürücülerin çekirdek imajına eklenmesi için.
    - Çekirdeğe tamamen başka özelliklerin eklenmesi için.
    - Çekirdek üzerinde çekirdek parametreleriyle sağlanamayacak bazı konfigürasyon değişikliklerinin yapılabilmesi için.
    - Çekirdek kodlarında yapılan değişikliklerin etkin hale getirilmesi için.
    - Çekirdeğe yama (patch) yapılması için.
    - Yeni çıkan çekirdek kodlarının kullanılabilir hale getirilmesi için.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için öncelikle çekirdek kaynak kodlarının derlemenin yapılacağı bilgisayara indirilmesi gerekir. Pek 
    çok dağıtım default durumda çekirdeğin kaynak kodlarını kurulum sırasında makineye çekmemektedir. Çekirdek kodları "kernel.org"
    sitesinde bulundurulmaktadır. Tarayıcdan "kernel.org" sitesine girerek "pub/linux/kernel" dizinine geçtiğinizde tüm yayınlanmış
    çekirdek kodlarını göreceksiniz. İndirmeyi tarayıcıdan doğrudan yapabilirsiniz. Eğer indirmeyi komut satırından "wget" 
    programıyla yapmak istiyorsanız aşağıdaki URL'yi kullanabilirsiniz:

    https://cdn.kernel.org/pub/linux/kernel/v[MAJOR_VERSION].x/linux-[VERSION].tar.xz

    Buradaki MAJOR_VERSION "3", "4", "5" gibi tek bir sayıyı belirtmektedir. VERSION ise çekirdeğin büyük ve küçük numaralarını 
    belirtmektedir. Örneğin biz çekirdeğin 5.15.12 versiyonunu şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.15.12.tar.xz

    Örneğin çekirdeğin 6.8.1 versiyonunu da şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.1.tar.xz

    Çekirdek kodları indirildikten sonra onun açılması gerekir. Açma işlemi "tar" komutuyla aşağıdaki gibi yapılabilir:

    $ tar -xvJf linux-5.15.12.tar.xz

    Debian tabanlı sistemlerde o anda makinede yüklü olan mevcut çekirdeğin kaynak kodlarını indirmek için aşağıdaki komutu 
    kullanabilirsiniz:

    $ sudo apt-get install linux-source

    Burada yükleme "/usr/src" dizinine yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux kaynak kodlarının versiyonlanması eskiden daha farklıydı. Cekirdeğin 2.6 versiyonundan sonra versiyon numaralandırma 
    sistemi değiştirilmiştir. Eskiden (2.6 ve öncesinde) versiyon numaraları çok yavaş ilerletiliyordu. 2.6 sonrasındaki yeni 
    versiyonlamada versiyon numaraları daha hızlı ilerletilmeye başlanmıştır. Bugün kullanılan Linux versiyonları nokta ile 
    ayrılmış üç sayıdan oluşmaktadır:

    Majör.Minör.Patch-Extra (-rcX, -stable, -custom, -generic)

    Buradaki "majör numara" büyük ilerlemeleri "minör numara" ise küçük ilerlemeleri belirtmektedir. Eskiden (2.6 ve öncesinde) 
    tek sayı olan minör numaralar "geliştirme versiyonlarını (ya da beta versiyonlarını)", çift olanlar ise stabil hale getirilmiş 
    dağıtılan versiyonları belirtiyordu. Ancak 2.6 sonrasında artık tek ve çift minör numaralar arasında böyle bir farklılık 
    kalmamıştır. Patch numarası birtakım böceklerin ya da çok küçük yeniliklerin çekirdeğe dahil edildiği versiyonları belirtmektedir. 
    Bu bağlamda minör numaralardan daha küçük bir ilerlemenin söz konusu olduğunu anlatmaktadır. Burada Extra ile temsil edilen 
    alanda "rcX (X burada bir sayı belirtir) "stable", "custom", "generic", "realtime" gibi sözcükler de bulunmaktadır. "rc" 
    harfleri "release candidate" sözcüklerin kısaltmadır. Stabil sürümün öncesindeki son geliştirme sürümlerini belirtmektedir. 
    "stable" sözcüğü dağıtılan kararlı sürümü belirtir. Eğer sistem programcısı çekirdekte kendisi birtakım değişiklikler yapmışsa 
    genellikle bunun sonuna "custom" sözcüğünü getirir. Tabii bu "custom" sözcüğünü ayrıca "-<custom_version_number>" biçiminde 
    numaralar da izleyebilir. Buradaki numaralar sistem programcısının kendi özelleştirmesine ilişkin numaralardır. "generic" 
    sözcüğü ise genel kullanım için yapılandırılmış bir çekirdek olduğunu belirtmektedir. "realtime" yapılandırmanın gerçek 
    zamanlı sistem özelliği kazandırmak için yapıldığını belirtmektedir. "generic" ve "realtime" sözcüklerinin öncesinde "-N-" 
    biçiminde bir sayı da bulunabilmektedir. Bu sayı "dağıtıma özgü yama ya da derleme numarasını belirtmektedir.

    Çalışmakta olan Linux sistemi hakkında bilgiler "uname -a" komutu ile elde edilebilir. Örneğin:

    $ uname -a
    Linux kaan-virtual-machine 5.15.0-91-generic #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

    Bu bilgi içerisindeki çekirdek versiyonu "uname -r" ile elde edilebilir:

    $ uname -r
    5.15.0-91-generic

    Buradan biz çekirdeğin "5.15.0" sürümünün kullanıldığını anlıyoruz. Burada genel yapılandırılmış bir çekirdek söz konusudur. 
    91 sayısı dağıtıma özgü yama ya da derleme numarasını belirtir.

    Aslında "uname" komutu bu bilgileri "/proc" dosya sisteminin içerisinde almaktadır. Örneğin:

    $ cat /proc/version
    Linux version 5.15.0-91-generic (buildd@lcy02-amd64-045) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld 
    (GNU Binutils for Ubuntu) 2.38) #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için zaten çekirdek kodlarında bir "build sistemi" oluşturulmuştur. Buna "KConfig sistemi" ya da 
    "KBuild sistemi" denilmektedir. Biz önce çekirdek derleme işleminin hangi adımlardan geçilerek yapılacağını göreceğiz. 
    Sonra çekirdeğin önemli konfigürasyon parametreleri üzerinde biraz duracağız. Sonra da çekirdekte bazı değişiklikler yapıp
    değiştirilmiş çekirdeği kullanacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdeğin davranışını değiştirmek için farklı olanaklara sahip 5 yöntem kullanılabilmektedir:

    1) Çekirdeğin boot parametreleri yoluyla davranışının değiştirilmesi. Bunun için çekirdeğin yeniden derlenmesi gerekmez.

    2) Kernel mode aygıt sürücüsü yazmak yoluyla çekirdeğin davranışının değiştirilmesi. Bunun çekirdek kodlarının yeniden 
    derlenmesi gerekmez.

    3) Çekirdeğin konfigürasyon parametrelerinin değiştirilmesiyle davranışının değiştirilmesi. Bunun için çekirdeğin yeniden 
    derlenmesi gerekir.

    4) Çekirdeğin kodlarının değiştirilmesiyle davranışının değiştirilmesi. Bunun için de çekirdeğin yeniden derlenmesi gerekir.

    5) Çekirdeğin bazı özellikleri "proc" dosya sistemindeki bazı dosyalara birtakım değerler yazarak da değiştirilebilmektedir.
    Aslında bu tür değişiklikler "systemd" init sisteminde "systemctl" komutuyla da yapılabilmektedir. Örneğin sistem çalışırken 
    bir prosesin açabileceği dosya sayısını "proc" dosya sistemi yoluyla şöyle değiştirebiliriz:

    $ echo 2048 | sudo tee /proc/sys/fs/file-max
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdek derlemesi tipik olarak aşağıdaki aşamalardan geçilerek gerçekleştirilmektedir:

    1) Derleme öncesinde derlemenin yapılacağı makinede bazı programların yüklenmiş olması gerekmektedir. Gerekebilecek tipik 
    programlar aşağıda verilmiştir:

    $ sudo apt update

    $ sudo apt install build-essential libncurses-dev bison flex libssl-dev wget gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf libelf-dev dwarves

    2) Çekirdek kodları indirilerek açılır. Biz bu konuyu yukarıda ele almıştık. İndirmeyi şöyle yapabiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2.tar.xz" isimli dosya indirilmiş durumdadır. Onu aşağıdaki gibi açabiliriz:

    $ tar -xvJf linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2" isminde bir dizin oluşturulacaktır.

    Ayrıca ek bir bilgi olarak eğer Ubuntu türevi bir dağıtımda çalışıyorsanız istediğiniz bir çekirdeği aşağıdaki gibi indirip 
    kurabilirsiniz:

    sudo apt install linux-image-<çekirdek_sürümü>

    Örneğin:

    $ sudo apt install linux-image-5.15.0-91-generic
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                194. Ders 31/01/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    3) Çekirdek derlenmeden önce konfigüre edilmelidir. Çekirdeğin konfigüre edilmesi birtakım çekirdek özelliklerin belirlenmesi 
    anlamına gelmektedir. Konfigürasyon bilgileri çekirdek kaynak kod ağacının kök dizininde (örneğimizde "linux-6.9.2" dizini) 
    ".config" ismiyle bulunmalıdır. Bu ".config" dosyası default durumda kaynak dosyaların kök dizininde bulunmamaktadır. Bunun 
    çekirdeği derleyen kişi tarafından oluşturulması gerekmektedir. Çekirdek konfigürasyon parametreleri oldukça fazladır. Biz 
    izleyen paragraflarda önemli çekirdek konfigürasyon parametrelerini göreceğiz. Çekirdek konfigürasyon parametreleri çok 
    fazla olduğu için bunlar bazı genel amaçları karşılayacak biçimde default değerlerle önceden oluşturulmuş durumdadır. Bu 
    önceden oluşturulmuş default konfigürasyon dosyaları "arch/<mimari>/configs" dizininin içerisinde bulunmaktadır. Örneğin 
    Intel X86 mimarisi için bu default konfigürasyon dosyaları şöyledir:

    $ ls arch/x86/configs
    hardening.config  i386_defconfig  tiny.config  x86_64_defconfig  xen.config

    Burada biz 64 bit Linux sistemleri için "x86_64_defconfig" dosyasını kullanabiliriz. O halde bu dosyayı kaynak dosyaların 
    bulunduğu dizinin kök dizinine ".config" ismiyle kopyalayabiliriz:

    $ cp arch/x86/configs/x86_64_defconfig .config

    Biz bütün işlemlerde çekirdek kaynak kodlarının kök dizininde bulunduğumuzu (current working directory) varsayacağız. Ancak 
    burada bir noktaya dikkatinizi çekmek istiyoruz. Linux kaynak kodlarındaki default konfigürasyon dosyaları minimal biçimde
    konfigüre edilmiştir. Bu nedenle pek çok modül bu default konfigürasyon dosyalarında işaretlenmiş değildir. Bu default 
    konfigürasyon dosyalarını kullanarak derleme yaptığınızda bazı çekirdek modüllerinin seçilmemiş olması nedeniyle sisteminiz 
    açılmayabilir. Bu tür denemeleri zaten var olan konfigürasyon dosyalarını kullanarak yaparsanız daha fazla modül dosyası 
    oluşturulabilir, ancak daha az zahmet çekebilirsiniz. Linux sistemlerinde genel olarak "/boot" dizini içerisinde 
    "configs-<çekirdek_sürümü>" ismi altında mevcut çekirdeğe ilişkin konfigürasyon dosyası bulundurulmaktadır.

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Çekirdek kaynak kodlarındaki "arch/<paltform>/configs/x86_64_defconfig" 
    dizinindeki konfigürasyon dosyası ".config" ismiyle kopyalandıktan sonra ayrıca "make menuconfig" gibi bir işlemle onun 
    satırlarına bazı default değerlerin de eklenmesi gerekir. Bu default değerler "arch/<platform>" dizinindeki "Kconfig" dosyasından 
    gelmektedir. Bu nedenle bu default konfigürasyon dosyalarını kaynak kök dizine ".config" ismiyle kopyaladıktan sonra 
    aşağıda belirtildiği gibi "make menuconfig" yapmalısınız.

    Aslında ".config" dosyasını oluşturmanın başka alternatif yolları da vardır:

    make defconfig: Bu komut çalıştığımız sisteme uygun olan konfigürasyon dosyasını temel alarak mevcut donanım bileşenlerini 
    de gözden geçirerek sistemin açılması için gerekli minimal bir konfigürasyon dosyasını ".config" ismiyle oluşturmaktadır. Örneğin 
    biz 64 bit Intel sistemine ilişkin bir bilgisayarda çalışıyorsak "make defconfig" dediğimizde "arch/x86/configs/x86_64_defconfig" 
    dosyası temel alınarak o anda çalışılmakta olan çekirdek donanımları da dikkate alınarak nispeten minimal olan bir konfigürasyon
    dosyası oluşturmaktadır.

    make oldconfig: Bu seçeneği kullanmak için kaynak kök dizinde bir ".config" dosyasının bulunuyor olması gerekir. Ancak bu 
    seçenek KConfig dosyasındaki ve kaynak dosya ağacındaki diğer değişiklikleri de göz önüne alarak bu eski ".config" dosyasını 
    eğer söz konusu mimaride birtakım değişiklikler söz konusu ise o değişikliklere uyumlandırmaktadır. Yani örneğin biz eski
    bir ".config" dosyasını kullanıyor olabiliriz. Ancak çekirdeğin yeni versiyonlarında ek birtakım başka konfigürasyon parametreleri 
    de eklenmiş olabilir. Bu durumda "make oldconfig" bize bu eklenenler hakkında da bazı sorular sorup bunların dikkate alınmasını 
    sağlayacaktır.

    make <platform>_defconfig: Bu seçenek belli bir platformun default konfigürasyon dosyasını ".config" dosyası olarak save etmektedir. 
    Örneğin biz Intel makinelerinde çalışıyor olabiliriz ancak BBB (BeagleBone Black) için default konfigürasyon dosyası oluşturmak 
    isteyebiliriz. Eğer biz "make defconfig" yaparsak Intel tabanlı bulunduğumuz platform dikkate alınarak ".config" dosyası oluşturulur. 
    Ancak biz burada örneğin "make bb.org_defconfig" komutunu uygularsak bu durumda Intel mimarisinde çalışıyor olsak da "bb.org_defconfig"
    konfigürasyon dosyası ".config" olarak save edilir. Tabii bu durumda biz aslında yine ilgili platformun konfigürasyon dosyasını 
    manuel olarak ".config" biçiminde de kopyalayabiliriz.

    make modules: Bu seçenek ile yalnızca modüller derlenir. Yani bu seçenek ".config" dosyasında belirtilen aygıt sürücü dosyalarını 
    derler ancak çekirdek derlemesi yapmaz. Yalnızca "make" işlemi zaten aynı zamanda bu işlemi de yapmaktadır.

    Aşağıdaki ilave konfigürasyon seçenekleri ise seyrek kullanılmaktadır:

    make allnoconfig: Tüm seçenekleri hayır (no) olarak ayarlar (minimal yapılandırma).
    make allyesconfig: Tüm seçenekleri evet (yes) olarak ayarlar (maksimum özellikler).
    make allmodconfig: Tüm aygıt sürücülerin çekirdeğin dışında modül (module) biçiminde derleneceğini belirtir.
    make localmodconfig: Sistemde o anda yüklü modüllere dayalı bir yapılandırma dosyası (".config" dosyası) oluşturur.
    make silentoldconfig: Yeni seçenekler için onları görmezden gelir ve o yeni özellikler ".config" dosyasına yansıtılmaz.
    make dtbs: Kaynak kod ağacında "/arch/platform/boot/dts" dizinindeki aygıt ağacı kaynak dosyalarını derler ve "dtb" 
    dosyalarını elde eder. Gömülü sistemlerde bu işlemin yapılması ve her çekirdek versiyonuyla o versiyonun "dtb" dosyasının 
    kullanılması tavsiye edilir.
    make headers_install: Aygıt sürücüler için gereken başlık dosyalarının kurulumu sağlanır. Default kurulum yeri "/usr/include/linux"
    dizinidir. Ancak INSTALL_HDR_PATH çevre değişkeni ile değiştirilebilir.

    Yukarıda da belirttiğimiz gibi aslında pek çok dağıtım o anda yüklü olan çekirdeğe ilişkin konfigürasyon dosyasını "/boot" 
    dizini içerisinde "config-$(uname -r)" ismiyle bulundurmaktadır. Örneğin kursun yapılmakta olduğu Mint dağıtımında "/boot" 
    dizininin içeriği şöyledir:

    $ ls /boot
    config-5.15.0-91-generic  grub        initrd.img-5.15.0-91-generic  vmlinuz
    efi                       initrd.img  System.map-5.15.0-91-generic  vmlinuz-5.15.0-91-generic

    Buradaki "config-5.15.0-91-generic" dosyası çalışmakta olduğumuz çekirdekte kullanılan konfigürasyon dosyasıdır. Benzer biçimde 
    BBB'deki built-in eMMC içerisinde bulunan çekirdekteki "/boot" dizininin içeriği de şöyledir:

    SOC.sh                      dtbs                System.map-5.10.168-ti-r71
    initrd.img-5.10.168-ti-r71  uboot               config-5.10.168-ti-r71
    vmlinuz-5.10.168-ti-r71

    Buradaki konfigürasyon dosyası da "config-5.10.168-ti-r71" biçimindedir.

    Eğer çalışılan sistemdeki konfigürasyon dosyasını temel alacaksanız bu dosyayı Linux kaynak kodlarının bulunduğu kök dizine 
    ".config" ismiyle kopyalayabilirsiniz. Örneğin:

    $ cp /boot/config-$(uname -r) .config

    Fakat eski bir konfigürasyon dosyasını yeni bir çekirdekle kullanmak için ayrıca "make oldconfig" işleminin de yapılması 
    gerekmektedir.

    4) Şimdi elimizde pek çok değerin set edilmiş olduğu ".config" isimli bir konfigürasyon dosyası vardır. Artık bu konfigürasyon 
    dosyasından hareketle yalnızca istediğimiz bazı özellikleri değiştirebiliriz. Bunun için "make menuconfig" komutunu kullanabiliriz:

    $ make menuconfig

    Bu komut ile birlikte grafik ekranda konfigürasyon seçenekleri listelenecektir. Tabii buradaki seçenekler default değerler 
    almış durumdadır. Bunların üzerinde değişiklikler yaparak ".config" dosyasını save edebiliriz. Aslında "make menuconfig" 
    işlemi hiç ".config" dosyası oluşturulmadan doğrudan da yapılabilmektedir. Bu durumda hangi sistemde çalışılıyorsa o sisteme 
    özgü default config dosyası temel alınmaktadır. Biz en azından "General stup/Local version - append to kernel release" 
    seçeneğine "-custom" gibi bir sonek girmenizi böylece yeni çekirdeğe "-custom" soneki iliştirmenizi tavsiye ederiz.

    ".config" dosyası elde edildiğinde çekirdek imzalamasını ortadan kaldırmak için dosyayı açıp aşağıdaki özellikleri belirtildiği 
    gibi değiştirebilirsiniz (bunların bazıları zaten default durumda aşağıdaki gibi de olabilir):

    CONFIG_SYSTEM_TRUSTED_KEYS=""
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    CONFIG_SYSTEM_TRUSTED_KEYRING=n
    CONFIG_SECONDARY_TRUSTED_KEYRING=n

    CONFIG_MODULE_SIG=n
    CONFIG_MODULE_SIG_ALL=n
    CONFIG_MODULE_SIG_KEY=""

    Çekirdek imzalaması konusu daha ileride ele alınacaktır.

    Yukarıda da belirttiğimiz gibi derlenecek çekirdeklere yerel bir versiyon numarası da atanabilmektedir. Bu işlem "make menuconfig" 
    menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak ya da ".config" dosyasında "CONFIG_LOCALVERSION" 
    kullanılarak yapılabilir. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Artık çekirdek sürümüne "-custom" sonekini eklemiş olduk.

    5) Derleme işlemi için "make" komutu kullanılmaktadır. Örneğin:

    $ make

    Eğer derleme işleminin birden fazla CPU ile yapılmasını istiyorsanız "-j<cpu_sayısı>" seçeneğini komuta dahil edebilirsiniz. 
    Çalışılan sistemdeki CPU sayısının "nproc" komutuyla elde edildiğini anımsayınız:

    $ make -j$(nproc)

    Derleme işlemi bittiğinde ürün olarak biz "çekirdek imajını", "çekirdek tarafından yüklenecek olan modül dosyalarını (aygıt 
    sürücü dosyalarını)" ve diğer bazı dosyaları elde etmiş oluruz. Derleme işleminden sonra elde oluşturulan dosyalar ve
    onların yerleri şöyledir (buradaki <çekirdek_sürümü> "uname -r" ile elde edilecek değeri belirtiyor):

    - Sıkıştırılmış Çekirdek İmajı: "arch/<platform>/boot" dizininde "bzImage" ismiyle oluşturulmaktadır. Denemeyi yaptığımız Intel makinede 
    dosyanın yol ifadesi "arch/x86_64/boot/bzImage" biçimindedir.

    - Çekirdeğin Sıkıştırılmamış ELF İmajı: Kaynak kök dizininde "vmlinux" isminde dosya biçiminde oluşturulur.

    - Çekirdek Modülleri (Aygıt Sürücü Dosyaları): "drivers" dizininin altındaki dizinlerde ve "fs" dizininin altındaki dizinlerde 
    ve "net" dizininin altındaki dizinlerde. Ancak "make modules_install" ile bunların hepsi belirli bir dizine çekilebilir.

    - Çekirdek Sembol Tablosu: Kaynak kök dizininde "System.map" ismiyle bulunuyor.

    Çekirdeğin derlemesi ne kadar zaman almaktadır? Şüphesiz bu derlemenin yapıldığı makineye göre değişebilir. Ancak derleme sürecinin
    uzamasına yol açan en önemli etken çekirdek konfigüre edilirken çok fazla modülün seçilmesidir. Pek çok dağıtım "belki lazım
    olur" gerekçesiyle konfigürasyon dosyalarında pek çok modülü dahil etmektedir. Bir dağıtımın konfigürasyon dosyasını kullandığınız 
    zaman çekirdek derlemesi uzayacaktır. Ayrıca çekirdek konfigüre edilirken çok fazla modülün dahil edilmesi modüllerin çok fazla 
    yer kaplamasına da yol açabilmektedir. Çekirdek kodlarındaki platforma özgü default konfigürasyon dosyaları daha minimalist 
    bir biçimde oluşturulmuş durumdadır.

    6) Derleme sonrasında farklı dizinlerde oluşturulmuş olan aygıt sürücü dosyalarını (modülleri) belli bir dizine kopyalamak 
    için "make modules_install" komutu kullanılmaktadır. Bu komut seçeneksiz kullanılırsa default olarak "/lib/modules/<çekirdek_sürümü>"
    dizinine kopyalama yapar. Her ne kadar bu komut pek çok ".ko" uzantılı aygıt sürücü dosyasını hedef dizine kopyalıyorsa 
    da bunların hepsi çekirdek tarafından belleğe yüklenmemektedir. Çekirdek gerektiği zaman gereken aygıt sürücüleri bu dizinden 
    alarak yüklemektedir. Örneğin:

    $ sudo make modules_install

    Aslında "make modules_install" komutunun modül dosyalarını (aygıt sürücü dosyalarını) istediğimiz bir dizine kopyalamasını 
    da sağlayabiliriz. Bunun için INSTALL_MOD_PATH komut satırı argümanı kullanılmaktadır. Örneğin:

    $ sudo INSTALL_MOD_PATH=modules make modules_install

    Burada aygıt sürücü dosyaları "/lib/modules/<çekirdek_sürümü>" dizinine değil bulunulan yerdeki "modules" dizinine kopyalanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki "make modules_install" komutu yalnızca modül dosyalarını mı hedef dizine kopyalıyor? Hayır aslında bu komut modül 
    dosyalarının kopyalanması dışında bazı dosyaları da oluşturup onları da hedef dizine kopyalamaktadır. Bu komut sırasıyla 
    şunları yapmaktadır:

    - Modül dosyalarını "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.dep" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.alias" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.order" isimli dosyayı oluşturur ve "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.builtin" isimli dosyayı "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.

    Aslında burada oluşturulan dosyaların bazıları mutlak anlamda bulunmak zorunda değildir. Ancak sistemin öngörüldüğü gibi 
    işlev göstermesi için bu dosyaların ilgili dizinde bulunması uygundur.

    Bir aygıt sürücü başka bir aygıt sürücüleri de kullanıyor olabilir. Bu durumda bu aygıt sürücü yüklenirken onun kullandığı
    tüm sürücülerin özyinelemeli olarak yüklenmesi gerekir. İşte "modules.dep" dosyası bir aygıt sürücünün yüklenmesi için 
    başka hangi sürücülerin yüklenmesi gerektiği bilgisini tutmaktadır. Aslında "modules.dep" bir text dosyadır. Bu text dosya
    satırlardan oluşmaktadır. Satırların içeriği şöyledir:

    <modül_yolu>: <bağımlılık> <bağımlılık2> ...

    Dosyanın içeriğine şöyle örnek verebiliriz:

    ...
    kernel/arch/x86/crypto/nhpoly1305-sse2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/nhpoly1305-avx2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/curve25519-x86_64.ko.zst: kernel/lib/crypto/libcurve25519-generic.ko.zst
    ...

    Eğer bu "modules.dep" dosyası olmazsa bu durumda "modeprob" komutu çalışmaz ve çekirdek modülleri yüklenirken eksik 
    yükleme yapılabilir. Dolayısıyla sistem düzgün bir biçimde açılmayabilir. Eğer bu dosya elimizde yoksa ya da bir biçimde
    silinmişse bu dosyayı yeniden oluşturabiliriz. Bunun için "depmod -a" komutu kullanılmaktadır. Komut doğrudan kullanıldığında 
    o anda çekirdek sürümü için "modules.dep" dosyasını oluşturmaktadır. Örneğin:

    $ sudo depmod -a

    Ancak siz yüklü olan başka bir çekirdek sürümü için "modules.dep" dosyasını oluşturmak istiyorsanız bu durumda çekirdek 
    sürümünü de komut satırı argümanı olarak aşağıdaki gibi komuta vermelisiniz:

    $ sudo depmod -a <çekirdek sürümü>

    Tabii depmod komutunun çalışabilmesi için "/lib/modules/<çekirdek_sürümü> dizininde modül dosyalarının bulunuyor olması gerekir. 
    Çünkü bu komut bu dizindeki modül dosyalarını tek tek bulup ELF formatının ilgili bölümlerine bakarak modülün hangi modülleri 
    kullandığını tespit ederek "modules.dep" dosyasını oluşturur.

    "modules.alias" dosyası belli bir isim ya da id ile aygıt sürücü dosyasını eşleştiren bir text dosyadır. Bu dosyanın 
    bulunmaması bazı durumlarda sorunlara yol açmayabilir. Ancak örneğin USB porta bir aygıt takıldığında bu aygıta ilişkin 
    aygıt sürücünün hangisi olduğu bilgisi bu dosyada tutulmaktadır. Bu durumda bu dosyanın olmayışı aygıt sürücünün yüklenememesine
    neden olabilir. Dosyanın içeriği aşağıdaki formata uygun satırlardan oluşmaktadır:

    alias <tanımlayıcı> <modül_adı>

    Örnek bir içerik şöyle olabilir:

    ...
    alias usb:v05ACp*d*dc*dsc*dp*ic*isc*ip*in* apple_mfi_fastcharge
    alias usb:v8086p0B63d*dc*dsc*dp*ic*isc*ip*in* usb_ljca
    alias usb:v0681p0010d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v0681p0005d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v07C0p1506d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    alias usb:v07C0p1505d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    ...

    Bu dosya bir biçimde silinirse yine "depmod" komutu ile oluşturulabilir. (Yani depmod komutu yalnızca "modules.dep" dosyasını
    değil, bu dosyayı da oluşturmaktadır.)

    "modules.order" dosyası aygıt sürücü dosyalarının yüklenme sırasını barındıran bir text dosyadır. Bu dosyanın her satırında 
    bir çekirdek aygıt sürücüsünün dosya yol ifadesi bulunur. Daha önce yazılmış aygıt sürücüler daha sonra yazılanlardan 
    daha önce yüklenir. Bu dosyanın olmaması genellikle bir soruna yol açmaz. Ancak modüllerin belli sırada yüklenmemesi 
    bozukluklara da neden olabilmektedir. Bu dosyanın da silinmesi durumunda yine bu dosya da "depmod" komutuyla oluşturulabilmektedir.

    7) Eğer gömülü sistemler için derleme yapıyorsanız kaynak kod ağacındaki "arch/<platform>/boot/dts" dizini içerisindeki aygıt
    ağacı kaynak dosyalarını da derlemelisiniz. Tabii elinizde zaten o versiyona özgü aygıt dosyası bulunuyor olabilir. Bu durumda 
    bu işlemi hiç yapmayabilirsiniz. Aygıt ağacı kaynak dosyalarını derlemek için "make dtbs" komutunu kullanabilirsiniz:

    $ make dtbs

    Derlenmiş aygıt ağacı dosyaları "arch/<platform>/boot/dts" dizininde oluşturulacaktır.

    8) Bizim çekirdek imajını, geçici kök dosya sistemine ilişkin dosyayı ve aygıt ağacı dosyasını uygun yere yerleştirmemiz 
    gerekir. Bu dosyalar "/boot" dizini içerisinde bulunmalıdır. Ancak aslında bu işlem de "make install" komutuyla otomatik 
    olarak yapılabilmektedir. "make install" komutu aynı zamanda "grub" isimli bootloder programın konfigürasyon dosyalarında da 
    güncelleme yapıp yeni çekirdeğin "grub" menüsü içerisinde görünmesini de sağlamaktadır. Komut şöyle kullanılabilir:

    $ sudo make install

    Bu komut ile sırasıyla yapılanlar şunlardır:

    - Çekirdek imaj dosyası "arch/<platform>/boot/bzImage" hedef "/boot" dizinine "vmlinuz-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "System.map" dosyası hedef "/boot" dizinine "System.map-<çekirdek_sürümü>" ismiyle kopyalanır.
    - ".config" dosyası "/boot" dizinine "config-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "Geçici kök dosya sistemi dosyası oluşturulur ve hedef "/boot" dizinine "initrd.img-<çekirdek_sürümü>" ismiyle kopyalanır.
    - Eğer "grub" boot loader kullanılıyorsa "grub" konfigürasyonu güncellenir ve "grub"" menüsüne yeni girişler eklenir. Böylece
    sistemin otomatik olarak yeni çekirdekle açılması sağlanır.

    Yukarıda da belirttiğimiz gibi derleme işlemi sonucunda elde edilmiş olan dosyaların hedef sistemde bazı dizinlerde bulunuyor 
    olması gerekir. Bu yerleri bir kez daha belirtmek istiyoruz:

    - Çekirdek İmajı ---> "/boot" dizinine
    - Çekirdek Sembol Tablosu ---> "/boot" dizinine
    - Modül Dosyaları ---> "/lib/modules/<çekirdek_sürümü>/kernel" dizininin altında

    Ancak yukarıdaki dosyalar dışında isteğe bağlı olarak aşağıdaki dosyalar da hedef sisteme konuşlandırılabilir:

    - Konfigürasyon Dosyası ---> "/boot" dizini
    - Geçici Kök Dosya Sistemi Dosyası ---> "/boot" dizinine
    - Modüllere İlişkin Bazı Dosyalar ---> "/lib/modules/<çekirdek_sürümü>" dizinine

    Peki yukarıda belirttiğimiz dosyalar hedef sistemdeki ilgili dizinlere hangi isimlerle kopyalanmalıdır? İşte tipik 
    isimlendirme şöyle olmalıdır (buradaki <çekirdek_sürümü> "uname -r" komutuyla elde edilecek olan yazıdır):

    - Çekirdek İmajı: "/boot/vmlinuz-<çekirdek_sürümü>". Örneğin "vmlinuz-6.9.2-custom" gibi.
    - Çekirdek Sembol Tablosu: "/boot/System.map-<çekirdek_sürümü>". Örneğin "System.map-6.9.2-custom" gibi.
    - Modüllere İlişkin Dosyalar: Bunlar yukarıda da belirttiğimiz gibi "/lib/modules/<çekirdek_sürümü>" dizininin içerisine
    kopyalanmalıdır.
    - Konfigürasyon Dosyası: "/boot/config-<çekirdek_sürümü>". Örneğin "config-6.9.2-custom" gibi.
    - Geçici Kök Dosya Sistemine İlişkin Dosya: "/boot/initrd.img-<çekirdek_sürümü>". Örneğin "initrd.img-6.9.2-custom" gibi.

    Ayrıca bazı dağıtımlarda "/boot" dizini içerisindeki "vmlinuz" dosyası default olan "vmlinuz-<çekirdek_sürümü>" dosyasına, 
    "inird.img" dosyası da "/boot/initrd.img-<çekirdek_sürümü>" dosyasına sembolik link yapılmış durumda olabilir. Ancak bu sembolik 
    bağlantıları "grub" kullanmamaktadır. Aşağıda Intel sistemindeki "/boot" dizininin default içeriğini görüyorsunuz:

    $ ls -l
    total 141168
    -rw-r--r-- 1 root root    261963 Kas 14  2023 config-5.15.0-91-generic
    drwx------ 3 root root      4096 Oca  1  1970 efi
    drwxr-xr-x 7 root root      4096 Ara  5 19:02 grub
    lrwxrwxrwx 1 root root        28 Ara  5 20:28 initrd.img -> initrd.img-5.15.0-91-generic
    -rw-r--r-- 1 root root 126391088 Tem 11 20:19 initrd.img-5.15.0-91-generic
    -rw------- 1 root root   6273869 Kas 14  2023 System.map-5.15.0-91-generic
    lrwxrwxrwx 1 root root        25 Ara  5 20:28 vmlinuz -> vmlinuz-5.15.0-91-generic
    -rw-r--r-- 1 root root  11615272 Kas 14  2023 vmlinuz-5.15.0-91-generic

    Peki derleme sonucunda elde ettiğimiz dosyaları manuel isimlendirirken çekirdek sürüm yazısını nasıl bileceğiz? Bunun için 
    "uname -r" komutunu kullanamayız. Çünkü bu komut bize o anda çalışmakta olan çekirdeğin sürüm yazısını verir. Biz yukarıdaki 
    denemede Linux'un "6.9.2" sürümünü derledik. Bunun sonuna da "-custom" getirirsek sürüm yazısının "6.9.2-custom" olmasını bekleriz. 
    Ancak bu sürüm yazısı aslında manuel olarak isim değiştirmekle oluşturulamamaktadır. Bu sürüm yazısı çekirdek imajının içerisine 
    yazılmaktadır ve bizim bazı dosyalara verdiğimiz isimlerin çekirdek içerisindeki bu yazıyla uyumlu olması gerekir. Default olarak 
    "kernel.org" sitesinden indirilen kaynak kodlar derlendiğinde çekirdek sürümü "6.9.2" gibi üç haneli bir sayı olmaktadır. Yani yazının 
    sonunda "-generic" gibi "-custom" gibi bir sonek yoktur. İşte çekirdeği derlemeden önce daha önceden de belirttiğimiz gibi ".config" 
    dosyasında "CONFIG_LOCALVERSION" özelliğine bu sürüm numarasından sonra eklenecek bilgiyi girebilirsiniz. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Anımsayacağınız gibi bu işlem "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak 
    da yapılabilmektedir. Biz buradaki örneğimizde bu işlemi yaparak çekirdeği derledik. Dolayısıyla bizim derlediğimiz çekirdekte 
    çekirdek imajı içerisinde yazan sürüm ismi "6.9.2-custom" biçimindedir. Peki biz bu ismi unutsaydık nasıl öğrenebilirdik. Bunun 
    basit bir yolu sıkıştırılmamış çekirdek dosyası içerisindeki (kaynak kök dizindeki "vmlinux" dosyası) string tablosunda "Linux version"
    yazısını aramaktır. Örneğin:

    $ strings vmlinux | grep "Linux version"
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) # SMP PREEMPT_DYNAMIC

    Buradan sürüm yazısının "6.9.2-custom" olduğu görülmektedir. O halde bizim derleme sonucunda elde ettiğimiz dosyaları manuel biçimde 
    kopyalarken sürüm bilgisi olarak "6.9.2-custom" yazısını kullanmalıyız. Çekirdek imajının "/boot" dizinine manuel kopyalanması işlemi 
    şöyle yapılabilir (kaynak kök dizinde bulunduğumuzu varsayıyoruz):

    $ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-6.9.2-custom

    Konfigürasyon dosyasını da şöyle kopyalayabiliriz:

    $ sudo cp .config /boot/config-6.9.2-custom

    Tabii bizim çekirdek modüllerini de "/lib/modules/6.9.2-custom/kernel" dizinine kopyalamamız gerekir. Ayrıca bir de geçici kök dosya 
    sistemine ilişkin dosyayı da kopyalamamız gerekir. Çekirdek modüllerinin kopyalanması biraz zahmetli bir işlemdir. Çünkü bunlar 
    derlediğimiz çekirdekte farklı dizinlerde bulunmaktadır. Bu kopyalamanın en etkin yolu "make modules_install" komutunu kullanmaktır. 
    Benzer biçimde çekirdek dosyalarının ve gerekli diğer dosyaların uygun yerlere kopyalanması için en etkin yöntem "make install" komutudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak biz "make install" yaptığımızda eğer sistemimizde "grub" önyükleyicisi varsa komut "grub" konfigürasyon 
    dosyalarında güncellemeler yaparak sistemin yeni çekirdekle açılmasını sağlamaktadır. Ancak kullanıcı bir menü yoluyla 
    sistemin kendi istediği çekirdekle açılmasını sağlayabilir. GRUB menüsü otomatik olarak görüntülenmemektedir. Boot işlemi 
    sırasında ESC tuşuna basılırsa menü görüntülenir. Eğer "grub" menüsünün her zaman görüntülenmesi isteniyorsa "/etc/default/grub" 
    dosyasındaki iki satır aşağıdaki gibi değiştirilmelidir:

    GRUB_TIMEOUT_STYLE=menu
    GRUB_TIMEOUT=5

    Buradaki GRUB_TIMEOUT satırı eğer menünün müdahale yapılmamışsa en fazla 5 saniye görüntüleneceğini belirtmektedir.

    Bu işlemden sonra "update-grub" programı da çalıştırılmalıdır:

    $ sudo update-grub

    Bu tür denemeler yapılırken "grub" menüleri bozulabilmektedir. Düzeltme işlemleri bazı konfigürasyon dosyalarının edit 
    edilmesiyle manuel biçimde yapılabilir. Konfigürasyon dosyaları güncellendikten sonra "update-grub" programı mutlaka 
    çalıştırılmalıdır. Ancak eğer "grub" konfigürasyon dosyaları konusunda yeterli bilgiye sahip değilseniz "grub" işlemlerini 
    görsel bir biçimde "grub-customizer" isimli programla da yapabilirsiniz. Bu program "debian depolarında" olmadığı için 
    önce aşağıdaki gibi programın bulunduğu yerin "apt" kayıtlarına eklenmesi gerekmektedir:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update

    Bu işlemden sonra kurulum yapılabilir:

    $ sudo apt-get install grub-customizer
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çekirdek derleme ve yeni çekirdeği kurma sürecini maddeler halinde açıkladık. Şimdi yukarıdaki adımları özet 
    hale getirelim:

    1) Çekirdek derlemesi için gerekli olan araçlar indirilir.

    2) Çekirdek kodları indirilir ve açılır.

    3) Zaten hazır olan konfigürasyon dosyası ".config" biçiminde kaynak kök dizine save edilir.

    4) Konfigürasyon dosyası üzerinde "make menuconfig" komutu ile değişiklikler yapılır.

    5) Çekirdek derlemesi "make -j$(nproc)" komutu ile gerçekleştirilir.

    6) Modüller ve ilgili dosyalar hedefe "sudo make modules_install" komutu ile konuşlandırılır.

    7) Çekirdek imajı ve ilgili dosyalar "sudo make install" komutu ile hedefe konuşlandırılır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki yeni çekirdeği derleyip sisteme dahil ettikten sonra nasıl onu sistemden tamamen çıkartabiliriz? Tabii yapılan 
    işlemlerin tersini yapmak gerekir. Bu işlem manuel biçimde şöyle yapılabilir:

    - "/lib/modules/<çekirdek_sürümü>" dizini tamamen silinebilir.
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silinmelidir.
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silindikten sonra "update-grub" programı sudo ile çalıştırılmalıdır. 
    Bu program "/boot" dizinini inceleyip otomatik olarak ilgili girişleri "grub" menüsünden siler. Yani aslında "grub" 
    konfigürasyon dosyaları üzerinde manuel değişiklik yapmaya gerek yoktur. "grub" işlemleri için diğer bir alternatif ise 
    "grub-customizer" programı ile görsel silme yapmaktır. Ancak bu program "/boot" dizini içerisindeki dosyaları ve modül 
    dosyalarını silmez. Yalnızca ilgili girişleri "grub" menüsünden çıkartmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                195. Ders 02/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki biz Intel sisteminde çalışırken ARM için çekirdek derlemesini nasıl yapabiliriz? Bir platformda çalışırken başka
    bir platform için derleme yapılabilir. Ancak hedef platforma ilişkin ismine "araç zinciri (toolchain)" denilen bir paketin 
    yüklenmiş olması gerekir. Araç zincirleri derleyicilerle birlikte sistem programlama için gerekli olan çeşitli programları 
    barındıran paketlerdir. Örneğin ARM platformu için çeşitli araç zincirleri bulunmaktadır. ARM platformu için en yaygın 
    kullanılan araç zincirleri aşağıdaki bağlantıdan indirilebilir:

    https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

    Örneğin Beaglebone Black (BBB) için Windows'ta çalışan araç zinciri bu sitede aşağıdaki bağlantıya tıklanarak indirilebilir:

    arm-gnu-toolchain-14.2.rel1-mingw-w64-i686-arm-none-linux-gnueabihf.zip

    Genel olarak araç zincirleri kullanılmadan önce birkaç çevre değişkeninin set edilmesi gerekmektedir:

    - CROSS_COMPILE isimli çevre değişkeni araç zincirinin öneki ile set edilmelidir. Örneğin:

    $ export CROSS_COMPILE=arm-none-linux-gnueabihf-

    - PATH çevre değişkenine araç zincirine ilişkin "bin" dizininin eklenmesi gerekir:

    $ PATH=$PATH:/home/kaan/Study/UnixLinux-SysProg/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-linux-gnueabihf/bin

    - ARCH çevre değişkeninin hedef platformu belirten bir yazı ile set edilmesi gerekir. ARM platformu için bu yazı "arm"
    biçimindedir:

    $ export ARCH=arm

    Bundan sonra çekirdeğin kaynak kodları yukarıda belirtildiği gibi derlenebilir. Burada bu işlemin ayrıntısı üzerinde 
    durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de çekirdek kodlarının değiştirilip derlenmesine bir örnek verelim. Çekirdek kodlarında değişiklik yapmanın birkaç 
    yolu olabilir:

    1) Çekirdek kodlarındaki bir dosya içerisinde bulunan fonksiyon kodlarında değişiklik yapılması.
    2) Çekirdek kodlarındaki bir dosya içerisine yeni bir fonksiyon eklenmesi.
    3) Çekirdek kodlarındaki bir dizin içerisine yeni bir C kaynak dosyası eklenmesi.
    4) Çekirdek kodlarındaki bir dizin içerisine yeni bir dizin ve bu dizinin içerisinde çok sayıda C kaynak dosyalarının 
    eklenmesi.

    Eğer biz birinci maddedeki ve ikinci maddedeki gibi çekirdek kodlarına yeni bir dosya eklemiyorsak çekirdeğin derlenmesini
    sağlayan make dosyalarında bir değişiklik yapmamıza gerek yoktur. Ancak çekirdeğe yeni bir kaynak dosya ya da dizin ekleyeceksek
    bu eklemeyi yaptığımız dizindeki make dosyasında bu ekleme izleyen paragraflarda açıklayacağımız biçimde belirtilmelidir. 
    Böylece çekirdek yeniden derlendiğinde bu dosyalar da çekirdek imajının içerisine eklenmiş olacaktır. Eğer kaynak kod 
    ağacında bir dizinin altına yeni bir dizin eklemek istersek bu durumda o dizini yine ana dizine ilişkin make dosyasında 
    belirtmemiz ve o dizinde ayrı bir Makefile oluşturmamız gerekmektedir.

    Peki çekirdek kodlarındaki bir dosya içerisindeki bir fonksiyonda değişiklik yaptığımızda çekirdek modüllerini yeniden 
    hedef makineye aktarmamız gerekir mi? İşte genel olarak bu tür basit değişikliklerde çekirdek modüllerinin güncellenmesi 
    gerekmemektedir. Ancak ne olursa olsun bu durum yapılan değişikliklere de bağlıdır. Bu nedenle çekirdek modüllerinin de 
    yeniden "make modules_install" komutu hedef makineye çekilmesi önerilir.

    Örneğin biz çekirdek kaynak kod ağacında "fs/open.c" içerisinde "chdir" sistem fonksiyonuna aşağıdaki gibi bir satır ekleyelim:

    SYSCALL_DEFINE1(chdir, const char __user *, filename)
    {
        struct path path;
        int error;
        unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;

        printk(KERN_INFO "directory is changing...\n");

    retry:
        error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
        if (error)
            goto out;

        error = path_permission(&path, MAY_EXEC | MAY_CHDIR);
        if (error)
            goto dput_and_out;

        set_fs_pwd(current->fs, &path);

    dput_and_out:
        path_put(&path);
        if (retry_estale(error, lookup_flags)) {
            lookup_flags |= LOOKUP_REVAL;
            goto retry;
        }
    out:
        return error;
    }

    Bu işlemden sonra sırasıyla aşağıdakileri yapıp sistemi yeni çekirdekle açabiliriz:

    make -j$(nproc)
    make modules_install
    make install

    Bu yeni çekirdekte ne zaman bir dizin değiştirilse bir log yazısı oluşturulmaktadır. Bu yazıları "dmesg" komutuyla 
    görebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki biz çekirdeğin kaynak kod ağacına yeni bir ".c" dosyası eklemek istersek ne yapacağız? İşte bu durumda çekirdeğin
    make dosyalarında bu eklemenin belirtilmesi gerekmektedir. Çekirdek kodlarında her kaynak kod dizininde ayrı bir Makefile
    dosyası bulunmaktadır. Programcı yeni kaynak dosyayı hangi dizine ekliyorsa o dizine ilişkin Makefile içerisine aşağıdaki
    gibi bir satır eklemesi gerekir:

    obj-y += dosya_ismi.o

    Böylece artık make işlem yapıldığında bu dosya da derlenip çekirdek imajına dahil edilecektir. Buradaki += operatörü obj-y 
    isimli hedefe ekleme yapma anlamına gelmektedir. "obj" sözcüğünün yanındaki "-y" harfi ilgili dosyanın çekirdeğin bir 
    parçası biçiminde çekirdek imajının içerisine gömüleceğini belirtmektedir. Make dosyalarının bazı satırlarında "obj-y" 
    yerine "obj-m" de görebilirsiniz. Bu da ilgili dosyanın ayrı bir modül biçiminde derleneceği anlamına gelmektedir. 
    Eklemeler genellikle çekirdek imajının içine yapıldığı için biz de "obj-y" kullanırız. Eğer bir dosyayı biz çekirdek 
    imajının içine gömmek yerine ayrı bir çekirdek modülü olarak derlemek istiyorsak bu durumda dosyayı yerleştirdiğimiz 
    dizinin "Makefile" dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-m += dosya_ismi.o

    Eğer çekirdek kaynak kodlarına tümden bir dizin eklemek istiyorsak bu durumda o dizini oluşturduğumuz dizindeki "Makefile"
    dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-y += dizin_ismi/

    Burada dizin isminden sonra '/' karakterini unutmayınız. Tabii bu ekleme bir modül biçiminde de olabilirdi:

    obj-m += dizin_ismi/

    Fakat bu ekleme yapıldıktan sonra bizim ayrıca yarattığımız dizinde "Makefile" isimli bir dosya oluşturmamız ve o dosyanın 
    içerisinde o dizinde çekirdek kodlarına ekleyeceğimiz dosyaları belirtmemiz gerekir. Örneğin biz "drivers" dizininin altına
    "mydriver" isimli bir dizin oluşturup onun da içerisine "a.c" "b.c" ve "c.c" dosyalarını eklemiş olalım. Bu durumda önce 
    "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki gibi bir satır ekleriz:

    obj-y += mydriver/

    Sonra da "mydriver" dizini içerisinde "Makefile" isimli bir dosya oluşturup bu dosyanın içerisinde de bu dizin içerisindeki 
    dosyaları belirtiriz. Örneğin:

    obj-y += a.o
    obj-y += b.o
    obj-y += c.o
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin biz kaynak kod ağacında "drivers" dizininin altında "mydriver" isimli dizin yaratıp onun içerisine "mydrive.c" 
    dosyasını yerleştirmek isteyelim. Sırasıyla şunları yapmamız gerekir:

    1) "drivers" dizini altında "mydriver" dizini yaratırız.

    2) "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki satır ekleriz:

    obj-y += mydriver/

    3) "drivers/mydriver" dizini içerisinde "mydriver.c" dosyasını oluştururuz. Dosyanın içeriği şöyle olabilir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    static int __init helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    4) "drivers/mydriver" dizini içerisinde "Makefile" isimli dosya oluştururuz ve içine aşağıdaki satırı ekleriz:

    obj-y += mydriver.o

    5) Çekirdek kod dizininin kök dizinine gelip ve sırasıyla aşağıdaki komutları uygularız:

    make -j$(nproc)
    make modules_install
    make install

    Böylece sistem yeni çekirdekle açılabilir. Aygıt sürücünün çekirdeğe dahil edildiğini geçmiş dmesg mesajlarına bakarak
    aşağıdaki gibi anlayabilirsiniz:

    $ dmesg | grep -i "Hello World..."
    [    0.949515] Hello World...
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                196. Ders 07/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yeni bir sistem fonksiyonunu çekirdeğe eklemek isteyelim. Linux çekirdeğinde sistem fonksiyonlarının adresleri 
    bir fonksiyon gösterici dizisinde tutulmaktadır. Bu gösterici dizisinin her elemanı bir sistem fonksiyonunun adresini içerir. 
    O halde çekirdeğe bir sistem fonksiyonu ekleyebilmek için sistem fonksiyonunu bir dosya içerisine yazmak ve bu tabloya 
    o fonksiyonu gösteren bir giriş eklemek gerekir. Bunun yapılış biçimi Linux'un çeşitli versiyonlarında değiştirilmiştir. 
    Aşağıda güncel bir versiyonda bu işlemin nasıl yapıldığına ilişkin bir örnek vereceğiz:

    1) Sistem fonksiyonumuzu "mysyscall" biçiminde isimlendirmiş olalım. Önce yine çekirdek kaynak kod ağacında uygun bir dizine
    yeni bir dosya eklemek gerekir. Bunun için en uygun dizin "kernel" dizinidir. Bu durumda sistem fonksiyonumuzu "kernel" 
    dizini içerisinde "mysyscall.c" ismiyle yazabiliriz:

    /* mysyscall.c */

    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>

    SYSCALL_DEFINE0(mysyscall)
    {
        printk(KERN_INFO "My system call\n");

        return 0;
    }

    Bundan sonra kernel dizini içerisindeki "Makefile" dosyasına aşağıdaki satırı ekleriz:

    obj-y += mysyscall.o

    2) Sistem fonksiyon tablosuna ilgili sistem fonksiyonu bir eleman olarak girilir. Sistem fonksiyon tablosu 
    "arch/<platform>/syscalls/xxx.tbl" dosyasında belirtilmektedir. 64 bit Linux sistemleri için bu dosya 
    "arch/x86/entry/syscalls/syscall_64.tbl" biçimindedir. Ekleme bu dosyanın sonuna aşağıdaki gibi yapılabilir:

    ...
    544    x32    io_submit        compat_sys_io_submit
    545    x32    execveat        compat_sys_execveat
    546    x32    preadv2            compat_sys_preadv64v2
    547    x32    pwritev2        compat_sys_pwritev64v2
    # This is the end of the legacy x32 range. Numbers 548 and above are
    # not special and are not to be used for x32-specific syscalls.
    548    common   mysyscall    sys_mysyscall

    3) Artık çekirdek aşağıdaki gibi derlenebilir:

    $ sudo make -j$(nproc)

    4) Çekirdek modüllerini aşağıdaki gibi install edebiliriz:

    $ sudo make modules_install

    5) Çekirdeğin kendisini de şöyle install edebiliriz:

    $ sudo make install
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem fonksiyonunu çekirdeğe yerleştirip yeni çekirdekle makinemizi açtıktan sonra fonksiyonun testini aşağıdaki gibi 
    yapabiliriz:

    #include <stdio.h>
    #include <sys/syscall.h>
    #include <unistd.h>

    #define SYS_mysyscall        548

    int main(void)
    {
        printf("running...\n");

        syscall(SYS_mysyscall);

        return 0;
    }

    Bu programı derleyip çalıştırdıktan sonra "dmesg" yaptığımızda aşağıdaki gibi bir çıktı elde etmeliyiz:

    ...
    file uses a different sequence number ID, rotating.
    [  144.816248] warning: `ThreadPoolForeg' uses wireless extensions which will stop working for Wi-Fi 7 hardware; use nl80211
    [  487.365691] My system call
---------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Her ne kadar sistem programlamanın doğrudan veritabanlarıyla bir ilgisi yoksa da sistem programcıların bazı durumlarda 
    veritabanları oluşturup onları kullanması gerekebilmektedir. Bu bölümde C'den SQL kullanarak veritabanlarıyla nasıl işlem 
    yapılacağı üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Eskiden veritabanı işlemleri kütüphanelerle yapılıyordu. Daha sonra veritabanı işlemleri için özel programlar geliştirildi. 
    Veritabanı işlemlerini ayrıntılı ve etkin bir biçimde gerçekleştiren yazılımlara "Veritabanı Yönetim Sistemleri (VTYS/DBMS)"
    denilmektedir. Günümüzde çeşitli firmalar ve kurumlar tarafından geliştirilmiş pek çok VTYS vardır. Bunların bazıları 
    kapalı ve ücretli yazılımlardır. Bazıları ise açık kaynak kodlu ve ücretsiz yazılımlardır. En çok kullanılan VTYS yazılımları 
    şunlardır:

    - IBM DB2 (Dünyanın ilk VTYS'sidir.)
    - Oracle (Oracle firmasının en önemli ürünü.)
    - SQL Server (Microsoft firmasının VTYS'si.)
    - MySQL (Açık kaynak kodlu, ancak Oracle firması satın aldı ve gelecekteki durumu tartışmalı.)
    - MariaDB (Açık kaynak kodlu, MySQL Oracle tarafından satın alınınca kapatılma tehlikesine karşı MySQL varyantı olarak 
    devam ettirilmektedir.)
    - PostgreSQL (Açık kaynak kodlu, son yıllarda geniş kesim tarafından kullanılan VTYS.)
    - SQLite (Gerçek anlamda bir VTYS değil, VTYS'yi taklit eden mini bir kütüphane gibi. Bu tür yazılımlara "gömülü VTYS" de
    denilmektedir.)
    - Microsoft Access Jet Motoru (Bu da Microsoft'un gömülü bir VTYS sistemidir. Microsoft Access tarafından da kullanılmaktadır.)

    Bir yazılımın VTYS olabilmesi için onun bazı gelişmiş özelliklere sahip olması gerekir:

    1) VTYS'ler kullanıcılarına yüksek seviyeli bir çalışma modeli sunmaktadır.

    2) VTYS'ler genellikle dış dünyadan istekleri "SQL (Structured Query Language)" denilen dekleratif bir dille almaktadır. 
    Yani programcı VTYS'ye iş yaptırmak için SQL denilen bir yüksek seviyeli dekleratif bir dil kullanmaktadır. VTYS SQL 
    komutlarını alıp onları parse eder ve C ve C++ gibi dillerde yazılmış olan motor kısmı (engine) tarafından işlemler yapılır. 
    SQL, veritabanı işlemlerini yapan bir dil değildir. Programcı ile VTYS arasında yüksek seviyeli iletişim için kullanılan 
    bir dildir. VTYS'lerin motor kısımları genellikle C ve C++ gibi sistem programlama dilleriyle yazılmaktadır.

    3) VTYS'ler pek çok yüksek seviyeli araçlara da sahiptir. Örneğin backup ve restore işlemlerini yapan araçlar her VTYS'de 
    bulunmaktadır.

    4) VTYS'ler genellikle birden fazla kullanıcıya aynı anda hizmet verecek biçimde client-server mimarisine uygun biçimde
    yazılmaktadır. Bunlara uzaktan erişilebilmekte ve aynı anda pek çok kullanıcı bunlara iş yaptırabilmektedir.

    5) VTYS'ler ileri derece güvenlik sunmaktadır. Bir kullanıcı başka bir kullanıcının bilgilerine erişememektedir.

    6) VTYS'ler yüksek miktarda kayıtlardan oluşan veritabanları üzerinde etkin bir biçimde işlemler yapabilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem programlama uygulamalarında bazen küçük veritabanlarının oluşturulması gerekebilmektedir. Bu tür durumlarda kapasiteli
    VTYS'ler yerine tek bir dosyadan oluşan adeta bir kütüphane biçiminde yazılmış olan gömülü VTYS'lerden (embedded DBMS)
    faydalanılmaktadır. Bunların en çok kullanılanı SQLite denilen gömülü VTYS'dir. Örneğin bir tarayıcı yazdığımızı düşünelim. 
    Son ziyaret edilen Web sayfalarının bir biçimde tarayıcıdan çıkıldıktan sonra saklanması gerekir. İşte bu tür durumlarda 
    SQLite gibi basit yapıda VTYS'ler tercih edilebilmektedir. Internet bağlantısı olmayan mobil cihazlarda da SQLite gibi 
    gömülü VTYS'ler çokça kullanılmaktadır. Örneğin biz bir soket uygulaması yazmış olalım. Bu uygulama bir log tutacak olsun. 
    Burada SQLServer, MySQL gibi büyük çaplı VTYS'ler yerine SQLite gibi bir gömülü VTYS'yi tercih edebiliriz. Gömülü VTYS'ler
    büyük çaplı veritabanlarında iyi bir performans gösterememektedir. Bunlar daha çok küçük ve orta çaplı veritabanlarında 
    kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanı işlemleri için C'den ziyade yüksek seviyeli diller tercih edilmektedir. Örneğin Java, C#, Python gibi diller 
    veritabanı işlemlerinde oldukça yaygın kullanılmaktadır. Benzer biçimde JavaScript de Web uygulamalarında veritabanları
    üzerinde işlem yapmak için kullanılan dillerdendir. Günümüzde veritabanlarının en çok kullanıldığı uygulamalar Web 
    uygulamalarıdır. Bir Web mağazasına girdiğinizde oradaki bütün ürünler veritabanlarında tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    VTYS'lerin client-server mimarisine uygun bir biçimde yazıldığını belirtmiştik. VTYS'lerle tipik çalışma şu biçimdedir:

    1) Programcı "kullanıcı ismi" ve "parola" ile VTYS'ye bağlanır. Bu durumda programcı client durumunda, VTYS ise server 
    durumundadır.

    2) Programcı VTYS'ye yaptırmak istediği şeyleri SQL dilinde oluşturur ve VTYS'ye SQL komutlarını gönderir.

    3) VTYS bu SQL komutlarını parse eder ve istenilen işlemleri yapar, programcıya işlemin sonuçlarını iletir.

    4) Programcı işi bittiğinde bağlantıyı kapatır.

    Her ne kadar SQLite ve Microsoft Access Jet Motoru gibi VTYS'ler aslında client-server çalışmıyor olsa da bunlar çalışma 
    biçimi olarak geniş kapasiteli VTYS'leri taklit etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanları tasarım bakımından birkaç gruba ayrılmaktadır. Günümüzde en çok kullanılan veritabanı mimarisine "İlişkisel
    Veritabanı (Relational Database) Mimarisi" denilmektedir. İlişkisel veritabanları "tablolardan (tables)", tablolar da 
    sütun ve satırlardan oluşmaktadır. Örneğin biz öğrencilerin bilgilerini tutmak için bir veritabanı tablosu oluşturalım. 
    Bu tablo aşağıdaki görünümde olsun:

    Adı Soyadı      Numarası        Sınıfı
    ---------------------------------------
    Ali Serçe       1234            3B
    Güray Sönmez    6745            2C
    Ayşe Er         6234            2B
    ...

    Tablolardaki sütunlara "alan (field)", satırlara ise "satır (row)" ya da "kayıt (record)" denilmektedir. MySQL, SQLServer, 
    Oracle, SQLite gibi VTYS'ler ilişkisel veritabanı mimarisini kullanmaktadır.

    Hiyerarşik bilgileri (örneğin bir ağaç yapısını) tutmak için hiyerarşik veritabanı mimarileri kullanılabilmektedir. Son 15
    senedir ismine "nosql" denilen ilişkisel olmayan ve özellikle metin tabanlı bilgiler üzerinde işlem yapan veritabanı 
    mimarileri sıkça kullanılır hale gelmiştir. Ancak en yaygın kullanılan mimari ilişkisel veritabanı mimarisidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                197. Ders 09/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    MySQL'i kurmak için tek yapılacak şey server programı http://dev.mysql.com/downloads/ sitesinden indirip yüklemektir. Kurulum 
    oldukça basittir. Birtakım sorular default değerlerle geçilebilir. Ancak kurulum sırasında MySQL kurulum programı bizden 
    “root” isimli yetkili kullanıcının parolasını istenecektir. Bu parola yetkili olarak VTYS'ye bağlanmak için gerekir. Server 
    programın yanı sıra bir yönetim ekranı elde etmek için ayrıca "MySql Workbench" programı da kurulabilir.

    MySQL Linux sistemlerinde Debian paket yöneticisi ile aşağıdaki gibi basit bir biçimde kurulabilir:

    $ sudo apt-get install mysql-server

    Kütüphane dosyaları da şöyle indirilebilir:

    $ sudo apt-get install libmysqlclient21

    MySQL Workbench ise komut satırı yerine Web Sayfasından indirilerek kurulabilir.

    Yukarıda da belirttiğimiz gibi MySQL kısmen paralı hale getirilince bunun MariaDB isimli bir klonu oluşturuldu. MariaDB'nin
    uzun vadede açık kaynak kod güvencesi olduğu için tercih edebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL paralı bir üründür. Fakat bunun da "Express Edition" isminde bedava bir sürümü vardır. Bu sürüm Microsoft'un sayfasından 
    indirilip kurulabilir. Tıpkı MySQL'de olduğu gibi SQL Server'da da yönetim konsol programı vardır. Buna "SQL Server Management 
    Studio" denilmektedir. Bunun da indirilip kurulması tavsiye edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQLite zaten tek bir DLL'den oluşmaktadır. Dolayısıyla aslında kurulumu diye bir durum söz konusu değildir. Fakat biz 
    burada C için örnekler yaparken SQLite başlık dosyalarına ve SQLite DLL’inin import kütüphanesine sahip olmak zorundayız. 
    Bunların nasıl elde edileceği sonraki konularda ele alınacaktır. SQLite yönetim konsolu olarak pek çok alternatif vardır. 
    Bunlardan biri "FireFox Add On" olarak çalışmaktadır. Diğer seçenekler ise “SQLite Studio” ve "SQLite Browser" programlarıdır. 
    Cross Platform olan bu araç ilgili web sayfasından indirilerek kurulabilir. Ya da daha genel "DBeaver" da tercih edilebilir.

    SQLite'ı Windows için aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.sqlite.org/download.html

    Buradan indirilen zip dosyasının içerisinde bir tane ".DLL" dosyası bir ".DEF" dosyası bulunacaktır. Bu DLL'i PATH dizinlerinin
    içerisine ya da uygulama dizininin içerisine çekebilirsiniz. Linux'ta SQLite şöyle indirilebilir:

    $ sudo apt-get install sqlite
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanları tablolardan, tablolar da sütunlardan (fields) oluşmaktadır. Tabii sütunların da veri türleri vardır. 
    SQL Standartları'nda standart bazı veri türleri belirtilmiştir. Ancak SQL VTYS'den VTYS'ye değişiklik gösterebilmektedir. 
    Dolayısıyla her VTYS'nin SQL komutlarında bazı farklılıklar bulunabilmektedir. Biz burada bazı standart sütun türleri
    üzerinde duracağız. Çalıştığınız VTYS'nin dokümanlarından onlara özgü ayrıntıları elde edebilirsiniz.

    INTEGER: Tamsayısal bilgileri tutan bir türdür. İstenirse kaç digitlik sayıların tutulacağı da belirtilebilir.

    INT: Tipik olarak 4 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki int türü ile temsil edilebilir.)

    SMALLINT: Tipik olarak 2 byte'lık işaretli tamsayı türüdür. (Örneğin bu tür C’deki short türü ile temsil edilebilir.)

    BIGINT: Tipik olarak 8 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki long long türü ile temsil 
    edilebilir.)

    FLOAT: Tipik olarak 4 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki float türü ile temsil edilebilir.)

    DOUBLE: Tipik olarak 8 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki double türü ile temsil edilebilir.)

    TIME: Zaman bilgisini saklamak için kullanılan türdür.

    DATE: Tarih bilgisini saklamak için kullanılan türdür.

    CHAR(n): n karakterli yazıyı tutmak için kullanılan türdür.

    VARCHAR(n): En fazla n karakterli bir yazıyı tutmak için kullanılan türdür.

    TINYTEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    TEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGTEXT: (Tipik olarak 4GB'ye byte'a kadar)

    TINYBLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    BLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGBLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 4GB'ye byte'a kadar)

    Tablo sütunlarının türleri tablo yaratılırken belirlenmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                198. Ders 16/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de temel SQL komutlarını görelim. SQL bazı ayrıntıları olan dekleratif bir programlama dilidir. Komutlardan oluşmaktadır.
    Biz burada temel SQL komutlarını ayrıntılarına girmeden ele alacağız.

    SQL büyük harf küçük harf duyarlılığı olmayan (case insensitive) bir dildir. Ancak geleneksel olarak anahtar sözcüklerin
    büyük harflerle yazılması tercih edilmektedir. SQL komutlarının sonunda sonlandırıcı olarak ';' karakteri bulundurulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    CREATE DATABASE Komutu: İlişkisel veritabanlarında “veritabanı” tablolardan oluşmaktadır. Bu nedenle önce bir veritabanının 
    yaratılması, sonra da onun içerisinde tabloların yaratılması gerekir. Veritabanlarını yaratmak için CREATE DATABASE komutu 
    kullanılır. Komutun genel biçimi şöyledir:

    CREATE DATABASE <isim>;

    Örneğin:

    CREATE DATABASE student;

    USE Komutu: Belli bir veritabanı üzerinde işlemler yapmak için öncelikle onun seçilmesi gerekir. Bu işlem USE komutuyla 
    yapılır. Komutun genel biçimi şöyledir:

    USE <isim>;

    SHOW DATABASES Komutu: Bu komut VTYS'de yaratılmış olarak bulunan veritabanlarını gösterir. Komutun genel biçimi şöyledir:

    SHOW DATABASES;

    CREATE TABLE Komutu: Bu komut veritabanı için bir tablo yaratmak amacıyla kullanılır. Komutun genel biçimi şöyledir:

    CREATE TABLE <isim> (<isim> <tür>, <isim> <tür>, <isim> <tür>... );

    Aslında bu komutun bazı ayrıntıları vardır. Bu ayrıntılar ilgili dokümanlardan öğrenilebilir.

    Örneğin:

    CREATE TABLE student_info(student_id PRIMARY KEY AUTO_INCREMENT, student_name VARCHAR(45), student_no INTEGER);

    Bir tabloda tekrarlanması yasaklanmış olan sütunlara “birincil anahtar (primary key)” denilmektedir. Tablodaki kayıtların 
    hepsinin birincil anahtar sütunları farklı olmak zorundadır. Başka bir deyişle biz bir tabloya orada zaten var olan birincil 
    anahtar değerine ilişkin bir kayıt ekleyemeyiz. Her tabloda bir tane birincil anahtarın olması tavsiye edilmektedir. 
    Birincil anahtarın tablo yaratılırken CREATE TABLE komutunda belirtilme biçimi çeşitli VTYS’lerde farklı olabilmektedir.

    DROP TABLE Komutu: Bu komut tabloyu silmek için kullanılır. Komutun genel biçimi şöyledir:

    DROP TABLE <isim>;

    Örneğin:

    DROP TABLE person;

    INSERT INTO Komutu: Bu komut bir tabloya bir satır eklemek için kullanılır. Komutun genel biçimi şöyledir:

    INSERT INTO <tablo ismi> (sütun1, sütun2, sütun3,...) VALUES (değer1, değer2, değer3,...);

    Tabloya satır eklerken aslında her sütun bilgisinin belirtilmesi gerekmez. Bu durumda o sütun için tablo yaratılırken 
    (CREATE TABLE komutunda) belirlenmiş olan default değerler kullanılır. Komutun ayrıntılı genel biçimi için ilgili 
    dokümanlara başvurabilirsiniz. Örneğin:

    INSERT INTO student_info(student_name, student_no) VALUES('Güray Sönmez', 754);

    Değerler girilirken yazılar ve tarihler tek tırnak içerisinde belirtilmelidir.

    WHERE Cümleciği: Pek çok komut bir WHERE kısmı içermektedir. Where cümleciği koşul belirtmek için kullanılır. Koşullar 
    karşılaştırma operatörleriyle oluşturulur. Mantıksal operatörlerle birleştirilebilir. Örneğin:

    WHERE age > 20 AND birth_place = 'Eskişehir'

    LIKE operatörü joker karakterleri kullanılarak belli bir kalıba uyan yazı koşulu oluşturur. Örneğin:

    WHERE student_name LIKE 'A%'

    Burada student_name için 'a' ile başlayanlar koşulu verilmiştir. % karakteri "geri kalanı herhangi biçimde olabilir" 
    anlamına gelir. Örneğin:

    WHERE student_name LIKE '%an'

    Burada sonu 'an' ile bitenler koşulu verilmiştir.

    WHERE cümleciğinin bazı detayları vardır. Bu detaylar ilgili dokümanlardan öğrenilebilir.

    DELETE FROM Komutu: Bu komut bir tablodan satır silmek için kullanılır. Komutun genel biçimi şöyledir:

    DELETE FROM <tablo ismi> <WHERE cümleciği>;

    UPDATE Komutu: Update komutu belli kayıtların alan bilgilerini değiştirmek amacıyla kullanılır. Örneğin ismi "Kağan" 
    olan bir kaydı "Kaan" olarak değiştirmek isteyebiliriz. Ya da bir müşterinin bakiyesini değiştirmek isteyebiliriz. Komutun 
    genel biçimi şöyledir:

    UPDATE <tablo ismi> SET alan1 = değer1, alan2 = değer2, ... WHERE <koşul>;

    Örneğin:

    UPDATE student_info SET student_name = 'Kaan Kaplan' WHERE student_name = 'Kaan Aslan'

    DELETE ve UPDATE komutlarını kullanırken dikkat ediniz. Çünkü eğer koşul belirtmezseniz ya da koşulu yanlış belirtirseniz
    yaptığınız işlemden birden fazla kayıt etkilenir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı';

    Burada koşul zayıf oluşturulmuştur. Bu durumda bütün "Veli Ballı" isimleri "Ali Ballı" olarak değiştirilir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı' AND student_no = 754;

    Artık burada ismi "Veli Ballı" olan ve numarası 754 olan satırın ismi "Ali Ballı" olarak değiştirilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                199. Ders 21/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SELECT Komutu: Koşulu sağlayan kayıtların elde edilmesi SELECT komutuyla yapılmaktadır. SELECT komutunun genel biçimi 
    oldukça ayrıntılıdır. Çünkü komuta çeşitli cümlecikler monte edilebilmektedir. Komutun genel biçimi şöyledir:

    SELECT <sütun_listesi> FROM <tablo_ismi> [WHERE <koşul];

    Eğer WHERE cümleciği kullanılmazsa tablodaki tüm kayıtlar elde edilir. Sütun listesi sütunların isimlerinden oluşmaktadır. 
    Uygulamacı yalnızca bazı sütun bilgilerini elde edebilir. Sütun istesi yerine "*" kullanılırsa "tüm sütunlar" anlamına gelmektedir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY student_name;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY student_name;

    ORDER BY default olarak kayıtları küçükten büyüğe (ASC) vermektedir. Ancak DESC ile büyükten küçüğe de sıralama yapılabilir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC;

    ORDER BY cümleciğinde birden fazla sütun belirtilebilir. Bu durumda ilk sütun değerleri aynıysa diğer sütunlar dikkate alınır. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC;

    Burada ismi aynı olanlar numaralarına göre küçükten büyüğe elde edilecektir.

    LIMIT cümleceği de SELECT cümlesiyle kullanılabilir. LIMIT anahtar sözcüğünün yanında bir sayı bulunur. Koşulu sağlayan 
    belli sayıdaki kayıtları elde etmek için kullanılır. Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC LIMIT 10;

    WHERE cümleciğinde built-in fonksiyonlar kullanılabilir. Örneğin:

    SELECT * FROM city WHERE char_length(city) = 6;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanlarında tablolarda veri tekrarı istenmez. Örneğin bir öğrenci veritabanı oluşturacak olalım. Bir öğrencinin 
    çeşitli bilgilerinin yanı sıra onun okulu hakkında da bilgileri tutmak isteyelim. Aşağıdaki gibi bir tablo tasarımı uygun 
    değildir:

    Adı Soyadı  No      Okul Adı                Okulun Bulunduğu Şehir      Okulun Türü
   --------------------------------------------------------------------------------------
    Ali Serçe   123     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    Kaan Aslan  745     Eskişehir Atatürk Lisesi    Eskişehir               Devlet Lisesi
    Hasan Bulur 734     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    ...                 ...                         ...                     ...

    Burada Okul Adı bilgileri gereksiz bir biçimde tekrarlanmaktadır. Bu tekrarı engellemek için iki tablo oluşturabiliriz.

    Öğrenci Tablosu

    Adı Soyadı     No      Okul ID'si
    ----------------------------------
    Ali Serçe      123     100
    Kaan Aslan     745     235
    Hasan Bulur    734     100
    ...            ...     ...

    Okul Tablosu

    Okul Id'si       Okul Adı                   Okulun Bulunduğu Şehir      Okulun Türü
    ------------------------------------------------------------------------------------
    ...              ...                        ...                         ...
    100              Tarsus Amerikan Lisesi     Mersin                      Devlet Lisesi
    150              Eskişehir Atatürk Lisesi   Eskişehir                   Devlet Lisesi
    ...              ...                        ...                         ...

    Burada veri tekrarı ortadan kaldırılmıştır. Tabii bu tablolarda da Okul ID'si ortak bir sütundur. Bu ortak sütun tablolar 
    arasında ilişki kurmak için gerekmektedir. Bu tür sütunlara "foreign key" de denilmektedir. Ancak yukarıdaki gibi tekrarlar 
    engellendiğinde gerekli bilgiler artık tek bir tablodan değil, çeşitli tablolardan çekilip alınacaktır. İşte çeşitli tablolardan 
    bilgilerin çekilip alınması işlemine "JOIN" işlemi denilmektedir. JOIN işleminin birkaç biçimi vardır (INNER JOIN, OUTER JOIN, 
    LEFT JOIN, RIGHT JOIN gibi). Ancak en fazla kullanılan JOIN işlemi "INNER JOIN" denilen işlemdir. JOIN denildiğinde zaten 
    default olarak INNER JOIN anlaşılır. INNER JOIN işleminde eğer iki tablo söz konusu ise önce iki tablonun kartezyen çarpımları 
    elde edilir. Her kartezyen çarpım iki tablonun birleştirilmesi biçiminde ("join" ismi oradan geliyor) elde edilmektedir. 
    Sonra kartezyen çarpımlarda yalnızca belli koşulu sağlayan satırlar elde edilir. Böylece tablolar "ilişkisel (relational)" 
    biçimde birleştirilmiş olur.

    INNER JOIN sentaksı iki biçimde oluşturulabilmektedir. Birinci sentaks klasik eski tip sentakstır. İkinci sentaks daha modern 
    biçimdir. Klasik eski tip sentaks şöyledir:

    SELECT <iki tablodaki istenen sütunların listesi> FROM <birinci tablo ismi> INNER JOIN <ikinci tablo ismi> ON <koşul>;

    Örneğin:

    SELECT student.student_name, student.student_no, school.school_name FROM student INNER JOIN school ON 
    student.school_id = school.school_id WHERE stduent.student_no > 600;

    Sütun isimleri belirtilirken eğer çakışma yoksa yalnızca isimler yazılabilir. Ancak çakışma varsa tablo ismi ve nokta 
    operatörü ile sütunun hangi tabloya ilişkin olduğu belirtilmelidir. Bazı uygulamacılar çakışma olsa da olmasa da 
    niteliklendirme yaparlar. Bazı uygulamacılar yalnızca çakışan sütunlarda niteliklendirme yaparlar. Yukarıdaki örnekte 
    tüm sütunlar niteliklendirilerek belirtilmiştir. Bu örnek şöyle de yapılabilirdi:

    SELECT student_name, student_no, school_name FROM student INNER JOIN school ON student.school_id = school.school_id 
    WHERE student_no > 600;

    Modern INNER JOIN sentaksında SELECT komutunun FROM kısmında birden fazla tablo ismi belirtilir. Koşul da yine WHERE 
    cümleciğine taşınır. Örneğin:

    SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id AND 
    student_no > 600;

    Daha çok bu modern biçim tercih edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemlere başlamadan önce SQLite’ın programlama kurulumunu yapmamız gerekir. SQLite yukarıda da belirttiğimiz gibi 
    çok küçük (tek bir dinamik kütüphaneden oluşan) bir VTYS’dir. Dolayısıyla onun kurulması Windows’ta bildiğimiz anlamda 
    bir setup işlemi ile yapılmaz. Tabii bizim C’den SQLite kütüphanesini kullanabilmemiz için ona ilişkin başlık ve kütüphane 
    dosyalarını elde etmemiz gerekir. Windows'ta SQLite'ın resmi indirme sitesi şöyledir:

    https://sqlite.org/download.html

    Buradan aşağıdaki iki indirme yapılır:

    1) Precompiled Binaries for Windows (32 bit ya da 64 bit)
    2) SQLite Amalgamation

    Birinci indirmede tek bir DLL elde edilecektir. İkinci indirmede de "sqlite3.h" başlık dosyası ve kaynak dosyası elde 
    edilecektir.

    Ayrıca SQlite için "sqlite3" isminde komut satırından kullanılan bir program da bulundurulmuştur. Bu programın kullanımına 
    ilişkin bilgileri aşağıdaki bağlantıdan edinebilirsiniz:

    https://www.sqlite.org/cli.html

    Birinci indirmede Windows için gereken sqlite3.dll ve sqlite3.def dosyaları elde edilir. Buradaki “.def” dosyasına 
    “module definition file” denilmektedir. Bu dosya “DLL’in import kütüphanesi” gibi link aşamasına dahil edilebilir. 
    Ya da istenirse aşağıdaki komutla bu “.def” dosyasından “.lib” uzantılı “import kütüphanesi de oluşturulabilmektedir:

    LIB /DEF:sqlite3.def /machine:x86

    Buradaki "machine" argümanı hedef sistemi belirtmektedir. Burada 32 bit Windows sistemleri için x86, 64 bit Windows 
    sistemleri için "x64" kullanılmalıdır. Örneğin:

    LIB /DEF:sqlite3.def /machine:x64

    İkinci indirmeden biz SQLite’ın kaynak dosyalarını elde ederiz. Buradaki “sqlite3.h” dosyası SQLite fonksiyonları için 
    başlık dosyası niteliğindedir.

    Debian kökenli (Debian, Ubuntu, Mint vs.) apt-get kullanan sistemlerde bu işlem şöyle yapılabilir:

    $ sudo apt-get install sqlite3 libsqlite3-dev

    Mac OS X için kurulum Windows’takine benzemektedir. Yine ilgili “.zip” dosyaları indirilip kurulum yapılabilir. Bu 
    sistemlerde derleme yaparken link aşamasında "-lsqlite3" ile kütüphane dosyasını belirtmeyi unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                200. Ders 23/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurulum sonrası her şeyin hazır olduğunu anlamak için SQLite kütüphanesinin versiyon numarasını yazdıran aşağıdaki 
    gibi bir programla test işlemi yapabilirsiniz:

    #include <stdio.h>
    #include "sqlite3.h"

    int main(void)
    {
        printf("%s\n", sqlite3_libversion());

        return 0;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C’de SQLite veritabanı ile işlem yapmak için önce o veritabanının sqlite3_open fonksiyonuyla açılması gerekir. Bu işlemden 
    sqlite3 türünden bir handle elde edilir. sqlite3_open fonksiyonunun prototipi şöyledir:

    int sqlite3_open(
        const char *filename,   /* Database filename (UTF-8) */
        sqlite3 **ppDb          /* OUT: SQLite db handle */
    );

    Fonksiyonun birinci parametresi bizden sqlite dosyasının yol ifadesini alır. İkinci parametresi sqlite3 isimli yapı türünden 
    bir göstericinin adresini almaktadır. Fonksiyon handle alanını (yani sqlite yapı nesnesini) oluşturur. Onun adresini bu 
    göstericinin içerisine yerleştirir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtmektedir. Fonksiyon başarılıysa 
    SQLITE_OK değerine geri döner. Fonksiyon başarısız olduğunda yine dosyanın sqlite3_close fonksiyonuyla kapatılması gerekir. 
    Hata nedeni de sqlite3_errmsg fonksiyonuyla yazdırılabilir. Bu durumda sqlite dosyasının açılması tipik olarak şöyle 
    yapılabilir:

    if (sqlite3_open("student.db", &db) != SQLITE_OK) {
        fprintf(stderr, "sqlite3_open failed: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        exit(EXIT_FAILURE);
    }

    sqlite3_open fonksiyonu dosya varsa olanı açar, yoksa yeni bir SQLite DB dosyası yaratır.

    sqlite3_errmsg fonksiyonunun parametrik yapısı şöyledir:

    const char *sqlite3_errmsg(sqlite3 *db);

    sqlite3_close fonksiyonunun prototipi ise şöyledir:

    int sqlite3_close(sqlite3*);

    Dosya kapatılırken başarı kontrolü yapmaya gerek yoktur. Başarısızlık durumlarında hata mesajını stderr dosyasına yazdırıp
    programı sonlandıran bir sarma fonksiyon şöyle yazılabilir:

    void sqlite3_exit(const char *msg, sqlite3 *db)
    {
        fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
        sqlite3_close(db);

        exit(EXIT_FAILURE);
    }

    Böylece biz hata durumlarını aşağıdaki gibi ele alabiliriz:

    if (sqlite3_open("studentxxx.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    printf("success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SQLite'a bir SQL cümlesi göndermek için sqlite3_exec fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int sqlite3_exec(
        sqlite3 *db,                               /* An open database */
        const char *sql,                           /* SQL to be evaluated */
        int (*callback)(void*,int,char**,char**),  /* Callback function */
        void *param,                               /* 1st argument to callback */
        char **errmsg                              /* Error msg written here */
    );

    Fonksiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre sql cümlesinin 
    yazısını alır. Üçüncü parametre işlemden sonra çağrılacak “callback” fonksiyonun adresini almaktadır. Bu parametre NULL 
    geçilebilir. Dördüncü parametre bu “callback” fonksiyona geçirilecek argümanı belirtir. Bu parametre de NULL geçilebilir. 
    Son parametre ise char * türünden bir göstericinin adresini almaktadır. Hata durumunda hata mesajının adresi bu göstericiye 
    yerleştirilir. Bu parametre NULL olarak da geçilebilir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtir. Fonksiyon 
    başarılıysa SQLITE_OK değerine geri dönmektedir. Bu durumda biz hata mesajını yazdırdıktan sonra sqlite3_free fonksiyonu 
    ile tahsis edilen alanı serbest bırakabiliriz. Örneğin:

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) VALUES('Rasim Öztekin', 367)", 
                NULL, NULL, NULL) != SQLITE_OK)
        sqlite3_exit("sqlite3_exec", db);

    Aşağıdaki örnekte student_info veritabanına sqlite3_exec fonksiyonu ile bir kayıt eklenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) VALUES('Rasim Öztekin', 367)", NULL, NULL, NULL) != SQLITE_OK) 
        sqlite3_exit("sqlite3_exec", db);

    printf("Success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                201. Ders 07/03/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanından kayıtların elde edilmesi biraz daha ayrıntılı bir konudur. İstenilen kayıtların elde edilmesi için iki 
    yol vardır. Birincisinde önce sqlite3_prepare fonksiyonu ile SQL SELECT cümlesi VTYS’ye gönderilir. Sonra her bir kayıt 
    tek tek sqlite3_step fonksiyonu çağrılarak elde edilir. sqlite3_prepare fonksiyonundan elde edilen kayıtların bir liste 
    oluşturduğunu sqlite3_step fonksiyonunun da listede sonraki kayda geçtiğini düşünebilirsiniz. Yani adeta sqlite3_step 
    fonksiyonu imleci bir sonraki kayda konumlandırıyormuş gibidir. O andaki kayıtın sütun elemanları sqlite3_column_xxx 
    fonksiyonlarıyla elde edilebilir. Burada xxx o sütunun türünü belirtmektedir. sqlite3_prepare fonksiyonunun prototipi 
    şöyledir:

    int sqlite3_prepare(
        sqlite3 *db,            /* Database handle */
        const char *zSql,       /* SQL statement, UTF-8 encoded */
        int nByte,              /* Maximum length of zSql in bytes. */
        sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
        const char **pzTail     /* OUT: Pointer to unused portion of zSql */
    );

    Fonksiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre SELECT 
    cümlesini belirtir. Üçüncü parametre ikinci parametredeki SELECT cümlesine ilişkin yazının uzunluğunu belirtir. Bu 
    parametre negatif değer geçilirse (örneğin -1) bu yazı null karaktere kadar ele alınır. Fonksiyonun dördüncü parametresi 
    sqlite3_stmt türünden bir yapı göstericisinin adresini almaktadır. Bu da bir handle değeri gibidir. Kayıtlar elde edilirken 
    bu handle değeri kullanılmaktadır. Son parametre NULL geçilebilir. Fonksiyon başarı durumunda SQLITE_OK değerine geri 
    dönmektedir. Fonksiyon başarılı olduğunda imleç ilk kaydın bir gerisini göstermektedir. Yani işleme önce bir kez 
    sqlite3_step çağrısı yaparak başlamak gerekir. Her sqlite3_step çağrısı select edilen kayıtlardan bir sonrasına konumlanma 
    sağlar. sqlite3_step fonksiyonunun prototipi şöyledir:

    int sqlite3_step(sqlite3_stmt*);

    Fonksiyonun parametresi sqlite3_prepare fonksiyonundan alınan handle değeridir. Son kayda erişildikten sonra sqlite3_step 
    fonksiyonu SQLITE_DONE değerine geri dönmektedir. O halde bu yöntemde önce bir kez sqlite3_prepare fonksiyonu çağrılır. 
    Sonra bir döngü içerisinde sqlite3_step çağrıları yapılır. İmleç konumlandırıldıktan sonra sütun değerleri sqlite3_column_xxx 
    fonksiyonlarıyla elde edilmektedir. Her sütun türü için ayrı bir fonksiyon vardır. Bu fonksiyonlardan bazılarının 
    prototipleri aşağıda verilmiştir:

    const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
    double sqlite3_column_double(sqlite3_stmt*, int iCol);
    int sqlite3_column_int(sqlite3_stmt*, int iCol);
    sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
    const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
    const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
    int sqlite3_column_type(sqlite3_stmt*, int iCol);
    sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);

    Bu işlemler bittikten sonra sqlite3_finalize fonksiyonu çağrılmalıdır. Fonksiyonun prototipi şöyledir:

    int sqlite3_finalize(sqlite3_stmt *pStmt);

    Fonksiyon başarı durumunda SQLITE_OK değeri ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte komut satırında bir menü çıkartılmış ve seçilen seçeneğe göre uygun işlemler yapılmıştır. Menü 
    aşağıdaki gibidir:

    1) Kayıt Ekle
    2) Kayıt Sil
    3) Kayıt Bul
    4) Çıkış
    Seçiminiz:

    Örnekteki "student.db" veritabanı yoksa yaratılmaktadır, varsa olan veritabanı açılmaktadır. Eğer veritabanı yoksa aşağıdaki
    SQL komutuyla tablo yaratılmıştır:

    "CREATE TABLE IF NOT EXISTS student_info(student_id INTEGER PRIMARY KEY AUTOINCREMENT, 
        student_name VARCHAR(64), 
        student_no INTEGER
    );"

    Görüldüğü gibi student_info tablosunda üç sütun vardır. Sütunlardan biri otomatik artırımlı PRIMARY KEY sütunudur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include "sqlite3.h"

int disp_menu(void);
void clear_stdin(void);
void add_record(sqlite3 *db);
void del_record(sqlite3 *db);
void find_record(sqlite3 *db);
void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;
    int option;

    setlocale(LC_ALL, "tr_TR.UTF-8");

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db,
            "CREATE TABLE IF NOT EXISTS student_info("
            "student_id INTEGER PRIMARY KEY AUTOINCREMENT, "
            "student_name VARCHAR(64), "
            "student_no INTEGER);", NULL, NULL, NULL != SQLITE_OK))
        sqlite3_exit("sqlite3_exec", db);

    for (;;) {
        if ((option = disp_menu()) == -1) {
            printf("Geçersiz seçenek!...\n");
            clear_stdin();
            continue;
        }
        switch (option) {
            case 1:
                add_record(db);
                break;
            case 2:
                del_record(db);
                break;
            case 3:
                find_record(db);
                break;
            case 4:
                goto EXIT;
            default:
                printf("Geçersiz seçenek!...\n");
        }
    }

EXIT:
    sqlite3_close(db);

    return 0;
}

int disp_menu(void)
{
    int option;

    printf("1) Kayıt Ekle\n");
    printf("2) Kayıt Sil\n");
    printf("3) Kayıt Bul\n");
    printf("4) Çıkış\n");

    printf("Seçiminiz: ");
    fflush(stdout);
    if (scanf("%d", &option) != 1)
        return -1;
    clear_stdin();

    return option;
}

void clear_stdin(void)
{
    while (getchar() != '\n')
        ;
}

void add_record(sqlite3 *db)
{
    char name[64];
    char sql[1024];
    char *str;
    int no;

    printf("Adı Soyadı:");
    fflush(stdout);
    fgets(name, 64, stdin);
    if ((str = strchr(name, '\n')) != NULL)
        *str = '\0';
    printf("No:");
    fflush(stdout);
    scanf("%d", &no);
    clear_stdin();

    sprintf(sql, "INSERT INTO student_info(student_name, student_no) VALUES('%s', %d);", name, no);

    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot add record!...\n");
}

void del_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';
    sprintf(sql, "DELETE FROM student_info WHERE %s;", condition);
    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot delete record!...\n");
}

void find_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;
    sqlite3_stmt *stmt;
    unsigned char *name;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';

    printf("\n");
    if (*str == '\0')
        strcpy(sql, "SELECT student_name, student_no FROM student_info");
    else
        sprintf(sql, "SELECT student_name, student_no FROM student_info WHERE %s;", condition);

    if (sqlite3_prepare(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        return;
    }

    while (sqlite3_step(stmt) != SQLITE_DONE) {
        name = sqlite3_column_text(stmt, 0);
        no = sqlite3_column_int(stmt, 1);
        printf("%s, %d\n", name, no);
    }

    sqlite3_finalize(stmt);

    printf("\n");
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                202. Ders 09/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                203. Ders 16/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki işlemlerin benzerlerinin MySQL'de nasıl yapılacağını görelim. MySQL'in de C için API'leri vardır. 
    MySQL VTYS’si ile işlemler MySQL’in gerekli kütüphanelerinin client tarafta kurulması gerekir. Bunun için Windows’ta, 
    macOS sistemlerinde ve Linux’ta “MySQL C++ Connector” denilen kurulum yapılabilir. Bu paket aşağıdaki bağlantıdan
    indirilebilir:

    https://downloads.mysql.com/archives/c-c/

    Bu kurulum yapıldığında tipik olarak gerekli olan kütüphaneler ve include dosyaları "C:\Program Files\MySQL\MySQL Connector C 6.1"
    gibi bir dizine kurulacaktır.

    Debian türevi (Ubuntu, Mint vs.) sistemlerde aşağıdaki apt-get komutu bu paketin indirilerek kurulmasını sağlamaktadır:

    $ sudo apt-get install libmysqlclient-dev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows ortamında VisualStudio IDE'sinde çalışıyorsanız projenizde "Additional Include Directories" elemanında MySQL 
    Connector'ü kurduğunuz dizindeki include dizinini burada belirtmelisiniz. Ayrıca Windows'ta link işlemi için "libmysql.lib"
    import kütüphanesinin de projede belirtilmesi gerekmektedir. Ancak programın çalışabilmesi için "libmysql.dll" dosyasının 
    ya sistem tarafından bakılan dizinlerin birinde olması ya da PATH çevre değişkeni ile belirtilen dizinlerden birinde olması 
    gerekmektedir.

    Linux'ta MySQL include dosyaları "/usr/include/mysql" dizini içerisindedir. Dolayısıyla include işlemi <mysql/mysql.h>
    biçiminde yapılmalıdır. Linux'ta ayrıca "libmysqlclient" kütüphanesinin de bağlama işlemine dahil edilmesi gerekmektedir. 
    Derleme işlemini şöyle yapmalısınız:

    $ gcc -o sample sample.c -lmysqlclient
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir MYSQL C programda ilk yapılacak şey mysql_init fonksiyonu çağırarak bir handle elde etmektir:

    MYSQL *MySQL_init(MYSQL *MySQL);

    Bu fonksiyon parametre olarak bizden MYSQL türünden bir nesnenin adresini ister onun içini doldurur. Eğer parametre NULL 
    girilirse fonksiyon bu nesneyi kendisi tahsis edip bize adresini verecektir. Fonksiyon başarısız olabilir. Başarısızlık 
    durumunda NULL adrese geri döner. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "MySQL_init failed\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

int main(void)
{
    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysqlL_init failed\n");
        exit(EXIT_FAILURE);
    }

    printf("Ok\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    MYSQL * türünden handle elde edildikten sonra artık "IP adresi", "port numarası", "kullanıcı adı", "parola" ve bağlanılacak
    veritabanını belirtilerek bağlantı mysql_real_connect fonksiyonuyla sağlanır. Fonksiyonun prototipi şöyledir:

    MYSQL *mysql_real_connect(MYSQL *MySQL, const char *host, const char *user, const char *passwd, const char *db, 
            unsigned int port, const char *unix_socket, unsigned long client_flag);

    Fonksiyonun birinci parametresi mysql_init fonksiyonundan elde edilmiş olan handle değeridir. İkinci parametre host'un
    IP adresini, üçüncü parametre MySQL'deki kullanıcı ismini almaktadır. MySQL'i ilk kurduğunuzda tüm yetkilere sahip bir 
    "root" kullanıcısı bulunmaktadır. Bu kullanıcı tüm veritabanlarına erişebilmektedir. Tabii siz isterseniz kısıtlı 
    kullanıcılarda yaratabilirsiniz. Fonksiyonun dördüncü parametresi kullanıcıya ilişkin parolayı belirtmektedir. "root" 
    kullanıcısının parolası kurulum sırasında belirlenmektedir. Beşinci parametre kullanılacak veritabanının ismini almaktadır. 
    Altıncı parametre port numarasını belirtmektedir. MySQL Server programlarının kullandığı default port numarası 3306'dır. 
    Son iki parametre NULL ve 0 biçiminde geçilebilir. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysql_init failed!...\n");
        exit(EXIT_FAILURE);
    }

    if (mysql_real_connect(db, "localhost", "root", "maviay", "student_info", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", NULL);

    MySQL ile çalışırken hata durumlarında bağlantıyı kapatıp prosesi sonlandırmak için aşağıdaki gibi bir fonksiyondan 
    faydalanabiliriz:

    void exit_err(const char *msg, MYSQL *db)
    {
        fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
        mysql_close(db);
        exit(EXIT_FAILURE);
    }

    mysql_close fonksiyonuna NULL adres geçilirse close işlemi yapılmaz ama mysql_init fonksiyonuyla tahsis edilmiş olan handle 
    alanı boşaltılır.

    Server'a bağlanırken birkaç problem ortaya çıkabilir. Server default SSL kullanıyor olabilir. Bu durumda SSL konfigürasyonunu
    yapmadıysanız bağlantı sırasında sorun oluşabilir. Bağlanırken SSL'i pasif hale getirmek için (disable etmek için) iki yöntem 
    kullanılabilir. Birincisi "mysql.ini" ya da "my.cnf" dosyasına aşağıdaki satırlar girilerek SSL kullanımı devre dışı bırakılabilir:

    [mysqld]
    ssl=0
    skip_ssl

    Windows sistemlerinde "mysql.ini" dosyası "C:\ProgramData\MySQL\MySQL Server 8.0" dizin içerisinde bulunmaktadır. Linux 
    sistemlerinde "my.cnf" dosyası "/etc/mysql" dizini içerisindedir. Bu dosyaları edit etmek için editörünüzü "Administrator" 
    ya da "sudo" hakkıyla açmalısınız. İkinci yöntem programa özgü bir biçimde SSL'i mysql_options fonksiyonu ile devre dışı 
    bırakmaktır. Bu işlem şöyle yapılabilir:

    int ssl_mode = SSL_MODE_DISABLED;

    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode))
        exit_err("mysql_options failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Eskiden MySQL server programı default olarak uzak bağlantıları kabul ediyordu. Sonra default durumda uzak bağlantılara
    izin verilmemeye başlandı. Yani siz yerel ağınızda bile olsa başka bir makinedeki MySQL Server programına IP adresi ve 
    port numarası belirterek bağlanamayabilirsiniz. Uzak bağlantılara izin vermek için konfigürasyonda bazı ayarlamaların 
    yapılması gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                204. Ders 21/03/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL cümlesini server’a gönderip işletmek için MySQL_query fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int mysql_query(MYSQL *MySQL, const char *stmt_str);

    Fonksiyonun birinci parametresi handle değerini, ikinci parametresi SQL komut yazısını alır. Fonksiyon başarı durumunda 
    sıfır, başarısızlık durumunda sıfır dışı bir değere geri döner. Örneğin:

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no) VALUES('Ali Eker', 345)") != 0)
        exit_err("mysql_query", db);

    Aşağıda program bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode))
        exit_err("mysql_options failed", db);

    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no, student_school_id) VALUES('Ali Eker', 122, 1)") != 0)
        exit_err("mysql_query", db);

    printf("Ok\n");

    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    MySQL server'ı Linux'ta kullanıyorsanız tüm ayarlar default durumda Unicode UTF-8 enconding'ine ilişkindir. Linux ortamında 
    uzun süredir default encoding zaten Unicode UTF-8 olduğu için bu ortamda çalışırken bir encoding sorunu ortaya çıkmayacaktır. 
    Ancak Windows sistemlerinde MySQL server kurulduğunda default encoding Unicode UTF-8 yerine Microsoft'un 1254 Code Page'i
    olabilir. MySQL'de encoding çeşitli düzeylerde değiştirilebilmektedir. Örneğin:

    - Server Düzeyinde
    - Veritabanı Düzeyinde
    - Tablo Düzeyinde
    - Tablonun Sütunu Düzeyinde

    Aşağıdaki belirleme yukarıda yapılan belirlemeyi devre dışı bırakmaktadır. Ayrıca MySQL'de client programlar da server
    ile bağlandığında server'dan belli bir encoding kullanmasını isteyebilmektedir. Yani server ayarları yapılmış olsa bile 
    client programların da encoding isteklerinin uygun olması gerekebilmektedir. Client'ın default encoding davranışı da aslında
    server ayarlarından belirlenebilmektedir. Client için bu ayar uygun değilse client program bağlantıdan sonra mysql_options
    fonksiyonu ile bunu aşağıdaki gibi değiştirebilir:

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Belli koşulu sağlayan kayıtların ele geçirilmesi için başka bir deyişle SELECT cümlesi ile seçilen kayıtların elde 
    edilmesi için birkaç yol vardır. Bunun için önce SELECT cümlesi yine sql_query fonksiyonuyla uygulanır. Sonra select 
    edilen kayıtların elde edilmesi için şu işlemler yapılır:

    1) mysql_store_result fonksiyonu çağrılarak bir “result handle değeri” elde edilir:

    MYSQL_RES *mysql_store_result(MYSQL *MySQL);

    Fonksiyon parametre olarak bizden mysql_init ile elde edilen handle değerini alır ve bize kayıtları elde etmemiz için 
    gereken MYSQL_RES * türünden bir handle değeri verir. Fonksiyon başarısız olursa NULL adrese geri dönmektedir.

    2) Kayıtların tek tek ele geçirilmesi için mysql_fetch_row fonksiyonu bir döngü içerisinde çağrılır. Bu fonksiyonun 
    prototipi şöyledir:

    MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);

    Fonksiyon mysql_store_result fonksiyonundan elde edilen handle değerini alır ve MYSQL_ROW türüyle geri döner. Bu tür 
    aslında char ** biçiminde typedef edilmiştir. Yani char türünden göstericileri tutan dizinin adresini belirtir. İşte 
    bu fonksiyon NULL adres döndürene kadar döngü içerisinde ilerlenir. Artık kayıtlara ilişkin sütun bilgilerine MYSQL_ROW 
    türünden göstericiye sütun numarası indeks yapılarak erişilir. Ancak bu türden erişim bize tüm sütunları yazı gibi 
    vermektedir. Kayıtlar elde edildikten sonra mysql_store_result ile elde edilen alan mysql_free_result fonksiyonu ile 
    boşaltılmalıdır. Fonksiyonun parametrik yapısı şöyledir:

    void mysql_free_result(MYSQL_RES *result);

    Örneğin:

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0)
        exit_err("mysql_query", db);

    if ((res = mysql_store_result(db)) == NULL)
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL)
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);

    Burada önce SELECT cümlesi server'a gönderilmiş, sonra mysql_store_result fonksiyonu ile sonuçlar alınıp satırlar da 
    mysql_fetch_row çağrıları ile tek tek elde edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;
    MYSQL_RES *res;
    MYSQL_ROW row;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode) != 0)
        exit_err("mysql_options failed", db);

    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0)
        exit_err("mysql_query", db);

    if ((res = mysql_store_result(db)) == NULL)
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL)
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);
    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                205. Ders 23/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu son bölümde işletim sistemlerindeki GUI (Graphical User Interface) çalışma modeli hakkında temel bilgiler vereceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilgisayar ekranları temel olarak iki modda çalışmaktadır:

    1) Text Mod
    2) Grafik Mod

    Eskiden text mod çalışma çok yaygındı. Çünkü grafik kartları henüz gelişkin değildi. Ancak son 20 senedir grafik mod çalışma 
    baskın hale gelmiştir.

    Text modda ekrana basılabilecek en küçük birim bir karakterdir. Bu karakterler kalıp olarak ekrana basılmaktadır. Dolayısıyla 
    text modda çalışma çok hızlıdır. Ancak text modda resimler görüntülenemez, filmler izlenemez.

    Grafik modda ekranda görüntülenebilen en küçük görsel öğeye "pixel" denilmektedir. Pixel bir noktadır. İşte grafik modda 
    ekrandaki tüm görsel öğeler bu pixel'lerin bir araya getirilmesiyle oluşmaktadır. Her pixel'in rengi diğerlerinden bağımsız 
    bir biçimde ayarlanabilmektedir. Bugünkü grafik kartlarında ve monitörlerde her pixel "kırmızı (red)", "yeşil (green)" ve 
    "mavinin (blue)" birer byte'lık tonal bileşimleriyle oluşturulmaktadır. Bir byte 8 bit olduğu için bir pixel 2^8 * 2^8 * 2^8 
    = 2^24 ≃ 16 milyon renkten herhangi biriyle renklendirilebilmektedir. Aslında grafik modda tüm resimler ve yazılar bu 
    pixel'lerin bir araya getirilmesiyle oluşturulmaktadır. Ekranı bir pixel matrisi olarak düşünebilirsiniz. Örneğin 1920x1080 
    HD çözünürlükte matriste 1920 sütun 1080 tane de satır bulunmaktadır. Yani ekranda toplam 2 milyon civarı pixel bulunur.

    Aynı monitörde çözünürlüğü yükseltirsek pixel'ler küçülür, resimler ve yazılar ekranda daha küçük görünür hale gelir, ancak 
    ekrana daha fazla içerik sığar. Eğer çözünürlük düşürülürse bu kez pixel'ler büyür, yazılar ve resimler büyük gözükür. 
    Peki çözünürlük sabit bırakılıp ekran büyütülürse ne olur? Yine pixel'ler büyüyecektir. Bu durumda çözünürlük yükseltildikçe 
    her şey küçüleceği için monitörün büyütülmesi uygun olur. Monitör büyüklüğü ile pixel yoğunluğu arasındaki ilişki "DPI (Dot 
    Per Inch)" bir terimle ifade edilmektedir. DPI bir inch'teki pixel sayısıdır. Çözünürlük aynı kalıp monitör büyütülürse DPI 
    düşer, çözünürlük aynı kalıp monitör küçültülürse DPI yükselir. Benzer biçimde monitör aynı kalıp çözünürlüğü düşürürsek 
    DPI düşecek, monitör aynı kalıp çözünürlüğü yükseltirsek DPI artacaktır. Belli bir DPI değerinden sonra artık çözünürlüğü 
    artırmanın da bir anlamı kalmamaktadır. Çünkü insan gözündeki algılayıcı kısım olan retinanın da bir çözünürlüğü vardır.

    Ekrandaki görüntü aslında grafik kartları (GPU) tarafından oluşturulmaktadır. Görüntüyü ekran kartları oluşturur, onu belli 
    periyotta monitöre yollar, monitör de pixel'leri görüntüler. Yani monitör pasif bir aygıttır. Asıl işi yapan kısım grafik 
    kartlarıdır.

    Ekranın bir bölümü text modda bir bölümü grafik modda olmaz. Bugün GUI arayüzlü işletim sistemlerinde konsol pencerelerini 
    açtığımızda o pencereler text modda çalışmamaktadır. Konsol pencereleri grafik modda text modu pixel'lerle simüle etmektedir. 
    Text mod çalışma çok yaygın ve pratik olduğu için bugün yine yoğun bir biçimde kullanılmaktadır.

    Ekran koordinat sisteminde genellikle ekranın sol üst köşesi orijin noktasıdır. X ekseni sağa doğru, Y ekseni aşağıda 
    doğru ilerlemektedir. Ekran koordinat sisteminde her pixel'in bir koordinatı vardır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                206. Ders 11/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peki mademki GUI çalışma çok zengin olanaklar sunuyor, peki neden o zaman hala konsol uygulamaları kullanılıyor? 
    İşte GUI programların yazılması oldukça zordur. GUI programların yazılmasını kolaylaştırmak için pek çok yüksek seviyeli 
    kütüphaneler oluşturulmuştur. Oysa text modda klasik konsol çalışma modeli oldukça basittir. Bazı sistemler ise hiç GUI 
    arayüzüne sahip olmayabilmektedir. Örneğin UNIX/Linux sistemlerinde hala klasik konsol çalışma modeli çok yaygın biçimde 
    kullanılmaktadır. (UNIX/Linux sistemleri özellikle sunucularda kullanıldığı için ve sunucuların grafik arayüze sahip olması 
    onların hızını ve kaynak kullanımını yavaşlatacağı için bu sistemlerde klasik konsol çalışma modeli hala en yaygın modeldir.)

    GUI çalışma modeli ile klasik konsol çalışma modelini karşılaştırırsak şunları söyleyebiliriz:

    - GUI çalışma modelinin uygulanması için bilgisayar sisteminin bazı gelişmiş özelliklere sahip olması gerekir. Halbuki 
    konsol çalışma modeli DOS gibi basit işletim sistemlerinde ve onların çalıştığı eski donanımlarda bile oldukça verimli
    bir biçimde uygulanabiliyordu.

    - GUI çalışma modelini kullanarak program yazmak oldukça zordur. Programcılar işlerini kolaylaştırmak için yüksek seviyeli
    GUI kütüphanelere gereksinim duyarlar. Bu da ek bir çalışma ve eğitim gerektirmektedir.

    - GUI çalışma modeli konsol çalışma modeline göre yavaştır ve çok daha fazla sistem kaynağına gereksinim duymaktadır.

    - GUI çalışma modeli modern grafiksel bir girdi ve çıktı ortamı sunmaktadır. Halbuki konsol çalışma ortamında her şey
    karakterlerin kalıp olarak konsol ekranına basılmasıyla oluşturulmaktadır. Yani GUI çalışma modeli albenili ve zengin 
    bir arayüz sunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows’un çekirdek (kernel) ile entegre edilmiş bir GUI alt sistemi vardır. Başka bir deyişle Windows’ta pencereli 
    çalışma başka bir katman tarafından değil, doğrudan işletim sisteminin çekirdeği tarafından sağlanmaktadır. Windows’u 
    GUI alt sistemi olmadan kullanmak mümkün olsa da uygulamada çok zordur. Windows'ta GUI arayüz olmadan çalışmak anlamlı 
    değildir.

    UNIX/Linux sistemlerinde grafik arayüz çekirdeğin üzerine oturtulan ve ismine X11 (ya da XWindow) denilen bir alt sistem 
    tarafından sağlanmaktadır. Yani örneğin Linux’un çekirdeğinin kaynak kodlarında pencere kavramına ilişkin hiçbir şey yoktur. 
    Ancak Windows’ta vardır. Zaten Linux sistemlerinde doğal çalışma grafik arayüz ile değil, text ekrandaki konsol arayüzü 
    ile sağlanmaktadır. Server olarak kullanılan Linux sistemlerinde de genellikle sistemi yavaşlattığı gerekçesiyle grafik 
    arayüz kullanılmamaktadır. Son yıllarda UNIX/Linux dünyasında klasik X11 GUI alt sistemine bir alternatif olarak "Wayland" 
    isimli yeni bir alt sistem de tasarlanmıştır. Wayland alt sistemi X11'e göre daha modern ve hızlı bir tasarıma sahip olmakla 
    birlikte henüz yaygınlaşmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    X11 grafik sistemi client-server tarzda çalışmaktadır. Yani sanki X11 bir server program gibidir, pencere açmak ve pencereler 
    üzerinde işlemler yapmak isteyen programlar da client programlar gibidir. X11 sisteminde işlem yapabilmek için oluşturulmuş 
    temel kütüphaneye Xlib denilmektedir. Xlib'i X11’in API kütüphanesi olarak düşünebiliriz. Son yıllarda Xlib’in XCB isimli 
    daha modern bir versiyonu da oluşturulmuştur. Xlib ve XCB temelde C Programlama Dili'nden kullanılmak için tasarlanmıştır. 
    Ancak bu kütüphaneler başka dillerden de kullanılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Grafik arayüze sahip pencereli sistemlerde genel olarak "mesaj tabanlı (message driven)" ya da "olay tabanlı (event driven)" 
    denilen çalışma modeli kullanılmaktadır. Mesaj tabanlı çalışma modelinin ayrıntıları sistemden sisteme değişebilmekle birlikte 
    burada biz her sistemde geçerli olan bazı temel bilgileri vermekle yetineceğiz.

    Mesaj tabanlı programlama modelinde klavye ve fare gibi aygıtlarda oluşan girdileri programcı kendisi almaya çalışmaz. 
    klavye gibi, fare gibi girdi aygıtlarını işletim sisteminin (ya da GUI alt sisteminin) kendisi izler. Oluşan girdi olayı 
    hangi pencereye ilişkinse işletim sistemi ya da GUI alt sistem, bu girdi olayını “mesaj” adı altında bir yapıya dönüştürerek 
    o pencerenin ilişkin olduğu (yani o pencereyi yaratan) programın “mesaj kuyruğu (message queue)” denilen bir kuyruk sistemine 
    yerleştirir. Mesaj kuyruğu içerisinde mesajların bulunduğu FIFO prensibiyle çalışan bir kuyruk veri yapısıdır. Sistemin daha 
    iyi anlaşılması için süreci maddeler halinde özetlemek istiyoruz:

    1) Her programın (thread'li sistemlerde her thread’in) “mesaj kuyruğu” denilen bir kuyruk veri yapısı vardır. Mesaj kuyruğu 
    mesajlardan oluşmaktadır.

    2) İşletim sistemi ya da GUI alt sistem gerçekleşen girdi olaylarını “mesaj (message)” adı altında bir yapı biçimine dönüşürmekte 
    ve bunu pencerenin ilişkin olduğu programın (ya da thread’in) mesaj kuyruğuna eklemektedir.

    3) Mesajlar ilgili olayı betimleyen ve ona ilişkin bazı bilgileri barındıran yapı (structure) nesneleridir. Örneğin Windows’ta 
    mesajlar MSG isimli bir yapıyla temsil edilmişleridir. Bu yapının elemanlarında mesajın ne mesajı olduğu (yani neden gönderildiği) 
    ve mesajın gönderilmesine neden olan olaya ilişkin bazı parametrik bilgiler bulunur.

    Görüldüğü gibi GUI programlama modelinde girdileri programcı elde etmeye çalışmamaktadır. Girdileri bizzat işletim sisteminin 
    kendisi ya da GUI alt sistemi elde edip programcıya mesaj adı altında iletmektedir.

    GUI programlama modelinde işletim sisteminin (ya da GUI alt sisteminin) oluşan mesajı ilgili programın (ya da thread’in) mesaj 
    kuyruğuna eklemenin dışında başka bir sorumluluğu yoktur. Mesajların kuyruktan alınarak işlenmesi ilgili programın sorumluluğundadır. 
    Böylece GUI programcısının mesaj kuyruğuna bakarak sıradaki mesajı alması ve ne olmuşsa ona uygun işlemleri yapması gerekir. Bu 
    modelde programcı kodunu şöyle düzenler: "Bir döngü içerisinde sıradaki mesajı kuyruktan al, onun neden gönderildiğini belirle, 
    uygun işlemleri yap, kuyrukta mesaj yoksa da blokede bekle”. İşte GUI programlarındaki mesaj kuyruğundan mesajı alıp işleyen döngüye 
    mesaj döngüsü (message loop) denilmektedir.

    Bir GUI programının işleyişini tipik akışı aşağıdaki gibi bir kodla temsil edebiliriz:

    int main(void)
    {
        <programın ana penceresini yarat>

        for (;;) {
            <mesaj kuyruğundan sıradaki mesajı al>
            <mesajın ne mesajı olduğunu anla ve gerekeni yap>
            if (mesaj pencerenin x tuşuna basma mesajı mı)
                break;
        }

        return 0;
    }

    Bu temsili koddan da görüldüğü gibi tipik bir GUI programında programcı bir döngü içerisinde mesaj kuyruğundan sıradaki 
    mesajı alır ve onu işler. Mesajın işlenmesi ise “ne olmuş ve ben buna karşı ne yapmalıyım?” biçiminde oluşturulmuş olan 
    kodlarla yapılmaktadır.

    Peki bir GUI programı nasıl sonlanmaktadır? İşte pencerenin sağındaki (bazı sistemlerde solundaki) X simgesine kullanıcı 
    tıkladığında işletim sistemi ya da GUI alt sistem bunu da bir mesaj olarak o pencerenin ilişkin olduğu prosesin (ya da 
    thread’in) mesaj kuyruğuna bırakır. Programcı da kuyruktan bu mesajı alarak mesaj döngüsünden çıkar ve program sonlanır.

    GUI ortamımız (framework) ister .NET, ister Java, ister MFC, isterse Qt olsun, işletim sisteminin ya da GUI alt sisteminin 
    çalışması hep burada ele açıklandığı gibidir. Yani örneğin biz .NET'te ya da Java'da işlemlerin sanki başka biçimlerde 
    yapıldığını sanabiliriz. Aslında işlemler bu ortamlar tarafından aşağı seviyede yine burada anlatıldığı gibi yapılmaktadır. 
    Bu ortamlar (frameworks) ya da kütüphaneler çeşitli yükleri üzerimizden alarak bize daha rahat bir çalışma modeli sunarlar. 
    Ayrıca şunu da belirtmek istiyoruz: GUI programlama modeli özellikle nesne yönelimli programlama modeline çok uygun düşmektedir. 
    Bu nedenle bu konuda kullanılan kütüphanelerin büyük bölümü sınıflar biçiminde nesne yönelimli diller için oluşturulmuş 
    durumdadır. Örneğin Qt Framework C++ ile, .NET Forms ve WPF Framework'leri C# ile (ya da diğer nesne yönelimli .NET dilleri 
    ile) kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi GUI programlama modelindeki mesaj kavramını biraz daha açalım. Yukarıda da belirttiğimiz gibi bu modelde programcıyı 
    ilgilendiren çeşitli olaylara “mesaj” denilmektedir. Örneğin klavyeden bir tuşa basılması, pencere üzerinde fare ile 
    tıklanması, pencere içerisinde farenin hareket ettirilmesi gibi olaylar hep birer mesaj oluşturmaktadır. İşletim sistemleri 
    ya da GUI alt sistemleri mesajları birbirinden ayırmak için onlara birer numara karşılık getirirler. Örneğin Windows’ta 
    mesaj numaraları WM_XXX biçiminde sembolik sabitlerle kodlanmıştır. Programcılar da konuşurken ya da kod yazarken mesaj 
    numaralarını değil, bu sembolik sabitleri kullanırlar. (Örneğin WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_KEYDOWN gibi) Mesajların 
    numaraları yalnızca gerçekleşen olayın türünü belirtmektedir. Oysa bazı olaylarda gerçekleşen olaya ilişkin bazı bilgiler 
    de söz konusudur. İşte bir mesaja ilişkin o mesaja özgü bazı parametrik bilgiler de işletim sistemi ya da GUI alt sistemi 
    tarafından mesajın bir parçası olarak mesajın içerisine kodlanmaktadır. Örneğin Windows’ta biz klavyeden bir tuşa bastığımızda 
    Windows WM_KEYDOWN isimli mesajı programın mesaj kuyruğuna bırakır. Bu mesajı kuyruktan alan programcı mesaj numarasına 
    bakarak klavyenin bir tuşuna basılmış olduğunu anlar. Fakat hangi tuşa basılmıştır? İşte Windows basılan tuşun bilgisini 
    de ayrıca bu mesajın içerisine kodlamaktadır. Örneğin WM_LBUTTONDOWN mesajını Windows farenin sol tuşuna tıklandığında 
    kuyruğa bırakır. Ancak ayrıca basım koordinatını da mesaja ekler. Yani bir mesaj oluştuğunda yalnızca o mesajın hangi tür 
    bir olay yüzünden oluştuğu bilgisini değil, aynı zamanda o olayla ilgili bazı bilgileri de kuyruktaki mesajın içerisinden 
    alabilmekteyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                207. Ders 18/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows'ta GUI programları en aşağı seviyede Windows API fonksiyonları kullanılarak yazılmaktadır. Ekrana boş bir pencere
    çıkartan iskelet bir GUI programı aşağıdaki gibi yazılabilir:

    #include <windows.h>

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

    int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
    {
        WNDCLASS wndClass;
        HWND hWnd;
        MSG message;

        if (!hPrevInstance) {
            wndClass.style = CS_HREDRAW | CS_VREDRAW;
            wndClass.cbClsExtra = 0;
            wndClass.cbWndExtra = 0;
            wndClass.hInstance = hInstance;
            wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
            wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
            wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
            wndClass.lpszMenuName = NULL;
            wndClass.lpszClassName = "Generic";
            wndClass.lpfnWndProc = (WNDPROC)WndProc;
            if (!RegisterClass(&wndClass))
                return -1;
        }
        hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
        if (!hWnd)
            return -1;
        ShowWindow(hWnd, SW_RESTORE);
        UpdateWindow(hWnd);
        while (GetMessage(&message, 0, 0, 0)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }
        return message.wParam;
    }

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows sistemlerinde iskelet GUI programında şunların sırasıyla yapılması gerekmektedir:

    1) Önce WNDCLASS türünden bir yapı nesnesi tanımlanıp bunun içi doldurulur ve bu yapı RegisterClass APIO fonksiyonu ile
    sisteme register ettirilir. Bu WNDCKASS belirlemelerine "pencere sınıfı" denilmektedir. Örneğin:

    WNDCLASS wndClass;

    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }

    2) Programın ana penceresi pencere sınıfı kullanılarak yaratılır:

    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, 
                CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;

    Ana pencere yaratıldıktan sonra pencerenin görünür hale getirilmesi gerekmektedir:

    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);

    3) Artık program mesaj döngüsüne girmelidir. Mesaj döngüsü kuyruktan sıradaki mesajı alıp bunu işleyen döngüdür. Mesaj
    döngüsü şöyle oluşturulmaktadır:

    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }

    Burada GetMessage API fonksiyonu mesaj kuyruğundan mesajı alır. TranslateMessage klavye mesajları için bazı dönüştürmeleri 
    yapmaktadır. Mesajın işlenmesine yol açan fonksiyon DispatchMessage isimli API fonksiyonudur. Ancak DispatchMessage aslında
    pencere sınıfında belirtilen fonksiyonun çağrılmasına yol açmaktadır. Örneğimizde bu fonksiyon WndProc ismindedir. Yani
    DispatchMessage yapıldığında aslında WndProc fonksiyonu çağrılmaktadır. Buna "pencere fonksiyonu" denir. Programcı mesajı
    bu fonksiyon içerisinde işler. WndProc fonksiyonu şöyle yazılmıştır:

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
            case WM_DESTROY:
                PostQuitMessage(0);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows'ta kuyruğa bırakılan bazı mesajların mutlaka işlenmesi gerekir. Bu işlem de çok sıkıcı olduğu için DefWindowProc
    isimli bir fonksiyon bulundurulmuştur. Programcı tarafından işlenmeyen mesajlar DefWindowProc fonksiyonuna verilir. Bu 
    fonksiyon mesaj için gereken bazı default işlemler varsa onu yapar. Programın sonlanması pencerenin X simgesine tıklanarak 
    yapılır. Bu durumda Windows kuyruğa WM_CLOSE isimli mesajı bırakır. DefWindowProc bu mesaj için DestroyWindow fonksiyonunu
    çağırır. Bu fonksiyon da WM_DESTROY mesajını oluşturur. Bu mesajda programcı PostQuitMessage API fonksiyonunu çağırır. 
    Bu API fonksiyonu da kuyruğa WM_QUIT mesajını bırakır. WM_QUIT mesajını alan GetMessage fonksiyonu 0 ile geri döner. 
    Böylece döngü sonlanır ve program da biter.
---------------------------------------------------------------------------------------------------------------------------*/

#include <windows.h>

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
{
    WNDCLASS wndClass;
    HWND hWnd;
    MSG message;

    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }
    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
        CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;
    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);
    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }
    return message.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:
        MessageBox(hWnd, u8"Farenin sol tuşuna basıldı", "Mesaj", MB_OK);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi UNIX/Linux sistemlerinde XWindow ya da X11 denilen bir katman kullanılmaktadır. Bu 
    katmanın API fonksiyonlarına Xlib ya da bunun modern biçimine XCB denilmektedir. Xlib ya da XCB çok aşağı seviyeli bir 
    kütüphanedir. Bu kütüphane kullanılarak GUI elemanlarını oluşturan X-Toolkit ya da kısaca Xt isimli ayrı bir kütüphane 
    vardır. Bu Xt üzerine kurulan Motif gibi başka kütüphaneler de vardır. Ayrıca Xlib ya da XCB üzerine kurulmuş olan iki 
    önemli kütüphane de Qt ve GTK (GTK+ da denilmektedir) kütüphanelerdir. Qt kütüphanesi C++ ile yazılmıştır, dolayısıyla 
    Qt için kodlar da C++ ile yazılmaktadır. GTK ise C'de yazılmıştır.

                          +----------------------------+
                          |      GUI Uygulamaları      |
                          +----------------------------+
                           /            |          \
                          /             |           \
                         /              |            \
                   +-------+        +--------+     +---------+
                   |  GTK  |        |   Qt   |     |  Motif  |
                   +-------+        +--------+     +---------+
                       |                |               |
            +----------+-----+      +--+--+--+      +---+--+
            | Xlib / Wayland |      |Xlib/XCB|      |  Xt  |
            +----------+-----+      +--+--+--+      +---+--+
                       |                |               |
                       |                |           +--+--+--+
                       |                |           |Xlib/XCB|
                       |                |           +--+--+--+
                       |                |               |
         +-------------+----------------+---+-----------+-----------------+
         |      X Window System (X11)       |     Wayland (alternatif)    |
         +----------------------------------+-----------------------------+
         |                  Donanım / OS (Çekirdek, GPU)                  |
         +----------------------------------------------------------------+

    Şimdi de bu kütüphanelerin hiyerarşisini tek tek gösterelim. GTK kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |        GTK         |
    +--------------------+
    |   Xlib / Wayland   |
    +--------------------+
    | X Window / Wayland |
    +--------------------+

    Xt kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |         Xt         |
    +--------------------+
    |        Xlib        |
    +--------------------+
    |      X Window      |
    +--------------------+

    Motif kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |       Motif        |
    +--------------------+
    |         Xt         |
    +--------------------+
    |        Xlib        |
    +--------------------+
    |      X Window      |
    +--------------------+

    Qt kütüphanesini de şöyle gösterebiliriz:

    +--------------------+
    |         Qt         |
    +--------------------+
    |   Xlib / Wayland   |
    +--------------------+
    | X Window / Wayland |
    +--------------------+

    Bugün artık Xt ve Motif yeni uygulamalar tarafından pek kullanılmamaktadır. Bu nedenle yüksek seviyeli kütüphaneler için
    önemli iki alternatif GTK ve Qt kütüphaneleridir. GTK kütüphanesi C ile kullanılabilir. Ancak Qt için C++ bilmek gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Xlib ya da XCB kütüphaneleri oldukça düşük seviyeli kütüphanelerdir. Bunlar aslında X Window sistemlerinin aşağı seviyeli
    API kütüphanesi gibi düşünülebilir. Xlib ile GUI uygulamaları yazmak çok zordur. Çünkü Xlib içerisinde pencere yaratan 
    öğeler olsa da GUI uygulamalarında kullanılan düğmeler (push buttons), listeleme kutuları (listbox), checkbox gibi 
    grafik elemanlar bulunmamaktadır. Eğer C kullanılarak bu GUI elemanlar ile gelişmiş GUI programlar oluşturmak istiyorsanız
    GTK kütüphanesini kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX/Linux sistemlerinde en düşük seviyede Xlib kullanan iskelet bir GUI programını yazmaya çalışalım. Bu program 
    ekrana boş bir pencere çıkartacaktır. Bunun öncelikle Xlib kütüphanesinin kurulması gerekmektedir. Bu işlem Debian tabanlı
    sistemlerde şöyle yapılabilir:

    $ sudo apt-get install libx11-dev

    Derleme işlemi sırasında X11 kütüphanesinin "-lX11" seçeneği ile belirtilmesi gerekmektedir. Örneğin:

    $ gcc -o generic-xlib generic-xlib.c -lX11

    Ekrana boş bir pencere çıkartan iskelet GUI programı şöyle yazılabilir:

    /* generic-xlib.c */

    #include <X11/Xlib.h>
    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        Display *disp;
        Window w;
        XEvent e;
        int scr;

        disp = XOpenDisplay(NULL);
        if (disp == NULL) {
            fprintf(stderr, "Cannot open display\n");
            exit(1);
        }

        scr = DefaultScreen(disp);
        w = XCreateSimpleWindow(disp, RootWindow(disp, scr), 10, 10, 100, 100, 1,
                BlackPixel(disp, scr), WhitePixel(disp, scr));
        XSelectInput(disp, w, ExposureMask | KeyPressMask);
        XMapWindow(disp, w);

        for (;;) {
            XNextEvent(disp, &e);
            if (e.type == KeyPress)
                break;
        }

        XCloseDisplay(disp);

        return 0;
    }

    Burada sırasıyla şu işlemler yapılmıştır:

    1) XOpenDisplay fonksiyonu XWindow sunucusu ile bağlantı kurmak için kullanılmaktadır. Bu fonksiyon başarı durumunda bize 
    Display türünden bir handle verir.

    2) Daha sonra biz bu handle’ı vererek bir ekran (screen) nesnesi yaratmamız gerekir. Bu işlem de DefaultScreen fonksiyonuyla 
    yapılmaktadır. Bu fonksiyon bize ilgili ekranı betimleyen int türden bir değer vermektedir.

    3) Örnek programımızda daha sonra uygulamanın ana penceresi XCreateSimpleWindow fonksiyonuyla yaratılmıştır. Bu fonksiyon 
    bize Window * türünden yaratılan pencereye ilişkin bir handle değeri vermektedir.

    4) Programda daha sonra mesaj döngüsüne girmeden önce hangi girdi olaylarının izleneceğini belirlemek için XSelectInput 
    fonksiyonu çağrılmıştır.

    5) Mesaj döngüsünden sıradaki mesaj XNextEvent fonksiyonuyla elde edilmektedir. (Bu fonksiyonu Windows'ta GetMessage API 
    fonksiyonuna benzetebilirsiniz. Bu fonksiyon bize kuyruktaki mesajı XEvent isimli bir yapı olarak verir. Örnek programımızda 
    bir tuşa basıldığında mesaj döngüsünden çıkılmaktadır.

    6) Mesaj döngüsünden çıkıldığında XCloseDisplay fonksiyonu ile daha önce alınmış olan ekran geri bırakılmıştır. Tabii 
    ekran yok edildiğinde tüm pencereler de yok edilecektir. Ayrıca program sonlandığında X11 sistemi ile bağlantı da otomatik 
    koparılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    GTK pek çok ayrıntıya sahip olan C tabanlı bir GUI kütüphanesidir. GTK kütüphanesinin son versiyonu GTK 4'tür. Bu versiyon 
    2020'de oluşturulmuştur. Ancak önceki versiyon olan GTK 3 halen daha yoğun olarak kullanılmaktadır. GTK 3 Debian tabanlı 
    sistemlerde şöyle kurulabilir:

    $ sudo apt-get install libgtk-3-dev

    GTK 4 ise şöyle kurulabilir:

    $ sudo apt-get install libgtk-4-dev

    GTK 3 ile GTK 4 birbirine çok benzemekle birlikte tam uyumlu değildir.

    Biz burada GTK 4 için bazı küçük örnekler vereceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Ekrana boş bir pencere çıkartan iskelet GTK 4 programı şöyle oluşturulabilir:

    #include <gtk/gtk.h>

    void activate(GtkApplication *app, gpointer user_data)
    {
        GtkWidget *window;

        // Yeni pencere oluştur
        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    int main(int argc, char **argv)
    {
        GtkApplication *app;
        int status;

        // Uygulama nesnesini oluştur
        app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);
        g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

        // Uygulamayı çalıştır
        status = g_application_run(G_APPLICATION(app), argc, argv);

        // Hafızayı temizle
        g_object_unref(app);

        return status;
    }

    Bu program şöyle derlenebilir:

    $ gcc -o generic-gtk generic-gtk.c $(pkg-config --cflags --libs gtk4)

    Burada $(pkg-config --cflags --libs gtk4) ifadesi pkg-config programının çıktısının komut satırına yerleştirilmesini 
    sağlamaktadır. GTK 4 programlarının derlenmesi için komut satırında çeşitli include dizinlerine ilişkin seçeneklerin ve 
    birden fazla dinamik kütüphanenin devreye sokulması gerekmektedir. Bu $(pkg-config --cflags --libs gtk4) ifadesi aslında
    gereken komut satırı argümanlarını oluşturmaktadır.

    Yukarıdaki iskelet programın açıklamasını şöyle yapabiliriz:

    1) Bir GTK 4 uygulamasında önce bir GtkApplication nesnesinin oluşturulması gerekir. GtkApplication yapısı uygulama ile
    ilgili çeşitli bilgileri tutmaktadır. Bu işlem iskelet programda şöyle yapılmıştır:

    app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);

    2) İskelet programda daha sonra uygulama çalıştırıldığında oluşan "activate" mesajı için activate isimli fonksiyonun 
    çağrılması sağlanmıştır. GTK'da mesaj yerine "sinyal (signal)" sözcüğü kullanılmaktadır:

    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    Bu sinyal bağlantısından sonra artık activate isimli fonksiyon çağrılacaktır. Bizim bu fonksiyon içerisinde programın 
    ana penceresini yaratmamız gerekir.

    3) activate fonksiyonu şöyle yazılmıştır:

    void activate(GtkApplication *app, gpointer user_data)
    {
        GtkWidget *window;

        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    Uygulamanın ana penceresi gtk_application_window_new fonksiyonu ile yaratılmaktadır. Ana pencere diğer pencereler gibi 
    GtkWidget yapısı ile temsil edilmektedir. gtk_window_set_title fonksiyonu yaratılan pencerenin başlık kısmına (caption)
    çıkacak yazının set edilmesini sağlamaktadır. Ana pencerenin default genişlik ve yüksekliği gtk_window_set_default_size
    fonksiyonuyla oluşturulmaktadır. Bu işlemlerden sonra iskelet programda gtk_window_present fonksiyonu ile ana pencere 
    görünür hale getirilmiştir.

    4) Ana pencere yaratıldıktan sonra artık mesaj döngüsü oluşturulmalıdır. GTK 4'te mesaj döngüsü manuel oluşturulmaz. 
    Mesaj döngüsü g_application_run fonksiyonu ile oluşturulmaktadır:

    status = g_application_run(G_APPLICATION(app), argc, argv);

    Program hayatını bu fonksiyon içerisinde oluşturulan mesaj döngüsünde geçirmektedir.

    5) Mesaj döngüsünden yine pencerenin X tuşuna basıldığında çıkılır. İskelet programımızda mesaj döngüsünden çıkıldığında 
    heap'te tahsis edilen çeşitli nesnelerin yok edilmesi için g_object_unref fonksiyonu çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                208. Ders 20/04/2025 - Pazar -Son-
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    GTK içerisinde pek çok GUI eleman hazır biçimde bulunmaktadır. Bu GUI elemanların yaratılması için fonksiyonlar vardır. 
    Sinyal mekanizması yoluyla bu GUI elemanlarda birtakım olaylar gerçekleştiğinde bizim belirlediğimiz fonksiyonun çağrılması 
    sağlanabilmektedir. Örneğin:

    button_ok = gtk_button_new_with_label("Ok");
    gtk_window_set_child(GTK_WINDOW(window), button_ok);
    g_signal_connect(button_ok, "clicked", G_CALLBACK(on_button_clicked), window);

    Burada bir düğme yaratılmıştır. Bu düğmeye tıklandığında on_button_clicked isimli fonksiyon çağrılacaktır. Aşağıdaki örnekte
    biz fonksiyon çağrıldığında bir diyalog penceresinin çıkmasını sağladık:

    void on_button_clicked(GtkButton *button, gpointer user_data)
    {
        GtkWindow *parent_window = GTK_WINDOW(user_data);

        GtkWidget *dialog = gtk_message_dialog_new(
            parent_window,
            GTK_DIALOG_MODAL,
            GTK_MESSAGE_INFO,
            GTK_BUTTONS_OK,
            "Düğmeye tıkladınız!"
        );

        g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
        gtk_window_present(GTK_WINDOW(dialog));
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <gtk/gtk.h>

void on_button_clicked(GtkButton *button, gpointer user_data)
{
    GtkWindow *parent_window = GTK_WINDOW(user_data);

    GtkWidget *dialog = gtk_message_dialog_new(
        parent_window,
        GTK_DIALOG_MODAL,
        GTK_MESSAGE_INFO,
        GTK_BUTTONS_OK,
        "Düğmeye tıkladınız!"
    );

    g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
    gtk_window_present(GTK_WINDOW(dialog));
}

void activate(GtkApplication *app, gpointer user_data)
{
    GtkWidget *window;
    GtkWidget *button_ok;
    GtkWidget *box;

    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
    gtk_window_set_default_size(GTK_WINDOW(window), 320, 200);

    button_ok = gtk_button_new_with_label("Ok");
    gtk_window_set_child(GTK_WINDOW(window), button_ok);
    g_signal_connect(button_ok, "clicked", G_CALLBACK(on_button_clicked), window);

    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char **argv)
{
    GtkApplication *app;
    int status;

    app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    status = g_application_run(G_APPLICATION(app), argc, argv);

    g_object_unref(app);

    return status;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün çeşitli programalama dillerinden kullanılabilen pek çok GUI kütüphanesi ve GUI ortamları (GUI Frameworks) bulunmaktadır. 
    GUI kütüphaneleri ve GUI ortamları zamanla evrim geçirerek bugünkü durumlarına gelmiştir. Günümüzde GUI ortamlarında 
    iki önemli tasarım seçeneği belirginleşmiştir:

    1) GUI elemanları için otomatik yerleştirme yapan nesnelerin kullanılması.
    2) GUI arayüzünü mümkün olduğunca koddan ayırma girişimleri.

    Eskiden kullanıcı arayüzlerindeki düğme, edit alanları, listeleme kutuları gibi GUI elemanları tek tek pixel temelinde 
    programcı tarafından konumlandırılıyordu. Bu da ekran çözünürlüğü değiştiğinde görünümün bozulmasına yol açıyordu. Ancak 
    son yıllarda artık GUI ortamlarında otomatik yerleştirme yapan nesneler bulundurulmaya başlanmıştır. Bu otomatik "yerleştirme 
    nesneleri (layout objects)" çözünürlük değişse bile yerleştirmeyi makul olarak kendisi yapmaktadır.

    Bir uygulamada GUI arayüzünün diğer kodlardan ayrılması uygulamanın "önyüz (front-end)" ve "arkayüz (back-end)" kodlamasının 
    farklı ekipler tarafından yapılabilmesine olanak sağlamaktadır. Son yıllarda artık GUI ortamları görsel arayüzle diğer 
    kodları birbirinden ayırabilmek için mekanizmalar sunmaktadır. Böylece görsel arayüz XML ya da ona benzer bir dille 
    bir text editörle oluşturulabilmekte ve uygulamaya kolayca dahil edilebilmektedir. Örneğin GTK 3'te bu olanak daha sınırlıydı. 
    GTK 4'te bu olanak güçlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda GTK 4 ile oluşturulmuş bir grid yerleştirme (layout) nesnesinin kullanımı verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <gtk/gtk.h>

// Düğmeye basıldığında çalışacak fonksiyon
static void on_button_clicked(GtkButton *button, gpointer user_data) {
    GtkEntry *entry = GTK_ENTRY(user_data);
    const char *text = gtk_entry_buffer_get_text(gtk_entry_get_buffer(entry));

    // Ana pencereyi entry'den al (up-cast)
    GtkWindow *parent_window = GTK_WINDOW(gtk_widget_get_root(GTK_WIDGET(entry)));

    GtkWidget *dialog = gtk_message_dialog_new(
        parent_window,
        GTK_DIALOG_MODAL,
        GTK_MESSAGE_INFO,
        GTK_BUTTONS_OK,
        "Editbox içeriği:\n%s",
        text
    );

    gtk_window_set_transient_for(GTK_WINDOW(dialog), parent_window);
    g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
    gtk_window_present(GTK_WINDOW(dialog));
}

// Uygulama başlatıldığında çağrılır
static void activate(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    GtkWidget *grid;
    GtkWidget *entry;
    GtkWidget *button;

    // Pencere oluştur
    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Editbox + Düğme");
    gtk_window_set_default_size(GTK_WINDOW(window), 400, 100);

    // Grid oluştur
    grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(grid), 10);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 10);
    gtk_window_set_child(GTK_WINDOW(window), grid);

    // Editbox
    entry = gtk_entry_new();
    gtk_widget_set_margin_start(entry, 20);
    gtk_widget_set_margin_top(entry, 20);
    gtk_grid_attach(GTK_GRID(grid), entry, 0, 0, 1, 1);    // (widget, col, row, width, height)

    // Düğme
    button = gtk_button_new_with_label("Göster");
    gtk_widget_set_margin_start(button, 20);
    gtk_widget_set_margin_top(button, 20);

    gtk_grid_attach(GTK_GRID(grid), button, 1, 0, 1, 1);

    // Sinyal bağla
    g_signal_connect(button, "clicked", G_CALLBACK(on_button_clicked), entry);

    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char **argv) {
    GtkApplication *app;
    int status;

    app = gtk_application_new("com.ornek.editdugme", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}
