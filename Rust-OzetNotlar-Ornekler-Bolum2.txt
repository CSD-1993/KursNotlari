/*---------------------------------------------------------------------------------------------------------------------------

                                                C ve Sistem Programcıları Derneği

                                    Rust Programlama Dili Kursunda Yapılan Örnekler ve Özet Notlar
    
                                                      Eğitmen: Kaan ASLAN

                                                            2. Bölüm

        Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
        Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

                Aslan, K. (2025), "Rust Programlama Dili", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                    C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                            Son Güncelleme: 09/02/2026 - Pazartesi   

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        63. Ders 10/11/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta generic'ler konusunu ele alacağız. Biz daha önce generic'ler konusunu üstünkörü ele almıştık. Ancak 
    bu bölümde sıfırdan başlayarak konuyu ayrıntılarıyla ele alacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Farklı türler için benzer işlemlerin yapılması gerektiği pek çok durum vardır. Örneğin sıralama yapan bir fonksiyon yazmak 
    isteyelim:

    fn sort_i32(a: &mut [i32]) {
        //...
    }

    Burada fonksiyon yalnızca i32 türünden bir diziyi sıraya dizebilmektedir. Eğer biz farklı türden bir diziyi sıraya dizmek 
    istiyorsak içi aynı olacak biçimde bu fonksiyondan bir tane daha yazmamız gerekir. Örneğin i64 türünden bir diziyi sıraya 
    dizmek için içi aynı olan yeni bir fonksiyon yazmamız gerekir:

    fn sort_i64(a: &mut [i64]) {
        //...
    }

    Rust'ta farklı parametrik yapılara ilişkin aynı isimli fonksiyonlar oluşturulamamaktadır. (Rust'ta "function overloading" 
    ya da "method overloading" özelliğinin olmadığını anımsayınız. Bu nedenle fonksiyonların içi aynı olsa da bunlara farklı 
    isimlerin verilmesi gerekmektedir.) Örneğin i32 türündn bir dizinin en büyük elemanı ile geri dönen aşağıdaki gibi bir 
    yazmış olalım:

    fn get_max_i32(a: &[i32]) -> i32 {
        //...
    }

    Bu fonksiyonla biz ancak i32 türünden bir dizinin en büyük elemanını bulabiliriz. Biz örneğin i64 türünden bir dizinin 
    en büyük elemanını bu fonksiyonla bulamayız. Bunun için bu fonksiyonu içi aynı olacak biçimde i64 türü için yeniden yazmamız 
    gerekir:

    fn get_max_i64(a: &[i64]) -> i64 {
        //...
    }

    Aynı problemli durum yapılar için de söz konusu olabilmektedir. Bir yapı belli türlerden bilgileri kullanacak biçimde 
    oluşturulmuş olabilir. Böyle yapıların başka türler için yniden tanımlanmaları grekir. Örneğin sabit büyüklükteki i32 türünden
    bir diziyi bir kuyruk sistemi biçiminde kullanan Queue isimli bir yapı oluşturacak olalım. Bu yapıda kuyruğa eklenecek elemanlar 
    i32 türünden olacaktır:

    struct QueueI32 {
        queue: [i32; 1024],
        head: usize,
        tail: usize 
    }

    impl QueueI32 {
        //...
    }

    Eğer biz örneğin i64 türünden elemanları tutacak bir kuyruk sistemi oluşturmak istersek bu yapıdan i64 türü için yeni bir 
    tane daha tanımlamamız gerekir:

    struct QueueI64 {
        queue: [i64; 1024],
        head: usize,
        tail: usize 
    }

    impl QueueI64 {
        //...
    }

    İşte generic'ler bir şablon tanımlaması eşliğinde aynı fonksiyonun ya da struct, enum, trait gibi türlerin otomatik 
    olarak derleyici tarafından türe uygun biçimde oluşturulmasını sağlamaktadır. Yani generic'ler içi aynı olan ancak 
    farklı türler için tekrar tekrar yazmak zorunda olduğumuz fonksiyonların ve türlerin derleyici tarafından yazılmasını 
    sağlamaktadır. Bu da hem yük oluşturan bu sıkıcı işlemleri bizim üzerimizden alır hem kodumuzun daha az karmaşık görünmesini 
    sağlar. Bu özellik C++'ta "template", Java ve C#'ta "generic" ismiyle zaten bulunmaktadır. Diğer modern pek çok dil de 
    artık bu mekanizmayı desteklemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta generic fonksiyonların ve türlerin kullanılması durumunda derleyicinin o türlere dayalı olarak o generic şablondan 
    hareketle gerçek fonksiyonları ya da türleri oluşturması sürecine "monomorfizasyon (monomorphisation)" denilmektedir. 
    (C++'ta bu sürece "template instantiation" denildiğini anımsayınız.) Monomorfizasyon derleme aşamasında derleyici tarafından 
    yapılmaktadır. Rust'ta generic türler kütüphanelerde de bulundurulabilmektedir. (C++'ta böyle bir durumun mümkün olmadığını 
    anımsayınız.) Derleyici kütüphanelere başvurarak bu generic tanımlamaları elde edip monomorfizasyon işlemini derleme 
    aşamasında yapabilmektdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta fonksiyonlar, metotlar, yapılar, enum türleri ve trait'ler generic biçimde tanımlanabilmektdir. Biz önce generic 
    fonksiyonları daha sonra da generic türleri ele alacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic fonksiyonlar ve metotlar tanımlanırken fonksiyon isminden sonra açısal parantezler içerisinde generic parametreler 
    aralarına ',' atomu yerleştirilerek bildirilmektedir. Fonksiyonun ya da metodun generic olduğu bu açısal parantezlerden 
    anlaşılmaktadır. Örneğin:

    fn foo<T, K>(x: T, y: K) {
        //...
    }

    Burada foo generic bir fonksiyondur, T ve K da generic parametrelerdir. Generic parametreler bir tür belirtmektedir. Bu 
    parametreler tür gereken her bağlamda kullanılabilmektedir. Generic parametreler genellikle T gibi K gibi V gibi tek 
    karakterlik büyük harfler kullanılarak isimlendirilmektedir. Ancak isimlendirme herhangi bir biçimde yapılabilir.  

    Generic bir fonksiyon çağrılmak istendiğinde derleyicinin generic parametrelerin gerçekte hangi türleri temsil ettiğini 
    belirlemesi gerekir. Buna Rust dünyasında "tür çıkarımı (type inference)" denilmektedir. (C++'ta buna "template argument 
    deduction" denildiğini anımsayınız.) Rust derleyicileri generic tür parametrelerinin gerçekte hangi türleri temsil ettiğini 
    iki biçimde belirlemektedir:

    1) Eğer generic türler programcı tarafından açıkça belirtilmişse derleyici tür çıkarımı yapmaya çalışmaz, programcının 
    belirlediği türleri esas alır. 

    2) Eğer generic türler programcı tarafından açıkça belirtilmediyse derleyici tür çıkarımını fonksiyonun kullanıldığı 
    bağlamı göz önüne alarak yapar.

    Eğer generic tür parametreleri açıkça belirtilmediyse ve derleyici de generic fonksiyonun kullanıldığı bağlamdan tür 
    çıkarımını yapamazsa bu durum error oluşturmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic fonksiyon çağrılırken tür parametreleri programcı tarafından fonksiyon isminden sonra :: operatörü ve bunu izleyen 
    açısal parantezlerle açıkça belirtilebilmektedir. Örneğin:

    fn foo<T, K>(x: T, y: K) {
        //...
    }

    Burada biz T türünün i32, K türünün i64 olmasını isteyelim. Bu durumda fonksiyonu şöyle çağırırız:

    foo::<i32, i64>(10, 20);

    Bu sentaksı C++'tan geçenler yadırgamaktadır. Çünkü C++'ta fonksiyon şablonlarında çağrım yapılırken tür belirlemesi 
    hemen fonksiyon isminden sonra açısal parantezler kullanılarak yapılmaktadır. Örneğin:

    foo<int, long>(10, 20);

    Halbuki Rust'ta fonksiyon isminden sonra ancak açısal parantezlerden önce :: operatörü kullanılmalıdır. 

    C++'ta ilk N tane şablon parametresi için açıkça tür belirtilip geri kalanlarının derleyici tarafından akıl yürütme 
    yoluyla belirlenmesi sağlanabilmektedir. Örneğin C++'ta foo fonksiyonun iki şablon parametresi varsa aşağıdaki gibi 
    bir çağrı yapabiliriz:

    template <typename T, typename K>
    void foo(T x, K y) 
    {
        //...
    }
    //...

    foo<int>(10, 3.14);

    Burada biz ilk şablon parametresini açıkça belirttik, ancak ikinci şablon parametresinin türünü derleyicinin belirlemesini 
    istedik. Rust'ta bu işlem C++'taki gibi yapılmamaktadır. Rust'ta belli generic parametrelerin derleyici tarafından çıkarsanması
    isteniyırsa o tür parametreleri için _ atomu kullanılmaktadır. Örneğin:

    foo::<i32, _>(10, 3.14);

    Burada biz birinci generic parametrenin türünü açıkça belirttik. Ancak ikinci generic parametrenin türünü derleyicinin 
    tespit etmesini istedik. Tabii _ atomu birden fazla generc parametre için de kullanılabilir. Bu atomun pozisyonu önemli 
    değildir. Örneğin:

    foo::<_, f64>(10, 3.14);        // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Eğer çağrım sırasında generic parametrelerin türleri programcı tarafından açıkça belirtilmemişse derleyici generic 
    parametrelerin türlerini argümanların türlerinden ve geri dönüş değerinin türünden hareketle çıkarsamaya çalışmaktadır. 
    Örneğin:

    use std::any::type_name;

    fn foo<T, K>(x: T, y: K) {
        println!("T: {}", type_name::<T>());
        println!("K: {}", type_name::<K>());
    }

    Bu örneğimizde type_name isimli generic fonksiyon generic parametrenin türünü yazı olarak elde etmek için kullanılmıştır. 
    type_name fonksiyonu üzerinde ileride duracağız. Biz burada type_name fonksiyonunu parametre çıkarımını test etme amaçlı 
    kullanacağız. Şimdi foo fonksiyonunu şöyle çağırmış olalım:

    foo(10, 3.14);

    Derleyici 10 sabiti i32 türünden, 3.14 sabiti de f64 türünden olduğu için T türünün i32, K türünün de f64 olduğunu 
    çıkarsayacaktır. Dolayısıyla fonksiyondan şöyle bir çıktı elde edilecektir:

    T: i32
    K: f64

    Eğer derleyici argümanlardan hareketle tür çıkarımı yapamazsa bu durumda çağırma ifadesinde error oluşacaktır. Örneğin:

    fn foo<T>(x: T, y: T) {
        println!("T: {}", type_name::<T>());
    }

    Burada x ve y parametre değişkenlerinin her ikisi de T türündendir. O halde çağırma sırasında iki argümanın da aynı 
    türden olması gerekir. Örneğin:

    foo(3.14, 6.28);        // geçerli

    Burada her iki argüman da f64 türünden olduğu için çağrı geçerlidir, T türü f64 olarak çıkarsanacaktır. Ancak örneğin:

    foo(10, 6.28);        // error!

    Burada T türü derleyici tarafından çıkarsanamayacağı için error oluşacaktır. Ancak örneğin:

    foo::<i64>(10, 20);     // geçerli

    Burada da bir sorun ortaya çıkmayacaktır. Çünkü 10 ve 20 sabitleri i64 türü için geçerli sabitlerdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun geri dönüş değerinde de generic parametreler kullanılabilir. Örneğin:

    fn foo<T>() -> T {
        //...
    }

    Burada artık argümandan hareketle fonksiyonun geri dönüş değerinin türü tespit edilemeyecektir. Örneğin:

    foo();

    Bu tür durumlarda programcının açıkça tür belirlemesi yapması gerekmektedir. Örneğin:

    foo::<i32>();

    Ancak Rust derleyicisi geri dönüş değerinin atandığı değişkenden hareketle de tür çıkarımını da yapabilmektedir. 
    Örneğin:

    fn foo<T: Default>() -> T {
        let a: T = T::default();
        a
    }
    //...

    let a: i32;

    a = foo();      // T türü i32 olarak çıkarsanır

    Burada foo fonksiyonunun egri dönüş değeri i32 türüne atandığı için generic T parametresi de i32 olarak çıkarsanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta generic bir fonksiyon ya da metodun içerisindeki kodların generic parametrelerin türü ne olursa olsun geçerli 
    olması gerekir. Örneğin:

    fn max(a: T, b: T) -> T {           // error!
        if a > b {
            a
        }
        else {
            b
        }
    }

    Buradaki generic max fonksiyonu derlenemeyecektir. Çünkü fonksiyonun içerisindeki kod olası her T türü için geçerli 
    değildir. Örneğin T türü i32 olsa ya da i64 olsa bu kod geçerli olurdu. Çünkü i32 ve i64 türleri > operatörüyle karşılaştırılabilmektedir. 
    Ancak örneğin bizim oluşturduğumuz Point türü > operatörüyle karşılaştırılamamaktadır. İşte bu tür durumlarda programcı 
    "tür sınırlaması (type bounding)" uygulayarak kodun her generic tür için geçerli olmasını sağlamalıdır. (Bu durum Rust'a 
    özgü değildir. C# ve Java'da da benzerdir. C++'a da "Concepts" ismiyle C++20 ile eklenmiştir.) Biz yukarıdaki generic 
    fonksiyonda eğer derleyiciye T türünün > operatörünü destekleyeceği sözünü verirsek kod artık geçerli olacaktır. Bu garanti 
    PartialOrd isimli trait ile verilmektedir:

    fn max<T: PartialOrd>(a: T, b: T) -> T {            // geçerli
        if a > b {
            a
        }
        else {
            b
        }
    }

    Burada açısal parantezler içerisinde T: PartialOrd sentaksı ile biz derleyiciye T türünün PartialOrd trait'ini destekleyeceği 
    sözünü vermiş olduk. Artık derleyici generic fonksiyonu kabul edecektir. Örneğin:

    let a = 10;
    let b = 20;
    let result: i32;

    result = max(a, b);         // geçerli
    println!("{}", result);
    
    Burada T türü i32 olarak çıkarsanacaktır. Derleyiciye verilen söz tutulmuştur. Çünkü i32 türü PartialOrd trait'ini 
    desteklemektedir dolayısıyla iki i32 değeri > operatörüyle karşılaştırılabilmektedir. Peki böyle bir söz verildiği halde 
    programcı bu sözde durulmazsa ne olur? Örneğin:

    let pt1 = Point { x: 1, y: 2 };
    let pt2 = Point { x: 3, y: 4 };
    let result: Point;

    result = max(pt1, pt2);         // error!

    Burada Point türü PartialOrd trait'ini desteklemediği için max çağrısı error ile sonuçlanacaktır. Tabii biz Point yapısının
    PartialOrd trait'ini desteklemesini sağlayabiliriz. Bu durumda max fonksiyonunu Point ile de kullanabiliriz:

    struct Point {
        x: i32,
        y: i32,
    }

    impl Point {
        fn new(x: i32, y: i32) -> Point {
            Point { x: x, y: y }
        }

        fn disp(&self) {
            println!("x: {}, y: {}", self.x, self.y);
        }
    }

    impl PartialEq for Point {
        fn eq(&self, other: &Point) -> bool {
            self.x == other.x && self.y == other.y
        }
    }

    use std::cmp::Ordering;

    impl PartialOrd for Point {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            let pt1_len = self.x * self.x + self.y * self.y;
            let pt2_len = other.x * other.x + other.y * self.y;

            if pt1_len > pt2_len {
                Some(Ordering::Greater)
            }
            else if pt1_len < pt2_len {
                Some(Ordering::Less)
            }
            else {
                Some(Ordering::Equal)
            }
        }
    }

    Biz henüz operatör metotlarını ve dolayısıyla da PartialOrd trait'ini görmedik. Ancak PartialOrd trait'i PartialEq 
    trait'inden türetilmiştir. Dolayısıyla biz yalnızca PartialOrd trait'ini değil aynı zamanda PartialEq trait'ini de 
    desteklemek zorundayız. Yukarıdaki desteğin nasıl yapıldığını bu aşamada bilmenize gerek yoktur. Burada önemli olan 
    nokta artık bizim Point yapımızın > operatörünü destekliyor olmasıdır. O halde artık biz max fonksiyonunda T türü 
    olarak Point türünü kullanırsak verdiğimiz sözde durmuş oluruz:

    let pt1 = Point::new(1, 2);
    let pt2 = Point::new(3, 4);
    let result: Point;

    result = max(pt1, pt2);         // geçerli
    result.disp();
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    O halde Rust'ta bir generic fonksiyon ya da metot yazılırken eğer kod içerisinde yaptığımız birtakım işlemler her generic 
    tür için geçerli olamıyorsa bizim tür sınırlamaları uygulayarak kodumuzu geçerli hale getirmemiz gerekir. Örneğin:

    fn foo<T>() -> T {
        T::default()            // error!
    }

    Bu kod derlenmeyecektir. Çünkü her T türünün default isminde bir ilişkili fonksiyonu olmak zorunda değildir. Ancak 
    örneğin:

    fn foo<T: Default>() -> T {
        T::default()            // geçerli
    }

    Burada artık fonksiyon geçerli hale gelmiştir. Çünkü T türünün Default trait'ini destekleyeceği sözü verilmiştir. T türü 
    Default trait'ini desteklediğine göre zaten default isimli bir ilişkili fonksiyonun bulunuyor olması gerekir. Biz burada 
    foo fonksiyonunu Default trait'ini desteklemeyen bir türle kullanamayız. Örneğin Point yapısının Default trait'ini 
    desteklemediğini varsayalım:

    let result: Point;

    result = foo::<Point>();        // error!

    Derleyici foo fonksiyonunu Point için monomorfize edemeyecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir dizinin en büyük elemanı ile geri dönen get_max isimli generic fonksiyonu yazmaya çalışalım. Fonksiyonu 
    aşağıdaki gibi yazarsak error oluşacaktır:

    fn get_max<T>(a: &[T]) -> T {           // error!
        let mut max = a[0];

        for i in 1..a.len() {
            if a[i] > max {
                max = a[i];
            }
        }
        max
    }

    Burada iki sorun vardır. Birincisi derleyiciye T türünün > operatörünü destekleyeceği biçiminde bir söz verilmemiştir. 
    Buradaki ikinci sorun eğer fonksiyona aktardığımız dizi Copy türünden değilse fonksiyonun içerisindeki kod geçersiz hale 
    gelir. Çünkü anımsayacağınız gibi Copy türünden olmayan bir dizinin elemanları taşınamaz. İşte burada T türü için derleyiciye 
    iki sözün verilmesi gerekmektedir: T türünün > operatörünü destekliyor olması sözü ve T türünün Copy trait'ini destekliyor 
    olması sözü:

    fn get_max<T: PartialOrd + Copy>(a: &[T]) -> T {            // geçerli
        let mut max = a[0];

        for i in 1..a.len() {
            if a[i] > max {
                max = a[i];
            }
        }
        max
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            64. Ders 12/11/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Adresiyle aldığı bir değişken ya da değeri ekrana (stdout dosyasına) yazdıran aşağıdaki disp isimli generic fonksiyonun 
    yazımında bir soun vardır:

    fn disp<T>(a: &T) {
        println!("{}", *a);         // error!
    }

    Burada T ütünen değerin println! makrosu ile yazdırılması için bu T türünün Display trait'ini destekliyor olması 
    gerekmektedir. O halde yukarıdaki fonksiyon T'nin her olası türü için geçerli olabilecek bir fonksiyon değildir. Bu 
    fonksiyonun geçerli olabilmesi için bizim T türünün std::fmt modülündeki Display trait'ini destekleyeceği sözünü 
    vermemiz gerekir. Bu da tür sınırlaması ile yapılmaktadır:

    fn disp<T: std::fmt::Display>(a: &T) {
        println!("{}", *a);         // geçerli
    }

    Temel türlerin hepsi Display trait'ini desteklemektedir. Display trait'i #[derive(Display)] özniteliği ile otomatik 
    olarak desteklenememektedir. Bunun için oluşturduğumuz yapı ya da enum türünün açıkça bu trait'i desteklemesi gerekir. 
    Biz henüz bu trait'in nasıl destekleneceğini görmemiş olsak da aşağıda bir rönek veriyoruz:

    struct Point {
        x: i32,
        y: i32,
    }

    impl std::fmt::Display for Point {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "({}, {})", self.x, self.y)
        }
    }

    Artık biz Point türünü de disp generic fonksiyonu ile yazdırabiliriz:

    let pt: Point = Point { x: 10, y: 20 };
    disp(&pt);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda generic fonksiyonlara örnek verdik. Generic olmayan yapı ve enum türlerinin metotları da generic olabilmektedir. 
    Örneğin:

    struct Sample {
        a: i32,
        b: i32,
    }

    impl Sample {
        fn foo<T>(&self, x: T) {
            //...
        }
    }

    Burada foo generic bir metottur. Yine foo metodu çağrılırken generic parametrelerin türleri açıkça tür belirtilebilir 
    ya da derleyicinin bunu çıkarsaması istenebilir:

    let s = Sample { a: 10, b: 20 };

    s.foo::<f64>(3.14);     // geçerli
    s.foo(3.14);            // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir yapı generic olabilir. Generic yapılar yapı isminden sonra açısal parantezler içerisinde generic parametreler 
    belirtilerek tanımlanmaktadır. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    Burada dikkat edilmesi gereken önemli bir nokta vardır. Aslında biz bunu daha önce de belirtmiştik. Generic türler 
    türünden somut türler tür ismi ve hemen sonra açısal parantezler içerisinde tür listesi belirtilerek oluşturulmaktadır. 
    Örneğin Point<i32>, Point<f64> Point türünden somut türleri belirtmektedir. Ancak generic türlerden değer oluşturuken 
    ya da generic türlerin metotlarına ve ilişkili fonksiyonlarına erişirken tür isminden sonra :: operatörü ve sonra açısal 
    parantezler içerisinde tür listesi belirtilmektedir. Örneğin:

    let pt: Point<i32>;     // geçerli

    Burada pt değişkeni Point<i32> türündendir. Burada türün aşağıdaki gibi belirtilmediğine dikkat ediniz:
    
    let pt: Point::<i32>;     // error! böyle bir tür ifadesi yok

    Ancak örneğin bu Point türünün new isimli ilişkili bir fonksiyonu olsun. 

    pt = Point::<i32>::new(10, 20);

    Burada aslında bir tür belirtilmemektedir. Point generic türünün i32 açılımına ilişkin new ilişkili fonksiyonu 
    çağrılmaktadır. Burada new ilişki fonksiyonun şöyle çağrılmadığına dikkat ediniz:

    pt = Point<i32>::new(10, 20);       // error! böyle bir çağrım yok

    Örneğin:

    let pt: Point<i32> = Point::<i32> { x: 10, y: 20 }     // geçerli

    Bu örnekte türü belirtirken Point<i32> sentaksının kullanıldığına ancak o türe ilişkin bir işlem yaparken Point::<i32>
    sentaksının kullanıldığına dikkat ediniz. 

    Özellikle C++'tan Rust'a geçen programcılar buradaki hataları sık yapmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic bir yapının metotları ve ilişkili fonksiyonları tanımlanırken generic parametreler hem impl anahtar sözcüğünden 
    sonra hem de yapı isminden sonra belirtilmek zorundadır. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    impl<T> Point<T> {
        //...
    }

    Daha önce de belirttiğimiz gibi aslında impl bloğunda belirtilen generic parametre isimlerinin yapı tanımlamasındaki 
    isimlerle aynı olması da gerekmemektedir. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    impl<K> Point<K> {      // geçerli
        //...
    }

    Yapı tanımlamasıyla impl bloğundaki eşleştirme pozisyonel biçimde yapılmaktadır. Tabii Rust programcıları hemern her zaman 
    impl bloğunda da yapı tanımlamasındaki isimleri kullanmaktadır. 

    Generic yapılardaki generic parametreler impl bloğu içerisindeki tüm metot ve ilişkili fonksiyonlarda doğrudan 
    kullanılabilmektedir. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    impl<T> Point<T> {      
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }
    }

    Burada T tür parametresinin metotlarda ve ilişkili fonksiyonlarda doğrudan kullanılabildiğine dikkat ediniz. Yapıyı 
    şöyle kullanabiliriz:

    let mut pt: Point<i32>;

    pt = Point::<i32> { x: 10, y: 20 };
    println!("{}, {}", pt.x, pt.y);

    pt.set_x(30);
    pt.set_y(40);

    println!("{}, {}", pt.x, pt.y);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki yukarıdaki Point yapısına disp isimli bir metot ekleyecek olalım. Bu metotta Point yapısının x ve y elemanalarını 
    println! makrosu ile yazdıracaksak disp metodunun Display trait'ini destekliyor olması gerekir. Pekiyi buna ilişkin 
    tür sınırlaması nerede belirtilmelidir? İşte burada üç seçenek karşımıza çıkmaktadır. 

    1) Tür sınırlamasının yapıda ya da enum türünde belirtilmesi
    2) Tür sınırlamasının impl bloğunda belirtilmesi
    3) Tür sınırlamasının metotta ya da ilişkili fonksiyonda belirtilmesi 

    Burada en kapsayıcı olan sınırlamanın (bounding) yapıda belirtilmesidir. Eğer sınırlama yapıda belirtilirse zaten 
    bu sınırlamanın impl bloğunda da belirtilmesi zorunlu olmaktadır. Eğer sınırlama impl bloğunda belirtilirse bu durumda
    blok içerisindeki tüm metotlar ve ilişkili fonksiyonlar için bu sınırlama geçerli olmaktadır. Eğer sınırlama belli bir 
    mettota ya da ilişkili fonksiyonda belirtilirse sınırlama yalnızca bu mettota ya da ilişkili fonksiyonda geçerli 
    olmaktadır. Bu durumu tersten örneklerle açıklayalım. Önce sınırlamayı belli bir metot ya da ilişkli fonksiyonla sınırlı 
    tutalım. Bu durumda sınırlama artık açısal parantezler içersinde değil where sentaksıyla yapılmak zorundadır. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    impl<T> Point<T> {      
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }

        fn disp(&self) 
        where T: std::fmt::Display {
            println!("{}, {}", self.x, self.y);
        }
    }

    Burada yalnızca disp metodu çağrılırken T türünün Display trait'ini desteklemesi gerekmektedir. Örneğin Sample yapısı 
    Display trait'ini desteklemiyor olsun:

    struct Sample {
        val: i32
    }
    
    Burada bizim Point<Sample> türünden bir değişken oluşturmamızda hiçbir sakınca yoktur:

    let mut pt: Point<Sample>;                                          // geçerli
    pt = Point::<Sample>::new(Sample { val: 10 }, Sample { val: 20 });    // geçerli

    Çünkü new ilişkili fonksiyonun Display trait'ini desteklemesi gerekmemektedir. Ancak aşağıdaki çağrı error oluşturacaktır:

    pt.disp();      // error!

    disp metodunda T türünün Display trait'ini destekliyor olması gerekir. Ancak örneğimizde Sample yapısı Dİsplay trait'ini 
    desteklememektedir. Burada şu noktaya dikkat ediniz: Biz sınırlamayı yalnızca disp metoduna uyguladık. Bu durumda sınırlama
    kontrolü yalnızca disp metodu çağrılırken yapılmaktadır. 

    Şimdi Display trait'ine ilişkin sınırlamayı impl bloğuna yerleştirelim:

    impl<T: std::fmt::Display> Point<T> {
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }

        fn disp(&self) {
            println!("{}, {}", self.x, self.y);
        }
    }

    Artık bu kısıt impl bloğundaki tüm metotlar ve ilişkili fonksiyonlar çağrılırken kontrol edilecektir. Yani buradaki 
    sınırlama impl bloğundaki tüm metotlara ve ilişkili fonksiyonlara uygulanmış gibi olmaktadır. Şimdi Display trait'ini 
    desteklemeyen Sample türü aşağıdaki işlemleri yapmak isteyelim:

    let mut pt: Point<Sample>;                                              // geçerli

    pt = Point::<Sample>::new(Sample { val: 10 }, Sample { val: 20 });        // error!
    pt.disp();                                                              // error!

    Burada Point<Sample> tür ifadesi error oluşturmamaktadır. Çünkü sınırlama yapıya değil impl bloğuna uygulanmıştır. 
    Ancak o bloktaki tüm ilişki fonksiyonlar ve metotlar bu için bu sınırlama uygulanmış gibi bir durum oluşmaktadır. 
    Dolayısıyla new ilişkili fonksiyonun çağrılması ve disp metounun çağrılması error oluşturacaktır. 

    Anımsanacağı gibi bir bir yapının ilişkili fonksiyonları ve metotları birden fazla impl bloğu içerisinde tanımlanabiliyordu. 
    O halde bazı impl blokları sınırlama içerirken bazıları içermeyebilir. Örneğin:

    impl<T> Point<T> {
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }
    }

    impl<T: Display> Point<T> {
        fn disp(&self) {
            println!("{}, {}", self.x, self.y);
        }
    }

    Burada ikinci impl bloğuna sınırlama uygulanmıştır, ilk impl bloğuna sınırlama uygulanmamaıştır:

    let mut pt: Point<Sample>;                                      // geçerli

    pt = Point::<Sample>::new(Sample { val: 10 }, Sample { val: 20 });    // geçerli
    pt.disp();                                                      // error!

    impl bloğundaki sınırlamalar yalnızca açısal parantezler içerisinde değil where sentaksıyla da yapılabilmektedir. 
    Biz sınırlamaları daha sonra yeniden tümden gözden geçireceğiz. Örneğin:

    impl<T> Point<T> 
    where T: std::fmt::Display {
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }

        fn disp(&self) {
            println!("{}, {}", self.x, self.y);
        }
    }
    
    Eğer sınırlama yapıya uygulanırsa bu durumda sınırlama bu hem somut tür oluştururken hem de tüm impl bloklarında etkili 
    olmaktadır. Zaten eğer sınırlama yapıya uygulanmışsa tüm impl bloklarında da bu sınırlamaların belirtilmesi zorunlu 
    olmaktadır. Örneğin:

    struct Point<T: std::fmt::Display> {
        x: T,
        y: T
    }

    impl<T: std::fmt::Display> Point<T> {
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }

        fn disp(&self) {
            println!("{}, {}", self.x, self.y);
        }
    }

    Artık biz aşağıdaki bildirimi bile yapamayız:

    let pt: Point<Sample>;      // error!

    Tabii aslında yapıdaki sınırlamalar da where sentaksıyla oluşturulabilmektedir:

    struct Point<T> where T: std::fmt::Display {        // geçerli
        x: T,
        y: T
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tür sınırlaması yalnızca bir metot ya da ilişkili fonksiyon için de söz konusu olabilir. Bu durumda açısal parantez 
    sentaksı kullanılamaz kısıtın where sentaksıyla belirtilmesi gerekeir. Örneğin:

    struct Point<T> {
        x: T,
        y: T
    }

    impl<T> Point<T> {
        fn new(x: T, y: T) -> Self {
            Point { x, y }
        }

        fn set_x(&mut self, x: T) {
            self.x = x;
        }

        fn set_y(&mut self, y: T) {
            self.y = y;
        }

        fn disp(&self) 
        where T: std::fmt::Display {
            println!("{}, {}", self.x, self.y);
        }
    }

    Burada Display trait sınırlaması yalnızca disp metoduna uygulanmıştır. Metoda ya da ilişkili fonksiyonlara özgü 
    sınırlamaların ancak where sentaksıyla oluşturulabildiğini bir kez daha vurgulamak istiyoruz.  
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi basit bir FIFO kuyruk sistemini generic bir yapı biçiminde gerçekleştirelim. Yapımız şöyle olabilir:

    const SIZE: usize = 10;

    struct Queue<T: Default + Copy> {
        queue: [T; SIZE],
        head: usize,
        tail: usize,
        count: usize
    }

    Aslında bu tür veri yapılarının gerçekleştirilmesinde dizilerin dinmaik bir biçimde yani istenilen büyüklükte oluşturulması 
    gerekir. Ancak biz örneğimizde şimdilik buradaki diziyi 10 gibi belli bir büyüklükte alıyoruz. Kuyruk elemanları bir dizide 
    olacağına göre ve bu elemanlar diziden alınıp verileceğine göre dizinin Copy türünden olması gerekmektedir. Çümkü anımsanacağı 
    gibi Copy türünden olmayan dizilerin belli elemanları taşınamamaktadır. Dizi elemanlarına default değer verilirken generic 
    tür neyse o türden default değerlerin verilmesi anlamlıdır. O halde buradaki yapımız Default trait'ini de desteklemeldir. 
    Yapı türünden bir nesne oluşturan new ilişkili fonksiyonu şöyle tanımlanmıştır:

    impl<T: Default + Copy> Queue<T> {
        fn new() -> Self {
            Queue {
                queue: [T::default(); SIZE], 
                head: 0, 
                tail: 0, 
                count: 0
            }
        }
        //...
    }

    Kuyruğa eleman ekleyen ve kuyruktan eleman alan metotlar da şöyle tanımlanmıştır:

    fn pop(&mut self) -> Option<T> {
        let result: Option<T>;
        if self.count == 0 {
            return None;
        }
        result = Some(self.queue[self.head]);
        self.head = (self.head + 1) % SIZE;
        self.count -= 1;

        result
    }

    fn pop(&mut self) -> Option<T> {
           if self.count == 0 {
            return None;
        }
        self.head = (self.head + 1) % SIZE;
        self.count -= 1;

        Some(self.queue[self.head])
    }

    push metodunun bool türüne geri dönmesi uygundur. Çünkü bu metot kuyruk doluysa başarısız olacaktır. pop metodu ise 
    hem kuyruktaki değeri hem de başarısızsa başarısızlık durumunu bize vermelidir. Bu nedenle pop metodunun geri dönüş 
    değeri Option türündendir. Kuyruk sistemini aşağıdaki gibi bir kodla test edebilirsiniz:

    let mut q = Queue::<i32>::new();

    for i in 0..100 {
        if !q.push(i) {
            println!("queue is full!");
            break;
        }
    }

    while let Some(val) = q.pop() {
        println!("{}", val);
    }

    Aşağıda yapının gerçekleştirimini bir bütün olarak veriyoruz. Tabii yapıya siz de gerekli başka metotları ekleyebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut q = Queue::<i32>::new();

    for i in 0..100 {
        if !q.push(i) {
            println!("queue is full!");
            break;
        }
    }

    while let Some(val) = q.pop() {
        println!("{}", val);
    }
}

const SIZE: usize = 10;

struct Queue<T> {
    queue: [T; SIZE],
    head: usize,
    tail: usize,
    count: usize
}

impl<T: Default + Copy> Queue<T> {
    fn new() -> Self {
        Queue {
            queue: [T::default(); SIZE],
            head: 0,
            tail: 0,
            count: 0
        }
    }

    fn push(&mut self, item: T) -> bool {
        if self.count >= self.queue.len() {
            return false;
        }
        self.queue[self.tail] = item;
        self.tail = (self.tail + 1) % SIZE;
        self.count += 1;

        true
    }

    fn pop(&mut self) -> Option<T> {
        let result: Option<T>;
        if self.count == 0 {
            return None;
        }
        result = Some(self.queue[self.head]);
        self.head = (self.head + 1) % SIZE;
        self.count -= 1;

        result
    }

    fn clear(&mut self) {
        self.head = 0;
        self.tail = 0;
        self.count = 0;
    }

    fn len(&self) -> usize {
        self.count
    }

    fn capacity(&self) -> usize {
        SIZE
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                        65. Ders 17/11/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta const generic parametre denilen bir generic parametre türü de vardır. const generic parametreler aşağıdaki genel 
    biçimle bildirilmektedir:

    const <parametre_ismi>: <tür>

    Örneğin:

    const U: i32
    const V: u64

    const generic parametrelerde ':' atomundan sonra belirtilen türün tamsayı türlerine ya da char ve bool türlerine ilişkin 
    olması gerekmektedir. Yani const generic parametrelerin türleri aşağıdakilerden biri olabilir:

    u8
    u16
    u32
    u64
    u128
    usize
    i8
    i16
    i32
    i64
    i128
    isize
    bool
    char

    const generic parametreler için açıkça sabit ifadesi biçimnde ilgili türden bir değerin açısal parantezler içerisinde 
    belirtilmesi gerekir. Örneğin:

    fn foo<T, const U: usize>(x: T) {
        //...
    }

    Burada foo fonksiyonun iki generic parametresi vardır: T ve U. T parametresi herhangi bir türü temsil etmektedir. Ancak 
    U parametresi usize türünden bir sabit ifadesini temsil etmektedir. Dolayısıyla bu U değeri fonksiyonun içerisinde bir 
    sabit ifadesi gibi kullanılabilir. Örneğin:

    fn foo<T, const U: usize>(x: T) {
        let x: [i32; U] = [0; U];      // geçerli
        //...
    }

    Dizi uzunluklarının usize türünden sabit ifadesi belirtmesi gerektiğini anımsayınız. Buradaki U const generic parametre 
    usize türünden sabit ifadesi belirttiği için fonksiyon içerisindeki dizi bildirimi geçerlidir. Aşağıdaki tanımlama da 
    benzer biçimde geçerlidir:

    fn foo<T: Default, const U: usize>(x: T) {
        let x: [T; U] = [T::default(); U];      // geçerli
        //...
    }

    const generic parametreler birer sabit ifadesi belirttiği için fonksiyon ya da metot çağrılırken onlar için açısal 
    parantezler içerisinde sabit ifadesi girilmesi gerekir. Örneğin:

    foo(100);                   // error!

    Burada bu çağrıda U const generic parametrenin değeri belli değildir. Dolayısıyla çağrı da geçerli değildir. Örneğin:

    foo::<i32, 10>(100);        // geçerli!

    Burada çağrı geçerlidir. Artık U parametresinin değeri bellidir. Tabii T için tür çıkarımının derleyiciye yaptırılması 
    da aşağıdaki gibi sağlanabilir:

    foo::<_, 10>(100);        // geçerli!

    Generic yapılarda ve enum türlerinde de const generic parametreler kullanılabilir. Örneğin:

    struct Queue<T, const SIZE: usize> {
        queue: [T; SIZE],
        head: usize,
        tail: usize,
        count: usize
    }

    Burada artık Queue yapısının queue alanındaki dizinin uzunluğunun generic const parametre yoluyla dışarıdan belirlenmesi 
    sağlanabilmektedir. (Dizi uzunluklarının sabit uszie türünden sabit ifadesi belirtmek zorunda olduğunu anımsayınız.)
    Tabii artık impl bloğunda hetm T parametresinin hem de SIZE parametresinin belirrtilmesi gerekmektedir. Örneğin:

    impl<T: Default + Copy, const SIZE: usize> Queue<T, SIZE> {
        //...
    }

    Yukarıdaki Queue yapısının const generic parametre gerçekleştirimini aşağıda veriyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {

    let mut q = Queue::<i32, 10>::new();

    for i in 0..100 {
        if !q.push(i) {
            println!("queue is full!");
            break;
        }
    }

    while let Some(val) = q.pop() {
        println!("{}", val);
    }
}

struct Queue<T, const SIZE: usize> {
    queue: [T; SIZE],
    head: usize,
    tail: usize,
    count: usize
}

impl<T: Default + Copy, const SIZE: usize> Queue<T, SIZE> {
    fn new() -> Self {
        Queue {
            queue: [T::default(); SIZE],
            head: 0,
            tail: 0,
            count: 0
        }
    }

    fn push(&mut self, item: T) -> bool {
        if self.count >= self.queue.len() {
            return false;
        }
        self.queue[self.tail] = item;
        self.tail = (self.tail + 1) % SIZE;
        self.count += 1;

        true
    }

    fn pop(&mut self) -> Option<T> {
        let result: Option<T>;
        if self.count == 0 {
            return None;
        }
        result = Some(self.queue[self.head]);
        self.head = (self.head + 1) % SIZE;
        self.count -= 1;

        result
    }

    fn clear(&mut self) {
        self.head = 0;
        self.tail = 0;
        self.count = 0;
    }

    fn len(&self) -> usize {
        self.count
    }

    fn capacity(&self) -> usize {
        SIZE
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    const generic parametrelerin değerlerini de derleyici eğer bağlam uygunsa otomatik çıkarsayabilmektedir. Örneğin:

    fn foo<T, const SIZE: usize>(a: [T; SIZE]) {
        //...
    }

    Burada fonksiyon bir dizi parametresi almaktadır. Fonksiyon parametresindeki T ve SIZE derleyici tarafından çıkarsanabilecektir.
    Örneğin:

    let a: [i32; 5] = [1, 2, 3, 4, 5];

    foo(a);     // geçerli, T = i32, SIZE = 5

    Burada derleyici argüman olarak girilen diziden hareketle T türünün i32 olduğunu, SIZE değerinin ise 5 olduğunu 
    anlayabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    enum türlerinin de generic olabileceğini belirtmiştik. Örneğin çok kullandığımız Option ve Result enum türlerinin de 
    generic olduğunu anımsayınız. Option enum türü şöyle tanımlanmıştır:

    pub enum Option<T> {
        None,
        Some(T)
    }

    Burada enum türünün demetsel Some varyantının generic parametre türünden olduğuna dikkat ediniz. Generic enum türlerinde 
    enum türünün her farklı generic parametresinin varyantları da farklıdır. Varyantlar birimsel olsa da bunlar farklıdır. 
    ÖrneğinyOption::<i32>::None varyanı ile Option::<i64>::None varyantı farklı türlerdendir. Başka bir deyişle burada her 
    Option<T> türünün farklı bir None varyantı vardır. Varyantların ilgili enum türünden olduğunu anımsayınız. Dolayısıyla
    burada Option::<i32>::None varyantı Option::<i32> türünden, Option::<i64>::None varyantı ise Option<i64> türündendir. 
    Tabii standart prelude içerisinde standart kütüphanedeki Option ve onun içerisindeki None ve Some isimleri 
    use edildiği için biz onları doğrudan kullanabilmekteyiz. 
    
    Rust derleyicisi atama işleminde eğer hedef generic enum türünün generic parametresini biliyorsa atama işleminde varyant
    belirtilirken türün ayrıca belirtilmesine gerek kalmamaktadır. Örneğin:

    
    Örneğin:

    let mut opt: Option<i32>;
    
    opt = Some(10);
    //...
    opt = None;

    Burada biz doğrudan Some dediğimizde aslında Option::<i32>::Some demiş olmaktayız. Benzer biçimde doğrudan None dediğimizde 
    de aslında Option::<i32>::None demiş olmaktayız. Farklı generic türlere ilişkin Option enum değişkenlerine aynı None değerin 
    atanması kişilere tuhaf gelebilmektedir. Örneğin:

    let opt1: Option<i32>;
    let opt2: Option<i64>;

    opt1 = None;
    opt2 = None;;

    Buradaki iki None değeri aynı None değeri değildir. Üstteki Option::<i32>::None alttaki ise Option::<i64>::None anlamına 
    gelmektedir. Derleyici yukarıda da belirttiğimiz hedefin türüne bakarak bu tespiti yapabilmektedir. Örneğin:

    let opt: Option<i32>;
    
    opt = Option::<i64>::None;      // error!
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önce kullanmış olduğumuz Result enum türü de aslında iki generic parametre almaktadır:

    pub enum Result<T, E> {
        Ok(T),
        Err(E),
    }

    Yine standart prelude içerisinde Result ismi, Ok ve Err varyant isimleri use edilmiştir. Dolayısıyla biz bu isimleri 
    doğrudan kullanabilmekteyiz. Örneğin:

    let mut r: Result<i32, &str>;

    r = Ok(10);         // geçerli
    r = Err("fail");    // geçerli

    Buradaki atamalar aslında tamamen aşağıdakilerle eşdeğerdir:

    r = Result::<i32, &str>::Ok(10);         
    r = Result::<i32, &str>::Err("fail");    
    
    Örneğin aşağıdaki gibi generic bir enum söz konusu olsun:

    enum Fruit<T> {
        Apple,
        Banana(T),
        Orange { x: T, y: T }
    }

    Şimdi bu enum türünden bir değişken bildirelim:

    let mut f: Fruit<i32>;

    Şimdi de bu enum değişkenine bu enum türünün varyantlarını atayalım:

    f = Fruit::Apple;

    Bu atama aşağıdakiyle eşdeğerdir:

    f = Fruit::<i32>::Apple;

    Şimdi de f değişkenine diğer varyantı atayalım:

    f = Fruit::Banana(10);

    Derleyici yine hedef değişknin generic parametresinden hareketle bu atamayı aşağıdakiyle eşdeğer kabul edecektir:

    f = Fruit::<i32>::Banana(10);

    Şimdi de f değişkenine yapısal varyanı atayalım:

    f = Fruit::Orange { x: 10, y: 20 };

    Derleyiciye göre bu atama işlemi de aşağıdakiyle eşdeğerdir:

    f = Fruit::<i32>::Orange { x: 10, y: 20 };

    Bu örnekten de görüldüğü gibi Rust derleyicisi hedef enum değişkenin generic tür parametresini bildiği için varyant 
    ataması sırasında programcının ayrıca generic parametreyi açıkça belirtmesine gerek kalmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta generic bir yapı ya da enum türü için farklı türlerden impl blokları oluşturulabilmektedir. Örneğin:

    struct Sample<T> {
        val: T
    }

    Böyle bir generic yapı için impl bloğunun aşağıdaki gibi oluşturulduğunu görmüştük:

    impl<T> Sample<T> {
        //...
    }

    Eğer istenirse T'nin bazı türleri için ayrı impl blokları da oluşturulabilmektedir. Örneğin:

    struct Sample<T> {
        val: T
    }

    impl<T> Sample<T> {
        //...
    }

    impl Sample<i32> {
        //...
    }

    impl Sample<i64> {
        //...
    }

    Bu biçimde farklı türler için farklı impl blokları oluşturulurken impl anahtar sözcüğünden sonra açısal parantezler içerisinde
    türün belirtilmesi zorunlu değildir. Yani örneğin:

    impl Sample<i32> {
        //...
    }

    bloğu ile aşağıdaki blok eşdeğerdir:

    impl<i32> Sample<i32> {
        //...
    }

    Bu biçimde özelleştirmeler yapılırken impl bloklarındaki fonksiyonların ve metotların aynı türler için çakışmaması 
    gerekir. Örneğin aşağıdaki ikinci impl bloğu error oluşmasına yol açacaktır. 

    struct Sample<T> {
        val: T
    }

    impl<T> Sample<T> {
        fn foo(&self) {
            //...
        }
    }

    impl Sample<i32> {
        fn foo(&self) {                 // error!
            println!("foo i32");
        }
    }

    Burada birinci impl bloğu T üzerinden oluşturulduğu için ve bu T türü i32 de olabileceğinden dolayı sanki Sample<i32> 
    için aynı isimli iki fonksiyon tanımlanmış gibi bir durum oluşur. Örneğin:

    struct Sample<T> {
        val: T
    }

    impl Sample<f64> {
        fn foo(&self) {
            //...
        }
    }

    impl Sample<i32> {
        fn foo(&self) {                 // geçerrli
            println!("foo i32");
        }
    }

    Burada iki farklı impl bloğunda foo fonksiyonun bulunmasında bir sorun oluşmayacaktır. Çünkü Sample<i32> ile Sample<f64> 
    farklı türlerdir. Dolayısıyla burada aynı türün içerisinde birden fazla aynı isimli fonksiyon bulunmamaktadır. Bu tür 
    durumlarda trait sınırlaması dikkate alınmamaktadır. Örneğin:

    struct Sample<T> {
        val: T
    }

    impl<T: Copy> Sample<T> {
        fn foo(&self) {
            //...
        }
    }

    impl Sample<String> {
        fn foo(&self) {         // error!
            //...
        }
    }

    Burada T generic parametresi için Copy trait sınırlaması yapılmıştır. String yapısı da Copy türünden değildir. O halde 
    aslında burada bir çakışma olamaz. Ancak Rust derleyicisi karmaşık bir anlamlandırma oluşturabileceğinden generic 
    tür sınırlamalarını hiç dikkate almamaktadır. Dolayısoyla yukardaki ikinci impl bloğu yine error oluşturmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta bazı nesne yönelimli programlama dillerinde olduğu gibi generic tür parametreleri için default tür belirlemesi 
    yapılabilmektedir. Defult tür belirleme işlemi açısal parantezler içerisinde generic tür isminden sonra '=' atomu kulanılarak 
    yapılmaktadır. Örneğin:

    struct Sample<T = i32> {
        val: T
    }

    Burada T generic parametresi için default tür i32 olarak belirtilmiştir. Default tür, "eğer generic parametre için tür 
    belirtilmezse varsayılacak türü" belirtmektedir. Yani yukarıdaki yapıyı biz kullanırken T generic parametresi için tür 
    belirlemesi yapmazsak default olarak T türü i32 anlamına gelecektir. Örneğin:

    let s: Sample;

    Burada s değişkeni Sample<i32> türündendir. Çünkü Sample için T türünün ne olacağı konusunda bir belirlemede bulunulmamıştır. 

    Rust'ta generic yapılardaki, enum türlerindeki ve trait'lerdeki generic parametrelere default türler iliştirilebilmektedir
    ancak fonksiyonlardaki ve metotlardaki generic parametrelere default türler iliştirilememektedir. Örneğin:

    fn foo<T = i32>(a: T) {     // error! generic fonksiyonlarda defult tür belirtilememektedir
        //...
    }

    Rust'ta eğer generic bir türün gerçekte hangi tür olduğu çıkarımla belirlenebiliyorsa bu durumda verilen default tür dikkate 
    alınmaz. Örneğin:

    struct Sample<T = i32> {
        val: T
    }
    //...

    let s = Sample { val: 3.14 };

    Burada s artık Sample<i32> türünden değil Sample<f64> türündendir. Çünkü val alanından hareketle T için tür çıkarımı 
    yapılmaktadır. Bu tür durumlarda eğer açısal parantezler kullanıp içi boş bırakılırsa derleyici default türün kullanılmak 
    istendiğini kabul etmektedir. Örneğin:

    let s = Sample::<> {val: 3.14};              // error!

    Burada açısal parantezlerin içi boş bırakıldığı için default tür devreye sokulmaktadır. Ancak tür yerine _ atomunun bulundurulması
    bu bağlamda default türü devreye sokmamaktadır:

    let s = Sample::<_> {val: 3.14};        // geçerli

    Burada s değişkeni Sample<f64> türündendir. 
    
    Bir generic parametreye default tür verilmişse onun sağındaki generic parametrelerin hepsine default tür verilmek zorundadır. 
    Örneğin:

    struct Sample<T, K = i32> {             // geçerli
        a: T,
        b: K
    }

    struct Sample<T = i32, K> {             // error!
        a: T,
        b: K
    }

    struct Sample<T = i32, K = i64> {       // geçerli
        a: T,
        b: K
    }

    Yukarıda da belirttiğimiz gibi generic tür parametrelerine için default türlerin devreye girmesi isteniyorsa açısal 
    parantezler kullanılmalıdır. Açısal parantezlerin içerisi tamamen boş bırakılabilir ya da açısal parantezlerin içerisinde 
    yalnızca ilk N tane generic parametre için tür belirlemesi de yapılabilir. Bu durumda belirtilmeyen türler için 
    default türler devreye girecektir. Örneğin:

    struct Sample<T = i32, K = i64> {
        a: T,
        b: K
    }
    //...

    let s: Sample<f64>;

    Burada s değişkeni Sample<f64, i64> türündendir. Örneğin:

    let k: Sample;

    Burada k değişkeni Sample<i32, i64> türündendir. Yukarıdaki bildirim aşağıdakiyle eşdeğerdir:

    let k: Sample<>;

    Eğer bu örnekte biz türü Sample<_, f64> biçiminde belirtseydik buradaki _ atomu yukarıda da belirttiğimiz gibi 
    "default türü kullan anlamına gelmeyecekti", "tür çıkarımı yap" anlamına gelecekti. Örneğin:

    let s: Sample<_, f64>;      // error! 

    Burada derleyicinin tür çıkarımı yapabilmesi için yapının a alanının türünü bir biçimde belirleyebilmesi gerekmektdir. 
    Aşağıdaki gibi bir sentaks da geçerli değildir:

    let s: Sample<, f64>;      // error! böyle bir sentaks yok
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki default tür iliştirilen generic yapılar ve enum türlerinde impl blokları nasıl olacaktır? İşte normal olarak impl 
    bloklarının yine generic bir biçimde yazılması gerekir. Örneğin:

    struct Sample<T = i32> {
        val: T
    }

    impl<T> Sample<T> {
        fn foo(&self) {
            //...
        }
    }

    Tabii biz impl bloğunda Sample<T> değil yalnızca Sample da diyebilirdik. Bu durum i32 için özelleştirme yapmış olduğumuz 
    anlamına gelmektedir. Örneğin:

    impl Sample {
        fn foo(&self) {
            println!("{}", self.val);
        }
    }

    Bu impl bloğu tamamen aşağıdakiyle eşdeğerdir:

      impl Sample<i32> {
        fn foo(&self) {
            println!("{}", self.val);
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic bir yapı ya da enum türünün generic parametresi hem default türe hem de trait sınırlamasına sahip olabilir. Bu 
    durumda önce ':' sentaksı ile trait sınırlaması belirtilir sonra da '=' sentaksı ile default tür belirtilir. ÖrneğiN:

    struct Sample<T: Copy = i32> {          // geçerli
        val: T
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de generic sınırlamaları (generic bounds) konusunu baştan itibaren ele aalım.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic sınırlamaları daha önceden de belirttiğimiz gibi generic fonksiyonların ve metotların söz konusu kısıtlar 
    sağlandığında her zaman geçerli olmasını derleme aşamasında garantiye almak için dile eklenmiştir. Yalnızca Rust'ta değil
    C# ve Java gibi diğer dillerde de bu kavram benzer amaçları sağlamak için bulunmaktadır. C++'ta bu kavram C++20 ile 
    dile eklenmiştir. 

    Rust'ta generic sınırlamalar iki sentaks ile oluşturulmaktadır:

    1) Açısal parantez içerisinde ':' sentaksı ile
    2) where sentaksı ile 

    Bu iki sentaks bazı durumlarda tamamen eşdeğerdir. Ancak bazı durumlarda açısal parantez içerisinde sınırlama yetersiz 
    kalmakta ve mecburen where sentaksının kullanılması gerekmektedir. 

    Açısal parantezdeki ':' sentaksında generic türün desteklemesi gereken trait'ler ':' atomundan sonra blirtiliyordu. 
    Eğer birden fazla trait söz konusu ise bunlar '+' ile belirtiliyodu. Örneğin:

    fn foo<T: Default + Copy>(a: T) {
        //...
    }

    Birden fazla generic parametrenin olduğu durumda da sentaks aynı biçimdedir. Örneğin:

    fn foo<T: Default + Copy, K: Clone> (a: T, k: K)  {
        //...
    }

    where sentaksının genel biçimi de şöyledir:

    where <paramete_ismi>: <sınırlamalar>, <parametre_ismi>: <sınırlamalar>, ....

    where sentaksı fonksiyonun ya da metodun parametre parantezinden sonraya yerleştirilmektedir. Hem açısal parantez 
    sentaksı hem de where sentaksı fonksiyonun ya da metodun imzasına dahildir. Örneğin:

    fn foo<T, K>(a: T, k: K)
    where 
        T: Default + Copy, 
        K: Clone 
    {
        //...
    }

    Rust programcıları genel olarak where sentaksındaki hizalamayı yukarıda biçimdeki yapmayı tercih etmektedir. Tabii 
    aslında atomlar istenildiği gibi peşi sıra geitirlebilmektedir. Örneğin:

    fn foo<T, K> (a: T, k: K) where T: Default + Copy, K: Clone {
        //...
    }

    Pek çok dilde "sentaksta virgüllerle ayrılmış olan listelerde (comma separetad lists)" listenin sonunda isteğe bağlı 
    son bir ',' atomu kullanılabilmektedir. Rust'ta da bu gelenek muhafaza edilmiştir. Bu tür durumlarda sonda bir ',' 
    atomu görürseniz bunun özel bir anlama geldiğini sanmayınız. Örneğin:

    fn foo<T, K>(a: T, k: K)
    where 
        T: Default + Copy, 
        K: Clone,
    {
        //...
    }
    //...
    let a = [10, 20, 30, 40, 50, ];
    //...
    bar(10, 20, 30, );
    //..
    struct Sample {
        a: i32,
        b: i32,
    }

    Bu tür virgülle aytılmış listelerin bazılarında son virgülün kasten yerleştirilmesi Rust'ta neredeyse gelenek haline 
    gelmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki where sentaksının zorunlu olduğu durumlar dışında biz hangi sentaksı tercih etmeliyiz? Açısal parantez sentaksını mı 
    where sentaksını mı? Eğer generic parametreler fazla değilse ve sınırlamalar karmaşık değilse açısal parantez sentası 
    daha pratik olduğundan tercih edilebilir. Ancak çok fazla generic parametre varsa ve sınırlamalar da açısal parantez 
    içerecek biçimde karmaşıksa where sentaksı okunabilirlik bakımından tercih edilmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Açısal parantez sentaksında önceki generic parametreye ilişkin sınırlama sonra generic parametrelere ilişkin olabilmektedir. 
    Örneğin:

    trait Error<T, K> {
        //...
    }

    fn foo<T: Error<U, K>, U: Copy, K: Default>() {
        //...
    }

    Burada ilk generic parametresinin sınırlamasında sonraki generic parametreler kullanılmıştır. Ancak bu tür durumlarda 
    where sentaksı okunabilirlik bakımından tercih edilebilir:

    fn foo<T, U, K>()
    where
        T: Error<U, K>,
        U: Copy,
        K: Default
    {
        //...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            66. Ders 19/11/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Generic tür sınırlamalarının bazıları açısal parantez sentaksıyla bazıları ise where sentaksıyla oluşturulabilmektedir. 
    Örneğin:

    fn foo<T: Copy, K>(a: T, b: K)
    where
        K: std::fmt::Debug,             // geçerli
    {
        //...
    }

    Burada T generic parametresi Copy trait'ini, K generic parametresi ise Debug trait'ini desteklemek zorundadır. Aynı 
    generic paramatre için hem açısal parantezler içerisinde hem de where sentaksında sınırlama yapılabilir. Bu durumda 
    bu sınırlamalar sanit + ile çoğaltılmış gibi etki göstermektedir. Örneğin:

    fn foo<T: Copy, K>(a: T, b: K)
    where
        T: std::fmt::Debug,
        K: std::fmt::Debug
    {
        //...
    }

    Burada artık T generic parametresi hem Copy hem de Debug trait'ini desteklemek zorundadır. Tabii okunabilirlik bakımından 
    hem açısal parantezler içerisinde hem de where sentaksı içerisinde sınırlama belirtmek iyi bir teknik değildir. Rust 
    programcıları ya tüm sınırlamaları açısal parantezler içerisinde ya da where sentaksına belirtmeyi tercih etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Trait sınırlamasında bir trait ilişkili türlere sahipse sınırlamada eğer ilişkili türün ne olacağı konusunda bir sınırlama
    yapılmazsa bu durum ilişkili türün herhangi bir olabileceği anlamına gelmektedir. Örneğin Test trait'i şöyle olsun:

    trait Test {
        type Item;

        fn test(&self);
    }

    Anımsanacağı gibi bu trait'i destekleyen türlerin Item türünü impl bloğu içerisinde belirtmesi gerekmektedir. Şimdi 
    aşağıdaki gibi bir generic fonksiyon tanımlamış olalım:

    fn foo<T>(a: T)
    where
        T: Test
    {
        //...
    }

    Burada T generic parametresinin Test trait'ini destekleyen bir tür türünden olması gerektiğine ilişkin bir sınırlamada 
    bulunulmuştur. Ancak bu sınırlamada Test trait'ini destekleyen türdeki Item türü hakkında bir sınırlama yoktur. O halde 
    Test trait'ini destekleyen türdeki Item ilişkili türü hangi tür olursa olsun foo fonksiyonuna argüman olarak verilebilir. 
    Örneğin:

    struct Sample(i32);

    impl Test for Sample {
        type Item = f64;

        fn test(&self) {
            //...
        }
        //...
    }

    Biz Sample türünden bir değişken yaratıp onunla foo fonksiyonunu çağırabiliriz:

    let s = Sample(10);

    foo(s);     // geçerli

    Ancak sınırlama yapılırken ilişkili tür için de belirlemede bulunulabilmektedir. Örneğin:

    fn foo<T>(a: T)
    where
        T: Test<Item=i32>
    {
        //...
    }

    Burada artık sınırlama şu anlama gelmektedir: "T generic parametresi Test trait'ini Item ilişkili türü i32 olacak 
    biçimde desteklemek zorundadır." Örneğin:

    struct Sample(i32);

    impl Test for Sample {
        type Item = f64;

        fn test(&self) {
            //...
        }
    }
    //...

    let s = Sample(10);

    foo(s);     // error!

    Burada Sample yapısı Test trait'ini desteklemektedir ancak ilişkili Item türü uygun değildir. 

    Tabii ilişkili tür belirleme açısal parantezler içerisinde de benzer biçimde yapılabilmektedir:

    fn foo<T: Test<Item=i32>>(a: T)
    {
        //...
    }

    Yukarıda da belirttiğimiz gibi açısal parantezler yeniden açışsal parantez kullanıldığında okunabilirlik biraz 
    bozulabilmektedir. Bu tür durumlarda where sentaksını tercih edebilirsiniz. 

    İlişkili türlere sahip olan trait'lerde ilişkili türler için de sınırlamalar oluşturulabilmektedir. Örneğin:

    fn foo<T>(a: T)
    where
        T: Test<Item: Copy>
    {
        //...
    }

    Buradaki sınırlama şu anlama gelmektedir: "T generic parametresi Test türünü destekleyen bir tür türünden olmalıdır. 
    Ancak o türde Item isimli ilişkili tür de Copy trait'ini desteklemelidir." BUradaki sentaksta artık Item isminden 
    sonra '=' atomu değil ':' atomunun kullanıldığına dikkat ediniz. Örneğin Sample yapısı şöyle tanımlanmış olsun:

    struct Sample(i32);

    impl Test for Sample {
        type Item = String;

        fn test(&self) {
            println!("foo");
        }
    }

    Biz Sample türünden bir değerle yukarıdaki foo fonksiyonunu çağıramayız. Her ne kadar Sample türü Test trait'ini 
    destekliyor olsa da Item ilişkili türü Copy türünden değildir:

    let s = Sample(10);

    foo(s);     // error!

    Bu kıst açısal paramtezler içerisinde de oluşturulabilmektedir:

    fn foo<T: Test<Item: Copy>>(a: T)
    {
        //...
    }

    Tabii bu tür sınırlamalar daha karışık hale de gelebilmektedir. Örneğin:

    fn foo<T>(a: T)
    where
        T: Test<Item: AnotherTest<AnotherItem: Copy>>
    {
        //...
    }

    Burdada T generic parametre için belirtilen kısıt şu anlama gelmektedir: "T generic parametresi Test trait'ini destekleyen 
    ancak Item türü de AnotherTest trait'ini destekleyen bir tür türündenolmalıdır. AnotherTest türünü destekleyen türde 
    ise AnotherItem türü Copy trait'ini desteklemidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta "operatör metotları konusunu ele alacağız. Operatör metotları ya da operatör fonksiyonları nesne 
    yönelimli pek çok programlama dilinde var olan bir özelliktir. Çeşitli diller operatör metotlarını kendilerine uygun bir 
    biçimde bünyesine dahil etmiştir. Operatör metotlarının bulunduğu yaygın diller şunlardır:

    C++
    C#
    Python
    Ruby
    Swift
    Kotlin
    Rust

    Java her ne kadar C#'a oldukça benzese de operatör metotlarına sahip değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Operatör metotları aslında dile ek bir işlevsellik kazandırmamaktadır. Yalnızca okunabilirliği artıran bir işlev görmektedir. 
    Operatör metotları sayesinde programcının kendi oluşturduğu türler +, -, *, /, >, < gibi operatörlerle kullanılabilmektedir. 
    Örneğin karmaşık sayıları temsil eden bir yapı tanımlamış olalım:

    #[derive(Copy, Clone)]
    struct Complex {
        real: f64,
        imag: f64,
    }

    Biz iki karmaşık sayıyı toplayan bir fonksiyon yazmak isteyelim. Tabii bu fonksiyon Complex yapısıyla ilgili olduğu için
    Complex yapısının ilişkili fonksiyonu biçiminde yazılabilir:

    impl Complex {
        fn new(real: f64, imag: f64) -> Complex {
            Complex { real, imag }
        }

        fn add(left: Complex, right: Complex) -> Complex {
            let real = left.real + right.real;
            let imag = left.imag + right.imag;

            Complex { real, imag }
        }

        fn disp(&self) {
            println!("{}+{}i", self.real, self.imag)
        }
    }

    Artık biz iki karmaşık sayıyı bu add metodunu kullanarak toplayabiliriz:

    let x = Complex::new(3., 2.);
    let y = Complex::new(4., 3.);
    let result: Complex;

    result = Complex::add(x, y);
    result.disp();

    Buradaki toplama işlemini yapan satıra dikkat ediniz:

    result = Complex::add(x, y);

    Eğer biz bu işlemi doğrudan + operatörünü kullanarak yapabilseydik kodumuz matematiksel alana daha yakın hale gelirdi, 
    dolayısıyla daha okunabilir olurdu:

    result = x + y;

    İşte operatör metotları bunu sağlamaktadır. Yani operatör metotları sayesinde biz kendi türümüzü sanki onlar temel 
    türlerdenmiş gibi operatörlerle kullanabilir hale gelmekteyiz. Tabii aslında yukarıdaki örneğimizde derleyici x + y
    ifadesini gördüğünde x ve y değişkenlerini operatör metodu denilen metoda argüman olarak geçirip o metodu çağırmaktadır. 
    Yani aslında x + y ifadesi bir metodun çağrılmasına yol açmaktadır. x + y ifadesindne elde edilen değer bu operatör 
    metodunun geri dönüş değeridir. Başak bir deyişle:

    result = x + y;

    işlemini derleyici adeta aşağıdaki ile eşdeğr kabul etmektedir:

    result = x.add(y);

    Aşağıdaki örnekte iki Complex sayı Complex yapısının add isimli ilişkili fonksiyonuyla toplanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let x = Complex::new(3., 2.);
    let y = Complex::new(4., 3.);
    let result: Complex;

    result = Complex::add(x, y);
    result.disp();
}

#[derive(Copy, Clone)]
struct Complex {
    real: f64,
    imag: f64,
}

impl Complex {
    fn new(real: f64, imag: f64) -> Complex {
        Complex { real, imag }
    }

    fn add(left: Complex, right: Complex) -> Complex {
        let real = left.real + right.real;
        let imag = left.imag + right.imag;

        Complex { real, imag }
    }

    fn disp(&self) {
        println!("{}+{}i", self.real, self.imag)
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            67. Ders 24/11/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta operatör metotları trait tabanlıdır. Yani operatör metotlarını oluşturabilmek için özel bazı trait'lerin desteklenmesi 
    gerekmektedir. Rust derleyicisi ilgili tür bu özel trait'leri destekliyorsa bu türlere ilişkin operatörler kullanıldığında 
    türde desteklenen trait'lerin ilgili metotlarını çağırmaktadır. Örneğin Sample yapısı eğer std::ops::Add trait'ini 
    destekliyorsa bu trait'te bulunan add metodunu barındırmak zorundadır. Derleyici de iki Sample değerinin + operatörüyle 
    toplandığını gördüğünde bu add metodunu çağırır. Yani Rust derleyicisi aslında operatörleri metot çağrılarına dönüştürmektedir. 
    Tutarlılığın sağlanması için i32, i64, f64 gibi temel türlerin de bu trait'leri desteklediği varsayılmaktadır. Yani 
    örneğin a ve b i32 türündense a + b işlemi Rust'a göre i32 yapısının add metodu tarafından yapılmaktadır. Tabii aslında 
    temel türler için Rust bir metot çağırmaz. Ancak semantik bütünlük sağlansın diye sanki temel türler de birer yapı 
    gibi ele alınmıştır.

    Rust'ta operatör metotlarının yazılması için gereken tüm trait'ler std::ops modülünde bulunmaktadır. Biz genellikle 
    örneklerimizde bu trait'leri nitelikli olarak değil use deyimi ile niteliksiz olarak kullanacağız. 

    Rust'ta operatörlerin çoğu için operatör metodu yazılabilmektedir. Ancak aşağıdaki operatörler için operatör metotları 
    yazılamamaktadır:

    =
    &&
    ||
    ..
    ..=
    .

    Biz kursumuzda operatörleri tek tek ele alıp bunlar için hangi trait'lerin desteklenmesi gerektiğini tek tek açıklayacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Operatör metotları konusunu birkaç örnek yapı ile ele alacağız. Bunlardan biri rasyonel sayıları temsil eden Rational 
    yapısıdır. Bilindiği gibi rasyonel sayılar a ve b tamsayı olmak üzere a / b biçimindeki sayılardır. Tabii burada b'nin 
    0 olmaması gerekir. Rational yapısının iskeleti şöyle oluşturulabilir:

    struct Rational {
        a: i64,
        b: i64
    }

    impl Rational {
        fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
            if b == 0 {
                return Err("invalid rational number");
            }
            if b < 0 {
                a = -a;
                b = -b;
            }

            let mut result = Rational { a, b};
            result.simplify();
            Ok(result)
        }

        fn gcd(mut a: i64, mut b: i64) -> i64 {
            if a == 0 { return b; }
            if b == 0 { return a; }
            while b != 0 {
                let r = a % b;
                a = b;
                b = r;
            }
            a
        }

        fn simplify(&mut self) {
            let gcd = Self::gcd(self.a.abs(), self.b.abs());

            self.a /= gcd;
            self.b /= gcd;
        }

        fn disp(&self) {
            if self.a == 0 {
                println!("0");
            }
            else if self.b == 1 {
                println!("{}", self.a);
            }
            else {
                println!("{}/{}", self.a, self.b);
            }
        }
    }

    Burada rasyonel sayılar new ilişkili fonksiyonuyla yaratılmalıdır. Bu iskelet yapıyı aşağıdaki gibi bir kodla test 
    edebiliriz:

    fn main() {
        let x = Rational::new(4, 8).unwrap();

        x.disp();           // 1/2
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    + operatörü için std::ops modülündeki Add trait'i kullanılmaktadır. Add trait'i şöyle tanımlanmıştır:

    pub trait Add<Rhs = Self> {
        type Output;

        // Required method
        fn add(self, rhs: Rhs) -> Self::Output;
    }

    Add trait'inin generic olduğuna dikkat ediniz. Bu trait'in Rhs isimi generic parametresi default olarak Self türünü 
    almıştır. Buradaki Self Add anlamına gelmemektedir. Bu trait'i destekleyen tür anlamına gelmektedir. Yani örneğin 
    bu Add trait'ini eğer Rational yapısı desteklerse buradaki Rhs default olarak Rational anlamına gelir. Ayrıca trait'in 
    Output isimli bir ilişkili türü de vardır. Add trait trait'ini destekleyen türde add metodu yazılmak zorundadır. add 
    metodunun ilk parametresi trait'i destekleyen tür türündendir. İkinci parametresi Rhs türünden olduğuna göre default 
    olarak o da Add trait'ini destekleyen tür türündendir. Metodun geri geri dönüş değeri ilişkili tür türündendir. 
    O halde biz Rational yapımızda Add trait'ini şöyle destekleyebiliriz:

    impl Add for Rational {
        type Output = Rational;

        fn add(self, other: Rational) -> Rational {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Burada yalnızca Add demekle Add<Raional> demek arasında bir fark yoktur. Bu durumda add metodunun her iki parametresi 
    de Rational türündendir. add metodunun geri dönüş değerinin türünün Output ilişkili türüyle belirlendiğini anımsayınız. 
    Bu durumda bu metodun geri dönüş değeri de Rational türündendir. Özetle buradaki add metodu iki Rational değerini alıp 
    bunları toplar ve topama ilişkin Rational değeriyle geri döner. 

    Add trait'inde self parametresinin &self biçiminde olmadığına self biçiminde olduğuna dikkat ediniz. Benzer biçimde 
    add metodunun ikinci parametresi de referans değildir. O halde add metoduna biz Rational değişkenlerini geçirdiğimizde 
    Rational türü Copy türünden olmadığı için sahiplik devri yapmış oluruz. Yani add metodundan sonra artık bu değişkenleri 
    kullanamayız. Buradaki aktarımın ödünç alma biçiminde değil de taşıma biçiminde yapıldığına dolayısıyla da çağrımın 
    "call by reference" biçiminde değil "call by value" biçiminde yapıldığına dikkat ediniz. 

    Aşağıda Add trait'ini destekleyen Rational örneği bir bütün olarak verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::Add;

fn main() {
    let x = Rational::new(1, 3).unwrap();
    let y = Rational::new(2, 4).unwrap();
    let result: Rational;

    result = x.add(y);      // result = x + y;
    result.disp();
}

struct Rational {
    a: i64,
    b: i64
}

impl Rational {
    fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
        if b == 0 {
            return Err("invalid rational number");
        }
        if b < 0 {
            a = -a;
            b = -b;
        }

        let mut result = Rational { a, b};
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        if a == 0 { return b; }
        if b == 0 { return a; }
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a /= gcd;
        self.b /= gcd;
    }

    fn disp(&self) {
        if self.a == 0 {
            println!("0");
        }
        else if self.b == 1 {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            68. Ders 26/11/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    std::ops öodülündeki bir operatöre ilişkin trait bir yapı ya da enum türü tarafından desteklendiğinde artık metot çağrısı
    yerine doğrudan metodun temsil ettiği operatör kullanılabilir. Bu durumda derleyici operatör ifadesini gördüğünde operatörün 
    operand'karın trait metoduna argümanm olarak geçirir ve operatör metodunu çağırır. Çağrılan metodun geri dönüş değeri 
    operatörün ürettiği değeri oluşturmaktadır. 
    
    Op trait'inin iki operand'lı bir operatöre ilişkin trait olduğunu bunun da metodunun op isminde olduğunu kabul edelim. 
    Bu durumda aşağıdaki iki ifadeşlem eşdeğerdir:

    a op b
    a.op(b)

    Yani örneğin a + b ifadesi aslında a.add(b) ifadesiyle eşdeğerdir. İki operand'lı operatörlerde derleyici her zaman 
    sol taraftaki operand'ın türüne ilişkin türde ilgili operatör metodunu aramaktadır. Yani örneğin a + b ifadesinde a 
    operand'ının Sample isimli yapı türünden olduğunu varsayalım. Bu durumda ifadenin geçerli olması için Sample yapısının 
    std::ops::Add trait'ini destekliyor olması gerekmektedir. Buradaki metodun self parametresine b ise diğer parametresine 
    aktarılacaktır. İki operand'lı operatörlere ilişkin trait metotlarının toplamda iki parametresinin olduğuna dikkat 
    ediniz. Parametrelerden biri self paramatresidir ve bu parametre soldaki operand'ı temsil eder. Diğer parametre ise 
    sağdaki operand'ı temsil eder. 

    Şimdi de Op trait'inin tek operand'lı bir oprratöre ilişkin olduğunu varsayalım. Yine bu Op trait'inin operatör işlemini 
    yapan op isimli metodu bulunuyor olsun. Bu durumda aşağıdaki iki ifade birbirleriyle eşdeğerdir:

    op a
    a.op()

    Burada artık operatör metodunun yalnızca self parametresinin olduğuna dikkat ediniz. operand doğrudan metodun self 
    parametresine atanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    op1 ve op2 iki operand'lı iki operatör belirtiyor olsun. a op1 b op2 c ifadesinde operatör önceliğine göre önce a op1 b 
    işleminin yapıldığını varsayalım. Bu durumda a op1 b işleminden elde edilen değerin türü de ilgili operatör metodunu 
    destekliyorsa a op1 b op2 c işlemi geçerli olur. Bu da a.op1(b).op2(c) ifadesiyle eşdeğer olacaktır. Örneğin a +  b + c
    ifadesinin eşdeğeri a.add(b).add(c) biçimindedir. Yani operatörler bu biçimde kombine edilebilmektedir. Örneğin:

    let x = Rational::new(1, 3).unwrap();
    let y = Rational::new(1, 2).unwrap();
    let z = Rational::new(3, 2).unwrap();
    let result: Rational;

    result = x + y + z;     // result = x.add(y).add(z);
    result.disp();

    Burada x + y + z ifadesinin x.add(y).add(z) ile eşdeğer olduğuna dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi add metodunun parametik yapısında self parametresi ve diğer parametre referans değildir. 
    Dolayısıyla eğer söz konusu tür Copy türünden değilse değişkenler taşınır. Biz de artık bu değişkenleri işlem 
    sonrasında kullanamayız. Örneğin:

    let x = Rational::new(1, 3).unwrap();
    let y = Rational::new(1, 2).unwrap();
    let z = Rational::new(3, 2).unwrap();
    let mut result: Rational;

    result = x + y + z;             // result = x.add(y).add(z);
    result.disp();

    x.disp();                       // error!
    y.disp();                       // error!
    z.disp();                       // error!

    Burada x, y ve z değişkenleri taşındığı için x + y + z işleminden sonra onları kullanamayız. Tabii biz Rational yapısını 
    Copy türü olarak tanımlarsak bu durumda artık değişkenler taşınmaz. Dolayısıyla yukarıdaki kod error oluşturmaz:

    #[derive(Copy, Clone)]
    struct Rational {
        a: i64,
        b: i64
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örnekte iki rasyonel sayıyı toplayacak bir add metodu yazdık. Peki bir rasyonel sayı ile o rasyonel sayının 
    türü ile uyumlu olan (örneğimizde i64) bir tamsayıyı toplayabilir miyiz? Örneğin:

    let x = Rational::new(1, 3).unwrap();
    let result: Rational;

    result = x + 1;         // error!

    Bu işlem matematikte geçerlidir. Ancal bizim yazmış olduğumuz add metodu bu işlem için kullanılamaz:

    impl Add for Rational {
        type Output = Rational;

        fn add(self, other: Rational) -> Rational {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Çünkü bu add metodu ikinci operand'ı Rational beklemektedir. İşte bu işlemin yapılabilmesini Add trait'ini desteklerken 
    açıkça generic türü belirterek sağlayabiliriz. Anımsayacağınız gibi iki operand'lı operatör metotlarına ilişkin trait'lerin 
    generic parametreleri sağ  taraf taraftaki operand'ın türünü belirtiyordu. Bu durumda x + 1 gibi bir işlemin de yapılabilmesini
    şöyle sağlayabiliriz:

    impl Add<i64> for Rational {
        type Output = Rational;

        fn add(self, other: i64) -> Rational {
            let a = other * self.b + self.a;
            let b = self.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Buradaki add metodu artık bir Rational değeri ile i64 değerini toplayıp sonucu Rational olarak vermektedir. Bırada 
    bizim Rational yapımızdaki pay ve payda değerleri (a ve b alanlarını kastediyoruz) i64 türündendir. Dolayısıyla Rust'ın
    "aynı türler üzerinde işlem yapabilme" tasarımına uygun bakımından bir Rational değeri ile i64 türünden bir değeri toplayacak
    operatör metodunun yazılması uygun olur. Peki biz aynı zamanda bir Rational değeir ile i32 değerini de toplayabilmek 
    istersek bunu nasıl sağlayabiliriz? En bazriz yöntem i32 türü için yeni bir impl bloğu oluşturmaktır:

    impl Add<i32> for Rational {
        type Output = Rational;

        fn add(self, other: i32) -> Rational {
            let a = other as i64 * self.b + self.a;
            let b = self.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Tabii aslında bu metodunun içi zaten var olan operatör metodunu çağıracak biçimde de yazılabilir:

    impl Add<i32> for Rational {
        type Output = Rational;

        fn add(self, other: i32) -> Rational {
        self + other as i64
        }
    }

    Peki buradaki add metodunu da generic yapabilir miydik? Biz operatör metotlarının generic'lerle kullanılması konuusunu 
    ileride ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz Rust'taki i32, i64, f64 gibi temel türlerin de (primitive types) birer yapı belirttiğini söylemiştik. Daha önceden 
    de bu türlerle sqrt gibi abs gibi metotları çağırdığımızı anımsayınız. İşte aynı zamanda bu türler Rust'ta bu operatör 
    trait'lerini desteklemektedir. Örneğin:

    let a = 10;
    let b = 20;
    let result: i32;

    result = a + b;

    Tıpkı diğer yapılarda olduğu gibi a + b iafdesi yine i32 yapısı için de a.add(b) ifadesiyle eşdeğerdir. Örneğin:

    result = a.add(b);      // geçerli

    Rust'ta aşağıdaki gibi bir ifade geçerlidir:

    result = 10.add(20);      // geçerli

    Sabitler de aslında ilgili türden değer belirttiğine göre doğrudan sabitler kullanılarak da metotlar çağrılabilmetedir. 

    Aklınıza şöyşe bir soru geşebilir: a ve b örneğin i32 türünden olsa a + b işlemini yapmak için derleyici gerçekten 
    bir metot mu çağırmaktadır? Tabii ki hayır. Kodun gözlemlenebilir işlevi değişmedikten sonra derleyici kodu istediği 
    gibi değiştirebilir. Biz Rust'ta a.add(b) yapmış olsak bile Rust derleyicisi yine tek bir makine komutu ile bu iki sayıyı
    toplayacaktır. Özetle her ne kadar Rust'taki temel ütrler birer yapıysa da aslında kod üretimi bakımından bunların C'deki
    temel türlerden bir farkı yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi matematikte + ve * gibi işlemlerin değişme özelliği vardır. Yani örneğin matematikte a + b ile b + a arasında 
    hiçbir farklılık yoktur. İşte operatör metotlarını yazarken eğer operatörün değişme özelliği varsa bu değişme özelliğini 
    sizin sağlamanız iyi bir tekniltir. Örneğin yukarıdaki örnekte bir Rational değeri ile bir i64 değeri x + 1 gibi bir ifade 
    ile toplanabilmektedir. O halde bunun terisinin de sağlanması iyi bir tekniktir. Yani nasıl x + 1 geçerliyse 1 + x'te geçerli 
    olmalıdır. Örneğin x Rational yapısı türüden a da temel türlerden olsun. x + a ifadesinin eşdeğeri x.add(a) biçimindedir. 
    Ancak a + x ifadesinin eşdeğeri a.add(x) biçimindedir. Temel türlerde add metodu bulunmaktadır. Ancak parametresi Rational 
    olan bir Add metodu bulunmamaktadır. İşte a + x gibi bir ifadenin yazılanilmesi için bizim a değerinin ilişkin olduğu yapı 
    için kendimizin bir add metodu yazmamız gerekir. Örneğin:

    impl Add<Rational> for i64 {
        type Output = Rational;

        fn add(self, other: Rational) -> Rational {
            other + self
        }
    }

    Add trait'inin generic parametresinin sağdaki operand'ın türünü belirttiğini anımsayınız. O halde burada sağdaki operand
    Rational türünden olacaktır. soldaki self opereran'ı destek verdiğimiz yapıya ilişkinidir. Yani örneğimizde i64 türündendir. 
    O halde buradaki add metodu sol taraftaki operand'ı i64 olan, sağ taraftaki operand'ı Rational olan ve Rational türünden 
    bir değerle geri dönne metottur. Tabii biz zaten daha önce Rational + i64 işlemini yapan metodu yazmıştık. O halde bu 
    metodun içini yeniden yazmak yerine yazmış olduğumuz metodu çağırmak daha uygundur. Peki x Rational tründen olmak üzere
    1 + x işlemindeki 1 derleyici için hangi türden ele alınacaktır. Anımsanacağı gibi Rust'ta bu tür durumlarda sabit 
    için tür belirlemesi bağlamdan hareketle tespit edilmektedir. 1 + x işlemini yapabilecek add metodu i64 yapısı için 
    yazıldığından dolayı derleyici buradaki 1 değerininin i32 türünden değil i64 türünden olduğunu kabul edecektir. Yani 
    bir sorun oluşmayacaktır. Tabii biz bu örneğimizde hem i32 için hem de i64 için add metodunu yazmış olsaydık 1 + x
    gibi bir işlemde artık i32 türü için yazdığımız add kullanılacaktı.

    Aşağıda açıkladığımız durumların gerçekleştirildiği örneği bir bütün olarak veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::Add;

fn main() {
    let x = Rational::new(1, 3).unwrap();
    let result: Rational;

    result = 1 + x;
    result.disp();
}

#[derive(Copy, Clone)]
struct Rational {
    a: i64,
    b: i64
}

impl Rational {
    fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
        if b == 0 {
            return Err("invalid rational number");
        }
        if b < 0 {
            a = -a;
            b = -b;
        }

        let mut result = Rational { a, b};
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        if a == 0 { return b; }
        if b == 0 { return a; }
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a /= gcd;
        self.b /= gcd;
    }

    fn disp(&self) {
        if self.a == 0 {
            println!("0");
        }
        else if self.b == 1 {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<i64> for Rational {
    type Output = Rational;

    fn add(self, other: i64) -> Rational {
        let a = other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<i32> for Rational {
    type Output = Rational;

    fn add(self, other: i32) -> Rational {
        let a = other as i64 * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<Rational> for i64 {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        other + self
    }
}

impl Add<Rational> for i32 {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        other + self
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Operatör metotlarına ilişkin trait'lerdeki metotların parametreleri referans değildir. Bu durumda daha önceden de belirtitğimiz 
    gibi "call by value" işlemi yapılmaktadır. Tabii eğer söz konusu türler Copy türünden değilse aslında derleyici gerçek 
    anlamda bir taşıma işlemi yapmaz. Arka planda bir görmüyor olsak bile aktarımı adres yoluyla yapabilmektedir. Söz konusu 
    tür Copy türünden olsa bile eğer parametre değişkenleri mut değilse derleyici yine optimizasyon yaparak "call by value" 
    yerine "call by reference" uygulayabilmektedir. Yani Rust'ta aslında çoğu durumda biz "call value" semnatiğini uyguluyor 
    olsak bile derleyici arka planda "call by reference" uygulayabilmektedir. Dolayısıyla aslında "call by value" durumunun 
    yaratacağı dezavantaj çoğu durumda derleyicilerin optimizasyonu sayesinde elimine edilmektedir. Bu durumu şöyle özeteyebiliriz:

    - Parametre Copy türünden değil referans da değil: Derleyici optimizasyon sırasında "call by referance" yapabilir. 
    - Parametre Copy türünden ancak parametre mut değil: Derleyici optimizasyon sırasında "call by referance" yapabilir. 
    - Parametre Copy türünden değil ancak mut: Derleyici optimizasyon sırasında "call by referance" yapamaz.

    Peki yine de biz operatör metotlarına aktarımı açıkça "call by reference" ile yapabilir miyiz? Aslında yapabiliriz. 
    Ancak Rust'taki referansların C++'taki referanslar gibi olmadığını anımsayınız. Rust'ta bir referansa atama yapılırken
    atanacak değer referans türünden değilse açıkça bizim & operatörüyle adres almamız gerekir. Operatör fonksiyonlarının 
    "call by reference" biçiminde çağrılmasını sağlayabilmek için akla gelen ilk yöntem trait'teki generic parametreyi 
    referans yapmaktır. Tabii desteklenecek türün de referans yapılması gerekiri Örneğin:

    impl Add<&Rational> for &Rational {
        type Output = Rational;

        fn add(self, other: &Rational) -> Rational {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Burada trait kurallarına uyulmuştur. Add trait'inin generic parametresi &Rational biçimdedir. O halde artık add metodunun
    ikinci parametresi Rational türünden değil &Rational türünden olacaktır. add metodunun self parametresini &self biçiminde 
    yazamayız. Çünkü bu durum trait'te belirtilen imzaya uymamaktadır. Birinci paranetreyi self biçiminde tutarak onun 
    referans belirtmesini sağlamak için desteğin referans türüne yapılması gerekmektedir. Destek sentaksındaki for anahtar 
    sözcüğünün sağındaki türün Rational olmadığına &Rational olduğuna dikkat ediniz. Bu durumda self parametresi artık 
    &Rational türünden olacaktır. Görüldüğü gibi artık her iki operand'ın da aktarımı "call by reference" biçiminde yapılmaktadır. 
    Bu aktarım biçimi C++'taki operatör fonksiyonlarına benzer hale gelmiştir. Ancak maalesef Rust'ta böyle bir tasarım 
    okunabilirliği oldukça bozmaktadır. Çünkü bu tasarımda biz iki Rational değerini toplayabilmemiz için onların adreslerini 
    açıkça bizim gerekir. Örneğin:

    let x = Rational::new(1, 3).unwrap();
    let y = Rational::new(1, 2).unwrap();
    let result: Rational;

    result = x + y;         // error!

    Bizim artık bu işlemi şöyle yapmamız gerekir:

    result = &x + &y;         // geçerli

    Biz operatör metotları okunabilirlik ifade gücü sağlamak amacıyla kullanılmaktadır. Halbuki bu son durum okunabilirliği 
    tamamen bozmaktadır. Peki bu işlemi gerçekten x + y ifadesiyle yapabilmenin bir yolu yok mudur? 
    
    Yukarıdaki referanslı biçimde aslında generic parametrenin belirtilmesine gerek yoktur. Generic parametrenin defalt türü 
    Self olduğuna göre ve buradaki Self de &Rational anlamına geleceğine göre generic tür belirtilmeyebilir. Örneğin:

    impl Add for &Rational {
        type Output = Rational;

        fn add(self, other: &Rational) -> Rational {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    Burada zaten generic parametre &Rational türündendir. Tabii biz her zaman impl bloğu içerisinde impl türü için Self 
    anahtar sözcüğünü de kullanabiliriz. Yani add metodunun ikinci parametresi için &Rational yerine Self de fiyebilirdik:

    impl Add for &Rational {
        type Output = Rational;

        fn add(self, other: Self) -> Rational {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            69. Ders 01/12/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda + operatörü için operatör metodu yazdık. Ancak dört temel aritmetik operatörün yazımı birbirine çok benzerdir. 
    Yalnıcza trait'ler farklıdır. Örneğin çıkartma - operatörü için Sub trait'i, * operatörü için Mul trait'i, / operatörü için
    ise Div trait'i kullanılmaktadır. Yukarıda da belirttiğimiz gibi temel aritmetik operatörlere ilişkin bu trait'lerin 
    genel kullanımı birbirine çok benzerdir. Yalnıca metotlar isimleri farklıdır. Aşağıda bu dört trait'in tanımını veriyoruz:


    pub trait Add<Rhs = Self> {
        type Output;

        // Required method
        fn add(self, rhs: Rhs) -> Self::Output;
    }

    pub trait Sub<Rhs = Self> {
        type Output;

        // Required method
        fn sub(self, rhs: Rhs) -> Self::Output;
    }

    pub trait Mul<Rhs = Self> {
        type Output;

        // Required method
        fn mul(self, rhs: Rhs) -> Self::Output;
    }

    pub trait Div<Rhs = Self> {
        type Output;

        // Required method
        fn div(self, rhs: Rhs) -> Self::Output;
    }

    Şimdi Rational yapımıza - operatör desteğini verelim. Bunun için yazmamız gereken impl blokları şöyledir:

    impl Sub for Rational {
        type Output = Rational;

        fn sub(self, other: Rational) -> Rational {
            let a = self.a * other.b - self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b};
            result.simplify();
            result
        }
    }

    impl Sub<i64> for Rational {
        type Output = Rational;

        fn sub(self, other: i64) -> Rational {
            let a = -other * self.b + self.a;
            let b = self.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl Sub<Rational> for i64 {
        type Output = Rational;

        fn sub(self, other: Rational) -> Rational {
            let a = self * other.b - other.a;
            let b = other.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    Şimdi de Rational yapımıza * operatörü desteği verelim. Yazmamız gereken impl blokları da şöyledir:

    impl Mul for Rational {
        type Output = Rational;

        fn mul(self, other: Rational) -> Rational {
            let a = self.a * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl Mul<i64> for Rational {
        type Output = Rational;

        fn mul(self, other: i64) -> Rational {
            let a = self.a * other;
            let b = self.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl Mul<Rational> for i64 {
        type Output = Rational;

        fn mul(self, other: Rational) -> Rational {
            other * self
        }
    }

    Rasyonel sayılarda bölme işleminin sağdaki operand'ın tersiyle çarpma anlamına geldğini anımsaınız. Bu durumda Rational 
    yapımıza bölme detsteğini vermek için yazmamız gereken şmpl blokları şöyledir:

    impl Div for Rational {
        type Output = Rational;

        fn div(self, other: Rational) -> Rational {
            let a = self.a * other.b;
            let b = self.b * other.a;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl Div<i64> for Rational {
        type Output = Rational;

        fn div(self, other: i64) -> Rational {
            let a = self.a;
            let b = self.b * other;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl Div<Rational> for i64 {
        type Output = Rational;

        fn div(self, other: Rational) -> Rational {
            let a = self * other.b;
            let b = other.a;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    % operatörü için Rem ("Remainder" isminden geiyor) isimli trait kullanılmaktadır. Bu trait aşağıdaki gibi tanımlanmıştır:

    pub trait Rem<Rhs = Self> {
        type Output;

        // Required method
        fn rem(self, rhs: Rhs) -> Self::Output;
    }

    Kullanım biçiminin diğer artimetik operatörlerle aynı olduğuna dikkat ediniz. 

    Rational yapımıza % operatörü desteği vermek biraz zorlama olacaktır. Ancak biz yine de z bir Rational değeri k da i64
    türündne olmak üzere z % k işlemini yapan bir % operatör metodunu Rationa yapısına ekleyelim. Bu işlemin sonucu da 
    rasyonel sayının gerçek sayı karşılığının k değerine bölümünden elde edilen kalan olsun. Bu işlemin ürettiği değerin 
    f64 olması daha anlamlıdır:

    impl Rem<i64> for Rational {
        type Output = f64;

        fn rem(self, other: i64) -> f64 {
            (self.a as f64 / self.b as f64) % other as f64
        }
    }

    Aşağıda beş operatörü destekleyen Rational yapısını bir bütün olarak veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::{Add, Sub, Mul, Div, Rem};

fn main() {
    let x = Rational::new(20, 3).unwrap();
    let y = Rational::new(1, 3).unwrap();
    let result: f64;

    result = x % 2;
    println!("{} ", result);


}

#[derive(Copy, Clone)]
struct Rational {
    a: i64,
    b: i64
}

impl Rational {
    fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
        if b == 0 {
            return Err("invalid rational number");
        }
        if b < 0 {
            a = -a;
            b = -b;
        }

        let mut result = Rational { a, b};
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        if a == 0 { return b; }
        if b == 0 { return a; }
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a /= gcd;
        self.b /= gcd;
    }

    fn disp(&self) {
        if self.a == 0 {
            println!("0");
        }
        else if self.b == 1 {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<i64> for Rational {
    type Output = Rational;

    fn add(self, other: i64) -> Rational {
        let a = other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<Rational> for i64 {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        other + self
    }
}

impl Sub for Rational {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self.a * other.b - self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Sub<i64> for Rational {
    type Output = Rational;

    fn sub(self, other: i64) -> Rational {
        let a = -other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Sub<Rational> for i64 {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self * other.b - other.a;
        let b = other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul for Rational {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        let a = self.a * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<i64> for Rational {
    type Output = Rational;

    fn mul(self, other: i64) -> Rational {
        let a = self.a * other;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<Rational> for i64 {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        other * self
    }
}

impl Div for Rational {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self.a * other.b;
        let b = self.b * other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<i64> for Rational {
    type Output = Rational;

    fn div(self, other: i64) -> Rational {
        let a = self.a;
        let b = self.b * other;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<Rational> for i64 {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self * other.b;
        let b = other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Rem<i64> for Rational {
    type Output = f64;

    fn rem(self, other: i64) -> f64 {
        (self.a as f64 / self.b as f64) % other as f64
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatörlerine ilişkin operatör metotları için PartialEq ve PartialOrd trait'leri kullanılmaktadır. PartialOrd
    trait'i zaten PartialEq trait'inden türetilmiştir. Yani PartialOrd trait'ini destekleyenler mecburen PartialEq trait'ini 
    de desteklemesi gerekir. Bu trait'ler std::cmp modülünde (std::ops modülünde değil) aşağıdaki gibi tanımlanmışlardır:

    pub trait PartialEq<Rhs = Self>
    where
        Rhs: ?Sized,
    {
        // Required method
        fn eq(&self, other: &Rhs) -> bool;

        // Provided method
        fn ne(&self, other: &Rhs) -> bool { ... }
    }

    pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs>
    where
        Rhs: ?Sized,
    {
        // Required method
        fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

        // Provided methods
        fn lt(&self, other: &Rhs) -> bool { ... }
        fn le(&self, other: &Rhs) -> bool { ... }
        fn gt(&self, other: &Rhs) -> bool { ... }
        fn ge(&self, other: &Rhs) -> bool { ... }
    }

    Trait isimlerindeki "Partial" öneki kafanızı karıştırabilir. Trait'lere bu "Partial" önekleri "kısmi sıralama ilişkisini 
    (partial ordering relation)" vurgulamak içindir. Sıralama teorisinde bir kümenin elemanları belli bir sıraya göre 
    konumlandırılabilmektedir. Eğer kümenin tüm elemanları birbirleriyle sırasal olarak karşılaştırılabiliyorsa buna matematikte
    "tam sıralama (total ordering)" denilmektedir. Eğer kümenin bazı elemanları birbirleriyle sırasal olarak karşılaştırılamıyorsa
    buna da "kısmi sıralama (partial ordering)" denilmektedir. Örneğin tamsayılar kümesinde <= işlemini ele alalım. Biz bu 
    işlemle tüm tamsayıları bir sıraya dizebiliriz. Biz <= operatörünü kullanarak tüm tamsayıları sıraya dizebiliriz. Ancak 
    bilgisayardaki f64 gibi gerçek sayı türleri <= operatörü dikkate alındığında tam sıralama değil kısmı sıralama özelleğine 
    sahiptir. Çünkü her f64 türünden değer <= operatörüyle karşılaştırılamamaktadır. Çünkü anımsayacağınız gibi f64 türü 
    IEEE 754 standartlarına uymaktadır. Dolayısıyla bazı f64 değerleri NaN (Not a Number) olabilmektedir. NaN değeri ile 
    bir gerçek sayı değeri <= operatörüyle karşılaştırılamaz. O halde "kısmi sıralama (partial orddering)" söz konusu olduğunda
    iki değeri karşılaştırdımızda dört durum oluşabilmektedir:

    Büyüktür
    Küçüktür
    Eşittir
    Karşılaştırılamaz

    İşte bu nedenle izleyen paragraflarda göreceğimiz gibi PartialOrd işleminden bir Option<Ordering> değeri elde edilmektedir. 
    
    PartialEq ve PartialOrd trait'lerinin ilk parametresine dikkat ediniz. Bu ilk parametre self biçiminde değil &self 
    biçimindedir. Yani karşılaştırma işlemlerinde sahiplik devredilmemektedir. Bu operatör metotlarının ikinci parametreleri 
    de referans biçimindedir. Yani "call by reference" durumu söz konusudur. 

    PartialEq ve PartialOrd trait'lerinde tek bir metodun zorunlu olduğuna dikkat ediniz. Çünkü bu zorunlu metotlar programcı 
    tarafından yazılırsa zaten diğer metotlar bu zorunlu metot kullanılarak yazılabilmektedir. Örneğin PartialEq trait'inde 
    zorunlu metot eq metodudur. Eğer programcı eq metodunu yazarsa ne metodunu yazmayabilir. Çünkü zaten eq metodu çağrılarak 
    ne değeri elde edilebilmektedir. PartialOrd trait'indeki zorunlu metoda dikkat ediniz:

    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    Bu metot Option<Ordering> değerine geri dönmektedir. Ordering bir enum türüdür ve std::cmp modülünde aşağıdaki gibi 
    tanımlanıştır:

    pub enum Ordering {
        Less = -1,
        Equal = 0,
        Greater = 1,
    }

    O halde aslında Option<Ordering> türü Less, Equal, Greater ya da None değeri veren bir türdür. Programcı bu zorunlu metodu 
    yazarken eğer iki değer karşılaştırılamaz biçimdeyse Option<Ordering>::None değerine geri dönmektedir. PartialOrd trait'inde
    lt, le, gt, ge metotları partial_cmp metodu kullanılarak yazılmıştır. Dolayısıyla bu trait'te programcının tek yazması 
    gereken metot partial_cmp metodudur. Aşağıda karşılaştırma işlemlerinin eşdeğer metot karşılıkları verilmiştir:

    a == b  eşdeğeri a.eq(&b)
    a != n  eşdeğeri a.ne(&b)
    a < b   eşdeğeri a.lt(&b)
    a <= b  eşdeğeri a.le(&b)
    a > b   eşdeğeri a.gt(&b)
    a >= b  eşdeğeri a.ge(&b)

    Rust'taki temel türlerin hepsi PartialEq ve PartialOrd trait'lerini desteklemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi Rational yapısında için PartialEq trait'ini destekleyerek iki Rational yapısının == ve != operatörleriyle karşılatırılmasını
    sağlayalım. Bunun için yalnızca zorunlu eq metodunu yazmamız yeterlidir:

    impl PartialEq for Rational {
        fn eq(&self, other: &Rational) -> bool {
            self.a == other.a && self.b == other.b
        }
    }

    Biz rasyonel sayıları sadeleştirerek a ve b alanlarında tuttuğumuz için iki rasyonel sayısının eşitliğini yukarıdaki gibi 
    sorgulayabilmekteyiz. 

    Şimdi de Rational yapısına <, >, <= ve >= operatör desteğini verelim. Bunun için PartialOrd trait'indeki partial_cmp 
    metodunu yazmamız gerekir. partial_cmp metodu Option değerine geri dönmektedir. Ancak rasyonel sayılar zaten "tam sıralamaya
    (total ordering)" uygundur. Dolayısıyla bizim partial_cmp metodumuz aslında hin None değerine geri dönmeyecektir. 
    Peki iki rasyonel sayıyı nasıl karşılaştırabiliriz? Akla gelecek ilk yöntem bu rasyonel sayıların payını paydasına bölüp
    bunlardan gerçek sayı elde etmek ve bu gerçek sayıları karşılaştırmaktır. Bu yöntem çoğu durumda yeterli olabilir. 
    Ancak yuvarlama hatalarından dolayı farklı iki değer aynı değere uvarlanabilmektedir. Daha sağlam bir yol bu iki rasyonel
    sayının paydalarını eşitleyip paylarını karşılaştırmaktır. Örneğin a/b rasyonel sayısı ile c/d rasyonel sayısını bu 
    yöntemle karşılaştıracak olalım. a/b kesrinin payını ve paydasını d ile c/d kesrinin payını ve paydasını da b ile çarparsak 
    paydaları eşitleyebiliriz. O halde aslında karşılaştırmayı a * d ile b * c arasında yapabiliriz:

    impl PartialOrd for Rational {
        fn partial_cmp(&self, other: &Rational) -> Option<Ordering> {
            let x = self.a * other.b;
            let y = other.a * self.b;

            if x > y {
                Some(Ordering::Greater)
            }
            else if x < y {
                Some(Ordering::Less)
            }
            else {
                Some(Ordering::Equal)
            }
        }
    }

    Aslında yukarıdaki yazım daha sade hale de getirilebilir. Tüm temel türlerin PartialEq ve PartialOrd trait'lerini 
    desteklediğini belirmiştik:

    impl PartialOrd for Rational {
        fn partial_cmp(&self, other: &Rational) -> Option<Ordering> {
            let left = self.a * other.b;
            let right = other.a * self.b;

            left.partial_cmp(&right)
        }
    }

    Aşağıda Rational yapısının son hali bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::{Add, Sub, Mul, Div, Rem};
use std::cmp::{PartialEq, PartialOrd, Ordering};

fn main() {
    let x = Rational::new(1, 2);
    let y = Rational::new(1, 3);

    if x < y {
        println!("x < y");
    }
    else if x > y {
        println!("x > y");
    }
    else if x == y {
        println!("x == y");
    }
}

#[derive(Copy, Clone)]
struct Rational {
    a: i64,
    b: i64
}

impl Rational {
    fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
        if b == 0 {
            return Err("invalid rational number");
        }
        if b < 0 {
            a = -a;
            b = -b;
        }

        let mut result = Rational { a, b};
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        if a == 0 { return b; }
        if b == 0 { return a; }
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a /= gcd;
        self.b /= gcd;
    }

    fn disp(&self) {
        if self.a == 0 {
            println!("0");
        }
        else if self.b == 1 {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<i64> for Rational {
    type Output = Rational;

    fn add(self, other: i64) -> Rational {
        let a = other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<Rational> for i64 {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        other + self
    }
}

impl Sub for Rational {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self.a * other.b - self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Sub<i64> for Rational {
    type Output = Rational;

    fn sub(self, other: i64) -> Rational {
        let a = -other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Sub<Rational> for i64 {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self * other.b - other.a;
        let b = other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul for Rational {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        let a = self.a * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<i64> for Rational {
    type Output = Rational;

    fn mul(self, other: i64) -> Rational {
        let a = self.a * other;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<Rational> for i64 {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        other * self
    }
}

impl Div for Rational {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self.a * other.b;
        let b = self.b * other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<i64> for Rational {
    type Output = Rational;

    fn div(self, other: i64) -> Rational {
        let a = self.a;
        let b = self.b * other;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<Rational> for i64 {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self * other.b;
        let b = other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Rem<i64> for Rational {
    type Output = f64;

    fn rem(self, other: i64) -> f64 {
        (self.a as f64 / self.b as f64) % other as f64
    }
}

impl PartialEq for Rational {
    fn eq(&self, other: &Rational) -> bool {
        self.a == other.a && self.b == other.b
    }
}

impl PartialOrd for Rational {
    fn partial_cmp(&self, other: &Rational) -> Option<Ordering> {
        let left = self.a * other.b;
        let right = other.a * self.b;

        left.partial_cmp(&right)
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz Rust'ta kısmi sıralamanın (partial ordering) PartialEq ve PartialOrd trait'leriyle temsil edildiğini söyledik. Rust'ta
    tam sıralama da (total ordering) Eq ve Ord (başında Partial sözcüğünün olmadığına dikkat ediniz) trait'leriyle temsil 
    edilmektedir. Bu trait'lerin operatör metotlarıya bir ilgisi yoktur. Ancak burada biz mantıksal çağrışım nedeniyle bu 
    iki trait üzerinde de durmak istiyoruz. Bu iki trait'te std::cmp modülü içerisindedir. Eq trait'inin aslında PartialEq
    trait'inden bir farkı yoktur. Eq trait'i PartialEq trait'inden türetilmiştir ve elemana sahip değildir:

    pub trait Eq: PartialEq { }

    Kısmı sıralamada == ve != operatörlerinin Option üretmediğini anımsayınız. Çünkü bir kümenin iki elemanının karşılaştırılamaz
    olması zaten == karşılaştırmasında doğrudan false != karşılaştırmasında da true elde edilmesi anlamına gelmektedir. 
    Dolayısıyla == ve != operatörleri için kısmı sıralamayla tam sıralama davranışı arasında fark yoktur.

    Ord trait'i ise Eq ve PartialOrd trait'lerinden türetilmiştir:

    pub trait Ord: Eq + PartialOrd {
        // Required method
        fn cmp(&self, other: &Self) -> Ordering;

        // Provided methods
        fn max(self, other: Self) -> Self
        where Self: Sized { ... }
        fn min(self, other: Self) -> Self
        where Self: Sized { ... }
        fn clamp(self, min: Self, max: Self) -> Self
        where Self: Sized { ... }
    }

    Yani Ord tarit'ini destekleyen bir yapı ya da enum türü Eq (dolayısıyla PartialEq) ve PartialOrd trait'lerini de 
    desteklemek zorundadır. Ord trait'inde cmp isimli zorunlu bir metot olduğuna dikkat ediniz. (PartialOrd trait'indeki
    zorunlu metodun partial_cmp biçiminde olduğunu anımsayınız.) cmp metodu Option<Ordering> üründen değil doğrudan Ordering 
    türünden bir değerle geri dönmektedir. Tam sıralamada kümenin tüm elemanları sıralanabilir olduğu için cmp metodunun 
    geri dönüş değerinin Option olmasına gerek kalmamıştır.

    Rust'ın i32 gibi, i64 gibi temel tamsayı türlerinin hepsi aynı zamanda Ord trait'ini de destekliyor durumdadır. Ancak 
    f32 ve f64 türleri yukarıda da belirttiğimiz gerekçelerle bu trait'i desteklememektedir. 

    Eq ve Ord trait'lerinin türetme dumunu aşağıdaki şekille özetleyebiliriz:

    PartialEq
        |
        |
    PartialOrd
        |
        +---> Eq
        |
        |
        Ord
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşaret - operatörü için std::ops modülündeki Neg isimli trait kullanılmaktadır. Trait şöyle tanımlanmıştır:

    pub trait Neg {
        type Output;

        // Required method
        fn neg(self) -> Self::Output;
    }

    Burada Neg trait'inin generic olmadığına ve neg metodunun parametresinin self biçiminde olduğuna dikkat ediniz. Yani 
    neg metodu sahipliği almaktadır.  Metodun geri dönüş değeri Output türündendir. Bu Output türü hemen her zaman Self 
    türüyle aynı olmaktadır. Yani örneğin bir Rational değerinin negatifini biz yine Rational olarak elde ederiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            70. Ders 03/12/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rational yapısı için - operatör metodu şöyle yazılabilir:

    impl Neg for Rational {
        type Output = Rational;

        fn neg(self) -> Rational {
            Rational { a: -self.a, b: self.b }
        }
    }

    Bir rasyonel sayının negatifinin pay kısmının negatifi alınrak aluşturulduğına dikkat ediniz. Örneğin:

    let x = Rational::new(1, 2).unwrap();
    let y: Rational;

    y = -x + x;

    y.disp();           // 0
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    +=, *=, /=, %= gibi bileşik atama operatörleri için de operatör metotalrı yazılabilmektedir. (Ancak Rust'ta zaten sahiplik 
    devri olduğu için atama operatörüne yönelik bir operatör metodu yazılamamaktadır.) Biz operatörler konusunda a += b gibi 
    bir işlemin a = a + b işlemiyle edeğer olduğunu belirtmiştik. Aslında biraz daha ayrıntıya girdeğimizde bu iki işlem 
    birbirine eşdeğer değildir. Çünkü bu işlemde farklı operatör metotları çağrılmaktadır. Biz bir yapı ya da enum türü 
    için + operatör metodunu yazmış olsak bile += operatörünü kullanamyız. Bu operatör metodunun ayrıca yazılması gerekmektedir. 
    Örneğin biz Rational yapısı için + operatör metodunu yazmıştık. Ancak aşağıdaki işlemi += operatör metodunu ayrıca 
    yazmadıktan sonra yapamayız:

    let mut x = Rational::new(1, 2).unwrap();
    let y = Rational::new(1, 3).unwrap();

    x += y;         // error!
    x = x + y;      // geçerli

    Peki neden operatörlerin normal biçimleri ve bileşik biçimleri birbirinden ayrılmıştır? Örneğin + operatörüne ilişkin 
    operatör metodunu yazdığımızda x += y neden derleyici tarafından x = x + y biçiminde ele alınmamaktadır? İşte bazen 
    x = x + y işlemiyle x += y işlemi arasında semantik farklılıklar oluşturulabilmektedir. Örneğin x = x + y işleminde 
    x + y yeni bir değer yaratırken x += y bir ekleme işleminin yapılmasını sağlayabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Artimetik operatörlere ilişkin bileşik operatörlerin ilişkin olduğu trait'ler şunlardır:

    AddAssign
    SubAssign
    MulAssign
    DivAssign
    RemAssign

    Bu trait şöyle tanımlanmıştır:

    pub trait AddAssign<Rhs = Self> {
        // Required method
        fn add_assign(&mut self, rhs: Rhs);
    }

    pub trait SubAssign<Rhs = Self> {
        // Required method
        fn sub_assign(&mut self, rhs: Rhs);
    }

    pub trait MulAssign<Rhs = Self> {
        // Required method
        fn mul_assign(&mut self, rhs: Rhs);
    }

    pub trait DivAssign<Rhs = Self> {
        // Required method
        fn div_assign(&mut self, rhs: Rhs);
    }

    pub trait RemAssign<Rhs = Self> {
        // Required method
        fn rem_assign(&mut self, rhs: Rhs);
    }

    Bu trait'lerin hepsi std::ops modülünde tanımlanmıştır. Trait'lere baktığımızda bu bileşik operatör metotlarının normal
    operatör metotlarından farklılıklarının şunlar olduğunu görmekteyiz:

    - Bu opeartörlerde bir Output ilişkili türü yoktur. Çünkü bu operatörler aslında sol taraftaki operand üzerinde güncelleme 
    işlemi yapmaktadır.

    - Bu trait metotlarının geri dönüş değerleri yokturç Yani () biçimindedir. 

    - Bu trait metotlarının self parametreleri &mut self biçimindedir. Yani bu operatörlerin sol tarafındaki operand mut olmak 
    zorundadır. 

    - Bu trait metotlarının ikinci parametresini oluşturan operand'ın sahipliği devredilmektedir. 

    - Bu trait metotlarının ismi op_assign biçimindedir. 

    Yine trait'lerin generic parametreleri sağ taraftaki operand'ın türünü belirtmektedir. Defalt tür yine sol taraftaki 
    operand'ın türündendir. 

    Örneğin biz Rational yaısı için += operatör metodunu aşağıdaki gibi yazabiliriz:

    impl AddAssign for Rational {
        fn add_assign(&mut self, other: Rational) {
            self.a = self.a * other.b + self.b * other.a;
            self.b = self.b * other.b;

            self.simplify();
        }
    }

    Burada metodun bir değere geri dönmediğine doğrudan sol taraftaki operand'ı güncellediğine dikkat ediniz. Tabii biz 
    eğer + operatör metodunu yazmışsak (Rational yapımızda yazmıştık) aynı işlemi şöyle de yapabiliriz:

    impl AddAssign for Rational {
        fn add_assign(&mut self, other: Rational) {
            *self = *self + other;
        }
    }

    Eğer derleyici hiç optimizasyon yapmasaydı ilk biçim ikinci biçimden daha hızlı çalışırdı. Ancak Rust derleyicileri 
    bu tür durumları iyi bir biçimde optimize etmektedir. Dolayısıyla pratikte iki gerçekleştirim arasında bir fark 
    oluşmamaktadır. Şimdi Rational yapısı için diğer bileşik atama operlarini yazalım:

    impl SubAssign for Rational {
        fn sub_assign(&mut self, other: Rational) {
            *self = *self - other;
        }
    }

    impl MulAssign for Rational {
        fn mul_assign(&mut self, other: Rational) {
            *self = *self * other;
        }
    }

    impl DivAssign for Rational {
        fn div_assign(&mut self, other: Rational) {
            *self = *self / other;
        }
    }

    Biz Rational yapımızda genel olarak bir Rational değerle i64 türünden değeri işleme sokuyorduk. Bu durumda aynı desteği 
    bileşik atama operatörlerine de vermimiz uygun oluar:

    impl AddAssign<i64> for Rational {
        fn add_assign(&mut self, other: i64) {
            *self = *self + other;
        }
    }

    impl SubAssign<i64> for Rational {
        fn sub_assign(&mut self, other: i64) {
            *self = *self - other;
        }
    }

    impl MulAssign<i64> for Rational {
        fn mul_assign(&mut self, other: i64) {
            *self = *self * other;
        }
    }

    impl DivAssign<i64> for Rational {
        fn div_assign(&mut self, other: i64) {
            *self = *self / other;
        }
    }

    Geldiğmiğz noktaya kadar Rational yapısının son halini aşağıda veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::{Add, Sub, Mul, Div, Rem, Neg, AddAssign, SubAssign, MulAssign, DivAssign, Not};
use std::cmp::{PartialEq, PartialOrd, Ordering};

fn main() {
    //...
}

#[derive(Copy, Clone)]
struct Rational {
    a: i64,
    b: i64
}

impl Rational {
    fn new(mut a: i64, mut b: i64) -> Result<Rational, &'static str>  {
        if b == 0 {
            return Err("invalid rational number");
        }
        if b < 0 {
            a = -a;
            b = -b;
        }

        let mut result = Rational { a, b};
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        if a == 0 { return b; }
        if b == 0 { return a; }
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a /= gcd;
        self.b /= gcd;
    }

    fn disp(&self) {
        if self.a == 0 {
            println!("0");
        }
        else if self.b == 1 {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<i64> for Rational {
    type Output = Rational;

    fn add(self, other: i64) -> Rational {
        let a = other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Add<Rational> for i64 {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        other + self
    }
}

impl Sub for Rational {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self.a * other.b - self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b};
        result.simplify();
        result
    }
}

impl Sub<i64> for Rational {
    type Output = Rational;

    fn sub(self, other: i64) -> Rational {
        let a = -other * self.b + self.a;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Sub<Rational> for i64 {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let a = self * other.b - other.a;
        let b = other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul for Rational {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        let a = self.a * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<i64> for Rational {
    type Output = Rational;

    fn mul(self, other: i64) -> Rational {
        let a = self.a * other;
        let b = self.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Mul<Rational> for i64 {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        other * self
    }
}

impl Div for Rational {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self.a * other.b;
        let b = self.b * other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<i64> for Rational {
    type Output = Rational;

    fn div(self, other: i64) -> Rational {
        let a = self.a;
        let b = self.b * other;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Div<Rational> for i64 {
    type Output = Rational;

    fn div(self, other: Rational) -> Rational {
        let a = self * other.b;
        let b = other.a;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl Rem<i64> for Rational {
    type Output = f64;

    fn rem(self, other: i64) -> f64 {
        (self.a as f64 / self.b as f64) % other as f64
    }
}

impl PartialEq for Rational {
    fn eq(&self, other: &Rational) -> bool {
        self.a == other.a && self.b == other.b
    }
}

impl PartialOrd for Rational {
    fn partial_cmp(&self, other: &Rational) -> Option<Ordering> {
        let left = self.a * other.b;
        let right = other.a * self.b;

        left.partial_cmp(&right)
    }
}

impl Neg for Rational {
    type Output = Rational;

    fn neg(self) -> Rational {
        Rational { a: -self.a, b: self.b }
    }
}

impl AddAssign for Rational {
    fn add_assign(&mut self, other: Rational) {
        *self = *self + other;
    }
}
impl SubAssign for Rational {
    fn sub_assign(&mut self, other: Rational) {
        *self = *self - other;
    }
}

impl MulAssign for Rational {
    fn mul_assign(&mut self, other: Rational) {
        *self = *self * other;
    }
}

impl DivAssign for Rational {
    fn div_assign(&mut self, other: Rational) {
        *self = *self / other;
    }
}

impl AddAssign<i64> for Rational {
    fn add_assign(&mut self, other: i64) {
        *self = *self + other;
    }
}

impl SubAssign<i64> for Rational {
    fn sub_assign(&mut self, other: i64) {
        *self = *self - other;
    }
}

impl MulAssign<i64> for Rational {
    fn mul_assign(&mut self, other: i64) {
        *self = *self * other;
    }
}

impl DivAssign<i64> for Rational {
    fn div_assign(&mut self, other: i64) {
        *self = *self / other;
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir yapı ya da enum türünden değerle [] operatürünü kullanmak isteyebiliriz. Örneğin x biizm oluşturuğumuz yapı türünden 
    bir değişken olsun. Biz bu x değişkenini x[n] biçiminde ya da x[n] = val biçiminde kullanmak isteyebiliriz. Tabii bir 
    yapının ya da enum türünün [] operatörüyle kullanılabilmesi için onun bir dizi değer tutuyor olması gerekir. Örneğin 
    yukarıda tanımladığımız Rational türünden bir değerin [] operatörüyle kullanılmasının bir anlamı yoktur. [] operatörü
    çağrışımsal olarak O(1) karmaşıklıktaki erişimlerde kullanılmaktadır. Örneğin dinamik büyütülen bir diziyi temsil eden 
    bir yapında [] operatörü anlamlıdır. Ancak elemanlara sıralı erişimin yapıldığı bir bağlı listede [] operatörü yanlış 
    anlaşılmalar yol açabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Örneğin aşağıdaki gibi bir Date yapımız olsun:

    struct Date {
        day: i32,
        month: i32,
        year: i32,
    }

    impl Date {
        fn new(day: i32, month: i32, year: i32) -> Self {
            Date { day, month, year }
        }

        fn disp(&self) {
            println!("{}/{}/{}", self.day, self.month, self.year);
        }
    }

    Biraz zorlama olsa da biz yapıya [] operatörü desteğini vermek isteyelim. [] içerisindeki değer 0, 1, ya da 2 oalbilsin.
    0 indeski yapının day elemanına, 1 indeksi month elemanına ve 2 indeksi de year elemanına erişmek için kulanılacak olsun. 
    [] operatör desteği verebilmek için iki trait kullanılmaktadır:

    pub trait Index<Idx>
    where
        Idx: ?Sized,
    {
        type Output: ?Sized;

        // Required method
        fn index(&self, index: Idx) -> &Self::Output;
    }

    pub trait IndexMut<Idx>: Index<Idx>
    where
        Idx: ?Sized,
    {
        // Required method
        fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
    }

    Index trait'i [] operatörüyle değer elde etek için, IndexMut trait'i ise değer yerleştirmek için kullanılmaktadır. Yani
    biz köşeli parantez ifadesini atama operatörünün sağında kullanırsak index metodu, solunda kullanırsak index_mut 
    metodu çağrılacaktır.  

    x bir yapı ya da enum türünden bir değişken ya da değeri belirtiyor olsun. y = x[i] işleminin eşdeğeri şöyledir:

    y = *std::ops::Index::index(&x, i);

    Benzer biçimde x[i] = y ifadesinin eşdeğeri de şöyledir:

    *std::ops::IndexMut::index_mut(&x, i) = y;

    Bu eşdeğerlik "The Rust Reference" dokümanlarında "8.2.6 Array and slice indexing expressions" başlığı altında şöyle
    açıklanmıştır:

    For other types an index expression a[b] is equivalent to *std::ops::Index::index(&a, b), or *std::ops::IndexMut::index_mut(&mut a, b) 
    in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on a repeatedly 
    to find an implementation."
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            71. Ders 10/12/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Index trait'indeki index metoduna dikkat ediniz:

    pub trait Index<Idx>
    where
        Idx: ?Sized,
    {
        type Output: ?Sized;

        // Required method
        fn index(&self, index: Idx) -> &Self::Output;
    }

    Bu metot Index trait'inin generic türü türünden bir indeks değeri alıp Output isimli ilişkili türden bir referansla 
    geri dönmektedir. Yukarıdaki Date yapımız için bu trait'i desteklemeye çalışalım:

    impl Index<usize> for Date {
        type Output = i32;

        fn index(&self, index: usize) -> &i32 {
            match index {
                0 => &self.day,
                1 => &self.month,
                2 => &self.year,
                _ => panic!("invalid date index"),
            }
        }
    }

    Index trait'inin generic parametresinin köşeli parantez içerisindeki index'in türünü belirttiğini anımsayınız. Köşeli 
    parantezler içerisinde genellikle usize türünden index değerleri bulunur. Ancak böyle bir zorunluluk yoktur. Yukarıdaki 
    örneğimize göre Date türünden bir değişken ya da değer ile [] operatörünü kullandığımızda [] içerisine usize türünden bir 
    index değeri yazmak zorundayız. index metodunun geri dönüş değerinin Output ilişkili türünden bir referans olması gerekir. 
    Biz Index trait'ini desteklerken Output ilişkili türünü i32 aldık. Bu durumda index metodunun geri dönüş değeri de &i32 
    türünden olmak zorundadır. index metodunun hemen her zaman self parametresinin içerisindeki bir değerle geri dönmesi 
    gerekir. Çünkü geri dönüş değeri için bir ömür belirtilmediğinden ömür self ile ilişkili olmak zorundadır. Biz de index
    metodunun içerisinde index 0 ise, self.day, 1 ise self.month ve 2 ise self.year alanlarının adresiyle geri döndük. index
    metotlarını yazarken geçersiz indeksler için mecburen panic! uygulamak gerekir. Operatör metodumuzun testini şöyle yapabiliriz:

    fn main() {
        let date = Date::new(10, 12, 2021);

        println!("{}/{}/{}", date[0], date[1], date[2]);
    }

    Şimdi de IndexMut trait'ini destekleyelim. IndexMut trait'inin tanımlamasına bir kez daha dikkat ediniz:

    pub trait IndexMut<Idx>: Index<Idx>
    where
        Idx: ?Sized,
    {
        // Required method
        fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
    }

    IndexMut trait'i ındex trait'inden türetilmiştir. Yani IndexMut trait'ini destekleyen programcı mutlaka Index trait'ini 
    de desteklemek zorundadır. Başka bir deyişle Rust'ta "write-only" bir [] operatör metodu yazılamamaktadır. index_mut 
    metodunun birinci parametresinin &mut self türünden olduğuna dikkat ediniz. Yani bu operatörün mutlaka mut bir değişkenle
    kullanılması gerekmektedir. index_mut metodunun geri dönüş değeri de &mut bir referanstır. IndexMut trait'inde ayrıca 
    bir Output ilişkili türünün olmadığına da dikkat ediniz. Output ilişkili türü Index trait'indeki türdür. Türemiş trait 
    taban trait'in ilişkili türlerini kullanabilmektedir. 
    
    Date yapımız için bu trait'i şöyle destekleyebiliriz:

    impl IndexMut<usize> for Date {
        fn index_mut(&mut self, index: usize) -> &mut i32 {
            match index {
                0 => &mut self.day,
                1 => &mut self.month,
                2 => &mut self.year,
                _ => panic!("invalid date index"),
            }
        }
    }

    index_mut metodunda yapılanlar index metodunda yapılanlara benzerdir. Ancak geri döndürülen referans mut bir referanstır. 
    Biz bu küçük örnekte atama sırasında herhangi bir geçerlilik sınaması yapmadık. Yani örneğin bu durumda yapıyı kullanan 
    Data yapısının alanlarına geçersiz değerler de atayabilir. Bu metodun tesitini de şöyle yapabiliriz:

    fn main() {
        let mut date = Date::new(10, 12, 2021);

        println!("{}/{}/{}", date[0], date[1], date[2]);

        date[0] = 20;
        date[1] = 8;
        date[2] = 2022;

        println!("{}/{}/{}", date[0], date[1], date[2]);
    }

    Yukarıdaki işlemlerin metot çağırma eşdeğerileri de şöyledir:

    fn main() {
        let mut date = Date::new(10, 12, 2021);

        println!("{}/{}/{}", *date.index(0), *date.index(1), *date.index(2));
        
        *date.index_mut(0) = 20;
        *date.index_mut(1) = 8;
        *date.index_mut(2) = 22;

        println!("{}/{}/{}", *date.index(0), *date.index(1), *date.index(2));
    }

    Aşağıda örneğin tamamı verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

use std::ops::{Index, IndexMut};

fn main() {
    let mut date = Date::new(10, 12, 2021);

    println!("{}/{}/{}", date[0], date[1], date[2]);
    date[0] = 20;
    date[1] = 8;
    date[2] = 2022;

    println!("{}/{}/{}", date[0], date[1], date[2]);
}

struct Date {
    day: i32,
    month: i32,
    year: i32,
}

impl Date {
    fn new(day: i32, month: i32, year: i32) -> Self {
        Date { day, month, year }
    }

    fn disp(&self) {
        println!("{}/{}/{}", self.day, self.month, self.year);
    }
}

impl Index<usize> for Date {
    type Output = i32;

    fn index(&self, index: usize) -> &i32 {
        match index {
            0 => &self.day,
            1 => &self.month,
            2 => &self.year,
            _ => panic!("invalid date index"),
        }
    }
}

impl IndexMut<usize> for Date {
    fn index_mut(&mut self, index: usize) -> &mut i32 {
        match index {
            0 => &mut self.day,
            1 => &mut self.month,
            2 => &mut self.year,
            _ => panic!("invalid date index"),
        }
    }

/*---------------------------------------------------------------------------------------------------------------------------
    [] operatör metodunda köşeli parantezler içerisine usize türünden bir index ifadesi getirilmesi zorunlu değildir. Eğer 
    bağlam uygunsa programcı kendi yapı ya da enum türünden değişken ya da değerleri başka türlerle de indeksleyebilir. Örneğin 
    bir enum türü için [] operatör metodunu aşağıdaki gibi destekleyebiliriz. Örneğin yukarıdaki Date yapımıza ilişkin bir 
    değişkeni usize türüyle değil de DateType isimli bir enum türüyle de indeskleyebiliriz:

    enum DateType {
        Day,
        Month,
        Year,
    }

    impl Index<DateType> for Date {
        type Output = i32;

        fn index(&self, index: DateType) -> &i32 {
            match index {
                DateType::Day => &self.day,
                DateType::Month => &self.month,
                DateTypeYear => &self.year,
                _ => panic!("invalid date index"),
            }
        }
    }

    impl IndexMut<DateType> for Date {
        fn index_mut(&mut self, index: DateType) -> &mut i32 {
            match index {
                DateType::Day => &mut self.day,
                DateType::Month => &mut self.month,
                DateTypeYear => &mut self.year,
                _ => panic!("invalid date index"),
            }
        }
    }

    Bu durumda artık köşeli parantezler içerisine DateType türünden bir değer de yazabiliriz. Örneğin:

    fn main() {
        let mut date = Date::new(10, 12, 2021);

        println!("{}/{}/{}", date[DateType::Day], date[DateType::Month], date[DateType::Year]);
        date[DateType::Day] = 20;
        date[DateType::Month] = 8;
        date[DateType::Year] = 2022;

        println!("{}/{}/{}", date[DateType::Day], date[DateType::Month], date[DateType::Year]);
    }

    Örneğin index'in string olduğu bir kullanımı da mümkün hale getirebiliriz:

    impl Index<&str> for Date {
        type Output = i32;

        fn index(&self, index: &str) -> &i32 {
            match index {
                "day" => &self.day,
                "month" => &self.month,
                "year" => &self.year,
                _ => panic!("invalid date index"),
            }
            }
        }

    impl IndexMut<&str> for Date {
        fn index_mut(&mut self, index: &str) -> &mut i32 {
            match index {
                "day" => &mut self.day,
                "month" => &mut self.month,
                "year" => &mut self.year,
                _ => panic!("invalid date index"),
            }
        }
    }

    Kullanım için şöyle bir örnek verebiliriz:

    fn main() {
        let mut date = Date::new(10, 12, 2021);

        println!("{}/{}/{}", date["day"], date["month"], date["year"]);
        date["day"] = 20;
        date["month"] = 8;
        date["year"] = 2022;

        println!("{}/{}/{}", date["day"], date["month"], date["year"]);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    [] operatör metoduna Range desteği de verebiliriz. Anımsanacağı gibi Range ve benzeri yapılar bir grup elemanı elde 
    etmek için kullanılıyordu. Önce Range yapısını anımsatmak istiyoruz:

    pub struct Range<Idx> {
        pub start: Idx,
        pub end: Idx,
    }

    Görüldüğü gibi yapının bir generic parametresi vardır, start ve end indeksleri aralık belirtmektedir. Şimdi aşağıdaki gibi 
    bir MyArray yapımız olsun:

    struct MyArray {
        array: [i32; 10]
    }

    impl MyArray {
        fn new(array: [i32; 10]) -> MyArray {
            MyArray {array}
        }
    }

    Burada MyArray 10 elemanlı i32 türünden array isimli bir dizi alanına sahiptir. Biz de bu yapımız için Range yapısını
    aşağıdaki gibi destekleyebiliriz:

    impl Index<Range<usize>> for MyArray {
        type Output = [i32];

        fn index(&self, range: Range<usize>) -> &[i32] {
            &self.array[range]
        }
    }

    Burada bir noktaya dikkat ediniz. Output ilişkili türü [i32] biçiminde bir dilim belirtmektedir dolayısıyla da index 
    metodunun geri dönüş değeri &[i32] biçiminde bir dizi dilim referansıdır. Ancak bu metot çağrıldığında derleyici dereferens 
    işlemini de kendisi yapmaktadır. (Dilim referanslarıyla doğrudan [] operatörünü kullanabildiğimizi anımsayınız.) Dolayısıyla 
    bizim tıpkı normal dizileri dilimlerken yaptığımız gibi dilimleme işleminden elde edilen dizi dilimiin adresini almamız gerekir. 
    Örneğin:

    let a: [i32; 10] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
    let ma = MyArray::new(a);

    let rs: &[i32] = &ma[2..5];      

    Bu işlemin eşdeğeri şöyledir:

    let rs: &[i32] = &*ma.index(2..5);

    Burada derleyicinin zaten * operatörünü uyguladığına dikkat ediniz. Biz atamayı şöyle yapamazdık:

    let rs: &[i32] = ma[2..5];  

    Çünkü bu işlemin eşdeğeri şöyledir:

    let rs: &[i32] = *ma.index(2..5);

    Bir dizi dilimi dizi dilim referansına atanamaz. 

    Tabii biz 2..5 biçiminde range operatörü yerine doğrudan Range nesnesini de kullanabilirdik:

    let rs: &[i32] = &ma[Range {start: 2, end: 5}]; 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C++'ta olduğu gibi Rust'ta * operatörüne ilişkin operatör metodu yazılabilmektedir. Ancak Rust'ta bu operatör metotudu 
    doğrudan değil dolaylı bir biçimde yazılmaktadır. Bu işlemleri yapan operatör metotlarına gösterici gibi davranan yapılar 
    ya da enum türleri oluşturmak amacıyla gereksinim duyulmaktadır. Gösterici gibi davranan yapılara (ya da sınıflara)
    İngilizce "smart pointer" denilmektedir. 
    
    Rust'ta * operatörüne ilişkin operatör metotları Deref ve DerefMut trait'lerinin desteklenmesiyle yazılabilmektedir. 
    Deref ve DerefMut trait'leri şöyle tanımlanmıştır:

    pub trait Deref {
        type Target: ?Sized;

        // Required method
        fn deref(&self) -> &Self::Target;
    }

    pub trait DerefMut: Deref {
        // Required method
        fn deref_mut(&mut self) -> &mut Self::Target;
    }

    Deref ve DerefMut trait'lerinin generic olmadığına dikkat ediniz. Deref trait'inin Target isimli bir ilişkili türü vardır. 
    deref metodu bu ilişkli tür türünden referansa geri dönmektedir. DerefMut trait'i Deref trait'inden türetilmiş durumdadır. 
    Bu trait'in deref_mut metodu &mut referans alıp &mut bir referans s geri döndürmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        72. Ders 15/12/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    x bir yapı ya da enum türünden mut olmayan bir değişken ya da değer belirtiyor olsun. *x ifadesinin eşdeğeri *x.deref() 
    biçimindedir. Eğer x mut bir değişken ise ve *x ifadesine atama yapılıyorsa *x ifadesinin eşdeğeri *x.deref_mut() biçiminde 
    olur. Burada bir noktaya dikkat ediniz. deref ve deref_mut metotları referans geri döndürmektedir. Bu referansa * operatörü 
    uygulanmaktadır. Rust'ta C++'ta olduğu gibi doğrudan * operatör metodu yazılamamaktadır. Biz yapı ya da enum türünden 
    değişken ya da değere * operatörü uyguladığımızda önce bu yapı ya da enum türünden değişken ya da değer üzerinde deref 
    ya da deref_mut metodu çağrılmakta ve onun geri döndürdüğü referansın gösterdiği yere erişilmektedir. "The Rust Reference" 
    dokümanlarında "The dereference operator" başlığında * operatörünün bu bağlamdaki davranışı şöyle açıklanmaktadır:

    "On non-pointer types *x is equivalent to *std::ops::Deref::deref(&x) in an immutable place expression context and 
    *std::ops::DerefMut::deref_mut(&mut x) in a mutable place expression context."

    Örneğin:

    struct Number {
        number: i32
    }

    impl Number {
        fn new(number: i32) -> Number {
            Number { number }
        }

        fn disp(&self) {
            println!("{}", self.number)
        }
    }

    impl Deref for Number {
        type Target = i32;

        fn deref(&self) -> &i32 {
            &self.number
        }
    }

    Burada Deref trait'inin gerçekleştiriminde Target ilişkili türünün i32 olduğuna dikkat ediniz. Bu durumda deref metodu 
    da &i32 türünden geri dönüş değerine sahip olmak zorundadır. Metodun Number yapısının number alanın adresiyle geri 
    döndürüldüğüne dikkat ediniz. (Anımsanacağı gibi fonksiyonların ve metotların geri dönüş değerleri referans ise "lifetime 
    elision" denilen özel iki durumda ömür bilgisinin iliştirilmesi elimine edilebilmektedir.)

    Yukarıdaki Number yapısı türünden bir değişken ya da değerle artık * operatörünü kullanılabiliriz. Örneğin:

    let n = Number::new(10);

    println!("{}", *n);      

    Burada *n ifadesinin eşdeğeri *n.deref() biçimindedir. 

    Bu örneğimizde n değişkenin mut olduğunu düşünelim:

    let mut n = Number::new(10);

    Biz yine n ile * operatörünü kullanabiliriz. Çünkü *n ifadesi n üzerinde bir değişilik yapmayı hedeflememektedir. Ancak 
    *n ifadesini *n = 20 gibi bağlamda kullanamayız. Bu durumda bizin artık DerefMut trait'ini de desteklememiz gerekir. 
    Örneğin:

    impl DerefMut for Number {
        fn deref_mut(&mut self) -> &mut i32 {
            &mut self.number
        }
    }

    Burada deref_mut metodunun &mut self parametresine aldığına ve geri dönüş değerinin de &mut i32 biçiminde olduğuna 
    dikkat ediniz. Artık Number değişkeninine * ile atama yapabilriz:

    let mut n = Number::new(10);
    *n = 20;            // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda Deref ve DerefMut trait'lerini * operatörü bağlamında ele aldık. Ancak Rust'ta bu iki trait "deref conversion"
    denilen otomatik referans dönüştürmelerinde de devreye girmektedir. Anımsanacağı gibi Rust'ta "coercion" sözcüğü 
    "otomatik dönüştürme" anlamına gelmektedir. Rust'ta temel türler arasında otomatik dönüştürmenin olmadığını da anımsayınız. 
    Otomatik dönüştürmeler yalnızca referans ve göstericiler ile ilgili olarak yapılmaktadır. Bu konu "The Rust Reference" 
    dokümanlarında "10.7 Type coercions" başlığında ele alınmıştır. Bu bölümde referanslar ve göstericilerle ilgili mümkün 
    olan otomatik dönüştürmeler şöyle listelenmiştir:

    1) dyn T => dyn U, eğer U trait'i T trait'inin taban trait'i ise
    2) &mut => to &T
    3) *mut T => *const T
    4) &T => *const T
    5) &mut T => *mut T
    6) &T ya da &mut T => &U eğer T Deref<Target = U> trait'ini destekliyorsa
    7) &mut T => &mut U if T DerefMut<Target = U> trait'ini destekliyorsa

    Ayrıca bölümde "Unsized coercions" başlığı altında dizilerden dilimlere otomatik dönüştürmenin de mümkün olduğu 
    belirtilmiştir:

    8) [T; n] => [T]

    Tabii anımsanacağı gibi Rust'ta [T] türündne bir değişken bildirilememktedir. Ancak &[T] türünden değişkenler bildirilebilmektedir 
    Dolayısıyla bu 8'inci maddedeki dönüştürme aslında prtaikte &[T; N] => &[T] biçiminde karşımıza çıkmaktadır. 

    Yukarıdaki listede 6'ıncı ve 7'inci maddelere dikkat ediniz. Bu maddelerde özetle söylenmak istenen şey şudur: Eğer 
    elimizde bir T türü varsa ancak bu T türü Deref<Target=U> trait'ini destekliyorsa &T türünden &U türüne otomatik 
    dönüştürme vardır. Bnezer biçimde elimizde bir T türü varsa ancak bu T türü DerefMut<Target=U> trait'ini destekliyorsa
    &mut T türünden &mut U türüne otomatik dönüştürme vardır. Örneğin:

    let n = Number::new(10);
    let r: &i32;

    Aşağdıdaki gibi bir atamanın yapılabilmesi için Number yapısının Deref<Target=i32> trait'ini destekliyor olması gerekir:

    r = &n;     // geçerli değer Number Deref<Target=i32> trait'ini destekliyorsa

    Benzer biçimde:

    let mut n = Number::new(10);
    let r: &mut i32;

    Burada da aşağıdaki gibi bir atamanın yapılabilmesi için Number yapısının DerefMut<Target=i32> trait'ini destekliyor 
    olması gerekmektedir:

    r = &mut n;

    Tersten gidersek eğer T türü Deref<Target=i32> trait'in destekliyorsa biz T türünden bir değişkenin ya da değerin 
    adresini Target türünden bir referansa atayabiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi x.foo() gibi metot çağırmasında x'e alıcı (receiver) denilmektedir. Bu alıcı ile fonksiyonun birinci 
    parametresi olan self parametresi tür bakımından eşleştirilmektedir. "The Rust Reference" dokümanları bu çağırma 
    mekanizmasını şöyle açıklamıştır:

    *****
    "The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver 
    expression’s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, 
    and adding the result type if that is successful.

    Then, for each candidate T, add &T and &mut T to the list immediately after T.

    For instance, if the receiver has type Box<[i32;2]>, then the candidate types will be Box<[i32;2]>, &Box<[i32;2]>, 
    &mut Box<[i32;2]>, [i32; 2] (by dereferencing), &[i32; 2], &mut [i32; 2], [i32] (by unsized coercion), &[i32], 
    and finally &mut [i32].

    Then, for each candidate type T, search for a visible method with a receiver of that type in the following places:

    1) T’s inherent methods (methods implemented directly on T).
    2) Any of the methods provided by a visible trait implemented by T. If T is a type parameter, methods provided by 
    trait bounds on T are looked up first. Then all remaining methods in scope are looked up.

    If this results in multiple possible candidates, then it is an error, and the receiver must be converted to an 
    appropriate receiver type to make the method call."
    *****

    Bu açıklamalardan çıkan sonuş şöyledir: x.foo() gibi bir çağırma yapıldığında alıcı (receiver) üzerinde sürekli dreference 
    işlemleri yapılarak (yani * operatörü uygulanarak) türler elde edilmekte ve her elde edilen tür T olmak üzere T, &T ve
    &mut T oluşturulan bir listeye eklenmektedir. En nihayetinde listeye "diziden dilime dönüştürme söz konusuysa bu dizi 
    dilim türü de eklenmektedir. İşte bu listedeki tüm elemanlara ilişkin türlerde foo metodu aranır. Eğer böyle tek bir 
    fonksiyon bulunursa ve o fonksiyonun birinci parametresi olan self parametresi bu alıcıyla uyumluysa o metot çağrılır. 
    Eğer bu biçimde listedeki türlerde birden fazla metot bulunursa ya da hiç metot bulunmazsa error oluşur. Örneğin:

    x.foo();

    çağrısı yapılmış olsun. Buradaki x henüz görmemiş olsak da Box<[i32; 5]> türünden olsun. İşte aday alıcı listesi 
    şöyle oluşturulmaktadır:

    Box<[i32; 2]> 
    &Box<[i32; 2]> 
    &mut Box<[i32; 2]> 
    [i32; 2]
    &[i32; 2]
    &mut [i32; 2]
    [i32]
    &[i32]
    &mut [i32]

    Biz henüz bu noktada Box türünü görmedik. Ancak burada Box türü dereferens edildiğinde (yani Box türüne * operatörü 
    uygulandığnda) [i32; 2] türü elde edilmektedir. İşte nihayetinde elde edilen bu alıcı listesindeki her türde çağrılan 
    metot aranacaktır. Eğer böyle bir metot bulunursa o çağrılacak, birden fazl ametot bulunursa ya da hiç metot bulunamazsa
    bu durum error ile sonuçlanacaktır. 

    Daha önce de belirtitğimiğz gibi "The Rust Reference" dokümanlarında "8.2.11 (Field Access Expressions)" başlığında 
    x.a gibi bir alan erişimi için şunlar söylenmiştir:

    *****
    "If the type of the container operand implements Deref or DerefMut depending on whether the operand is mutable, it is 
    automatically dereferenced as many times as necessary to make the field access possible. This process is also called 
    autoderef for short."
    *****

    Burada anlatılmak istenen şey şudur: x.a gibi bir erişimde nokta operatörünün solunda operand'ın türünde (örneğimizde x) 
    bir x alanı yoksa bu operand'a sürekli olarak * operatörü uygulanır. Ta ki ifade geçerli olana kadar. İfadenin ilk 
    geçerli olduğu durumdaki erişim gerçekleştirilir. Tabii ifade hala geçersiz olursa error oluşacaktır. Örneğin:

    let s = Sample { val: 10 };
    let rs = &s;

    Burada biz s.val erişimini yapmış olalım. &Sample türünde val isimli bir alan yoktur. Bu durumda *rs ifadenin türünde
    val alanı aranır. *rs Sample türündne olduğu için ve Sample türünde val alanı olduğu için erişim geçerlidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede Deref ve DerefMut trait'lerine benzer std::convert modülünde AsRef isimli ve AsMut isimli trait'ler 
    de vardır. AsRef trait'i şöyle tanımlanmıştır:

    pub trait AsRef<T> 
    where
        T: ?Sized,{
        // Required method
        fn as_ref(&self) -> &T;
    }

    AsMut trait'i de şöyle tanımlanmıştır:

   pub trait AsMut<T>where
        T: ?Sized,{
        // Required method
        fn as_mut(&mut self) -> &mut T;
    }

    Görüldüğü gibi iki trait arasındaki tek fark referansların mut'luk durumudur. AsRef<T> ve AsMut<T> bu trait'leri bunları 
    destekleyen türden T türüne dönüştürme yapmak için kullanılmaktadır. Ancak bu trait'ler otomatik dönüştürmede devreye 
    girmemekte ve otomatik dereferense işlemini yapmamakltadır. Dolayısıyla bu trait'ler * operatörüne ilişkin operatör 
    metotlarının yazılmasında kullanılamazlar. Ancak açıkça (explicit) dönüştürme vurgulanmak isteniyorsa bu trait'ler 
    tercih edilebilmektedir. Örneğin:

    struct Number {
        number: i32
    }

    impl Number {
        fn new(number: i32) -> Number {
            Number { number }
        }

        fn disp(&self) {
            println!("{}", self.number)
        }
    }

    impl AsRef<i32> for Number {
        fn as_ref(&self) -> &i32 {
            &self.number
        }
    }

    impl AsMut<i32> for Number {
        fn as_mut(&mut self) -> &mut i32 {
            &mut self.number
        }
    }

    Burada Deref yerine AsRef, DerefMut yerine AsMut trait'leri desteklenmiştir. Ancak artık biz Nuköber türünden bir 
    değişkenden içerisindeki number alanının adresini açıkça as_ref ve as_mut metotlarını çağırarak elde edebiliri. Örneğin:

    let mut n = Number::new(10);
    let r: &i32;
    let k: &mut i32;

    r = n.as_ref();
    println!("{}", *r);

    k = n.as_mut();
    *k = 20;
    n.disp();

    Burada bir kez daha Deref ve DefetMut ile AsRef ve AsMut trait'lerinin arasındaki farkları vurgulamak istiyoruz:

    1) Deref ve DerefMut trait'lerini desteklenirse * operatörü ilgili tür için kullanılabilir. Ancal AsRef ve AsMut 
    trait'lerinin böyle bir etkisi yoktur. 

    2) Deref ve DerefMut trait'leri bunları derstekleyen tür türünden değişkenlerin adresleri alındığında ilgili türe 
    otomatik dönüşüm (deref coercion) sağlamaktadır. Ancak AsRef ve AsMut trait'lerinin böyle bir bir özelliği yoktur. 

    Yani biz yalnızca AsRef ve AsMut trait'lerini desteklersek aşağdaki işlemleri yapamayız:

    let n = Number::new(10);
    let r: &i32;
    let x: i32;

    r = &n;     // error! bu işlem ancak Deref trait'i ile mümkündür
    x = *x;     // errror! bu işlem ancak Deref trait'i ile mümkündür
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde operatör metotlarını generic olmayan yapılarda kullandık. Eğer yapı (ya da enum) generic ise 
    sentaks biraz kafa karıştırıcı olabilmektedir. Bu nedenle generic yapı ya da enum türlerine ilişkin operatör metotlarının 
    yazımı üzerinde de ayrıca durmak istiyoruz. 

    Daha önce üzerinde çalışmış olduğumuz Rational yapısını bu kez generic olarak gerçekleştirmeye çalışalım:

    struct Rational<T> {
        a: T,
        b: T
    }

    Rasyonel sayıların pay ve paydasının tamsyı olması gerektiğini anımsayınız. O halde bizim bu generic Rational yapımızda
    generic T parametresi için "işaretli tamsayı türünden olma" sınırlamasını oluşturmamız gerekir. Rust'ta tür sınırlamalarının
    trait'lerle yapıldığını görmüştük. Peki bu işi yapan standart bir trait var mıdır? Maalesef Rust'ta bu sınırlamayı 
    yapabilecek standart bir trait yoktur. Rust'ın standart kütüphanesi minimalist tutulmuştur. Standart kütüphanenin 
    yetmediği durumlarda başkaları tarafından yazılmış olan kütüphaneler kullanılmaktadır. İşte temel türler üzerinde 
    sınırlamalar yapmak için "num" isimli başkaları tarafından yazılmış bir crate bulunmaktadır. Anımsanacağı gibi bir 
    crate'i kullanmak için tek yapılacak şey ".toml" dosyasında [Dependencies] bölümüne crate'in versiyon numarasını
    belirtmektir. Örneğin:

    [package]
    name = "RustRover-Project"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    num="0.4.2"
    
    num crate'nin dokümantasyonuna "docs.rs" sitesindeki aşağıdaki bağlantıyla erişebilirsiniz:

    https://docs.rs/num/latest/num/

    num crate'nin içerisindeki tür sınırlaması için oluşturulmuş önemli trait'ler şunlardır:

    num::Integer - Tüm tamsayı türleri (hem işaretli hem işaretsiz) için genel trait
    num::Signed - İşaretli sayılar için trait (negatif değer alabilenler)
    num::PrimInt - Primitive integer türleri için trait
    num::Num - Temel sayısal operasyonlar için en genel trait
    num::Float - f32 ve f64 tgürleri için trait

    Bu durumda biz Rational yapı tanımşamasında ya da impl bloklarında aşağıdaki gibi tür sınırlaması uygulayabiliriz:

    use num::{Integer, Signed};
    use std::fmt::Display;

    struct Rational<T: Integer + Signed + Display = i64> {
        a: T,
        b: T
    }

    Generic Rational yapımız için new ilişkili fonksiyonunu ve disp metodunu tanımlayalım:

    use num::{Integer, Signed, Zero, One};
    use std::fmt::Display;

   struct Rational<T = i64>
    where T: Integer + Signed + Copy 
    {
        a: T,
        b: T
    }

   impl<T> Rational<T>
    where T: Integer + Signed + Copy {
        fn new(a: T, b: T) -> Result<Rational<T>, &'static str> {
            if b == T::zero() {
                return Err("invalid rational number");
            }
            let mut result = Rational { a, b };
            result.simplify();
            Ok(result)

        }

        fn gcd(mut a: T, mut b: T) -> T {
            if a == Zero::zero() { return b; }
            if b == Zero::zero() { return a; }
            while b != Zero::zero() {
                let r = a % b;
                a = b;
                b = r;
            }
            a
        }

        fn simplify(&mut self) {
            let gcd = Self::gcd(self.a.abs(), self.b.abs());

            self.a = self.a / gcd;
            self.b = self.b / gcd;
        }

        fn disp(&self)
        where T: Display {
            if self.a == Zero::zero() {
                println!("0");
            }
            else if self.b == One::one() {
                println!("{}", self.a);
            }
            else {
                println!("{}/{}", self.a, self.b);
            }
        }
    }

    Burada disp metodunun nasıl yazıldığına dikkat ediniz. T generic parametresi zaten Integer ve Signed trait'lerini 
    destekliyor olduğu için biz de Display trait'ini desteklediğimizde artık self.a ve self.b değerlerini println! 
    makrosuyla yazdırabilir hale gelmekteyiz. Metotlarda 0 ve 1 sabitleri yerine num crate'indeki Zero::zero ve
    One::one ilişkili fonksiyonlarının kullanıldığına dikkat ediniz. Biz bu metot içeriside doğrudan 0 ve 1 sabitlerini 
    kullanamayız. Her ne kadar T türü işaretli tamsayı türlerinden biri olacak biçimde sınırlandırılmışsa da karşılaştırma
    operatörlerinin her iki operand'ının da aynı türden olma zorunluluğu nedeniyle bu işlemi yapamamaktayız.

    Şimdi + ve - operatörlerine ilişkin operatör netotlarını yazalım:

    impl<T> Add<Rational<T>> for Rational<T>
    where T: Integer + Signed + Copy {
        type Output = Rational<T>;

        fn add(self, other: Rational<T>) -> Rational<T> {
            let a = self.a * other.b + self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    impl<T> Sub<Rational<T>> for Rational<T>
    where T: Integer + Signed + Copy {
        type Output = Rational<T>;

        fn sub(self, other: Rational<T>) -> Rational<T> {
            let a = self.a * other.b - self.b * other.a;
            let b = self.b * other.b;

            let mut result = Rational { a, b };
            result.simplify();
            result
        }
    }

    Diğer operatör metotları da benzer biçimde yazılabilir. Bu örneğin bütünsel halini aşağıda veriyoruz.
-----------------------------------------------------------------------------------------------------------------------*/

use num::{Integer, Signed, Zero, One};
use std::fmt::Display;
use std::ops::{Add, Sub};

fn main() {
    let x = Rational::new(1, 2).unwrap();
    let y = Rational::new(1, 2).unwrap();
    let z: Rational<i32>;

    z = x - y;
    z.disp();
}

struct Rational<T = i64>
where T: Integer + Signed + Copy
{
    a: T,
    b: T
}

impl<T> Rational<T>
where T: Integer + Signed + Copy {
    fn new(a: T, b: T) -> Result<Rational<T>, &'static str> {
        if b == T::zero() {
            return Err("invalid rational number");
        }
        let mut result = Rational { a, b };
        result.simplify();
        Ok(result)
    }

    fn gcd(mut a: T, mut b: T) -> T {
        if a == Zero::zero() { return b; }
        if b == Zero::zero() { return a; }
        while b != Zero::zero() {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }

    fn simplify(&mut self) {
        let gcd = Self::gcd(self.a.abs(), self.b.abs());

        self.a = self.a / gcd;
        self.b = self.b / gcd;
    }

    fn disp(&self)
    where T: Display {
        if self.a == Zero::zero() {
            println!("0");
        }
        else if self.b == One::one() {
            println!("{}", self.a);
        }
        else {
            println!("{}/{}", self.a, self.b);
        }
    }
}

impl<T> Add<Rational<T>> for Rational<T>
where T: Integer + Signed + Copy {
    type Output = Rational<T>;

    fn add(self, other: Rational<T>) -> Rational<T> {
        let a = self.a * other.b + self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

impl<T> Sub<Rational<T>> for Rational<T>
where T: Integer + Signed + Copy {
    type Output = Rational<T>;

    fn sub(self, other: Rational<T>) -> Rational<T> {
        let a = self.a * other.b - self.b * other.a;
        let b = self.b * other.b;

        let mut result = Rational { a, b };
        result.simplify();
        result
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            73. Ders 17/12/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta C++'taki gibi "tür dönüştürme operatör fonksiyonu" yoktur. Yukarıda görmüş olduğumuz Deref ve DerefMut trait'leri 
    sahipliği bırakmadan değişken içerisindeki alanın adresiyle geri dönmek için kullanılmaktadır. Deref ve DerefMut trait'lerinin 
    bir çeşit ödünç alma mekanizmasını uyguladığına dikkat ediniz. Rust'ta bu trait'lerin desteklenmesi ile C++'taki tür 
    dönüştürme operatör fonksiyonu etkisi tam olmasa da adres yoluyla kısmen karşılamaktadır. 
    
    Rust'ta Deref ve DerefMut trait'lerinin yanı sıra değişkenin sahipliğini devrederek dönüştürme yapmak için std::convert 
    modülünde bulunan From ve Into trait'leri de bulundurulmuştur. Bu trait'ler için standart prelude içerisinde use işlemi 
    yapıldığından dolayı trait isimleri doğrudan kullanılabilmektedir. Biz aslında From trait'iyle daha önce karşılaşmıştık:

    let s = String::from("ankara");

    İşte aslında String yapısındaki from ilişkili fonksiyonu From trait'inden gelmektedir. 

    From trait'i şöyle tanımlanmıştır:

    pub trait From<T>: Sized {
        // Required method
        fn from(value: T) -> Self;
    }

    Burada from fonksiyonun bir metot olmadığına ilişkli fonksiyon olduğuna dikkat ediniz. Fonksiyon T türünden bir parametreye 
    sahiptir. Parametre bir referans olmadığı için sahiplik devri söz konusu olmaktadır. Fonksiyonun geri dönüş değeri From 
    trait'ini destekleyen tür türünden olmak zorundadır. Biz X türünden bir yapı ya da enum türünün From<T> trait'ini 
    desteklediğini görmüş olalım. Bu durumda şunu anlkamalıyız: "X yapı ya da enum türünün from isimli bir ilişkili fonksiyonu
    vardır. Bu from fonksiyonu T türünden bir değeri alıp X türünden bir değer vermektedir". Aşağıdaki kullanıma dikkat 
    ediniz:

    let s = String::from("ankara");

    Burada biz String yapısında From<&str> trait'inin desteklendiğini anlıyoruz. Bu from fonksiyonu parametre olarak &str 
    alıp bize String vermektedir. Şimdi de aşağıdaki örneğe bakınız:

    struct Number {
        number: i32
    }

    impl Number {
        fn new(number: i32) -> Number {
            Number { number }
        }

        fn disp(&self) {
            println!("{}", self.number)
        }
    }

    impl From<i32> for Number {
        fn from(value: i32) -> Number {
            Number { number: value }
        }
    }

    impl From<&str> for Number {                // dikkat! aslında kötü bir fikir
        fn from(s: &str) -> Number {
            Number { number: s.parse().unwrap() }
        }
    }

    Burada i32 alıp Number veren ve &str alıp Number veren iki from fonksiyonu oluşturulmuştur. From trait'indeki from 
    fonksiyonunun her zaman başarılı olması gerektiğine dikkat ediniz. Aslında bu nedenle &str alıp Number veren from 
    fonksiyonunu oluşturmak iyi bir teknik değildir. Çünkü bu durumda eğer string içerisindeki yazı i32 ile temsil edilen 
    bir sayı belirtmiyorsa panic oluşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let n = Number::from(10);
    n.disp();

    let k = Number::from("20");
    k.disp();
}

struct Number {
    number: i32
}

impl Number {
    fn new(number: i32) -> Number {
        Number { number }
    }

    fn disp(&self) {
        println!("{}", self.number)
    }
}

impl From<i32> for Number {
    fn from(value: i32) -> Number {
        Number { number: value }
    }
}

impl From<&str> for Number {                // dikkat! aslında kötü bir fikir
    fn from(s: &str) -> Number {
        Number { number: s.parse().unwrap() }
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    From trait'indeki from fonksiyonunun referans almadığına doğrudan değerin kendisini aldığına dikkat ediniz. O halde 
    eğer kaynak tür Copy türünden değilse bir sahiplik devri de söz konusu olacaktır. Örneğin:

    struct Number<T> {
        number: T
    }

    struct Rational {
        a: i64,
        b: i64
    }

    impl From<Rational> for Number<f64> {
        fn from(r: Rational) -> Number<f64> {
            Number { number: r.a as f64 / r.b as f64 }
        }
    }

    Burada Number generic bir yapıdır. From trait'i Number<f64> destklenmiştir. Burada from fonksiyonu Rational alıp Number<f64> 
    vermektedir. Ancak Rational yapısı Copy türünden olmadığı için sahiplik devri söz konusu olacaktır. Dolayısıyla biz from 
    çağrısından sonra artık argüman olarak verdiğimiz değişkeni kullanamayız:

    let r = Rational { a: 1, b: 2 };
    let n = Number::from(r);

    println!("{}", n.number);

    println!("{}/{}", r.a, r.b);        // error! sahiplik devredildi
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let r = Rational {a: 1, b: 2};
    let n = Number::from(r);

    println!("{}", n.number);

    // println!("{}/{}", r.a, r.b);        ===> error! sahiplik devredildi
}

struct Number<T> {
    number: T
}

struct Rational {
    a: i64,
    b: i64
}

impl From<Rational> for Number<f64> {
    fn from(r: Rational) -> Number<f64> {
        Number { number: r.a as f64 / r.b as f64 }
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Into trait'i From trait'inin metotsal ters biçimi gibidir. Şöyle tanımlanmıştır:

    pub trait Into<T>: Sized {
        // Required method
        fn into(self) -> T;
    }

    Buradaki into artık bir metottur. Bu metot trait'i destekleyen türden bir değeri alıp generic parametreyle belirtilen 
    türe dönüştürmektedir. into metodunun parametresinin &self değil self biçiminde olduğuna dikkat ediniz. Yani metot 
    çağrıldıktan sonra yine sahiplik devri yapılacaktır. Örneğin:

    struct Number {
        number: i32
    }

    impl Number {
        fn new(number: i32) -> Number {
            Number { number }
        }

        fn disp(&self) {
            println!("{}", self.number)
        }
    }

    impl From<i32> for Number {
        fn from(value: i32) -> Number {
            Number { number: value }
        }
    }

    impl Into<i32> for Number {
        fn into(self) -> i32 {
            self.number
        }
    }

    Burada from fonksiyonu i32'den Number türüne into fonksiyonu ise Number türünden i32 türüne dönüştürme yapmaktadır. 
    Bu metotları aşağıdaki gibi kullanmış olalım:

    let n = Number::from(10);
    n.disp();

    let val: i32 = n.into();
    println!("{}", val);

    Burada into metodunun kullanımına dikkat ediniz:

    let val: i32 = n.into();       

    into metodunun hangi türe dönüştürme yapmak için kullanıldığını derleyiciye söylemek için hedef türün açıkça belirtilmesi 
    gerekmektedir. Aşağıdaki kullanım geçerli değildir:

    let val = n.into();                     // error! 

    Burada derleyici hangi türe dönüştürme yapan into metodunun kullanılacağını alyamamamaktadır. (Örneğimizde yalnızca i32
    türüne dönüştürme yapan into metodu vardır. Ancak derleyici "nasıl olsa yalnızca bir tane into var o halde hedef tür 
    i32 olmalıdır" biçiminde bir akıl yürütme yapmamaktadır.) Peki biz into metodunda hedef türü nasıl açıkça belirtebiliriz?
    Aşağıdaki bir sentaks geçerli değildir:

    let val = n.into::<i32>();              // error! 

    Çünkü burada into metodu generic değildir, Into trait'i generic'tir. O halde mecburen bu işlem için UFCS sentaksını 
    kullanmamız gerekir:

    let val = Into::<i32>::into(n);         // geçerli

    into metodunda self üzerinden sahiplik devrinin yapıldığına dikkat ediniz:

    let n = Number::from(10);
    let val: i32;

    val = n.into();
    println!("{}", val);

    println!("{}", n.number);       // error!

    Bu örnekte n değişkenin sahipliği devredilerek tüketilmiştir. Dolayısıyla into çağrısından sonra artık biz n değişkenini 
    kullanamayız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ın standart kütüphanesinde From<T> türünü destekleyen her tür için Into<T> desteği de "kaplayıcı destekleme 
    (blanket implementation)" yoluyla verilmiştir. From tarit'i üzerinden Into kaplayıcı desteklemesi şöyle oluşturulmuştur:
    
    impl<T, U> Into<U> for T
    where
        U: From<T> 
    {
        fn into(self) -> U {
            U::from(self)
        }
    }

    Burada ana noktaya dikkat ediniz: Aslında from kullanılarak into yazılabilmektedir. Yukarıdaki kapsayıcı destekleme 
    şu anlama gelmektedir: Eğer bir U türünden T türüne dönüştürme yapan bir from fonksiyonu varsa U türünün içerisinde de 
    T türünde dönüştürme yapan bir into metodu da otomatik olarak oluşturulmaktadır. Yani örneğin biz i32 türünden Number türüne 
    dönüştürme yapan bir from fonksiyonu oluşturmuşsak, i32 türünün içerisinde de Number türüne türüne dnüştürme yapan bir into 
    metodu da otomatik olarak oluşturulmaktadır. Bunun için bizim ayrıca i32 türü için Number türüne dönüştürme yapan into 
    metodunu yazmamıza gerek yoktur. Örneğin:

    struct Number {
        number: i32
    }

    impl Number {
        fn new(number: i32) -> Number {
            Number { number }
        }

        fn disp(&self) {
            println!("{}", self.number)
        }
    }

    impl From<i32> for Number {
        fn from(value: i32) -> Number {
            Number { number: value }
        }
    }

    Burada i32 türünden Number türüne dönüştürme yapan from ilişkili fonksiyonunu biz yazdık. Artık i32 türünün içerisinde de 
    Number türüne dönüştürme yapan into metodu kapsayıcı destekleme sayesinde otomatik olarak oluşturulacaktır. Burada sıklıkla 
    yapılan bir yanlış anlaşılmaya dikkatinizi çekmek istiyoru: i32 türünden Number türüne from ile yapılan dönüştürmenin 
    kapsayıcı karşılığı Number türünden i32 türüne yapılan dönüştürme değildir, yine i32 türünden Number türüne yapılan ancak
    i32 içerisindeki metotla yapılan dönüşürmedir. Zaten kapsayıcı destekleme "bir fonksiyon ya da metot varsa onu kullanarak 
    diğerininin otomatik yazılması" anlamına gelmektedir. Örneğin elimizde i32 türünden Number türüne dönüştürme yapan bir 
    from fonksiyonu varsa biz i32 türünden Number türüne dönüştürme yapan into metodunu bu fonksiyonu kullanarak aşağdıaki 
    gibi yazabiliriz:

    impl Into<Number> for i32 {
        fn into(self) -> Number {
            Number::from(self)
        }
    }

    Buradaki self artık i32 anlamına gelmektedir. Tabii biz bu biçimde bir desteği kodumuza eklersek aynı zamanda kapsayıcı 
    destekleme de bulunduğu için error oluşacaktır. Ancak burada bizim göstermek istediğimiz şey U türünden T türüne dönüştürme 
    yapan bir from fonksiyonu varsa U türü için T türüne dönüştürme yapan into metodu da from metodu kullanılarak yazılabilmektedir. 
    Örneğin Rational türünden Number türüne dönüştürme yapan bir from fonksiyonu varsa Rational türünden de Number türüne 
    dönüştürme yapan bir into metodu otomatik olarak bulunuyor olacaktır. Örneğin:

    let s = String::from("ankara");

    Burada &str türünden String türüne dönüştürme yapan bir from fonksiyonun olduğunu görüyorsunuz. O halde &str türünün 
    içerisinde de String türüne dönüştürme yapan bir into metodu bulunmak zorundadır:

    let k: String;

    k = "ankara".into();
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi biz i32 türünden Number türüne dönüştürme yapan from fonksiyonunu yazmış olalım. Bu durum 
    bizim Number türünden i32 türüne dönştürme yapabileceğimiz anlamına gelmemektedir. i32 içerisinde Number türüne dönüştürme 
    yapan bir metodun da otomatik bulundurulduğu anlamına gelmektedir. 
    
    Peki biz Number türünden de i32 türüne dönüştürme yapmak isteyelim. Bu durumda Number için i32 dönüştürmesi yapan 
    into metodunu mu yazmalıyız, yoksa i32 için Number dönüştürmesini yapan from metodunu mu yazmalıyız? İşte bu tür 
    durumlarda "her zaman from metodunun yazılması" tercih edilmektedir. Nasıl olsa into metodu da kapsayıcı destekleme 
    sayesinde otomatik olarak oluşturulacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            74. Ders 29/12/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta "hataların ele alınması (error handling)" konusu üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C'de hataların ele alınması genellikle fonksiyonların geri dönüş değerlerinin kontrol edilmesi yoluyla yapılmaktadır. 
    Yani programcı bir fonksiyonu çağırdığında fonksiyonun başarılı olup olmadığını genellikle fonksiyonun geri dönüş değerine
    bakarak tespit eder ve hata durumunda gerekli işlemleri if deyimini kullanarak gerçekleştirir. Örneğin UNIX/Linux sistemlerindeki
    POSIX fonksiyonlarının önemli bir böşümü int türden geri dönüş değerine sahiptir. Bu fonksiyonlar başarı durumunda 0 değerine 
    başarısızlık durumunda -1 değerine geri dönmektedir:

    struct stat finfo;

    if (stat("test.dat", &fnfo) == -1) {
        perror("stat");
        exit(EXIT_FAILURE);
    }

    Aynı teknik çoğu kez C++'ta da kullanılmaktadır. Ancak C++, Java ve C# gibi diller "exception" mekanizmasına da sahiptir.
    Bu sayede bir kod içerisinde her fonksiyon çağrısının geri dönüş değerini kontrol etmeye gerek kalmamaktadır. Bu fonksiyonlar
    başarısızlık durumunda exception fırlatmakta ve fırlatılanm exception'lar ortak bir noktada ele alınabilmektedir. Örneğin
    biz Linux sistemlerinde peşi sıra üç kez read işlemi yapmış olalım:

    if (read(...) == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    if (read(...) == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    if (read(...) == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    Halbuki örneğin buna benzer işlemler C#'ta şöyle yapılabilmektedir:

    try {
        fs = FileStream(...);

        fs.Read(...);
        fs.Read(...);
        fs.Read(...);
    }
    catch (Exception e) {
        Console.WriteLine(e);
    }

    Exception mekanizmasında fonksiyonlar zaten başarısız olduğunda exception fırlatabilmektedir. Programcı hatanın 
    ele alımını tek bir noktada yapabilmektedir. 

    C'de fonksiyonun her çağrımında kontrol yapılması istenmiyorsa genellikle sarma fonksiyon yazılmaktadır. Hata ele alımları 
    da goto deyimi ile ortak bir noktada yapılabilmektedir. 

    Exception mekanizması daha açık bir kodlamaya olanak sağlasa da bu mekanizmanın derleyici tarafından gerçekleştirilmesi 
    bir maliyet gerektirmektedir. Bu nedenle aşağı seviyeli sistem programlama uygulamalarında exception mekanizması uygun 
    bir araç olmaktan çıkmaktadır. Exception mekanizması genel olarak nesne yönelimli programlama dillerinde bulunan bir 
    özelliktir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta exceptipon mekanizması yoktur. Hatalar Option ve Result enum türleri yoluyla ele alınmaktadır. Yani Rust'ta bir 
    fonksiyon başarısız olabiliyorsa genellikle onun geri dönüş değeri Option<T> ya da Result<T, E> türündendir. Programcı 
    da kalıp uyuşumu özelliklerini kullanarak hatayı belirleyip ele almaktadır. Anımsayacağınız gibi Option<T> enum türü 
    Some(T) ve None varyantlarına, Result<T, E> enum türü ise Ok(T) ve Err(E) varyantlarına sahipti. Option<T> türü hata 
    durumunda hataya ilişkin bir bilgi vermemektedir. Option<T> türünde jata durumu None varyantıyla tespit edilmektedir. 
    Halbuki Result<T, E> türünde hatalı durumun nedenine iişkin bir bilgi de iletilmektedir. Eğer hatanın nedeni ile 
    ilgilenilmiyorsa ya da hata tek bir nedenden kaynaklanıyorsa Option<T> türü kullanılabilir. Ancak hatanın pek çok nedeni 
    varsa ve hata durumunda bu hata nedeni de fonksiyonu çağıran kişiye iletilecekse Result<T, E> türü tercih edilmelidir. 
    Bu enum türlerinin tanımlamasını 
    yendien veriyoruz:

    pub enum Option<T> {
        None,
        Some(T),
    }

    pub enum Result<T, E> {
        Ok(T),
        Err(E),
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta hataları iki grupta ele alabiliriz:

    1) Telafi Edilemeyecek Hatalar (Unrecoverable Errors)
    2) Telafi Edilebilecek Hatalar (Recoverable Errors)

    Telafi edilemeyecek hata demekle "hata oluştuğunda artık programa devam etmenin bir anlamının kalmadığı" durumları 
    kastediyoruz. Rust'ta böylesi durumlarda tipik olarak panic makrolarıyla program sonandırılmaktadır. Telafi edilebilecek 
    hatalar ise "hata oluştuğunda kodun bir biçimde yoluna devam edebileceği" durumları belirtmektedir. Örneğin bir dosya 
    açılamazsa programcı başka bir dosyayı kullanarak işlemine devam edebilir. 

    Biz önce telafi edilebilir hatalar üzerinde sonra da telafi edilemez hatalar üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun geri dönüş değeri Option<T> türündense hata ele alımı tipik olarak birkaç biçimde yapılabilmektedir. 
    En sık kullanılan yöntemler if let ve match deyimleridir. Örneğin f32 değer üzerinde bölme işlemi yapan div isimli 
    bir fonksiyon yazacak olalım. Eğer payda 0 ise bölme yapılamayacktır. Bu durumda fonksiyonun geri dönüş değeri Option<f64>
    olabilir:
    
    fn div(a: i32, b: i32) -> Option<f64> {
        if b != 0 {
            Some(a as f64 / b as f64)
        }
        else {
            None
        }
    }
    
    Programcı da fonksiyonu çağırıp ele hata ele alımını if let ya da match deyiminde yapabilir:

    if let Some(result) = div(10, 0) {
        println!("{}", result);
    }
    else {
        eprintln!("divide by zero!");
    }
    //...

    Ya da örneğin:

    match div(10, 4) {
        Some(result) => println!("{}", result),
        None => eprintln!("divide by zero!..")
    }
    println!("program continues...");

    if let deyiminde kalıptaki değişkenin yalnızca if deyiminin doğruysa kısmında kullanılabildiğine dikkat ediniz. Eğer bu 
    değer dışarıya iletilecekse if deyimini bir ifade gibi kullanmak gerekir. Tabii bu durumda deyimin else kısmı ya aynı 
    türdne olmalı ya da ! türünden (yani "divergent") olamlıdıri Örneğin:

    let result: f64;

    result = if let Some(result) = div(10, 0) {
        //...
        result
    }
    else {
        eprintln!("divide by zero!");
        std::process::exit(1)
    };
    println!("{}", result);

    Aynı dırım match deyiminde de geçerlidir. Kalıp uyuşumu ile elde edilen değerin yerleştirildiği değişken yalnızca ilgili 
    match kolunda kullanılabilmektedir. Bu değerin dışarıya iletilmesi için match deyimini bir ifade biçiminde kullanılması 
    gerekmektedir. Örneğin:

    let result: f64;

    result = match div(10, 4) {
        Some(result) => {
            //...
            result
        },
        None => {
            eprintln!("divide by zero!");
            std::process::exit(1)
        }
    };
    println!("{}", result);

    Tabii eğer None durumunda özel birtakım işlemler yapılmayacaksa Option<T> türüne geri dönen fonksiyonlarla doğrudan 
    Option<T> enum türünün unwrap ya da expect metotları çağrılabilir. Örneğin:

    let result: f64;

    result = div(10, 4).unwrap();
    println!("{}", result);

    Hatayı önce is_none metoduyla ele alıp sonra yola devam etmek Rust için iyi bir teknik değildir. Örneğin:

     if result.is_none() {              // kötü teknik
        println!("dive by zero!..");
        std::process::exit(1);
    }
    let val = result.unwrap();
    println!("{}", val);

    unwrap metodu kendi içerisinde yeniden kontrol uygulamaktadır. Bu yöntemde aslında None kontrolü iki kez yapılmış olacaktır. 
    İkinci kez kontrolün yapılmaması için unwrap_uncheked isimli bir metodun da bulunduğunu anımsayınız. Ancak bu metot unsafe 
    olduğu için ensafe bağlamda kullanılabilmektedir. Yukarıdaki durum için bu metodun kullanılması da tavsiye edilmez. 
    Örneğin:

    if result.is_none() {
        println!("dive by zero!..");
        std::process::exit(1);
    }
    let val = unsafe {
      result.unwrap_unchecked()
    };
    println!("{}", val);

    Görüldüğü gibi "önce hatayı kontrol et, hata varsa programı sonlandır, hata yoksa devam et" biçimindeki kontrol C'de 
    çokça uygulanıyor olsa da Rust'ta Option türü için uygun değildir. 
    
    Option<T> türü için hatayı ele almanın diğer bir yolu da unwrap_or_else metodunu kullanmaktır. Bu metot eğer Option<T> 
    değerindeki varyant Some(T) ise T türünden değeri geri döndürmektedir, değilse parametresiyle aldığı closure çağrımını 
    yapıp o çağrıdan elde edilen değeri geri döndürmektedir. Tabii closure çağrısı T türünden değer geri döndürmeyecekse 
    divergent olmak zorundadır. Örneğin:

    let result: f64;

    result = div(10, 4).unwrap_or_else(|| {
        println!("divide by zero!..");
        std::process::exit(1)
    });

    println!("{}", result);

    Closure konusu ileride ele alınacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon Result<T, E> türüne geri dönüyorsa hata durumunda hata nedeni hakkında da bilgi vermektedir. Bu tür 
    fonksiyonların ele alımı Option<T> türüne geri dönen fonksiyonların ele alımına oldukça benzemektedir. Eğer söz konusu 
    hata "telafi edilemez ise ve hatanın nedeni ile ilgilenilmiyorsa yine doğrudan unwrap ya da expect metotları kullanılabilir. 
    Programcılar özellikle deneme kodları yazarken unwrap ve expect metotlarını Result<T, E> türü için de oldukça sık 
    kullanmaktadır. 
    
    Örneğin kişinin yaşını kontrol eden validate_age isimli bir fonksiyon yazacak olalım. Bu fonksiyon eğer parametre 
    olarak girilen yaş negatif ise ya da 150'den büyük ise farklı mesaj metinleri oluşturarak başarısızlıkla geri dönüyor olsun. 
    Eğer yaş geçerliyse fonksiyon parametresiyle girilen yaştan 1 fazlasıyla geri dönsüyor olsun.

    fn validate_age(age: i32) -> Result<i32, String> {
        if age < 0 {
            Err(String::from("age cannot be negative!.."))
        }
        else if age > 150 {
            Err(String::from("age too high!.."))
        }
        else {
            Ok(age + 1)
        }
    }

    Burada fonksiyon başarı durumunda i32 değeri ile başarısızlık durumunda da başarısızlığın nedenini belirten bir  
    String ile geri dönmektedir. Biz hata mesajını dikkate almadan durumu da "telafi edilemez biçimde" ele alacaksak 
    doğrudan unwrap ya da expect metotlarını kullanabiliriz:

    let new_age: i32;

    new_age = validate_age(10).unwrap();
    println!("{}", new_age);

    Eğer hatanın nedenini dikkate alacak ve onu rapor edeceksek match deyimini kullanabiliriz. Örneğin:

     match validate_age(10) {
        Ok(new_age) => println!("{}", new_age),
        Err(msg) => eprintln!("Error: {msg}")
    }

    Eğer Ok(T) durumunda elde edilen değer dışarıda kullanılacaksa match deyimi bir ifade biçiminde kullanılmalıdır. 
    Tabii Err(E) varyantı ele alınırken divergent durum oluşturulmalıdır. Örneğin:

    let new_age: i32;

    new_age = match validate_age(10) {
        Ok(new_age) => new_age,
        Err(msg) => {
            eprintln!("Error: {msg}");
            std::process::exit(1)
        }
    };
    println!("{}", new_age);

    Result<T, E> türüne geri dönen fonksiyonlarda if let deyimi pek işlevsel olamamaktadır. Çünkü bu durumda hata mesajı 
    etkin bir biçimde elde edilemeyecektir. Örneğin:

    if let Ok(new_age) = validate_age(10) {
        println!("{}", new_age);
    }
    else {
        eprintln!("invalid age!..");
    }

    Aklınıza else if let kullanmak da gelebilir. Ama bu durumda da bireden fazla kez kalıp uyuşumu yapılacaktır. Örneğin:

    if let Ok(new_age) =  result {
        println!("{}", new_age);
    }
    else if let Err(msg) = result {
        eprintln!("Error: {msg}");
    }

    Bu işlemin match deyiminden zaten bir farkı da kalmamıştır. C'deki gibi önce hatayı ele alıp sonra yola devam etmek de 
    Rust'ta genellikle iyi bir teknik değildir. Örneğin:

    let result =  validate_age(10);
    let new_age: i32;

    if let Err(msg) = result {
        eprintln!("{}", msg);
        std::process::exit(1);
    }
    new_age = unsafe {
        result.unwrap_unchecked()
    };
    println!("{}", new_age);

    Burada unwrap_uncheked metodu Ok kontrolü yapmamaktadır. Ancak metot unsafe olduğu için unsafe bağlamda çağrılma 
    zorunluluğu ortaya çıkmıştır. 

    Tıpkı Option<T> türünde olduğu gibi Result<T, E> türünün de unwrap_or_else metodu bulunmaktadır. Bu metot eğer Result
    değeri Ok(T) ise T türünden değeri, Err(E) ise E türünden değerle parametresiyle belirtilen closure çağrısını yapıp 
    clousure çağrısından elde edilen değeri geri döndürmektedir. Tabii burada closure çağrısının divergent olması 
    gerekmektedir. Örneğin:

    let new_age: i32;
    
    new_age = validate_age(10).unwrap_or_else(|msg| {
        eprintln!("Error: {msg}");
        std::process::exit(1)
    });
    println!("{}", new_age);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            75. Ders 05/01/2026 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz panic! makrosunu daha önce kullandık. Bu makro "telafi edilemeyecek (unrecoverable)" hata durumlarında programı 
    sonlandırmak için kullanılmaktadır. panic! makrosu argüman olarak hataya ilişkin bir bilgi alabilmektedir. panic! 
    makrosunda tıpkı print! makrosunda olduğu gibi "{}" biçiminde yer tutucular kullanılabilmektedir. Örneğin:

    if a < 0 {
        panic!("Invalid value: {}", a);
    }

    Burada panic oluştuğunda a değişkenin değeri de yazdırılmıştır. panic! makrosu hata mesajını stderr dosyasına yazdırmaktadır. 
    print! ve prinln! makrolarının mesajları stdout dosyasına eprint! ve eprintln! makrolarının ise stderr dosyasına 
    yazdırdığını anımsayınız.

    panic! makrosu aynı zamanda default durumda o zamana kadar yaratılmış ancak yok edilmemiş olan tüm yerel değişkenleri 
    drop etmektedir. Yani eğer ilgili tür Copy türü değilse ve Drop trait'ini destekliyorsa onların drop metotları da ters sırada 
    çağrılacaktır. Örneğin:

    fn main() {
        let x = Sample::new(10);

        foo(-10);
    }

    fn foo(a: i32) {
        let y = Sample::new(20);

        bar(a);
    }

    fn bar(a: i32) {
        let z = Sample::new(30);

        if a < 0 {
            panic!("invalid parameter!");
        }
    }

    struct Sample {
        val: i32,
    }

    impl Sample {
        fn new(val: i32) -> Self {
            Self { val }
        }
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("Drop: {}", self.val);
        }
    }

    Burada main fonksiyonu foo fonksiyonunu foo fonksiyonu da bar fonksiyonunu çağırmıştır. bar fonksiyonu içerisinde panic!
    makrosu çağrılmıştır. İşte default durumda programın başından beri yaratılan tüm yerel değişkenler için "ters sırada" 
    drop metotları çağrılacaktır. Yukarıdaki programın çıktısı panic haricinde şöyle olacaktır:

    Drop: 30
    Drop: 20
    Drop: 10

    Stack unwinding süreci için derleyici bizim görmediğimiz biçimde bazı kayıtlar da tutmaktadır. Sistem programlama 
    uygulamalarında bu tür ekstra kayıtlar genellikle istenmez. İşte Rust'ta panic sırasındaki "stack unwinding" durumu 
    "Cargo.toml" dosyası yoluyla elimine edilebilmektedir. Programcı isterse bu dosyaya aşağıdaki ekleyerek default olan 
    "unwind" durumunu "abort" haline getirebilmektedir:

    [profile.dev]
    panic = "abort"

    [profile.release]
    panic = "abort"

    Burada "dev" projenin debug versiyonunu, "release" ise release versiyonunu belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    panic! makrosunun dışında Rust'ta benzer amaçlarla kullanılan todo! ve unimplemented! makroları da vardır. Bu makrolar da 
    panic oluşturmaktadır. Dolayısıyla panic! makrosu için söylediklerimiz bu makrolar için de geçerlidir. İki makro arasında
    niyet bakımından belki bir farklılık düşünülebilir. todo! makrosu daha çok "şimdi yazılmadı ama ileride yazılacak" anlamına 
    gelmektedir. unimplemented! makrosu ise daha çok "kasti olarak yazılmadı" gibi bir anlama gelmektedir. Örneğin:

    fn foo() {
        todo!("foo");
    }

    Burada foo fonksiyonun içi henüz yazılmamıştır. İleride buraya dönülüp için yazılması gibi bir niyet vardır. 

    todo! ve unimplemented! makrolarının dışında unreachable! isimli bir makro da vardır. Bu makro "bir noktaya kodun
    gelmemesi gerektiği halde geldiği durumlarda panik oluşturmak için kullanılmaktadır. Örneğin.

    match foo() {
        0 => bar(),
        1 => tar(), 
        2 => zar(),
        _ => unreachable!("unexpected match!..")
    }

    Burada foo fonksiyonun geri dönüş değerinin i32 türünden olduğunu ve fonksiyonun normal olarak 0, 1 ya da 2 değeri 
    geri döndürdüğünü kabul edelim. match deyiminin exhaustive olması gerektiği için mecburen sonuna _ kalıbı yerleştirilmiştir. 
    Ancak aslında akış buraya hiç gelmemelidir. İşte bu tür durumlarda okunabilir bir biçimde panik oluşturmak için 
    unreachable! makrosu kullanılabilmektedir. (Tabii aslında yukarıdaki gibi bir örnekte foo fonksiyonun enum geri döndürmesi 
    daha iyi bir tekniktir. Çünkü bu durumda zaten tüm enum varyantları match kollarına dizildiğinde match ifadesi exhaustive
    hale gelmektedir. Ancak bu tür durumlarla da bazen mecburen karşılabilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta da C'de ve C++'ta olduğu gibi assert makroları vardır. Programlama dillerinde assert mekanizması programın 
    "release" versiyonunda bulunmayacak olan ancak "debug" versiyonunda böcek yakalamak için eklenen kontrol kodlarının 
    oluşturulmasını sağlamaktadır. assert makrolarında aslında görünüşte gereksiz olan kontroller koda eklenmektedir. Çünkü
    bu kontrollerin amacı programın geliştirilmesi sırasında olası hataların programcı tarafından tespit edilmesini sağlamaktır. 
    Assert mekanizmalarında "release" derlemesi yapılırken otomatik olarak tüm assert makroları koddan kaldırılır. Yani sanki
    onun oluşturduğu kontroller bir derleyici ayarıyla koddan atılmaktadır. Böylece geliştiricinin geliştirme aşamasında bolca
    assert kullanmasının bir sakıncası yoktur. Nasıl olsa onlar nihai üründe koddan çıkartılacaktır. 

    Rust'ta assert makrolarının listesi şöyledir:

    ┌──────────────────────┬────────────────────────────────────────────────────────────┬─────────────────┐
    │     Makro            │                    Parametreler                            │      Mod        │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ assert!              │ assert!(condition)                                         │ Debug + Release │
    │                      │ assert!(condition, format_string, args...)                 │                 │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ assert_eq!           │ assert_eq!(left, right)                                    │ Debug + Release │
    │                      │ assert_eq!(left, right, format_string, args...)            │                 │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ assert_ne!           │ assert_ne!(left, right)                                    │ Debug + Release │
    │                      │ assert_ne!(left, right, format_string, args...)            │                 │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ debug_assert!        │ debug_assert!(condition)                                   │ Sadece Debug    │
    │                      │ debug_assert!(condition, format_string, args...)           │                 │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ debug_assert_eq!     │ debug_assert_eq!(left, right)                              │ Sadece Debug    │
    │                      │ debug_assert_eq!(left, right, format_string, args...)      │                 │
    ├──────────────────────┼────────────────────────────────────────────────────────────┼─────────────────┤
    │ debug_assert_ne!     │ debug_assert_ne!(left, right)                              │ Sadece Debug    │
    │                      │ debug_assert_ne!(left, right, format_string, args...)      │                 │
    └──────────────────────┴────────────────────────────────────────────────────────────┴─────────────────┘
   
    Buradadaki başı debug ile başlamayan makrolar programın "release" versiyonunda da kodda kalmaktadır. Başı "debug" 
    ile başlayan makrolar programın "debug" versiyonunda koda eklenmekte, "release" versiyonunda koddan çıkartılmaktadır.
    Buradaki assert makroları aynı zamanda asıl argümanlardan sonra yer tutucu içeren mesaj yazısıda alabilmektedir. 
    Örneğin:

    fn draw_rect(row1: u32, col1: u32, row2: u32, col2: u32) {
        debug_assert!(row1 < row2 && col1 < col2, "invalid rectangle");

        println!("drawing rectangle...");
    }

    Burada ekranda dikdörtgensel bir çizim yapan fonksiyon yazılmıştır. Normal olarak bu fonksiyonda hiçbir zaman 
    row1 >= row2 ya da col1 >= col2 durumu oluşmamalıdır. İşte böyle bir kontrolü projeyi geliştirirken olası böcekleri 
    yakalamak amacıyla koda ekleyebiliriz. Nasıl olsa programın "release" aşamasında bunlar basit bir biçimde koddan 
    otomatik biçimde kaldırılabilecektir. 

    Pek çok IDE'de programın "debug" versiyonu ile "release" verisyonu bir combobox'tan ayarlanabilmektedir. Eğer derlemeyi 
    komut satırından yapıyorsanız default versiyon "debug" versiyonudur. "Release" versiyonunda derleme yapmak için rustc 
    derleyicisinde cargo aracında "--release" komut satırı argümanı kullanılmalıdır. Örneğin:

    rustc --release main.rs
    cargo build --release
    cargo run --release
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Rust'ta diğer bazı dillerde de bulunan ? ile temsil edilen önemli bir operatör vardır. Bu operatöre Rust dünyasında "soru 
    işareti operatörü (question mark operator)" ya da "try operatörü (try operator)" denilmektedir. "The Rust Reference" 
    dokümanlarında bu operatör 8.2.4. Bölümünde "The try propagation expression" başlığı altında ele alınmıştır. 

    ? operatörü tek "operand'lı sonek (unary postfix)" bir operatördür. Bu operatörün solundaki operand'ın Try isimli trait'i 
    destekleyen bir tür türünden olması gerekmektedir. Yani ifade? gibi bir kullanımda ifade'nin Try trait'ini destekleyen 
    bir tür türünden olması zorunludur. Her ne kadar ? operatörü daha genel biçimde trait ile ilişkilendirilmiş olsa da 
    tipik olarak Option ve Result türleri için düşünülmüştür. Zaten ilk zamanlar Try trait'i yoktu. Dolayısıyla ? operatörü 
    built-in bir biçimde Option ve Result türleriyle kullanılabiliyordu. 

    ? operatörünün nasıl bir işlev gördüğü ilk karşılaşan kişilerde kavramsal zorluk oluşturabilmektedir. Biz de önce bu 
    operatöre neden gereksinim duyulduğuna yönelik bir örnekle konuya girelim. foo ve bar fonksiyonlarının Option<i32>
    türüyle geri döndüğünü varsayalım. tar fonksiyonu da Option<i32> türüyle geri dönüyor olsun. tar fonksyionun foo ve bar 
    fonksiyonlarını çağırarak onların çarpım değerleriyle geri döndüğünü kabul edelim:

    fn foo(a: i32) -> Option<i32> {
        if a < 10 {
            Some(a * 2)}
        else {
            None
        }
    }

    fn bar(a: i32) -> Option<i32> {
        if a < 5 {
            Some(a * 4)}
        else {
            None
        }
    }

    fn tar(a: i32) -> Option<i32> {
        let val1: i32;
        let val2: i32;

        val1 = match foo(a) {
            Some(val) => val,
            None => return None
        };

        val2 = match bar(a) {
            Some(val) => val,
            None => return None
        };

        Some(val1 * val2)
    }

    Burada görüldüğü gibi tar fonksiyonu foo fonksiyonunu çağırdığında onun geri dönüş değerini kontrol etmektedir. Eğer foo
    None ile geri dönmüşse tar da None ile geri dönmektedir. Benzer biçimde bar fonksiyonun da geri dönüş değeri kontrol 
    edilmiştir. İşte ? operatörü bu sıkıcı işlemi yapan bir operatördür. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        76. Ders 07/01/2026 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    tar fonksiyonun yazımına bir kez daha dikkat ediniz:

    fn tar(a: i32) -> Option<i32> {
        let val1: i32;
        let val2: i32;

        val1 = match foo(a) {
            Some(val) => val,
            None => return None
        };

        val2 = match bar(a) {
            Some(val) => val,
            None => return None
        };

        Some(val1 * val2)
    }

    Burada eğer foo fonksiyonu Option<i32>::None varyantı ile geri dönüyorsa biz de tar fonksiyonunu hedef türün None varyantıyla 
    geri döndürmüş durumdayız. Aynı işlemi bar çağrısı için de yaptık. İşte buradaki işlemler ? operatörü ile çok daha kısa bir biçimde 
    yapılabilmektedir:

    fn tar(a: i32) -> Option<i32> {
        let val1: i32;
        let val2: i32;

        val1 = foo(a)?;
        val2 = bar(a)?;

        Some(val1 * val2)
    }

    O halde ? operatörü ne anlama gelmektedir? 
    
    1) Eğer ? operatörünün solundaki ifade Option<T> türündense ve Option<T>::None varyantı içeriyorsa bu operatör kullanıldığı 
    fonksiyonu hedef Option türünün None varyantıyla ile geri döndürmekte, eğer solundaki ifade Option<T> türündense ve 
    Option<T>::Some(val) varyantı içeriyorsa val değerini üretmektedir.

    2) Eğer ? operatörünün solundaki ifade Result<T, E> türündense ve Result<T, E>::Err(e) varyantını içeriyorsa bu operatör
    kullanıldığı fonksiyonu hedef türün Err(e.into()) değeri ile geri döndürmekte, eğer solundaki ifade Result<T, E> ve 
    Result<T, E>::Ok(val) varyantı içeriyorsaval değerini üretmektedir. 

    Şimdi de bu operatörün yaklaşık eşdeğerlerini oluşturalım. Örneğin exp ifadesi Option<T> türündne olsun ve ? operatörü 
    şöyle kullanılmış olsun:

    a = exp?;

    Bu işlemin eşdeğeri şöyledir:

    a = match exp {
        Some(val) => val, 
        None => return None
    };

    Şimdi de exp ifadesinin Result<T, E> türündne olduğunu kabul edelim ve ? operatörü aşağıdaki gibi kullanılmış olsun:

    a = exp?;

    Bunun match eşdeğeri de şöyledir:

    val = match exp {
        Ok(val) => val,
        Err(e) => return Err(e.into()),
    };

    Burada Result<T, E> türü söz konusu olduğunda ve match ifadesi Err(e) varyantını içerdiğinde fonksiyonun Err(e.into())
    varyantı ile geri döndürüldüğüne dikkat ediniz. From trait'inden gelen from ilişkili fonksiyonunun kaplayıcı destekleme
    sayesinde into metodu olarak da kullanılabildiğini anımsayınız. O halde yukarıdaki eşdeğerlik şöyle oluşturulabilir:

    val = match exp {
        Ok(val) => val,
        Err(e) => return Err(From::from(e)),
    };

    Buradaki son dönüştürmenin neden yapıldığını izleyen paragraflarda ele alacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let result: i32;

    result = tar(3).unwrap();
    println!("{}", result);
}

fn foo(a: i32) -> Option<i32> {
    if a < 10 {
        Some(a * 2)}
    else {
        None
    }
}

fn bar(a: i32) -> Option<i32> {
    if a < 5 {
        Some(a * 4)}
    else {
        None
    }
}

fn tar(a: i32) -> Option<i32> {
    let val1: i32;
    let val2: i32;

    val1 = foo(a)?;
    val2 = bar(a)?;

    Some(val1 * val2)
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de ? operatörünün Result<T, E> ile kullanıma basit bir örnek verelim. foo, bar ve tar fonksiyonları 
    Result<i32, &'static str> türü ile geri geri dönüyor olsun:

    fn foo(a: i32) -> Result<i32, &'static str> {
        if a < 10 {
            Ok(a * 2)
        }
        else {
            Err("invalid argument!..")
        }
    }

    fn bar(a: i32) -> Result<i32, &'static str> {
        if a < 5 {
            Ok(a * 4)}
        else {
            Err("invalid argument!..")
        }
    }

    fn tar(a: i32) -> Result<i32, &'static str> {
        let val1: i32;
        let val2: i32;

        val1 = foo(a)?;
        val2 = bar(a)?;

        Ok(val1 * val2)
    }

    Burada tar fonksiyonunda foo ve bar çağrılarına dikkat ediniz:

    val1 = foo(a)?;
    val2 = bar(a)?;

    Burada eğer foo ve bar fonksiyonları Err(e) varyantıyla geri dönerse tar fonksiyonu da bununla geri döndürülmüştür. 
    Eğer bu fonksiyonlar Ok(val) varyantıyla geri dönerlerse çağrılardan val değerleri elde edilmiştir. Fonksiyonlar aşağıdaki
    gibi bir kodla test edilebilir:

    fn main() {
        let result: i32;

        result = tar(3).unwrap();
        println!("{}", result);
    }
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let result: i32;

    result = tar(3).unwrap();
    println!("{}", result);
}

fn foo(a: i32) -> Result<i32, &'static str> {
    if a < 10 {
        Ok(a * 2)
    }
    else {
        Err("invalid argument!..")
    }
}

fn bar(a: i32) -> Result<i32, &'static str> {
    if a < 5 {
        Ok(a * 4)}
    else {
        Err("invalid argument!..")
    }
}

fn tar(a: i32) -> Result<i32, &'static str> {
    let val1: i32;
    let val2: i32;

    val1 = foo(a)?;
    val2 = bar(a)?;

    Ok(val1 * val2)
}

/*---------------------------------------------------------------------------------------------------------------------------
    exp? ifadesindeki ? operatörü eğer exp ifadesi Option<T> türünün None varyantını içeriyorsa fakat fonksiyonun geri dönüş 
    değeri Option<K> türündense gerekli dönüştürmeyi kendisi yapmaktadır. Aşağıdaki örneğe dikkat ediniz:

    fn foo(a: i32) -> Option<i32> {
        if a < 10 {
            Some(a * 2)}
        else {
            None
        }
    }

    Burada foo ve bar fonksiyonlarının Option<i32> geri dönüş değerine sahip olduğunu görüyorsunuz. Şimdi tar fonksiyonunun 
    aşağıdaki gibi yazılmış olduğunu düşünelim:

    fn tar(a: i32) -> Option<i64> {
        let result: i32;

        result = foo(a)?;

        Some(result as i64 * 2)
    }

    Burada foo fonksiyonun Option<i32>::None değeri ile geri döndüğünü düşünelim. Normalde fonksiyonun geri dönüş değeri 
    Option<i64> olduğu için burada bir sorun çıkacağını düşünebilirsiniz. Ancak yukarıda verdiğimiz eşdeğerlik dikkate 
    alındığında burada bir soun çıkmayacağı anlaşılacaktır:

    result = match foo() {
        Some(val) => val, 
        None => return None
    };

    Bu tür dönüştürmeye Rust'ta resmi olmayan bir biçimde "kovaryans dönüştürmesi" de denilmektedir. Aynı durum Result 
    türü için de geçerlidir. Örneğin:

    fn foo(a: i32) -> Result<i32, String> {
        if a < 10 {
            Ok(a * 2)
        }
        else {
            Err(String::from("invalid value!.."))
        }
    }

    fn tar(a: i32) -> Result<i64, String> {
        let result: i32;

        result = foo(a)?;

        Ok(result as i64 * 2)
    }

    Burada foo fonksiyonu Result<i32, String> türünden bir değer geri döndürmektedir. result = foo()? ifadesinin eşdeğerinin 
    aşağıdaki gibi olduğunu anımsayınız:

    result = match foo(a) {
        Ok(val) => val,
        Err(e) => return Err(e.into()),
    }

    Burada tar fonksiyonun geri dönüş değeribib Result<i64, String> türündne olması bir sorun oluşturmayacaktır. Çünkü 
    aslında derleyicinin geri döndürdüğü değer Result<i32, String> türünden Err(e.into()) değil Result<i64, String> türünden 
    Err(e.into()) değeridir. 

    Yukarıdaki anlatımlardan şu sonuçları çıkartabiliriz:

    1) exp? ifadesinde exp ifadesi Option<T> türündense ancak ifadenin kullanıdığı fonksiyon Option<K> türündense bir 
    sorun ortaya çıkmayacaktır. 

    2) exp? ifadesinde exp ifadesi Result<T, E> türündense ve ifadenin kullanıldığı fonksiyonun geri dönüş değeri Result<K, E>
    ise bir sorun ortaya çıkmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da anlatımlardan da anlaşılacağı gibi eğer exp? ifadesinde exp ifadesi Result<T, E> türündense fakat bu ifadenin 
    kullanıldığı fonksiyonun geri dönüş değeri Result<T, K> türündense exp? ifadesinin kullanımı error oluşturacktır. Örneğin:

    struct Sample;
    
    fn foo(a: i32) -> Result<i32, String> {
        if a < 10 {
            Ok(a * 2)
        }
        else {
            Err(String::from("invalid value!.."))
        }
    }

    fn tar(a: i32) -> Result<i32, Sample> {
        let result: i32;

        result = foo(a)?;           // error

        Ok(result * 2)
    }

    Burada result = foo()? ifadesinin eşdeğeri şöyledir:

    result = match foo(a) {
        Ok(val) => val, 
        Err(e) => Err(e.into()),        // error!
    };

    Burada artık adeta Err(e.into()) ifadesi sanki Result<i32, Sampel> türüne atanmış olmaktadır. Bu atama da geçersizdir. 
    
    İşte into metodu ya da from fonksiyonu bu tür durumlarda otomatik dönüştürme yapmakta kullanılmaktadır. Eğer exp? 
    türü Result<T, E> ise ancak ifadenin kullanıldığı fonksiyonun geri dönüş değerindeki E türü farlı ise (tabii T 
    türü de farklı olabilir) into metodu ya da from fonksiyonu bu dönüştürmeyi yapabiliyorsa sorun ortadan kaldırılmaktadır. 
    Örneğin:

    fn foo(a: i32) -> Result<i32, String> {
        if a < 10 {
            Ok(a * 2)
        }
        else {
            Err(String::from("invalid value!.."))
        }
    }

    fn tar(a: i32) -> Result<i32, Sample> {
        let result: i32;

        result = foo(a)?;       // geçerli

        Ok(result * 2)
    }

    struct Sample;

    impl From<String> for Sample {
        fn from(s: String) -> Self {
            Sample
        }
    }

    Burada artık tar içerisindeki result = foo(a)? çağrısı geçerlidir. Çünkü artık eşdeğerlikte Err(e.into()) varyantı 
    Result<i32, Sample> ile uyum hale gelmektedir. Burada bir noktaya dikkat ediniz. Yukarıdaki örnekte tar fonksiyonun 
    geri dönüş değeriin T generic parametresi i32 türünden olmak zorunda da değildir. Tabii tar fonksiyonunun içinde ona
    uygun düzenlemenin yapılması gerekmektedir. Örneğin:

    fn tar(a: i32) -> Result<i64, Sample> {
        let result: i32;

        result = foo(a)?;

        Ok(result as i64 * 2)
    }

    into çağrısının (ya da from çağrısının) Result türü için söz konusu olduğuna Option için söz konusu olmadığına dikkat 
    ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Konuya girişte ? operatörünün aslında yalnızca Option ve Result türü ile değil de genel olarak Try trait'ini destekleyen 
    türlerle kullanılabildiğini söylemiştik. Eskiden bu operatör gerçekteb Option ve Result türü ile çalışıyordu. Ancak 
    maalesef güncel Rust derleyicilerinin stabil versiyonlarında henüz programcı kendi yapıları ya da enum türleri için bu 
    trait'i destekleyememektedir. Bu özellik şimdilik ancak Rust'ın "nightly" tabir edilen deneme sürümlerinde kullanılabilmektedir. 
    Biz kursumuzda henüz konu tam oturmadığı için Try trait'inden bahsetmeyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi ? operatörünün kullanımına standart kütüphane bağlamında bir örnek verelim. Anımsanacağı gibi str (yani string
    dilimi) yapısının parse metodu eğer parse işlemi tamsayı türlerine doğru yapılıyorsa Result<T, ParseIntError> değeri
    ile geri dönmektedir. (Burada T tamsayı türlerini temsil ediyor.) Yani bu metot eğer parse işlemi başarılıysa bize Ok(T)
    türünden değer, başarısızsa Err(ParseIntError) türündne değer geri döndürmektedir. Şimdi aşağıdaki gibi bir fonksiyon 
    yazacak olalım:

    use std::num::ParseIntError;

    fn tsquare(s: &str) -> Result<i32, ParseIntError> {
        let result: i32;

        result = s.parse()?;
        Ok(result * result)
    }

    Burada tsquare fonksiyonu bir string dilim referansını parametre olarak alıp Result<i32, ParseIntError> türüne geri 
    dönmektedir. parse işleminin naısl yapıldığına dikkat ediniz:

    result = s.parse()?;

    Burada parse işlemi başarısızsa fonksiyon hemen geri önecektir. Başarılıysa da parse eidlen değer result değişkenine 
    atanacaktır. Fonskiyonu şöyle test edebiliriz:

    fn main() {
        let s = "10";
        let result: i32;

        result = tsquare(s).unwrap();
        println!("{}", result);
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::num::ParseIntError;

fn main() {
    let s = "10";
    let result: i32;

    result = tsquare(s).unwrap();
    println!("{}", result);
}

fn tsquare(s: &str) -> Result<i32, ParseIntError> {
    let result: i32;

    result = s.parse()?;
    Ok(result * result)
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                77. Ders 12/01/2026 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer geri fonksiyonun geri dönüş değerindeki Result türündeki Err türü ? operatörünün 
    solundaki türle uyuşmuyorsa fonksiyonun geri dönüş değerindeki Result türünün Err türü için From trait'inin desteklenmesi 
    gerekmektedir. Yukarıdaki örnekte tsquare fonksiyonunun geri dönüş değerinin MyErrot türünden olduğunu düşünelim:

    #[derive(Debug)]
    enum MyError {
        Err(&'static str),
    }

    fn tsquare(s: &str) -> Result<i32, MyError> {
        let result: i32;

        result = s.parse()?;
        Ok(result * result)
    }

    Burada parse metodu Result<i32, ParseIntError> ile geri dönemktedir. Halbuki fonksiyonumuz Result<i32, MyError> geri 
    dönüyor. İşte bu duurmda bizim ParseIntError türünün Myerror türüne dönüştürülmesini sağlayan From trait'ini desteklememiz
    gerekir. Örneğin:

    impl From<ParseIntError> for MyError {
        fn from(val: ParseIntError) -> Self {
            MyError::Err("Error!")
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::num::ParseIntError;

fn main() {
    let s = "10";
    let result: i32;

    result = tsquare(s).unwrap();
    println!("{}", result);
}

#[derive(Debug)]
enum MyError {
    Err(&'static str),
}

fn tsquare(s: &str) -> Result<i32, MyError> {
    let result: i32;

    result = s.parse()?;
    Ok(result * result)
}

impl From<ParseIntError> for MyError {
    fn from(val: ParseIntError) -> Self {
        MyError::Err("Error!")
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında henüz görmemiş olsak da bu tür durumlarda çokbiçimliliği kullanarak daha genel bir destek de oluşturulabilmektedir. 
    Rust'ın standart kütüphanesindeki ve standart olmayan pek çok kütüphanedeki Result enum türünün Err türü genel olarak 
    std::error::Error isimli bir trait'i desteklemektedir. İşte biz çokbiçimli davranışı da devreye sokarak bu Err türünü 
    Box<dyn std::error::Error> türünden alarak onun her türlü XXXError türü için geçerli olmasını sağlayabiliriz. Böylece 
    ? operatörünün solundaki Result türünden değerin Err türü ne olursa olsun (tabii bu türün std::error::Error türünü 
    desteklemesi gerekmektedir) tüm hataları elde edebiliriz. Örneğin:

    fn tsquare(s: &str) -> Result<i32, Box<dyn std::error::Error>> {
        let result: i32;

        result = s.parse()?;
        Ok(result * result)
    }

    Yukarıdakş kod sorunsuz derlenecektir. tsquare metodunun içerisindeki ? solunda bulunan ifade Result<i32, std::num::ParseIntError>
    olsa bile bir sorun çıkmayacaktır. Bu durumda hatanın ele alınması şöyle yapılabilecektir:

    fn main() {
        let s = "10";
        let result: i32;

        match tsquare("ankara") {
            Ok(val) => println!("{}", val),
            Err(e) => println!("{}", e),
        }
    }
    
    Burada elde edilecek mesaj aslında ParseIntError yapısının veridği mesajdır. Burada henüz görmediğimiz Box konusu olduğu 
    için biz açıklamaları burada keseceğiz. Ancak buradaki mekanizma diğer pek çok nesne yönelimli programlama dillerindeki 
    exception sınıflarının taban bir exception sınıfından türetilmiş olmasına benzemektedir. O dillerdeki taban exception 
    sınıfı ise hata mesajını çokbiçimli olarak veren metotlara sahiptir. Rust'taki std::error::Error trait'i Display ve 
    Debug trait'lerinden türetilmiştir:

    pub trait Error: Debug + Display {
        // ...
    }

    Elimizde bu trait türünden dyn bir referans varsa biz bu trait'lerin sağladığı metotlar yoluyla orijinal hata mesajını 
    elde edebilmekteyiz. 
---------------------------------------------------------------------------------------------------------------------------*/

 fn main() {
        let s = "10";
        let result: i32;

        match tsquare("ankara") {
            Ok(val) => println!("{}", val),
            Err(e) => println!("{}", e),
        }
    }

 fn tsquare(s: &str) -> Result<i32, Box<dyn std::error::Error>> {
    let result: i32;

    result = s.parse()?;
    Ok(result * result)
}

fn main() {
    let s = "10";
    let result: i32;

    match tsquare("ankara") {
        Ok(val) => println!("{}", val),
        Err(e) => println!("{}", e),
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki fonksiyona dikkat ediniz:

    fn get_square() -> Result<i32, Box<dyn std::error::Error>> {
        let val: i32;
        let mut s: String = String::new();
        let result: i32;

        std::io::stdin().read_line(&mut s)?;
        val = s.trim().parse()?;

        Ok(val * val)
    }

    Burada get_square fonksiyonu klavyeden (stdin dosyasından) bir değer okuyup o değerin karesiyle geri dönmektedir. 
    Burada önce std::io::stdin fonksiyonun geri döndürdüğü Stdin yapısı türünden değer ile read_line metodu çağrılmıştır. 
    buradaki read_line metodu aslında Result<i32, std::io::Error> türü ile geri dönmektedir. (Buradaki Error türünü 
    std::error::Error trait'i ile karıştırmayınız). Buradan elde edilen yazı ile de önce String yapısının trim metodu 
    çağrılmıştır. Bu trim metodu &str türünden bir string dilim referansı vermektedir. string dilim referansı ile de 
    str türünün parse metodu çağrılmıştır. Bu parse metodunun örneğimizde Result<i32, std::num::ParseIntError> türüyle 
    geri döndüğünğ anımsayınız. İşte burada aslında ? operatörünün solundaki ifadedeki Result türünün Err türleri farklıdır. 
    Fonksiyonda iki farklı tür için ? operatörünün kullanılması ancak fonksiyonun geri dönüş değerinin 
    Result<i32, Box<dyn std::error::Error>> olması ile sağlanabilmektedir. Bu örnekte get_square fonksiyonun geri dönüş 
    değeri aynı biçimde kullanılacaktır:

    fn main() {
        match get_square() {
            Ok(val) => println!("{}", val),
            Err(e) => println!("{}", e),
        }
    }

---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    match get_square() {
        Ok(val) => println!("{}", val),
        Err(e) => println!("{}", e),
    }
}

fn get_square() -> Result<i32, Box<dyn std::error::Error>> {
    let val: i32;
    let mut s: String = String::new();
    let result: i32;

    std::io::stdin().read_line(&mut s)?;
    val = s.trim().parse()?;

    Ok(val * val)
}

/*---------------------------------------------------------------------------------------------------------------------------
    Kurusumuzun bu bölümünde Rust'ta heap tahsisatları için kullanılan std::boxed modülünde bulunan Box yapısını ele alacağız. 
    Box Rust'ta built-in bir yapıdır. Dolayısıyla Box türünü kullanırken herhangi bir use işlemi yapmaya gerek yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi programlama dillerinde heap alanı iki gerekçeyle kullanılmaktadır:

    1) Derleme zamanında uzunluğu bilinmeyen ancak çalışma zamanında bilinen nesneleri tahsis etmek için.
    2) Nesnelerin ömürlerini kontrol etmek için.

    Programlama dillerindeki global değişkenlerin statik ömürlü olduğunu, yerel değişkenelrin ise içerisinde tanımlandıkları 
    bloğun yaşamı kadar olduğunu anımsaynız. Biz nesnelerin istediğimiz bir noktada yaratılmasını ve yok edilmesini istiyorsak
    onları heapt'te yaratıyorduk. 

    C++'ta bir kaynağın ömrünün bir nsnenin ömrüye ilişkilendirilmesine "RAII (Resource Acquisition is Initialization)"
    denilmektedir. C++'taki bu teknik sayesinde bir kaynak nesnenin ömrü bittiğinde otomatik boşaltılmaktadır. C++'ta 
    dinamik nesne tahsisatları için RAII prensibini kullanan "akıllı gösterici (smart pointer)" sınıfları bulundurulmuştur. 
    Ruts zaten RAII prensibini doğuştan desteklemektedir. İşte Rust'taki Box yapısı adeta C++'ta unique_ptr sınıfı gibi 
    bir işlev görmektedir. Box yapısı ile heap'te yapılan tahsisatlar Box değişkenn ömrü bittiğinde otomatik olarak heap'ten 
    silinmektedir. Tabii bu silinme işlemi Box yapısının Drop trait'ini desteklemesi ile sağlanmaktadır. Örneğin:

    {
        let b = Box::new(100);
        //...
    }

    Burada heap'te bir i32 uzunluğunda yer tahsis edilmiştir. Ancak tahsis edilen yer bir yapı değişkeni ile kullanıma 
    sunulmaktadır. Örneğimizdeki b yapı değişkeninin ömrü bittiğinde Box yapısının drop metodu çağrılacak ve heap'te 
    yapılan tahsisat serbest bırakılacaktır. Böylece Rust programcısı C'deki free gibi bir fonksiyonu C++'taki delete gibi 
    bir operatörü kullanmak zorunda kalmamaktadır. Rust'ta bu sayede bellek sızınısı olasılığı ortadan kaldırılmış olmaktadır. 
    Rust'ta Copy türündne olmayan her nesnenin bir sahibinin olduğunu ve bu sahipliğin atama işlemleriyle devredildiğini 
    anımsayınız. Örneğin:

    fn main() {
        let a: Box<i32>;
            
        a = foo();
        bar(a);
        //...
    }

    fn foo() -> Box<i32> {
        Box::new(100)
    }

    fn bar(b: Box<i32>) {
        //...
    }

    Burada foo fonksiyonun içerisinde Box::new(100) çağrısı ile heap'te i32 türünden bir nesne tahsis edilmiştir. Sonra bu 
    nesnenin sahipliği geri dönüş değerine ilişkin geçici değişkene devredilmiştir. Oradan da sahiplik a değişkenine 
    devredilmiştir. Sonra a değişkenin sahipliği bar fonksiyonun parametre değişkeni olan b'ye devredilmiştir. Nihateinde 
    heap'teki i32 türünden nesne bar fonksiyonu bittiğinde drop metodu yoluyla free hale getirilecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box yapısı yukarıdaki örnekten de gördüğünüz gibi generic bir yapıdır. Şöyle tanımlanmıştır:

    pub struct Box<T, A = Global>(/* private fields */)
    where
        A: Allocator,
        T: ?Sized;

    Bu tanımlamadan Box türünün iki generic parametresinin olduğu görülmektedir. T ile temsil edilen birinci generic parametre 
    heap'te tahsis edilecek nesnenin türünü belirtmektedir. İkinci generic parametre ise tahsisat işleminde kullanılacak 
    tahsisat nesnesinin türünü belirtmektedir. Bu generic parametrenin default olarak Global türünü belirttiğine dikkat ediniz. 
    Global isimli tahsisat yapısı zaten Rust'ta kullanılan default tahsisat yapısıdır. Yani tahsisatlar default durumda
    Rust'ın bu yapısının içerisindeki ilişkili fonksiyonlar tarafından yapılmaktadır. Programcılar bu default tahsisat yapısını 
    çok uç durumlarda değiştirmek zorunda kalmaktadır. (Örneğin programcı başka bir heap tahsisat algoritması kullanmak 
    isteyebilir. Box tahsisatlarının da bu algoritma tarafından yapılmasını sağlayabilir.) Tanımlamadaki generic tür 
    sınırlamalarına da dikkat ediniz. Tahsisatı yapacak yapının Allocator isimli bir trait'i desteklemesi gerekmektedir. 
    Ancak tahsis edilecek nesnenin türünün de derleme zamanında biliniyor olması gerekmemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box türünden bir değer Box yapısının new ilişkili fonkisyonuyla yaratılmaktadır. Örneğin:

    let b = Box::new(100);

    Bu bağlama aşağıdakiyle eşdeğerdir:

    let b: Box<i32> = Box::new(100);

    Burada 100 sabiti i32 türünden kabul edilmiştir. Tabii istenirse tahsisat türü açıkça da belirtilebilir. Örneğin:

    let b = Box::<i64>::new(100);

    Burada artık heap'te i64 türünden bir nesne yaratılmaktadır. b'nin türü de Box<i64> olacaktır. 

    Box<T> türünden bir değer yalnızca bir göstericinin uzunluğu kadar yer kaplamaktadır. Yani Box<T> türünü kullanmanın 
    doğrudan referans ya da gösterici kullanmaktan yer bakımından bir farkı yoktur. Örneğin:

    let b = Box::<i32>::new(100);

    println!("{:?}", std::mem::size_of_val(&b));        // 8

    64 bit sistemlerde adres bilgisinin 8 byte olduğunu anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box<T> türü Deref trait'ini desteklediği için doğrudan * operatörüyle kullanılabilmektedir. (Anımsanacağı gibi Deref 
    trait'ini destekleyen bir yapı ya da enum değerine * operatörü uygulandığında önce ilgili türün deref metodu çağrılıyordu. 
    Bu metot da bir referansa geri dönüyordu. * operatörü geri döndürülen referansa uygulanıyordu.) Bu durumda biz Box<T> 
    türünden bir değişkeni bir referans gibi kullanabiliriz. Örneğin:

    let b = Box::<i64>::new(100);
    let val: i64;

    val = *b;                   // b adeta bir &i64 türünden bir referans gibi davranıyor
    println!("{}", val);

    Buradaki *b ifadesinin *b.deref() ile eşdeğer olduğunu anımsayınız. İşte Box yapısının deref metodu adresini tuttuğu 
    heap'teki nesnenin referansına geri dönmektedir. Böylece biz Box türünden bir değişkenin & operatörü ile adresini 
    aldığımızda aslında heap'te tahsis edilmiş olan nesnenin referansını elde etmiş oluruz. 

    Eğer yapılan tahsisat bir yapı ya da enum türündense Box içerisindeki adresi tutulan nesneynin alanlarına doğrudan nokta 
    ile erişebilmektedir. Örneğin:

    let pt: Box<Point>;

    pt = Box::new(Point {x: 10, y: 20});
    println!("{}, {}", pt.x, pt.y);

    Tıpkı referanslarda olduğu gibi bizim (*pt).x ve (*pt).y gibi açıkça dereference işlemini yapmamıza gerek yoktur. 
    Bu tür erişimlerde otomatik Deref işleminin yapıldığını anımsayınız. The Rust Reference 8.2.11'de "Field Access Expressions" 
    başlığı altında bu durum şöyle açıklanmıştı:

    *****
    "if the type of the container operand implements Deref or DerefMut depending on whether the operand is mutable, 
    it is automatically dereferenced as many times as necessary to make the field access possible. This process is also 
    called autoderef for short."
    *****

    "The Rust Reference" dokümanlarındaki bu açıklamaya göre yukarıdaki pt.x ifadesi için derleyici önce Box türünde x 
    isimli bir alan var mı diye bakacak, eğer bulamazsa bu kez *pt işlemini yaparak Point türünde x'i arayacaktır. Dolayısıyla 
    burada Point türünün x alanına erişilecektir. 
    
    Sonuç olarak Box türünden bir değişken tamamen bir referans gibi davranmaktadır.

    Her ne kadar biz "Box türünden değişkenler üzerinde * gibi operatörler uygulandığında deref metodu çağrılıyor diyorsak 
    da" Box aslında built-in bir yapıdır. Dolayısıyla gerçekte bu deref çağrıları hiç yapılmamaktadır. Yani aslında Box 
    türünden bir değişkeni kullanmakla bir referansı kullanmak arasında yer ve zaman bakımından bir maliyet farkı yoktur. 

    Box<T> türünde T bit yapı ya da enum türündense nokta operatörü ile doğrudan T türünün metotları çağrılabilmektedir. 
    Örneğin:

    struct Point {
        x: i32,
        y: i32
    }

    impl Point {
        fn disp(&self) {
            println!("{}, {}", self.x, self.y);
        }
    }
    //...

    let b: Box<Point> = Box::new(Point {x: 10, y: 20});

    b.disp();       // burada (*b).disp() işlemine gerek ypk

    Burada b üzerinde otomatik olarak Deref dönüştürmesi yapılıp deref metodu çağrılacak ve elde edilen Point değeri ile
    disp metodu çağrılacaktır. Anımsacağı gibi "The Rust Reference" dokümanlarında "8.2.10 Method Call Expression" 
    başlığında bu metot çağrısındaki dönüştürme için şunlar söylenmişti:

    *****
    "The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver 
    expression’s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, 
    and adding the result type if that is successful.
    
    The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver 
    expression’s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, 
    and adding the result type if that is successful.
    
    Then, for each candidate T, add &T and &mut T to the list immediately after T.
    For instance, if the receiver has type Box<[i32;2]>, then the candidate types will be Box<[i32;2]>, &Box<[i32;2]>, 
    &mut Box<[i32;2]>, [i32; 2] (by dereferencing), &[i32; 2], &mut [i32; 2], [i32] (by unsized coercion), &[i32], 
    and finally &mut [i32]."
    *****
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box türünü kullanarak heap'te bir dizi de tahsis edebiliriz. Örneğin:

    let b: Box<[i32; 5]>;

    Burada b değişkeni Box<[i32; 5]> türündendir. Biz şimde Box::new ilişkili fonksiyonuna bir dizi verirsek heap'te dizi 
    tahsis edilecek ve verdiğimiz dizi heap'te tahsis edilen diziye atanacaktır. Örneğin:

    b = Box::new([10, 20, 30, 40, 50]);

    Anımsanacağı gibi Rust'ta x[i] ifadesi tamamen *std::ops::Index::index(&x, i) ya da *std::ops::Index::index_mut(&x, i) 
    ifadesiyle eşdeğerdir. Bu durumda yukarıdaki Box değişkenini biz b[i] gibi bir ifadede kullanırsak bu ifade 
    *std::ops::Index::index(&b, i) ile eşdeğer olacaktır. &b ifadesinde de Deref dönüştürmesi uygulanacağından b[i] ifadesi 
    de b değişkeninde adresi tutulan dizinin i'inci elemanına erişme anlamına gelecektir. Özetle biz böylesi bir durumda Box 
    değişkenini tamamen bir dizi gibi kullanabiliriz:

    let b: Box<[i32; 5]>;

    b = Box::new([10, 20, 30, 40, 50]);

    for i in 0..b.len() {
        print!("{} ", b[i]);
    }
    println!();

    Tabii dizi türleri için heap'te tahsisat yapılırken dizi uzunluğunun sabit ifadesi biçiminde belirtilmesi zorunludur. 
    Bu durumu C'deki malloc fonksiyonun işlevi ile ya da C++'ta new operatörünün işlevi ile karıştırmayınız. Örneğin:

    let size = 5;
    let b: Box<[i32; size]>;        // error! 

    Burada dizi uzunluğu sabit ifadesiyle belirtilmemiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        78. Ders 14/01/2026 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box türü ile bir trait türünden tahsisatlar da yapılabilmektedir. Ancak söz konusu trait'in dyn uyumlu olması ve trait 
    isminde önce dyn anahtar sözcüğünün kullanılması zorunludur. Böylece heap tabanlı çpkbiçimli davranışlar oluşturulabilmektedir. 
    Örneğin aşağıdaki gibi bir trait ve onu destekleyen yapılar bulunuyor olsun:

    trait Go {
        fn go(&self);
    }

    struct Car {
        //...
    }

    struct Truck {
        //...
    }

    struct Motorcycle {
        //...
    }

    impl Go for Car {
        fn go(&self) {
            println!("Car is going...");
        }
    }

    impl Go for Truck {
        fn go(&self) {
            println!("Truck is going...");
        }
    }

    impl Go for Motorcycle {
        fn go(&self) {
            println!("Motorcycle is going...");
        }
    }

    Biz Box<dyn Go> türünden bir değişken bildirebiliriz:

    let mut g: Box<dyn Go>;

    Burada g değişkeni aslında Go trait'ini destekleyen heap'te tahsis edilmiş olan nesnelerin adreslerini tutabilmektedir. 
    Biz bu g değişkeni ile trait metodunu çağırırsak dinamik türe ilişkin yani ilgili trait referansının gösterdiği türe 
    ilişkin yapnın ilgili metodu çağrılacaktır. Örneğin:

    g = Box::new(Car {});
    g.go();         // Car yapısının go metodu çağrılır

    g = Box::new(Truck {});
    g.go();         // Truck yapısının go metodu çağrılır

    g = Box::new(Motorcycle {});
    g.go();         // Motorcycle yapısının go metodu çağrılır

    Görüldüğü gibi çokbiçimli etki heap'te tahsis edilmiş olan neselerle de oluşturabilmektedir.    
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box türünden bir değişkenin faaliyet alan bittiğinde dropğ edildiğini dolayısıyla heap'teki nesnenin de free hale getirildiğini 
    belirtmiştik. İşte Box<T> türünden eğer T drop trait'ini destekliyorsa Box değişkeni dropğ edilirken heap'te tutulan 
    T türündne nesne için de drop metodu çağrılacaktır. Örneğin:

    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("Sample is dropping...");
        }
    }

    fn main() {
        println!("one");
        {
            let b = Box::new(Sample { val: 10 });

            println!("two");
        }
        println!("two");
    }

    Buarada Box değişkeni iç blok bittiğinde drop edilecektir. Bu değişkenin adresini tuttuğu heap'teki Sample nesnesi 
    üzerinde de drop metodu çağrılacaktır. Programı çalıştırdığımızda ekranda şunları göreceğiz:

    one
    two
    Sample is dropping...
    two
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki elimizde bir değişkeni varsa biz o değişken faaliyet alanını bitirmeden heap'teki alanı nasıl free hale getirebiliriz. 
    Örneğin:

    fn main() {
        let b = Box::new(Sample { val: 10 });

        // Bu noktada heap'ten temizlemek isteyebiliriz

        println!("program continues...");
    }

    Biz burada heap'te yaratılmış olan Sample türünden nesneyi belli bir noktada yok etmek isteyebiliriz. Bunun için Box 
    yapısında bir metot yoktur. Ancak Rust Standart Kütüphanesinde bu işlemin yapılmasına yol açan aşağıdaki gibi tanımlanmış
    std::mem modülünde drop isimli bir fonksiyon bulunmaktadır. Bu fonksiyon şöyle yazılmıştır:

    fn drop<T>(_: T) {    
    }

    Görüldüğü gibi drop fonksiyonu hiçbir şey yapmamaktadır. Box nesnesinin sahipliği fonksiyonun parametre değişkenine 
    aktarılacağına göre fonksiyon bittiğinde de zaten drop işlemi yapılacaktır. drop fonksiyonu standart prelude içerisinde 
    use edildiği için doğrudan kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box<T> türünden bir değişkene ya da değer & operatörü uygulayıp bu ifadeyi T türünden bir referansa atamak istediğimizde 
    Box<T> türü Deref<Target = T> trait'ini desteklediği için yapının deref metodu çağrılacaktır. Bu deref metodu da heap'te 
    tutulan nesnenin adresini bize vermektedir. Dolayısıyla biz istediğimiz zaman heap'teki nesnenin adresini bir referans 
    olarak elde edebiliriz. Örneğin:

    let b = Box::new(Sample { val: 10 });
    let r: &Sample;

    r = &b;
    println!("{}", r.val);

    Burada biz &b ifadesi ile Box değişkeninin adresini elde etmek istediğimizde aslında heap'teki Sample nesneninin adresini 
    elde etmiş olduk. Eğer referansın mut olmasını istiyorsak Box değişkenin de mut olması ve adresin &mut operatörüyle 
    elde edilmesi gerekmektedir. Örneğin:

    let mut b = Box::new(Sample { val: 10 });
    let r: &mut Sample;

    r = &mut b;
    println!("{}", r.val);      // 10
    r.val = 20;
    println!("{}", b.val);      // 20

    Burada görüldüğü gibi &mut b ifadesi ile Box değişkenin adresi alınarak mut bir referansa yerleştirilmiştir. Sonra da 
    bu referans yoluyla heap'tek Sample nesnesinin val alanı değiştirilmiştir. Biz mut referans atamaları konsuunu ele 
    almıştık. Anımsanacağı gibi bir referans onun son kullanıldığı noktada bu bağlamda faaliyet alanını bitiriyordu. Dolaısıyla
    yukarıdaki kod parçasında bir sorun oluşmayacaktır. Ancak anımsanacağı gibi bu kod parçası aşağıdaki gibi olsaydı 
    sorun ortaya çıkardı:

    let mut b = Box::new(Sample { val: 10 });
    let r: &mut Sample;

    r = &mut b;
    println!("{}", r.val);
    r.val = 20;
    println!("{}", b.val);      
    r.val = 30;                 // error!

    mut bir referansın faaliyet alanı boyunca o referansın gösterdiği yere ancak bu referanls erişilebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box<T> türünden bir değişkenin adresi T türünden bir göstericiye de atanabilir. Ancak bunun için önce * operatörü ile 
    heap'teki nesneye erişilip sonra onun adresi alınmalıdır. Örneğin:

    let b = Box::new(Sample { val: 10 });
    let ps: *constt Sample;
    ps = &*b;

    Burada ps = &*b; ifadesine dikkat ediniz. Bu ifadede önce *b işlemi yapılıp heap'teki Sample nesnesine erişilmiş, ondan 
    sonra onun adresi alınarak göstericiye yerleştirilmiştir. Burada bir noktaya dikkat ediniz. Bu işlemi biz ps = &b;
    biçiminde yapamayız. Çünkü burada Deref dönüştürmesinin devreye girmesi için atanacak hedef türün Smaple türünden referans 
    olması gerekir. Halbuki atanacak hedef tür referans değil bir göstericidir. Bu nedenle bu işlemi yapabilmek için önce *b ifadesiyle 
    Sample nesnesine erişilip sonra onun adresi elde edilmelidir. Box değişkenin gösterdiği heap'teki nesnenin mut olarak da
    adresi alınabilir. Örneğin:

    let mut b = Box::new(Sample { val: 10 });
    let ps: *constt Sample;
    let r: &mut Sample;

    r = &mut *b;

    Heap'teki nesnenin adresi elde edildikten sonra nesne yine faaliyet alanı bittiğinde drop edilecektir. Bu tür durumlarda
    tanımsız davranışlar oluşabilmektedir. Örneğin:

    fn main() {
        let ps: *constt Sample;
        {
            let b = Box::new(Sample { val: 10 });

            ps = &*b;
            unsafe {
                println!("{}", (*ps).val);
            }
        }
        unsafe {
            println!("{}", (*ps).val);      // dikkat tanımsız davranış!
        }
    }

    Burada iç blok bittiğinde heap'teki nesne drop edilecek dolayısıyla free hale getirilecektir. Artık nesneye blok dışından 
    erişmek tanımsız davranışa yol açacaktır. 

    Aslında &*b işlemini yapan Box yapısına as_ptr ve as_mut_ptr isimli ilişkili fonksiyonlar da eklenmiştir. Ancak bu fonksiyonlar 
    henüz karalı sürümde bulunmamaktadır. Bı ilişkili fonksiyonların parametrik yapıları şöyledir:

    pub fn as_ptr(b: &Box<T, A>) -> *const T
    pub fn as_mut_ptr(b: &mut Box<T, A>) -> *mut T

    Görüldüğü gibi fonlsiyonlar Box<T> türünden referan alıp mut olmayan ve mut olan gösteriye geri dönmektedir. 

    Hem heap'teki nesnenin sahipliği devredilip hem de onun göstericiye atanması isteniyorsa bunun için Box yapısının into_raw 
    isimli ilişki fonksiyonu kullanılmaktadır. Bu fonksiyonun parametrik yapısı şöyledir:

    pub fn into_raw(b: Box<T>) -> *mut T

    Burada into_raw ilişkili fonksiyonunun parametresinin referans olmadığına ve geri dönüş değerinin mut bir gösterici olduğuna 
    dikkat ediniz. Fonksiyon yapı değerinin sahipliğini almaktadır,  ancak tabii onu drop etmemektedir. Örneğin:

    fn main() {
        let ps: *mut Sample;
        {
            let b = Box::new(Sample { val: 10 });

            ps = Box::into_raw(b);
            unsafe {
                println!("{}", (*ps).val);
            }
        }
        unsafe {
            println!("{}", (*ps).val);      // artık tanımsız davranış değil
        }
    }

    Burada Box değişkenin içerisindeki nesne adresi Box::into_raw fonksiyonuyla elde edilmiştir. Bu fonksiyon sahipliği 
    devralmakla birlikte drop işlemini yapmamaktadır. Dolayısıyla iç bloktan çıkıldığında hala heap'teki nesne yaşıyor 
    durumda olacaktır. Tabii yukarıdaki örnekte artık nesnenin sahipliği tutulmadığı için onun drop edilmesi manuel olarak 
    sağlanmalıdır. Peki artık elimizde heap'taki nesneyi gösteren bir gösterici varsa biz bu nesneyi nasıl drop edeceğinz? 
    Bu nesnein drop edilmesi aşağıdaki gibi sağlanamamaktadır:

    drop(*ps);      // error!

    Ancak *ps ifadesinden sahipliği alarak yeniden orijinal türdne bir değerin elde edilmesi gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        79. Ders 19/01/2026 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    into_raw ilişkili fonksiyonun ters işlemi from_raw fonksiyonuyla yapılmaktadır. Fonksiyonun parametrik yapısı şöyledir:

    pub unsafe fn from_raw(raw: *mut T) -> Box<T>

    Fonksiyon *mut T türünden bir adresi paranetre olarak alıp bundan yaniden Bo<T> nesnesi oluşturmaktadır. Bu ilişkili 
    fonksiyon tipik olarak into_raw ilişkili fonksiyonuyla elde edilen göstericeden yeniden Box nesesi elde etmek için 
    kullanılmaktadır. Böylece biz bu yolla drop işlemini istediğimiz noktada gerçekleştirebiliriz. Yukarıda verdiğimiz 
    örneğe dikkat ediniz:

    fn main() {
        let ps: *mut Sample;
        {
            let b = Box::new(Sample { val: 10 });

            ps = Box::into_raw(b);
            unsafe {
                println!("{}", (*ps).val);
            }
        }
        unsafe {
            println!("{}", (*ps).val);      // artık tanımsız davranış değil
        }

        // göstericinin gösterdiği yer free hale getirilmemiştir
    }

    Burada b değişkeninin heap'te gösterdiği nesneyi gösteren bir gösterici elde edilmiştir. Ancak göstericinin gösterdiği 
    yerdeki Sample nesnesi free hale getirilmemiştir. Yukarıda drop(*ps) çağrısının da ypılamayacağını görmüştük. İşte bu 
    işlem tipik olarak from_raw ilişkili fonksiyonu yoluyla yapılmaktadır. Örneğin:

    fn main() {
        let ps: *mut Sample;
        {
            let b = Box::new(Sample { val: 10 });

            ps = Box::into_raw(b);
            unsafe {
                println!("{}", (*ps).val);
            }
        }
        unsafe {
            println!("{}", (*ps).val);      // artık tanımsız davranış değil
        }
        //...

        unsafe {
            let b = Box::from_raw(ps);
            drop(b);
        }
    }

    Aslında unsafe blok da bir faaliyet alanı belirttiğine göre değişkenin faaliyet alanı bittiğinde drop işlemi işlemi 
    yapılacağına göre hiç drop çağrısına bile gerek yoktur:

    unsafe {
            let _ = Box::from_raw(ps);
            //...
        }

    Benzer biçimde yukarıdaki işlem tek hamlede drop çağrılarak şöyle de yapılabilirdi:

    unsafe {
        drop(Box::from_raw(ps));
    }

    Box yapısının aslında burada açıkladığımızdan çok daha fazla metotları ve ilişkili fonklsiyonları vardır. Ancak çok 
    kullanılanlar bunlardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Box<T> yapısı ile ilgili anahtar noktalar şunlardır:

    - Box<T> yapısının amacı akışın belirli noktasında heap'te T türündne nesne tahsis etmektir. 

    - Box<T> türündne heap'te tahsisat yapmak için Box::new ilişkili fonksiyonu kullanılmaktadır. 

    - Box<T> türünden bir değişken ya da değer T türünden bir referans gibi kullanılabilmektedir. Örneğin b değişkeni Box<i32>                                         
    türündense heap tahsis edilmiş olan nesneye *b ifadesiyle erişilebilir. b değişkeni mut ise *b de mut durumdadır. 

    - Box<T> türündne değişken ya da değerin & operatör ile adresi alınarak T türünden bir referansa yerleştirilebilir. Örneğin:

    let b: Boxi32> = Box::new(100);
    let r: &i32;
    let mr: &mut i32;

    r = &b;             // geçerli
    mr = &mut b;        // geçerli

    - Box türünden bir değişkenin heap'te gösterdiği T türünden nesnenin adresini bir göstericiye atamak için &*b ifadesi 
    ya da &mut *b kullanılmaktadır. Örneğin:

    let b: Boxi32> = Box::new(100);
    let pi: *const i32;

    pi = &*b;       // geçerli

    Ancak bu biçimde adres elde edildiğinde b değişkeni de faaliyet alanını bitirdiğinde drop edilecektir. Heap'teki nesne 
    drop edildikten sonra göstericinin gösterdiği yere erişmek tanımsız davranışa yol açacaktır. 

    - Elimizde Box<T> türünden bir değişken varsa o değişkenin sahipliğini bırakarak heap'teki nesnenin adresi elde edilecekse
    bu işlem into_raw ilişkili fonksiyonuyla yapılmalıdır. Örneğin:

    let b: Boxi32> = Box::new(100);
    let pi: *mut i32;

    pi = Box::into_raw(b);

    Burada artık b değişkeni drop edilmeyecektir. Dolayısıyla b değişkeni faaliyet alanını bitirse bile onun heap'te gösterdiği 
    nesne free hale getirilmeyecektir. 

    - into_raw ilişkili fonksiyonuyla sahipliği bırakılmış ancak drop edilmemiş heap'teki nesnenin geri bırakılması için 
    yenidne ondan Box<T> değerinin oluşturulması ve onun drop fonksiyonuna verilmesi gerekmektedir. Bu işlem de from_raw 
    ilişkili fonksiyonuyla yapılmaktadır. Örneğin:

    let b: Boxi32> = Box::new(100);
    let pi: *mut i32;

    pi = Box::into_raw(b);
    //...
    unsafe {
        let _ = Box::from_raw(pi);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de Box uygulaması olarak başa ekleme yapılabilen "tek bağlı liste (single linked list)" örneği verelim. Bağlı 
    listemizin düğümünü aşağıdaki gibi bir yapıyla temsil edebiliriz:

    struct Node<T>  {
        val: T,
        next: Option<Box<Node<T>>>
    }

    Burada next alanının türü size biraz karşık gelebilir. Box<T> türünden bir değerin aslında heap'ta T türünden bir 
    nesneyi tuttuğunu anımsayınız. Buradaki Node yapısı generic olduğna göre Box içerisinde tutulan tür de Box<Node<T>> 
    biçiminde olacaktır. Öte yandan bağlı listenin son düğümü artık başka bir Box<Node<T>> türünü göstermeyeceği için bunu 
    Option<T> enum tür ile temsil edilmesi uygundur. O halde next alanı ya None değerini içermektedir (bağlı listenin 
    son elemanı böye olabilir) ya da Box<Node<T>> değerini içermektedir. Bağlı listenin kendisini temsil eden LList yapısını 
    da şöyle tanımlayabiliriz:

    struct LList<T> {
        head: Option<Box<Node<T>>>,
        count: usize
    }

    Eğer LList yapısının head alanı None ise henüz bağlı listede hiç eleman yoktur. Yapının vount alanı ise o anda bağlı 
    listedeki eleman sayısını tutmaktadır. 

    İlk yapılacak şüphesiz içi boş bir bağlı liste oluşturmaktır. Bu işlemi geleneksel olarak new ilişkili fonksiyonuna 
    yaptırabiliriz. Bizin push_front içerisinde yeni bir Node değeri yaratıp, LList yapısının head alanının orayı bu 
    yarattığımız bu düğümü göstermesini, yarattığmız bu düğümün de LList yapının head alanının gösterdiği düğümü göstermesini 
    sağlamamız gerekir. Ancak bu işlem şöyle yapılamaz:

    fn push_front(&mut self, val: T) {
        let new_node = Box::new(Node { val, next: self.head });       // error! kısmı sahiplik devredilmez
        self.head = Some(new_node);
        self. count += 1;
    }

    Buradaki sorun yeni yaratılan düğümün next alanına self.head alanın atanmasıdır. Rust'ta bir yapının Copy türünden 
    olmayan belli bir alanının sahipliği devredilememektedir. Box::new(Node {val, next: self.head}) işleminde self ile 
    belirtilen değişkenin head alanın sahipliği devredilmek istenmiştir. Bir yapı değişkenin bütünsel olarak sahipliği 
    devredilebilir ancak Copy türünden olmayan alanlarının sahipliği devredilemez. İşte bu tür durumlarda sahiplik 
    devredilmeden bir değişkenin içerisindeki değerin alınması gerekmektedir. Option enum türünün take isimli metodu 
    bunu yapabilmektedir. Biz take metodunu görmüştük. Bu metot Option değişkenin içerisindeki değeri alıp ona  None 
    vatyantını yerleştiriyordu. Ancak bu işlemi yaparken değişkenin sahipliğine dokunmuyordu. O halde yukarıdaki 
    push_front metodu şöyle düzeltilebilir:

     fn push_front(&mut self, val: T) {
        let new_node = Box::new(Node { val, next: self.head.take() });        // geçerli
        self.head = Some(new_node);
        self. count += 1;
    }

    Biz burada self.head.take() işlemi ile self içerisindeki head alanın değerini elde ettik ve head alanına None varyantını
    yerleştirdik. Bu take işlemi sahipliğe dokunmadan bu işlemi yaptı. Sonraki satırdaki self.head = Some(new_node) atamsı 
    self.head alanın drop edilmesine yol açacaktır. Ancak bunun bir sakıncası yoktur. Çünkü bu head alanında artık None 
    varyantı vardır. 

    Şimdi de dolaşım işlemini yapan disp isimli bir metot yazalım. Bu metodu yazarken biz dolaşımı sahipliği alarak 
    yapmamalıyız. Referanslarla ödünç alarak yapmalıyız. Metot şöyle yazılabilir:

    fn disp(&self) {
        let mut opt = &self.head;

        while let Some(boxed_node) = opt {
            print!("{:?} ", boxed_node.val);
            opt = &boxed_node.next;
        }
    }

    Burada opt değişkeni Option<Boz<Node<T>>> türünden bir referanstır. Yani biz burada opt değişkeninin içerisine 
    LList yapısının head alanın adresini atamış olduk. Artık bizim düğümler üzerinde yürümemiz gerekir. Bağlı listedeki 
    son düğümün next elemanının None varyantı içerdiğine dikkat ediniz. O halde bizim None görmeyene kadar, başka bir deyişle 
    Some kalıbı sağlandığı sürece döngüyü devam ettirmemiz gerekir. Bunun için while let deyimini kullandık:

    while let Some(boxed_node) = opt {
        //...
        opt = &boxed_node.next;
    }

    Bu döngü node_opt None olmayabna kadar devam etmesini ve Option alanın Some değerinin elde edilmesini sağlamaktadır. 
    Tabii biz bir sonraki düğüme geçmek için node_opt = box_node.next işlemini yaptık. 

    Şimdi de bağlı listenin başındaki düğümü silelim:

    fn pop_front(&mut self) -> Option<T> {
        let opt = self.head.take();
        if let Some(boxed_node) = opt {
            self.head = boxed_node.next;
            self.count -= 1;
            Some(boxed_node.val)
        }
        else {
            None
        }
    }

    Burada önce self.head.take ile LList yapıısnın head alanı elde edilmiştir. head alanının Optiontüründen olduğunu anımsayınız. 
    take metodu head alanının sahipliğini devretmeden içindeki değeri almakta ve oraya None varyantını yerleştirmektedir:

    let opt = self.head.take();

    Dolayısıyla bu işlemden sonra head alanın içerisinde None değeri bulunacak ce head alanı opt olarak elde edilecektir. 
    Bundan sonra metotta opt içerisinde Some varyantının bulunup bulunmadığına bakılmıştır:

    if let Some(boxed_node) = opt {
        //...
    }

    Eğer opt içerisinde Some varyantı varsa onun değeri boxed_value değişkenine aktarılmıştır. Burada boxed_value Node 
    yapısı türündendir. Sonra bağlı listenin başındaki bu düğümden sonra gelen düğüm head alanına atanmıştır:

    self.head = boxed_node.next;
    
    pop_front metodu bağlı listeden atılan ilk düğümdeki derler, bağlı listede hiç eleman yoksa None değeri ile geri 
    dönmektedir. 

    Buradaki bağlı liste tek bağlı listedir ve bağlı listenin ancak başına eleman eklenebilmektedir. Bağlı listenin sonuna 
    eleman eklenebilmesi için son düğümün de bir biçimde tutulması gerekir. Son düğümün Box biçimde tutulması yerine 
    düz bir gösterici ile tutulması işlemler bakımından kolaylık sağlamaktadır. Yukarıdak tek bağlı liste yapısını şöyle test 
    edebiliriz:

    fn main() {
        let mut ll = LList::<i32>::new();

        ll.push_front(10);
        ll.push_front(20);
        ll.push_front(30);
        ll.push_front(40);
        ll.push_front(50);

        ll.disp();
        println!("------------------");
        if let Some(val) = ll.pop_front() {
            println!("Deleted value: {}", val);
        }
        ll.disp();
        println!("------------------");
        if let Some(val) = ll.pop_front() {
            println!("Deleted Value: {}", val);
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::fmt::Debug;

fn main() {
    let mut ll = LList::<i32>::new();

    ll.push_front(10);
    ll.push_front(20);
    ll.push_front(30);
    ll.push_front(40);
    ll.push_front(50);

    ll.disp();
    println!("------------------");
    if let Some(val) = ll.pop_front() {
        println!("Deleted value: {}", val);
    }
    ll.disp();
    println!("------------------");
    if let Some(val) = ll.pop_front() {
        println!("Deleted Value: {}", val);
    }
}

struct Node<T>  {
    val: T,
    next: Option<Box<Node<T>>>
}

struct LList<T> {
    head: Option<Box<Node<T>>>,
    count: usize
}

impl<T> LList<T>
where T: Debug {
    fn new() -> LList<T> {
        LList {
            head: None,
            count: 0
        }
    }

    fn push_front(&mut self, val: T) {
        let new_node = Box::new(Node {val, next: self.head.take()});
        self.head = Some(new_node);
        self. count += 1;
    }

    fn pop_front(&mut self) -> Option<T> {
        let opt = self.head.take();
        if let Some(boxed_node) = opt {
            self.head = boxed_node.next;
            self.count -= 1;
            Some(boxed_node.val)
        }
        else {
            None
        }
    }

    fn disp(&self) {
        let mut opt = &self.head;

        while let Some(boxed_node) = opt {
            print!("{:?} ", boxed_node.val);
            opt = &boxed_node.next;
        }
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            80. Ders 21/01/2026 - Çarşamba                                  
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şmdi de Rust'ın standart kütüphanesindeki mem modülü üzerinde duralım. mem modülünde genellikle göstericilerin işin içine 
    karıştığı aşağı seviyeli fonksiyonlar ve yapılar bulunmaktadır. Bu bölümde mem modülündeki önemli olanları üzerinde 
    duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    mem modülündeki size_of fonksiyonu (C'de sizeof bir operatördür) bir türün bellekte kapladığı byte uzunluğunu vermektedir. 
    Fonksiyonun parametrik yapısı şöyledir:

    pub const fn size_of<T>() -> usize

    Burada size_of fonksiyonunun generic olduğuna ve parametresinin bulunmadığına dikkat ediniz. Fonksiyon usize türünden 
    değerle geri dönmektedir. Fonksiyonun parametresi olmadığı için ve geri dönüş değeri de generic parametre türünden 
    olmadığı için generic tür otomatik tespit edilemeyeceğinden programcının byte uzunluğunu elde etmek istediği türü 
    açısal parantezler içerisinde açıkça belirtmesi gerekmektedir. Örneğin:

    struct Sample {
        a: i16,
        b: i32,
        c: i64
    }
    //...

    let size = std::mem::size_of::<Sample>();
    println!("{}", size);           // 16

    Burada Sample yapısının bellekte kapladığı alan elde edilmiştir. Hizalama nedeniyle bu yapı türünden değişkenler bellekte 
    16 byte yer kaplayacaktır. Bu tür durumlarda hizalama göz önüne alınarak yapının a alanı i32 alınabilir:

      struct Sample {
        a: i32,
        b: i32,
        c: i64
    }

    Örneğin:

    let size = std::mem::size_of::<String>();
    println!("{}", size);       // 24

    Burada String türünden bir değişkenin 64 bit sistemlerde bellekte 24 byte yer kapladığı görülecektir. Çünkü bir String
    değişkeni içerisinde "bir adres, string'in uzunluğu ve kapasitesi" tutulmaktadır. Örneğin:

    let size = std::mem::size_of::<[i32; 10]>();
    println!("{}", size);           // 40

    Her biri i32 elemanlardan oluşan 10 byte'lık bir i32 türünden dizi bellekte toplam 40 byte yer kaplamaktadır. Örneğin:

    let size = std::mem::size_of::<&i32>();
    println!("{}", size);       // 8

    Referanslar aslında birer gösterici olduğuna göre bir referans için 64 bit sistemlerde bellekte 8 byte yer ayrılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    size_of fonksiyonu bir türün uzunluğunu elde etmektedir. Bir ifadenin türünün uzunluğunu elde etmek için size_of_val 
    fonksiyonu kullanılmaktadır. (C'deki sizeof operatörünün hem türle hem de ifadeyle kullanıldığını anımsayınız.) Fonksiyonun
    parametrik yapısı şöyledir:

    pub const fn size_of_val<T>(val: &T) -> usize
    where
        T: ?Sized,

    Görüldüğü gibi fonksiyon ifadenin kendisini değil adresini almaktadır. Dolayısıyla bir ödünç alma söz konusudur, sahiplik
    devri yapılmamaktadır. Örneğin:

    let x = 10i64;
    let size = size_of_val(&x);
    println!("{}", size);       // 8

    Örneğin:

    let a: [i32; 10] = [0; 10];
    let result = size_of_val(&a);
    println!("{}", result);     // 40
    
    Her ne kadar Rust'ın gramerinde size_of bir fonksiyon gibi ele alınmış olsa da aslında tıpkı C'de olduğu gibi tamamen 
    derleme zamanında adeta bir operatör gibi işleme sokulmaktadır. Yani size_of ve size_of_val birer fonksiyon olsa da 
    operatör gibi ele alınmaktadır. Bu fonksiyonların tanımlamalarındaki const anahtar sözcüğüne dikkat ediniz:

    pub const fn size_of<T>() -> usize
    pub const unsafe fn size_of_val<T>(ptr: *const T) -> usize
    where
        T: ?Sized,

    const fonksiyonlar tıpkı C++'taki const ve const_eval fonksiyonlar gibi derlme aşamasında çağrılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    mem modülündeki drop fonksiyonunu daha önce görmüştük. Bu aslında sahipliği alıp ilgili değerin drop edilmesini sağlayan 
    içi boş bir fonksiyondu:

    pub fn drop<T>(_x: T) {}

    mem modülündeki forget fonksiyonu da sahipliği almaktadır ancak bu fonksşyon sahipliğini aldığı değişken ya da değeri 
    drop etmemektedir. Tabii bu durum bellek sızıntılarına yol açabilir. Ancak bazen değişkenler Rust dışındaki başka 
    kütüphanelere gönderiliyor olabilir. Bu durumda boşaltım o kütüphane tarafından yapılıyor olabilir. Fonksiyonun parametrik
    yapısı şöyledir:

    pub const fn forget<T>(t: T)

    Aşağıdaki örnekte drop metodu çağrılmayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let s = Sample { val: 10 };
    std::mem::forget(s);
    //...
}

struct Sample {
    val: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("Dropping: {}", self.val);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    mem modülündeki take fonksiyonu bir değişkenin içerisindeki değeri onun sahipliğini almadan elde ederek aynı türden 
    başka bir değer olarak vermektedir. Ancak aynı zamanda değerini elde ettiği değişkenin içerisine o türün default değerini 
    de yerleştirmektedir. Fonksiyonun parametrik yapısı şöyledir:

    pub fn take<T>(dest: &mut T) -> T
    where
        T: Default

    Gördüğünüz gibi take generic bir fonksiyondur. Değişkenin adresini mut biçimde alarak o türden bir değere geri dönmektedir. 
    T türünün Default trait'ini desteklemesi gerektiğine dikkat ediniz. Çünkü take adresini aldığı değişkenin içerisine o 
    türün default değerini de yerleştirmektedir. Nümerik türler için default ilişkili fonksiyonun 0 değerine geri döndüğünü, bool 
    türü için false değerine geri döndüğünü, Option türü için de None değerine geri döndüğünü anımsayınız. Örneğin:

    #[derive(Default)]
    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("Dropping: {}", self.val);
        }
    }

    Bir değişkenin take fonksiyonunda kullanılabilmesi için o değişkenin türünün Default trait'ini destekliyor olması 
    gerekmektedir. Kullanıma dikkat ediniz:

    fn main() {
        let mut s = Sample { val: 10 } ;
        let k: Sample;

        k = std::mem::take(&mut s);
        println!("{}", k.val);          // 10
        println!("{}", s.val);          // 0
    }

    Burada s değişkeninin içerisindeki değer s'nin sahipliği devredilmeden yeni bir Sample değeri olarak elde edilmektedir. 
    Dolayısıyla artık s'nin içerisinde default değer bulunacaktır. Burada dikkat edilmesi gereken nokta blok bittiğinde 
    hem k için hem de s için drop işleminin yapılacağıdır. Çünkü take fonksiyonu s'nin içerisindeki değeri almakla birlikte 
    onun sahipliğini almamaktadır, yalnızca onun içerisindeki değeri çalmaktadır. Yukarıdaki kodu çalıştırdığınızda 
    ekranda (stdout dosyasında) şunları göreceksiniz:

    10
    0
    Dropping: 10
    Dropping: 0
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut s = Sample { val: 10 };
    let k: Sample;

    k = std::mem::take(&mut s);
    println!("{}", k.val);          // 10
    println!("{}", s.val);          // 0
}

#[derive(Default)]
struct Sample {
    val: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("Dropping: {}", self.val);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında daha önce görmüş olduğumuz Option<T> türünün take metodu da std::mem::take fonksionunu çağrımaktadır:

    impl<T> Option<T> {
        fn take(&mut self) -> MyOption<T> {
            std::mem::take(self)
        }
        //...
    }

    Burada take metodunun parametresinin &mut T türünden olduğuna dikkat ediniz. O halde doğrudan bu self parametresi
    std::mem::take fonksiyonuna argüman olarak geçirilmiştir. Aşağıdaki örnekte bu gerçekleştirimin nasıl yapıldığına yönelik 
    bir ipucu verilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut opt1: MyOption<i32> = MyOption::Some(123);
    let opt2: MyOption<i32>;

    opt2 = opt1.take();

    match opt1 {
        MyOption::Some(val) => println!("{}", val),
        MyOption::None => println!("None")
    }

    match opt2 {
        MyOption::Some(val) => println!("{}", val),
        MyOption::None => println!("None")
    }
}

enum MyOption<T> {
    Some(T),
    None
}

impl<T> Default for MyOption<T> {
    fn default() -> Self {
        MyOption::None
    }
    //...
}

impl<T> MyOption<T> {
    fn take(&mut self) -> MyOption<T> {
        std::mem::take(self)
    }
}

impl<T> Drop for MyOption<T> {
    fn drop(&mut self) {
        println!("droping...");
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Peki take fonksiyonun kendisi nasıl yazılmıştır? Anımsanacağı gibi std::ptr modülünün read fonksiyonu ya da gösterici türünün 
    read metodu değişkenin içerisindeki değeri okuyup sahipliği almadan yeni bir değer olarak veriyordu. std::ptr modülünün 
    write fonksiyonu ya da gösterici türünün write metodu da hedefi drop etmeden onun içerisine yeni değer yerleştiriyordu. ptrt 
    modülündeki read ve write fonksiyonlarının parametrik yapıları şöyleydi:

    pub const unsafe fn read<T>(src: *const T) -> T
    pub const unsafe fn write<T>(dst: *mut T, src: T)

    Örneğin:

    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("dropping...")
        }
    }

    fn main() {
        let s = Sample { val: 10 };
        let k: Sample;

        unsafe {
            k = std::ptr::read(&s);
        }
        println!("{}", s.val);
        println!("{}", s.val);
    }

    Bu örnekte sahiplik devredilmeden read fonksiyonun Sample içerisindeki byte'ları alarak yeni bir Sample değeri oluşturuğunu 
    ve o değerle geri döndüğünü görüyoruz. Ekranda (stdout dosyasında) şunlar görülecektir:

    10
    10
    dropping...
    dropping...

    Anımsayacağınız gibi ptr modülünün write fonksiyonu da hedefi drop etmeden ona yeni bir değer yerleştirmektedir. Örneğin:

    fn main() {
        let s = Sample { val: 10 };
        let mut k = Sample { val: 20 };

        unsafe {
            std::ptr::write(&mut k, s);
        }
    }

    Bu örnekte eğer k = s yapılsaydı k'daki değer önce drop edilip s'teki değer k'ya taşınacaktı. Halbuki write fonksiyonu 
    k'yı drop etmeden onu ezerek s'deki değeri taşımaktadır. Dolayısıyla bu örnekte ekranda tek bir "dropping..." yazısı 
    görülecektir. 

    İşte std::mem::take fonksiyonu aslında std::ptr::read ve std::ptr::write fonksiyonu kullanılarak yazılmıştır. Örneğin
    take fonksiyonunu biz de şöyle yazabiliriz:

    fn mytake<T>(dest: &mut T) -> T
    where
        T: Default {
        unsafe {
            let result = std::ptr::read(dest);
            std::ptr::write(dest, T::default());
            result
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut s = Sample { val: 10 };
    let k: Sample;

    k = mytake(&mut s);
    println!("{}", k.val);      // 10
    println!("{}", s.val);      // 0
}

fn mytake<T>(dest: &mut T) -> T
where
    T: Default {
    unsafe {
        let result = std::ptr::read(dest);
        std::ptr::write(dest, T::default());
        result
    }
}

#[derive(Default)]
struct Sample {
    val: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("dropping: {}", self.val);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında std::mem modülünde replace isimli daha genel bir fonksiyon bulunmaktadır. replace fonksiyonunun take fonksiyonundan 
    tek farkı değişkeni okduktan sonra ona default değer yerleştirmek yerine parametresiyle aldığı değeri yerleştirmesidir. 
    Fonksşyonun parametrik yapısı şöyledir:

    pub const fn replace<T>(dest: &mut T, src: T) -> T

    Fonksiyonun birinci parametresi değerin okunduğu ve yerleştirileceği değişkenin adresini almaktadır. İkinci parametresi 
    ise değer okunduktan sonra yerleştirilecek değeri belirtmektedir. İkinci parametrenin referans olmadığına dikkat ediniz. 
    Yani ikinci parametre sahipliği almaktadır. Örneğin:

    let mut s = Sample { val: 10 };
    let k: Sample;

    k = std::mem::replace(&mut s, Sample { val: 20 });
    println!("{}", k.val);      // 10
    println!("{}", s.val);      // 20

    Burada s değişken drop edilmeden içindeki değer okunmuş ve yen bir Sample değeri olarak k değişkenine yerleştirilmiştir. 
    Ancak s değişkenine default değer değil Sample { val: 20 } değeri yerleştirilmiştir. Tabii take fonksiyonu aslında daha
    genel olan replace fonksiyonunu çağırarak da yazılabilir:

    fn mytake<T>(dest: &mut T) -> T
    where
        T: Default {
        std::mem::replace(dest, T::default())
    }

    Tabii replace fonksiyonu da std::ptr::read ve std::ptr::write fonksiyonları kullanılarak benzer biçimde yazılabilir:

    fn myreplace<T>(dest: &mut T, src: T) -> T
    where
        T: Default {
        unsafe {
            let result = std::ptr::read(dest);
            std::ptr::write(dest, src);
            result
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut s = Sample { val: 10 };
    let k: Sample;

    k = std::mem::replace(&mut s, Sample { val: 20 });
    println!("{}", k.val);      // 10
    println!("{}", s.val);      // 20
}

#[derive(Default)]
struct Sample {
    val: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("dropping: {}", self.val);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    mem modülündeki swap fonksiyonu aynı türden iki mut değişkenin içerisindeki değerleri değiştirmektedir. Bu fonksiyon 
    da değişkenleri drop etmez ve onların sahipliklerini almaz. Fonksiyonun parametrik yaısı şöyledir:

    pub const fn swap<T>(x: &mut T, y: &mut T)

    Örneğin:

    #[derive(Debug)]
    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("dropping: {}", self.val);
        }
    }

    fn main() {
        let mut s = Sample { val: 10 };
        let mut k = Sample { val: 20 };

        std::mem::swap(&mut s, &mut k);
        println!("s: {:?}", s);     // s: Sample { val: 20 }
        println!("k: {:?}", k);     // k: Sample { val: 10 }
    }

    Tabii swap fonksiyonu da std::ptr::read ve std::ptr::write fonksiyonları kullanılarak yazılabilir:

    fn myswap<T>(x: &mut T, y: &mut T) {
        unsafe {
            let tempx = std::ptr::read(x);
            let tempy = std::ptr::read(y);

            std::ptr::write(y, tempx);
            std::ptr::write(x, tempy);
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let mut s = Sample { val: 10 };
    let mut k = Sample { val: 20 };

    myswap(&mut s, &mut k);
    println!("s: {:?}", s);     // s: Sample { val: 20 }
    println!("k: {:?}", k);     // k: Sample { val: 10 }
}

fn myswap<T>(x: &mut T, y: &mut T) {
    unsafe {
        let tempx = std::ptr::read(x);
        let tempy = std::ptr::read(y);

        std::ptr::write(y, tempx);
        std::ptr::write(x, tempy);
    }
}

#[derive(Debug)]
struct Sample {
    val: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("dropping: {}", self.val);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                        81. Ders 26/01/2026 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    mem modülündeki transmute fonksiyonu kaynak türdeki bir değeri byte'ları aynı olacak biçimde hedef türde bir değer 
    haline getirmektedir. Fonksiyonun parametrik yapısı şöyledir:

    pub const unsafe fn transmute<Src, Dst>(src: Src) -> Dst

    Fonksiyonun iki generic parametreye sahip olduğuna ve unsafe olduğuna dikkat ediniz. Fonksiyon parametresiyle aldığı 
    değerin byte'larını hedef türde bir değer haline getirip o değerle geri dönmektedir. Tabii böyle bir dönüştürme ancak 
    özel durumlarda ve anlamlıysa uygulanmalıdır. Örneğin:

    let a: i32 = 100;
    let b: f32;

    b = unsafe {
        std::mem::transmute(a)
    };
    println!("{}", b);      // dikkat anlamsız bir değer çıkacaktır!

    Burada i32 türünün üçerisindeki 100 değerini oluşturan byte'lar f32 haline getirilmiştir. Tabii bir böyle bir işlem 
    sonucunda anlamlı bir f32 değeri elde edilmeyecektir. Çünkü tamsayı formatı ile gerçek sayı sayı formatı tamamen 
    farklıdır. Örneğin:

    let a: i32 = 0x12345678;
    let bytes: [u8; 4];

    bytes = unsafe {
        std::mem::transmute(a)
    };
    for b in bytes {
        print!("{:x} ", b);         // 78 56 34 12 
    }
    println!();

    Burada 4 byte'tan oluşan i32 türünden bir değişkenin içerisindeki byte'lar 4 elemanlı u8 türünden bir dizi haline 
    getirilmiştir. Little Endian makinelerde ekrana (stdout dosyasına) 78 56 34 12 değerleri basılacaktır. 

    transmute fonksiyonundaki kaynak ve hedef türlerin uzunlukları farklıysa bu durum derleme aşamasında error oluşturmaktadır. 
    Örneğin:

    let a: i32 = 0x12345678;
    let b: f64;

    b = unsafe {
        std::mem::transmute(a)      // error!
    };

    Burada i32 türü f64 türüne transmute yapılmak istenmiştir. Bu işlem derleme aşamasında error ile sonuçlanacaktır. 

    transmute fonksiyonundaki parametrenin referans olmadığına dikkat ediniz. Dolayısıyla fonksiyon sahipliği almaktadır. 
    Ancak bu fonksiyon parametresiyle aldığı değeri hedefe kopyaladığından dolayı artık parametresiyle aldığı bu değeri 
    drop etmemektedir. Yani fonksiyon adeta kaynak türdeki değeri hedef türe taşımaktadır. Örneğin:

    fn main() {
        let s = Sample { a: 10, b: 20 };
        let pt: Point;

        pt = unsafe {
            std::mem::transmute(s)
        };

        println!("{}, {}", pt.x, pt.y);
    }

    struct Sample {
        a: i32,
        b: i32
    }

    struct Point {
        x: i32,
        y: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("Drop Sample: {}, {}", self.a, self.b);
        }
    }

    impl Drop for Point {
        fn drop(&mut self) {
            println!("Drop Point: {}, {}", self.x, self.y);
        }
    }

    Burada aynı uzunluktaki Sample değişkenin içerisindeki değer pt değişkenine taşınmıştır. Çağrıma dikkat ediniz:

    pt = unsafe {
        std::mem::transmute(s)
    };

    Burada Sample türünden değişken adeta Point türünden değişkene taşınmış gibi olmaktadır. Örneğimizde artık s drop 
    edilmeyecektir, ancak pt drop edilecektir. Programın çıktısı şöyle olacaktır:

    10, 20
    Drop Point: 10, 20
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let s = Sample { a: 10, b: 20 };
    let pt: Point;

    pt = unsafe {
        std::mem::transmute(s)
    };

    println!("{}, {}", pt.x, pt.y);
}

struct Sample {
    a: i32,
    b: i32
}

struct Point {
    x: i32,
    y: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("Drop Sample: {}, {}", self.a, self.b);
    }
}

impl Drop for Point {
    fn drop(&mut self) {
        println!("Drop Point: {}, {}", self.x, self.y);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            82. Ders 28/01/2026 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    transmute fonksiyonunu biz de aşağıdaki gibi yazabiliriz:

    pub unsafe fn mytransmute<T, U>(value: T) -> U {
        assert!(std::mem::size_of::<T>() == std::mem::size_of::<U>());

        let mut out = std::mem::MaybeUninit::<U>::uninit();
        std::ptr::copy_nonoverlapping(
            &value as *const T as *const u8,
            out.as_mut_ptr() as *mut u8,
            std::mem::size_of::<T>(),
        );
        std::mem::forget(value);
        out.assume_init()
    }

    Fonksiyonun başındaki assrt! makrosu eğer iki türün uzunlukları eşit değilse programın sonlanmasına yol açmaktadır. 
    Anımsayacağınız gibi kaynak ve hedef türün uzunlukları farklıysa transmute işlemi zaten derleme aşamasında error ile 
    sonuçlanıyordu. Biz henüz MaybeUninit türünü görmedik. İzleyen paragraflarda bu türün üzerinde duracağız. std::ptr 
    modülündeki copy_nonoverlapping fonksiyonuna geçirilen argümanlara dikkat ediniz. Fonksiyonun birinci parametresi kaynak 
    adresi, ikinci parametresi hedef adresi ve üçüncü parametresi de aktarılacak eleman sayısını (örneğimizde byte sayısını) 
    belirtmektedir. Anımsayacağınız gibi transmute edilen değer (yani parametre değişkenine taşınan değer) transmute 
    işleminden sonra drop edilmiyordu. forget fonksiyonu bunu sağlamak için çağrılmıştır. Fonksiyonun sonunda MaybeUninit 
    türünün assume_init metodunun çağrıldığına ve fonksiyonun bunun geri dönüş değeri ile geri döndürüldüğüne dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let s = Sample { a: 10, b: 20 };
    let pt: Point;

    pt = unsafe {
        mytransmute(s)
    };

    println!("{}, {}", pt.x, pt.y);
}

struct Sample {
    a: i32,
    b: i32
}

struct Point {
    x: i32,
    y: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("Drop Sample: {}, {}", self.a, self.b);
    }
}

impl Drop for Point {
    fn drop(&mut self) {
        println!("Drop Point: {}, {}", self.x, self.y);
    }
}

pub unsafe fn mytransmute<T, U>(value: T) -> U {
    assert!(std::mem::size_of::<T>() == std::mem::size_of::<U>());

    let mut out = std::mem::MaybeUninit::<U>::uninit();
    std::ptr::copy_nonoverlapping(
        &value as *const T as *const u8,
        out.as_mut_ptr() as *mut u8,
        std::mem::size_of::<T>(),
    );
    std::mem::forget(value);
    out.assume_init()
}

/*---------------------------------------------------------------------------------------------------------------------------
    std::mem modülünde transmute fonksiyonunun yanı sıra ona çok benzeyen bir de transmute_copy isimli bir fonksiyon vardır.
    Fonksiyonun parametrik yapısı şöyledir:

    pub const unsafe fn transmute_copy<Src, Dst>(src: &Src) -> Dst    

    Bu fonksiyonun transmute fonksiyonundan tek farkı parametresinin referans olmasıdır. Yani fonksiyon parametresine geçirilen 
    argümanın sahipliğini almamaktadır. Fonksiyonun işlevi transmute ile aynıdır. Tabii fonksiyon parametresine geçirilen 
    argümanın sahipliğini almadığına göre artık onun üzerinde forget fonksiyonunu da uygulamayacaktır. (Zaten isminin 
    transmute_copy olduğuna dikkat ediniz.) Örneğin:

    fn main() {
        let s = Sample { a: 10, b: 20 };
        let pt: Point;

        pt = unsafe {
            std::mem::transmute_copy(&s)
        };

        println!("{}, {}", pt.x, pt.y);
    }

    Burada transmute_copy fonksiyonuna s değişkeninin adresinin geçirildiğine dikkat ediniz. Tabii artık hem pt için hem de 
    s değişkeni için drop işlemi yapılacaktır. Bu program çalıştırıldığında aşağıdaki gibi bir çıktının görünmesi gerekir:

    10, 20
    Drop Point: 10, 20
    Drop Sample: 10, 20
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let s = Sample { a: 10, b: 20 };
    let pt: Point;

    pt = unsafe {
        std::mem::transmute_copy(&s)
    };

    println!("{}, {}", pt.x, pt.y);
}

struct Sample {
    a: i32,
    b: i32
}

struct Point {
    x: i32,
    y: i32
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("Drop Sample: {}, {}", self.a, self.b);
    }
}

impl Drop for Point {
    fn drop(&mut self) {
        println!("Drop Point: {}, {}", self.x, self.y);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    std::mem modülündeki çok kullanılan önemli bir tür de MaybeUninit isimli türdür. Bu tür şöyle tanımlanmıştır:

    pub union MaybeUninit<T> {
        /* private fields */
    }

    Buradaki union anahtar sözcüğü üzerinde daha sonra duracağız. Türün bir generic parametreye sahip olduğuna dikkat ediniz. 

    Normal olarak Rust'ta henüz değer atanmamış değişkenler atama ifadesi dışında kullanılamazlar. Örneğin onların adreslerini 
    alamayız:

    let a: i32;
    let r: &i32;
    let pi32: *const i32;

    r = &a;         // error!
    pi32 = &a;      // error!

    O halde biz bir değişklenin adresini alıp gösterici yoluyla oraya bir değer yazmak istesek bile Rust'ta ona ilkdeğer 
    vermek zorundayız. Bu durum değişkenlere bazen gereksiz ilkdeğer vermeyi zorunlu hale getirmektedir. Örneğin:

    fn main() {
        let mut a: i32;

        foo(&mut a);                // error!
        println!("{}", a);
    }

    fn foo(a: &mut i32) {
        *a = 100;
    }

    Burada aslında foo fonksiyonu a değişkenin içerisine değer yerleştirmektedir. Ancak henüz ilkdeğer atanmamış değişkenlerin 
    adresi alınamadığı için foo çağrısında error oluşacaktır. Bu durumda biz değişkene aslında ezilecek olan gereksiz bir ilkdeğer 
    vermek zorunda kalırız:

    let mut a: i32 = 0;

    foo(&mut a);       // geçerli       

    Yukarıdaki örnekte i32 küçük bir tamsayı türüdür. Ancak bu durum dizilerde daha dramitk hale gelmektedir. Örneğin:

    fn main() {
        let mut a: [i32; 100] = [0; 100];

        fill_array(&mut a);

        println!("{:?}", a);
    }

    fn fill_array(a: &mut [i32; 100]) {
        for i in 0..a.len() {
            a[i] = i as i32;
        }
    }

    Burada görüldüğü gibi biz mecburen adresini almadan önce 100 elemanlı dizinin her elemanına değer atamak zorunda kaldık. 
    Bu gereksiz atama işlemi bir zaman kaybına yol açacaktır. 

    Aynı sorun aşağıdaki gibi bir durumda da ortaya çıkacaktır:

    let mut a: [i32; 100];

    for i in 0..100 {
        a[i] = i as i32;
    }

    Biz dizinin tüm elemanlarına değer vermeden bir dizinin herhangi bir elemanına atama amaçlı bile erişemeyiz. 

    İşte MaybeUninit türü yukarıdaki sorunu çözmek için bulundurulmuştur. Biz MaybeUninit<T> türünden bir değişkeni yarattığımızda 
    aslında T türünden içerisine ilkdeğer verilmemiş bir değişken yaratmış gibi oluruz. 

    MaybeUninit türünden bir değişkene ilkdeğeri birkaç biçimde verilebilmektedir. MaybeUninit türünün uninit ilişkili 
    fonksiyonu aslında T türünden değişkene değer atamadan MaybeUninit<T> değişkenine değer vermeyi sağlamaktadır. Örneğin:

    use std::mem::MaybeUninit;

    let a: MaybeUninit<i32> = MaybeUninit::uninit();

    Burada biz a değişkenine ilkdeğer vermiş gibi olduk. Ancak a değişkenin tuttuğu i32 türünden değişkene değer vermedik. 
    Biçimsel (formal) olarak buradaki örnekte MaybeUninit::uninit() ile i32 türünden ilkdeğerverilmemiş bir değer yaratılmış 
    bu değer a'ya atanmıştır. Tabii daha önceden de belirttiğimiz gibi derleyiciler bu durumda kodu optimize ederek böyle bir 
    aslında hiç yapmamaktadır. 
    
    uninit ilişki fonksiyonu ile ilkdeğer verme aşağıdaki gibi yapılmazdı:

    let a = MaybeUninit::uninit();      // error!

    Burada generic T parametresinin türü tespit edilememektedir. Ancak aşağıdaki ilkdeğer verme geçerlidir:

    let a = MaybeUninit::<i32>::uninit();           // geçerli

    Örneğin:

    let a: MaybeUninit<[i32; 100]> = MaybeUninit::uninit();

    Burada biz a değişkenine ilkdeğer vermiş olduk, ancak a değişkeninin tuttuğu [i32; 100] dizisine ilkdeğer vermedik. 

    MaybeUninit<T> türünden değişkene en çok uninit ilişkili fonksiyonuyla ilkdeğer verilmektedir. Ancak ilkdeğer verme 
    için iki yöntem daha vardır. Türün zeroed isimli ilişkili fonksiyonu içi sıfırlarla dolu MaybeUninit değişkeni oluşturmaktadır.
    Örneğin:

    let a: MaybeUninit<[i32; 100]> = MaybeUninit::zeroed();

    Tabii böyle bir ilkdeğer verme genellikle MaybeUninit kullanımı ile çelişmektedir. Çünkü burada dizinin her elemanına 
    gerçekten 0 değeri yerleştirilecektir. Benzer biçimde değişkenin içerisine new ilişkili fonksiyonuyla belirli değerler 
    yerleştirilerek de MaybeUninit değişkeni yaratılabilmektedir. Örneğin:

    let a: MaybeUninit<i32> = MaybeUninit::new(100);

    Tabii bu da birkaç istisnai durum dıişında MaybeUninit kullanımı ile çelişmektedir. Yukarıda da belirttiğimiz gibi 
    genellikle MaybeUninit türünden değişkene ilkdeğer vermek için türün uninit ilişkili fonksiyonu kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit<T> türünden bir değişken T türü kadar yer kaplamaktadır. Yani bu tür T türünden değer dışında ek bir alana 
    sahip değildir. Örneğin:

    let a: MaybeUninit<i32> = MaybeUninit::uninit();

    println!("{}", std::mem::size_of_val(&a));      // 4
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit<T> türündeki T türü Copy türünden olmasa bile tutulan T değeri drop edilmemektedir.. Örneğin:

    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("dropping: {}", self.val);
        }
    }

    fn main() {
        let s: MaybeUninit<Sample> = MaybeUninit::new(Sample { val: 10 });
    
        // drop çağrılmayacak!
    }

    Burada MaybeUninit değişkeni tarafından tutulan Sample değeri için drop metodu çağrılmayacaktır. Bu çağrımın yapılmasını
    programcı kendisi manuel bir biçimde sağlamalıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit<T> türünden bir değişkenin içerisine T türünden değer yazmak için türün write metodu kullanılmaktadır. 
    Metodun parametrik yapısı şöyledir:

    pub const fn write(&mut self, val: T) -> &mut T

    Metot parametresiyle belirtilen val değerini değişkenin içerisindeki T değerine yerleştirip bu T  türünden değerin 
    mut referansıyla geri dönmektedir. Metodun unsafe olmadığına dikkat ediniz. Örneğin:

    let mut a: MaybeUninit<i32> = MaybeUninit::uninit();
    let r: &mut i32;

    r = a.write(100);
    println!("{}", *r);         // 100

    Burada a değişkenin içerisindeki i32 türünden alana 100 değeri yerleştirilmiştir. write metodu aynı zamanda tutulan 
    değişkenin T türündne mut referansını da vermektedir. 

    write metoodu eğer değişkende daha önce bir değer varsa ve T copy türündne değilse o değeri ezmeden önce drop etmez. 
    Örneğin:

    fn main() {
        let mut s: MaybeUninit<Sample> = MaybeUninit::new(Sample { val: 10 });

        s.write(Sample { val: 20 });
    }

    Burada Sample yapısı için drop metodu write işleminde de blok sonunda da çağrılmayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit türünden değişkenler genellikle mut yapılır. Çünkü onların içerisine daha sonra bir şeyler yazılacaktır. 
    MaybeUninit türünün as_ptr ve as_mut_ptr metotları değişkenin tuttuüu T türünden değerin sırasıyla const olan ve mut olan 
    adreslerini vermektedir. Metotların parametrik yapıları şöyledir:

    pub const fn as_ptr(&self) -> *const T
    pub const fn as_mut_ptr(&mut self) -> *mut T
    
    Bu sayede biz gösterici yoluyla da MaybeUninit türünden dğeişkenin içerisindeki değeri alıp değiştirebiliriz. Örneğin:

    let mut a: MaybeUninit<i32> = MaybeUninit::uninit();
    let pi32: *mut i32;

    pi32 = a.as_mut_ptr();
    unsafe {
        *pi32 = 10;
    }

    Artık biz ilkdeğer verilmemiş bir değişkenin adresini fonksiyona gönderip onun fonksiyon tarafından set edilmesini 
    sağlayabiliriz:

    fn main() {
        let mut a: MaybeUninit<i32> = MaybeUninit::uninit();
        let pi32: *mut i32;

        pi32 = a.as_mut_ptr();
        foo(pi32);

        unsafe {
            println!("{}", *pi32);      // 10
        }
    }

    fn foo(a: *mut i32) {
        unsafe {
            *a = 10;
        }
    }

    Yukarıdaki örneği bir yapı üzerinde de verebiliriz:

    use std::mem::MaybeUninit;

    fn main() {
        let mut s: MaybeUninit<Sample> = MaybeUninit::uninit();
        let ps: *mut Sample;

        ps = s.as_mut_ptr();
        foo(ps);

        unsafe {
            println!("{}", (*ps).val);
        }
    }

    fn foo(s: *mut Sample) {
        unsafe {
            (*s).val = 100;
        }
    }

    struct Sample {
        val: i32
    }

    impl Drop for Sample {
        fn drop(&mut self) {
            println!("dropping: {}", self.val);
        }
    }

    Burada herhangi bir drop çağrısı yapılmayacaktır. 

    Biz MaybeUninit değişkenin adresini de fonksiyona aktarıp fonksiyon içerisinde de işlemleri yapabilirdik. Örneğin:

    fn main() {
        let mut s: MaybeUninit<Sample> = MaybeUninit::uninit();

        foo(&mut s);
        //...
    }

    fn foo(s: &mut MaybeUninit<Sample>) {
        s.write(Sample { val: 10 });
    }

    Burada write metoduna Sample türünden değerin geçirilmesi gerektiğine dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit<T> türünün en önemli metotlarından biri assume_init denilen metottur. Bu metot doğrudan bize değişken içerisinde 
    tutulan T değerini vermektedir. Ancak aynı zamanda değişkeni de tüketmektedir. Yani bu metodu çağırdıktan sonra biz artık 
    MaybeUninit değişkenini kullanamayız. assume_init metodunun parametrik yapısı şöyledir:
    
    pub const unsafe fn assume_init(self) -> T

    Metodun self parametresinin referans olmadığına ve metodun da unsafe olduğuna dikkat ediniz. Örneğin:

    fn main() {
        let mut us: MaybeUninit<Sample> = MaybeUninit::uninit();

        us.write(Sample { val: 10 });

        let s = unsafe {
            us.assume_init()
        };

        println!("{}", s.val);      // 10
    }

    Bu örnekte us isimli MaybeUninit türünden değişken tüketilerek onun içerisinde değer elde edilmiştir. Biz yukarıda 
    MaybeUninit türünden değişkenlerin için drop edilmediğini belirtmiştik. Ancak onun içerisindeki değeri assume_init 
    ile aldığımızda artık elde ettiğimiz değer için drop işlemi yapılacaktır. Örneğimizde s değişkeni blok bittiğinde 
    drop edilecektir. s
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            83. Ders 04/02/2026 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    assume_init metodu MaybeUninit değişkeni içerisindeki değeri tüketerek almaktadır. Yani bu işlemden sonra MaybeUninit 
    değişkeni artık kullanılamaz. Eğer MaybeUninit değişkeninini tüketmeden onun içerisindeki T değerini elde etmek istiyorsanız 
    assume_init_mut metodunu kullanabilirsiniz. Netodun parametrik yapısı şöyledir:

    pub const unsafe fn assume_init_mut(&mut self) -> &mut T

    Metotun parametresinin self değil &mut self olduğuna dikkat ediniz. Metot değişkenin tuttuğu T türünden değerin mut adresiyle 
    geri dönmektedir. Bu işlemden sonra biz yine MaybeUninit değişkenini ve onun tuttuğu T türünden değeri kullanabiliriz. 
    Metodun unsafe olduğuna dikkat ediniz. Örneğin:

    let mut ua = MaybeUninit::<i32>::uninit();
    let r: &mut i32;

    r = unsafe {
        ua.assume_init_mut()
    };

    *r = 10;
    println!("{}", *r);      

    Burada assume_init_mut metodu ile değişkenin tuttuğu T türünden değerin mut adresi elde edilmiş, sonra da bu T değeri 
    referans yoluyla değiştirilmiştir. Tabii biz assume_init_mut ile verilen adresi mut bir referansa atadktan sonra artık 
    bu referansın faaliyet alanı boyunca bu a değişkeninin içerisindeki T değerini kullanamayız. Örneğin:

    let mut ua = MaybeUninit::<i32>::uninit();
    let r: &mut i32;

    r = unsafe {
        ua.assume_init_mut()
    };

    let b = unsafe {
        ua.assume_init()     // // error!
    };

    *r = 10;
    println!("{}", *r);   

    Türün assume_init_ref metodunun assume_init_mut metodundan tek farkı değişkenin içerisindeki T değerinin referansını 
    mut olmayan bir rererans olarak vermektedir. Metodun parametrik yapısı şöyledir:

    pub const unsafe fn assume_init_ref(&self) -> &T

    Metodun unsafe olduğuna ve geri dönüş değerinin mut olmayan bir referans olduğuna dikkat ediniz. Örneğin:

    let mut us = MaybeUninit::<Sample>::uninit();
    us.write(Sample { val: 10 });

    let r = unsafe {
        us.assume_init_ref()
    };
    println!("{}", r.val);

    MaybeUninit türünün assume_init_read isimli metodu değişkeni tüketmeden onun içerisindeki değeri elde etmektedir. 
    Metodun parametrik yapısı şöyledir:

    pub const unsafe fn assume_init_read(&self) -> T

    Metodun parametresinin &self türündne olduğuna dikkat ediniz. Metot MaybeUninit değişkeni içerisinde tutulan değerle 
    geri dönmektedir, ancak değişkeni tüketmemektedir. Bu nedenle biz örneğin birden fazla kez bu metodu kullanarak 
    değer elde edebiliriz. Tabii elde etiğimiz u drin hepsi drop edilecektir. 

    let mut us = MaybeUninit::<Sample>::uninit();
    us.write(Sample { val: 10 });

    let a = unsafe {
        us.assume_init_read()
    };
    println!("{}", a.val);      // 10

    let b = unsafe {
        us.assume_init_read()
    };
    println!("{}", b.val);      // 10

    Bu örnekte Sample türünden iki ayrı a ve b değişkeni elde edilmiştir. Faaliyet alanı bittiğinde bu a ve b değişkenleri 
    drop edilecektir.

    MaybeUninit türünün assume_init_drop metodunun ri dönüş değeri yoktur (Yani () türündendir) . Bu metot değişkenin içerisinde
    tutulan T değerini o anda drop etmektedir. Ancak değişkenin kendisini tüketmemektedir. Metodun parametrik yapısı şöyledir:

    pub unsafe fn assume_init_drop(&mut self)

    Metodun unsafe olduğuna ve geri dönüş değerinin olmadığına dikkat ediniz. Örneğin:

    let mut us = MaybeUninit::<Sample>::uninit();
    us.write(Sample { val: 10 });

    unsafe {
        us.assume_init_drop();
    }
    us.write(Sample { val: 20 });     // geçerli

    Burada biz assume_init_drop metodu ile us değişkenin tuttuğu Sample değerini drop ettik. Ancak us değişkeninin kendisini
    tüketmedik. Bu nedenle us değişkeni kullanabiliriz. Yani onun içerisine yeni bir değer yazabiliriz. assume_init_drop ile
    drop edilen T değerini unsafe bağlamda yeniden kullanmaya çalışırsanız bu durum tanımsız davranış oluşturacaktır. 
    Çünkü drop edilmiş olan değer kaynaklarını boşaltmış olabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsayazağınız gibi dizilere ilkdeğer vermeden dizinin herhangi bir elemanına değer atayamıyorduk. Örneğin:

    let mut a: [i32; 1_000_000];

    a[0] = 10;       // error!

    Bu tür durumlarda dizilerin tüm elemanlarına pratik bir biçimde ilkdeğer verebiliyorduk. Örneğin:

    let mut a: [i32; 1_000_000] = [0; 1_000_000];

    a[0] = 10;        // geçerli

    Dizi küçükse ona ilkdeğer vermek önemli bir zaman kaybına yol açmaz. Ancak dizi büyükse dizi elemanlarına yukarıdaki 
    gibi ilkdeğer verilmesi bir zaman kaybına yol açacaktır. Ayrıca eğer dizi elemanlarına sonra değerler aktarılıyorsa ilkdeğer 
    vermek gereksiz hale de gelmektedir. Örneğin:

    let mut a: [i32; 1_000_000] = [0; 1_000_000];

    for i in 0..a.len() {
        a[i] = i as i32;
    }

    İşte bu durumda büyük diziler için MaybeUninit türünün kullanılması gerekebilmektedir. Örneğin:

    let mut a: [MaybeUninit<i32>; 100_000] = [MaybeUninit::uninit(); 100_000];

    Burada dizinin kendisinin değil elemanlarının MaybeUninit olduğuna dikkat ediniz. Aslında burada verilen ilkdeğer 
    gerçek anlamda bir ilkdeğer değildir. Çünkü MaybeUninit::uninit() metodu aslında "ilkdeğer verme" anlamına gelmektedir. 
    Dolayısıyla derleyici yukarıdaki ilkdeğer verme işleminde ne kod olarak ne zamn olarak bir yük oluşturmayacaktır. 
    Yukarıdaki bildirim adeta C'deki aşağıdaki bildirimle eşdeğer hale gelmektedir:

    int a[100000];

    Artık yukarıdaki Rust dizisinin elemanlarına ilkdeğerlerini verebiliriz:

    for i in 0..a.len() {
        a[i].write(i as i32);
    }

    Şimdi dizinin ilk 10 elemanın içerisindeki değerleri yazdıralım:

    for i in 0..10 {
        let ri = unsafe {
            a[i].assume_init_mut()
        };
        print!("{} ", *ri)
    }
    println!();

    Tabii Copy türleri için assume_init ya da assume_init_read metotlarını da kullanabilirdik:

    for i in 0..10 {
        unsafe {
            print!("{} ", a[i].assume_init());
        };
    }
    println!();

    Yerel dizilerin stack'te yaratıldığınıve stack miktarının da şletim sistemlerinde göreli olarak düşün olduğunu 
    anımsayınız. Bu nedenle çok büyük dizileri zaten stack'te yaratamayabilirsiniz. Büyük dizilerin heap'te yaratılması
    doğru tekniktir. Bu tür durumlarda Rust'ta doğrudan dizi kullanmak yerine izleyen paragraflarda ele alacağımız Vec 
    yapısını kullanmak daha uygundur. Vec yapısı Rust'ta dinamik büyütülen dizileri temsil etmektedir. Bu yapı C++'ın 
    vector sınıfına benzetilebilir. Tabii Vec yerine biraz zahmetli de olsa Box kullanabiliriz. Örneğin:

    let a: Box<[MaybeUninit<i32>; 1_000_000]>;

    a = Box::new([MaybeUninit::uninit(); 1_000_000]);

    Burada büyük diziyi her elemanı MaybeUninit<i32> olacak biçimde heap'te yaratmış olduk. Tabii bu yaratımı daha pratik 
    bit biçimde eşdeğer olarak şöyle de yapabilirdik:

    let a = Box::new([MaybeUninit::<i32>::uninit(); 1_000_000]);    
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    MaybeUninit konusunu kapatmadan önce türün ilişkili fonksiyonları ve metotları üzerinde bir özet yapmak istiyoruz:

    - Türün uninit ilişkili fonksiyonu değişkeni içerisindeki T değerine ilkdeğer verilmemiş olarak yaratmaktaır.

    - Türün new ilişkili fonksiyonu değişkeni içerisindeki T değerine ilkdeğer vererek yaratmakmaktadır.

    - Türün zerod ilişkili fonksiyonu değişkeni içerisindeki T değeri sıfırlanmış olarak yaratmaktadır.
    (Amaç bakımından bu metot uç durumlarda kullanılabilir.)

    - Türün write metodu değişkenin içerisine  T değerini yazmak için kullanılmaktadır.

    - Türün as_ptr ve as_mut_ptr metotları değişkenin içerisindeki T değerinin adresini bir gösterici olarak vermektedir. 

    - assume_init metodu değişkenin tuttuğu T değerini vermektedir. Ancak bu metot değişkeni tüketmektedir. 

    - assume_init_read değişkenin tuttuğu T değerini vermektedir. Ancak bu metot değişkeni tüketmemektedir.

    - assume_init_mut değişkenin tuttuğu T değerininin mut referansını vermektedir. Bu metot değişkeni tüketmemektedir.

    - assume_init_ref değişkenin tuttuğu T değerininin mut olmayan referansını vermektedir. Bu metot değişkeni tüketmemektedir.

    - assume_init_drop değişkenin tuttuğu T değerini drop etmek için kullanılmaktadır. Bu metot değişkeni tüketmemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'taki Vec yapısını ele alacağız.                                        
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Uzunluğu baştan bilinmeyen programın çalışma zamanı sırasında değişebilen dizilere veri yapıları dünyasında "dinamik 
    dizi (dynamic array)" denilmektedir. C'nin standart kütüphanesinde dinamik diziler için hazır fonksiyonlar yoktur. C'de 
    dinamik diziler malloc ve realloc fonksiyonlarıyla manuel bir biçimde yaratılmaktadır. C++'ta dinamik diziler için 
    vector isimli sınıf şablonu bulundurulmuştur. Java ve C#'ta da dinamik diziler ArrayList isimli sınıfla temsil edilmiştir. 

    Dinamik dizilere neden gereksinim duyulmaktadır? İşte pek çok uygulamada dizinin uzunşuğu baştan bilinmemektedir. Dizinin 
    uzunluğu programın çalışma zamanı sırasında birtakım koşullara göre değişebilmektedir. Örneğin bir dizin ağacındaki bütün 
    dosyaların bilgilerini bir dizide saklayacak olalım. Baştan dizin ağacında kaç tane dosya olduğunu bilemeyiz. Önce bunun 
    sayısını hesaplayıp sonra onların bilgilerini ele geçirmek de işlemleri çok yavaşlatacaktır. Ya da örneğin TCP/IP'de 
    bir porttan gelen bilgileri bir dizide saklamak isteyebiliriz. Port'tan ne kadar bilgi geleceğini baştan bilemeyiz. 
    Ya da örneğin bir metin dosyasındaki "ankara" yazılarının dosyanın hangi offset'lerinde bulunduğunu bir dizide saklamak 
    isteyebiliriz. Dosyada kaç tane "ankara" yazısının bulunduğunu baştan bilemeyiz. Bu tür örneklerdeki ortak nokta şudur:
    Bir dizi yaratılacaktır, ancak dizinin uzunluğu baştan belli değildir. O halde dizi gerektikçe büyütülecektir. 

    Dinamk dizilerde başlangıçta dizi küçük bir uzunlukla heap'te yaratılır. Bu dizi dolduğunda dizi büyütülür. Ancak büyütme 
    işleminin birer birer her yeni eleman geldiğinde yapılması iyi bir teknik değildir. Çünkü bellek tahsisatları göreli 
    olarak yavaş işlemlerdendir. Her eleman geldiğinde dinamik dizinin uzunluğunu bir artırmak toplam tahsisat süresini uzatacaktır.
    Bu durumda aklınıza diziyi birer birer değil N'er N'er büyütmek gelebilir. Örneğin dizi baştan 4 uzunlukta açılabilir.
    Dolunca 4 elemanlık daha büyütülebilir. Böyle hep 4 eleman 4 eleman büyütme yapılabilir. Ancak bu yöntem de genellikle 
    tercih edilmemektedir. Bu yöntemde de yine yeniden tahsisat işlemleri zaman alıcı olmaktadır. En çok tercih edilen 
    yöntem diziyi "öncekenin belirli bir katı kadar (tipik olarak iki katı kadar)" büyütmektir. Örneğin dizi başlangıçta 
    heap'te 4 eleman uzunlukta yaratılabilir. Dolunca 8, o da dolunca 16, o da dolunca 32 biçiminde hep öncekinin iki katı 
    kadar büyütme yapılabilir. Bu biçimdeki büyütme geometik ya da üstel bir artışa yol açmaktadır. Dolayısıyla dizinin 
    büyütülmesi logaritmik karmaşıklığa düşürülmektedir. İşte programlama dillerinin standart kütüphanelerinde bulunan 
    dinamik dizilere ilişkin veri yapılarında genellikle büyütme öncekinin iki katı olacak biçimde yapılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            
---------------------------------------------------------------------------------------------------------------------------*/

