/*-----------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar
                                                     2. Bölüm

                                                Eğitmen: Kaan ASLAN

        Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
        Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

        Aslan, K. (2025), "Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
            C ve Sistem Programcıları Derneği, İstanbul.

                            (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                                    (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                            Son Güncelleme: 20/08/2025 - Çarşamba

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                82. Ders 20/02/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu bölümde geçici olarak Gömülü Linux sistemlerinin organize edilmesine yönelik konulardan uzaklaşıp kernel mod aygıt 
    sürücülerin yazılması ve kullanılması üzerinde duracağız. Sonra yeniden Linux sistemlerinin organize edilmesine ilişkin 
    "buildroot" ve "yocto" gibi araçları inceleyeceğiz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Giriş derslerinden de anımsayacağınız gibi modern Linux sistemleri işlemcilerin "korumalı mod" özelliklerini kullanıyordu. 
    Bu sistemlerde çalışan programların (yani proseslerin) "kullanıcı modu (user mode)" ya da "çekirdek modu (kernel mode)" biçiminde
    çalışma modları vardır. Normal bütün programlar kullanıcı modunda (user mode'da) çalışmaktadır. Ancak çekirdek kodları 
    "çekirdek modunda (kernel mode)" çalışır. Kullanıcı modunda koruma mekanizması aktiftir. Dolayısıyla kullanıcı modunda çalışan 
    programlar bellekte her yere erişemezler ve her makine komutunu kullanamazlar. Halbuki çekirdek kodları koruma mekanizmasına 
    takılmamaktadır. Yani çekirdek kodları bellekte her yere erişebilmekte ve her makine komutunu kullanabilmektedir. Daha önceden 
    de gördüğümüz gibi kullanıcı modundaki sıradan programlar işletim sisteminin içerisindeki ismine "sistem fonksiyonları ya da 
    sistem çağrıları" denilen özel fonksiyonları çağırabilmektedir. Kullanıcı modundaki programlar bir sistem fonksiyonunu çağırdığında
    programın akışı sistem fonksiyonu çağrıldığı anda çekirdek moduna geçer, sistem fonksiyonu çekirdek modunda çalıştırılır, 
    sonra sistem fonksiyonu bittiğinde programın akışı yeniden kullanıcı modune döner. Bunu şekilsel olarak şöyle gösterebiliriz:

    kullanıcı modunda çalışan sıradan program -----> sistem fonksiyonunu çağırıyor -----> programın akışı kullanıcı modundan 
    çekirdek moduna geçiliyor -----> ilgili sistem fonksiyonun kodları çalıştırılıyor -----> sistem fonksiyonun çalışması bitiyor
    -----> programın akışı çekirdek modundan yeniden kullanıcı moduna geçiyor.

    Kullanıcı modunda çalışan sıradan programlar sistem fonksiyonlarını genellikle doğrudan değil POSIX kütüphanesindeki POSIX
    fonksiyonları yoluyla dolaylı bir biçimde çağırmaktadır. Yani programcı bir POSIX fonksiyonunu çağırdığında o POSIX fonksiyonu 
    da bir sistem fonksiyonunu çağırabilmektedir. Tabii her POSIX fonksiyonun bir sistem fonksiyonunu çağırdığını söylemiyoruz. 
    Önceki konularda çekirdeğe yeni sistem fonksiyonu eklerken de gördüğümüz gibi programcı isterse syscall isimli "libc" kütüphane
    fonksiyonu ile numarasını belirterek de sistem fonksiyonlarını doğrudan çağırabilir. Tabii Linux'ta sistem fonksiyonlarının 
    çağrılmasının belli bir yöntemi vardır. Bunun için makine dilinde bazı komutların kullanılması gerekmektedir. syscall fonksiyonu
    bunu bizim için yapmaktadır.

    Linux çekirdeğinin içerisinde sistem fonksiyonlarının dışında binlerce fonksiyon vardır. Kullanıcı modunda çalışan normal 
    programlar yalnızca sistem fonksiyonlarını çağırabilmektedir.

    Biz bir programı etkin kullanıcı id'si 0 olacak biçimde "sudo" ile çalıştırdığımızda program yine kullanıcı modunda çalışmaktadır. 
    Bu "sudo" mekanizmasının bu konuyla bir ilgisi yoktur. Linux sistemlerinde kullanıcı id'leri bir kullanıcının bir programının 
    başka bir kullanıcının bir dosyasına erişip erişememesi konusunda etki göstermektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İşte çekirdeğin bir parçası biçiminde işlev gören çekirdek modunda çalışan özel programlara "çekirdek modülleri (kernel modules)
    ve "aygıt sürücüler (device drivers)" denilmektedir. Çekirdek modülleri ya da aygıt sürücülerin en önemli özelliği özelliği 
    bunların bellek ve komut koruma mekanizmasına takılmamalarıdır. Böylece biz kullanıcı modunda yapamayacağımız birtakım işlemleri 
    çekirdek modülleri ve aygıt sürücüler oluşturarak yapabilmekteyiz. Aslında aygıt sürücülerin çekirdek modu yerine kullanıcı 
    modunda çalıştığı işletim sistemleri de vardır. Bu tür çekirdek mimarilerine genel olarak "mikro çekirdek (micro kernel)" 
    mimarileri denilmektedir. Ancak Linux ve Windows sistemleri büyük ölçüde "monolitik" bir yapıdadır. Fakat bu işletim sistemlerine 
    de yavaş yavaş "kullanıcı modunda çalışan aygıt sürücüler" sokulmaktadır.

    Linux sistemlerinde "çekirdek modülü (kernel module)" ve "aygıt sürücü (device driver)" kavramları arasında bir fark vardır. 
    Çekirdeğe yüklenen bütün kodlara "çekirdek modülü" denilmektedir. Eğer bir çekirdek modülü kullanıcı modu ile ilişki kuruyorsa
    ya da birtakım kesme gibi olaylara yanıt verecek biçimde yazılmışsa bunlara aygıt sürücü denilmektedir. Yani her aygıt sürücü 
    bir çekirdek modülüdür ancak her çekirdek modülü bir aygıt sürücü değildir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinde ve aygıt sürücülerde her türlü fonksiyon kullanılamaz. Bunları yazabilmek için özel başlık dosyalarına 
    ve ve amaç dosyalara gereksinim duyulmaktadır. Bu nedenle ilk yapılacak şey bu başlık dosyalarının ve kütüphanelerin ilgili 
    sisteme yüklenmesidir.

    Genellikle bir Linux sistemini yüklediğimizde zaten çekirdek modüllerini ve aygıt sürücüleri oluşturabilmek için gereken 
    başlık dosyaları ve diğer gerekli öğeler "/usr/src" dizini içerisindeki "linux-headers-$(uname -r)" dizininde yüklü biçimde 
    bulunmaktadır. Ancak bunlar yüklü değilse Debian tabanlı sistemlerde bunları şöyle yükleyebilirsiniz:

    $ sudo apt install linux-headers-$(uname -r)

    Tabii programcı o anda çalışılan çekirdeğin kodlarının hepsini de kendi makinesine indirmek isteyebilir. Bunun için aşağıdaki 
    komut kullanılabilir:

    $ sudo apt-get install linux-source

    Bu indirmeler "/usr/src" dizinine yapılmaktadır.

    Ayrıca "/lib/modules/$(uname -r)" isimli dizindeki "build" isimli dizin de çekirdek kaynak kodlarının bulunduğu dizine ya 
    da aygıt sürücülerin derlenmesi için gereken öğelerin bulunduğu dizine (tipik olarak "linux-headers-$(uname -r)" dizinine) 
    sembolik link yapılmış durumdadır.

    Biz daha önce çekirdeği derlerken "make modules_install" yaptığımızda çekirdek modüllerinin install edildiği yerde "build" 
    isimli biri dizinin de oluşturulduğunu görmüştük. Bu "build" dizini aslında çekirdek kaynak kodlarına bir sembolik link 
    oluşturmaktaydı. Yani "make modules_install" yapıldığında aslında aynı zamanda çekirdek modüllerinin ve aygıt sürücülerin 
    derlenmesi ve link edilmesi için gerekli olan dosyalar da hedefe çekilmiş olmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünde biz user mod için yazılmış kodları kullanamayız. Çünkü orası ayrı bir dünyadır. Ayrıca biz çekirdek 
    modüllerinde çekirdek içerisindeki her fonksiyonu da kullanamayız. Yalnızca bazı fonksiyonları kullanabiliriz. Bunlara 
    "çekirdek tarafından export edilmiş fonksiyonlar" denilmektedir. "Çekirdek tarafından export edilmiş fonksiyon" kavramıyla 
    "sistem fonksiyonu" kavramının bir ilgisi yoktur. Sistem fonksiyonları kullanıcı modundan (user mode) çağrılmak üzere tasarlanmış 
    ayrı bir grup fonksiyondur. Oysa çekirdek tarafından export edilmiş fonksiyonlar kullanıcı modundan çağrılamazlar. Yalnızca 
    çekirdek modüllerinden çağrılabilirler. Buradan çıkan sonuç şudur: Bir çekirdek modülü yazılırken ancak çekirdeğim export 
    ettiği fonksiyonlar ve nesneler kullanılabilmektedir. Tabii çekirdeğin kaynak kodları çok büyüktür ancak buradaki kısıtlı 
    sayıda fonksiyon export edilmiştir. Benzer biçimde programcının oluşturduğu bir çekirdek modül içerisindeki belli fonksiyonları 
    da programcı export edebilir. Bu durumda bu fonksiyonlar da başka çekirdek modüllerinden kullanılabilirler. O halde özetle:

    1) Çekirdek modülleri yalnızca çekirdek içerisindeki export edilmiş fonksiyonları kullanabilir.
    2) Kendi çekirdek modülümüzde biz de istediğimiz fonksiyonu export edebiliriz. Bu durumda bizim çekirdek modülümüz çekirdeğin
    bir parçası haline geldiğine göre başka çekirdek modülleri de bizim export ettiğimiz bu fonksiyonları kullanabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mademki çekirdek modülleri işletim sisteminin çekirdek kodlarındaki fonksiyonları ve nesneleri kullanabiliyor o zaman çekirdek 
    modülleri o anda çalışılan çekirdeğin yapısına da bağlı durumdadır. Bu nedenle işletim sistemlerinde "çekirdek modülü yazmak" 
    ya da "aygıt sürücü yazmak" biçiminde genel bir konu yoktur. Her işletim sisteminin çekirdek modül ve aygıt sürücü mimarisi 
    diğerlerinden farklıdır. Dolayısıyla çekirdek modüllerinin ve aygıt sürücülerinin yazılması spesifik bir işletim sistemi için 
    geçerli olabilecek platform oldukça bağımlı bir konudur. Hatta işletim sistemlerinde bazı versiyonlarda genel aygıt sürücü 
    mimarisi bile değiştirilebilmektedir. Dolayısıyla bu tür durumlarda eski aygıt sürücüler yeni versiyonlarda, yenileri de eski 
    versiyonlarda çalışamamaktadır. Örneğin Linux'ta çekirdek versiyonları arasında çekirdekteki export edilmiş bazı fonksiyonlar 
    isim ya da parametrik yapı olarak değiştirilmiş durumdadır. Bu nedenle Linux çekirdeğinin belli bir versiyonu için yazılmış 
    olan aygıt sürücüler başka bir versiyonunda geçersiz hale gelebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin ve aygıt sürücülerin yazımı için programcının çekirdek yapısını ana hatlarıyla bilmesi gerekmektedir. 
    Çünkü bunları yazarken çekirdeğin içerisindeki çeşitli veri yapıları ve export edilmiş fonksiyonlar kullanılmaktadır.

    Linux çekirdek modülleri ve aygıt sürücüleri hakkında yazılmış birkaç kitap vardır. Bunların en klasik olanı "Linux Device 
    Drivers (3. Edition)" kitabıdır. Ancak bu kitaptaki bazı içerikler güncel çekirdeklerle uyumsuz hale gelmiştir. Bu konudaki 
    resmi dokümanlar ise "kernel.org" sitesindeki "documentation" kısmında bulunmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü derlemek ve link etmek maalesef sanıldığından daha zordur. Her ne kadar çekirdek modülleri ELF object 
    dosyaları biçimindeyse de bunlarda özel bazı "bölümler (sections)" bulunmaktadır. Dolayısıyla bu modüllerin derlenmesinde 
    özel gcc seçenekleri devreye sokulmaktadır. Çekirdek modüllerinin link edilmeleri de bazı kütüphane dosyalarının devreye 
    sokulmasıyla yapılmaktadır. Dolayısıyla bir çekirdek modülünün manuel biçimde "build edilmesi" için bazı ayrıntılı bilgilere 
    gereksinim duyulmaktadır. İşte çekirdek modüllerinin build edilmesinde çekirdeğin KBuild sistemi devreye sokulmaktadır. Bu 
    nedenle çekirdek modüllerinin build edilmesi için çekirdek kaynak kodlarındaki birtakım başlık dosyalarının ve Make dosyalarının 
    build işleminin yapılacağı makinede bulunması gerekir. Biz yukarıda bu dosyalara "/lib/modules/$(uname -r)/build" dizini 
    yoluyla erişilebileceğini belirtmiştik. Bu dizin aslında Linux kaynak kod ağacının bulunduğu dizini belirtmektedir. Ancak
    yukarıda da belirttiğimiz gibi çekirdek modüllerinin ve aygıt sürücülerin derlenmesi için Linux'ın tüm kaynak kodlarına
    gerek yoktur. Yalnızca başlık dosyaları ve make dosyalarının bulunması yeterlidir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri o anda çalışılan host sistem için derlenebileceği gibi gömülü bir sistem için de derlenebilir. Eğer derleme
    gömülü sistem için yapılacaksa süphesiz çapraz derleyicilerin de ilgili sistemde kurulu olması gerekir. Yukarıda da belirttiğimiz 
    gibi çekirdek modüllerinin derlenmesi için ilgili çekirdeğe yönelik başlık dosyaları ve çeşitli make dosyaları gibi 
    bazı öğelerin de bulunuyor olması gerekir. Eğer derleme bir gömülü sistem için yapılacaksa o gömülü sistemdeki çekirdeğe 
    ilişkin bu dosyalar da host makinede bulunuyor olmalıdır. Örneğin biz masaüstü bilgisayardaki Mint dağıtımında çalışıyor 
    olalım. Bu sistemin kendisi için çekirdek modülü derleyeceksek zaten tüm gerekli öğeler hazır bulunuyor olacaktır. Ancak biz 
    bu makinede BBB için çekirdek modülü ve aygıt sürücü derlemesi yapacaksak çapraz derleyicimizin ve BBB'deki çekirdeğe yönelik 
    temel başlık dosyalarının ve Make dosyalarının bulunuyor olması gerekecektir. Tabii BBB'deki çekirdek sürümüne kaynak kodları 
    bu makineye çekerek bu gereksinimi karşılayabiliriz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Masaüstü bir sistem için çekirdek modül derlemesinde kullanılabilecek minimal bir "Makefile" dosyası aşağıdaki gibi olabilir:

    obj-m += generic.o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Burada önce "/lib/modules/$(uname -r)/build" dizinindeki "Makefile" dosyası çalıştırılmış ondan sonra çalışma bu yazdığımız 
    make dosyasından devam ettirilmiştir. Özetle bu make dosyası aslında çekirdeğin build sistemini kullanarak "generic.c" isimli 
    dosyanın derlenmesini ve çekirdek modülü biçiminde link edilmesini sağlamaktadır. Tabii bu make dosyasını şöyle de düzenleyebiliriz:

    obj-m += generic.o

    KDIR := /lib/modules/$(shell uname -r)/build
    PWD := $(shell pwd)

    all:
        make -C ${KDIR} M=${PWD} modules
    clean:
        make -C ${KDIR} M=${PWD} clean

    Çekirdek modülü birden fazla kaynak dosya kullanılarak oluşturulabilir. Bu durumda ilk satır şöyle oluşturulabilir:

    obj-m += a.o b.o c.o...

    Eğer bu dosyaları birden fazla satırda ayrı ayrı belirtirsek bu durumda birden fazla modül dosyası oluşturulur:

    obj-m += a.o
    obj-m += b.o
    obj-m += c.o
    ...

    Eğer derlenecek dosyayı komut satırından girmek istiyorsanız Makefile dosyasını aşağıdaki gibi de düzenleyebilirsiniz:

    obj-m += ${file}.o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Bizim oluşturduğumuz Makefile dosyasındaki "all" hedefine dikkat ediniz:

    $ make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules

    make programının -C seçeneği Makefile dosyasını aramadan önce bu seçeneğin argümanında belirtilen dizine geçiş yapmaktadır.
    Dolayısıyla aslında yukarıdaki satırla "/lib/modules/$(shell uname -r)/build" dizinindeki Makefile dosyası çalıştırılacaktır.
    Buradaki M=${PWD} derlenecek kaynak dosyaların o anda çalışılan dizinde aranacağını belirtmektedir. Böylece çekirdeğin KBuild
    sistemi yalnızca bizim dosyalarımızı derleyecektir.

    Makefile oluştururken bir noktaya dikkat ediniz. Make dilinde hedeflerin aşağısındaki yapılacak işlemler bir tab içeriden 
    yazılmaktadır. Bazı text editörler TAB tuşuna basıldığında dosyaya TAB karakter yerine belli miktar (tipik olarak 4) SPACE
    karakteri basmaktadır. TAB yerine n tane SPACE karakterinin basılması make dosyalarında bir derleme sorununa yol açacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                83. Ders 25/02/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerini va aygıt sürücüleri derlerken iki noktaya dikkat etmelisiniz:

    1) Kullandığınız çekirdek kodları hedef makinenin çekirdek sürümüne uygun olmalıdır. Eğer bu koşul sağlanmazsa çekirdekler
    arasında farklılıklar söz konusu olabileceği için derlenmiş olan çekirdek modül dosyası hedef sisteme başarılı bir biçimde
    yüklenemeyebilir. Tabii Linux çekirdeğindeki değişiklikler daha önce yazılmış olan her çekirdek modülünü ve aygıt sürücüyü
    geçersiz hale getirmemektedir. Örneğin minör numara değişikliklerinde genellikle bir sorun oluşmamaktadır. Ancak ne olursa 
    olsun derleme yapılırken hedef sistemdeki çekirdeğe uygun kaynak dosyaların kullanılması şiddetle tavsiye edilmektedir. 
    Örneğin biz 6.9.2 çekirdeğinde çalışan makine için aygıt sürücüsü yazacaksak derleme yaptığımız makinede kullanacağımız 
    çekirdek kaynak kodlarının da bu 6.9.2 çekirdeğine ilişkin olması gerekir. Biz eski bir çekirdeğin kaynak kodlarıyla yeni 
    bir çekirdek için aygıt sürücü derlemeye çalışmamalıyız. Tabii eski bir veriyon kullanılarak derleme yapılırsa çoğu 
    durumda bir sorun ortaya çıkmayabilecektir. Ancak sorunun ortaya çıkma olasılığı da vardır.

    2) Kullanılan araç zincirinin de (yani derleyici, linker gibi programların da) çekirdeğin derlenmiş olduğu sistemle uyumlu
    olmasına dikkat ediniz. Eğer bu temel araçların versiyonlarında geçmişe doğru uyumu bozabilecek değişiklikler söz konusuysa
    yine derleme işlemi başarısız olabilir ya da çekirdek modülü yüklenirken sorun oluşabilir. Aslında çekirdeğin KBuild sistemi 
    çekirdek konfigürasyon dosyası yoluyla bu kontrolü yapabilmektedir. Ancak bu kontrol bypass da edilebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki bir çekirdek modülünü ya da aygıt sürücüyü gömülü bir Linux sistemi için derlerken yukarıdaki iki madde dışında nelere 
    dikkat etmemiz gerekir? Host makine genellikle Intel tabanlı hedef makine de ARM tabanlı olacaktır. O halde yine bir çapraz 
    derleme işleminin yapılması gerekir. Çapraz derleme yaparken make işleminde yine CROSS_COMPILE çevre değişkeni set edilmelidir. 
    Derlemenin yapıldığı kabukta yine çağıran derleyicinin "bin" dizini için PATH çevre değişkeninin ayarlanmış olması gerekir. 
    Ayrıca make işleminde ARCH çevre değişkeninin "arm" biçiminde ya da "arm64" biçiminde belirtilmiş olması gerekir. O halde 
    çapraz derleme yapacak tipik bir Makefile dosyası şöyle olabilir:

    CROSS_COMPILE = arm-none-linux-gnueabihf-
    ARCH = arm

    KDIR := /home/kaan/Study/EmbeddedLinux/KernelBuild/linux-6.6.32-ti-arm32-r4
    PWD := $(shell pwd)

    obj-m += $(file).o

    all:
        make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
    clean:
        make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) clean
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin ve aygıt sürücülerin derlenmesi için hedef çekirdeğe ilişkin başlık dosyalarının ve birtakım diğer 
    dosyaların derlemenin yapılacağı makinede hazır olarak bulundurulması gerektiğini belirtmiştik. Host sistemin kendisi 
    üzerinde geliştirme yapıyorsak genellikle bunlar zaten host sistemde bulunacaktır. Ancak başka bir çekirdeğe yönelik geliştirme
    yapılacaksa o çekirdeğe ilişkin kaynak kodların geliştirmenin yapılacağı makineye indirilmesi gerekir. Fakat yalnızca kaynak 
    kodların indirilmesi yeterli değildir. Kaynak kodlar indirildikten sonra en azından aşağıdaki iki işlemin yapılması gerekir:

    1) Modül derlemesi için "make modules_prepare" işleminin yapılması gerekir. Örneğin:

    $ make modules_prepare

    2) Modüllerin derlenmesi için "make modules" işleminin yapılması gerekir. Örneğin:

    $ make modules

    Tabii modüllerin derlenmesi uzun zaman almaktadır. Aslında uygulamacı kendi çekirdek modülü ya da aygıt sürücüsü içerisinde
    kullanacağı az sayıda modülü de derleyebilir. Ancak bunun kestirilmesi o kadar kolay değildir. Tabii çekirdek modüllerinin 
    ya da aygıt sürücülerin derlenmesi için sisteminde hazır olan dizin için zaten bunlar yapılmış durumdadır. Çekirdeğin hepsini 
    yeniden derlerken zaten yukarıdaki işlemlerin de yapılmış olacağına dikkat ediniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi en basit bir kernel modülü oluşturup bunu bir başlangıç noktası olarak kullanalım. Bu modülümüze "helloworld" ismini
    verelim:

    /* helloworld.c */

    #include <linux/module.h>
    #include <linux/kernel.h>

    MODULE_LICENSE("GPL");

    int init_module(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void cleanup_module(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    Bu kernel modül aşağıdaki gibi build edilebilir:

    $ make file=helloworld"

    Build işlemi bittiğinde kernel modül "helloworld.ko" dosyası biçiminde oluşturulacaktır. Burada "ko" uzantısı "kernel 
    object" sözcüklerinden kısaltılmıştır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

int init_module(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void cleanup_module(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Modüller "modprobe" isimli programla da yüklenebilir. Ancak modprobe programı yüklenecek modülleri "/lib/modules/$(uname -r)"
    dizininde aramaktadır. Dolayısıyla biz kendi derlediğimiz modülleri bu dizine yerleştirmemişsek yüklemeyi modprobe ile 
    yapamayız. Ancak çekirdek derlenirken oluşturulmuş olan modüller bu dizinde olduğu için bunları modprobe ile yükleyebiliriz. 
    modprobe programı yüklenecek aygıt sürücünün yalnızca ismini almaktadır. Çünkü zaten arama işlemini kendisi yapmaktadır. 
    Örneğin:

    $ modprobe g_ether

    insmod programının yüklenecek aygıt sürücü dosyasının tüm yol ifadesini aldığına dikkat ediniz. modprobe programında dosyanın 
    ".ko" uzantısı da belirtilmemektedir. Halbuki insmod programında bu uzantının da belirtilmesi gerekmektedir. modprobe aslında 
    "modules.dep" isimi bir dosyaya başvurmaktadır. Bu dosya çekirdek kaynak kodlarının kök dizininde çekirdek modülleri derlenirken 
    oluşturulmaktadır. Bu dosya içerisinde bağımlılık bilgileri vardır. Bir çekirdek modülü yazılırken başka bir çekirdek modülünün 
    içerisindeki fonksiyonlar kullanılmış olabilir. Bu durumda kullanan modülün yüklenmesi için önce onun kullandığı modülün 
    yüklenmesi gerekir. İşte bu biçimde durum karmaşık bir hal alabilmektedir. "modules.dep" dosyası içerisinde bir modülün 
    yüklenebilmesi için hangi modüllerin de yüklenmesi gerektiği bilgileri bulunmaktadır. Eğer biz kendi çekirdek modülümüzün de 
    modprobe ile yüklenmesini istiyorsak önce onu "/lib/modules/$(uname -r)/kernel" dizininin içerisindeki dizinlerden birine yerleştirip 
    sonra bu "modules.dep" dosyasının güncellenmesini sağlamamız gerekir. Bu işlem "depmod" programıyla "-a" seçeneği kullanılarak 
    yapılmaktadır:

    $ sudo depmod -a

    Kendi çekirdek modülünüzü ya da aygıt sürücünüzü örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc" dizinine yerleştirebilirsiniz.
    Tabii aygıt sürücü geliştirirken ikide bir modülü buraya yerleştirmenin bir anlamı yoktur. Bu nedenle geliştirme aşamasında 
    genellikle "insmod" programı kullanılmaktadır.

    modprobe ile yüklenen aygıt sürücü "modeprobe -r" ile boşaltılabilir. Örneğin:

    $ modprobe -r g_ether

    Tabii boşaltım sırasında yine eğer aygıt sürünün bağımlı olduğu çekirdek modülleri başka modüller tarafından kullanılmıyorsa
    onlar da çekirdekten çıkartılacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                84. Ders 27/02/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sistem açılır açılmaz otomatik olarak bir çekirdek modülünün ya da aygıt sürücünün yüklenmesi için birka ç yöntem kullanılabilmektedir. 
    "/etc/modules" dosyası "klasik sysvinit" ve "systemd" init tarafından işletilmektedir. Dolayısıyla bu dosyanın içerisine bir 
    satıra çekirdek modülünüzün ismini (yalnızca ismini) yazarsanız sistem açıldığında çekirdek modülü de otomatik yüklenmiş olur. 
    Ancak init programları bu dosyada belirtilen çekirdek modüllerini modprobe ile yüklemektedir. Dolayısıyla sizin de çekirdek 
    modülünüzü "/lib/modules/$(uname -r)/kernel" içerisindeki bir dizine (örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc"
    dizinine) yerleştirip "sudo depmod -a" komutunu uygulamanız gerekir. Eğer systemd init sistemi ile çalışıyorsanız yüklemeyi 
    yapacak bir "servis birim dosyası" oluşturabilirsiniz. Örneğin.

    [Unit]
    Description=Modül Yükleme Servisi
    After=network.target

    [Service]
    Type=oneshot
    ExecStart=/sbin/modprobe <modül_adı>
    RemainAfterExit=true

    [Install]
    WantedBy=multi-user.target

    Diğer bir yöntem de klasik systemvinit ve systemd tarafından bakılan "/etc/rc.local" dosyasının içerisine yükleme komutunu 
    yazmaktır. Örneğin:

    "sudo insmod /path/helloworld.ko"

    Tabii burada modprobe da kullanılabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    En basit bir çekirdek modülünde aşağıdaki iki temel dosya include edilmelidir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    Bu iki dosya "/lib/modules/$(uname -r)/build/include" dizini içerisindedir. (Bu dizinin çekirdek kaynak kodlarındaki "include"
    dizini olduğuna dikkat ediniz. Bu iki başlık dosyası "libc" ve POSIX kütüphanelerinin başlık dosyalarının bulunduğu "/usr/include" 
    içerisinde değildir.) Yukarıda kullandığımız make dosyası include dosyalarının bu dizinde aranmasını sağlamaktadır.

    Eskiden çekirdek modüllerine modül lisansının eklenmesi zorunlu değildi. Ancak belli bir zamandan sonra bu zorunlu hale
    getirilmiştir. Modül lisansı MODULE_LICENSE isimli makro ile belirtilmektedir. Bu makro <linux/module.h> dosyası içerisinde
    bildirilmiştir. Tipik modül lisansı aşağıdaki gibi "GPL" biçiminde oluşturulabilir:

    MODULE_LICENSE("GPL");

    Bir çekirdek modülü yüklendiğinde çekirdek modülü içerisinde belirlenmiş olan bir fonksiyon çağrılır (bu fonksiyon C++'taki 
    "constructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi init_module biçimindedir. Bu fonksiyonun geri 
    dönüş değeri int türdendir ve parametresi yoktur. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif 
    hata koduna (negatif errno değerine) geri dönmelidir. Bu fonksiyon başarısızlıkla geri dönerse modülün yüklenmesinden 
    vazgeçilmektedir. Benzer biçimde bir modül çekirdek alanından boşaltılırken de yine bir fonksiyon çağrılmaktadır. (Bu 
    fonksiyon da C++'taki "destructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi cleanup_module biçimindedir. 
    Bu fonksiyonun geri dönüş değeri ve parametresi void biçimdedir.

    Çekirdek modülleri ekrana değil log dosyalarına yazarlar. Bunun için çekirdek içindeki printk isimli fonksiyon kullanılmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    helloworld modülünde kullanmış olduğumuz printk fonksiyonu "çekirdeğin printf fonksiyonu" gibi düşünülebilir. printk fonksiyonunun 
    genel kullanımı printf fonksiyonu gibidir. Default durumda bu fonksiyon mesajların "/var/log/syslog" dosyasına yazdırılmasını 
    sağlamaktadır. printk fonksiyonunun prototipi <linux/kernel.h> dosyası içerisindedir. printk fonksiyonunun örnek kullanımı şöyledir:

    printk(KERN_INFO "This is test\n");

    Mesajın solundaki KERN_XXX biçimindeki makrolar aslında bir string açımı yapmaktadır. Dolayısıyla yan yana iki string 
    birleştirildiği için mesaj yazısının başında küçük bir önek bulunur. Bu önek (yani bu makro) mesajın türünü ve aciliyetini 
    belirtmektedir. Tipik KERN_XXX makroları şunlardır:

    KERN_EMERG
    KERN ALERT
    KERN_CRIT
    KERN_ERR
    KERN_WARN
    KERN_NOTICE
    KERN_INFO
    KERN_DEBUG

    Bu makroların tipik yazım biçimi şöyledir:

    #define KERN_SOH        "\001"        /* ASCII Start Of Header */
    #define KERN_SOH_ASCII    '\001'

    #define KERN_EMERG        KERN_SOH "0"        /* system is unusable */
    #define KERN_ALERT        KERN_SOH "1"        /* action must be taken immediately */
    #define KERN_CRIT        KERN_SOH "2"        /* critical conditions */
    #define KERN_ERR        KERN_SOH "3"        /* error conditions */
    #define KERN_WARNING    KERN_SOH "4"        /* warning conditions */
    #define KERN_NOTICE        KERN_SOH "5"        /* normal but significant condition */
    #define KERN_INFO        KERN_SOH "6"        /* informational */
    #define KERN_DEBUG        KERN_SOH "7"        /* debug-level messages */

    Ancak bu makrolarda çeşitli çekirdek versiyonlarında değişiklikler yapılabilmektedir. C'de aralarında hiçbir operatör bulunmayan
    iki string'in derleyici tarafından birleştirildiğini anımsayınız. Bu durumda aslında örneğin:

    printk(KERN_INFO "Hello World...\n");

    ile aşağıdaki çağrı eşdeğerdir:

    printk("\0017Hello World...\n");

    Ancak yukarıda da belirttiğimiz gibi bu makrolar üzerinde değişiklikler yapılabilmektedir. Dolayısıyla makroların kendisinin 
    kullanılması gerekir.

    Aslında KERN_XXX makroları ile printk fonksiyonunu kullanmak yerine pr_xxx makroları da kullanılabilir. Şöyle ki:

    printk(KERN_INFO "Hello World...\n");

    ile

    pr_info("Hello World...\n");

    tamamen eşdeğerdir. Diğer pr_xxx makroları şunlardır:

    pr_emerg
    pr_alert
    pr_crit
    pr_err
    pr_warning
    pr_notice
    pr_info
    pr_debug

    printk fonksiyonunun yazdıklarını "/var/log/syslog" dosyasına bakarak görebiliriz. Örneğin:

    $ tail /var/log/syslog

    Ya da "dmesg" programı ile de aynı bilgi elde edilebilir.

    En çok kullanılan log düzeyini belirten makrolar KERN_INFO, KERN_ERR ve KERN_WARNING makrolarıdır. Çekirdek modülü ya da 
    aygıt sürücü içerisinde bazı durumlara yönelik bilgi vermek için KERN_INFO, hatalı bir durumlar karşılaştığında KERN_ERR 
    ve bir uyarı oluşturulacağı zaman KERN_WARNING kullanılmaktadır. Diğer makrolar geliştiriciler tarafından çok seyrek 
    kullanılmaktadır.

    Çekirdek modülleri çekirdeğin içerisine yerleştirildiği için çekirdek modüllerinde biz kullanıcı modundaki (user mode'daki) 
    kütüphaneleri kullanamayız. (Örneğin çekirdek modunda standart C fonksiyonlarını ve POSIX fonksiyonlarını kullanamayız.) 
    Çünkü standart C fonksiyonları ve POSIX fonksiyonları "kullanıcı modunda (user mode)" programlar için oluşturulmuş kütüphanelerin 
    içerisindedir. Biz çekirdek modüllerinin içerisinde yalnızca "export edilmiş çekirdek fonksiyonlarını" kullanabiliriz.

    Çekirdek modülleri içerisinde kullanılabilecek export edilmiş çekirdek fonksiyonları "Linux Kernel API" ismi altında "kernel.org"
    tarafından dokümante edilmiştir. Örneğin bu fonksiyonların dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://docs.kernel.org/core-api/kernel-api.html

    Ancak maalesef bu export edilmiş fonksiyonlar hakkında ayrıntılı açıklamalar bulmak zordur. Bu nedenle bazen çekirdek kaynak 
    kodlarına başvurmak da gerekebilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Belli bir anda yüklenmiş olan çekirdek modülleri "/proc/modules" dosyasından elde edilebilir. "/proc/modules" "bir text 
    dosyadır. Dosyanın her satırında bir çekirdek modülünün bilgisi vardır. Örneğin:

    $ cat /proc/modules
    helloworld 16384 0 - Live 0x0000000000000000 (OE)
    vmw_vsock_vmci_transport 32768 2 - Live 0x0000000000000000
    vsock 40960 3 vmw_vsock_vmci_transport, Live 0x0000000000000000
    snd_ens1371 28672 2 - Live 0x0000000000000000
    snd_ac97_codec 131072 1 snd_ens1371, Live 0x0000000000000000
    gameport 20480 1 snd_ens1371, Live 0x0000000000000000
    ac97_bus 16384 1 snd_ac97_codec, Live 0x0000000000000000
    binfmt_misc 24576 1 - Live 0x0000000000000000
    intel_rapl_msr 20480 0 - Live 0x0000000000000000
    ...

    Yüklü modüllerin bilgileri "lsmod" isimli bir yardımcı programla da görüntülenebilmektedir. Tabii aslında "lsmod" 
    "/proc/modules" dosyasını okuyup onu daha anlaşılır biçimde görüntülemektedir. Örneğin:

    $ lsmod
    Module                  Size  Used by
    helloworld             16384  0
    btrfs                1564672  0
    blake2b_generic        20480  0
    xor                    24576  1 btrfs
    zstd_compress         229376  1 btrfs
    raid6_pq              122880  1 btrfs
    ufs                   106496  0
    qnx4                   16384  0
    hfsplus               118784  0
    hfs                    65536  0
    ...
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                85. Ders 04/03/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aslında init_module ve cleanup_module fonksiyonlarının ismi değiştirilebilir. Fakat bunun için bildirimde bulunmak gerekir. 
    Bildirimde bulunmak için ise module_init(...) ve module_exit(...) makroları kullanılmaktadır. Bu makrolar kaynak kodun 
    herhangi bir yerinde bulundurulabilir. Ancak makro içerisinde belirtilen fonksiyonların daha yukarıda bildirilmiş olması 
    gerekmektedir. Bu makrolar tipik olarak kaynak kodun sonuna yerleştirilmektedir. Örneğin:

    #include <linux/module.h>
    #include <linux/kernel.h>

    int helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    Aşağıda örnek bütünsel olarak verilmiştir. make işlemi şöyle yapılabilir:

    $ make file=helloworld
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Genellikle çekirdek modülü içerisindeki global değişkenlerin ve fonksiyonların "içsel bağlamaya (internal linkage)" sahip 
    olması tercih edilmektedir. Bu durum birtakım isim çakışmalarını da engelleyecektir. Biz de genel olarak örneklerimizde 
    zorunlu olmadıkça fonksiyonları hep static biçimde tanımlayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin init ve cleanup fonksiyonlarında fonksiyon isimlerinin soluna __init ve __exit makroları getirilebilmektedir. 
    Bu makrolar <linux/init.h> dosyası içerisindedir. Bu dosya da <linux/module.h> dosyası içerisinde include edilmiştir. 
    __init makrosu ilgili fonksiyonu ELF dosyasının özel bir bölümüne (section) yerleştirir. Modül yüklendikten sonra bu bölüm 
    çekirdek alanından atılmaktadır. __exit makrosu ise çekirdeğin içine gömülmüş modüllerde fonksiyonun dikkate alınmayacağını 
    (dolayısıyla da fonksiyonun yerleştirildiği bölümün çekirdekle birlikte belleğe hiç yüklenmeyeceğini) belirtir. Ancak 
    sonradan yüklemelerde bu makronun bir etkisi yoktur. Bir çekirdek modülü çekirdeğin içerisine gömülürse modülün cleanup 
    fonksiyonu zaten çağrılmamaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerine 2003 yılında 2.6 çekirdekleriyle birlikte "sysfs (kısaca sys)" isimli bellek tabanlı yeni bir dosya sistemi
    daha eklenmiştir. Bu dosya sistemi de tıpkı proc dosya sistemi gibi çekirdeğin içinde bulunduğu durumu dış dünyaya bildirmek 
    ve çekirdek davranışının dışarıdan değiştirilmesine olanak sağlamak amacıyla oluşturulmuştur. Ancak "sysfs" dosya sistemi 
    daha "nesne yönelimli" bir tasarıma sahiptir. Yani birtakım olgular dizinlerle onların özellikleri de o dizinler içerisindeki 
    dosyalarla temsil edilmektedir. Bu bakımdan "sysfs" dosya sistemi "proc" dosya sisteminin bazı eksikliklerini tamamlamaktadır. 
    sysfs dosya sistemine "/sys" dizini yoluyla erişilmektedir.

    insmod ile yüklediğimiz her modül için "/sys/module" dizinin içerisinde ismi modül ismiyle aynı olan bir dizin yaratılmaktadır. 
    "/proc/modules" dosyası ile bu dizini karıştırmayınız. "/proc/modules" dosyasının satırları yüklü olan modüllerin isimlerini 
    ve bazı temel bilgilerini tutmaktadır. Modüllere ilişkin asıl önemli bilgiler ise çekirdek tarafından "/sys/module" dizininde 
    tutulmaktadır. sysfs dosya sistemi de proc dosya sistemi gibi çekirdek tarafından bellek üzerinde oluşturulan ve içeriği çekirdek
    tarafından güncellenen bir dosya sistemidir. Örneğin "helloworld.ko" modülünü yükledikten sonra bu dizin aşağıdaki gibi bir 
    içeriğe sahip olacaktır:

    $ ls /sys/module/helloworld -l
    toplam 0
    -r--r--r-- 1 root root 4096 Mar 22 21:25 coresize
    drwxr-xr-x 2 root root    0 Mar 22 21:25 holders
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initsize
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initstate
    drwxr-xr-x 2 root root    0 Mar 22 21:25 notes
    -r--r--r-- 1 root root 4096 Mar 22 21:25 refcnt
    drwxr-xr-x 2 root root    0 Mar 22 21:25 sections
    -r--r--r-- 1 root root 4096 Mar 22 21:25 srcversion
    -r--r--r-- 1 root root 4096 Mar 22 21:25 taint
    --w------- 1 root root 4096 Mar 22 21:22 uevent
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Nasıl kullanıcı modu programlarında main fonksiyonuna komut satırı argümanları geçirilebiliyorsa benzer biçimde çekirdek 
    modüllerine de argüman (ya da parametre diyebiliriz) geçirilebilmektedir. Bu konuya genel olarak "çekirdek modül parametreleri" 
    denilmektedir.

    Çekirdek modüllerine parametre geçirme işlemi insmod komutu ile modül yüklenirken komut satırında modül isminden sonra 
    "değişken=değer" çiftleriyle yapılmaktadır. Örneğin:

    $ sudo insmod helloworld.ko number=10 msg="\"This is a test\"" values=10,20,30,40,50

    Bu örnekte number parametresi int bir değerden, msg parametresi bir yazıdan values parametresi ise birden fazla int değerden 
    oluşmaktadır. Bu tür parametrelere modülün dizi parametreleri denilmektedir.

    Çekirdek modüllerine geçirilen parametreleri modül içerisinde almak için module_param ve module_param_array isimli makrolar 
    kullanılır. module_param makrosunun üç parametresi vardır:

    module_param(name, type, perm);

    name parametresi ilgili değişkenin ismini belirtmektedir. Biz makroyu çağırmadan önce bu isimde bir global değişkeni tanımlamalıyız. 
    Ancak buradaki değişken isminin komut satırında verilen parametre (argüman da diyebiliriz) ismi ile aynı olması gerekmektedir. 
    type ilgili parametrenin türünü belirtir. Bu tür şunlardan biri olabilir:

    int
    long
    short
    uint
    ulong
    ushort
    charp
    bool
    invbool

    Buradaki charp char türden adresi, invbool ise geçirilen argümanın bool bakımdan tersini temsil etmektedir. module_param
    makrosunun perm parametresi "/sys/modules/<modül ismi>" dizininde yaratılacak olan "parameters" dizininin erişim haklarını 
    belirtir. Bu makrolar global alanda herhangi bir yere yerleştirilebilir.

    Örneğin kernel modülümüzde count ve msg isimli iki parametre olsun. Bunlara ilişkin module_param makroları şöyle oluşturulmalıdır:

    int count = 0;
    char *msg = "Ok";

    module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
    module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    char * türünden modül parametresi için makrodaki türün "charp" biçiminde olduğuna dikkat ediniz. Buradaki gösterici const 
    olamamaktadır. Bizim bir parametre için module_param makrosunu kullanmış olmamız modül yüklenirken bu parametrenin belirtilmesini 
    zorunlu hale getirmemektedir. Bu durumda bu parametreler default değerlerde kalacaktır. Yukarıdaki parametreleri helloworld 
    modülüne aşağıdaki gibi geçirebiliriz:

    $ sudo insmod helloworld.ko count=100 msg="\"this is a test\""

    Burada neden iç içe tırnakların kullanıldığını merak edebilirsiniz. Kabuk üzerinde tırnaklar "boşluklarla ayrılmış olan yazıların 
    tek bir komut satırı argümanı olarak ele alınacağını belirtmektedir. Ancak bizim ayrıca yazısal argümanları modüllere parametre 
    yoluyla aktarırken onları tırnaklamamız gerekir. Bu nedenle iç içe iki tırnak kullanılmıştır.

    Modül parametreleri kernel tarafından "/sys/module" içerisindeki modül ismine ilişkin dizinin altındaki parameters dizininde 
    dosyalar biçiminde dış dünyaya sunulmaktadır. İşte makrodaki erişim hakları buradaki parametre dosyalarının erişim haklarını 
    belirtmektedir. Kernel modül root kullanıcısı tarafından yüklendiğine göre bu dosyaların da kullanıcı ve grup id'leri root 
    olacaktır. Örneğin helloworld modülü için bu dosyalar "/sys/module/helloworld/parameters" dizini içerisindedir:

    $ ls -l /sys/module/helloworld/parameters
    toplam 0
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 count
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 msg

    Bu dosyalar doğrudan kernel modüldeki parametre değişkenlerini temsil etmektedir. Yani örneğin biz buradaki count dosyasına
    başka bir değer yazdığımızda kernel modülümüzdeki count değeri de değişmiş olacaktır. Tabii yukarıdaki erişim haklarıyla biz
    dosyaya yazma yapamayız. Bu erişim haklarıyla yazma yapabilmemiz için yazmayı yapan programın root olması gerekir. Terminalden 
    bu işlem aşağıdaki gibi yapılabilir:

    $ sudo bash -c "echo 200 > /sys/module/helloworld/parameters/count"

    yada

    $ echo 200 | sudo tee /sys/module/helloworld/parameters/count

    Burada işlemi aşağıdaki gibi yapamayacağımıza dikkat ediniz:

    $ sudo echo 200 > /sys/module/helloworld/parameters/count

    Çünkü burada her ne kadar echo programı root önceliğinde çalıştırılıyorsa da dosyayı açan kullanıcı root değildir. Çünkü 
    > işareti ve onun sağının sudo ile bir ilgisi yoktur.

    Bu denemeyi aşağıdaki modülle yapabilirsiniz. Modülü önce insmod ile aşağıdaki gibi yükleyiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\""

    Sonra "/sys/module/helloworld/parameters" dizinine geçip aşağıdaki komutları uygulayınız:

    $ echo 500 | sudo tee count
    $ echo "this is a new message" | sudo tee msg

    Modülü "rmmod" ile çekirdek alanından çıkarttıktan sonra yeniden "dmesg" yapınız. Artık modül içerisindeki parametrelerin
    aşağıdaki gibi değiştiğini göreceksiniz:

    [ 7668.582978] count = 500, msg=this is a new message
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
    printk(KERN_INFO "count = %d, msg=%s\n", count, msg);
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülüne birden fazla değer de bir dizi gibi aktarılabilir. Bunun için module_param_array makrosu kullanılmaktadır. 
    module_param_array makrosu da şöyledir:

    module_param_array(name, type, nump, perm)

    Makronun birinci ve ikinci parametreleri yine değişken ismi ve türünü belirtir. Tabii buradaki değişken isminin bir dizi 
    ismi olarak, türün de bu dizinin eleman türü olarak girilmesi gerekmektedir. Üçüncü parametre toplam kaç değerin modüle dizi 
    biçiminde aktarıldığını belirten int bir nesnenin adresini (ismini değil) alır. Son parametre yine oluşturulacak dosyanın 
    erişim haklarını belirtmektedir. Örneğin:

    static int values[5];
    static int size;

    module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    module_param_array makrosuyla bir diziye değer aktarırken değerlerin virgüllerle ayrılmış bir biçimde girilmesi gerekmektedir.
    Örneğin:

    $ sudo insmod helloworld.ko values=1,2,3,4,5

    Burada eğer verilen değerler dizinin uzunluğundan fazla olursa zaten modül yüklemesi başarısız olmaktadır. Yani "insmod" 
    bir hata mesajı ile işlemini sonlandıracaktır. Tabii verilen değerlerin dizinin uzunluğundan daha az olabilir. Girilen değerlerin
    sayısı zaten örneğimizde size nesnesine yerleştirilecektir.

    Aşağıdaki örnekte üç parametre komut satırından çekirdek modülüne geçirilmiştir. Komut satırındaki isimlerle programın içerisindeki 
    değişken isimlerinin aynı olması gerektiğini anımsayınız. Dizi elemanlarını virgüllerle belirtirken yanlışlıkla virgüllerin 
    arasına boşluk karakterleri yerleştirmeyiniz. Programı şöyle make yapabilirsiniz:

    $ make file=helloworld

    Yüklemeyi şöyle yapabilirsiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\"" values=10,20,30,40,50
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";
static int values[5];
static int size;

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    int i;

    printk(KERN_INFO "Hello World...\n");

    printk(KERN_INFO "count = %d\n", count);
    printk(KERN_INFO "msg = %s\n", msg);
    printk(KERN_INFO "Values:\n");
    for (i = 0; i < size; ++i)
        printk(KERN_INFO "%d ", values[i]);
    printk(KERN_INFO "\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

/*-----------------------------------------------------------------------------------------------------------------------------
                                                86. Ders 06/03/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    errno değişkeni aslında "libc" kütüphanesinin (libc standart C ve POSIX kütüphanesidir) içerisinde tanımlanmış bir değişkendir. 
    Çekirdek modunda yani çekirdeğin içerisinde errno isimli bir değişken yoktur. Bu nedenle çekirdekteki fonksiyonlar pek çok 
    POSIX fonksiyonunda olduğu gibi başarısızlık durumunda -1 ile geri dönüp errno değişkenini set etmezler. Çekirdek içerisindeki 
    fonksiyonlar başarısızlık durumunda negatif errno değeri ile geri dönerler. Örneğin "open" POSIX fonksiyonu "sys_open" isimli 
    çekirdek içerisinde bulunan sistem fonksiyonunu çağırdığında onun negatif bir değerle geri dönüp dönmediğine bakar. Eğer "sys_open" 
    fonksiyonu negatif değerle geri dönerse bu durumda bu değerin pozitiflisini errno değişkenine yerleştirip -1 ile geri dönmektedir. 
    Başka bir deyişle aslında bizim çağırdığımız int geri dönüş değerine sahip POSIX fonksiyonları sistem fonksiyonlarını çağırıp 
    o fonksiyonlar negatif bir değerle geri dönmüş ise bir hata oluştuğunu düşünerek o negatif değerin pozitiflisini errno değişkenine 
    yerleştirip -1 ile geri dönmektedir.

    Çekirdek modül yazan programcıların da bu biçime uyması iyi bir tekniktir. Örneğin:

    if (some_control_failed)        /* burada kontrol yapılıyor */
        return -EXXX;                /* fonksiyon başarısız ise negatif errno değeriyle geri döndürülüyor */

    Özetle biz çekirdek içerisindeki geri dönüş değeri int olan bir fonksiyonu çağırdığımızda onun başarılı olup olmadığını geri dönüş 
    değerinin negatif olup olmadığı ile kontrol ederiz. Eğer çağırdığımız fonksiyonun geri dönüş değeri negatif ise onun pozitif hali
    başarısızlığa ilişkin errno numarasını vermektedir.

    POSIX arayüzünde adrese geri dönen fonksiyonlar genel olarak başarısızlık durumunda NULL adrese geri dönmektedir. Oysa çekirdek 
    kodlarında adrese geri dönen fonksiyonlar başarısız olduklarında yine sanki bir adresmiş gibi negatif errno değerine geri 
    dönerler. Örneğin şöyle bir çekirdek fonksiyonu olsun:

    void *foo(void);

    Biz bu fonksiyonu çekirdek modülümüz içerisinde çağırdığımızda eğer fonksiyon başarısızsa negatif errno değerini bir adres gibi
    geri döndürmektedir. Negatif küçük değerlerin 2'ye tümleyen aritmetiğinde başı 1'lerle dolu olan bir sayı olacağına dikkat 
    ediniz. Örneğin bu foo fonksiyonu -EPERM değeri ile geri dönüyor olsun. EPERM değeri 1'dir. 64 bit sistemdeki -1 değeri 
    ise şöyledir:

    FF FF FF FF FF FF FF FF

    Bu değer ise çok yüksek bir adres gibidir. O zaman eğer fonksiyon çok yüksek bir adres geri döndürdüyse başarısız olduğu 
    sonucunu çıkartabiliriz. Örneğin yukarıdaki fonksiyon -ENOENT değeri ile geri dönüyor olsun. ENOENT 2 değerindedir. -2 
    ise 64 bit sistemde 2'ye tümleyen aritmetiğinde aşağıdaki gibidir:

    FF FF FF FF FF FF FF FE

    Görüldüğü gibi bu adres bilgisi de aslında bellek alanının sonlarındaki bir adrese belirtmektedir. İşte Linux çekirdeğindeki 
    son 4095 adres zaten çekirdek tarafından kullanılmamaktadır. Bunlar negatif errno değerlerini belirtirler. O halde biz adrese 
    geri dönen bir Linux çekirdek fonksiyonunu çağırdığımızda bu fonksiyon eğer belleğin sonundaki 4095 adresten biriyle geri 
    dönüyorsa aslında negatif bir errno değeriyle geri dönmektedir.

    Peki bir adres değerinin aslında negatif bir errno değeri içerdiğini yani geçerli olmadığını nasıl anlayabiliriz? 
    İşte yukarıda da belirttiğimiz gibi negatif errno değerleri bir adres gibi ele alındığında adeta adres alanının sonundaki 
    adresler gibi bir görünümde olacaktır. errno değerleri için toplamda ayrılan sayılar da sınırlı olduğu için kontrol kolaylıkla
    yapılabilir. Ancak bu kontrol için IS_ERR isimli inline fonksiyon da bulundurulmuştur. IS_ERR inline fonksiyonu şöyle 
    yazılmıştır:

    static inline long IS_ERR(const void *ptr)
    {
        return (unsigned long)ptr > (unsigned long)-4095;
    }

    Burada fonksiyon adresin "adres alanının son 4095 adresinden biri içerisinde mi" kontrolünü yapmaktadır. Negatif errno 
    değerlerinin hepsi bu aralıktadır. Tabii 4095 errno değeri yoktur. Burada geleceğe uyumu korumak için 4095'lik bir 
    alan ayrılmıştır. Bu durumda çekirdek kodlarında adrese geri dönen fonksiyonların başarısızlığı aşağıdaki gibi kontrol 
    edilebilmektedir.

    void *ptr;

    ptr = foo();
    if (IS_ERR(ptr)) {
        ...
    }

    Linux çekirdeğindeki EXXX sembolik sabitleri POSIX arayüzündeki EXXX sabitleriyle aynı değerdedir.

    Çekirdek kodlarındaki ERR_PTR isimli inline fonksiyon bir tamsayı değeri alıp onu adres türüne dönüştürmektedir. Bu nedenle 
    adrese geri dönen fonksiyonlarda aşağıdaki gibi kodlar görebilirsiniz:

    void *foo(void)
    {
        ...
        if (expression)
            return ERR_PTR(-EXXX);
        ...
    }

    ERR_PTR aşağıdaki gibi tanımlanmıştır:

    static inline void *ERR_PTR(long error)
    {
        return (void *) error;
    }

    Bu işlemin tersi de PTR_ERR inline fonksiyonu ile yapılmaktadır. Yani PTR_ERR bir adresi alıp onu negatif errno değerine 
    dönüştürmektedir. Bu fonksiyon da şöyle tanımlanmıştır:

    static inline long PTR_ERR(const void *ptr)
    {
        return (long) ptr;
    }

    Yani PTR_ERR makrosu bize aslında adres olarak kodlanmış olan negatif errno değerini geri döndürmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda ele aldığımız konuyu şöyle özetleyebiliriz:

    1) Bir çekirdek fonksiyonu tamsayı türlerine ilişkin bir değere geri dönüyorsa geri dönüş değerinin negatif olması 
    fonksiyonun başarısı olduğunu gösterir. Bu negatif değerin pozitiflisi errno değerini vermektedir.

    2) Bir çekirdek fonksiyonu bir adrese geri dönüyorsa fonksiyonun başarısı verilen adresin değerine bağlıdır. Eğer verilen 
    adres çok bir büyük bir adresse fonksiyon başarısız olmuştur. Bu kontrol IS_ERR inline fonksiyonuyla yapılmaktadır.

    3) Adrese geri dönen çekirdek fonksiyonu eğer başarısızsa negatif errno değeri PTR_ERR inline fonksiyonuyla elde edilir.

    4) Biz negatif bir errno değerini bir adres gibi geri döndireceksek bunun için ERR_PTR inline fonksiyonunu kullanmalıyız.

    5) Biz de çekirdek modüllerini ve aygıt sürücülerini yazarken çekirdekte uygulanan bu biçime (convention) uymalıyız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü yazarken o modül ile ilgili önemli bazı belirlemeler "modül makroları" denilen MODULE_XXX biçimindeki 
    makrolarla yapılmaktadır. Her ne kadar bu modül makrolarının bulundurulması zorunlu değilse de şiddetle tavsiye edilmektedir. 
    En önemli üç makronun tipik kullanımı şöyledir:

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("Kaan Aslan");
    MODULE_DESCRIPTION("General Kernel Module");

    Modül lisansı herhangi bir açık kaynak kod lisansı olabilir. Tipik olarak "GPL" tercih edilmektedir. MODULE_AUTHOR makrosu 
    ile modülün yazarı belirtilir. MODULE_DESCRIPTION modülün ne iş yapacağına yönelik kısa bir başlık yazısı içermektedir.

    Bu makrolar global alanda herhangi bir yere yerleştirilebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi kullanıcı modundaki programlar aygıt sürücülerle dosya sistemi yoluyla iletişim kurmaktadır. 
    Aygıt sürücüler sanki birer dosyaymış gibi açılırlar ve birer dosyaymış gibi işleme sokulurlar. Peki aygıt sürücüleri açmak 
    için yol ifadesi olarak (yani dosya ismi olarak) ne kullanılmaktadır? İşte aygıt sürücüler dosya sisteminde bir dizin girişiyle 
    temsil edilmektedir. O dizin girişi open fonksiyonuyla ile açıldığında aslında o dizin girişinin temsil ettiği aygıt sürücü 
    açılmış olur. Bu biçimdeki aygıt sürücüleri temsil eden dizin girişlerine "aygıt dosyaları (device files)" denilmektedir. 
    Aygıt dosyaları diskte bir dosya belirtmemektedir. Çekirdek içerisindeki aygıt sürücüyü temsil eden bir dizin girişi belirtmektedir. 
    Aygıt dosyalarının i-node tablosunda bir i-node elemanı vardır ancak bu i-node elemanı diskte bir yer değil çekirdekte bir 
    aygıt sürücü belirtmektedir.

    Peki bir aygıt dosyası nasıl yaratılmaktadır ve nasıl bir aygıt sürücüyü temsil eder hale getirilmektedir? İşte her aygıt 
    sürücünün majör ve minör numarası vardır. Bu majör ve minör numarayı aygıt sürücüye erişmek için kullanılan bir adres gibi 
    düşünebilirsiniz. Aynı zamanda aygıt dosyalarının da majör ve minör numaraları vardır. Bir aygıt sürücünün majör ve minör 
    numarası bir aygıt dosyasının majör ve minör numarasıyla aynıysa bu durumda o aygıt dosyası o aygıt sürücüyü temsil eder.
    Yani o aygıt dosyası açıldığında o aygıt sürücüyle iletişim kurulacaktır.

    Aygıt dosyaları özel dosyalardır. Bir dosyanın aygıt dosyası olup olmadığı "ls -l" komutunda dosya türü olarak 'c' (karakter 
    aygıt sürücüsü) ya da 'b' (blok aygıt sürücüsü) ile temsil edilmektedir. Anımsanacağı gibi dosya bilgileri stat, fstat, lstat 
    POSIX fonksiyonlarıyla elde ediliyordu. İşte struct stat yapısının dev_t türünden st_rdev elemanı eğer dosya bir aygıt dosyasıysa 
    dosyanın majör ve minör numaralarını belirtir. Biz de <sys/stat.h> dosyasındaki S_ISCHR ve S_ISBLK makrolarıyla ilgili dosyanın 
    bir aygıt dosyası olup olmadığını öğrenebiliriz.

    Yukarıda da belirttiğimiz gibi aygıt sürücüler "karakter aygıt sürücüleri (character device driver)" ve "blok aygıt sürücüleri
    (block device driver)" olmak üzere ikiye ayrılmaktadır. Karakter aygıt sürücüleri daha yaygın kullanılmaktadır. Biz kursumuzda
    önce karakter aygıt sürücülerini sonra blok aygıt sürücülerini ele alacağız. Blok aygıt sürücüleri tipik olarak disk gibi 
    medyalara erişmek amacıyla kullanılan aygıt sürücülerdir. Bunlar aktarım işlemini blok blok yaparlar. Bu işlemlerin daha 
    etkin gerçekleştirilmesi için çekirdeğin "buffer cache" (ya da yeni ismiyle "page cache") alt sistemleri devreye sokulmaktadır. 
    Karakter aygıt sürücüleri blok blok aktarım yapmayan aygıtlarla iletişim kuran aygıt sürücülerdir. Örneğin seri porttan bilgi 
    okuyan seri porta bilgi yazan aygıt sürücüler karakter aygıt sürücüleridir. Fakat RAM Disk oluşturan aygıt sürücüleri blok
    aygıt sürücüleridir. Karakter aygıt sürücülerinin yazımı blok aygıt sürücülerinden daha kolaydır.

    O halde şimdi bizim bir aygıt dosyasını nasıl oluşturacağımızı ve aygıt sürücüye nasıl majör ve minör numara atayacağımızı 
    bilmemiz gerekir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt dosyaları mknod isimli POSIX fonksiyonuyla (bu fonksiyon Linux'ta doğrudan sys_node isimli sistem fonksiyonunu 
    çağırmaktadır) ya da komut satırından mknod komutuyla (bu komut da mknod fonksiyonu ile işlemini yapmaktadır) yaratılabilir. 
    mknod fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mknod(const char *pathname, mode_t mode, dev_t dev);

    Fonksiyonun birinci parametresi yaratılacak aygıt dosyasının yol ifadesini, ikinci parametresi erişim haklarını ve üçüncü 
    parametresi de aygıt dosyasının majör ve minör numaralarını belirtmektedir. Aygıt dosyasının majör ve minör numaraları dev_t 
    türünden tek bir değer ile belirtilmektedir. dev_t türü POSIX standartlarına göre herhangi bir tamsayı türü olabilmektedir. 
    Biz majör ve minör numaraları user mod programlarda makedev isimli makroyla oluştururuz. Bir dev_t türünden değerin içerisinden 
    major numarayı almak için major makrosu, minor numarayı almak için ise minor makrosu bulunmaktadır:

    #include <sys/sysmacros.h>

    dev_t makedev(unsigned int maj, unsigned int min);
    unsigned int major(dev_t dev);
    unsigned int minor(dev_t dev);

    Yani aslında majör ve minör numaralar dev_t türünden bir değerin belli bitlerinde bulunmaktadır. Ancak bu numaraların dev_t 
    türünden değerin hangi bitlerinde bulunduğu sistemden sisteme değişebileceği için bu makrolar kullanılmaktadır.

    Ancak çekirdek dev_t nesnesini oluşturmak için büyük harflerle isimlendirilmiş aşağıdaki makrolar kullanılmaktadır:

    #include <linux/fs.h>

    MKDEV(major, minor)
    MAJOR(dev)
    MINOR(dev)

    Linux'ta son versiyonlar da dikkate alındığında dev_t 32 bitlik işaretsiz bir tamsayı türündendir. Bu 32 bitin yüksek anlamlı 
    12 biti majör numarayı, düşük anlamlı 20 biti ise minör numarayı temsil etmektedir. Ancak programcı bu varsayımlarla 
    kodunu düzenlememeli yukarıda belirtilen makroları kullanmalıdır.

    mknod fonksiyonunun ikinci parametresindeki erişim haklarına aygıt dosyasının türünü belirten aşağıdaki sembolik sabitlerden 
    biri de bit OR operatörü ile eklenmelidir:

    S_IFCHR (Karakter Aygıt Sürücüsü)
    S_IFBLK (Blok Aygıt Sürücüsü)

    Aslında mknod fonksiyonu ile Linux sistemlerinde isimli boru dosyaları, UNIX domain soket dosyaları ve hatta normal dosyalar 
    da yaratılabilmektedir. Bu durumda fonksiyonun aygıt numarasını belirten üçüncü parametresi fonksiyon tarafından dikkate 
    alınmamaktadır. Bu özel dosyalar için erişim haklarına eklenecek makrolar da şunlardır:

    S_IFREG (Disk dosyası yaratmak için)
    S_IFIFO (İsimli boru dosyası yaratmak için)
    S_IFSOCK (UNIX domain soket dosyası yaratmak için)

    Aslında mknod fonksiyonu aygıt dosyaları yaratmak için kullanılıyor olsa da yukarıda belirttiğimiz özel dosyaları da 
    yaratabilmektedir. Tabii zaten isimli boru dosyasını yaratmak için mkfifo fonksiyonu, normal dosyaları yaratmak için 
    open fonksiyonu kullanılabilmektedir.

    mknod fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Ayrıca mknod POSIX fonksiyonunun mknodat isimli at'li bir versiyonu da bulunmaktadır:

    #include <fcntl.h>

    int mknodat(int fd, const char *path, mode_t mode, dev_t dev);

    Bu at'li versiyon daha önce görmüş olduğumuz at'li fonksiyonlar gibi çalışmaktadır. Yani fonksiyon ilgili dizine ilişkin 
    dosya betimleyicisini ve göreli yol ifadesini parametre olarak alır. O dizinden göreli biçimde yol ifadesini oluşturur. 
    Yine fonksiyonun birinci parametresine AT_FDCWD özel değeri geçilebilir. Bu durumda fonksiyon at'siz versiyondaki gibi 
    çalışır. Diğer at'li fonksiyonlarda olduğu gibi bu fonksiyonun da ikinci parametresindeki yol ifadesi mutlak ise birinci 
    parametresindeki dizin hiç kullanılmamaktadır.

    mknod ve mknodat fonksiyonları prosesin umask değerini dikkate almaktadır. Bu fonksiyonlarla aygıt dosyası yaratabilmek için
    (diğer özel dosyalar için gerekmemektedir) prosesin uygun önceliğe sahip olması gerekmektedir.

    Aşağıdaki aygıt dosyası yaratan mymknode isimli bir fonksiyon yazılmıştır. Fonksiyonun genel kullanımı şöyledir:

    ./mymknod [-m ya da --mode <erişim hakları>] <path> <c ya da b> <majör numara> <minör numara>

    Örnek bir çalıştırma şöyle olabilir:

    $ sudo ./mymknode -m 666 mydriver c 25 0

    Programı sudo ile çalıştırmayı unutmayınız.
-----------------------------------------------------------------------------------------------------------------------------*/

/* mymknod.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <getopt.h>
#include <sys/sysmacros.h>

bool ismode_correct(const char *mode);
void exit_sys(const char *msg);

int main(int argc, char *argv[])        /* ./mymknod [-m <mode>] <path> <type> <major> <minor> */
{
    int m_flag;
    int err_flag;
    char *m_arg;
    int result;
    int mode;
    dev_t dev;

    struct option options[] = {
        {"mode", required_argument, NULL, 'm'},
        {0, 0, 0, 0}
    };

    m_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt_long(argc, argv, "m:", options, NULL)) != -1) {
        switch (result) {
        case 'm':
            m_flag = 1;
            m_arg = optarg;
            break;
        case '?':
            if (optopt == 'm')
                fprintf(stderr, "option -m or --mode without argument!...\n");
            else if (optopt != 0)
                fprintf(stderr, "invalid option: -%c\n", optopt);
            else
                fprintf(stderr, "invalid long option!...\n");

            err_flag = 1;
            break;
        }
    }
    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (m_flag) {
        if (!ismode_correct(m_arg)) {
            fprintf(stderr, "incorrect mode argument!...\n");
            exit(EXIT_FAILURE);
        }
        sscanf(m_arg, "%o", &mode);
    }
    else
        mode = 0644;

    if (argv[optind + 1][1] != '\0') {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }
    if (argv[optind + 1][0] == 'c')
        mode |= S_IFCHR;
    else if (argv[optind + 1][0] == 'b')
        mode |= S_IFBLK;
    else {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }

    dev = makedev(atoi(argv[optind + 2]), atoi(argv[optind + 3]));

    umask(0);
    if (mknod(argv[optind + 0], mode, dev) == -1)
        exit_sys("mknod");

    return 0;
}

bool ismode_correct(const char *mode)
{
    if (strlen(mode) > 3)
        return false;

        while (*mode != '\0') {
        if (*mode < '0' || *mode > '7')
            return false;
        ++mode;
    }

    return true;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıda yazdığımız mymknod programının aynısı zaten mknod isimli kabuk komutu biçiminde bulunmaktadır. Bu komutun
    genel biçimi şöyledir:

    sudo mknod [-m ya da --mode <erişim hakları>] <dosya ismi> <c ya da b> <majör numara> <minör numara>

    Örneğin:

    $ sudo mknod mydriver c 25 0

    mknod komutunu sudo ile çalıştırmayı unutmayınız. Yukarıdaki komut uygulandığında oluşturulan dosya şöyle olacaktır:

    crw-rw-rw- 1 root root 25, 0 Mar 29 22:05 mydriver
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                87. Ders 11/03/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünün karakter aygıt sürücüsü haline getirilebilmesi için öncelikle bir aygıt numarasıyla (majör ve minör 
    numara ile) temsil edilip çekirdeğe kaydettirilmesi (register ettirilmesi) gerekmektedir. Bu işlem tipik olarak 
    register_chrdev_region isimli çekirdek fonksiyonuyla yapılır. Fonksiyonun prototipi şöyledir:

    #include <linux/fs.h>

    int register_chrdev_region(dev_t from, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt sürücünün majör ve minör numaralarına ilişkin dev_t türünden değeri almaktadır. Bu 
    parametre için argüman genellikle MKDEV makrosuyla oluşturulmaktadır. MKDEV makrosu majör ve minör numarayı argüman olarak alıp 
    bunlardan dev_t türünden aygıt numarası oluşturmaktadır. Fonksiyonun ikinci parametresi ilk parametrede belirtilen minör numaradan 
    itibaren kaç minör numaranın kaydettirileceğini belirtmektedir. Örneğin biz majör = 20, minör = 0'dan itibaren 5 minör numarayı 
    kaydettirebiliriz. Fonksiyonun son parametresi proc ve sys dosya sistemlerinde görüntülenecek olan aygıt sürücünün ismini 
    belirtmektedir. Çekirdek modüllerinin isimleri çekirdek modül dosyasından gelmektedir. Ancak karakter aygıt sürücülerinin isimlerini 
    biz istediğimiz gibi verebiliriz. Tabii her aygıt sürücü bir çekirdek modülü biçiminde yazılmak zorundadır.

    register_chrdev_region fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. 
    Fonksiyon tipik olarak çekirdek modülünün "init" fonksiyonunda çağrılır. Eğer fonksiyon başarısız olursa init fonksiyonu da 
    bu fonksiyonun geri döndürdüğü değerle geri döndürülür. Örneğin:

    static int __init generic_init(void)
    {
        int result;

        printk(KERN_INFO "generic-char-driver module initialization...\n");

        if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
            printk(KERN_ERR "cannot register device!...\n");
            return result;
        }

        return 0;
    }

    Sistemde zaten yüklü olan aynı majör numaraya ilişkin bir aygıt sürücü varsa ya da fonksiyona girilen aygıt numarası geçersiz
    ise fonksiyon başarısız olabilir.

    register_chrdev_region fonksiyonu ile register ettirilmiş olan majör ve minör numaralar unregister_chrdev_region fonksiyonuyla 
    geri bırakılmalıdır. Aksi halde modül çekirdek alanından "rmmod" komutuyla atılsa bile bu aygıt numaraları tahsis edilmiş bir 
    biçimde kalmaya devam edecektir. Bu da önemli sorunlar doğurabilir. unregister_chrdev_region fonksiyonunun prototipi şöyledir:

    #include <linux/fs.h>

    void unregister_chrdev_region (dev_t from, unsigned count);

    Fonksiyonun birinci parametresi aygıt sürücünün register ettirilmiş olan majör ve minör numarasını, ikinci parametresi ise yine 
    o noktadan başlayan kaç minör numaranın unregister ettirileceğini belirtmektedir. Bu fonksiyon da tipik olarak aygıt sürücünün
    cleanup fonksiyonunda (exit fonksiyonunda) çağrılmalıdır. Örneğin:

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "generic-char-driver exit...\n");

        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
    }

    Bir aygıt sürücü register_chrdev_region fonksiyonuyla majör ve minör numarayı register ettirdiğinde artık "/proc/devices" 
    dosyasında bu aygıt sürücü için bir satır yaratılır. Aygıt sürücü unregister_chrdev_region fonksiyonuyla yok edildiğinde 
    "/proc/devices" dosyasındaki satır silinir. Örneğin aygıt sürücümüzü yükledikten sonra "/proc/devices" dosyasının içeriği 
    aşağıdakine benzer görüntülenecektir:

    Character devices:
    1 mem
    4 /dev/vc/0
    4 tty
    4 ttyS
    5 /dev/tty
    5 /dev/console
    5 /dev/ptmx
    5 ttyprintk
    6 lp
    7 vcs
    10 misc
    13 input
    14 sound/midi
    14 sound/dmmidi
    21 sg
    29 fb
    89 i2c
    99 ppdev
    108 ppp
    116 alsa
    128 ptm
    130 generic-char-driver
    136 pts
    ...

    Buradan da görüldüğü gibi aygıt sürücümüz "generic-char-driver" ismiyle 130 majör numaraya sahip olacak biçimde yüklenmiştir.

    Aşağıdaki örnekte çekirdek modülünün init fonksiyonunda register_chrdev_region fonksiyonu Majör = 139, Minor = 1 olacak 
    biçimde bir aygıt numarası çekirdeğe kaydettirilmiştir. Bu kayıt modülün exit fonksiyonunda unregister_chrdev_region fonksiyonu 
    ile silinmiştir. çekirdek modülünü aşağıdaki gibi derleyebilirsiniz:

    $ make file=generic-char-driver

    Modülü install ettikten sonra "/proc/modules" ve "/proc/devices" dosyalarına bakınız. "proc/devices" dosyasında aygıt
    sürücünün belirlediğimiz isimle ve majör numarayla kaydettirildiğini göreceksiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki aygıt sürücümüzü belli bir majör ve minör numarayla sisteme register ettirdikten sonra ne yapacağız? İşte aygıt 
    sürücüleri kabaca bir grup fonksiyondan oluşan modüller biçiminde düşünebiliriz. Aygıt sürücü içerisindeki fonksiyonlar 
    kullanıcı modunda bazı işlemler sonucunda çekirdek tarafından çağrılmaktadır. Örneğin:

    - Programcı aygıt sürücüye ilişkin aygıt dosyasını open fonksiyonu ile açtığı zaman aygıt sürücü içerisindeki "open" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile read işlemi yaptığında aygıt sürücü içerisindeki "read" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile write işlemi yaptığında aygıt sürücü içerisindeki "write" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile close işlemi yaptığında aygıt sürücü içerisindeki "close" 
    fonksiyonu çağrılır.

    Buradaki aygıt sürücü içerisindeki open, read, write, close fonksiyonlarına aygıt sürücüyü yazanlar istedikleri ismi verebilmektedir.
    Tabii yukarıda belirtmediğimiz ancak konular içerisinde göreceğimiz başka işlemler sonucunda yine aygıt sürücünün o işlemlere
    ilişkin fonksiyonları çağrılmaktadır. Aynı zamanda aygıt sürücüleri yazanlar dosya işlemleriyle doğrudan ilgili olmayan 
    aygıt sürücü fonksiyonlarına numaralar atayarak onların kullanıcı modundan ioctl isimli POSIX fonksiyonuyla (tabii bu POSIX 
    fonksiyonu da sys_ioctl isimli sistem fonksiyonunu çağırmaktadır) çağrılmasını sağlayabilmektedir. Tabii şüphesiz aygıt sürücü 
    içerisindeki bu fonksiyonlar çekirdek modunda çalıştırılmaktadır. Zaten aygı sürücü yazmanın ana nedenlerinden biri kullanıcı
    modunda yapılamayan işlemlerin çekirdek modunda yapılmasını sağlamak içindir.

    Ancak aygıt sürücüleri yalnızca kullanıcı modundan çekirdek modunda çalışacak fonksiyon çağırma mekanizması olarak düşünmemek 
    gerekir. Aygıt sürücüler birtakım kesmelere o anda yanıt verebilmektedir. Dolayısıyla aynı zamanda onları çekirdek modunda 
    çalışan birer program gibi de düşünebiliriz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülü bir aygıt numarasıyla ilişkilendirdikten sonra artık ona gerçek anlamda bir karakter aygıt sürücü kimliğinin 
    kazandırılması gerekir. Bu işlem struct cdev isimli bir yapının içinin doldurularak sisteme eklenmesi (yerleştirilmesi) 
    ile yapılmaktadır. Linux çekirdeği tüm çekirdek modüllerini ve aygıt sürücülerini çeşitli veri yapılarıyla tutmaktadır. Aygıt 
    sürücü yazan programcılar çekirdeğin bu organizasyonunu bilmek zorunda değillerdir. Ancak bazı işlemleri tam gerektiği gibi yapmak 
    zorundadırlar. (Linux çekirdeğinin aygıt sürücü mimarisi oldukça karmaşıktır. Bu konu "Linux Kernel" kursunda ele alınmaktadır.)

    cdev aşağıdaki gibi bir yapıdır:

    #include <linux/fs.h>

    struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;
        struct list_head list;
        dev_t dev;
        unsigned int count;
    };

    Bu türden bir yapı nesnesi programcı tarafından global olarak (statik ömürlü olarak) tanımlanabilir ya da alloc_cdev isimli 
    çekirdek fonksiyonuyla çekirdeğin heap sistemi (slab allocator) kullanılarak dinamik bir biçimde tahsis edilebilir. (İşletim 
    sistemlerinin çekirdeklerinin ayrı bir heap sistemi vardır. Linux çekirdeğinde spesifik türden nesnelerin hızlı tahsis edilmesi 
    için "slab allocator" denilen bir heap sistemi kullanılmaktadır.) Bu yapı nesnesini yerel bir nesne biçiminde oluşturmayınız. 
    Çünkü yerel değişkenler fonksiyon sonlandığında yok edilirler. Halbuki bu yapı nesnesinin aygıt sürücü yüklü olduğu sürece 
    bellekte bulunuyor olması gerekir.

    Eğer cdev türünden bu yapı nesnesi programcı tarafından global bir biçimde tanımlanacaksa yapının elemanlarına ilk değer vermek 
    için cdev_init fonksiyonu çağrılmalıdır. Eğer cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde tahsis edilecekse artık 
    yapı elemanlarına ilkdeğerlerin verilmesi işlemi cdev_init fonksiyonuyla yapılmaz. Çünkü zaten cdev_alloc bu işlemi kendi 
    içerisinde yapmaktadır. Fakat yine de programcının bu durumda manuel olarak yapının bazı elemanlarına değer ataması da 
    gerekmektedir. Bu iki yoldan biriyle oluşturulmuş olan cdev yapı nesnesi cdev_add isimli fonksiyonla çekirdeğin veri yapılarına 
    yerleştirilmelidir. Tabii aygıt sürücü boşaltılırken bu yerleştirme işlemi cdev_del fonksiyonuyla geri alınmalıdır. cdev_del 
    fonksiyonu, struct cdev yapısı cdev_alloc ile tahsis edilmişse aynı zamanda onu free hale de getirmektedir. Özetle çekirdek 
    modülümüzün tam bir karakter aygıt sürücüsü haline getirilmesi için şunlar yapılmalıdır:

    1) struct cdev isimli bir yapı türünden nesne global olarak (statik ömürlü olarak) tanımlanmalı ya da cdev_alloc fonksiyonu ile
    çekirdeğin heap sistemi içerisinde tahsis edilmelidir. Eğer bu nesne global olarak tanımlanacaksa nesneye cdev_init fonksiyonu 
    ile ilkdeğerleri verilmelidir. Eğer nesne cdev_alloc fonksiyonu ile çekirdeğin heap alanında tahsis edilecekse bu durumda ilkdeğer 
    verme işlemi bu fonksiyon tarafından yapılmaktadır. Ancak programcının yine yapının bazı elemanlarını manuel olarak doldurması 
    gerekmektedir.

    2) Oluşturulan bu struct cdev nesnesi cdev_add çekirdek fonksiyonu ile çekirdeğe eklenmelidir.

    3) Çekirdek modülü çekirdek alanından atılırken modülün exit fonksiyonunda cdev_add işleminin geri alınması için cdev_del 
    fonksiyonunun çağrılması gerekmektedir.

    cdev_init fonksiyonunun parametrik yapısı şöyledir:

    #include <linux/cdev.h>

    void cdev_init(struct cdev *cdev, const struct file_operations *fops);

    Fonksiyonun birinci parametresi ilk değer verilecek global cdev nesnesinin adresini alır. İkinci parametre ise file_operations 
    türünden bir yapı nesnesinin adresi almaktadır. file_operations isimli yapı birtakım fonksiyon adreslerinden oluşmaktadır. 
    Yani yapının tüm elemanları birer fonksiyon göstericisidir. Bu yapı kullanıcı modundaki program tarafından ilgili aygıt dosyası 
    açılıp çeşitli işlemler yapıldığında çağrılacak fonksiyonların adreslerini tutmaktadır. Örneğin kullanıcı modundaki program open, 
    close, read, write yaptığında çağrılacak fonksiyonlarımızı burada belirtiriz. file_operations büyük bir yapıdır:

    struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out,
                    loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
    };

    Bu yapının yalnızca bazı elemanlarına atama yapabiliriz. Bunun için gcc eklentilerinden faydalanılabilir. (Bu eklentiler C99 
    ile birlikte C'ye eklenmiştir.) Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp);
    static int generic_release(struct inode *inodep, struct file *filp);

    struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release
    };

    Yapının owner elemanına THIS_MODULE makrosunun atanması iyi bir tekniktir. Biz burada "aygıt sürücümüz open fonksiyonuyla 
    açıldığında generic_open isimli fonksiyon çağrılsın", aygıt sürücümüz close fonksiyonu ile kapatıldığında "generic_release 
    isimli fonksiyonumuz çağrılsın" demiş olmaktayız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                88. Ders 13/03/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde de tahsis edilebilir. cdev_alloc 
    fonksiyonunun prototipi şöyledir:

    #include <linux/cdev.h>

    struct cdev *cdev_alloc(void);

    Fonksiyon başarı durumunda cdev yapısının adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Yukarıda da belirttiğimiz
    gibi cdev yapısı cdev_alloc fonksiyonu ile tahsis edilmişse cdev_init yapılmasına gerek yoktur. Ancak bu durumda programcının 
    manuel olarak yapının owner ve ops elemanlarına değer ataması gerekir. Örneğin:

    struct cdev *g_cdev;
    ...
    if ((gcdev = cdev_alloc()) == NULL) {
        printk(KERN_ERROR "cannot allocate cdev!...\n");
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    cdev_alloc fonksiyonu başarısız olduğunda bunu çağıran fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygun olur. ENOMEM 
    errno değeri bellek yetersizliği nedeniyle başarısızlık oluştuğunu belirtmektedir. cdev yapı nesnesi başarılı bir biçimde 
    oluşturulduktan sonra artık bu yapının çekirdek modülü içerisine yerleştirilmesi gerekir. Bu da cdev_add fonksiyonuyla 
    yapılmaktadır. cdev_add fonksiyonunun prototipi de şöyledir:

    #include <linux/cdev.h>

    int cdev_add(struct cdev *devp, dev_t dev, unsigned count);

    Fonksiyonun birinci parametresi cdev türünden yapı nesnesinin adresini almaktadır. Fonksiyonun ikinci parametresi aygıt sürücünün 
    majör ve minör numaralarını, üçüncü parametresi ise ilgili minör numaradan itibaren kaç minör numaranın kullanılacağı belirtmektedir.
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        ...
        return result;
    }

    Aygıt sürücü boşaltılırken cdev_add ile yapılan işlemin geri alınması gerekir. Bu da cdev_del fonksiyonuyla yapılmaktadır. 
    (cdev_alloc işlemi için bunu free hale getiren ayrı bir fonksiyon yoktur. cdev_alloc ile tahsis edilen alan cdev_del fonksiyonu 
    tarafından otomatik olarak free hale getirilmektedir.)

    #include <linux/cdev.h>

    void cdev_del(struct cdev *devp);

    Fonksiyon parametre olarak cdev yapısının adresini almaktadır.

    Buradaki önemli bir nokta şudur: cdev_add fonksiyonu cdev nesnesinin içini çekirdekteki uygun veri yapısına kopyalamamaktadır. 
    Bizzat bu nesnenin adresini kullanmaktadır. Yani çekirdek modülü var olduğu sürece bu cdev nesnesinin de yaşıyor olması gerekir.
    Bu da cdev nesnesinin ve file_operations nesnesinin global biçimde (ya da statik ömürlü biçimde) tanımlanmasını gerektirmektedir.

    Aşağıda bu işlemlerin yapıldığı örnek bir karakter aygıt sürücüsü verilmiştir. Bu aygıt sürücü majör=130, minör=0 aygıtını 
    kullanmaktadır. Dolayısıyla aşağıdaki programın testi için şöyle bir aygıt dosyasının yaratılmış olması gerekir. Yaratımı
    aşağıdaki gibi yapabilirsiniz:

    $ sudo mknod mydriver -m 666 c 130 0

    Bu aygıt sürücü insmod ile yüklendiğinde artık biz kullanıcı modunda "mydriver" dosyasını açıp kapattığımızda file_operations
    yapısına yerleştirdiğimiz generic_open ve generic_release fonksiyonları çağrılacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda biz cdev nesnesini global olarak tanımladık. Aşağıda ise cdev nesnesinin cdev_alloc fonksiyonu ile 
    dinamik biçimde tahsis edilmesine bir örnek veriyoruz. cdev_alloc fonksiyonu ile tahsis edilmiş alanların zaten cdev_del
    fonksiyonu ile geri bırakıldığını belirtmiştik. Ancak cdev_add fonksiyonu başarısız olursa cdev_del fonksiyonunun çağrılması
    anlamsız olacağı için cdev_alloc fonksiyonu ile tahsis edilmiş olan alan kfree fonksiyonuyla serbest bırakılmıştır. kfree
    fonksiyonu çekirdek heap sistemine ilişkin genel bir bir fonksiyondur. Çekirdek heap sistemine "dilimli tahsisat sistemi 
    (slab allocator)" denilmektedir. Bu konu ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev *g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!..\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_ERR "cannot allocate cdev!...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device...\n");
        kfree(g_cdev);
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek kodlarının ve aygıt sürücü kodlarının çekirdek modunda (kernel mode) çalıştığını belirtmiştik. Çekirdeğin bulunduğu
    bellek alanı ile kullanıcı proseslerinin bulunduğu bellek alanı birbirlerinden izole edilmiştir. Daha önceden de belirttiğimiz 
    gibi kullanıcı modunda çalışan prosesler çekirdek alanına erişemezler. Çünkü çekirdek kendisini sayfa tabanlı koruma mekanizması 
    yoluyla sıradan proseslerden korumaktadır. Fakat bazı durumlarda çekirdek alanı alanı kullanıcı proseslerinin bulunduğu kullanıcı 
    alanı arasında veri transferlerinin yapılması gerekebilmektedir. Örneğin sys_read sistem fonksiyonu çekirdek tarafından okunan 
    bilgileri kendisini çağıran prosesin kullanıcı alanına aktarmaktadır. sys_write fonksiyonu ise bunun tersini yapmaktadır. 

    Çekirdek alanı ile kullanıcı alanı arasında memcpy fonksiyonu ile transfer yapmaya çalışmak uygun değildir. Bunun birkaç nedeni 
    vardır. Bu tür transferlerde çekirdek modunda çalışan kodların kullanıcı alanındaki adresin geçerliliğini kontrol etmesi gerekir.
    Aksi takdirde çekirdek modunda geçersiz bir alana kopyalama yapmak sistemin çökmesine yol açabilmektedir. Örneğin biz sys_read 
    sistem fonksiyonu ile dosyadan belirttiğimiz adrese aktarım yapmak isteyelim. Eğer biz kendi prosesimize ilişkin bir adres vermek 
    yerine çekirdeğin çalıştığı alana ilişkin bir adres verirsek tüm sistem çökebilir. İşte sys_read fonksiyonu aktarımı yapmadan önce 
    verilen adresin gerçekten prosesin adres alanı içerisindeki bir adres olup olmadığını kontrol etmektedir. Ayrıca kullanıcı alanına 
    ilişkin prosesin sayfa tablosunun bazı bölümleri o anda RAM'de olmayabilir (yani swap out yapılmış olabilir). Böyle bir durumda 
    işleme devam etmek çekirdek tasarımı bakımından sorun oluşturmaktadır. Eğer böyle bir durum varsa çekirdek kodlarının önce sayfa 
    tablosunu RAM'e geri yükleyip işlemine devam etmesi gerekmektedir.

    İşte yukarıda açıklanan bazı nedenlerden dolayı çekirdek alanı ile kullanıcı alanı arasında aktarım işlemi için özel çekirdek 
    fonksiyonları kullanılmaktadır. Yani biz kullanıcı modunda çalışan programlar ile çekirdek modülümüz arasında aktarımları özel 
    bazı çekirdek fonksiyonlarıyla yapmalıyız. Bu amaçla kullanılan çeşitli çekirdek fonksiyonları ve makroları bulunmaktadır. En temel 
    iki fonksiyon copy_to_user ve copy_from_user fonksiyonlarıdır. Bu fonksiyonların prototipleri şöyledir:

    #include <linux/uaccess.h>

    unsigned long copy_to_user(void *to, const void *from, unsigned len);
    unsigned long copy_from_user(void *to, const void *from, unsigned len);

    Fonksiyonların birinci parametreleri kopyalamanın yapılacağı hedef adresi belirtmektedir. Yani copy_to_user için birinci 
    parametre user alanındaki adres, copy_from_user için birinci parametre çekirdek alanındaki adrestir. İkinci parametre kaynak 
    adresi belirtmektedir. Bu kaynak adres copy_to_user için çekirdek alanındaki adres, copy_from_user için kullanıcı alanındaki 
    adrestir. Son parametre aktarılacak byte sayısını belirtmektedir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık 
    durumunda aktarılamayan byte sayısına geri dönerler. Çekirdek mod programcılarının bu fonksiyonlar başarısız olursa kendi
    fonksiyonlarını -EFAULT (Bad address) ile geri döndürmesi uygun olur. (Örneğin sys_read ve sys_write fonksiyonlarına 
    biz geçersiz bir user mode adresi verirsek bu sistem fonksiyonları da -EFAULT değeri ile geri dönmektedir. Bu hata kodunun 
    yazısal karşılığı "Bad address" biçimindedir.) Örneğin:

    if (copy_to_user(...) != 0)
        return -EFAULT;

    Bazen kullanıcı alanındaki adresin geçerliliği zaten daha önceden sınanmıştır. Bu durumda yeniden geçerlilik sınaması yapmadan 
    yukarıdaki işlemleri yapan __copy_to_user ve __copy_from_user fonksiyonları kullanılabilir. Bu fonksiyonların parametrik yapıları 
    copy_to_user ve copy_from_user fonksiyonları ile aynıdır. Aralarındaki tek fark ise bu fonksiyonların adres geçerliliğine ilişkin 
    sınama yapmamalarıdır:

    #include <linux/uaccess.h>

    unsigned long __copy_to_user(void *to, const void *from, unsigned len);
    unsigned long __copy_from_user(void *to, const void *from, unsigned len);

    Bazı durumlarda programcı 1 byte, 2 byte, 4 byte, 8 byte'lık verileri transfer etmek isteyebilir. Bu küçük miktardaki verilerin 
    transfer edilmesi için daha hızlı çalışan özel iki makro bulundurulmuştur: put_user ve get_user. Bu makroların parametrik 
    yapısı şöyledir:

    #include <linux/uaccess.h>

    put_user(x, ptr);
    get_user(x, ptr);

    Burada x aktarılacak nesneyi belirtir. (Bu nesnenin adresini programcı almaz, makro içinde bu işlem yapılmaktadır.) ptr 
    ise aktarım adresini belirtmektedir. Aktarım ikinci parametrede belirtilen adresin türünün uzunluğu kadar yapılmaktadır. 
    Başka bir deyişle biz makroya hangi türden nesne verirsek zaten makro o uzunlukta aktarım yapmaktadır.

    Makrolar başarı durumunda 0, başarısızlık durumunda negatif hata koduna geri dönerler. Kullanımları şöyle olabilir:

    if (put_user(...) != 0)
        return -EFAULT;

    Bu makroların da geçerlilik kontrolü yapmayan __put_user ve __get_user isimli versiyonları vardır:

    #include <linux/uaccess.h>

    __put_user(x, ptr);
    __get_user(x, ptr);

    Örneğin biz çekirdek modülümüzdeki 4 byte'lık int bir x nesnesinin içerisindeki bilgiyi puser ile temsil edilen kullanıcı 
    alanındaki adrese kopyalamak isteyelim. Bu işlemi şöyle yaparız:

    int x;
    int *puser;
    ...
    if (put_user(x, puser) != 0)
        return -EFAULT;

    Nihayet kullanıcı alanındaki adresin geçerliliği de access_ok isimli makroyla sorgulanabilmektedir. Makro şöyledir:

    #include <linux/uaccess.h>

    access_ok(type, addr, size);

    Buradaki type sınama geçerliliğinin türünü belirtmektedir. Okuma geçerliliği için bu parametre VERIFY_READ, yazma geçerliliği 
    için VERIFY_WRITE ve hem okuma hem de yazma geçerliliği için VERIFY_READ|VERIFY_WRITE biçiminde girilmelidir. İkinci parametre
    geçerliliği sınanacak adresi ve üçüncü parametre de o adresten başlayan alanın uzunluğunu belirtmektedir. Fonksiyon başarı 
    durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri dönmektedir. Örneğin biz kullanıcı alanında puser
    adresiyle başlayan 100 byte'lık alanın yazma bakımından geçerli bir alan olup olmadığını sınamak isteyelim. Bu sınamayı
    çekirdek modülümüzde şöyle yapabiliriz:

    if (access_ok(VERIFY_WRITE, puser, 100)) {        // adres geçerli
        ...
    }
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                89. Ders 18/03/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar aygıt dosyası open ile açıldığında ve close ile kapatıldığında aygıt sürücümüz içerisindeki fopen ve release 
    fonksiyonlarımızın çağrılmasını sağladık. Şimdi de aygıt dosyası üzerinde read ve write fonksiyonları uygulandığında aygıt 
    sürücümüzdeki read ve write fonksiyonlarının çağrılması üzerinde duracağız.

    Aygıt dosyası open POSIX ile açılıp read POSIX fonksiyonu ile okunduğunda aygıt sürücümüz içerisinde belirlediğimiz "read" 
    fonksiyonumuz, write POSIX fonksiyonu çağrıldığında da aygıt sürücümüz içerisinde belirlediğimiz write fonksiyonumuz çağrılmaktadır. 
    Bunu sağlamak için file_operations yapısının read ve write elemanlarına çağrılacak fonksiyonların adreslerini girmeliyiz. 
    Karakter aygıt sürücülerinin read ve write fonksiyonlarının prototipleri aşağıdaki gibi olmak zorundadır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

    Aygıt sürücüsü için read ve write fonksiyonları yukarıdaki prototipe uygun bir biçimde tanımlandıktan sonra bunların adresleri 
    aşağıdaki gibi file_operations türünden yapı nesnesinin read ve write elemanlarına atanmalıdır:

    static struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release,
        .read = generic_read,
        .write = generic_write,
    };

    Artık aygıt dosyası üzerinde read POSIX fonksiyonu çağrıldığında aygıt sürücümüzdeki generic_read fonksiyonu, write POSIX 
    fonksiyonu çağrıldığında da aygıt sürücümüzdeki generic_write POSIX fonksiyonu çağrılacaktır.

    Aygıt sürücümüzdeki read ve write fonksiyonlarının birinci parametresi açılmış dosyaya ilişkin struct file nesnesinin adresini 
    belirtir. Bu nesneye "dosya nesnesi (file object)" de denilmektedir.

    Anımsanacağı gibi bir dosya açıldığında çekirdek sys_open fonksiyonunda bir dosya nesnesi (struct file) tahsis edip bu dosya 
    nesnesinin adresini dosya betimleyici tablosundaki bir slota yerleştirip onun indeksini dosya betimleyicisi olarak geri 
    döndürüyordu. İşte bu read ve write fonksiyonlarının birinci parametreleri bu dosya nesnesinin adresini belirtmektedir. 
    Çekirdek açık dosya ilgili her türlü işlemi bu dosya nesnesindeki bilgilerden hareketle yapmaktadır.

    Dosya Betimleyici Tablosu

    0 ---------> Dosya Nesnesi
    1 ---------> Dosya Nesnesi
    2 ---------> Dosya Nesnesi
    3 ---------> Dosya Nesnesi
    4 ---------> Dosya Nesnesi
    5 ---------> Dosya Nesnesi
    ...

    Yukarıda da belirttiğimiz gibi file yapısı içerisinde dosya göstericisinin konumu, dosyanın erişim hakları, referans sayacının 
    değeri, dosyanın açış modu ve açış bayrakları ve başka birtakım bilgiler bulunmaktadır. Linux çekirdeğinin 2.4.30 sürümündeki 
    file yapısı şöyledir:

    struct file {
        struct list_head        f_list;
        struct dentry            *f_dentry;
        struct vfsmount            *f_vfsmnt;
        struct file_operations    *f_op;
        atomic_t                f_count;
        unsigned int            f_flags;
        mode_t                    f_mode;
        loff_t                    f_pos;
        unsigned long            f_reada, f_ramax, f_raend, f_ralen, f_rawin;
        struct fown_struct        f_owner;
        unsigned int            f_uid, f_gid;
        int                        f_error;

        size_t                    f_maxcount;
        unsigned long            f_version;

        // needed for tty driver, and maybe others
        void                    *private_data;

        // preallocated helper kiobuf to speedup O_DIRECT
        struct kiobuf            *f_iobuf;
        long                    f_iobuf_lock;
    };

    Biz burada bilerek sadelik sağlamak için eski bir çekirdeğin file yapısını verdik. Yeni çekirdeklerde buna birkaç eleman daha 
    eklenmiştir. Ancak temel elemanlar yine aynıdır. Biz aygıt sürücümüzün read ve write fonksiyonlarında söz konusu aygıt 
    dosyasının birtakım özelliklerine erişmek istediğimizde bu yapıyı kullanırız.

    Aygıt sürücüdeki read ve write fonksiyonlarının ikinci parametresi kullanıcı alanındaki transfer adresini belirtir. Kullanıcı 
    modunda read POSIX fonksiyonu çağrıldığında aygıt sürücüdeki read fonksiyonunun copy_to_user gibi bir fonksiyonla bu adrese
    transfer yapması gerekir. Benzer biçimde kullanıcı modunda write POSIX fonksiyonu çağrıldığında da aygıt sürücü içerisindeki 
    write fonksiyonunun kullanıcı modundaki bu adresten copy_from_user gibi bir fonksiyonla transfer yapması gerekir. Aygıt 
    sürücüdeki read ve write fonksiyonlarının üçüncü parametreleri okunacak ya da yazılacak byte miktarını belirtmektedir. Son 
    parametre ise dosya göstericisinin konumunu belirtir. Ancak bu parametre file yapısı içerisindeki f_pos elemanının adresi 
    değildir. Çekirdek tarafından aygıt sürücünün read ve write fonksiyonları çağrılmadan önce file yapısı içerisindeki f_pos 
    elemanının değeri başka bir nesneye atanıp o nesnenin adresi read ve write fonksiyonlarına geçirilmektedir. read ve write 
    fonksiyonları sonlandığında çekirdek adresini geçirdiği nesnenin değerini file yapısının f_pos elemanına kendisi yerleştirmektedir.
    Yani aygıt sürücümüzdeki read ve write fonksiyonları içerisinde biz her zaman dosya göstericisinin konumunu bu parametrenin
    gösterdiği nesneden alıp bu parametrenin gösterdiği yerdeki nesneyi güncellemeliyiz.

    Aygıt sürücü içerisindeki read ve write fonksiyonları başarı durumunda transfer edilen byte sayısına, başarısızlık durumunda 
    negatif errno değerine geri dönmelidir.

    Biz aygıt sürücümüz için read ve write fonksiyonlarını yazarken read ve write fonksiyonları içerisinde transfer edilen byte 
    miktarı kadar dosya göstericisini ilerletmemiz gerekir. Bu işlem yukarıda da belirttiğimiz gibi fonksiyonların son parametresi 
    olan off göstericisinin gösterdiği yerin güncellenmesi ile yapılmalıdır. Örneğin n byte transfer edilmiş olsun. Bu durumda 
    dosya göstericisinin konumu aşağıdaki gibi güncellenebilir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        ...
        *off += n;
        ...

        return n;
    }

    Yukarıda da belirttiğimiz gibi aygıt sürücünüzün read ve write fonksiyonlarında dosya göstericisini konumlandırmak için 
    file yapısının f_pos elemanını güncellemeyiniz. Dosya göstericisinin konumlandırılması her zaman read ve write fonksiyonlarının 
    son parametresi yoluyla yapılmaktadır. Çekirdeğin dosya göstericisini nasıl güncellediğine ilişkin aşağıdaki gibi bir 
    temsili kod örneği verebiliriz:

    loff_t off;
    ...
    off = filp->f_pos;
    read(filp, buf, size, &off);
    filp->f_pos = off;

    Aşağıdaki örnekte aygıt sürücü için read fonksiyonu yazılmıştır. Bu fonksiyon aslında g_buf isimli dizinin içini dosya 
    gibi vermektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        25
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_read called...\n");

    return size;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[100];

    if ((fd = open("mydriver", O_RDWR)) == -1)
        exit_sys("open");

    read(fd, buf, 100);
    write(fd, buf, 100);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücümüzün read fonksiyonunun gerçekten bir dosyadan okuma yapıyormuş gibi davranmasını sağlayalım. Bunun 
    için dosyamızı temsil eden aşağıdaki gibi global bir dizi kullanacağız:

    static char g_file_buf[] = "01234567890ABCDEFGH";

    Buradaki diziyi sanki bir dosya gibi ele alacağız. Aygıt sürücümüzün read fonksiyonu aşağıdaki gibi olacaktır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;
        size_t slen;

        slen = strlen(g_buf);
        esize = *off + size > slen ? slen - *off : size;

        if (copy_to_user(buf, g_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;

        return esize;
    }

    Burada önce dosya göstericisinin gösterdiği yerden itibaren size kadar byte'ın gerçekten dizi içerisinde olup olmadığına 
    bakılmıştır. Eğer *off + size değeri bu dizinin uzunluğundan fazlaysa size kadar değer değil slen - *off kadar değer okunmuştur. 
    Aygıt sürücülerin read ve write fonksiyonlarında dosya göstericisinin ilerletilmesi programcının sorumluluğundadır. Bu nedenle 
    okuma işlemi yapıldığında dosya göstericisinin konumu aşağıdaki gibi artırılmıştır:

    *off += esize;

    read fonksiyonunun okunabilen byte sayısına geri döndürüldüğüne dikkat ediniz. copy_to_user fonksiyonu ile tüm byte'lar
    kullanıcı alanına kopyalanamamışsa fonksiyon -EFAULT değeri ile geri döndürülmüştür.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[] = "01234567890ABCDEFGH";

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;
    size_t slen;

    slen = strlen(g_file_buf);
    esize = size > slen - *off ? slen - *off : size;

    if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
        return -EFAULT;

    *off += esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü için write fonksiyonu da tamamen read fonksiyonuna benzer biçimde yazılmaktadır. write fonksiyonu içerisinde
    biz kullanıcı modundaki bilgiyi copy_from_user ya da get_user fonksiyonlarıyla alırız. Yine write fonksiyonu da istenilen 
    kadar byte'ın transfer edilememesi durumunda -EFAULT değeri ile, başarılı sonlanmada ise yazılan (çekirdek alanına yazılan) 
    byte miktarı ile geri dönmelidir.

    Aşağıdaki örnekte aygıt sürücü bellekte oluşturulmuş bir dosya gibi davranmaktadır. Aygıt sürücünün taklit ettiği dosya
    en fazla 4096 byte olabilmektedir:

    #define FILE_BUF_SIZE        4096
    ...
    static char g_file_buf[FILE_BUF_SIZE];

    Ancak buradaki FILE_BUF_SIZE bellek dosyasının maksimum uzunluğunu belirtmektedir. Bellek dosyasının gerçek uzunluğu f_fsize 
    nesnesinde tutulmaktadır. Aygıt sürücünün write fonksiyonu aşağıdaki gibi yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

        if (esize > 0) {
            if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
                return -EFAULT;
            *off += esize;

            if (*off > g_fsize)
                g_fsize = *off;
        }

        return esize;
    }

    Burada yine dosya göstericisinin gösterdiği yerden itibaren yazılmak istenen byte sayısı FILE_BUF_SIZE değerini aşıyorsa 
    geri kalan miktar kadar yazma yapılmıştır. Dosya göstericisinin yine ilerletildiğine dikkat ediniz. Dosya göstericisinin 
    ilerletilmesi her zaman programcının sorumluluğundadır. Aygıt sürücümüzün read fonksiyonu da şöyledir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > g_fsize - *off ? g_fsize - *off : size;

        if (esize > 0) {
            if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
                return -EFAULT;
            *off += esize;
        }

        return esize;
    }

    Burada da dosya göstericisinin gösterdiği yerden itibaren okunmak istenen byte sayısının g_fsize değerinden büyük olup 
    olmadığına bakılmıştır. Yine dosya göstericisi fonksiyon tarafından güncellenmiştir.

    Programın testi için önce aygıt sürücüye aşağıdaki gibi birtakım byte'ları aktarabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Burada -n parametresi '\n' karakterinin dosyaya yazılmasını engellemektedir. Bundan sonra artık yukarıdaki "app.c" programı
    ile testi yapabilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                90. Ders 20/03/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundan aygıt dosyası betimleyicisi ile lseek POSIX fonksiyonu çağrıldığında (bu fonksiyon da sys_lseek sistem 
    fonksiyonu çağırmaktadır) karakter aygıt sürücüsünün file_operations yapısı içerisine yerleştirilen llseek fonksiyonu 
    çağrılmaktadır. llseek fonksiyonun parametrik yapısı şöyledir:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

    Fonksiyonun birinci parametresi dosya nesnesini, ikinci parametresi konumlandırılmak istenen offset'i, üçüncü parametresi 
    ise konumlandırmanın nereye göre yapılacağını belirtmektedir. Bu fonksiyonu gerçekleştirirken programcı file yapısı 
    içerisindeki f_pos elemanını güncellemelidir. whence parametresi lseek fonksiyonundaki (ya da C'nin fseek fonksiyonundaki)
    orijinin belirten parametreyle aynı anlamdadır. Tipik olarak programcı whence parametresini switch içerisine alır. Hedeflenen 
    offset'i hesaplar ve en sonunda file yapısının f_pos elemanına bu hedeflenen offset'i yerleştirir. Hedeflenen offset uygun 
    değilse fonksiyon tipik olarak -EINVAL değeriyle geri döndürülür. Eğer konumlandırma offset'i başarılı ise fonksiyon 
    dosya göstericisinin yeni değerine geri dönmelidir.

    Aşağıda daha önce yapmış olduğumuz bellek dosyası örneğine llseek fonksiyonu da eklenmiştir. Fonksiyon aşağıdaki gibi 
    yazılmıştır:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
    {
        loff_t newpos;

        switch (whence) {
            case 0:
                newpos = off;
                break;
            case 1:
                newpos = filp->f_pos + off;
                break;
            case 2:
                newpos = g_fmem_size + off;
                break;
            default:
                return -EINVAL;
        }

        if (newpos < 0 || newpos > g_fmem_size)
            return -EINVAL;

        filp->f_pos = newpos;

        return newpos;
    }

    Burada önce whence parametresine bakılarak dosya göstericisinin konumlandırılacağı offset belirlenmiştir. Sonra dosya 
    nesnesinin f_pos elemanı güncellenmiştir. Çekirdek kodlarında da kullanıcı modunda kullandığımız SEEK_SET (0), SEEK_CUR (1)
    ve SEEK_END (2) sembolik sabitleri tanımlanmış durumdadır.

    Aşağıdaki örnekte aygıt sürücüyü yükledikten sonra yine onun içerisinde oluşturduğumuz dosyaya komut satırından birşeyler
    yazabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Test programında lseek ile konumlandırma yapıp sonra okuma yaptık. Test kodunu değiştirerek lseek fonksiyonunun 
    çalışıp çalışmadığını kontrol edebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};
static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = g_fsize + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= g_fsize)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    if (lseek(fd, 5, 0) == -1)
        exit_sys("lseek");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadarki örneklerimizde aygıt sürücümüzün majör ve minör numarasını baştan belirledik. Bunun en önemli sakıncası 
    belirlediğimiz majör numaralı bir aygıt sürücünün zaten yüklü olarak bulunuyor olmasıdır. Bu durumda aygıt sürücümüz yüklenemeyecektir. 
    Aslında daha doğru bir strateji tersten gitmektir. Yani önce aygıt sürücümüz içerisinde biz boş bir majör numara bulup onu 
    kullanabiliriz. Tabii sonra kullanıcı modundan bu aygıt numarasına ilişkin bir aygıt dosyasını da yaratmamız gerekir.

    Boş bir aygıt numarasını bize veren alloc_chrdev_region isimli bir çekirdek fonksiyonu vardır. Fonksiyonun parametrik yapısı 
    şöyledir:

    int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt numarasının yerleştirileceği dev_t nesnesinin adresini alır. İkinci ve üçüncü 
    parametreler başlangıç minör numarası ve onun sayısını belirtir. Son parametre ise aygıt sürücüsünün "/proc/devices" dosyasında 
    ve "/sys/module" dizininde görüntülenecek olan ismini belirtmektedir. alloc_chrdev_region fonksiyonu zaten register_chrdev_region 
    fonksiyonunun yaptığını da yapmaktadır. Dolayısıyla bu iki fonksiyondan yalnızca biri kullanılmalıdır. Fonksiyon başarı durumunda 
    0 değerine, başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    dev_t g_dev;
    ...

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) != 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    Aygıt sürücülerin majör numaraları birbirinden farklı olmak zorundadır. Biz kullanılan bir majör numaraya ilişkin kullanılmayan 
    bir numara eşliğinde aygıt sürücümüzü register ettiremeyiz.

    Aygıt sürücümüzde alloc_chrdev_region fonksiyonu ile boş bir majör numara numaranın bulunup aygıt sürücümüzün register 
    ettirildiğini düşünelim. Peki biz bu numarayı nasıl bilip de komut satırından bu numaraya uygun aygıt dosyası yaratacağız? 
    İşte bunun için genellikle izlenen yöntem "/proc/devices" dosyasına bakıp oradan majör numarayı alıp aygıt dosyasını yaratmaktır. 
    Tabii bu manuel olarak yapılabilir ancak bir "shell script" ile otomatize de edilebilir. Aşağıdaki bu işlemi yapan "load" 
    isimli bir "shell script" verilmiştir:

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./${module}.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module c $major 0

    Artık biz bu "load" script'i ile aygıt sürücümüzü yükleyip aygıt dosyamızı yaratabileceğiz. Bu script'i "load" ismiyle yazıp 
    aşağıdaki gibi dosyaya "x" hakkı vermelisiniz:

    $ chmod +x load

    Çalıştırmayı komut satırı argümanı vererek aşağıdaki gibi yapmalısınız:

    $ sudo ./load generic-char-driver

    Burada "load" script'i çalıştırıldığında hem aygıt sürücü çekirdek alanına yüklenmekte hem de yüklenen aygıt sürücünün 
    majör numarasıyla (minör numarası da 0 olacak biçimde) "generic-char-driver" isimli aygıt dosyası yaratılmaktadır. Aygıt 
    sürücünün çekirdek alanından atılması manuel bir biçimde "rmmod" komutuyla yapılabilir. Tabii aynı zamanda bu aygıt sürücü 
    için yaratılan aygıt dosyasının da silinmesi uygun olabilir. Yukarıdaki script'te aygıt dosyası zaten varsa aynı zamanda o 
    dosya silinmektedir. Tabii aygıt dosyasını çekirdek alanından atarak silen ayrı bir "unload" isimli script'i de aşağıdaki 
    gibi yazabiliriz:

    #!/bin/bash

    module=$1

    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module

    Tabii yine bu script dosyasının da "x" hakkına sahip olması gerekmektedir:

    $ chmod +x unload

    "unload" script'ini aşağıdaki gibi çalıştırabilirsiniz:

    $ sudo ./unload generic-char-driver

    Aşağıdaki örnekte alloc_chrdev_region fonksiyonuyla hem boş bir aygıt numarası elde edilip hem de bu aygıt numarası register 
    ettirilmiştir. Yükleme işlemi yukarıdaki "load" script'i ile yapılmalıdır. çekirdek modülünün boşaltılması işlemi manuel 
    olarak ya da "unload" script'i ile yapılabilir. Örneğin:

    $ sudo ./load generic-char-driver
    ...
    $ sudo ./unload generic-char-driver
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};

static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = g_fsize + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= g_fsize)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("generic-char-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (lseek(fd, 5, 0) == -1)
        exit_sys("lseek");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                91. Ders 25/03/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi gelinen noktaya kadar görülmüş olan konular kullanılarak basit bir "boru (pipe)" örneği yapalım. Borular pek çok 
    işletim sisteminde bulunan ve en çok kullanılan "prosesler arası haberleşme (interprocess communication)" yöntemlerinden 
    biridir. Bir proses boruya birtakım byte'ları yazar. Diğeri de o byte'ları yazıldığı sırada okur. Bu yönüyle borular
    çekirdek tarafından organize edilen FIFO kuyruk sistemi gibidir.

    Bizim boru örneğimizde bir proses boruyu yazma modunda açtığında prosesin write fonksiyonuyla yazdıkları aygıt sürücü 
    içerisindeki bir FIFO kuyruk sistemine yazılmaktadır. Diğer proses de read fonksiyonuyla okuma yaptığında aslında bu bu 
    FIFO kuyruk sisteminden okuma yapılmaktadır. Burada yapacağımız gerçekleştirim UNIX/Linux sistemlerindeki "isimli borulara 
    (named pipes)" benzemektedir. Biz bu örneği çeşitli konuları gördükçe geliştireceğiz. Anımsayacağınız gibi UNIX/linux 
    sistemlerindeki boruları kullanırken eğer boru tamamen boşsa karşı taraf boruya en az 1 byte yazana kadar bloke oluşmaktadır. 
    Boru tamamen doluysa yazma sırasında karşı taraf okuma yapıp boruda yazılacak miktar kadar alan açana kadar bloke oluşmaktadır. 
    Ayrıca isimli borularda boruyu bir taraf okuma modunda açmaya çalıştığında diğer taraf boruyu yazma modunda açana kadar, 
    yazma modunda açmaya çalıştığında diğer taraf boruyu okuma modunda açana kadar da bloke oluşmaktadır. Biz bu gerçekleştirimde 
    henüz bloke oluşturmayı görmediğimizden dolayı bu özellikleri sağlamayacağız.

    Boruya ilişkin bir FIFO kuysuk sistemini oluşturabilmek için aşağıdaki nesnelerin tanımlanması gerekmektedir:

    #define PIPE_BUFFER_SIZE        8192

    static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
    static size_t g_head;
    static size_t g_tail;
    static size_t g_count;

    Burada g_pipebuf FIFO kuyruk sistemi için kullanılacak olan tamponu belirtmektedir. Bu tamponun PIPE_BUFFER_SIZE kadar 
    olduğuna dikkat ediniz. g_head kuyruğun başını, g_tail ise sonunu göstermektedir. Kuyruğa yazan taraf g_tail indeksinden 
    itibaren yazmayı yapar, kuyruktan okuma yapan taraf ise g_head indeksinden itibaren okuma yapar. Tabii bu indeksler dizinin
    sonuna geldiğinde yeniden başa geçirilmelidir. g_count ise kuyrukta kaç byte'ın bulunduğunu belirtmektedir. Başlangıçta 
    g_head, g_tail ve g_count 0 değerindedir. Yani kuyruk boştur.

    Aygıt sürücünün write fonksiyonu şöyle yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Burada kullanıcı modundaki proses write işlemi yaptığında bizim yazılmak istenen byte'ları copy_from_user fonksiyonu ile 
    alarak g_pipebuf içerisine g_tail indeksinden itibaren yazmamız gerekir. Ancak burada iki durum söz konusudur. Eğer g_tail 
    indeksi g_head indeksinden büyük ya da ona eşitse iki parçalı bir yazım gerekebilir. Ancak eğer g_tail indeksi g_head indeksinden 
    küçükse yazım tek seferde yapılabilir. Biz kodumuzda önce boru tamponunun dolu olup olmadığına baktık:

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    Boru tamponu tamamen dolu ise fonksiyonu 0 ile geri döndürdük. Kullanıcı modunda write fonksiyonun geri dönüş değerini 0 
    olarak gören programcı borunun dolu olduğunu anlayacaktır. Biz kodumuzda, yazma işlemi sanki iki parça halinde yapılacakmış 
    gibi bu iki parçanın uzunluklarını elde ettik:

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    Tabii eğer g_tail indeksi g_head indeksinin gerisindeyse burada size2 zaten 0 olacaktır. Ayrıca g_tail indeksi g_head indeksinin
    ilerisinde olduğu halde yazılacak miktar PIPE_BUFFER_SIZE - g_tail miktarından küçük ya da ona eşit ise yine size2 0 olacaktır.
    Kopyalama şöyle yapılmıştır:

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    Tabii bu işlemlerden sonra g_tail artık yeni pozisyonuna çekilmeli ve g_count da yazılan miktar kadar artırılmalıdır:

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    write fonksiyonun başarılı biçimde yazılan byte sayısıyla geri döndüğünü anımsayınız. İsimli borularda aslında yazılmak istenen 
    miktar kadar boruda boş yer yoksa ve blokeli mod söz konusuysa bloke oluştuğunu ancak blokesiz mod söz konusuysa write fonksiyonun 
    başarısız olduğunu ve errno değerinin EAGAIN ile set edildiğini anımsayınız. Bizim buradaki tasarımımız blokesiz mod gibi de 
    değildir. Biz burada eğer boruda yazmak istenilen miktar kadar yer yoksa yazılabilecek kadar bilgiyi boruya yazmayı tercih ettik.

    Aygıt sürücümüzün read fonksiyonu da benzer biçimde yazılabilir:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Buradaki aygıt sürücümüzde şu kusurlar vardır:

    - Aygıt sürücümüzde read/write fonksiyonlarında hiçbir senkronizasyon uygulamadık. Dolayısıyla eş zamanlı işlemlerde boru 
    mekanizması birbirine girebilir. Örneğin iki farklı proses bu boruya aynı anda yazma yaparsa senkronizasyondan kaynaklanan 
    sorunlar oluşabilir.

    - Bu gerçekleştirimimizde ayrıca iki proses de boruyu kapatsa bile borunun içerisindekiler silinmemektedir. Halbuki orijinal 
    isimli borularda prosesler boruyu kapatınca boru içerisindeki tüm bilgiler silinmektedir.

    - Bu gerçekleştirimimizde sistem genelinde tek bir boru yaratılmaktadır. Yani bizim boru aygıt sürücümüz tek bir boru üzerinde 
    işlemler yapmaktadır. Halbuki orijinal isimli borularda programcılar birbirinden bağımsız istedikleri kadar çok isimli 
    boru yaratabilmektedir.

    Aygıt sürücümüzü önce build edip sonra aşağıdaki gibi yüklemelisiniz:

    $ make file=pipe-driver
    $ sudo ./load pipe-driver

    Buradaki boru aygıt sürücüsünü test etmek için "pwriter" ve "preader" isimli iki program yazılmıştır. "pwriter" programı 
    klavyeden (stdin dosyasından) alınan yazıları boruya yazmakta, "preader" ise klavyeden (stdin dosyasından) alınan uzunlukta 
    byte'ı borudan okumaktadır. Test işlemini yaparken boru uzunluğunu azaltabilirsiniz. Biz örneğimizde boru uzunluğunu 
    8192 aldık.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == 0)
        return 0;

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            return -EFAULT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again...\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                92. Ders 27/03/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerimiz içerisindeki fonksiyonlar kullanıcı modundaki proseslerin thread'leri tarafında çalıştırılabilmektedir. 
    Örneğin yukarıdaki boru örneğinde bir prosesteki bir thread write POSIX fonksiyonuyla bu aygıt sürücümüzün write fonksiyonunun 
    çalıştırılmasına yol açabilir. Tam o sırada tesadüfen başka bir prosesin başka bir thread'i de yine write POSIX fonksiyonuyla 
    aygıt sürücümüzün write fonksiyonun çalıştırılmasına yol açabilir. Böylece aygıt sürücümüzün write fonksiyonun kodları birden 
    fazla akış tarafından iç içe çalıştırılmış olacaktır. İşte bu tür durumlarda eğer birden fazla akış tarafından çalıştırılan 
    kod parçası global birtakım veri yapılarını ve nesneleri kullanıyorsa onların karalı durumunu bozabilir. Bu da aygıt sürücünün
    hatalı çalışmasına ya da tüm sistemin çökmesine yol açabilir. Örneğin aygıt sürücümüz içerisindeki bir kodun bir diziye 
    insert işlemi yaptığını düşünelim:

    xxxxxxxxxxxxxxxxxxxx
          ^

    Burada aygıt sürücümüz içerisindeki kod dizinin işaretlenmiş noktasına bir insert işlemi yapacak olsun. Bu insert işlemi 
    için bizim bu diziye o noktadan sağa doğru açmamız (expand işlemi) gerekir:

    xxxxxx xxxxxxxxxxxxxx
          ^

    Bu açım da bir döngü içerisinde yapılacaktır. İşte bu açım iki farklı prosesin akışları tarafından tesadüfen aynı zaman 
    dilimi içerisinde yapılırsa bu dizi bozulacaktır. Bunun sonucu olarak da ya kod istenildiği gibi çalışmayacak ya da çökmeler
    oluşacaktır. Aslında bu akışların iç içe geçme durumu bir global değişkenin değerinin artırılması gibi basit bir işlemde 
    bile sorunlara yol açabilmektedir. Örneğin:

    int g_count;

    ...
    ...
    ++g_count;
    ...
    ...

    Burada aygıt sürücümüz içerisindeki bir fonksiyon (örneğin aygıt sürücümüzün read ya da write fonksiyonu) bu g_count değerini 
    1 artırmaktadır. Normal olarak bu kod parçası iki farklı akış tarafından işletildiğinde toplamda bu g_count değeri 2 artmış 
    olmalıdır. Ancak burada bir sorun vardır. Derleyiciler bu tür artırımları tek bir makine komutu ile yapmak zorunda değildir. 
    Örneğin 32 bit Intel işlemcileri bu artırımı tipik olarak 3 makine komutuyla yaparlar:

    MOV EAX, g_count
    INC EAX
    MOC g_count, EAX

    İşte iki akış iç içe geçtiğinde burada bile sorun oluşabilir. Örneğin:

    MOV EAX, g_count
    ----> ikinci akış
    INC EAX
    ----> birinci akış
    MOC g_count, EAX

    Burada aslında g_count iki kez artırılmak yerine iç içe geçmeden dolayı bir kez artırılacaktır. Buradaki g_count nesnesinin
    kuyruktaki eleman sayısını belirttiğini düşünelim. Bu kodda kuyruğa eleman ekleyen kısım olsun. Bu durumda aslında kuyruğa 
    iki eleman eklendiği halde g_count 1 artırılmış olacaktır. Dolayısıyla bütün kuyruk mekanizması bozulacak belki de bundan 
    tüm sistem etkilenecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki aygıt sürücümüz içerisindeki hangi kod parçaları iç içe çalışma bakımından potansiyel bir tehlike oluşturmaktadır?
    Bir fonksiyon hiçbir paylaşılan kaynağa erişmiyorsa yalnızca kendi yerel değişkenlerini kullanıyorsa bu fonksiyonun bir
    sorun yaratma olasılığı yoktur. Çünkü aygıt sürücü içerisindeki fonksiyonlar çağrılırken kullanıcı modundaki prosesler 
    farklı stack kullanmaktadır. Dolayısıyla yerel değişkenler de stack'te yaratıldığı için aslında bu akışlar yerel değişkenlerin
    farklı kopyalarını kullanıyor durumdadır. Örneğin:

    void foo(void)
    {
        int i = 0;

        ...
        ++i;
        ...
        ++i;
        ...
        ++i;
        ...
    }

    Buradaki foo fonksiyonunun birden fazla akış tarafından işletilmesi bir soruna yol açmaz. Çünkü aslında her akış buradaki 
    yerel i değişkeninin farklı bir kopyasını kullanıyor durumdadır. Fakat örneğin:

    int g_i = 0;

    void foo(void)
    {
        ...
        ++g_i;
        ...
        ++g_i;
        ...
        ++g_i;
        ...
    }

    Burada g_i değişkeni global olduğu için ve global değişkenlerin toplamda tek bir kopyası olduğu için farklı akışlar 
    bu fonksiyonu çalıştırdığında sorunlar ortaya çıkabilir. İşte genel olarak "paylaşılan (sharable)" bir kaynağa erişim 
    bir senkronizasyon problemi oluşturma potansiyeline sahiptir. Örneğin global nesneler, static yerel nesneler, global veri 
    yapıları, birtakım donanım aygıtları paylaşılan kaynaklara örnek olarak verilebilir. Aslında genellikle (fakat her zaman 
    değil) birden fazla akışın paylaşılan bir kaynağa okuma yapma amaçlı erişimi bir soruna yol açmamaktadır. İki akış üzerinde
    bu durumu şöyle açıklayabiliriz:

    Akış-1          Akış-2          Paylaşılan Kaynağın Durumu
    Okuma           Okuma           Bozulma Olmaz
    Okuma           Yazma           Bozulma Olabilir
    Yazma           Okuma           Bozulma Olabilir
    Yazma           Yazma           Bozulma Olabilir

    Özetle n tane akışın paylaşılan bir kaynağa eş zamanlı erişmesi durumunda eğer bu n tane kaynağın hepsi bu paylaşılan kaynağa 
    okuma amaçlı erişiyorsa bir sorun oluşmamaktadır. Ancak bu n akışın en az biri yazma amaçlı erişiyorsa burada sorun oluşma
    potansiyeli vardır.

    İşte aygıt sürücüleri yazanlar bu durumu dikkate alıp kendi kodlarının içerisinde gerekli önlemleri almalıdırlar.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri dünyasında ve çok akışlı programlamada başından sonuna kadar tek bir akış tarafından işletilmesi gereken
    kodlara "kritik kodlar (critical sections)" denilmektedir. Bir akış kritik koda girdiğinde başka bir bakış kritik koda 
    girmemeli ancak diğer akış kritik kodda çıkınca girmelidir. Örneğin:

    ...
    ...
    ...    KRİTİK KOD
    ...
    ...

    Burada kritik koda bir akış girdiğinde başka akışlar kritik koda girmemelidir. Ta ki girmiş olan akış kritik koddan çıkana
    kadar.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki kritik kodlar nasıl oluşturulabilir? Kritik kodların oluşturulması için özel makine komutları kullanılmaktadır. 
    Intel ve ARM gibi yaygın işlemciler kritik kod oluşturmayı sağlayan özel makine komutlarına sahiptir. Kritik kodlar aşağıdaki
    gibi bir flag mekanizmasıyla oluşturulamazlar:

    int g_flag = 0;
    ...

    while (g_flag == 1)
        ;
    g_flag = 1;
    ...
    ...    KRİTİK KOD
    ...
    g_flag = 0;

    Koddaki mantık şöyledir: Eğer g_flag değişkeni 0 ise kaynak boştadır. Bu durumda döngüden çıkılır ancak kritik koda girmeden 
    g_flag değişkeni 1 yapılarak diğer akışların bekletilmesi sağlanır. Kritik koddan çıkılırken de g_flag değişkeni 0 yapılmıştır. 
    Böylece kritik koddan çıkan akış kilidi açmış olacaktır. Ancak bu mekanizmanın bariz üç problemi vardır:

    1) g_flag = 1 iken kritik koda girmeye çalışan akış bir döngü içerisinde sürekli biçimde kontrol yapacak ve gereksiz bir biçimde 
    CPU zamanı harcayacaktır. Bu tür döngülere işletim sistemleri terminolojisinde "meşgul döngüler (busy loops)" denilmektedir.

    2) Koddaki ikinci sorun farklı işlemcilerde ya da çekirdeklerde çalışan iki farklı kodun aynı anda döngüden çıkabilmesidir. 
    Tabii bu çok işlemcili ya da çok çekirdekli sistemlerde söz konusu olabilir.

    while (g_flag == 1)
        ;
    ----> Farklı çekirdeklerdeki kodlar burayı tesadüfen birlikte geçebilirler
    g_flag = 1;
    ...
    ...    KRİTİK KOD
    ...
    g_flag = 0;

    3) Linux çekirdekleri 2.6 versiyonuyla birlikte preemptive hale getirilmiştir. Dolayısıyla kullanıcı modundaki bir thread 
    çekirdek moduna geçip çalışırken quanta süresini bitirdiğinde thread'ler arası geçiş olabilir. Bu geçiş eğer tesadüfen 
    döngüden çıkıldığında gerçekleşirse tek bir işlemci ya da çekirdeğin olduğu ortamda bile kritik koda birden fazla akış 
    girebilir. Örneğin:

    while (g_flag == 1)
        ;
    ----> Tam bu noktada thread'ler arası geçiş olursa başka bir akış da kritik koda girebilir
    g_flag = 1;
    ...
    ...    KRİTİK KOD
    ...
    g_flag = 0;
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux gibi, Windows gibi, macOS gibi preemptive işletim sistemleri zaman paylaşımlı biçimde çalışmaktadır. İşletim sisteminin
    çekirdeği tarafından oluşturulan ismine "çalışma kuyruğu (run queue)" denilen bir kuyruk sistemi vardır. Çalışan thread'ler 
    bu kuyruk sisteminde tutulmaktadır. İşletim sistemi de kuyrukta sırada bekleyen thread'i CPU'ya atar onu belli bir süre çalıştırıp 
    çalışmasına ara vererek kuyruktaki diğer thread'e geçer. Böylece çalışma kuyruğundaki thread'ler aslında kesikli bir biçimde 
    "biraz çalıştırılıp biraz bekletilerek" çalıştırılmaktadır. Bu biçimdeki çalışma sistemine işletim sistemleri dünyasında 
    "zaman paylaşımlı (time sharing)" çalışma denilmektedir. Zaman paylaşımlı çalışma 1950'li yılların sonlarına doğru işletim 
    sistemlerine sokulmuştur. Günümüzde çok prosesli ve çok thread'li işletim sistemlerinin hemen hepsi bu biçimde çalışmaktadır. 
    Çalışma kuyruğu işletim sistemi tarafından bir "bağlı liste (linked list)" biçiminde oluşturulmaktadır. Bunu görsel biçimde 
    şöyle temsil edebiliriz:

    thread-1 ---> thread-2 ---> thread-3 ---> thread-4 ---> [İlk düğümü gösteriyor (thread-1)]

    Tabii bu kuyruk sistemi döngüseldir. İşletim sistemi de buradan thread'leri alarak onu belli sürelerde çalıştırıp kalınan 
    yeri not alarak diğer thread'e geçmektedir. Kullanıcılar sanki programlarını kesiksiz çalışıyor sanabilirler. Ancak aslında 
    programları parçalı bir biçimde çalıştırılmaktadır. Örneğin:

    for (;;) {
        ...
    }

    Programcılar bu kodun CPU verilip sürekli olarak CPU'nun bu for döngüsünü çalıştırdığını sanabilmektedir. Aslında bu kod
    sürekli çalıştırılmamakta durdurulup kalınan yerden devam ettirilip kesikli kesikli çalıştırılmaktadır.

    İşletim sistemleri terminolojisinde bir thread'in parçalı çalışma süresine "quanta süresi (time quantum)" denilmektedir. 
    Bir thread'in çalışmasına ara verilip durumunun kaydedilmesi ve diğer thread'in kaldığı yerden CPU'ya atanmasına "bağlamsal
    geçiş" ya da İngilizcesiyle "context switch" denilmektedir. Eğer ilgili sistemde quanta süresi çok yüksek tutulursa bu 
    durumda interaktivite azalır. Eğer quanta süresi çok düşük tutulursa bu durumda bağlamsal geçiş (context switch) için harcanan 
    zaman thread'lerin harcadığı zaman oranla büyür, birim zamanda yapılan iş miktarı (throughput) düşer. Linux sistemlerinde 
    thread'e ayrılan quanta süresi thread önceliğine göre, "nice değerine" göre değişebilmektedir. Günümüz bilgisayarlarında 
    ortalama 60 ms gibi bir quanta süresi pek çok genel amaçlı sistem için uygun bir süredir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                93. Ders 08/04/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çok prosesli ve çok thread'li preemptive işletim sistemlerinde en önemli kavramlardan biri de "thread'in bloke olması 
    (blocking)" denilen kavramdır. Bir thread'in bloke olması onun geçici olarak çalışma kuyruğundan (run queue) çıkartılıp 
    "bekleme kuyruğu (wait queue)" denilen bir kuyrukta bekletilmesi anlamına gelmektedir. İşletim sistemi bir thread'i CPU'ya 
    atadığı zaman o thread kendisine ayrılan quanta süresini sonuna kadar kullanmak zorunda değildir. Thread'ler uzun zaman 
    alabilecek dışsal bir olayı beklemeye başladığında işletim sistemi tarafından geçici olarak çalışma kuyruğundan çıkartılıp 
    bekleme kuyruğu denilen bir kuyruk sisteminde bekletilmektedir. İlgili olay gerçekleştiğinde yine işletim sistemi tarafından 
    thread bekleme kuyruğundan çıkartarak yeniden çalışma kuyruğuna yerleştirmektedir. Örneğin bir thread klavyeden (stdin dosyasından) 
    bir okuma yapacak olsun. Bu durumda işletim sistemi thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştirir. 
    Böylece thread olayın gerçekleşmesini CPU zamanı harcamadan pasif bir biçimde bekler. Kullanıcı klavyeden tuşa bastığında 
    işletim sistemi bunu fark eder, bekleme kuyruğundaki thread'i yeniden çalışma kuyruğuna yerleştirir. Burada kullanıcı açısından 
    değişen hiçbir şey olmamaktadır. Kullanıcı klavyeden tuşa bastığında programın devam ettiğini düşünür. Buradaki bütün mesele 
    beklemenin CPU zamanı harcamadan yapılmasıdır. Örneğin işletim sistemlerindeki akışı belli bir süre bekletmek için kullanılan 
    sleep fonksiyonları da blokeye yol açmaktadır. Programın akışı sleep fonksiyonuna girdiğinde işletim sistemi thread'i çalışma 
    kuyruğundan çıkartıp bekleme kuyruğuna alır. sleep ile belirlenen süre dolduğunda da thread'i yeniden bekleme kuyruğundan 
    çıkartıp çalışma kuyruğuna yerleştirir. Yani bekleme pasif bir biçimde CPU zamanı harcanmadan sağlanmaktadır.

    Bir thread kendisine verilen quanta süresini büyük ölçüde kullanıyorsa bu tür thread'lere "CPU yoğun (CPU bound)" thread'ler 
    denilmektedir. Örneğin bir döngü içerisinde hiç IO işlemi yapmadan yalnızca matematiksel hesap yapan bir thread kendisine 
    verilen quanta süresini sonuna kadar kullanacaktır. CPU yoğun thread'ler sistemi yavaşlatma potansiyeline sahiptir. Ancak bir 
    thread kendisine verilen quanta süresinin çok azını kullanıp hemen bloke oluyorsa bu tür thread'lere de "IO yoğun (IO bound)"
    thread'ler denilmektedir. Örneğin:

    for (;;) {
        scanf("%d", val);
        printf("%d\n", val * val);
    }

    Bu for döngüsü IO yoğun bir thread'e ilişkindir. Bu thread çok az CPU zamanı kullanacaktır. Bu biçimde yüzlerce thread'in 
    olması bile sistemi yormayacaktır. Aslında programların büyük çoğunluğu IO yoğun biçimdedir. Bu nedenle sistemi yormamaktadır.

    Peki işletim sisteminde toplamda bir tane mi bekleme kuyruğu vardır? İşte aslında işletim sistemleri her olay için 
    o olaya özgü ayrı bir bekleme kuyruğu oluşturmaktadır. Dolayısıyla sistemde pek çok farklı bekleme kuyrukları vardır. 
    Her kuyruk belli bir olayı bekleyen thread'leri barındırır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çok işlemcili ya da çok çekirdekli sistemlerde zaman paylaşımlı çalışma benzer biçimde yürütülür. Genellikle işletim sistemleri 
    her CPU ya da çekirdek için ayrı bir çalışma kuyruğu oluşturmaktadır. Örneğin sistemimizde 4 çekirdek varsa 4 farklı çalışma 
    kuyruğu vardır. Bizim thread'imiz de bu çalışma kuyruklarının herhangi birinde bulunabilir. Ancak yine o kuyrukta sırası 
    geldiğinde çalışacaktır. Bu durumu bir süpermarkette tek kasa yerine 4 kasanın olduğu duruma benzetebiliriz. Yine müşteri
    bekler ancak kuyruklar tek kasa durumuna göre daha kısa olduğundan daha az beklemiş olur. Tabii süpermarketlerde de şöylesi 
    durumlarla hepimiz karşılaşmışızdır: Biz en az müşterinin olduğu kuyruğa girdiğimiz halde süreç umduğumuz gibi ilerlememiş 
    ve diğer kuyruklar bizimkinden daha hızla işlem görerek kısalmış olabilir. Bu tür durumlarda biz kendi kuyruğumuzu bırakıp 
    diğer kısalmış olan diğer kuyruğa geçmeyi tercih ederiz. İşte aynı durum çok işlemcili ya da çok çekirdekli sistemlerde de 
    benzer biçimdedir. İşletim sistemi bir thread'i bir kuyruğa atadığında diğer kuyruklar azalmışsa onu oradan kopartıp diğer 
    kuyruğa transfer edebilmektedir. İşletim sistemlerinin bu işlemleri yapan alt sistemlerine "çizelgeleyici (scheduler)" 
    denilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bizim aygıt sürücüleri yazan kişiler olarak bekleme kuyrukları ile ilgili şu işlemleri yapabilmemiz gerekir:

    1) Yeni bir bekleme kuyruğunun yaratılması ve yok edilmesi
    2) Çalışma kuyruğundan bekleme kuyruğuna thread'in aktarılması
    3) Bekleme kuyruğundan çalışma kuyruğuna thread'in aktarılması

    Örneğin gömülü sistemimize bir düğme (button) yerleştirmiş olalım. İlgili thread'in de kullanıcı düğmeye basılana kadar
    bekletilmesini sağlamak isteyelim. Burada iki yöntem kullanılabilir. Birinci yönteme "yoklama (polling)" yöntemi denilmektedir. 
    Bu yöntemde biz bir döngü içerisinde sürekli bir biçimde "düğmeye basılmış mı" diye bakarız. Ancak bu iyi bir yöntem değildir. 
    Çünkü CPU yoğun bir biçimde meşgul bir döngüde gereksiz CPU zamanının harcanmasına yol açmaktadır. Özellikle gömülü sistemlerde
    böylesi meşgul döngüler önemli bir güç harcanmasına da yol açmaktadır. İkinci yöntemde biz thread'i bloke ederek çalışma 
    kuyruğundan çıkartıp bekleme kuyruğuna yerleştiririz. Düğmeye basıldığında da bir donanım kesmesinin oluşturulmasını sağlarız. 
    Bu kesme oluştuğunda aygıt sürücümüz kesmeye yanıt verir ve bekleme kuyruğundaki thread'i yeniden çalışma kuyruğuna yerleştirir.
    Bu yönteme "kesme (interrupt) yöntemi" de denilmektedir. Tabii bu yöntemi uygulayabilmemiz için bizim bekleme bekleme kuyruklarıyla 
    işlem yapmayı bilmemiz gerekir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modunda aygıt sürücü kodları daha önce user mode'da gördüğümüz senkronizasyon nesnelerini kullanamaz. Çünkü daha 
    önce gördüğümüz senkronizasyon nesneleri user mode'dan kullanılsın diye oluşturulmuştur. Çekirdeğin içerisinde kernel 
    mode'dan kullanılabilecek ayrı senkronizasyon nesneleri bulunmaktadır. Bu bölümde aygıt sürücülerin kernel mode'da 
    kullanabileceği senkronizasyon nesnelerini göreceğiz.

    Çekirdek modu için user mode'dakine benzer senkronizasyon nesneleri kullanılmaktadır. Bunların genel çalışma biçimi user 
    mode'dakilere benzemektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmak için en çok kullanılan nesnelerden biri "mutex (mutual exclusion)" denilen nesnelerdir. UNIX/Linux 
    sistemlerinde kullanıcı modundan kullanılabilecek mutex nesneleri de vardır. Ancak biz burada çekirdeğin içerisinde bulunan 
    aygıt sürücülerimizde kullanabileceğimiz mutex nesneleri üzerinde duracağız.

    Mutex nesneleri Linux çekirdeğine 2.6 versiyonu ile eklenmiştir. Bundan önce mutex işlemleri binary semaphore'larla yapılıyordu. 
    Çekirdeğin mutex mekanizması kullanıcı modundaki mutex mekanizmasına çok benzemektedir. Çekirdek mutex nesnelerinin yine 
    thread temelinde sahipliği vardır. Çekirdek mutex nesneleri thread'i bloke edip onu bekleme kuyruklarında bekletebilmektedir. 

    Mutex mekanizması şöyle işletilmektedir: Önce bir mutex nesnesi yaratılır. Kritik koda girişte bu mutex nesnesinin sahipliği
    ele geçirilmeye çalışılır. Mutex'in sahipliğinin ele geçirilmesine "mutex'in kilitlenmesi (mutex lock)" de denilmektedir. Eğer 
    mutex'in sahipliği ele geçirilirse (yani mutex kilitlenirse) sahiplik bırakılana kadar (yani kilit bırakılana kadar) başka bir 
    thread kritik koda giremez. Mutex'in sahipliğini almaya çalışan thread mutex kilitli ise bloke olarak mutex kilidi açılana kadar 
    bekler. Mutex'in sahipliğini almış olan thread kritik koddan çıkarken mutex'in sahipliğini bırakır (yani mutex'in kilidini açar). 
    Böylece blokede bekleyen thread'lerden biri mutex'in sahipliğini alarak kritik koda girer. Kritik kod tipik olarak şöyle 
    oluşturulmaktadır:

    mutex_lock(...)
    ...
    ...    KRİTİK KOD
    ...
    mutex_unlock(...)

    Thread'lerden biri mutex_lock fonksiyonuna geldiğinde eğer mutex kilitlenmemişse mutex'i kilitler ve kritik koda giriş yapar. 
    Eğer mutex zaten kilitlenmişse mutex_lock fonksiyonunda thread bloke edilir ve bekleme kuyruğuna alınır. Kritik koda girmiş
    olan thread mutex_unlock fonksiyonu ile mutex nesnesinin kilidini bırakır. Böylece nesneyi bekleyen thread'lerden biri nesnenin 
    sahipliğini alarak mutex'i kilitler. Birden fazla thread'in mutex_lock fonksiyonunda bloke edilmesi durumunda mutex'in kilidi 
    açıldığında bunlardan hangisinin mutex kilidini alarak kritik koda gireceği konusunda bir garanti verilmemektedir. (İlk bloke 
    olan thread'in mutex kilidini alarak kritik koda gireceğini düşünebilirsiniz, ancak bunun bir garantisi yoktur.)

    Çekirdekteki mutex mekanizmasının tipik gerçekleştirimi şöyledir:

    1) mutex_lock işlemi sırasında işlemcinin maliyetsiz compare/set (compare/exchange) komutlarıyla mutex'in kilitli olup olmadığına 
    bakılır.
    2) Diğer bir işlemcideki thread mutex'i kilitlemişse boşuna bloke olmamak için yine compare/set komutlarıyla biraz spin 
    işlemi yapılır. Spin işleminin be olduğu izleyen paragraflarda açıklanacaktır.
    3) Spin işleminden sonuç elde edilemezse bloke oluşturulur.

    Çekirdeğin mutex nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Mutex nesnesi mutex isimli bir yapıyla temsil edilmektedir. Sistem programcısı bu yapı türünden global bir nesne yaratır 
    ve ona ilk değerini verir. DEFINE_MUTEX(name) makrosu hem struct mutex türünden nesneyi tanımlamakta hem de ona ilk değerini 
    vermektedir. Örneğin:

    #include <linux/mutex.h>

    static DEFINE_MUTEX(g_mutex);

    Burada biz hem g_mutex isminde bir global nesne tanımlamış olduk hem de ona ilk değer vermiş olduk. Aynı işlem önce nesneyi 
    tanımlayıp sonra mutex_init fonksiyonunun çağrılmasıyla da yapılabilmektedir. Örneğin:

    static struct mutex g_mutex;
    ...
    mutex_init(&g_mutex);

    DEFINE_MUTEX makrosuna nesnenin adresinin verilmediğine dikkat ediniz. Bu makro ve mutex_init fonksiyonunun prototipleri
    <linux/mutex.h> başlık dosyasında bulunmaktadır.

    Her ne kadar mutex_init bir fonksiyon görünümündeyse de aslında çekirdek kodlarında hem bir makro olarak hem de bir fonksiyon 
    olarak bulunmaktadır. Mevcut Linux çekirdeklerinde fonksiyonların makro gerçekleştirimleri aşağıdaki gibidir:

    #define DEFINE_MUTEX(mutexname)                            \
        struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)

    #define mutex_init(mutex)                \
    do {                            \
        static struct lock_class_key __key;        \
                                \
        __mutex_init((mutex), #mutex, &__key);        \
    } while (0)

    2) Mutex nesnesini kilitlemek için mutex_lock fonksiyonu kullanılır:

    #include <linux/mutex.h>

    void mutex_lock(struct mutex *lock);

    Mutex'in kilitli olup olmadığı ise mutex_trylock fonksiyonuyla kontrol edilebilir:

    #include <linux/mutex.h>

    int mutex_trylock(struct mutex *lock);

    Eğer mutex kilitliyse fonksiyon bloke olmadan 0 değeriyle geri döner. Eğer mutex kilitli değilse mutex kilitlenir ve fonksiyon
    1 değeri ile geri döner.

    Mutex nesnesi mutex_lock ile kilitlenmek istendiğinde bloke oluşursa bu blokeden sinyal yoluyla çıkılamamaktadır. Örneğin mutex_lock 
    ile çekirdek modunda biz mutex kilidini alamadığımızdan dolayı bloke oluştuğunu düşünelim. Bu durumda ilgili prosese bir sinyal 
    gelirse ve eğer o sinyal için sinyal fonksiyonu set edilmişse thread uyandırılıp sinyal fonksiyonu çalıştırılmamaktadır. Ayrıca 
    bu durumda biz ilgili prosese SIGINT gibi SIGKILL gibi sinyaller göndererek de prosesi sonlandıramayız. İşte eğer mutex'in kilitli 
    olması nedeniyle bloke oluştuğunda sinyal yoluyla thread'in uyandırılıp sinyal fonksiyonunun çalıştırması ya da sinyal fonksiyonu 
    set edilmemişse prosesin sonlandırılması isteniyorsa mutex nesnesi mutex_lock ile değil, mutex_lock_interrupible fonksiyonu 
    ile kilitlenmeye çalışılmalıdır. mutex_lock_interruptible fonksiyonunun prototipi şöyledir:

    #include <linux/mutex.h>

    int mutex_lock_interruptible(struct mutex *lock);

    Fonksiyon eğer mutex kilidini alarak sonlanırsa 0 değerine, bloke olup sinyal dolayısıyla sonlanırsa -EINTR değerine geri dönmektedir. 
    Programcı bu fonksiyonun 0 ile geri dönmediğini ya da -EINTR ile geri döndüğünü tespit ettiğinde ilgili sistem fonksiyonunun yeniden 
    çalıştırılabilirliğini sağlamak için -ERESTARTSYS ile geri dönebilir. Örneğin:

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    3) Mutex nesnesinin kilidini bırakmak için (nesneyi unlock etmek için) mutex_unlock fonksiyonu kullanılmaktadır:

    void mutex_unlock(struct mutex *lock);

    Bu durumda örneğin tipik olarak aygıt sürücü içerisinde belli bir bölgeyi mutex yoluyla koruma şöyle yapılmaktadır:

    DEFINE_MUTEX(g_mutex);
    ...

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    ...
    ...    KRİTİK KOD
    ...

    mutex_unlock(&g_mutex);

    Mutex nesnesini kilitledikten sonra fonksiyonlarınızı geri döndürürken kilidi açmayı unutmayınız.

    Aşağıdaki örnekte yukarıdaki boru aygıt sürücüsü daha güvenli olacak biçimde mutex nesneleriyle senkronize edilmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/mutex.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    mutex_unlock(&g_mutex);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    mutex_unlock(&g_mutex);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again...\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                94. Ders 10/04/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çok kullanılan diğer bir senkronizasyon nesnesi de "semaphore" denilen nesnedir. Semaphore'lar sayaçlı senkronizasyon
    nesneleridir. Semaphore'lar ilk kez Edsger Dijkstra tarafından bulunmuştur. Bugün neredeyse tüm işletim sistemlerinde 
    kullanıcı modunda ve çekirdek modunda kullanılmaktadır. UNIX/Linux sistemlerinde de kullanıcı modunda kullanılabilen 
    semaphore nesneleri vardır. Ancak biz burada aygıt sürücülerde de kullanılan çekirdeğin içerisindeki semaphore nesneleri 
    üzerinde duracağız.

    Semaphore'lar bir kritik koda en fazla n tane akışın girmesine olanak sağlamaktadır. Örneğin buradaki n değerinin 3 olduğunu
    düşünelim. Bu durumda birinci thread semaphore'dan geçer ve kritik koda girer. İkinci thread da semaphore'dan geçip geçip 
    kritik koda girer. Şimdi kritik kodda iki thread bulunmaktadır. Üçüncü thread de semaphore'dan geçerek kritik koda girebilir. 
    Şimdi kritik kodda üç thread bulunmaktadır. Artık dördüncü bir thread kritik koda girmek isterse bloke oluşur ve bu thread
    bekleme kuyruklarına alınarak bekletilir. Beşinci thread de benzer biçimde semaphore'dan geçemeyecek ve bloke olacaktır. 
    Şimdi kritik koda girmiş olan thread'lerden birinin kritik koddan çıktığını düşünelim. Şimdi kritik iki thread bulunmaktadır. 
    İşte bloke edilmiş olan thread'lerden biri kritik koda girebilir. Böylece kritik kod içerisinde yine en fazla 3 thread 
    bulunmaktadır. Tıpkı mutex nesnelerinde olduğu gibi bu durumda blokede bekleyen hangi thread'in kritik koda gireceği 
    hakkında bir garanti verilmemektedir. (Yani ilk bloke thread'in kritik koda gireceğinin bir garantisi yoktur.)

    Semaphore'larda N sayısı 1 ise bu durumda kritik koda en fazla tek bir thread girebilir. Böyle semaphore'lara "ikili semaphore'lar
    (binary semaphores)" denilmektedir. İkili semaphore'lar kullanım amacı bakımından mutex nesnelerine oldukçe benzemektedir. 
    (Ancak ikili semaphore'lar mutex nesneleriyle tamamen aynı işlevselliği sunmazlar.)

    Yukarıda da belirttiğimiz gibi bir kritik koda iki akışın bile girmesi paylaşılan kaynağı bozabilir. O halde kritik koda
    N tane akışın girmesinin ne anlamı olabilir? İşte semaphore'lar tipik olarak N tane kaynağı thread'lere paylaştırmak 
    için kullanılmaktadır. Örneğin elimizde 3 tane makine olsun. Bir thread makine istediğinde biz ona bu üç makineden birini 
    veririz. Başka bir thread de makine istediğinde biz ona geri kalan iki makineden birini veririz. Başka bir thread de makine 
    istediğinde biz ona boşta olan tek makineyi veririz. Artık elimizde hiç makine kalmamıştır. Şimdi başka bir thread bizden 
    makine istediğinde biz artık o thread'e elimizde makine kalmadığı için makine veremeyiz. Ancak o thread'in işlemine devam 
    etmesi için makineye gereksinimi vardır. İşte bu durumda o thread'in bir makine boşalana kadar CPU zamanı harcamadan beklemesi 
    gerekir. Semaphore'lar tipik olarak bu biçimde senaryolarda kullanılmaktadır.

    <semaphore girişi>
    ...
    ...    Buradaki kritik kod boştaki bir makineyi gelen thread'e veriyor
    ...
    <semaphore çıkışı>

    Yukarıdaki örnekte makineyi elde eden thread'lerden biri kritik koddan çıktığında artık onun kullandığı makine boşaltılmış 
    olur. Bu durumda bloke olmuş olan bir thread uyanıp kritik koda girer. Artık elimizde boşta bir makine olduğuna göre onu
    gelen thread'e atayabiliriz.

    Semaphore'lar üretici-tüketici problemi (producer-consumer problem) senkronizasyon problemini çözmek için de kullanılmaktadır. 
    Zaten Edsger Dijkstra semaphore nesnelerini üretici-tüketici problemlerinin çözmek amacıyla bulmuştur. Örneğin UNIX/Linux
    sistemlerinde kullanıcı modunda kullanılan "mesaj kuyrukları (message queues)" tipik olarak semaphore nesneleriyle 
    gerçekleştirilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Semaphore nesnelerinini bir sayıcının bulunduğunu belirtmiştik. Bu sayaç bir thread kritik koda girerken kontrol edilir. 
    Eğer sayaç 0'dan büyükse kritik koda giriş izni verilir. Ancak sayaç thread kritik koda girerken 1 eksiltilir. Eğer 
    sayaç 0 değerine düşerse artık semaphore nesnesi kapalı durumda olur. Bu durumda thread semaphore sayacı 0'dan büyük 
    duruma gelene kadar blokede bekletilir. Semaphore'larla kritik kod tipik olarak aşağıdaki gibi oluşturulmaktadır:

    down(...);
    ...
    ... KRİTİK KOD
    ...
    up(...);

    down fonksiyonu semaphore sayacı 0 ise bloke oluşturur, böylece thread kritik koda giremez. up fonksiyonu da semaphore sayacını 
    1 artırmaktadır. Burada semaphore sayacının 3 olduğunu düşünelim. Bir thread down fonksiyonuna geldiğinde down fonksiyonu 
    semaphore sayacı 0'dan büyük olduğu için bloke oluşturmaz ancak semaphore sayacını 1 eksiltir. Şimdi semaphore sayacı 2'dir. 
    Bir thread daha kritik koda girmek istediğinde semaphore sayacı 1'e düşecektir. Şimdi kritik kodda iki thread bulunacaktır.
    Bir thread daha kritik koda girmek istediğinde semaphore sayacı 0 olur ve artık kritik kodda üç thread bulunmaktadır. 
    Artık yeni bir thread down fonksiyonuna geldiğinde semaphore sayacı 0 olduğu için blokede bekleyecektir. Kritik koddaki 
    bir thread kritik koddan çıkarken up fonksiyonunu çağırır. Bu fonksiyon da semaphore 1 artırır. Şimdi semaphore sayacı 
    yeniden 1 olmuştur. Artık blokede bekleyen bir thread kritik koda girebilir. Tabii bu thread kritik koda girdiğinde semaphore
    sayacı yeniden 0 olacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek semaphore nesnelerini şöyle kullanılmaktadır:

    1) Semaphore nesnesi struct semaphore isimli bir yapıyla temsil edilmiştir. Bir semaphore nesnesi DEFINE_SEMAPHORE(name) 
    makrosuyla aşağıdaki gibi oluşturulabilir.

    #include <linux/semaphore.h>

    static DEFINE_SEMAPHORE(g_sem);

    Bu biçimde yaratılan semaphore nesnesinin başlangıçta sayaç değeri 1'dir. Yeni çekirdeklerde (v6.4-rc1 ve sonrası) bu makro iki 
    parametreli olarak da kullanılabilmektedir:

    static DEFINE_SEMAPHORE(g_sem);

    Buradaki ikinci parametre semaphore sayacının başlangıçtaki değerini belirtmektedir.

    Semaphore nesneleri sema_init fonksiyonuyla da yaratılabilmektedir:

    static struct semaphore g_sem;
    ...
    sema_init(&g_sem, 1);

    Fonksiyonun ikinci parametresi başlangıç sayaç numarasıdır.

    2) Kritik kod "down" ve "up" fonksiyonları arasına alınır. "down" fonksiyonları sayacı bir eksilterek kritik koda giriş yapar. 
    "up" fonksiyonu ise sayacı bir artırmaktadır. Fonksiyonların prototipleri şöyledir:

    #define <linux/semaphore.h>

    void down(struct semaphore *sem);
    int down_interruptible(struct semaphore *sem);
    int down_killable(struct semaphore *sem);
    int down_trylock(struct semaphore *sem);
    int down_timeout(struct semaphore *sem, long jiffies);
    void up(struct semaphore *sem);

    Kritik kod "down" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılamamaktadır. Ancak kritik kod 
    "down_interruptible" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılabilmektedir. down_killable
    bloke olmuş thread'in yalnızca SIGKILL sinyalini kabul edip sonlandırılabilmesini sağlamaktadır. down_killable fonksiyonunda 
    eğer thread bloke olursa diğer sinyaller yine blokeyi sonlandıramamaktadır. down_trylock yine nesnenin açık olup olmadığına 
    bakmak için kullanılır. Eğer nesne açıksa yine sayaç 1 eksiltilir ve kritik koda girilir. Bu durumda fonksiyon 0 dışı bir 
    değerle geri döner. Nesne kapalıysa (yani semaphore sayacı 0 ise) fonksiyon bloke olmadan 0 değerine geri döner. down_timeout 
    ise en kötü olasılıkla belli miktar "jiffy" zamanı kadar blokeye yol açmaktadır. ("jiffy" kavramı ileride ele alınacaktır.) 
    Fonksiyon zaman aşımı dolduğundan dolayı sonlanmışsa negatif hata koduna, normal bir biçimde sonlanmışsa 0 değerine geri 
    dönmektedir. down_interruptible fonksiyonu normal sonlanmada 0 değerine, sinyal yoluyla sonlanmada -ERESTARTSYS değeri ile 
    geri döner. Normal uygulama eğer bu fonksiyonlar -ERESTARTSYS ile geri dönerse aygıt sürücüdeki fonksiyonun da aynı değerle 
    geri döndürülmesidir. Zaten çekirdek bu -ERESTARTSYS geri dönüş değerini aldığında asıl sistem fonksiyonunu eğer sinyal için 
    otomatik restart mekanizması aktif değilse -EINTR değeri ile geri döndürmektedir. Bu da tabii POSIX fonksiyonlarının başarısız 
    olup errno değerini EINTR biçiminde set edilmesine yol açmaktadır. up fonksiyonu yukarıda da belirttiğimiz gibi semaphore 
    sayacını 1 artırmaktadır.

    Kernel semaphore nesneleriyle kritik kod aşağıdaki gibi oluşturulmaktadır:

    DEFINE_SEMAPHORE(g_sem, 3);
    ...

    down_interruptible(&g_sem);
    ...
    ... <KRİTİK KOD>
    ...
    up(&g_sem);

    Yukarıdaki boru örneğinde biz mutex nesnesi yerine binary semaphore nesnesi de kullanabilirdik. Aşağıda aynı örneğin 
    binary semaphore ile gerçekleştirimi görülmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SEMAPHORE(g_sem);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    up(&g_sem);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again...\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek kodlarında ve aygıt sürücülerde çok kullanılan diğer bir senkronizasyon nesnesi de "spinlock" denilen nesnelerdir. 
    Buradaki "spin" sözcüğü "meşgul bir döngü oluşturarak kontrol etmek" anlamına gelmektedir. Spinlock mekanizması oldukça 
    basittir. Kritik koda girerken eğer spinlock açık ise giriş gerçekleşir. Ancak spinlock kilitli ise bloke oluşmaz bir döngü
    içerisinde kilit açılana kadar sürekli kilit kontrol edilir. Biz kritik kod kilidinin bu biçimde kontrol edilmesinin sürekli 
    CPU'yu meşgul ettiğinden dolayı uygun olmadığını belirtmiştik. Ancak bazı durumlarda aslında bloke olmadan sürekli döngü 
    içerisinde kontrol etme daha verimli sonuçlara yol açabilmektedir.

    Eğer kritik kod kısa ise bu durumda kritik koda girmek isteyen thread'in bloke olup bekleme kuyruğuna alınması yerine 
    meşgul bir döngüde biraz beklemesi daha etkin bir çözüm oluşturmaktadır. Çünkü kritik kod kısa olduğuna göre zaten bekleyen 
    thread çok fazla spin yapmadan kritik koda girebilecektir. Tabii kritik koda girmiş olan thread'in kritik kod içerisinde 
    bloke olmaması gerekir. Eğer kritik koda girmiş olan thread kritik kod içerisinde bloke olursa bu durumda kritik koda 
    girmek isteyen thread'ler tüm quanta sürelerini spin yaparak geçirirler. Bu da çok verimsiz durum oluşturur. Spinlock 
    nesneleri özellikle çok işlemcili ya da çekirdekli sistemlerde fayda sağlamaktadır. Çünkü işlemcilerin ya da çekirdeklerin
    birinde çalışan bir thread kritik koda girdiğinde başka bir işlemcide ya da çekirdekte çalışan thread spin yaparak diğerinin
    kritik koddan çıkmasını beklemektedir. Tek bir işlemcili ya da çekirdekli sistemlerde spinlock kullanımının bir anlamı yoktur.

    Peki bir thread spinlock'tan geçerek kritik koda girdiğinde o sırada quanta süresi bittiği için bağlamsal geçiş oluşursa
    ne olur? Thread bir sonraki quanta süresine kadar artık CPU'ya atanmayacaktır. Bu durumda spinlock kilitli kalacaktır. 
    Başka bir thread kritik koda girmek istediğinde tüm quanta süresini spin ile geçirecektir. Bu da sistemin etkinliğini 
    düşürecektir. İşte bunun için spinlock fonksiyonları kritik koda girişte kesme mekanizmasını kapatarak kritik kodda 
    çıkılana kadar bağlamsal geçişin oluşmasını engelleyebilmektedir. Yani spinlock'tan geçerek kritik koda giren thread'ler 
    kritik koddan çıkana kadar hiç kesilmemektedir.

    İşletim sistemi kodları ve aygıt sürücü kodları genel yazılmaktadır. Yani örneğin işletim sistemleri ve aygıt sürücüler 100 
    işlemcili ya da çekirdekli sistemde de 1 işlemcili ya da çekirdekli sistemde de çalışacak biçimde yazılırlar. Peki spinlock 
    kullanıldığında eğer sistemimizde bir işlemci ya da çekirdek varsa bu durum bir olumsuzluğa yol açar mı? Bunun yanıtı hayır'dır.
    Tek işlemcili ya da çekirdekli sistemlerde bir thread kritik koda girdiğinde zaten çıkana kadar CPU bağlamsal geçişe kapatılır.
    Böylece kritik kod içerisinde bloke de oluşmayacağı için sistem sanki spinlock yokmuş gibi çalışacaktır.

    Burada bir kez daha spinlock kullanımı için dikkat edilmesi gereken durumları belirtmek istiyoruz:

    - Spinlock ile kritik koda giren thread spinlock kilidini uzun süre kapalı tutmamalıdır. Yani spinlock kısa kodlar için 
    uygulanmalıdır
    - Spinlock ile kritik koda giren thread bloke olmamalıdır.
    - Spinlock ile kritik koda giren thread CPU'yu IRQ'lara açma konusunda dikkatli olmalıdır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdekteki spinlock nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Spinlock nesnesi spinlock_t türü ile temsil edilmektedir. Spinlock nesnesini aşağıdaki gibi tanımlayabilirsiniz:

    static spinlock_t g_spinlock;

    inux'un 2.6.9 çekirdeği ile birlikte spinlock nesnesini tanımlayıp ona ilkdeğer vermek için DEFINE_SPINLOCK makrosu da 
    çekirdeğe eklenmiştir. Bu makro kullanılarak spinlock nesnesi açık bir biçimde şöyle oluşturulabilir:

    #include <linux/spinlock.h>

    static DEFINE_SPINLOCK(g_spinlock);

    spinlock_t nesnesine ilkdeğer verme işlemi spin_lock_init fonksiyonuyla da yapılabilmektedir. spin_lock_init fonksiyonu 
    spinlock_t nesnesine açık olacak biçimde (unlocked) ilkdeğerlerini vermektedir:

    #include <linux/spinlock.h>

    void spin_lock_init(spinlock_t *lock);

    Örneğin:

    spinlock_init(&g_spinlock);S

    2) Kritik koda giriş için aşağıdaki fonksiyonlar kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_lock(spinlock_t *lock);
    void spin_lock_irq(spinlock_t *lock);
    void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
    void spin_lock_bh(spinlock_t *lock);

    spin_lock fonksiyonu klasik spin yapan fonksiyondur. spin_lock_irq fonksiyonu o anda çalışılan işlemci ya da çekirdekteki 
    IRQ'ları (yani donanım kesmelerini) kapatarak kilidi almaktadır. Yani biz bu fonksiyonla kilidi almışsak kilidi bırakana 
    kadar donanım kesmeleri oluşmayacaktır. spin_lock_irqsave fonksiyonu kritik koda girerken donanım kesmelerini kapatmakla 
    birlikte önceki bir durumu geri yükleme yeteneğine sahiptir. Aslında bu fonksiyonların bazıları makro olarak yazılmıştır. 
    Örneğin spin_lock_irqsave aslında bir makrodur. Biz bu fonksiyonun ikinci parametresine nesne adresini geçmemiş olsak da 
    bu bir makro olduğu için aslında ikinci parametrede verdiğimiz nesnenin içerisine IRQ durumları yazılmaktadır. spin_lock_bh
    fonksiyonu yalnızca yazılım kesmelerini kapatmaktadır.

    3) Kilidin geri bırakılması için spin_unlock fonksiyonları kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_unlock(spinlock_t *lock);
    void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
    void spin_unlock_irq(spinlock_t *lock);
    void spin_unlock_bh(spinlock_t *lock);

    Yukarıdaki lock fonksiyonlarının hepsinin bir unlock karşılığının olduğunu görüyorsunuz. Biz kilidi hangi lock fonksiyonu 
    ile almışsa o unlock fonksiyonu ile bırakmalıyız. Örneğin:

    spin_lock(&g_spinlock);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock(&g_spinlock);

    Ya da örneğin:

    ...
    unsigned long irqstate;
    ...

    spin_lock_irqsave(&g_spinlock, irqstate);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock_irqrestore(&g_spinlock, irqstate);

    Yine kernel spinlock nesnelerinde de try'lı lock fonksiyonları bulunmaktadır:

    #include <linux/spinlock.h>

    int spin_trylock(spinlock_t *lock);
    int spin_trylock_bh(spinlock_t *lock);

    Bu fonksiyonlar eğer spinlock kilitliyse spin yapmazlar ve 0 ile geri dönerler. Eğer kilidi alırlarsa sıfır dışı bir değerle
    geri dönerler.

    Her ne kadar yukarıdaki boru sürücüsündeki read ve write fonksiyonlarında kuyruğu korumak için spinlock kullanımı uygun değilse 
    de biz yine kullanım biçimini göstermek için aşağıdaki örneği veriyoruz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/spinlock.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SPINLOCK(g_spinlock);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    spin_unlock(&g_spinlock);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    spin_unlock(&g_spinlock);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again...\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                95. Ders 15/04/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Diğer çok kullanılan bir senkronizasyon nesnesi de "okuma yazma kilitleri (readers-writer locks)" denilen nesnelerdir. 
    Önce bu nesnelere neden gereksinim duyulduğunu bir örnekle açıklamak istiyoruz. Aygıt sürücümüzde paylaşılan bir kaynak 
    bulunuyor olsun. Örneğin bunun global bir liste (linked lists) olduğunu düşünelim. Bu bağlı listeye bir grup thread eleman
    (node) ekliyor olsun, bir grup thread de bu bağlı listeyi dolaşarak eleman arıyor olsun. Tabii burada thread demekle aslında
    aygıt sürücümüzdeki fonksiyonu çağıran kullanıcı modundaki herhangi bir prosesin herhangi bir thread'ini kastediyoruz. Burada
    bağlı listede arama yapmak "okuma (read)" işlemi gibi düşünülebilir. Çünkü bu işlem paylaşılan kaynakta (burada bağlı liste)
    bir durum değişikliğine yol açmadığı için farklı thread'lerden aynı anda yürütülebilir. Ancak bağlı listeye eleman ekleyen 
    thread bu işlem sırasında bağlı listenin düğümlerini değiştirdiği için tam o sırada başka bir thread de ekleme yaparsa ya 
    da arama yaparsa bir çökme oluşturabilir. Burada bağlı listeye eleman eklemek bir yazma (write) işlemi olarak düşünülebilir. 
    O halde bizim öyle bir kritik kod oluşturmamız gerekir ki birden fazla okuma yapan thread bu kritik koda girebilsin ancak 
    bir thread okuma yaparken yazma yapan bir thread kritik koda girmeden okuma yapan thread çıkana kadar beklesin. Benzer biçimde
    eğer yazma yapan bir thread kritik koda girmişse bu işlem bitene kadar okuma yapan bir thread de yazma yazma yapan bir thread 
    de kritik koda giremez. Aşağıda Thread-1 kritik koda girmişse Thread-2'nin durumu açıklanmaktadır:

    Thread-1            Thread-2        Bloke Oluşmalı Mı?
    -------------------------------------------------------
    Okuma               Okuma           Hayır
    Okuma               Yazma           Evet
    Yazma               Okuma           Evet
    Yazma               Yazma           Evet

    Görüldüğü gibi bu mekanizma yalnızca eş zamanlı okumalara izin vermektedir.

    Bu mekanizma tek başına mutex ya da semaphore nesneleriyle sağlanamaz. Aşağıdaki temsili koda (pseudo code) dikkat 
    ediniz:

    static DEFINE_MUTEX(g_mutex);

    read()
    {
        mutex_lock(&g_mutex);
        <okuma işlemi yapılıyor>
        mutex_unlock(&g_mutex);
    }

    write()
    {
        mutex_lock(&g_mutex);
        <yazma işlemi yapılıyor>
        mutex_unlock(&g_mutex);
    }

    Burada birden fazla okuma işlemi de blokeye yol açacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Okuma yazma kilitleri Linux'ta spinlock oluşturarak çalışmaktadır. Bu nedenle bu nesnelere Linux'ta "spinlock'lu okuma yazma
    kilitleri" reader/writer spinlock de denilmektedir.

    Spinlock'lu okuma yazma kilitleri rwlock_t türüyle temsil edilmektedir. Bu nesnelerin tanımlanması yine iki biçimde yapılabilmektedir. 
    Birinci biçimde DEFINE_RWLOCK(x) makrosu kullanılır. Örneğin:

    #include <linux/rwlock.h>

    static DEFINE_RWLOCK(g_rwlock);

    Bu makro eski çekirdeklerde bulunmamaktadır. Dolayısıyla kullanırken hata oluşursa diğer yöntemi deneyebilirsiniz. Spinlock'lu 
    okuma yazma kilit nesneleri global düzeyde tanımlanıp bunlara rwlock_init fonksiyonuyla da ilkdeğer verilebillmektedir.

    #include <linux/rwlock.h>

    void rwlock_init(rwlock_t *lock);

    Spinlock'lu okuma yazma kilitleri ile kritik kod oluşturmak için aşağıdaki fonksiyonlar kullanılmaktadır:

    #include <linux/rwlock.h>

    void read_lock(rwlock_t *lock);
    void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void read_lock_irq(rwlock_t *lock);
    void read_lock_bh(rwlock_t *lock);

    void read_unlock(rwlock_t *lock);
    void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void read_unlock_irq(rwlock_t *lock);
    void read_unlock_bh(rwlock_t *lock);

    void write_lock(rwlock_t *lock);
    void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void write_lock_irq(rwlock_t *lock);
    void write_lock_bh(rwlock_t *lock);
    int write_trylock(rwlock_t *lock);

    void write_unlock(rwlock_t *lock);
    void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void write_unlock_irq(rwlock_t *lock);
    void write_unlock_bh(rwlock_t *lock);

    Nesne read amaçlı lock edilmişse read amaçlı unlock işlemi, write amaçlı lock edilmişse write amaçlı unlock işlemi 
    uygulanmalıdır. Fonksiyonların diğer işlevleri normal spinlock nesnelerinde olduğu gibidir.

    Örneğin biz bu fonksiyonlarla okuma yazma işlemlerini aşağıdaki gibi senkronize edebiliriz:

     static DEFINE_RWLOCK(g_rwlock);

    read()
    {
        read_lock(&g_rwlock);
        <okuma işlemi yapılıyor>
        read_unlock(&g_rwlock);
    }

    write()
    {
        write_lock(&g_rwlock);
        <yazma işlemi yapılıyor>
        write_unlock(&g_rwlock);
    }

    Burada artık okuma yapmak isteyen thread read fonksiyonunu çağırdığında read_lock fonksiyonu ile spinlock kilidi alınır, 
    başka bir thread bu kilidi write_lock ile alamaz ve spin yapmaya başlar. Ancak başka bir thread kilidi yine read_lock 
    ile alabilir. Eğer bir thread kilidi write_lock ile almışsa başka bir thread kilidi read_lock ile de write_lock ile de 
    alamaz ve spin yaparak bekler.

    read_lock ve write_lock fonksiyonlarının irq sonekli versiyonları yine akış kritik kodda girdiğinde ilgili CPU ya da 
    çekirdeğin yerel kesmelerini kapatmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çok işlemcili ya da çok çekirdekli sistemlerde RAM ortak bir biçimde kullanılmaktadır. Bu konuda yaygın iki mimari bulunmaktadır. 
    Bunlardan birine SMP (Symmetric Multiprocessors), diğerine ise NUMA (Non-Uniform Memory Access) denilmektedir. Masaüstü ve 
    taşınabilir bilgisayarlarımızda hemen her zaman SMP mimarisini kullanan çok çekirdekli işlemciler bulunmaktadır. NUMA mimarisi 
    daha çok güçlü sunucularda ve iş istasyonlarında tercih edilmektedir. SMP mimarisinde bir işlemci ya da çekirdek RAM'e erişirken 
    diğerlerini durdurmaktadır. Böylece belli bir anda tek bir işlemci ya da çekirdek RAM'e erişmekte ve bus çakışması bu yolla 
    ortadan kaldırılmaktadır. Ancak bu sistem Intel gibi bazı işlemcilerde bazı özel durumlarda yetersiz kalabilmektedir. Örneğin 
    Intel işlemcileri özellikle hizalanmamış adreslerden bilgi çekerken ya da hizalanmamış adreslere bilgi yazarken bus'ı tüm 
    işlem boyunca tutmamaktadır. Hizalanmamış verileri bellekten okurken işlemci (ya da işlemcideki bir çekirdek) verinin bir 
    kısmını okuyup bus'ı bırakıp sonra diğer kısmını okuyabilmektedir. Aynı durum yazma sırasında da yapılmaktadır. İşte tam 
    bu sırada büyük bir tesadüfle diğer işlemci ya da çekirdek de aynı bellek bölgesinden okuma yazma yapıyorsa oradaki bilgi 
    yanlış okunabilmekte ya da oraya yanlış bilgi yazılabilmektedir. Bunu engellemek için Intel LOCK isimli bir önek makine 
    komutu oluşturmuştur. Belleğe erişirken bu LOCK öneki kullanıldığında tüm işlem bitene kadar bus tutulmaktadır. Örneğin 
    iki farklı işlemci ya da çekirdekteki kod aynı global değişkene tesadüfen aynı anda atama yapıyor olsun:

    Çekirdek-1             Çekirdek-2
    ...                    ...
    g_x = 1000;            g_x = 2000;
    ...                    ...

    Burada g_x hizalanmamışsa çok düşük bir olasılıkla g_x'in içerisinde 10000 de 20000 de yerleştirilmemiş olabilir. Bu da 
    tüm programın yanlış çalışmasına yol açacaktır. Tabii aynı sorun bir işlemci ya da çekirdeğin bir değişkene bir şey yazarken 
    tesadüfen aynı anda diğerinin okuması durumunda da oluşmaktadır. Tabii eğer bu işlemler için derleyici aşağıdaki makine 
    komutları üretseydi bir sorun olmayacaktır:

    Çekirdek-1             Çekirdek-2
    ...                    ...
    LOCK MOV g_x, 1000     LOCK MOV g_x, 2000
    ...                    ...

    Ancak derleyiciler yavaşlatacağı gerekçesiyle bu biçimde kod üretmemektedir. Peki bu durumda ne yapılabilir? İlk akla 
    gelen bu tür erişimleri kritik kod oluşturarak muhtemelen spinlock nesneleriyle yapmaktır. Ancak onun da maliyeti vardır. 
    İşte kullanıcı modunda olduğu gibi aygıt sürücülerde de basit atama, artırma, eksiltme gibi işlemlerin atomic yapılmasını 
    sağlayan özel fonksiyonlar vardır. Bu fonksiyonların hepsi nesneyi atomic_t türü biçiminde istemektedir. atomic_t türü 
    içerisinde yalnızca int bir nesne olan bir yapı türüdür. Bu yapı nesnesinin içerisindeki değeri alan atomic_read isimli 
    inline bir fonksiyon da vardır. Atomic inline fonksiyonların bazıları şunlardır:

    #include <asm/atomic.h>

    int atomic_read(const atomic_t *v);
    void atomic_set(atomic_t *v, int i);
    void atomic_add(int i, atomic_t *v);
    void atomic_sub(int i, atomic_t *v);
    void atomic_inc(atomic_t *v);
    void atomic_dec(atomic_t *v)
    ...

    Bu fonksiyonların hepsinin atomic_t türünden nesnenin adresini alan bir parametresi vardır. atomic_set fonksiyonunun ikinci 
    parametresi set edilecek değeri almaktadır.

    Yukarıda da belirttiğimiz gibi atomic_t türü aslında int bir elemana sahip bir yapı biçimindedir. atomic_t türünden 
    bir değişkene ilkdeğer vermek için ATOMIC_INIT makrosu da kullanılabilir. Örneğin:

    atomic_t g_count = ATOMIC_INIT(0);

    Yukarıda da belirttiğimiz gibi atomic_t nesnesi içerisindeki değeri atomic_read makrosuyla elde edebiliriz. Örneğin:

    val = atomic_read(&g_count);

    Peki mademki atomic_t türü içerisinde bir int değerin bulunduğu bir yapı belirtiyor bu durumda neden doğrudan int nesne
    kullanılmıyor da içerisinde iny bir eleman olan yapı kullanılıyor? İşte bunun amacı bu atomik nesnenin ++, -- += gibi 
    operatörlerle kullanımı konusunda cesareti kırmaktır.

    Bit işlemlerine yönelik atomik işlemler de yapılabilmektedir:

    void set_bit(nr, void *addr);
    void clear_bit(nr, void *addr);
    void change_bit(nr, void *addr);
    test_bit(nr, void *addr);
    int test_and_set_bit(nr, void *addr);
    int test_and_clear_bit(nr, void *addr);
    int test_and_change_bit(nr, void *addr);

    RISC işlemcilerinde aritmetik işlem yapan, karşılaştırma ve bit işlemleri yapan makine komutları bellek ile çalışmamaktadır. 
    Bu işlemcilerdeki bu tarz komutlar hep yazmaç üzerinden çalışmaktadır. Dolayısıyla da bu işlemlemcilerde bu işlemler 
    tek bir makine komutuyla yapılamamaktadır. İşte yukarıdaki inline fonksiyonlar bu işlemcilerde daha özel olarak yazılmıştır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                96. Ders 17/04/2025 - Persembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz kullanıcı modunda çeşitli fonksiyonların çeşitli koşullar altında blokeye yol açtığını belirtmiştik. Bir thread bloke 
    olduğunda thread belli bir koşul sağlanana kadar ilgili CPU'nun "çalışma kuyruğundan (run queue)" çıkartılır, ismine 
    "bekleme kuyruğu (wait queue)" denilen bir kuyruğa yerleştirilir. Blokeye yol açan koşul ortadan kalktığında ise thread 
    yeniden bekleme kuyruğundan alınarak ilgili CPU'nun çalışma kuyruğuna yerleştirilir.

    Aygıt sürücülerde blokeyi aygıt sürücünün kendisi oluşturmaktadır. Örneğin biz boru aygıt sürücümüzde read işlemi yapıldığında 
    eğer boruda okunacak hiç bilgi yoksa read işlemini yapan kullanıcı modundaki thread'i bloke edebiliriz. Boruya bilgi geldiğinde 
    de thread'i yeniden çalışma kuyruğuna yerleştirip blokeyi çözebiliriz. İşte bu bölümde aygıt sürücüde thread'lerin nasıl 
    bloke edileceği ve blokenin nasıl çözüleceği üzerinde duracağız.

    Daha önceden de belirttiğimiz gibi mevcut Linux sistemlerinde her CPU ya da çekirdeğin ayrı bir "çalışma kuyruğu (run queue)" 
    bulunmaktadır. Ancak bir ara O(1) çizelgelemesi ismiyle Linux'ta bu konuda bir değişikliğe gidilmişti ((2.6.0 ile 2.6.22
    arasındaki çekirdekler)O(1) çizelgelemesi tekniğinde toplam tek bir çalışma kuyruğu bulunuyordu. Hangi CPU ya da çekirdeğe 
    atama yapılacaksa bu tek olan çalışma kuyruğundan thread alınıyordu. O(1) çizelgelemesi Linux'ta kısa bir süre kullanılmıştır. 
    Bunun yerine "CFS (Completely Fair Scheduling)" çizelgeleme sistemine geçilmiştir. Bugün ağırlıklı olarak CFS çizelgeleme 
    algoritmasının iyileştirilmiş biçimleri kullanılmaktadır.

    Daha önceden de belirttiğimiz gibi Çalışmakta olan bir thread'in bloke olması sırasında thread'in yerleştirileceği tek bir 
    "bekleme kuyruğu (wait queue)" yoktur. Her CPU ya da çekirdek için de ayrı bir bekleme kuyruğu bulundurulmamaktadır. Bekleme 
    kuyrukları ilgili olay temelinde oluşturulmaktadır. Örneğin sleep fonksiyonu dolayısıyla bloke olan thread'ler ayrı bir bekleme 
    kuyruğuna, boru dolayısıyla bloke olan thread'ler ayrı bir bekleme kuyruğuna yerleştirilmektedir. Aygıt sürücüleri yazanlar 
    da kendi olayları için kendi bekleme kuyruklarını yaratırlar. Tabii çekirdekteki mutex ve semaphore fonksiyonları da aslında 
    kendi içerisinde bir bekleme kuyruğu kullanmaktadır. Çünkü bu fonksiyonlar da blokeye yol açmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi her aygıt sürücü kendi bloke olayları için kendinin kullanacağı bekleme kuyrukları 
    yaratabilmektedir. Çekirdek içerisinde bekleme kuyruklarını yaratan ve yok eden çekirdek fonksiyonları bulunmaktadır. Yine 
    çekirdek içerisinde bir thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştiren, bekleme kuyruğundan çıkartıp 
    çalışma kuyruğuna yerleştiren fonksiyonlar bulunmaktadır.

    Linux'ta bekleme kuyrukları wait_queue_head_t isimli bir yapıyla temsil edilmektedir. Bir bekleme kuyruğu DECLARE_WAIT_QUEUE_HEAD(name) 
    makrosuyla oluşturulabilir. Örneğin:

    #include <linux/wait.h>

    static DECLARE_WAIT_QUEUE_HEAD(g_wq);

    Bu makro hem wait_queue_head_t nesnesini tanımlayıp hem de ona küme parantezleriyle ilkdeğerlerini vermektedir. Alternatif 
    olarak önce nesne tanımlanıp sonra init_waitqueue_head fonksiyonuyla da ilk değer verilebilir. Bu fonksiyon aslında bir 
    makro biçiminde yazılmıştır. Örneğin:

    #include <linux/wait.h>

    static wait_queue_head_t g_wq;
    ...
    init_waitqueue_head(&g_wq);

    Bir thread'i (yani task_struct nesnesini) çalışma kuyruğundan çıkartıp istenilen bekleme kuyruğuna yerleştirme işlemi wait_event 
    makrolarıyla gerçekleştirilmektedir. Temel wait_event makroları şunlardır:

    wait_event(wq_head, condition);
    wait_event_interruptible(wq_head, condition);
    wait_event_killable(wq_head, condition);
    wait_event_timeout(wq_head, condition, timeout);
    wait_event_interruptible_timeout(wq_head, condition, timeout);
    wait_event_interruptible_exclusive(wq_head, condition);

    wait_event makrosu thread'i "uninterruptible" biçimde bekleme kuyruğuna yerleştirir. Bu biçimde bloke olmuş thread'lerin
    blokeleri sinyal dolayısıyla çözülememektedir. wait_event_interruptible makrosu ise aynı işlemi "interruptible" olarak 
    yapmaktadır. Yani sinyal geldiğinde thread bekleme kuyruğundan uyandırılır. wait_event_killable makrosu yalnızca SIGKILL 
    sinyali için thread'i uyandırmaktadır. Yani bu biçimde bekleme kuyruğuna yerleştirilmiş bir thread'in blokesi sinyal geldiğinde 
    çözülmez, ancak SIGKILL sinyali ile thread yok edilebilir. wait_event_timeout ve wait_event_interruptible_timeout makrolarının 
    wait_event makrolarından farkı thread'i en kötü olasılıkla belli bir jiffy zaman aşımı ile uyandırabilmesidir. Jiffy kavramı 
    izleyen bölümlerde ele alınacaktır. Makrolardaki ilk parametre bekleme kuyruğunu belirtmektedir. Bu parametreye argüman hiç 
    adresi alınmadan geçirilmelidir.

    Makrolardaki "condition (koşul)" parametresi bool bir ifade biçiminde oluşturulmalıdır. Bu ifade ya sıfır olur ya da sıfır 
    dışı bir değer olur. Bu koşul ifadesi "uyanık kalmak için bir koşul" belirtmektedir. Yani bu koşul uyandırma koşulu değildir, 
    uyanık kalma koşuludur. Çünkü bu makrolarda koşula bakılması uyumadan önce ve uyandırılma işleminden sonra yapılmaktadır. 
    Yani önce koşula bakılır. Koşul sağlanmıyorsa thread uyutulur. Thread uyandırıldığında yeniden koşula bakılır. Koşul sağlanmıyorsa 
    yeniden uyutulur. Dolayısıyla uyanma işlemi çekirdek kodlarında tıpkı koşul değişkenlerinde (condition variable) olduğu gibi 
    döngü içerisinde yapılmaktadır. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    wait_event(g_wq, g_flag != 0);

    Burada koşul g_flag != 0 biçimindedir. wait_event makroları fonksiyon değil makro biçiminde yazıldığı için bu koşul bu haliyle 
    makronun içinde kullanılmaktadır. (Yani koşul ifadesinin sonucu değil, kendisi makroda kullanılmaktadır.) Makronun içerisinde 
    önce koşula bakılmakta, bu koşul sağlanıyorsa thread zaten uyutulmamaktadır. Eğer koşul sağlanmıyorsa thread uyutulmaktadır. 
    Thread uykudan uyandırıldığında tıpkı koşul değişkenlerinde olduğu gibi yeniden koşula bakılmakta eğer koşul sağlanmıyorsa 
    thread yeniden uyutulmaktadır. wait_event makrosunun geri döndürdüğü bir değer yoktur. wait_event makrosu şöyle çalışmaktadır:

    1) Makro önce koşula bakar, koşul zaten sağlanıyorsa hemen işlemini sonlandırır.
    2) Eğer koşul sağlanmıyorsa thread çalışma kuyruğundan çıkartılıp bekleme kuyruğuna yerleştirilir.
    3) Thread uyandırıldığında aslında çalışma yine wait_event makrosunun içerisinden devam edecektir. Bu noktada makro yeniden 
    koşula bakar, koşulu sağlamayan thread'leri yeniden uyutur.

    Burada en çok tereddüt edilen nokta koşulun ne işe yaradığıdır. wake_up makroları izleyen paragraflarda da göreceğimiz gibi 
    yalnızca koşulu sağlayan thread'leri uyandıramamaktadır. Böyle bir mekanizmanın etkin bir biçimde oluşturulması da mümkün 
    değildir. Bu nedenle wake_up makroları koşula bakmaksızın bekleme kuyruğundaki birden fazla thread'i uyandırır. Uyanan 
    thread'lerin kendileri koşula bakmaktadır.

    wait_event_interruptible makrosunun wait_event makrosundan farkı eğer thread uyutulmuşsa uykudan bir sinyalle uyandırılabilmesidir. 
    Halbuki wait_event ile uykuya dalmış olan thread sinyal oluşsa bile uykudan uyandırılmamaktadır. wait_event_killable ile thread 
    uykuya dalındığında ise yalnızca SIGKILL sinyali ile thread uykudan uyandırılabilmektedir. Tabii programcı wait_event_interruptible
    makrosunun geri dönüş değerine bakmalı, eğer thread sinyal dolayısıyla uykudan uyandırılmışsa -ERESTARTSYS değeriyle kendi 
    fonksiyonundan geri dönmelidir. wait_event_interruptible makrosu eğer sinyal dolayısıyla uyanmışsa -ERESTARTSYS değeri ile, 
    koşul sağlandığından dolayı uyanmışsa 0 değeri ile geri dönmektedir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    if (wait_event_interruptible(g_wq, g_flag != 0) != 0)
        return -ERESTARTSYS;

    Bu tür durumlarda koşulda kullanılan değişkenleri atomic olarak tanımlama iyi bir tekniktir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    static atomic_t g_flag = ATOMIC_INIT(0);
    ...

    if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0)
        return -ERESTARTSYS;

    wait_event_interruptible_exclusive (bunun interruptible olmayan biçimi yoktur) makrosu Linux çekirdeklerine 2.6'nın belli 
    sürümünden sonra sokulmuştur. Yine bu makroyla birlikte aşağıda ele alınan wake_up_xxx_nr makroları da eklenmiştir. Bir 
    prosesin exclusive olarak wait kuyruğuna yerleştirilmesi onlardan belli sayıda olanların uyandırılabilmesini sağlamaktadır.

    Tabii wait_event makroları o andaki thread'i çizelgeden (yani run kuyruğundan) çıkartıp wait kuyruğuna yerleştirdikten sonra 
    "bağlamsal geçiş (context switch)" işlemini de yapmaktadır. Bağlamsal geçiş işlemi sonrasında artık çalışma kuyruğundaki yeni 
    bir thread CPU'ya atanarak çalıştırılır.

    wait_event makrolarının temsili kodunu şöyle düşünebilirsiniz:

    while (koşul_sağlanmadığı_sürece) {
        <thread'i bekleme kuyruğuna ekle>
        ---> <thread uyandırıldığında buradan çalışmaya devam eder>
    }

    Eski çekirdeklerde (yenilerinde de önemli değişiklik yoktur) wait_event makrosu şöyle yazılmıştır:

    #define __wait_event(wq, condition)                 \
    do {                                            \
        wait_queue_t __wait;                        \
        init_waitqueue_entry(&__wait, current);        \
                                                    \
        add_wait_queue(&wq, &__wait);                \
        for (;;) {                                    \
            set_current_state(TASK_UNINTERRUPTIBLE);        \
            if (condition)                            \
                break;                                \
            schedule();                                \
        }                                            \
        current->state = TASK_RUNNING;                \
        remove_wait_queue(&wq, &__wait);            \
    } while (0)

    #define wait_event(wq, condition)                 \
    do {                                            \
        if (condition)                                 \
            break;                                    \
        __wait_event(wq, condition);                \
    } while (0)

    Burada uyandırılan thread aslında schedule fonksiyonun içerisinde çalışmaya devam edecektir. Koddan da gördüğünüz gibi akış
    schedule fonksiyonundan çıktığında döngü başa saracak ve yeniden koşul kontrol edilecektir.

    Bekleme kuyruğunda blokede bekletilen thread'ler wake_up makrolarıyla uyandırılmaktadır. Uyandırılmaktan kastedilen şey thread'in 
    bekleme kuyruğundan çıkartılıp yeniden çalışma kuyruğuna (run queue) yerleştirilmesidir. wait_event makrolarındaki koşula 
    wake_up bakmamaktadır. wake_up makroları yalnızca thread'i bekleme kuyruğundan çıkartıp çalışma kuyruğuna taşımaktadır. Koşula 
    uyandırılmış thread'in kendisi bakmaktadır. Eğer koşul sağlanmıyorsa thread yeniden uyutulmaktadır. Yani biz koşulu sağlanır 
    duruma getirmeden wake_up işlemi yaparsak thread yeniden uykuya dalacaktır. (Zaten yukarıda da belirttiğimiz gibi yalnızca 
    "koşulu sağlayan thread'i uyandırması" mümkün değildir.)

    En çok kullanılan wake_up makroları şunlardır:

    wake_up(wq_head);
    wake_up_nr(wq_head, nr);
    wake_up_all(wq_head);
    wake_up_interruptible(wq_head);
    wake_up_interruptible_nr(wq_head, nr);
    wake_up_interruptible_all(wq_head);

    Bu makroların hepsi birinci parametre olarak bekleme kuyruğunun adresini almaktadır. Makroların çalışmasının anlaşılması 
    için bekleme kuyrukları hakkında biraz ayrıntıya girmek gerekir. Bekleme kuyruğunu temsil eden wait_queue_head_t yapısı şöyle 
    bildirilmiştir:

    struct wait_queue_head {
        spinlock_t lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    Görüldüğü gibi bu bir bağlı listedir. Bağlı liste spinlock ile korunmaktadır. Bu bağlı listenin düğümleri wait_queue_entry
    yapılarından oluşmaktadır.

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    Bu yapının ayrıntısına girmeyeceğiz. Ancak yapıdaki flags elemanına dikkat ediniz. Bekleme kuyruğuna yerleştirilen bir 
    thread'in exclusive bekleme yapıp yapmadığı (yani wait_event_intrerruptible_exclusive ile bekleme yapıp yapmadığı)
    bu flags elemanında saklanmaktadır. Bu wait kuyruğunun bekleyen thread'leri (onların task_struct adreslerini) tutan
    bir bağlı liste olduğunu varsayabilirsiniz. (Yapının private elemanı thread'leri temsil eden task_struct yapı nesnelerinin 
    adreslerini tutmaktadır.) Yani bekleme kuyrukları aşağıdaki gibi düşünülebilir:

    T1 ---> T2 ---> T3 ---> T4 ---> T5 ---> T6 ---> T7 ---> T8 ---> NULL

    Bu thread'lerden bazıları exclusive bekleme yapmış olabilir. Bunları (E) ile belirtelim:

    T1 ---> T2 ---> T3 ---> T4(E) ---> T5 ---> T6(E) ---> T7 ---> T8(E) ---> NULL

    Artık wake_up makrolarını açıklayabiliriz. wake_up makrosu kuyruğun başından itibaren ilk exclusive bekleme yapan thread'e 
    kadar bu thread de dahil olmak üzere tüm thread'leri uyandırmaktadır. Tabii bu thread'lerin hepsi uyandırıldıktan sonra 
    ayrıca koşula da bakacaktır. Örneğimizde wake_up makrosu çağrıldığında T1, T2, T3 ve T4 thread'leri uyandırılacaktır. Görüldüğü 
    gibi wake_up makrosu aslında 1 tane exclusive thread uyandırmaya çalışmaktadır. Ancak onu uyandırırken kuyruğun önündeki 
    exclusive olmayanları da uyandırmaktadır. Tabii bu anlatımdan anlaşılacağı gibi wake_up makrosu eğer kuyrukta hiç exclusive 
    bekleme yapan thread yoksa thread'lerin hepsini uyandırmaktadır.

    wake_up_nr makrosu, wake_up makrosu gibi davranır ancak 1 tane değil en fazla nr parametresiyle belirtilen sayıda exclusive 
    thread'i uyandırmaya çalışır. Başka bir deyişle wake_up(g_wq) çağrısı ile wake_up_nr(g_qw, 1) çağrısı aynı anlamdadır.
    Eğer yukarıdaki örnekte wake_up_nr(g_wq, 2) çağrısını yapmış olsaydık T1, T2, T2, T4, T5, T6 thread'leri uyandırılırdı. 
    Tabii yukarıda da belirttiğimiz gibi bu thread'lerin uyandırılmış olması wait_event makrolarından çıkılacağı anlamına gelmemektedir. 
    Uyandırma işleminden sonra koşula yeniden bakılmaktadır.

    wake_up_all makrosu bekleme kuyruğundaki tüm exclusive thread'leri ve exclusive olmayan thread'leri yani kısaca tüm thread'leri 
    uyandırmaktadır. Tabii yine uyanan thread'ler koşula bakacaktır.

    wake_up_interruptible, wake_up_interruptible_nr ve wake_up_interruptible_all makroları interruptible olmayan makrolar 
    gibi çalışmaktadır. Ancak bu makrolar bekleme kuyruğunda yalnızca "interruptible" wait_event fonksiyonlarıyla bekletilmiş 
    thread'lerle ilgilenmektedir. Diğer thread'ler kuyrukta yokmuş gibi davranmaktadır.

    wake_up makroları birden fazla thread'i uyandırabildiğine göre uyanan thread'lerin yeniden uykuya dalması gerekebilir. Çünkü 
    programcı yalnızca bir thread'in çalışmaya devam etmesini isteyebilir. Bu durumda tıpkı kullanıcı modundaki koşul değişkenlerindeki 
    gibi bir kalıp kullanılabilir:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread gelir */

    mutex_unlock(&g_mutex);

    Burada birden fazla thread uyandırıldığında bunlardan yalnızca biri mutex kilidini alarak kritik koda girmektedir. Eğer 
    kritik kod içerisinde koşul sağlanmaz hale getirilirse bu durumda diğer thread'ler while döngüsü nedeniyle yeniden uykuya 
    dalacaktır.

    Örneğin boru aygıt sürücüsünde okuma yapan thread'ler eğer boruda hiç byte yoksa bloke olmalıdır. O halde buradaki koşul 
    g_count > 0 olmalıdır. Boruya yazan thread g_count değerini güncelledikten sonra eğer g_count önceden sıfırsa wake_up 
    makrolarıyla bekleyen thread'leri uyandırır. Thread'ler uyandıktan sonra yukarıdaki while döngüsünde bunlardan yalnızca 
    biri mutex kilidini alır. Nutex kilidini alan thread'de borudan okuma yapar. Eğer okuma sonucunda g_count hala > 0 durumunda
    ise başka bir thread daha okuma yapacaktır. Taki g_count değeri 0 olana kadar. Bu durumda diğer thread'ler boruya yeni 
    bir yazma yapılana kadar blokede bekleyeceklerdir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                97. Ders 22/04/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücümüzün read ve write fonksiyonları aşağıdaki gibi olsun:

    wait_queue_head_t g_wq;
    atomic_t g_flag;
    ...

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver write...\n");

        atomic_set(&g_flag, 1);
        wake_up_interruptible(&g_wq);

        return 0;
    }

    Burada eğer birden fazla thread read yaparsa exclusive olmayan bir biçimde bekleme kuyruğunda bekleyecektir. write işleminde
    wake_up_interruptible makrosu ile uyandırma yapıldığına dikkat ediniz. Bekleme kuyruğunda exclusive bekleyen thread olmadığına 
    göre burada tüm read yapan thread'ler uyandırılacaktır. Onların koşulları sağlandığı için hepsi read fonksiyonundan çıkacaktır. 
    Şimdi bu read fonksiyonunda exclusive bekleme yapmış olalım:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    Artık write fonksiyonunda wake_up makrosu çağrıldığında yalnızca bir tane exclusive bekleme yapan thread uyandırılacağı 
    için read fonksiyonundan yalnızca bir thread çıkacaktır. Test için aşağıdaki kodları kullanabilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* wait-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Wait-Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static wait_queue_head_t g_wq;
static atomic_t g_flag;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "wait-driver module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "wait-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "wait-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver read...\n");

    atomic_set(&g_flag, 0);
    if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
        printk(KERN_INFO "Signal occurred...");
        return -ERESTARTSYS;
    }

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver write...\n");

    atomic_set(&g_flag, 1);
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Birden fazla thread'in uyandırıldığı durumda bunların yalnızca bir tanesinin kritik koda girmesini sağlayan kalıbı 
    anımsayınız:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread gelir */

    mutex_unlock(&g_mutex);

    Aşağıdaki kodda bu kalıp uygulanmıştır. Böylece her write işlemi yapıldığında yalnızca tek bir thread gerçek anlamda uyanıp
    kritik koda girecektir. Aygıt sürücünün read ve write fonksiyonları aşağıda verilmiştir:
-----------------------------------------------------------------------------------------------------------------------------*/

/* blocking-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static int g_flag;
static wait_queue_head_t g_wq;
static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "blocking-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "blocking-driver")) < 0) {
        printk(KERN_ERR "cannot #include <asm/atomic.h> register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "blocking-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "blocking...\n");

    g_flag = 0;

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (g_flag == 0) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, g_flag != 0) < 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
        printk(KERN_INFO "waking up...\n");
    }
    g_flag = 0;
    printk(KERN_INFO "enters critical section...\n");

    mutex_unlock(&g_mutex);

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wake up...\n");
    g_flag = 1;
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Daha önce görmüş olduğumuz mutex, semaphore, read/write kilitleri gibi 
    senkronizasyon nesnelerinin kendilerinin oluşturduğu bekleme kuyrukları vardır. Bu senkronizasyon nesneleri bloke oluşturmak
    için kendi bekleme kuyruklarını kullanmaktadır. Çekirdek kodları içerisinde bu senkronizasyon nesneleri için oluşturulmuş 
    bekleme kuyruklarını görebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                98. Ders 24/04/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yapmış olduğumuz boru örneğimizi gerçek bir boru haline getirelim. Yani eğer boruda en az 1 byte boş 
    alan kalmadıysa read fonksiyonu blokede en az 1 byte okuyana kadar beklesin. Eğer boruda tüm bilgileri yazacak kadar boş 
    yer kalmadıysa bu kez de yazan taraf blokede beklesin. Okuyan thread kuyruktaki byte sayısını belirten g_count == 0 olduğu 
    sürece bekleme kuyruğunda beklemelidir. Tabii bizim kuyruk üzerinde işlem yaptığımız kısımları senkronize etmemiz gerekir. 
    Bunu da bir binary semaphore nesnesi ya da mutex nesnesi iel sağlayabiliriz. Semaphore nesnesini ve bekleme kuyruğunu aşağıdaki 
    gibi yaratabiliriz:

    static wait_queue_head_t g_wq;
    DEFINE_SEMAPHORE(g_sem);

    Okuyan taraf önce semaphore kilidini eline almalı ancak eğer uykuya dalacaksa onu serbest bırakıp uykuya dalmalıdır. Kuyruk 
    üzerinde aynı anda işlemler yapılabileceği için tüm işlemlerin kritik kod içerisinde ele alınması uygun olur. O halde read 
    işlemindeki bloke olmanın tipik çatısı şöyle oluşturulabilir:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruktan okuma işlemleri

    up(&g_sem);

    Burada önce down_interruptible fonksiyonu ile semaphore kilitlenmeye çalışılmıştır. Eğer semaphore zaten kilitliyse semaphore'un 
    kendi bekleme kuyruğunda thread uykuya dalacaktır. Daha sonra g_count değerine bakılmıştır. Eğer g_count değeri 0 ise önce 
    semaphore serbest bırakılıp sonra thread bekleme kuyruğunda uyutulmuştur. Thread bekleme kuyruğundan uyandırıldığında yeniden 
    semaphore kontrolünü ele almaktadır. Tabii eğer birden fazla thread bekleme kuyruğundan uyandırılırsa yalnızca bunlardan biri 
    semaphore kontrolünü ele alacaktır. Semaphore kilidini alan thread bundan sonra kuyruktan bilgiler okunacak ve semaphore kilidini 
    serbest bırakılacaktır. Eğer birden fazla thread bekleme kuyruğundan uyanmışsa bu kez diğer bir thread semaphore kontrolünü ele 
    alacak ve g_count değerine bakacaktır.

    Benzer biçimde write işleminin de çatısı aşağıdaki gibidir:

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruğa yazma işlemleri

    up(&g_sem);

    Burada benzer işlemler uygulanmıştır. Eğer kuyrukta yazma yapılmak istenen kadar boş alan varsa akış while döngüsünün içerisine 
    girmeyecektir. (Buradaki while koşulunun "PIPE_BUFFER_SIZE - g_count < size" biçiminde olduğuna dikkat ediniz.) Dolayısıyla yazma 
    işlemi kritik kod içerisinde yapılabilecektir. Ancak kuyrukta yeteri kadar yer yoksa semaphore kilidi serbest bırakılıp thread 
    bekleme kuyruğunda bekletilecektir. Çıkışta benzer işlemler yapılmaktadır.

    Aslında burada spinlock nesneleri de kullanılabilir. Ancak zaten mutex, semaphore ve read/write lock nesneleri kendi içerisinde 
    bir miktar spin yapmaktadır. Spinlock için şu durumları gözden geçirmelisiniz:

    - Spinlock nesnesinde bekleme CPU zamanı harcanarak meşgul bir döngü içerisinde yapılmaktadır. Dolayısıyla spinlock nesneleri 
    kilidin kısa süreli bırakılacağından emin olunabiliyorsa kullanılmalıdır.

    - Spinlock içerisinde bağlamsal geçiş kapatılmakta ve sinyal işlemleri de bekletilmektedir. Yani spinlock beklemelerinin 
    "interruptible" bir biçimi yoktur.

    Örneğimizde kilitli kalınan kod miktarı dikkate alındığında semaphore ya da mutex nesnelerinin kullanılmasının daha uygun 
    olacağı söylenebilir.

    Burada yazma işlemleri için "yazma bekleme kuyruğu" ve okuma işlemleri için "okuma bekleme kuyruğu" biçiminde iki bekleme
    kuyruğu olduğuna dikkat ediniz. Çünkü yazan taraf okuma bekleme kuyruğundaki thread'leri okuyan taraf ise yazma bekleme 
    kuyruğundaki thread'leri uyandırmak isteyecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int n_readers;
static int n_writers;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver opened...\n");

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver closed...\n");

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda vermiş olduğumuz blokeli boru aygıt sürücüsü örneği UNIX/Linux sistemlerinde bulunan isimli borulara oldukça 
    benzemektedir. Ancak UNIX/Linux sistemlerindeki isimli boruların yukarıdaki aygıt sürücümüzde olmayan şu ek özellikleri 
    vardır:

    - Anımsanacağı gibi isimli boruyu bir bir prosesin thread'i O_RDONLY bayrağı ile okuma amaçlı açmak istediğinde eğer bu 
    boruyu herhangi bir prosesin thread'i O_WRONLY bayrağı ile yazma amaçlı açmamışsa okuma amaçlı açmaya çalışan thread boru 
    yazma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Benzer biçimde bir thread isimli boruyu O_WRONLY bayrağı 
    ile yazma amaçlı açmak istediğinde bu boruyu herhangi bir prosesin thread'i O_RONLY bayrağı ile okuma modunda açmamışsa yazma
    amaçlı açmaya çalışan thread boru okuma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Bizim aygıt sürücümüzde 
    böyle bir özellik yoktur.

    - İsimli borularda boru boşken okuma yapılmak istendiğinde eğer boruya yazma yapma potansiyelinde hiçbir thread kalmamışsa
    read fonksiyonu blokeye yol açmamakta 0 ile geri dönmektedir. Zaten boru haberleşmesi bu biçimde sonlandırılır. Yani boruya 
    yazan taraf önce boruyu kapatır. Borudan okuyan taraf borudakileri okur. Eğer boruda hiçbir şey kalmazsa read fonksiyonu 
    0 ile geri döner. Okuyan taraf da döngüden çıkarak işlemini sonlandırır. Bizim yukarıdaki boru aygıt sürücümüzde bu özellik 
    yoktur.

    - İsimli borularda borudan okuma yapma potansiyelinde olan hiçbir thread yoksa boruya yazma yapıldığında SIGPIPE sinyali 
    oluşturulmaktadır. Bu sinyal de ele alınmadıysa yazma yapan prosesin sonlanmasına yol açar. Bizim boru aygıt sürücümüzde
    de bu özellik yoktur.

    Peki bu özellikler nasıl sağlanabilir? Bizim open fonksiyonunda bloke oluşturabilmemiz için boruya yazma potansiyelinde 
    olan ve borudan okuma yapma potansiyelinde olan kaç thread'in bulunduğunu tutmamız gerekir. Tüm prosesler aygıt sürücüyü 
    açtığına göre bu işlem aygıt sürücünün open fonksiyonunda ve release fonksiyonunda yapılabilir. Dosya open fonksiyonu 
    ile açıldığında filp parametresinin gösterdiği yerdeki file nesnesinin f_flags elemanı open fonksiyonunda kullanılan açma
    bayrağını belirtmektedir. Biz de iki sayaç alıp kaç thread'in okuma amaçlı kaç thread'in yazma amaçlı olarak boruyu açtığını
    tutabiliriz.

    Aşağıdaki örnekte boru aygıt sürücümüzün yukarıdaki belirtilen eksiklikleri giderilmiştir. Burada aygıt sürücünün open 
    fonksiyonunda bloke işlemi şöyle sağlanmıştır:

    static int pipe_driver_open(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY) {
            ++g_nreaders;
            wake_up_interruptible(&g_writeopen);
            while (g_nwriters == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_readopen, g_nwriters > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }
        else if (accmode == O_WRONLY) {
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            while (g_nreaders == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_writeopen, g_nreaders > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }

        else if (accmode == O_RDWR) {
            ++g_nreaders;
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            wake_up_interruptible(&g_writeopen);
        }
        up(&g_sem);

        return 0;
    }

    Aygıt dosyasının hangi bayrakla açıldığının belirlenmesi için filp göstericisinin gösterdiği yerdeki file nesnesinin f_ops
    elemanına bakılmıştır. Bu elemanın ilk 2 biti dışındaki bitleri başka bayraklarla ilgili olduğu için önce ilk 2 bit 
    maskelenmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    Sonra eğer aygıt dosyası yazma amaçlı açılmışsa okuma amaçlı açış yapılmış mı diye, okuma amaçlı açılmışsa yazma amaçlı açış 
    var mı diye bakılmıştır. Kodumuzda open fonksiyonunda bloke oluşturmak için iki ayrı bekleme kuyruğunun daha yaratıldığını 
    görüyorsunuz. Aygıt sürücümüzün release fonksiyonunda bu sayaçlar aşağıdaki gibi eksiltilmiştir:

    static int pipe_driver_release(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY)
            --g_nreaders;
        else if (accmode == O_WRONLY)
            --g_nwriters;
        else if (accmode == O_RDWR) {
            --g_nreaders;
            --g_nwriters;

        }
        up(&g_sem);

        return 0;
    }

    Aygıt sürücümüzün read fonksiyonunda eğer boruya yazma potansiyelinde olan hiçbir thread kalmamışsa read fonksiyonu 0 ile 
    geri döndürülmüştür:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }
    ...

    Benzer biçimde aygıt sürücümüzün write fonksiyonunda eğer borudan okuma yapma potansiyelinde hiçbir thread kalmamışsa 
    SIGPIPE sinyali oluşturulmuştur:

    ...
    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }
    ...

    Aygıt sürücümüzün release fonksiyonunda da sayaçlar eksiltilmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    Aşağıda örnek bir bütün olarak verilmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }

    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;
    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                99. Ders 06/05/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aslında bekleme kuyrukları wait_queue_entry isimli yapı nesnelerinden oluşan bir çift bağlı listedir. wait_queue_head_t 
    yapısı da bağlı listenin ilk ve son elemanlarının adresini tutmaktadır:

    wait_queue_head_t <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry ...

    Çekirdek kodlarında bu yapılar "include/linux/wait.h" dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct wait_queue_head {
        spinlock_t    lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    wait_queue_head yapısının içerisindeki list_head elemanı bağlı listenin ilk ve son elemanlarının adreslerini tutmaktadır. 
    Yapının lock elemanı ise bekleme kuyruğuna erişirken kullanılacak olan spinlock nesnesini belirtmektedir. Biz burada 
    wait_queue_entry yapısının ayrıntılarına girmeyeceğiz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz aygıt sürücü kodumuzda o anda quanta süresini bırakıp çizelgeleyicinin kendi algortimasına göre sıradaki thread'i 
    çizelgelemesini sağlayabiliriz. Bunun için schedule isimli çekirdek fonksiyonu kullanılmaktadır. Bu fonksiyon bloke 
    oluşturmamaktadır. Yalnızca thread'ler arası geçiş (context switch) oluşturmaktadır. schedule fonksiyonu herhangi bir 
    parametre almamaktadır:

    #include <linux/kernel.h>

    void schedule(void);

    Tabii koşullara bağlı olarak biz schedule fonksiyonunu çağırmış olsak bile işletim sistemi başka bir thread olmadığı için 
    ya da thread önceliklerinden dolayı yine bizim thread'imizi çizelgeleyebilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları export edilmiş birkaç fonksiyon çağrılarak yazılmıştır. Dolayısıyla wait_event fonksiyonlarını 
    çağırmak yerine programcı daha aşağı seviyeli (zaten wait_event fonksiyonlarının çağırmış olduğu) fonksiyonları çağırabilir. 
    Yani bu işlemi daha aşağı seviyede manuel de yapabilir. Prosesin manuel olarak wait kuyruğuna alınması prepare_to_wait ve 
    prepare_to_wait_exclusive isimli fonksiyonlar tarafından yapılmaktadır:

    #include <linux/wait.h>

    void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
    void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);

    Bu fonksiyonların birinci parametreleri bekleme kuyruğu nesnesinin adresini, ikinci parametreleri bu kuyruğa yerleştirilecek 
    wait_queue_entry nesnesinin adresini almaktadır. Fonksiyonların üçüncü parametreleri TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE 
    biçiminde geçilebilir. Bir wait_queue_entry nesnesi şöyle oluşturulabilir:

    DEFINE_WAIT(wqentry);

    Ya da açıkça tanımlanıp init_wait makrosuyla ilk değerlenebilir. Örneğin:

    struct wait_queue_entry wqentry;
    ...
    init_wait(&wqentry);

    DEFINE_WAIT makrosu global tanımlamalarda kullanılamamaktadır. Çünkü bu makro küme parantezleri içerisinde sabit ifadesi olmayan 
    ifadeler barındırmaktadır. Ancak makro yerel tanımlamalarda kullanılabilir.

    Aslında prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları bekleme kuyruğuna bir wait_queue_entry nesnesi eklemektedir. 
    Yani programcının bunun için yeni bir wait_queue_entry nesnesi oluşturması gerekmektedir. prepare_to_wait_exclusive fonksiyonu 
    exclusive uyuma için kullanılmaktadır.

    prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları şunları yapmaktadır:

    1) Thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştirir. (Çalışma kuyruğunun organizasyonu ve bu işlemin gerçek 
    ayrıntıları biraz karmaşıktır. Biz burada çalışma kuyruğunun organizasyonu üzerinde durmayacağız.)
    2) Thread'in durum bilgisini (task state) state parametresiyle belirtilen duruma çeker.
    3) prepare_to_wait fonksiyonu kuyruk elemanını exclusive olmaktan çıkartırken, prepare_to_wait_exclusive onu exclusive yapar.

    Thread'in çalışma kuyruğundan bekleme kuyruğuna aktarılması onun uykuya dalması anlamına gelmemektedir. Programcı artık thread 
    çalışma kuyruğunda olmadığına göre schedule fonksiyonu ile thread'ler arası geçiş (context switch) uygulamalı ve akış kontrolünü 
    başka bir thread'e bırakmalıdır. Zaten thread'in çalışma kuyruğundan çıkartılması artık yeniden çalışma kuyruğuna alınmadıktan 
    sonra uykuda bekletilmesi anlamına gelmektedir.

    Tabii biz prepare_to_wait ya da prepare_to_wait_exclusive fonksiyonlarını çağırdıktan sonra bir biçimde koşul durumuna bakmalıyız. 
    Eğer koşul sağlanmışsa hiç prosesi uykuya daldırmadan hemen bekleme kuyruğundan çıkarmalıyız. Eğer koşul sağlanmamışsa gerçekten 
    artık schedule fonksiyonuyla "thread'ler arası geçiş" uygulamalıyız. Thread'imiz schedule fonksiyonunu çağırdıktan sonra artık 
    uyandırılana kadar bir daha çizelgelenmeyecektir. Bu da bizim uykuya dalmamız anlamına gelmektedir.

    Peki thread'imiz uyandırıldığında nereden çalışmaya devam edecektir? İşte schedule fonksiyonu thread'ler arası geçiş yaparken 
    kalınan yeri thread'e ilişkin task_struct yapısının içerisine kaydetmektedir. Kalınan yer schedule fonksiyonunun içerisinde 
    bir yerdir. O halde thread'imiz uyandırıldığında schedule fonksiyonunun içerisinden çalışmaya devam edecektir. Sonra schedule 
    fonksiyonu geri dönecek ve thread akışı devam edecektir.

    wake_up fonksiyonları thread'i bekleme kuyruklarından çıkartıp çalışma kuyruğuna eklemektedir. Ancak prepare_to_wait ve 
    prepare_to_wait_exclusive fonksiyonları çağrıldıktan sonra eğer koşulun zaten sağlandığı görülürse bu durumda uyandırma 
    wake_up fonksiyonlarıyla yapılmadığı için bekleme kuyruğundan thread'in geri çıkartılması da programcının sorumluluğundadır. 
    Bu işlem finish_wait fonksiyonu ile yapılmaktadır.

    #include <linux/wait.h>

    void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

    Bu fonksiyon zaten thread wake_up fonksiyonları tarafından bekleme kuyruğundan çıkartılmışsa herhangi bir işlem yapmaz. 
    Bu durumda manuel uyuma şöyle yapılabilir.

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_UNINTERRUPTIBLE);
    if (!condition)
        schedule();
    finish_wait(&wqentry);

    Tabii eğer thread INTERRUPTIBLE olarak uyuyorsa schedule fonksiyonundan çıkıldığında sinyal dolayısıyla da çıkılmış olabilir. 
    Bunu anlamak için signal_pending isimli fonksiyon çağrılır. Bu fonksiyon sıfır dışı bir değerle geri dönmüşse uyandırma 
    işleminin sinyal yoluyla yapıldığı anlaşılır. Bu durumda tabii aygıt sürücüdeki fonksiyon -ERESTARTSYS ile geri döndürülmelidir. 
    signal_pending fonksiyonunun prototipi şöyledir:

    #include <linux/kernel.h>

    int signal_pending(struct task_struct *p);

    Fonksiyon parametre olarak thread'e ilişkin task_struct yapısının adresini almaktadır. Bu durumda INTERRUPTIBLE uyuma aşağıdaki 
    gibi yapılabilir:

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_INTERRUPTIBLE);
    if (!condition)
        schedule();
    if (signal_pending(current))
        return -ERESTARTSYS;
    finish_wait(&wqentry);

    wake_up makrolarının şunları yaptığını anımsayınız:

    1) Wait kuyruğundaki prosesleri çıkartarak run kuyruğuna yerleştirir.
    2) Prosesin durumunu TASK_RUNNING haline getirir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları yukarıda açıkladığımız daha aşağı seviyeli fonksiyonlar kullanılarak gerçekleştirilmiştir. 
    Mevcut son Linux çekirdeğinde wait_event_interruptible makrosu şöyle yazılmıştır:

    #define wait_event_interruptible(wq_head, condition)                \
    ({                                                                    \
        int __ret = 0;                                                    \
        might_sleep();                                                    \
        if (!(condition))                                                \
            __ret = __wait_event_interruptible(wq_head, condition);        \
        __ret;                                                            \
    })

    Burada gcc'nin bileşik ifade de denilen bir eklentisi (extension) kullanılmıştır. Bu makro ayrıntılar göz ardı edilirse 
    __wait_event_interruptible makrosunu çağırmaktadır. Bu makro şöyle tanımlanmıştır:

    #define __wait_event_interruptible(wq_head, condition)                \
    ___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,            \
              schedule())

    Burada ___wait_event makrosunun interruptible olan ve olmayan kodların ortak makrosu olduğu görülmektedir. Bu 
    makro da şöyle tanımlanmıştır:

    #define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)        \
    ({                                                                            \
        __label__ __out;                                                        \
        struct wait_queue_entry __wq_entry;                                        \
        long __ret = ret;    /* explicit shadow */                                \
                                                                                \
        init_wait_entry(&__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);        \
        for (;;) {                                                                \
            long __int = prepare_to_wait_event(&wq_head, &__wq_entry, state);   \
                                                                                \
            if (condition)                                                        \
                break;                                                            \
                                                                                \
            if (___wait_is_interruptible(state) && __int) {                        \
                __ret = __int;                                                    \
                goto __out;                                                        \
            }                                                                    \
                                                                                \
            cmd;                                                                \
        }                                                                        \
        finish_wait(&wq_head, &__wq_entry);                                        \
    __out:    __ret;                                                                \
    })
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı (boru dosyaları da diğer aygıt sürücü dosyaları da dahil olmak üzere) açarken kullanılan bayraklardan biri de 
    O_NONBLOCK bayrağıdır. Bu bayrağın normal dosyalarda (regular file) bir etkisi yoktur. Ancak borularda, soketlerde ve özel 
    bazı aygıt sürücülerde bu bayrak önemli bir işlevselliğe sahiptir. Bu işlevselliğe "blokesiz IO işlemleri (Non-blocking IO)" 
    denilmektedir.

    Blokesiz IO işlemlerinin temel fikri şudur: Bazı aygıtlardan (boru ve soketler de dahil olmak üzere) okuma yazma yapılırken 
    uzun süre beklemeye yol açabilecek bir bloke durumu oluşabilmektedir. Örneğin biz bir borudan okuma yapmak isteyelim. Ancak 
    boruda hiç byte olmasın. Bu durumda read fonksiyonu blokeye yol açacak ve boruya bilgi gelene kadar program akışı kesilecektir. 
    İşte blokesiz işlemlerde eğer ilgili işlem blokeye yol açabilecekse bloke oluşturulmamakta read ve write fonksiyonları
    başarısızlıkla geri dönmekte ve errno değeri de EAGAIN denilen özel bir değerle set edilmektedir. Örneğin biz içerisinde hiç 
    byte olmayan bir borudan read fonksiyonu ile 10 byte okumak isteyelim. Eğer boru default durumda olduğu gibi "blokeli modda" 
    açılmış ise read fonksiyonu en az 1 byte boruya yazılana kadar blokede kalır. Ancak eğer blokesiz modda isek bu durumda read 
    fonksiyonu bloke olmaz -1 değeriyle geri döner ve errno değeri EAGAIN ile set edilir. Böylece programcı arka planda "mademki 
    boruda bir şey yok o zaman ben de başka bir şey yapayım" diyebilmektedir. Aynı durum write sırasında da benzer biçimde söz 
    olmaktadır. Örneğin blokesiz modda biz bir boruya write işlemi yapmak isteyelim ancak boruda yazmak istediğimiz miktar kadar 
    boş alan olmasın. Bu durumda write fonksiyonu -1 ile geri döner ve errno değeri EAGAIN değeri set edilir. Blokesiz modda 
    işlemler blokeli moddaki işlemlere göre oldukça seyrek kullanılmaktadır.

    İsimli boru dosyaları open fonksiyonuyla O_NONBLOCK bayrağı kullanılarak açılırken artık open fonksiyonunda bloke oluşmaz. 
    Anımsanacağı gibi blokesiz modda open karşı taraf boruyu ters modda açana kadar bloke oluşuyordu. open fonksiyonunda 
    O_NONBLOCK bayrağı kullanıldığında proses boruyu read modda açtığında henüz karşı taraf boruyu write modda açmamışsa read 
    fonksiyonu boruyu yazma potansiyelinde olan hiçbir betimleyici olmadığı için 0 ile geri döner.

    İsimli borularda proses boruyu "write" modda açarken normalde blokeli modda open fonksiyonu karşı taraf boruyu "read" modda 
    açana kadar bloke oluşuyordu. Halbuki isimli boruları O_NONBLOCK bayrağı ile "write" modda açmaya çalıştığımızda karşı 
    taraf boruyu henüz "read" modda açmamışsa open başarısız olmaktadır. Bu durumda open fonksiyonu errno değerini ENXIO ile 
    set etmektedir. Bu errno değerinin yazısı "No such device or address" biçimindedir.

    İsimli borularda iki taraf da boruyu O_NONBLOCK bayrağı ile açarsa yukarıda anlattığımız nedenden dolayı senkronizasyona 
    dikkat etmek gerekir. Bu tür durumlarda işlemleri kolaylaştırmak için isimli borular blokeli modda açılıp (O_NONBLOCK 
    kullanılmadan) sonrasında fcntl fonksiyonu ile blokesiz moda geçilebilir.

    Prosesler biri boruyu blokeli modda diğeri blokesiz modda açabilir. Bu da herhangi bir soruna yol açmaz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerimize arzu edersek "blokesiz (non-blocking)" okuma yazma desteği de verebiliriz. Tabii bu desteğin verilebilmesi
    için aygıt sürücünün okuma yazma sırasında bloke oluşturması gerekmektedir. Anımsanacağı gibi blokesiz işlem yapabilmek için 
    open POSIX fonksiyonunda fonksiyonun ikinci parametresine O_NONBLOCK bayrağı ekleniyordu. Normal disk dosyalarında O_NONBLOCK 
    bayrağının bir anlamı yoktu. Ancak boru gibi özel dosyalarda ve aygıt sürücülerde daha önceden de belirttiğimiz gibi bu bayrak 
    şu anlama gelmektedir:

    1) Okuma sırasında eğer okunacak bir bilgi yoksa read fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner ve errno değeri 
    EAGAIN olarak set edilir.

    2) Yazma sırasında yazma eylemi meşguliyet yüzünden yapılamıyorsa write fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner 
    ve errno değeri yine EAGAIN olarak set edilir.

    Aygıt sürücü açıldığında open fonksiyonunun ikinci parametresi file yapısının (dosya nesnesinin) f_flags elemanına yerleştirilmektedir. 
    Dosya nesnesinin adresinin aygıt sürücüdeki fonksiyonlara filp parametresiyle aktarıldığını anımsayınız. Bu durumda biz aygıt 
    dosyasının blokesiz modda açılıp açılmadığını şöyle test edebiliriz:

    if (filp->f_flags & O_NONBLOCK) {        /* blokesiz modda mı açılmış */
        /* open fonksiyonunda aygıt O_NONBLOCK bayrağı ile açılmış */
    }

    Aygıt sürücümüz blokesiz modda işlemlere izin vermiyorsa biz bu durumu kontrol etmeyebiliriz. Yani böyle bir aygıt sürücüde 
    programcı aygıt sürücüyü O_NONBLOCK bayrağını kullanarak açmışsa bu durumu hiç dikkate almayabiliriz. (Örneğin disk dosyalarında
    blokesiz işlemlerin bir anlamı olmadığı halde Linux çekirdeği disk dosyaları O_NONBLOCK bayrağıyla açıldığında hata ile geri 
    dönmeden bayrağı dikkate almamaktadır.) Eğer bu kontrol yapılmak isteniyorsa aygıt sürücünün açılması sırasında kontrol 
    aygıt sürücünün open fonksiyonunda yapılabilir. Bu durumda open fonksiyonunu -EINVAL değeriyle geri döndürebilirsiniz. Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp)
    {
        if (filp->f_flags & O_NONBLOCK)
            return -EINVAL;
        return 0;
    }

    Peki boru aygıt sürücümüze nasıl blokesiz mod desteği verebiliriz? Aslında bunun için iki şeyi yapmamız gerekir:

    1) Yazma yapıldığı zaman boruda yazılanları alacak kadar yer yoksa aygıt sürücümüzün write fonksiyonunu -EAGAIN değeriyle 
    geri döndürmeliyiz. Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_BUFSIZE - g_count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFSIZE - g_count >= size))
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    2) Okuma yapıldığı zaman eğer boruda hiç bilgi yoksa aygıt sürücümüzün read fonksiyonunu -EAGAIN değeriyle geri döndürmeliyiz.
    Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    read ve write fonksiyonlarının -EAGAIN değeriyle geri döndürülmeden önce aygıt dosyasının blokesiz modda açılıp açılmadığının
    kontrol edilmesi gerektiğine dikkat ediniz.

    Aşağıdaki örnekte boru aygıt sürücüsüne blokesiz okuma ve yazma desteği verilmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                100. Ders 08/05/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri ve aygıt sürücüler dinamik bellek tahsis etmeye gereksinim duyabilirler. Ancak çekirdek modunda çalışan 
    programlar dinamik tahsisatları malloc, calloc ve realloc gibi standart C fonksiyonlarıyla yapamazlar. Çünkü bu fonksiyonlar 
    kullanıcı modundaki programlar tarafından kullanılacak biçimde prosesin bellek alanında tahsisat yapmak için tasarlanmışlardır. 
    Oysa çekirdeğin ayrı bir heap sistemi vardır. Bu nedenle çekirdek modülleri ve aygıt sürücüler çekirdeğin sunduğu fonksiyonlarla 
    çekirdeğin heap alanında tahsisat yapabilirler. Biz de bu bölümde çekirdeğin heap sistemi üzerinde tahsisatların nasıl yapıldığı 
    üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Linux sistemlerinde proseslerin bellek alanları sayfa tabloları yoluyla izole edilmiştir. Ancak çekirdek 
    tüm proseslerin sayfa tablosunda aynı yerde bulunmaktadır. Başka bir deyişle her prosesin sayfa tablosunda çekirdek hep aynı 
    sanal adreslerde bulunmaktadır. Örneğin sys_open sistem fonksiyonuna girildiğinde bu fonksiyonun sanal adresi her proseste 
    aynıdır.

    32 bit Linux sistemlerinde proseslerin sanal bellek alanları 3 GB kullanıcı (user), 1 GB çekirdek (kernel) olmak üzere iki 
    bölüme ayrılmıştır. 64 bit Linux sistemlerinde ise yalnızca sanal bellek alanının 256 TB'si kullanılmaktadır. Bu sistemlerde 
    kullanıcı alanı için 128 TB, çekirdek alanı için de 128 TB yer ayrılmıştır. 32 bit Linux sistemlerindeki prosesin sanal 
    bellek alanı şöyle gösterilebilir:

    00000000
    ...            USER ALANI (3 GB)
    C0000000
    ...            KERNEL ALANI (1 GB)

    64 bit Linux sistemlerindeki sanal bellek alanı ise kabaca şöyledir:

    0000000000000000
    ...                        USER ALANI (128 TB)
    0000800000000000
    ...                        BOŞ BÖLGE (yaklaşık 16M TB)
    FFFF800000000000
    ...                        KERNEL ALANI (128 TB)
    FFFFFFFFFFFFFFFF
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir sistem fonksiyonunun çağrıldığını düşünelim. İşlemci çekirdek moduna otomatik olarak geçirilecektir. Bu durumda sayfa 
    tablosu değişmeyecektir. Peki çekirdek nasıl tüm fiziksel belleğe erişebilmektedir? İşte 32 bitlik sistemlerde proseslerin 
    sayfa tablolarının son 1 GB'yi sayfalandırdığı girişleri tamamen fiziksel belleği eşlemektedir. Başka bir deyişle bu 32 bit 
    sistemlerde çekirdek alanının başlangıcı olan C0000000 adresi aslında sayfa tablosunda 00000000 fiziksel adresini belirtmektedir. 
    Böylece çekirdeğin herhangi bir fiziksel adrese erişmek için yapacağı tek şey bu adrese C00000000 değerini toplamaktır. Bu 
    sistemlerde C0000000 adresinden itibaren proseslerin sayfa tabloları zaten fiziksel belleği 0'dan itibaren haritalandırmaktadır. 
    Ancak 32 bit sistemlerde şöyle bir sorun da vardır: Sayfa tablosunda C0000000'dan itibaren sayfalar fiziksel belleği haritalandırdığına 
    göre 32 bit sistemlerin maksimum sahip olacağı 4 GB fiziksel RAM'in hepsi haritalandırılamamaktadır. İşte Linux tasarımcıları 
    sayfa tablolarında C0000000'dan itibaren fiziksel RAM'in 1 GB'sini değil 896 MB'sini haritalandırmıştır. Geri kalan 128 MB'lik 
    alan fiziksel RAM'de 896 MB'nin ötesine erişmek için değiştirilerek kullanılmaktadır. Yani 32 bit sistemlerde çekirdek 
    fiziksel RAM'in ilk 896 MB'sine doğrudan ancak bunun ötesine sayfa tablosunun son 128 MB'lik bölgesini değiştirerek erişmektedir. 
    32 bit sistemlerde 896 MB'nin ötesine dolaylı biçimde erişildiği için bu bölgeye "high memory zone" denilmektedir. Tabii 
    64 bit sistemlerde böyle bir problem yoktur. Çünkü bu sistemlerde yine sayfa tablolarının çekirdek alanı fiziksel RAM'i 
    başından itibaren haritalandırmaktadır. Ancak 128 TB'lik alan zaten şimdiki bilgisayarlara takılabilecek fiziksel RAM'in 
    çok ötesindedir. Bu nedenle 64 bit sistemlerde "high memory zone" kavramı yoktur.

    Çekirdek kodlarında çekirdek alanının başlangıcı PAGE_OFFSET makrosuyla belirlenmiştir. Örneğin 32 bit sistemlerde bu 
    PAGE_OFFSET değeri 0xC0000000 biçimindedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz çekirdek modunda kod yazarken belli bir fiziksel adrese erişmek istersek onun sanal adresini bulmamız gerekir. Bu işin 
    manuel yapılması yerine bunun için __va isimli makro kullanılmaktadır. Biz bu makroya bir fiziksel adres veririz o da bize 
    o fiziksel adrese erişmek için gereken sanal adresi verir. Benzer biçimde bir sanal adresin fiziksel RAM karşılığını bulmak 
    için de __pa makrosu kullanılmaktadır. Biz bu makroya sanal adresi veririz o da bize o sanal adresin aslında RAM'deki hangi 
    fiziksel adres olduğunu verir. __va makrosu parametre olarak unsigned long biçiminde fiziksel adresi alır, o fiziksel adrese 
    erişmek için gerekli olan sanal adresi void * türünden bize verir. __pa makrosu bunun tam tersini yapmaktadır. Bu makro bizden 
    unsigned long biçiminde sanal adresi alır. O sanal adrese sayfa tablosunda karşı gelen fiziksel adresi bize verir.

    Çekirdek modunda RAM'in her yerine erişebildiğimize ve bu konuda bizi engelleyen hiçbir mekanizmanın olmadığına dikkat ediniz.
    Dolayısıyla bir aygıt sürücüler içerisinde RAM'in istediğimiz kısmına erişip oratayı değiştirebiliriz. Ancak bu durum 
    kontrolsüz ve amaçsız bir biçimde yapılırsa bu olumsuzluktan tün sistem etkilenebilecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeği için fiziksel RAM temel olarak 3 bölgeye (zone'a) ayrılmıştır:

    ZONE_DMA
    ZONE_NORMAL
    ZONE_HIGHMEM

    ZONE_DMA ilgili sistemde disk ile RAM arasında transfer yapan DMA'nın erişebildiği RAM alanıdır. Bazı sistemlerde DMA tüm 
    fiziksel RAM'in her yerine transfer yapamamaktadır. ZONE_NORMAL doğrudan çekirdeğin sayfa tablosu yoluyla haritalandırdığı 
    fiziksel bellek bölgesidir. 32 bit Linux sistemlerinde bu bölge RAM'in ilk 896 MB'sidir. Ancak 64 bit Linux sistemlerinde bu 
    bölge tüm fiziksel RAM'i içermektedir. ZONE_HIGHMEM ise 32 bit sistemlerde çekirdeğin doğrudan haritalandıramadığı sayfa 
    tablosunda değişiklik yapılarak erişilebilen fiziksel RAM alanıdır. 32 bit Linux sistemlerinde 896 MB'nin yukarısındaki 
    fiziksel RAM bölgesi ZONE_HIGHMEM alanıdır. Yukarıda da belirttiğimiz gibi 64 bit Intel işlemcilerinde ZONE_HIGHMEM biçiminde 
    bir alan zaten yoktur.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki programlarda kullandığımız malloc fonksiyonununda en fazla uygulanan tahsisat yöntemi "boş bağlı liste" 
    denilen yöntemdir. Bu yöntemde yalnızca boş alanlar bir bağlı listede tutulmaktadır. Dolayısıyla malloc gibi bir fonksiyon 
    bu bağlı listede uygun bir elemanı bağlı listeyi dolaşarak bulmaktadır. free fonksiyonu da tahsis edilmiş olan alanı bu boş 
    bağlı listeye eklemektedir. Tabii free fonksiyonu aynı zamanda bağlı listedeki komşu alanları da daha büyük bir boş alan 
    oluşturacak biçimde birleştirmektedir. Ancak bu klasik yöntem çekirdek heap sistemi için çok yavaş bir yöntemdir. Bu nedenle 
    çekirdek heap sistemlerinde için daha hızlı çalışan tahsisat algoritmaları kullanılmaktadır.

    Eğer tahsis edilecek bloklar eşit uzunlukta olursa bu durumda tahsisat işlemi ve geri bırakma işlemi O(1) karmaşıklıkta 
    yapılabilir. Örneğin heap içerisindeki tüm blokların 16 byte uzunlukta olduğunu düşünelim. Bu durumda 16 byte'lık tahsisat 
    sırasında uygun bir boş alan aramaya gerek kalmaz. Bir bağlı liste içerisinde boş alanlar tutulabilir. Bu boş alanlardan 
    herhangi biri verilebilir. Tabii uygulamalarda tahsis edilecek alanların büyükleri farklı olmaktadır.

    İşte BSD ve Linux sistemlerinde kullanılan "dilimli tahsisat sistemi (slab allocator)" denilen tahsisat sisteminin anahtar 
    noktası eşit uzunlukta olan ve ismine "dilim (slab)" denilen blokların tahsis edilmesidir. Çekirdek içerisinde çeşitli nesneler 
    için o nesnelerin uzunluğuna ilişkin farklı dilimli tahsisat sistemleri oluşturulmuştur. Örneğin bir proses yaratıldığında 
    task_struct yapısı çekirdeğin heap alanında tahsis edilmektedir. İşte dilimli tahsisat sistemlerinden biri (struct task_struct 
    yapısının uzunluğu kadar dilim uzunluklarından oluşan sistemdir. Böylece pek çok çekirdek nesnesi için ayrı dilimli tahsisat 
    sistemleri oluşturulmuştur. Bu durumu özet olarak şöyle düşünebilirsiniz: Çekirdek sanki kendi içerisindeki her veri yapısı 
    için eşit uzunluklarda bloklardan oluşan farklı heap alanı kullanıyor gibidir.

    Çekirdek içerisindeki veri yapıları için oluşturulmuş olan dilimli tahsisat sistemlerinin dışında ayrıca bir de genel 
    kullanım için blok uzunlukları 32, 64, 96, 128, 192, 256 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, ... biçiminde 
    olan farklı dilimli tahsisat sistemleri de bulundurulmuştur. Böylece çekirdek mod programcısı belli uzunlukta bir alan 
    tahsis etmek istediğinde bu uzunluğa en yakın fakat bu uzunluktan büyük bir dilimli tahsisat sistemini kullanır. Tabii 
    çekirdek modunda çalışan programcılar isterse kendi nesneleri için de o nesnelerin uzunluğu kadar yeni dilimli tahsisat 
    sistemleri de oluşturabilmektedir.

    Burada aklınıza "mademki dilimli tahsisat sistemi çok hızlı bir sistem" o halde neden kullanıcı modundaki malloc gibi 
    fonksiyonlar da aynı mantıkla çalışmıyor" sorusu aklınıza gelebilir. Bunun iki nedeni vardır:

    1) Bu sistem hızlı olmasına karşın bellek harcaması daha yüksektir. Örneğin bu sistemde 600 byte'lık bir tahsisat yapmak 
    istesek bunu 1024'lük dilimlerin bulunduğu sistemden yaparız. Bu da kullanılmayan boş alanlar oluşturur.

    2) Eğer programcı kendi dilim sistemini oluşturacak olsa bunun da arayüz olarak kullanımı zor olmaktadır.

    O halde bu dilimli tahsisat sistemi çekirdek için uygun ama kullanıcı modu için pek uygun bir sistem değildir.

    Aslında dilimli tahsisat sisteminin hazırda bulundurduğu dilimler işletim sisteminin sayfa tahsisatı yapan başka bir tahsisat
    algoritmasından elde edilmektedir. Linux sistemlerinde sayfa temelinde tahsisat yapmak için kullanılan tahsisat sistemine
    "buddy allocator" denilmektedir. (CSD işletim sisteminde buna "ikiz blok sistemi" denilmektedir.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modunda çekirdek alanında dinamik tahsisat yapmak için kullanılan en genel fonksiyon kmalloc isimli fonksiyondur. 
    Bu fonksiyon aslında parametresiyle belirtilen uzunluğa en yakın önceden yaratılmış olan dilimli tahsisat sisteminden dilim 
    vermektedir (yani blok tahsis etmektedir). Örneğin biz kmalloc fonksiyonu ile 100 byte tahsis etmek istesek 100 byte'lık 
    blokların bulunduğu önceden yaratılmış bir dilimli tahsisat sistemi olmadığı için kmalloc 128 byte'lık bloklara sahip dilimli 
    tahsisat sisteminden bir dilim tahsis ederek bize verecektir. Tabii bu örnekte 28 byte boşuna tahsis edilmiş olacaktır. Ancak 
    çekirdek tahsisat sisteminin amacı en uygun miktarda belleği tahsis etmek değil, talep edilen miktarda belleği daha hızlı 
    tahsis etmektir. kmalloc fonksiyonu ile tahsis edilen dilimler kfree fonksiyonu ile serbest bırakılmaktadır. Fonksiyonların 
    prototipleri şöyledir:

    #include <linux/slab.h>

    void *kmalloc (size_t size, int flags);
    void kfree (const void *objp);

    kmalloc fonksiyonunun birinci parametresi tahsis edilecek byte miktarını belirtir. İkincisi parametresi ise tahsis edilecek 
    zone ve tahsisat biçimi hakkında çeşitli bayrakları içermektedir. Bu ikinci parametre çeşitli sembolik sabitlerden oluşturulmaktadır. 
    Burada önemli birkaç bayrak şunlardır:

    GFP_KERNEL: Çekirdek alanı içerisinde normal tahsisat yapmak için kullanılır. Bu bayrak en sık bu kullanılan bayraktır. Burada 
    eğer RAM doluysa işletim sistemi prosesi bloke ederek swap işlemi ile yer açabilmektedir. Yani bu işlem sırasında akış çekirdek 
    modunda bloke olarak thread bekleme kuyruklarında bekletilebilir. Tahsisat işlemi ZONE_NORMAL alanından yapılmaktadır.

    GFP_NOWAIT: GFP_KERNEL gibidir. Ancak hazırda bellek yoksa thread uykuya dalmaz. Fonksiyon başarısız olur.

    GFP_HIGHUSER: 32 bit sistemlerde ZONE_HIGHMEM alanından tahsisat yapar.

    GFP_DMA: İlgili sistemde DMA'nın erişebildiği fiziksel RAM alanından tahsisat yapar.

    kmalloc fonksiyonu başarı durumunda tahsis edilen alanın sanal bellek adresiyle, başarısızlık durumunda NULL adresle geri
    dönmektedir. Çekirdek modülleri ve aygıt sürücüler dinamik tahsisat başarısız olursa tipik olarak -ENOMEM değerine geri 
    dönmelidir.

    kfree fonksiyonu ise daha önce kmalloc ile tahsis edilmiş olan alanın başlangıç adresini parametre olarak almaktadır.

    Aşağıda daha önce yapmış olduğumuz boru aygıt sürücüsündeki kuyruk sistemini kmalloc fonksiyonu ile tahsis edilip kfree
    fonksiyonu ile serbest bırakılmasına örnek verilmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }

    if ((g_pipe = kmalloc(sizeof(struct PIPE), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;

EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kfree(g_pipe);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0)
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0)
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY|O_NONBLOCK)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                101. Ders 13/05/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi istersek genel amaçlı kmalloc fonksiyonunu kullanmak yerine kendimiz de tam istediğimiz büyüklükte
    dilimlere sahip olan yeni bir dilimli tahsisat sistemi yaratıp onu kullanabiliriz. Yeni bir dilimli tahsisat sisteminin 
    yaratılması kmem_cache_create fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/slab.h>

    struct kmem_cache *kmem_cache_create(const char *name, unsigned int size, 
            unsigned int align, slab_flags_t flags, void (*ctor)(void *));
"
    Fonksiyonun birinci parametresi yeni yaratılacak dilimli tahsisat sisteminin ismini belirtmektedir. (Bu isim sys dosya sisteminde 
    bir dizin biçiminde görüntülenebilmektedir.) Burada dilimli tahsisat sistemine herhangi bir isim verilebilir. Linux çekirdeğinde 
    dilimli tahsisat sistemlerine genellikle "xxx_cachep" biçiminde isimlendirilmektedir. İkinci parametre dilimlerin büyüklüğünü 
    belirtmektedir. Üçüncü parametre ise hizalama değerini belirtir. Bu hizalama değerine 0 geçilirse default hizalama kullanılır. 
    Varsayılan hizalama 32 bit sistemlerde 4 byte, 64 bit sistemlerde 8 byte'tır. Fonksiyonun dördüncü parametresi yaratılacak dilimli 
    tahsisat sistemine ilişkin bazı özelliklerin belirlenmesi için kullanılmaktadır. Buradaki bayrakların önemli birkaç tanesi şöyledir:

    SLAB_NO_REAP: Fiziksel RAM'in dolması nedeniyle kullanılmayan dilimlerin otomatik olarak sisteme iade edileceği anlamına gelir. 
    Uç durumlarda bu bayrak kullanılabilir.

    SLAB_HWCACHE_ALIGN: Bu bayrak özellikle SMP sistemlerinde işlemci ya da çekirdeklerin cache alanları için hizalama yapılmasını
    sağlamaktadır. Yaratım sırasında bu parametreyi kullanabilirsiniz.

    SLAB_CACHE_DMA: Bu parametre DMA alanında (DMA zone) tahsisat için kullanılmaktadır. Daha önceden de belirttiğimiz gibi bazı 
    sistemlerde fiziksel RAM'ın ancak bazı bölgelerine DMA tarafından erişilebilmektedir.

    Fonksiyonun son parametresi dilim sistemi yaratıldığında çağrılacak callback fonksiyonu belirtmektedir. Bu parametre için 
    girilecek fonksiyon her yeni dilim tahsis edildiğinde çağrılmaktadır. Böylece yeni bir dilim tahsis edileceği zaman bu fonksiyon
    içerisinde o dilime ilkdeğer verilebilir. Bu fonksiyona tahsis edilen dilimin başlangıç adresi geçirilmektedir. Bu parametre 
    NULL da geçilebilir. Bu durumda dilim tahsis edilirken herhangi bir fonksiyon çağrılmaz. kmem_cache_create fonksiyonu başarı 
    durumunda struct kmem_cache türünden bir yapı nesnesinin adresiyle, başarısızlık durumunda NULL adrese geri dönmektedir. 
    Başarısızlık durumunda aygıt sürücü fonksiyonunun -ENOMEM değeri ile geri döndürülmesi uygundur. Fonksiyon şöyle kullanılabilir:

    struct kmem_cache *g_pipe_cachep;

    if ((g_pipe_cachep = kmem_cache_create("pipe_driver_cachep", sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        ...
        return -ENOMEM;
    }

    Yaratılmış olan bir dilim sisteminden tahsisatlar kmem_cache_alloc fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <linux/slab.h>

    void *kmem_cache_alloc(struct kmem_cache *cache, int flags);

    Fonksiyonun birinci parametresi yaratılmış olan dilim sisteminin handle değerini, ikinci parametresi ise yaratım bayraklarını 
    almaktadır. Bu bayraklar kmalloc fonksiyonundaki bayraklarla aynıdır. Yani örneğin bu parametreye GFP_KERNEL geçilebilir. 
    Fonksiyon başarı durumunda tahsis edilen dilimin sanal adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Başarısızlık 
    durumunda aygıt sürücüdeki fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygundur. Örneğin:

    if ((g_pipe = (struct PIPE *)kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        ...
        return -ENOMEM;
    }

    kmem_cache_alloc fonksiyonu ile tahsis edilen dinamik alan kmem_cache_free fonksiyonu ile serbest bırakılabilir. Fonksiyonun
    prototipi şöyledir:

    #include <linux/slab.h>

    void kmem_cache_free(struct kmem_cache *cache, const void *obj);

    Fonksiyonun birinci parametresi dilim sisteminin handle değerini, ikincisi parametresi ise serbest bırakılacak dilimin 
    adresini belirtmektedir. Örneğin:

    kmem_cache_free(g_pipe_cachep, g_pipe);

    kmem_cache_create fonksiyonu ile yaratılmış olan dilim sistemi kmem_cache_destroy fonksiyonu ile serbest bırakılabilir. 
    Fonksiyonun prototipi şöyledir.

    #include <linux/slab.h>

    int kmem_cache_destroy(struct kmem_cache *cache);

    Fonksiyon dilim sisteminin handle değerini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    negatif errno değerine geri döner. Örneğin:

    kmem_cache_destroy(g_pipe);

    Peki kmalloc yerine yeni bir dilimli tahsisat sisteminin yaratılması tercih edilmeli midir? Yukarıda da belirttiğimiz
    gibi kmalloc fonksiyonu da aslında önceden yaratılmış belli uzunluktaki dilim sistemlerinden tahsisat yapmaktadır. Ancak 
    "çok sayıda aynı büyüklükte alanların" tahsis edildiği durumlarda programcının belli uzunlukta olan kendi dilim sistemini 
    yaratması, bunun dışındaki durumlarda genel amaçlı kmalloc fonksiyonunu tavsiye edilmektedir.

    Tabii kmalloc yerine yeni bir dilimli tahsisat sistemi yaratmanın anlamlı olması için çok sayıda aynı büyüklükte tahsisatın
    yapılıyor olması gerekir. Tek bir tahisat için ya da birkaç tahsisat için yeni bir dilimli tahsisat sistemi yaratmaya hiç 
    gerek yoktur. Doğrudan kmalloc fonksiyonu kullanılabilir.

    Örneğin boru aygıt sürücümüzde yeni bir dilim sisteminin yaratılmasına hiç gerek yoktur. Çünkü zaten boru aygıt sürücüsünde 
    tek bir struct PIPE yapı nesnesi yaratılmaktadır. Ancak biz aşağıdaki bu dilimli tahsisat sistemlerinin nasıl kullanıldığına 
    bir örnek vermek için bu struct PIPE nesnesini kendi yarattığımız dilimli tahsisat sisteminden tahsis ediyoruz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE       1024
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct kmem_cache *g_pipe_cachep;
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }
    if ((g_pipe_cachep = kmem_cache_create("pipe_cachep", sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        printk(KERN_ERR "cannot create pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }
    if ((g_pipe = (struct PIPE *) kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT4;
    }
    g_pipe->head = g_pipe->tail = g_pipe->count = 0;

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;

EXIT4:
    kmem_cache_destroy(g_pipe_cachep);
EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kmem_cache_free(g_pipe_cachep, g_pipe);
    kmem_cache_destroy(g_pipe_cachep);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0)
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0)
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz kmem_cache_create fonksiyonlarıyla yaratılmış olan dilimli tahsisat sistemlerini proc dosya sistemi ile görüntüleyebiliriz. 
    "/proc/slabinfo" dosyası çekirdek tarafından kullanılan yaratılmış dilimli tahsisat sistemleri hakkında bilgi vermektedir. 
    Ancak bu dosya bizim kmem_cache_create fonksiyonuyla yarattığımız dilimli tahsisat sistemlerini listelememektedir. sys 
    dosya sistemindeki "/sys/kernel/slab" dizini aygıt sürücülerin yaratmış oldukları da dahil olmak üzere bütün dilimli tahsisat 
    sistemleri hakkında bilgiler vermektedir. Burada her kmem_cache_create fonksiyonu ile yaratılmış olan dilimli tahsisat sistemi
    için ayrı bir dizin bulunmaktadır. Ayrıca çekirdeğin kullandığı dilimli tahsisat sistemlerini canlı olarak görüntülemek için
    "slabtop" isimli bir utility program da vardır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'un dosya sistemi için önemli üç yapı vardır. Bunlar file, dentry ve inode yapılarıdır. file isimli yapıya biz "dosya 
    nesnesi" demiştik. Anımsanacağı gibi ne zaman bir dosya açılsa dosya betimleyici tablosunda dosya betimleyicisi denilen bir 
    indeks bu dosya nesnesini gösterir duruma getirilmektedir. Dosya betimleyici tablosuna (file descriptor table) prosesi temsil 
    eden task_struct yapısından erişilmektedir.

    task_struct ------> dosya betimleyici tablosu

    Dosya Betimleyici Tablosu
    --------------------------

    0 ----> dosya nesnesi (struct file)
    1 ----> dosya nesnesi (struct file)
    2 ----> dosya nesnesi (struct file)
    3 ----> dosya nesnesi (struct file)
    ...

    Dosya nesnesi "açık dosyaların bilgilerini" tutmaktadır. Ne zaman sys_open sistem fonksiyonu çağrılsa sys_open sistem 
    fonksiyonu yeni bir dosya nesnesini (struct file) yaratır, onun adresini dosya betimleyici tablosunda boş bir slota yazar. 
    Bu slotun indeks numarasını dosya betimleyicisi olarak geri döndürür. Aynı dosya ikinci kez açılsa bile yeni bir dosya nesnesi 
    (struct file nesnesi) yaratılmaktadır. Daha önce biz bu struct file yapısının içeriğini görmüştük. Bunu yeniden anımsatmak 
    istiyoruz:

    struct file {
        union {
            /* fput() uses task work when closing and freeing file (default). */
            struct callback_head     f_task_work;
            /* fput() must use workqueue (most kernel threads). */
            struct llist_node    f_llist;
            unsigned int         f_iocb_flags;
        };

        /*
        * Protects f_ep, f_flags.
        * Must not be taken from IRQ context.
        */
        spinlock_t                f_lock;
        fmode_t                    f_mode;
        atomic_long_t            f_count;
        struct mutex            f_pos_lock;
        loff_t                    f_pos;
        unsigned int            f_flags;
        struct fown_struct        f_owner;
        const struct cred        *f_cred;
        struct file_ra_state    f_ra;
        struct path                f_path;
        struct inode            *f_inode;    /* cached value */
        const struct file_operations    *f_op;
        u64            f_version;
    #ifdef CONFIG_SECURITY
        void            *f_security;
    #endif
        /* needed for tty driver, and maybe others */
        void            *private_data;

    #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct hlist_head    *f_ep;
    #endif /* #ifdef CONFIG_EPOLL */
        struct address_space    *f_mapping;
        errseq_t        f_wb_err;
        errseq_t        f_sb_err; /* for syncfs */
    } __randomize_layout
    __attribute__((aligned(4)));    /* lest something weird decides that 2 is OK */

    Eskiden dosya nesnesi dentry nesnesini, dentry nesnesi de inode nesnesini gösteriyordu. Yani durum şöyleydir:

    File ──▶ dentry ──▶ inode

    Daha sonraları dosya nesnesinin içerisinden inode nesnesine daha hızlı erişebilmek için dosya nesnesinin içerisine (yani
    file yapısının içerisine) doğrudan bir inode göstericisi daha eklenmiştir. Mevcut durum şöyledir:

    File ──▶ dentry ──▶ inode
    ╰──────────────────────▶

    inode yapısı dosyanın diskteki bilgilerini tutmaktadır. Yani örneğin aynı dosya üç kez açılsa çekirdek üç farklı file nesnesi 
    oluşturmaktadır. Ancak bu dosya diskte bir tane olduğuna göre çekirdek bunun için toplamda bir tane inode yapısı oluşturacaktır.
    Mevcut çekirdeklerde file yapısının içerisinde dosyanın diskteki bilgilerine ilişkin bu inode yapısına f_inode elemanı yoluyla 
    erişilebilmektedir. Linux işletim sistemi aynı zamanda diskte son erişilen dosyalara ilişkin i-node elemanlarını inode yapısı 
    biçiminde bir cache sisteminde de tutmaktadır. Buna "inode cache" denilmektedir. Örneğin biz "test.txt" isimli bir dosyayı 
    sys_open sistem fonksiyonuyla açmış olalım. İşletim sistemi bunun için bir dosya nesnesi oluşturacak ve bu dosyaya ilişkin 
    inode nesnesi zaten inode cache içerisinde varsa onu cache'ten alıp kullanacaktır. Eğer bu dosyaya ilişkin inode nesnesi 
    "inode cache" içerisinde yoksa işletim sistemi dosyaya ilişkin inode bilgilerini diskten bulup inode nesnesini oluşturacak
    ve "inode cache" içerisine yerleştirecektir. Bu dosya kapatıldığında da işletim sistemi inode yapısını çekirdek alanından 
    atmaz bu inode nesnesi "inode cache" içerisinde kalmaya devam eder. Tabii bu "inode cache" içerisinde belli sayıda inode 
    elemanı tutulmaktadır. Bu cache sistemi dolduğunda LRU (Least Recently Used) algoritmasına göre son zamanlarda en az kullanılan 
    inode elemanı cache'ten atılmaktadır.

    Linux çekirdeğinde dosyanın i-node elemanına erişmekte kullanılan dizin girişleri dentry isimli bir yapıyla temsil edilmiştir. 
    inode yapısı dosyanın diskteki bilgilerini tutarken dentry yapısı dosyanın dizin girişi bilgilerini tutmaktadır. Yukarıda da 
    belirttiğimiz gibi dentry nesnesinin içerisinde inode nesnesinin adresi tutulmaktadır. Örneğin farklı dentry nesneleri aynı 
    inode nesnesini gösteriyor olabilir. Bu tür durumlar "hard link" yoluyla oluşturulmaktadır. Açılmış dosyanın hangi dizinlerin 
    içerisinde bulunduğu bilgisi dentry nesnelerinde tutulmaktadır. Linux işletim sistemi nasıl inode nesnelerini bir cache sisteminde 
    tutuyorsa dentry nesnelerini de ismine "dentry cache" denilen bir cache sistemi içerisinde tutmaktadır. Bir dosyanın open 
    fonksiyonuyla (bu POSIX fonksiyonu doğrudan sys_open sistem fonksiyonunu çağırmaktadır) açıldığını varsayalım. Dosyaya ilişkin 
    dizin girişi bilgilerinin elde edilmesi için ismine "pathname resolution" denilen bir işlem yapılmaktadır. Örneğin biz 
    "/home/kaan/Study/test.txt" dosyasını açmak isteyelim. İşletim sistemi bunun için önce "/home" dizin girişini sonra home 
    dizininde "kaan" dizin girişini, sonra "kaan" dizininde "Study" dizin girişini sonra da "Study" dizininde "test.txt" dizin 
    girişini bulacaktır. İşte tüm bu dizin girişleri aynı zamanda "dentry cache" içerisinde de saklanmaktadır. Böylece bu dosyaya 
    bir daha erişilmek istendiğinde doğrudan bu dizin girişi bilgileri "dentry cache" içerisinden elde edilebilmektedir. Linux 
    işletim sistemi her zaman eğer bir dosyanın dentry nesnesi çekirdek içerisindeyse onun tüm yol ifadesine ilişkin dentry nesnelerini 
    de çekirdek içerisinde tutmaktadır. "dentry cache" sistemi de LRU prensibiyle çalışan bir cache sistemidir.

    Daha önceden de gördüğümüz gibi Bir aygıt sürücü üzerinde dosya işlemi yapıldığında çekirdek aygıt sürücü fonksiyonlarına 
    dosya nesnesinin adresini (filp parametre değişkeni) geçirmektedir. Yalnızca aygıt sürücü open fonksiyonuyla açılırken ve 
    close fonksiyonu ile kapatılırken inode nesnesinin adresi de bu fonksiyonlara geçirilmektedir. Aygıt sürücünün fonksiyonlarının 
    parametrik yapılarını aşağıda yeniden veriyoruz:

    int open(struct inode *inodep, struct file *filp);
    int release(struct inode *inodep, struct file *filp);
    ssize_t read(struct file *filp, char *buf, size_t size, loff_t *off);
    ssize_t write(struct file *filp, const char *buf, size_t size, loff_t *off);
    loff_t llseek(struct file *filp, loff_t off, int whence);
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                102. Ders 15/05/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücünün majör ve minör numaraları ne anlam ifade etmektedir? Majör numara aygıt sürücünün türünü, minör numara ise 
    aynı türden aygıt sürücülerin farklı örneklerini (instance'larını) belirtmektedir. Başka bir deyişle minör numara aygıt sürücünün 
    yönettiği aygıtların numaralarını belirtmektedir. Örneğin biz yukarıdaki "pipe-driver" aygıt sürücümüzün tek bir boruyu değil 
    on farklı boruyu idare etmesini isteyebiliriz. Bu durumda aygıt sürücümüzün bir tane majör numarası ancak 10 tane minör numarası 
    olacaktır. Aygıt sürücülerin majör numaraları aynı ise bunların kodları da aynıdır. O aynı kod birden fazla aygıt için işlev 
    görmektedir. Örneğin seri portu kontrol eden bir aygıt sürücü söz konusu olsun. Ancak bilgisayarımızda dört seri port olsun. 
    İşte bu durumda bu seri porta ilişkin aygıt dosyalarının hepsinin majör numaraları aynıdır. Ancak minör numaraları farklıdır. 
    Ya da örneğin terminal aygıt sürücüsü bir tanedir. Ancak bu aygıt sürücü birden fazla terminali yönetebilmektedir. O halde her 
    terminale ilişkin aygıt dosyasının majör numaraları aynı minör numaraları farklı olacaktır. Örneğin:

    $ ls -l tty1 tty2 tty3 tty4 tty5
    crw--w---- 1 root tty 4, 1 Haz  2 15:05 tty1
    crw--w---- 1 root tty 4, 2 Haz  2 15:05 tty2
    crw--w---- 1 root tty 4, 3 Haz  2 15:05 tty3
    crw--w---- 1 root tty 4, 4 Haz  2 15:05 tty4
    crw--w---- 1 root tty 4, 5 Haz  2 15:05 tty5

    Örneğin diskleri yöneten bir aygıt sürücüsü olsun. Ancak bilgisayarımızda üç farklı fiziksel disk olsun. Bu disklerin 
    yönetimleri aynı biçimde aynı kodlarla yapılmaktadır. Bunları yöneten tek bir aygıt sürücü kodu dolayısıyla majör numarası 
    vardır. Ancak her disk ayrı bir minör numarayla temsil edilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir aygıt sürücünün aynı türden birden fazla aygıtı nasıl yönetebileceğini ele alacağız. Birden fazla aygıtı yönetecek 
    (yani birden fazla minör numaraya sahip olan) bir aygıt sürücü nasıl yazılabilir? Her şeyden önce birden fazla minör numara 
    kullanan aygıt sürücüleri yazarken dikkatli olmak gerekir. Çünkü tek bir kod birden fazla aynı türden bağımsız aygıtı idare 
    edecektir. Dolayısıyla bu tür durumlarda bazı nesnelerin senkronize edilmesi gerekebilir.

    Birden fazla minör numara üzerinde çalışacak (yani birden fazla aynı türden aygıt üzerinde çalışacak) aygıt sürücüler tipik 
    olarak şöyle yazılmaktadır:

    1) Aygıt sürücüyü yazan programcı baştan onun kaç minör numaraya ilişkin aygıtı yöneteceğini belirlemelidir. Bunun için default
    bir değer kullanılabilir. Ancak genellikle aygıt sürücünün kaç minör numaraya ilişkin aygıtı yöneteceği aygıt sürücüye komut 
    satırı argümanlarıyla (yani modül parametreleriyle) geçirilmektedir. Biz de örneğimizde bu yöntemi kullanacağız. Minör numara 
    sayısının aşağıdaki gibi ndevices isimli parametre yoluyla komut satırından aygıt sürücüye aktarıldığını varsayacağız:

    #define DEF_NDEVICES        10
    ...
    static int ndevices = DEF_NDEVICES;
    module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Bu durumda bu aygıt sürücü yüklenirken ndevices parametresi girilmezse DEF_NDEVICES değeri dikkate alınmaktadır. Örneğin bu 
    aygıt sürücüyü 5 aygıtı yönetecek biçimde aşağıdaki gibi yükleyebiliriz:

    ./insmod pipe-driver.ko ndevices=5

    2) Programcının aygıt sürücü için majör ve minör numaraları tahsis etmesi gerekir. Daha önce yaptığımız gibi majör numara 
    alloc_chrdev_region fonksiyonuyla dinamik olarak belirlenebilmektedir. Bu fonksiyon anımsanacağı gibi aynı zamanda belli bir 
    minör numaradan başlayarak n tane minör numarayı da tahsis edebilmektedir. Örneğin:

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    Burada 0'ıncı minör numaradan ndevices tane minör numara için aygıt tahsisatı yapılmıştır. Tabii g_dev nesnesi yalnızca ilk 
    minör numaraya ilişkin (örneğimizde 0) aygıt numarasını tutmaktadır.

    3) Her aygıt bir yapıyla temsil edilmelidir. Bunun için N elemanlı bir yapı dizisi yaratabilirsiniz. Bu dizi global düzeyde 
    tanımlanabileceği gibi kmalloc fonksiyonuyla dinamik biçimde de tahsis edilebilir. Biz örneğimizde her PIPE_DEVICE yapısını 
    ayrı bir kmalloc fonksiyonu ile tahsis ettik. Bunların adreslerini de yine kmalloc fonksiyonuyla tahsis ettiğimiz bir gösterici
    dizisine yerleştirdik. cdev nesnesi kesinlikle aygıtı temsil eden yapının (bizim örneğimizde PIPE_DEVICE yapısının) içerisinde 
    bulundurulmalıdır. Çünkü çekirdek bize bu nesnenin adresini geri verebilmektedir. Biz de bu sayede aygıt yapısına erişebiliriz. 
    Örneğimizdeki aygıtı temsil eden PIPE_DEVICE yapısı şöyledir:
       
    struct PIPE_DEVICE {
        unsigned char buf[PIPE_BUFFER_SIZE];
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Burada görüldüğü gibi her farklı borunun farklı bekleme kuyrukları ve semaphore nesnesi vardır. cdev yapı nesnesinin yapının 
    içerisine yerleştirilmesinin amacı ileride görüleceği gibi bu nenenin adresten hareketle aygıt nesnesinin başlangıç adresinin 
    elde edilmesini sağlamaktır. Bunun nasıl yapıldığı izleyen paragraflarda görülecektir.

    Aygıt nenseleri aşağıdaki gibi tahsis edilmiştir:

    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    

    Burada önce aygıt nesnelerini tutan gösterici dizisi için tahsisat yapımış daha sonra da aygıt nesneleri için tahsisat 
    yapılmıştır. Tabii aslında biz tek hamlede de (yanş tek bir kmalloc ile de) tüm tahsisatı yapabilirdik.

    4) N tane minör numaralı aygıt için cdev_add fonksiyonuyla aygıtlar çekirdeğe eklenmelidir. Örneğin:

        for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }

    Burada yapı dizisinin her elemanındaki elemanlara ilkdeğerleri verilmiştir. Sonra her boru için ayrı bir cdev nesnesi cdev_add 
    fonksiyonu ile eklenmiştir. Eklemelerden biri başarısız olursa daha önce eklenenlerin de cdev_del fonksiyonu ile silindiğine 
    dikkat ediniz.

    5) Aygıt sürücünün exit fonksiyonunda tahsis edilen tüm kaynaklar ters sırada geri bırakılmalıdır. Örneğin:

    static void __exit pipe_driver_exit(void)
    {
        int i;

        for (i = 0; i < ndevices; ++i)
            cdev_del(&g_devices[i]->cdev);
        for (i = 0; i < ndevices; ++i)
            kfree(g_devices[i]);
        kfree(g_devices);

        unregister_chrdev_region(g_dev, ndevices);
        
        printk(KERN_INFO "pipe-driver module exit...\n");
    }

    6) Bizim read, write gibi aygıt sürücü fonksiyonlarında file yapısı türünden adres belirten filp parametre değişkeni yoluyla 
    PIPE_DEVICE yapısına erişmemiz gerekir. Bu işlem dolaylı bir biçimde şöyle yapılmaktadır:
  
    - Önce aygıt sürücünün open fonksiyonunda programcı inode yapısının i_cdev elemanından hareketle cdev nesnesinin içinde 
    bulunduğu yapı nesnesinin başlangıç adresini container_of makrosuyla elde eder. inode yapısının i_cdev elemanı cdev_add
    fonksiyonuyla eklenen cdev yapı nesnesinin adresini tutmaktadır. container_of bir yapının bir elemanın adresini, o elemanın 
    ismini ve yapının ismini alarak yapı nesnesinin başlangıç adresini veren bir makrodur. container_of makrosu C standartlarında 
    bulunan bir makro değildir. Ancak bu makro C standartlarında bulunan offsetof makrosu kullanılarak yazılabilir. Anımsanacağı 
    gibi C'de offsetof makrosu bir yapının bir elemanının yapının başından itibaren kaçıncı offset'te olduğunu bize vermektedir. 
    offsetof makrosu şöyle yazabiliriz:

    #define my_offsetof(type, member)     ((size_t)&((type *)0)->member)

    Burada gerçek anlamda 0 adresine erişim yapılmamaktadır. C standartlarına göre bir gösterici ile onun gösterdiği yere erişilip 
    oranın adresi alındığında derleyici gerçek bir erişim yapmaz. İşte offsetof makrosu kullanılarak container_of makrosu de 
    şöyle yazılabilir:

    #define my_container_of(ptr, type, member)   ((type *)((char *)(ptr) - my_offsetof(type, member)))

    Makronun birinci parametresi yapı elemanın adresini, ikinci parametresi yapının tür ismini, üçüncü parametresi ise adresi 
    verilen yapı elemanının ismini almaktadır. Bu makro yapı nesnesinin bütünsel adresine geri dönmektedir. 

    Yukarıda da belirttiğimiz gibi Programcı cdev nesnesinin adresini inode yapısının i_cdev elemanından geri alabilmektedir. İşte 
    bu adres yoluyla da container_of makrosunu kullanarak aygıt nesnesinin adresini (örneğimizde PIPE_DEVICE nesnesinin adresini) 
    elde eder. İşte programcı aygıt nesnesinin adresini elde ettikten sonra onu file yapısının private_data elemanına yerleştirir. 
    file yapısının private_data elemanı programcının kendisinin yerleştirdiği bilgileri tutmak için bulundurulmuştur. Burada bir 
    noktaya dikkat ediniz: inode nesnesinin adresi yalnızca aygıt sürücünün open ve release fonksiyonlarına geçirilmektedir. read 
    ve write gibi fonksiyonlara file nesnesinin adresi (filp parametresi) geçirilmektedir. O halde programcı aygıt sürücünün open
    fonksiyonu içerisinde aygıt nesnesinin adresini elde edip onu file nesnesinin içerisine yerleştirmelidir. Bu işlemler tipik 
    olarak aşağıdaki gibi yapılabilir:

    static int pipe_open(struct inode *inodep, struct file *filp)
    {
        struct PIPE_DEVICE *pipedev;
        int accmode = filp->f_flags & O_ACCMODE;

        pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
        filp->private_data = pipedev;

        /* ... */

        printk(KERN_INFO "pipe-driver opened...\n");

        return 0;
    }

    7) Aygıt sürücünün read ve write fonksiyonları yazılır.

    8) release (close) işleminde yapılacak birtakım son işlemler varsa yapılır.

    9) Birden fazla minör numara için çalışacak aygıt sürücüler için birden fazla aygıt dosyasının yaratılması gerekir. Yani 
    aygıt sürücü kaç minör numarayı destekliyorsa o sayıda aygıt dosyası yaratılmalıdır. Bu da onları yüklemek için kullandığımız 
    "load" script'inde değişiklik yapmayı gerektirmektedir. N tane minör numaraya ilişkin aygıt dosyası yaratacak biçimde yeni bir 
    "loadmulti" script'i aşağıdaki gibi yazılabilir:

    #!/bin/bash

    module=$2
    mode=666

    /sbin/insmod ./${module}.ko ${@:3} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
        mknod -m $mode ${module}$i c $major $i
    done

    Buradaki "loadmulti" script'i iki komut satırı argümanıyla aşağıdaki örnekteki gibi çalıştırılmalıdır:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Burada "loadmulti" script'i hem aygıt sürücüyü yükleyecek hem de pipe-driver0, pipe-driver1, ..., pipedriver9 biçiminde 
    aygıt dosyalarını yaratacaktır. Aşağıda yaratılmış olan örnek aygıt dosyalarına dikkat ediniz:

    crw-rw-rw- 1 root root  236, 0 Haz  7 22:09 pipe-driver0
    crw-rw-rw- 1 root root  236, 1 Haz  7 22:09 pipe-driver1
    crw-rw-rw- 1 root root  236, 2 Haz  7 22:09 pipe-driver2
    crw-rw-rw- 1 root root  236, 3 Haz  7 22:09 pipe-driver3
    crw-rw-rw- 1 root root  236, 4 Haz  7 22:09 pipe-driver4
    crw-rw-rw- 1 root root  236, 5 Haz  7 22:09 pipe-driver5
    crw-rw-rw- 1 root root  236, 6 Haz  7 22:09 pipe-driver6
    crw-rw-rw- 1 root root  236, 7 Haz  7 22:09 pipe-driver7
    crw-rw-rw- 1 root root  236, 8 Haz  7 22:09 pipe-driver8
    crw-rw-rw- 1 root root  236, 9 Haz  7 22:09 pipe-driver9

    Aygıt dosyalarının majör numaralarının hepsi aynıdır ancak minör numaraları farklıdır. Burada artık adeta birbirinden bağımsız 
    10 ayrı boru aygıtı var gibidir. Ancak aslında tek bir aygıt sürücü kodu bulunmaktadır. Tabii bizim benzer biçimde "unload"
    script'ini de tüm aygıt dosyalarını silecek biçimde düzeltmemiz gerekir. Bunun için "unloadmulti" script'ini aşağıdaki gibi
    yazabiliriz:

    #!/bin/bash

    module=$2

    /sbin/rmmod ./$module.ko || exit 1
    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
    done

    Bu script'te biz önce modülü çekirdekten sonra da "loadmulti" ile yarattığımız aygıt dosyalarını dosya sisteminden silmekteyiz. 
    Script aşağıdaki örnekteki gibi kullanılmalıdır:

    $ sudo ./unloadmulti 10 pipe-driver

    Şimdi ndevices kadar minör numarayı destekleyen aygıt sürücü kodunun tamamını veriyoruz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define DEF_NDEVICES            10
#define PIPE_BUFFER_SIZE           10

#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE_DEVICE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqwriteopen;
    wait_queue_head_t wqreadopen;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    int nreaders;
    int nwriters;
    struct cdev cdev;
};
static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
    int result;
    int i, k;
    dev_t dev;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate pipe device!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    
    
    for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }    
    return 0;
EXIT4:
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
EXIT3:
    kfree(g_devices);
EXIT2:
    unregister_chrdev_region(g_dev, ndevices);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    int i;

    for (i = 0; i < ndevices; ++i)
        cdev_del(&g_devices[i]->cdev);
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
    kfree(g_devices);

    unregister_chrdev_region(g_dev, ndevices);
    
    printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
    filp->private_data = pipedev;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++pipedev->nreaders;
        wake_up_interruptible(&pipedev->wqwriteopen);
        while (pipedev->nwriters == 0) {
            up(&pipedev->sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        while (pipedev->nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --pipedev->nwriters;
                up(&pipedev->sem);
                return -ENXIO;
            }
            up(&pipedev->sem);
            if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++pipedev->nreaders;
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        wake_up_interruptible(&pipedev->wqwriteopen);
    }
    up(&pipedev->sem);

    printk(KERN_INFO "pipe-driver opened...\n");
    
    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --pipedev->nreaders;
    else if (accmode == O_WRONLY)
        --pipedev->nwriters;
    else if (accmode == O_RDWR) {
        --pipedev->nreaders;
        --pipedev->nwriters;
    }
    if (pipedev->nreaders == 0)
        wake_up_interruptible(&pipedev->wqwrite);
    if (pipedev->nwriters == 0)
        wake_up_interruptible(&pipedev->wqread);

    if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;
    
    up(&pipedev->sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    while (pipedev->count == 0) {
        if (pipedev->nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, pipedev->count);
    if (pipedev->head >= pipedev->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
            goto EXIT;

    pipedev->head = (pipedev->head + esize) % PIPE_BUFFER_SIZE;
    pipedev->count -= esize;

    result = esize;

    wake_up_interruptible(&pipedev->wqwrite);
EXIT:
    up(&pipedev->sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (pipedev->nreaders == 0) {
        up(&pipedev->sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - pipedev->count < size) {
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqwrite, PIPE_BUFFER_SIZE - pipedev->count >= size || pipedev->nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
        if (pipedev->nreaders == 0) {
            up(&pipedev->sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - pipedev->count);

    if (pipedev->tail >= pipedev->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
            goto EXIT;

    pipedev->tail = (pipedev->tail + esize ) % PIPE_BUFFER_SIZE;
    pipedev->count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&pipedev->wqread);
    up(&pipedev->sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

//* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                        104. Ders 27/05/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüden bilgi okumak için read fonksiyonun, aygıt sürücüye bilgi göndermek için ise write fonksiyonun kullanıldığını 
    gördük. Ancak bazen aygıt sürücüye write fonksiyonunu kullanmadan bazı bilgilerin gönderilmesi, aygıt sürücüden read 
    fonksiyonunu kullanmadan da bazı bilgilerin alınması gerekebilmektedir. Bazen hiç bilgi okumadan ve bilgi göndermeden aygıt 
    sürüceden bazı şeyleri yapmasını da isteyebiliriz. Bu tür bazı işlemlerin read ve write fonksiyonlarıyla yaptırılması mümkün 
    olsa bile kullanışsızdır.

    Örneğin yukarıdaki boru aygıt sürücümüzde (pipe-driver) biz aygıt sürücüden kullandığı FIFO alanının uzunluğunu isteyebiliriz. 
    Ya da bu alanın boyutunu değiştirmek isteyebiliriz. Bu işlemleri read ve write fonksiyonlarıyla yapmaya çalışsak aygıt 
    sürücümüz sanki boruyu temsil eden kuyruktan okuma yazma yapmak istediğimizi sanacaktır. Tabii yukarıda da belirttiğimiz 
    gibi zorlanırsa bu tür işlemler read ve write fonksiyonlarıyla yine de yapılabilir. Ancak böyle bir kullanımın mümkün hale 
    getirilmesi ve user mode'dan kullanılması oldukça zor olacaktır.

    İşte aygıt sürücüye komut gönderip ondan bilgi almak ya da ona bazı işlemleri yaptırmak için genel amaçlı ioctl isminde 
    özel bir POSIX fonksiyonu bulundurulmuştur. Linux sistemlerinde ioctl fonksiyonu sys_ioctl isimli sistem fonksiyonunu 
    çağırmaktadır. ioctl fonksiyonunun parametrik yapısı şöyledir:

    #include <sys/ioctl.h>

    int ioctl(int fd, unsigned long request, ...);

    Fonksiyonun birinci parametresi aygıt sürücüye ilişkin dosya betimleyicisini belirtir. İkinci parametre ileride açıklanacak 
    olan komut kodudur. Aygıt sürücüsünü yazan programcı aygıt sürücüsünde farklı komutlar için farklı komut kodları (yani numaralar) 
    oluşturur. Sonra bu komut kodlarını switch içerisine sokarak hangi numaralı istekte bulunulmuşsa ona yönelik işlemleri yapar. 
    ioctl fonksiyonu iki parametreyle ya da üç parametreyle kullanılmaktadır. Yani fonksiyonun üçüncü parametresi isteğe bağlıdır. 
    Eğer bir veri transferi söz konusu değilse ioctl genellikle iki argümanla çağrılır. Ancak bir veri transferi söz konusu ise 
    ioctl üç argümanla çağrılmalıdır. Bu durumda üçüncü argüman user mode'daki transfer adresini belirtir. Tabii aslında bu üçüncü 
    parametrenin veri transferi ile ilgili olması dolayısıyla da bir adres belirtmesi zorunlu değildir.

    ioctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner. errno uygun biçimde set 
    edilmektedir. Örneğin:

    if (ioctl(fd, command_code) == -1)
        exit_sys("ioctl");

    Aslında çoğu kez uygulama programcıları ioctl çağrılarını doğrudan yapmamaktadır. Aygıt sürücüleri ayzanlar bu çağrıları 
    yapan daha yüksek seviyeli kütüphaneler (yani API'ler) oluşturup bu kütüphaneleri uygulama programcılarına vermektedir. 
    Yani çoğu kez aşaığıdaki gibi bir katmalı yapı söz konusu olmaktadır:

    +---------------------------+
    | Yüksek Seviyeli Kütüphane |
    +---------------------------+
    |        IOCTL Kodları      |
    +---------------------------+
    |        Aygıt Sürücü       |
    +---------------------------+
    |          Çekirdek         |
    +---------------------------+

    Buradaki "Yüksek Seviyeli Kütüphane" ioctl çağrılarını yapan fonksiyonlardan oluşmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki bir program aygıt sürücü için ioctl fonksiyonunu çağırdığında akış kullanıcı modundan çekirdke moduna 
    geçer ve aygıt sürücüdeki file_operations yapısının unlocked_ioctl elemanında belirtilen fonksiyon çağrılır. Bu fonksiyonun 
    parametrik yapısı şöyle olmalıdır:

    long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

    Fonksiyonun birinci parametresi yine dosya nesnesinin adresini, ikinci parametresi ioctl fonksiyonunda kullanılan komut 
    kodunu (yani ioctl fonksiyonuna geçirilen ikinci argümanı) ve üçüncü parametresi de ek argümanı (yani ioctl fonksiyonuna 
    geçirilen üçüncü argümanı) belirtmektedir. Tabii programcının eğer ioctl fonksiyonu iki argümanlı çağrılmışsa bu üçüncü 
    parametreye erişmemesi gerekir.

    Bu fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif hata koduna geri dönmelidir. Fakat bazen programcı 
    doğrudan iletilecek değeri geri dönüş değeri biçiminde oluşturabilir. Bu durumda geri dönüş değeri pozitif değer olabilir.
    Örneğin:

    static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
    ...

    static struct file_operations g_fops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .read = generic_read,
        .write = generic_write,
        .release = generic_release,
        .unlocked_ioctl = generic_ioctl
    };
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ioctl işleminde ioctl fonksiyonunun ikinci parametresi olan kontrol kodu dört parçanın bit düzeyinde birleştirilmesiyle
    oluşturulmaktadır. Bu dört parçnın 32 bit içerisindeki bit genişlikleri ve pozisyonları şöyledir:

    31     30 29           22 21            14 13              0
    +--------+---------------+----------------+----------------+
    |  Dir   |     Type      |     Number     |     Size       |
    +--------+---------------+----------------+----------------+
      2 bits      8 bits           8 bits          14 bits 
    
    Ancak bu parçalara ilişkin bitlerin 32 bit içerisinde belli pozisyonlara yerleştirilmesini kolaylaştırmak için _IOC isimli 
    bir makro bulundurulmuştur. Bu makronun parametreleri şöyledir:

    _IOC(dir, type, nr, size)

    Bu makro buradaki parçaları bit düzeyinde birleştirerek 4 byte'lık bir değer vermektedir. Makronun parametrelerini oluşturan 
    dört parçanın anlamları ve bit uzunlukları şöyledir:

    dir (direction): Bu 2 bitlik bir alandır ([30, 31] bitler). Burada kullanılacak sembolik sabitler _IOC_NONE, _IOC_READ, 
    _IOC_WRITE ve _IOC_READ|_IOC_WRITE biçimindedir. Buradaki _IOC_READ aygıt sürücüden bilgi alınacağını _IOC_WRITE ise aygıt 
    sürücüye bilgi gönderileceğini belirtmektedir. Ancak bu yön ioctl sistem fonksiyonu tarafından dosyanın açış moduyla kontrol
    edilmemektedir. Örneğin biz buradaki yönü _IOC_READ|_IOC_WRITE biçiminde vermiş olsak bile aygıt dosyaısnı O_RDONLY modunda 
    açıp bu ioctl işlemini yapabiliriz. Çekirdek hiçbir işlemde bu yön bilgisini kontrol etmemektedir. Eğer programcı böyle bir 
    kontrol yapmak istiyorsa aygıt sürücünün ioctl fonksiyonu içerisinde bunu yapmalıdır. Buradaki sembolil sabitler tipik olarak 
    şu değerlerdedir:

    #define _IOC_NONE       0U
    #define _IOC_WRITE      1U
    #define _IOC_READ       2U
    
    type: Bu 8 bitlik bir alandır ([22, 29] bitleri). Bu alana aygıt sürücüyü yazan istediği herhangi bir byte'ı verebilir. 
    Genellikle bu byte bir karakter sabiti olarak verilmektedir. Buna "magic number" da denilmektedir.

    nr: Bu 8 bitlik bir alandır ([14, 21] bitleri). Programcı tarafından kontrol koduna verilen sıra numarasını temsil etmektedir. 
    Genellikle aygıt sürücü programcıları 0'dan başlayarak her koda bir numara vermektedir.

    size: Bu 14 bitlik bir alandır ([0, 13] bitleri). Bu alan kaç byte'lık bir transferin yapılacağını belirtmektedir. Buradaki 
    size değeri aslında çekirdek tarafından kullanılmamaktadır. Dolayısıyla biz 14 bitten daha büyük transferleri de yapabiliriz.

    Kullanım kolaylığı sağlamak için genellikle _IOC makrosu bir sembolik sabit biçiminde define edilir. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO            _IOC(_IOC_READ, GENERAL_DRIVER_MAGIC, 0, 4)

    Aslında _IOC makrosundan daha kolay kullanılabilen aşağıdaki makrolar da oluşturulmuştur:

    #ifndef __KERNEL__
        #define _IOC_TYPECHECK(t) (sizeof(t))
    #endif

    #define _IO(type,nr)                _IOC(_IOC_NONE,(type),(nr),0)
    #define _IOR(type,nr,size)          _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOW(type,nr,size)          _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOWR(type,nr,size)         _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))

    Bu makrolarda _IOC makrosunun birinci parametresinin artık belirtilmediğine dikkat ediniz. Çünkü makrolar zaten isimlerine
    göre _IOC makrosunun birinci parametresini kendisi oluşturmaktadır. Ayrıca artık uzunluk (size parametresi) byte olarak 
    değil tür olarak belirtilmelidir. Makrolar bu türleri sizeof operatörüne kendisi sokmaktadır. Görüldüğü gibi _IO makrosu 
    veri transferinin söz konusu olmadığı durumda kullanılır. _IOR aygıt sürücüden okuma yapıldığı durumda, _IOW aygıt sürücüye 
    yazma yapıldığı durumda, _IOWR ise aygıt sürücüden hem okuma hem de yazma yapıldığı durumlarda kullanılmaktadır. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO        _IOR(GENERAL_DRIVER_MAGIC, 0, int)

    ioctl için kontrol kodları hem aygıt sürücünün içerisinden hem de user kullanıcı modundan kullanılacağına göre ortak bir 
    başlık dosyasının oluşturulması uygun olabilir. Burada ioctl kontrol kodları bulundurulabilir. Örneğin boru aygıt sürücümüz 
    için "pipe-driver.h" dosyası aşağıdaki gibi düzenlenebilir:

    /* ioctl-driver.h */

    #ifndef IOOCTL_DRIVER_H_
    #define IOCTL_DRIVER_H_

    #include <linux/stddef.h>
    #include <linux/ioctl.h>

    #define GENERIC_DRIVER_MAGIC        'g'
    #define IOC_GENERIC_TEST            _IO(GENERIC_DRIVER_MAGIC, 0)

    #endif

    Aygıt sürücüdeki ioctl fonksiyonunu yazarken iki noktaya dikkat etmek gerekir:

    1) ioctl fonksiyonunun üçüncü parametresi unsigned long türden olmasına karşın aslında genellikle kullanıcı modunda çalışan 
    programcı buraya bir nesnesin adresini geçirmektedir. Dolayısıyla bu transfer adresine aktarım gerekmektedir. Bunun için 
    copy_to_user, copy_from_use, put_user, get_user gibi "adresin geçerliliğini sorguladıktan sonra transfer yapan fonksiyonlar" 
    kullanılabilir.

    2) Kullanıcı modunda çalışan programcının olmayan bir komut kodu girmesi durumunda ioctl fonksiyonu -ENOTTY değeri ile geri 
    döndürülmelidir. Bu tuhaf hata kodu (TTY teletype terminal sözcüklerinden kısaltmadır) tarihsel bir durumdan kaynaklanmaktadır. 
    Bu hata kodu için kullanıcı modunda "Inappropriate ioctl for device" biçiminde bir hata yazısı elde edilmektedir.

    Kullanıcı modundaki ioctl fonksiyonu başarı durumunda 0 değerine geri döndüğü için aygıt sürücüdeki ioctl fonksiyonu da genel 
    olarak başarı durumunda 0 ile geri döndürülmelidir. Yukarıda da belirttiğimiz gibi olmayan bir ioctl kodu için aygıt sürücüdeki
    fonksiyonun -ENOTTY ile geri döndürülmesi uygundur. Bazı aygıt sürücülerinde başarı durumunda aygıt sürücüden bilgi ioctl 
    fonksiyonunun üçüncü parametresi yoluyla değil geri dönüş değeri yoluyla elde edilmektedir. Bu durumda aygıt sürücüdeki ioctl 
    fonksiyonu pozitif değerle de geri döndürülebilir. Ancak bu durum seyrektir. Biz veri transferinin ioctl fonksiyonunun üçüncü 
    parametresi yoluyla yapılmasını tavsiye ediyoruz.

    Aygıt sürücüdeki ioctl fonksiyonu tipik olarak bir switch deyimi ile gerçekleştirilmektedir. Örneğin:

   static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
        printk(KERN_INFO "generic_ioctl...\n");

        switch (cmd) {
            case IOC_GENERIC_TEST1:
                result = ioctl_generic_test1(filp, arg);
                break;
            case IOC_GENERIC_TEST2:
                result = ioctl_generic_test2(filp, arg);
                break;
            case IOC_GENERIC_TEST3:
                result = ioctl_generic_test3(filp, arg);
                break;
            case IOC_GENERIC_TEST4:
                result = ioctl_generic_test4(filp, arg);
                break;
            case IOC_GENERIC_TEST5:
                result = ioctl_generic_test5(filp, arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada switch deyiminin default bölümünde fonksiyonun -NOTTY değeri ile geri döndürüldüğüne dikkat ediniz. Tabii fonksiyon
    üçüncü parametresi ile belirtilen transfer adresi geçersiz bir adresse yine -EFAULT değeri ile geri döndürülmelidir.

    Aşağıda iskelet bir ioctl örneği verilmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

 /* ioctl-driver.h */

#ifndef GENERIC_DRIVER_H_
#define GENERIC_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define GENERIC_DRIVER_MAGIC		'g'
#define IOC_GENERIC_TEST1		    _IO(GENERIC_DRIVER_MAGIC, 0)
#define IOC_GENERIC_TEST2		    _IO(GENERIC_DRIVER_MAGIC, 1)
#define IOC_GENERIC_TEST3		    _IO(GENERIC_DRIVER_MAGIC, 3)
#define IOC_GENERIC_TEST4		    _IO(GENERIC_DRIVER_MAGIC, 4)
#define IOC_GENERIC_TEST5		    _IO(GENERIC_DRIVER_MAGIC, 5)

#endif

/* ioctl-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include "ioctl-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("ioctl-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static long ioctl_generic_test1(struct file *filp, unsigned long arg);
static long ioctl_generic_test2(struct file *filp, unsigned long arg);
static long ioctl_generic_test3(struct file *filp, unsigned long arg);
static long ioctl_generic_test4(struct file *filp, unsigned long arg);
static long ioctl_generic_test5(struct file *filp, unsigned long arg);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.write = generic_write,
	.release = generic_release,
    .unlocked_ioctl = generic_ioctl
};

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "ioctl-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "ioctl-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

	return 0;
}

static void __exit generic_exit(void)
{
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "ioctl-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver read...\n");

	return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver write...\n");

	return 0;
}

static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
    printk(KERN_INFO "generic_ioctl...\n");

    switch (cmd) {
        case IOC_GENERIC_TEST1:
            result = ioctl_generic_test1(filp, arg);
            break;
        case IOC_GENERIC_TEST2:
            result = ioctl_generic_test2(filp, arg);
            break;
        case IOC_GENERIC_TEST3:
            result = ioctl_generic_test3(filp, arg);
            break;
        case IOC_GENERIC_TEST4:
            result = ioctl_generic_test4(filp, arg);
            break;
        case IOC_GENERIC_TEST5:
            result = ioctl_generic_test5(filp, arg);
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

long ioctl_generic_test1(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST1\n");

    return 0;
}

long ioctl_generic_test2(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST2\n");

    return 0;
}

long ioctl_generic_test3(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST3\n");

    return 0;
}

long ioctl_generic_test4(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST4\n");

    return 0;
}

long ioctl_generic_test5(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST5\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module
    
/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "ioctl-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
		
	if ((fd = open("ioctl-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_GENERIC_TEST1) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST2) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST3) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST4) == -1)
        exit_sys("ioctl");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                            105. Ders 29/05/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte boru aygıt sürücüsü için birkaç ioctl komutu uygulanmıştır. Buradaki IOCTL kodları şöyle oluşturulmuştur:

    #define PIPE_DRIVER_MAGIC           'p'
    
    #define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
    #define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
    #define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
    #define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
    #define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

    Bu komut kodlarının ne yaptıklarını şöyle açıklayabiliriz:
    
    IOC_PIPE_GETCOUNT: Aygıt sürücünün kulllanabildiği boru sayısını (yani minör numara miktarını) elde etmek için 
    kullanılmaktadır.

    IOC_PIPE_GETCOUNT: Boruda o anda bulunan byte sayısını elde etmek için kullanılmaktadır.
    
    IOC_PIPE_GETNDEVICES: Kullanılmakta olan borunun uzunluğunu elde etmek için kullanılmaktadır. 

    IOC_PIPE_SETBUFSIZE: Kullanılmakta olan borunun uzunluğunu (yani buffer uzunluğunu) değiştirmekte kullanılmaktadır.

    IOC_PIPE_PEEK: Borudan okuma yapmakta kullamılır. Ancak okunanlar borudan atılmaz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                106. Ders 03/06/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu örnek için yukarıda vermiş olduğumuz boru aygıt sürücüsünde bazı değişiklikler yaptık. Bu değişiklikler şunlardır:

    - Artık borunun uzunluğu PIPE_DEVICE yapısının içerisinde tutulmaya başlanmıştır:

    struct PIPE_DEVICE {
        unsigned char *buf;
        size_t bufsize;
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Buradaki bufsize elemanı ilgili borunun uzunluğunu belirtmektedir. Default uzunluk PIPE_DEF_BUFFER_SIZE değeri kadardır. 
    Bu değer örneğimizde test için kolaylık sağlamak amacıyla 10 olarak alınmıştır. Bu değişiklik sayesinde artık her minör 
    numaraya ilişkin  boru uzunlukları farklılaşabilecektir.

    - ioctl işlemleri farklı proseslerden aynı anda yapılabileceği için işlemlerin genel olarak senkronize edilmesi gerekir.

    - Aygıt sürücümüz içerisindeki ioctl fonksiyonu aşağıdaki gibi yazılmıştır:

    static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        struct PIPE_DEVICE *pipedev;
        int result;

        printk(KERN_INFO "ioctl\n");

        pipedev = (struct PIPE_DEVICE *)filp->private_data;

        if (down_interruptible(&pipedev->sem))
            return -ERESTARTSYS;

        switch (cmd) {
            case IOC_PIPE_GETNDEVICES:
                result =  put_user(ndevices, (size_t *)arg);
                break;
            case IOC_PIPE_GETCOUNT:
                result =  put_user(pipedev->count, (size_t *)arg);
                break;
            case IOC_PIPE_GETBUFSIZE:
                result = put_user(pipedev->bufsize, (size_t *)arg);
                break;
            case IOC_PIPE_SETBUFSIZE:
                result = set_bufsize(pipedev, arg);
                break;
            case IOC_PIPE_PEEK:
                result = read_peek(pipedev, arg);
                break;
            default:
                result = -ENOTTY;
        }

        up(&pipedev->sem);

        return result;
    }

    Burada biz ioctl fonksiyonun hemen başında bir kritik kod oluşturduk. Tabii kritik kodun mümkün olduğunca küçük bir kod
    parçasını içermesini sağlamalısınız. Ancak buradaki örneğimizde tüm fonksiyonu kilitlemenin önemli bir sakıncası yoktur. 
    set_busize fonksiyonu borunun kullandığı tamponu büyütme ya da küçültme işlevini yerine getirmektedir. peek_read fonksiyonu 
    ise borudan bilgiyi atmadan okuma yapmaktadır. Normal olarak borudan read fonksiyonu ile okuma yapıldığında okunanlar borudan 
    atılmaktadır. Ancak bu ioctl kodu ile borudan okuma yapıldığında okunanlar borudan atılmamaktadır. Bu ioctl kodu için aşağıdaki 
    gibi bir yapı oluşturulmuştur:

    struct PIPE_PEEK {
        size_t size;
        void *buf;
    };

    Yapının size elemanı kaç byte peek işleminin yapılacağını, buf elemanı ise peek edilen byte'ların yerleştirileceği adresi
    belirtmektedir. Tabii boruda mevcut olan byte sayısından daha fazla byte peek edilmek istenirse boruda olan kadar byte peek 
    edilmektedir. Peek edilen byte sayısı aygıt sürücü tarafından yapının size elemanına aktarılmaktadır. 

    Aygıt sürücümüzü yine "loadmulti" script'i ile aşağıdaki gibi yükleyebilirsiniz:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Aygıt sürücünün çekirdekten atılması da yine "unloadmulti" script'i ile aşağıdaki gibi yapılabilir:

    $ sudo ./unloadmulti 10 pipe-driver

    Buradaki aygıt sürücünün testi için üç ayrı program kullandık. "pipe-ioctl-test.c" programı bu IOCTL komutlarını aygıt 
    sürücüye yollamaktadır. Tabii test işlemini yalnızca bu programı değil başka bir termianlden daha önce yazmış olduğumuz 
    "pwriter" ve "preader" programlarını da çalıştırmalısınız. 

    Aşağıda tüm kodlar verilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/types.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	return 0;

EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static void __exit pipe_driver_exit(void)
{
	int i;

    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* pipe-ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

void exit_sys(const char *msg);
void disp_pipe_info(int fd);

int main(int argc, char *argv[])
{
	int fd;
	struct PIPE_PEEK pp;
	unsigned char pbuf[1024];

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	printf("Press ENTER to continue...\n");
	getchar();

	disp_pipe_info(fd);

	if (ioctl(fd, IOC_PIPE_SETBUFSIZE, 20ul) != 0) 
		exit_sys("ioctl");

	disp_pipe_info(fd);

	printf("number opf bytes to peek?");
	scanf("%zu", &pp.size);
	pp.buf = pbuf;

	if (ioctl(fd, IOC_PIPE_PEEK, &pp) != 0) 
		exit_sys("ioctl");

	pbuf[pp.size] = '\0';
	printf("Peek bytes: %s\n", pbuf);

	close(fd);

	return 0;
}

void disp_pipe_info(int fd)
{
	size_t ndevices, count, bufsize;

	if (ioctl(fd, IOC_PIPE_GETNDEVICES, &ndevices) != 0) 
		exit_sys("ioctl");
	printf("number of pipe: %zu\n", ndevices);

	if (ioctl(fd, IOC_PIPE_GETCOUNT, &count) != 0) 
		exit_sys("ioctl");
	printf("number of bytes in pipe: %zu\n", count);

	if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &bufsize) != 0) 
		exit_sys("ioctl");
	printf("pipe buffer size: %zu\n", bufsize);
	
	printf("---------------------------\n");
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi proc dosya sistemi disk tabanlı bir dosya sistemi değildir. proc dosya sistemi çekirdek çalışması sırasında 
    çekirdeğin dış dünyaya bilgi vermesi için bazen de davranışını dış dünyadan gelen bilgilerle değiştirebilmesi için tasarlanmıştır 
    Daha sonraları benzer amaçlarla sys isimli bir dosya sistemi de Linux'a eklenmiştir.

    proc dosya sistemi yalnızca çekirdek tarafından değil aygıt sürücüler tarafından da kullanılabilmektedir. Ancak bu dosya 
    sisteminin içerisinde kullanıcı modundan dosyalar ya da dizinler yaratılamamaktadır. proc dosya sistemindeki tüm girişlerin 
    dosya uzunlukları 0 biçiminde rapor edilmektedir. proc dosya sisteminin bütün kontrolü çekirdek tarafından çekirdeğin
    içerisindeki fonksiyonlarla sağlanmaktadır. Yani proc dosya sistemi çekirdeğin bir parçasını oluşturmaktadır.

    proc dosya sisteminin kullanımına yönelik çekirdek fonksiyonları çekirdeğin versiyonları ile zaman içerisinde birkaç kez 
    değiştirilmiştir. Dolayısıyla eski çekirdeklerde çalışan kodlar yeni çekirdeklerde derlenmeyecektir. Biz kursumuzda bu 
    fonksiyonların son hallerini ele alıp açıklayacağız.

    Aygıt sürücümüz proc dosya sisteminde bir dosya yaratmış olsun. Kullanıcı modundan bu dosya üzerinde open, read, write, lseek, 
    close gibi işlemler yapıldığında aslında aygıt sürücümüzün belirlediği fonksiyonlar çağrılmaktadır. Yani örneğin biz kullanıcı 
    modundan proc dosya sistemi içerisindeki bir dosyadan okuma yapmak istediğimizde aslında onu oluşturan aygıt sürücünün 
    içerisindeki bir okuma fonksiyonu çağrılmaktadır. Bu fonksiyon bize okuma sonucunda elde edilecek bilgileri vermektedir.
    Benzer biçimde proc dosya sistemindeki bir dosyaya kullanıcı modundan yazma yapılmak istendiğinde aslında o dosyayı yaratan
    aygıt sürücünün bir yazma fonksiyonu çağrılmaktadır. Yani proc dosya sistemi aslında bilgileri statik biçimde tutan dosyalardan
    oluşmamaktadır. Dosyada bulunduğu varsayılan bilgiler talep edildiğinde aygıt sürücüler tarafından kullanıcıya verilmektedir. 

    Aslında proc dosya sistemi üzerinde işlemler yapmak için bir aygıt sürücüsü oluşturulması zorunlu değildir. Çekirdek 
    modlleri de proc dosya süstemi üzerinde aşağıda açıklayacağımız biçimde işlemler yapabilir. Ancak biz temel örneklerimizi 
    yine de bir karakter aygıt sürücüsü üzerinde vereceğiz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                107. Ders 10/06/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------   
    proc dosya sisteminde bir dosya yaratabilmek için proc_create isimli fonksiyon kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_create(const char *name, umode_t mode, 
        struct proc_dir_entry *parent, const struct proc_ops *proc_ops);

    Fonksiyonun birinci parametresi proc dosya sisteminde yaratılacak olan dosyanın ismini belirtir. İkinci parametresi ise 
    erişim haklarını belirtmektedir. Bu parametre 0 geçilirse default erişim hakları kullanılır. Üçüncü parametre dosyanın hangi 
    dizinde yaratılacağını belirtmektedir. Bu parametre NULL geçilirse dosya ana "/proc" dizini içerisinde yaratılır. proc dosya 
    sistemi içerisinde dizinlerin nasıl yaratıldığını izleyen paragraflarda açıklayacağız. Son parametre proc dosya sistemindeki 
    ilgi dosyaya yazma ve okuma gibi işlemler yapıldığında çağrılacak fonksiyonları belirtmektredir. Aslında Linux'un 3.10 
    çekirdeklerine kadarki çekirdeklerde bu fonksiyonun son parametresi proc_ops yapısını değil, file_operations yapısını 
    kullanıyordu. Dolayısıyla çekirdeğinizdeki fonksiyonun son parametresinin ne olduğuna dikkat ediniz. proc_ops yapısı 
    şöyle bildirilmiştir:

    #include <linux/proc_fs.h>

    struct proc_ops {
        unsigned int proc_flags;
        int    (*proc_open)(struct inode *, struct file *);
        ssize_t    (*proc_read)(struct file *, char __user *, size_t, loff_t *);
        ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
        ssize_t    (*proc_write)(struct file *, const char __user *, size_t, loff_t *);
        /* mandatory unless nonseekable_open() or equivalent is used */
        loff_t    (*proc_lseek)(struct file *, loff_t, int);
        int    (*proc_release)(struct inode *, struct file *);
        __poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
        long    (*proc_ioctl)(struct file *, unsigned int, unsigned long);
    #ifdef CONFIG_COMPAT
        long    (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
    #endif
        int    (*proc_mmap)(struct file *, struct vm_area_struct *);
        unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    };

    proc_ops yapısının elemanlarına ilişkin fonksiyon göstericilerinin türlerinin file_operations yapısındaki elemanlara ilişkin
    fonksiyon göstericilerinin türleri ile aynı olduğuna dikkat ediniz. Bu fonksiyonların kullanımı tamamen aygıt sürücü 
    için oluşturduğumuz file_operations yapısı ile aynı biçimdedir.

    proc dosya sistemi genel olarak text tabanlı bir dosya sistemi biçiminde düşünülmüştür. Yani buradaki dosyalar genel olarak 
    text içeriğe sahiptir. Siz de aygıt sürücünüz için proc dosya sisteminde dosya oluşturacaksanız onların içeriğini text 
    olarak oluşturmalısınız. (proc dosya sisteminde binary bir dosya içeriği oluşturmak mümkündür. Ancak kullanıcıların beklentisi
    bu yönde değildir.)

    proc_create fonksitonu başarı durumunda yaratılan dosyanın bilgilerini içeren proc_dir_entry türünden bir yapı nesnesinin 
    adresiyle, başarısızlık durumunda NULL adresle geri dönmektedir. Bu durumda çağıran fonksiyonun -ENOMEM gibi bir hata değeriyle 
    geri döndürülmesi yaygındır.

    proc dosya sisteminde yaratılan dosya remove_proc_entry fonksiyonuyla silinebilmektedir. Fonksiyonun parametrik yapısı 
    şöyledir:

    #include <linux/proc_fs.h>

    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi silinecek dosyanın ismini, ikinci parametresi dosyanın içinde bulunduğu dizine ilişkin 
    proc_dir_entry nesnesinin adresini almaktadır. Yine bu parametre NULL adres girilirse dosyanın ana "/proc" dizininde
    olduğu kabul edilmektedir. 

    proc dosya sisteminde yarattığınız dosyaları aygıt sürücüyü kaldırırken silmeyi unutmayınız. Aksi takdirde bu dosyalar 
    kullanılırken tüm sistem çökebilir. 

    Aşağıdaki örnekte proc dosya sisteminde dosya yaratan iskelet bir aygıt sürücü programı verilmiştir. Bu aygıt sürücüde 
    "/proc"  dizininde "proc-driver" isminde bir dosya yaratılmaktadır. Aygıt sürücüyü install ettikten sonra "/proc" dizininde
    bu dosyanın yaratılıp yaratılmadığını kontrol ediniz. Biz bu örnekte ilgili dosyaya yazma yapılmasını da sağladık. Örneğimizde
    bu dosya okunduğunda aslında aygıt sürücümiz içerisindeki int türdne g_val değişkeninin içerisindeki değer sanki bir 
    yazıymış gibi okunmaktadır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32];
        size_t esize, left;

        sprintf(valbuf, "%d\n", g_val);
        left = strlen(valbuf) - *off;
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf + *off, esize) != 0) 
            return -EFAULT; 
        *off += esize;

        return esize;
    } 
    
    Benzer biçimde bu dosyaya yazma yapıldığında yazılan karakterler önce bir diziye yazılmış sonra g_val global değişkenine
    akratılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32 + 1];
        size_t esize;
        int val;
        int result;

        if (*off > 0)
            return 0;

        esize = size > 32 ? 32 : size;

        if (copy_from_user(valbuf, buf, esize) != 0) 
            return -EFAULT; 
        valbuf[esize] = '\0'; 
        if ((result = kstrtoint(valbuf, 10, &val)) != 0)
            return result;

        g_val = val;

        *off += esize;

        return esize;
    }

    Buradaki örnekte write işleminde dosya göstericisinin konumunun hiç dikkate alınmadığına dikkat ediniz. Yani örneğimizde
    parçalı yazıma olanak verilmemiştir. Yani yazma yapmak için mutlaka dosya göstericisinin dosyasnın başında olması gerekir. 
    Gerçekten de aygıt sürücüleri yazanlar bu tür durumlarda parçalı yazmaya hatta parçalı okumaya izin vermemektedir. 

    Test sırasında yazma işlemini aşağıdaki örnekte olduğu gibi yapmayı unutmayınız:

    echo "1000" | sudo tee /proc/proc-driver
-----------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
 #include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    if (proc_create("proc-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create proc-driver file!..\n");
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
        
    g_val = val;

    *off += esize;

    return esize;
}

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*-----------------------------------------------------------------------------------------------------------------------------
                                            108. Ders 12/06/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosyayı proc dosya sisteminin kök dizininde yarattık. İstersek proc dizininde bir dizin yaratıp 
    dosyalarımızı o dizinin içerisinde de oluşturabilirdik. Eğer aygıt sürücü içerisinde proc dosya sisteminde çok fazla dosya 
    yaratılacaksa bunların proc dizinin kökünde değil ayrı bir dizinde yaratılması daha iyi bir tekniktir.
    
    proc dosya sisteminde bir dizin yaratmak için proc_mkdir fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi yaratılacak dizinin ismini, ikinci parametresi dizinin hangi dizin içerisinde yaratılacağını 
    belirtir. Bu parametre NULL geçilirse dizin proc dosya sisteminin kök dizininde yaratılır. Buradan aldığımız geri dönüş değerini 
    proc_create fonksiyonunun parent parametresinde kullanırsak ilgili dosyamızı bu dizinde yaratmış oluruz. Tabii benzer biçimde 
    dizin içerisinde dizin de yaratabiliriz. proc_mkdir fonksiyonu başarısızlık durumunda NULL adrese geri dönmektedir. Başarısızlık 
    durumunda çağıran fonksiyonun yine -ENOMEM değeriyle geri döndürülmesi uygundur. Örneğin:

    struct proc_dir_entry *pdir;
    ...

    if ((pdir = proc_mkdir("procfs-driver", NULL)) == NULL) 
        return -ENOMEM;

    if (proc_create("info", 0, pdir, &g_proc_ops) == NULL) {
        ...
        return -ENOMEM;
    }

    Dizinlerin silinmesi yine remove_proc_entry fonksiyonuyla yapılmaktadır. Tabii dizin içerisindeki dosyaları silerken 
    remove_proc_entry fonksiyonunda dosyanın hangi dizin içerisinde olduğu belirtilmelidir. Bu fonksiyon ile dizin silinirken 
    dizinin içi boş değilse bile o dizin ve onun içindeki girişlerin hepsi silinmektedir. (Halbuki disk tabanlı dosya sistemlerinde 
    ancak içi boş olan dizinler silinebilmektedir.) Ayrıca kök dizindeki girişleri silmek için proc_remove fonksiyonu da bulundurulmuştur. 
    Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    void proc_remove(struct proc_dir_entry *de);

    Bu fonksiyon parametre olarak proc_create ya da proc_mkdir fonksiyonunun verdiği geri dönüş değerini alır. proc dosya sisteminin 
    kök dizininde silme yapılmak isteniyorsa aşağıdaki her iki çağrım eşdeğerdir:

    remove_proc_entry("file_name", NULL);
    proc_remove(pde);

    Aşağıdaki örnekte "proc-driver" isimli aygıt sürücüsünde önce proc dosya sisteminin kök dizininde "proc-driver" isimli dizin 
    yaratılmış onun da içerisinde "val" isimli bir dosya yaratmıştır. Sonra da bu dosyadan okuma yapıldığında aygıt sürücü 
    içerisindeki g_val değişkenindeki değer verilmiştir. Bu dosyaya yazma yapıldığında ise yazılan değer g_val değişkenine 
    yerleştirilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;
    struct proc_dir_entry *dir;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {    
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT1;
    }

    if ((dir = proc_mkdir("proc-driver", NULL)) == NULL) {
        printk(KERN_ERR "cannot create proc-driver directory!..\n");
        result = -ENOMEM;
        goto EXIT2;
    }

    if (proc_create("val", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, dir, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create val file!..\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    return 0;

EXIT3:
    remove_proc_entry("proc-driver", NULL);
EXIT2:
    cdev_del(g_cdev);
EXIT1:
   unregister_chrdev_region(g_dev, 1);

    return result;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
    
    g_val = val;

    *off += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*-----------------------------------------------------------------------------------------------------------------------------
                                        109. Ders 17/06/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yazmış olduğumuz boru aygıt sürücüsüne proc dosya sistemi desteği verelim. Bunun için proc dosya sisteminde
    aşağıdaki gibi bir dizin ve dosya yapısı kullanacak olalım:

    /proc
        pipe-driver <DIR>
            pipe-0 <DIR>
                bufsize
                count
            pipe-1 <DIR>
                bufsize
                count
            pipe-2 <DIR>
                bufsize
                count
            pipe-3 <DIR>
                bufsize
                count
            ...
        
    Örneğimizde "/proc" dizinin kök dizininde "pipe-driver" isimli bir dizin, bu dizinin içerisinde de minör numara kadar 
    "pipe-N" dizinleri yaratılacaktır. Her "pipe-N" dizinin içerisinde "bufsize" ve "count" isminde iki dosya bulundurulacaktır.
    "bufsize" dosyası read/write, count dosyası ise read-only biçimde olacaktır. Böylece bir kişi hiç ioctl yapmadan boruların 
    uzunluklarını alıp değiştirebilecek ve bir borunun içerisinde kaç byte olduğunu anlayabilecektir. 

    Yukarıdaki gibi bir örnek için proc dosya sistemi desteğini sağlarken sorun oluşturabilecek iki önemli nokta vardır:

    1) Birden fazla proc dosyasıyla işlem yaparken her dosya için ayrı bir proc_read, proc_write fonksiyonu oluşturmak oldukça
    zahmetlidir. İdeal olan durum tek bir proc_read, proc_write fonksiyonu yazıp bu fonksiyonun birden fazla dosya üzerinde işlem
    yapabilmesini sağlamaktır. 

    2) Boru aygıt sürücüsü örneğimizde birden fazla minör numaraya ilişkin birden fazla boru söz konusudur. Dolayısıyla bizim 
    kod içerisinde bir biçimde hangi boru üzerinde işlem yapıldığını bilmemiz gerekir. 

    İşte proc dosya sisteminde bir dosya yaratmak için kullandığımız proc_create fonksiyonunun proc_create_data isimli bir
    biçimi de vardır. proc_create_data fonksiyonunun prototipi şöyledir:

    struct proc_dir_entry *proc_create_data(const char *name, umode_t mode, struct proc_dir_entry *parent, 
        const struct proc_ops *proc_ops, void *data);

    Linux çekirdeğinin 5.17 versiyonundan öncesinde buradaki data adresi proc_dir_entry yapısı içerisindeki data elemanına 
    yerleştiriliyordu. Bu versiyonlarda inode nesnesi yoluyla proc dosyasına ilişkin proc_dir_entry yapısına ise PDE_DATA 
    isimli fonksiyonla erişiliyordu. Erişimde kullanılan fonksiyonları ver yapıları aşağıda veriyoruz:

    void *PDE_DATA(const struct inode *inode)
    {
        return __PDE_DATA(inode);
    }

    static inline void *__PDE_DATA(const struct inode *inode)
    {
        return PDE(inode)->data;
    }

    static inline struct proc_dir_entry *PDE(const struct inode *inode)
    {
        return PROC_I(inode)->pde;
    }

    static inline struct proc_inode *PROC_I(const struct inode *inode)
    {
        return container_of(inode, struct proc_inode, vfs_inode);
    }

    struct proc_inode {
        struct pid *pid;
        unsigned int fd;
        union proc_op op;
        struct proc_dir_entry *pde;
        struct ctl_table_header *sysctl;
        struct ctl_table *sysctl_entry;
        struct hlist_node sibling_inodes;
        const struct proc_ns_operations *ns_ops;
        struct inode vfs_inode;
    } __randomize_layout;

    file yapısından inode yapısına daha hızlı erişimi sağlamak için belli bir versiyondan sonra file yapısının içerisine
    f_inode elemanının eklendiğinden bahsetmiştik. Bu işlemin geçmişe ve geleceğe doğru uyumu koruyarak yapılmasını sağlamak 
    için ise file_inode fonksiyonu bulundurulmuştur. Bu fonksiyonunun mevcut çekirdeklerdeki tanımlması şöyle yapılmıştır:

    static inline struct inode *file_inode(const struct file *filp)
    {
        return filp->f_inode;
    }

    O halde 5.17 öncesi çekirdeklerde verilen bu adres filp göstericisi yoluyla şöyle elde edilmektedir:

    data = PDE_DATA(file_inode(filp));

    Ancak 5.17 çekirdeğinden itibaren artık proc_create_data fonksiyonuna verilen data adresi doğrudan i_node nesnesinin
    i_private elemanına yerleştirilmektedir. Dolayısıyla yeni çekirdeklerde artık proc_create_data fonksiyonuna geçirilen data
    parametresine şöyle erişilmektedir:

    data = file_inode(filp)->i_private;

    Aslında yeni çekirdeklerde inode nesnesinin adresinden hareketle inonde nesnesinin i_private elemanını veren pde_data isimli 
    ayrı bir fonksiyon da bulunmaktadır:

    static inline void *pde_data(const struct inode *inode)
    {
        return inode->i_private;
    }

    O halde yeni çekirdeklerde proc_create_data fonksiyonuna girilen data adresi şöyle de elde edilebilmektedir:

    data = pde_data(file_inode(filp));

    Örneğimizde proc_create_data fonksiyonuna aşağıdaki yapı türünden nesnenin adresi geçirilmiştir:

    struct PROC_FILE_INFO {
        struct PIPE_DEVICE *pipedev;
        int procfile;	
    };

    Yapının procfile elemanı hangi proc dosyasının kullanıldığını belirtmektedir. Bu değerin 0 olması bufsize dosyasının 
    1 olması ise count dosyasının kullanıldığı anlamına gelmektedir:

    for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

    Örneğimizdeki proc_read fonksiyonu şöyle yazılmıştır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        ssize_t result;
        size_t esize, left;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) 								// bufsize
            sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
        else if (pfi->procfile == 1) 
            sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
        else {										
            result = 0;
            goto EXIT;
        }

        left = strlen(valbuf);
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf, esize) != 0)  {
            result = -EFAULT; 
            goto EXIT;
        }
        *off += esize;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda parçalı okumaya izin verilmemektedir. proc_write fonksiyonu da benzer biçimde yazılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        size_t esize;
        ssize_t  result;
        int val;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) { 								// bufsize
            esize = size > 32 ? 32 : size;
            if (copy_from_user(valbuf, buf, esize) != 0) {
                result = -EFAULT; 
                goto EXIT;
            }
            valbuf[esize] = '\0'; 
            if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
                goto EXIT;
            if ((result = set_bufsize(pfi->pipedev, val)) != 0)
                goto EXIT;
            *off += esize;
        }
        else 									
            result = 0;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda da parçalı okumaya izin verilmediğine dikkat ediniz. Örneğin tüm kodlarını aşağıda veriyoruz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int create_proc_files(void);
static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

struct PROC_FILE_INFO {
	struct PIPE_DEVICE *pipedev;
	int procfile;	
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;
struct PROC_FILE_INFO *g_proc_info;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	if (create_proc_files() != 0)
		goto EXIT6;

	return 0;

EXIT6:
	for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[k]->cdev);
EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static int create_proc_files(void)
{
	struct proc_dir_entry *pdir1, *pdir2;
	int i;
	char pname[16];
	struct PROC_FILE_INFO *pfi;

	if ((pdir1 = proc_mkdir("pipe-driver", NULL)) == NULL)
		return -1;

	if ((g_proc_info = (struct PROC_FILE_INFO *)kmalloc(sizeof(struct PROC_FILE_INFO) * ndevices * 2, GFP_KERNEL)) == NULL)
		goto EXIT1;

	for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

	return 0;

EXIT2:
	kfree(g_proc_info);
EXIT1:
	remove_proc_entry("pipe-driver", NULL);

	return -1;
}

static void __exit pipe_driver_exit(void)
{
	int i;

	kfree(g_proc_info);
	remove_proc_entry("pipe-driver", NULL);
    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;
		
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}


static int proc_open(struct inode *inodep, struct file *filp)
{
    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	ssize_t result;
	size_t esize, left;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) 								// bufsize
		sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
	else if (pfi->procfile == 1) 
		sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
	else {										
		result = 0;
		goto EXIT;
	}

	left = strlen(valbuf);
  	esize = size > left ? left : size;

	if (copy_to_user(buf, valbuf, esize) != 0)  {
		result = -EFAULT; 
		goto EXIT;
	}
	*off += esize;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
    
	return result;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	size_t esize;
	ssize_t  result;
	int val;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) { 								// bufsize
		esize = size > 32 ? 32 : size;
		if (copy_from_user(valbuf, buf, esize) != 0) {
			result = -EFAULT; 
			goto EXIT;
		}
    	valbuf[esize] = '\0'; 
    	if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
        	goto EXIT;
		if ((result = set_bufsize(pfi->pipedev, val)) != 0)
			goto EXIT;
		*off += esize;

	}
	else 									
		result = 0;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
	
    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                        110. Ders 19/06/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu bölümde aygıt sürücülerde zamanlama işlemlerinin nasıl yapılacağı üzerinde duracağız. Aygıt sürücülerde zamanlama 
    işlemleri bazı uygulamalarda kritik önemde olabilmektedir. Örneğin programcının bir IO port'una bir bilgi gönderdikten 
    sonra diğerini göndermek için belli bir süre beklemesi gerekebilir. Bazen programcı belli bir süre sonra birtakım işlemlerin 
    yapılmasını isteyebilir. Masaüstü Linux sistemleri "katı gerçek zamanlı (hard real time)" işlemler için uygun olmasa da bazı 
    "gevşek gerçek zamanlı (soft real time)" işlemlere olanak sağlayabilmektedir. Gerçek zamanlı işlemlerde kritik zamanlamalar 
    söz konusu olabilmektedir. İşte Linux'ta bu tür bekleme işlemleri çekirdeğin sunduğu mekanizmalar yoluyla yapılmaktadır. 

    Linux çekirdeğinde zamanlama işlemleri iki yolla gerçekleştirilmektedir:

    1) Periyodik donanım kesmeleri yoluyla
    2) İşlemcilerin sunduğu TSC (time stamp counter) mekanizması yoluyla

    Uzun süreli zamanlama işlemlerinde periyodik donanım kesmelerinden kısa süreli zamanlama işlemlerinde ise işlemcilerin sunduğu 
    TSC mekanizmasından faydalanılmaktadır. 

    Zamanlama işlemleri için periyodik donanım kesmeleri oluşturan devrelerden faydalanılmaktadır. Örneğin klasik PC mimarisinde 
    CPU üzerinde periyodik kesme oluşturmak için Intel'in 8254 "Programmable Interval Timer (PIT)" denilen entegre devresi 
    kullanılıyordu. Bugün Intel tabanlı PC'lerde hala bu donanım birimi bulundurulmaktadır. Ancak belli bir zamandan sonra 
    PC board'larına daha yüksek çözünürlüklü periyodik donanım kesmesi oluşturmak için chipset'ler içerisine yeni donanım 
    birimleri de eklenmiştir. Periyodik donanım kesmesi oluşturmak için kullanılan bu yüksek çözünürlüklü birimlere "HPET (High 
    Precision Event Timer)" de denilmektedir. 
    
    Belli bir süreden sonra Intel ve ARM işlemcilerine CPU içerisine de periyodik kesme oluşturan zamanlayıcı devreler eklenmiştir. 
    Bunlara PC mimarisinde "APIC Timer (Advanced Progammable Interrupt Controller Timer)" ya da "yerel timer (local timer)" 
    denilmektedir. Çok çekirdekli işlemcilerde her çekirdeğin ayrı bir "yerel timer" devresi bulunmaktadır. Bugünkü çok çekirdekli 
    sistemlerde thread'ler arası geçiş (context switch) bu yerel timer devrelerinin oluşturduğu kesmeler yoluyla gerçekleştirilmektedir. 
    
    Gömülü sistemlerde CPU'nun dışındaki periyodik kesme oluşturan donanım birimleri genellikle SoC içerisinde bulunmaktadır.
    Tabii ARM tabanlı gömülü sistemlerde aynı zamanda tıpkı Intel işlemcilerinde olduğu gibi CPU içerisinde de periyodik donanım 
    kesmeleri oluşturacak ayrı yerel timer devreleri vardır. Bu yerel timer devrelerine "ARM Generic Timer" da denilmektedir. 

    Özetle bugünkü Linux sistemlerinin çalıştırıdığı masaüstü sistemlerinde ve ARM tabanlı gömülü sistemlerde genel olarak olarak 
    iki zamanlayıcı devre bulunmaktadır:

    1) Global Timer devresi
    2) Her CPU'nun ya da çekirdeğin içerisindeki yerel timer devresi

    Global timer devresi Linux tarafından genel zamanlama işlemleri için, yerel timer devreleri ise ilgili çekirdekteki 
    thread'ler arası geçiş (context switch) işlemlerini sağlamak için kullanılmaktadır.
    
    Bugünkü Linux sistemlerinde bu global ve yerel timer devrelerinin hepsi 1 milisaniye, 4 milisaniye ya da 10 milisaniyeye 
    kurulmaktadır. Eskiden ilk Linux çekirdeklerinde 10 milisaniyelik periyotlar kullanılıyordu. Sonra bilgisayarlar hızlanınca 
    1 milisaniye periyot yaygın olarak kullanılmaya başlandı. Ancak bugünlerde 4 milisaniye periyotları kullanan çekirdekler 
    de yaygın biçimde bulunmaktadır. Aslında timer frekansı çekirdek konfigüre edilirken kullanıcılar tarafından da değiştirilebilmektedir. 
    (Anımsanacağı gibi çekirdek derlenmeden önce çekirdeğin davranışları üzerinde etkili olan parametrelerin belirlenmesi sürecine 
    "çekirdeğin konfigüre" edilmesi denilmektedir.) Ancak bu timer frekansı çekirdek boot parametreleri yoluyla değiştirilememektedir. 

    proc dosya sistemine belli bir çekirdek verisyonundan sonra "timer_list" isimli bir giriş de eklenmiştir. Bu dizin girişi 
    okunduğunda o sistemdeki çekirdeğin kullandığı timer devrelerine ilişkin bilgiler elde edilmektedir. Yine Linux'un kullandığı 
    timer kaynakları hakkında bilgiler sys dosya sisteminin içerisinden "/sys/devices/system/clocksource" dizininden de elde 
    edilebilmektedir. Bu dosyaların ayrıntılı formatları için Linux dokümanlarına başvurabilirsiniz. (İçerik olarak çekirdek 
    versiyonları arasında farklılıklar da söz konusu olabilmektedir.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Global timer kesmelerine (PC mimarisinde IRQ0) ilişkin kesme kodları çekirdek içerisindeki jiffies isimli bir global değişkeni 
    artırmaktadır. Böylece eğer timer kesme periyodu biliniyorsa iki jiffies değeri arasındaki farka bakılarak bir zaman ölçümü 
    mümkün olabilmektedir. Tabii buradaki hesabın çözünürlüğü ancak global timer devresinin periyodu kadardır.

    Timer frekansı Linux çekirdeği içerisindeki HZ isimli sembolik sabitle belirtilmiştir. Timer frekansı çekirdek konfigüre 
    edilirken CONFIG_HZ konfigürasyon parametresi yoluyla değiştirilebilmektedir. Yukarıda da belirttiğimiz gibi genellikle 
    timer frekansı 1000 (1 ms) , 250 (4 ms) ya da 100 (10 ms) olmaktadır. (Ancak değişik mimarilerde farklı değerlerde olabilir.) 
    Örneğin kursun yapıldığı sanal makinede timer periyodu 1 milisaniyedir. Bu da saniyede 1000 kez timer kesmesinin oluşacağı 
    anlamına gelmektedir. Başka bir deyişle bu makinede HZ sembolik sabiti 1000 olarak define edilmiştir. Çekirdeğin CONFIG_HZ
    konfigürasyon parametresi değiştirildiğinde bu değişiklik HZ sembolik sabitine de yansıtılmaktadır. Çekirdek kodlarında 
    aşağıdaki gibi bir #define işlemi bulunmaktadır:

    #define HZ  CONFIG_H

    Ancak bazı özel ve uç durumlarda CONFIG_HZ değeri HZ değeri ile olmayabilmektedir. Ancak burda bu durum hakkında açıklama
    yapmayacağız.

    İşte global timer kesmesi her oluştuğunda işletim sisteminin kesme kodu (interrupt handler) devreye girip "jiffies" isimli 
    global değişkeni 1 artırmaktadır. Bu jiffies değişkeni unsigned long türdendir. Bilindiği gibi unsigned long türü 32 
    bit Linux sistemlerinde 4 byte, 64 bit Linux sistemlerinde 8 byte'tır. 32 bit Linux sistemlerinde ayrıca jiffies_64 isimli 
    bir değişken de bulunmaktadır. Bu değişken hem 32 bit sistemde hem de 64 bit sistemde 8 byte'tır. Aslında 32 bit sistemlerde 
    zaten jiffies değişkeni jiffies_64 değişkeninin düşük anlamlı 4 byte'ı durumundadır. 32 bit sistemde jiffies değişkeni 4 
    byte olduğu için bilgisayar çok uzun süre açık kalırsa taşma (overflow) oluşabilmektedir. Ancak 64 bit sistemlerde taşma 
    mümkün değildir. 32 bit sistemlerde jiffies_64 değeri çekirdek tarafından iki ayrı makine komutuyla güncellenmektedir. 
    Çünkü 32 bit sistemlerde 64 bit bir değeri belleğe tek hamlede yazmak mümkün değildir. Bu nedenle jiffies_64 değerinin 
    taşma durumunda yanlış okunabilme olasılığı vardır. Ayrıca bu jiffies_64 değeri okunurken de global timer kesmesi oluşabilir. 
    Overlow durumunda Hem 32 bit hem 64 bit sistemlerde 64 bitlik jiffies değerini düzgün bir biçimde okuyabilmek için get_jiffies_64 
    isimli fonksiyon bulundurulmuştur:

    #include <linux/jiffies.h>

    u64 get_jiffies_64(voi);

    Biz 32 bit sistemde de olsak bu fonksiyonla 64 bitlik jiffies değerini düzgün bir biçimde okuyabiliriz. Bu fonksiyon düzgün
    okuma için gereken senkronizasyonu sağlamaktadır.

    Aşağıdaki örnekte çekirdek modülü içerisinde proc dosya sisteminde "jiffy-module" isimli bir dizin, bu dizinin içerisinde 
    de "jiffy" ve "hertz" isimli iki dosya yaratılmıştır. "jiffy" dosyası okunduğunda o anki jiffies değeri, "hertz" dosyası 
    okunduğunda ise timer frekansı elde edilmektedir. Çekirdek modülünü aşağıdaki gibi derleyip yükleyebilirsiniz:

    $ make file=jiffy-module
    $ sudo insmod jiffy-module.ko

    Boşaltımı da şöyle yapabilirsiniz:

    $ sudo rmmod jiffy-module.ko
-----------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    static char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer 64 bit sistemde çalışıyorsak jiffies değerinin taşması (overflow olması) mümkün değildir. 
    Ancak 32 bit sistemlerde HZ değeri 1000 ise 49 günde taşma meydana gelebilmektedir. Aygıt sürücü programcısı bazen geçen 
    zamanı hesaplamak için iki noktada jiffies değerini alıp aradaki farka bakmak isteyebilmektedir. Ancak bu durumda 32 bit 
    sistemlerde "overflow" olasılığının ele alınması gerekir. İşaretli sayıların ikili sistemdeki temsiline dayanarak iki jiffies 
    arasındaki fark aşağıdaki gibi tek bir ifadeyle de hesaplanabilmektedir:

    unsigned long int prev_jiffies, next_jiffies;
    ...
    net_jiffies = (long) next_jiffies - (long) prev_jiffies;

    Çekirdek içerisinde iki jiffy değerini alarak bunları öncelik sonralık ilişkisi altında karşılaştıran aşağıdaki makrolar 
    bulunmaktadır:

    #include <linux/jiffies.h>

    time_after(jiffy1, jiffy2)
    time_before(jiffy1, jiffy2)
    time_after_eq(jiffy1, jiffy2)
    time_before_eq(jiffy1, jiffy2)

    Bu fonksiyonların hepsi bool bir değere geri dönmektedir. Bu fonksiyonlar 32 bit sistemlerde taşma durumunu da dikkate 
    almaktadır. time_after fonksiyonu birinci parametresiyle belirtilen jiffy değerinin ikinci parametresiyle belirtilen jiffy 
    değerinden sonraki bir jiffy değeri olup olmadığını belirlemekte kullanılmaktadır. Diğer fonksiyonlar da bu biçimde birinci 
    parametredeki jiffy değeri ile ikinci parametredeki jiffy değerini karşılaştırmaktadır. Tabii aslında eğer jiffies değerini 
    get_jiffies_64 fonksiyonuyla elde ediyorsanız yukarıdaki fonksiyonları kullanmanıza hiç gerek kalmaz.

    Çekirdek içerisinde jiffies değerini çeşitli biçimlere dönüştüren aşağıdaki fonksiyonlar da bulunmaktadır:

    #include <linux/time.h>

    unsigned long msecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);

    Bu işlemin tersini yapan da üç fonksiyon vardır:

    unsigned int jiffies_to_msecs(const unsigned long j);
    unsigned int jiffies_to_usecs(const unsigned long j);
    unsigned int jiffies_to_nsecs(const unsigned long j);

    Bu fonksiyonlar HZ sembolik sabitinin değerini dikkate almaktadır. HZ değerinin genel olarak CONFIG_HZ değeri ile aynı 
    olduğunu anımsayınız.

    Ayrıca jiffies değerini saniye ve nanosaniye biçiminde ayırıp bize struct timespec64 biçiminde bir yapı nesnesi olarak veren 
    jiffies_to_timespec64 isimli bir fonksiyon da vardır. Bunun tersi timespec64_to_jiffies fonksiyonuyla yapılmaktadır.

    timespec64 yapısı da şöyledir:

    struct timespec64 {
        time64_t    tv_sec;             /* seconds */
        long        tv_nsec;            /* nanoseconds */
    };

    Eski çekirdeklerde bu fonksiyonların yerine aşağıdaki fonksiyonlar bulunuyordu:

    #include <linux/time.h>

    unsigned long timespec_to_jiffies(struct timespec *value);
    void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
    unsigned long timeval_to_jiffies(struct timeval *value);
    void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);

    Aşağıdaki örnekte proc dosya sisteminde "jiffy-module" dizini içerisinde ayrıca "difference" isimli bir dosya da yaratılmıştır. 
    Bu dosya her okunduğunda önceki okumayla aradaki jiffies farkı yazdırılmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static struct proc_ops g_procops_difference = {
    .proc_read = proc_read_difference,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("difference", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_difference) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[64 + 1];
    static unsigned long long prev_jiffies;
    unsigned long long net_jiffies;
    struct timespec64 ts;
    size_t left, esize;

    if (*off > 0)
        return 0;

    if (prev_jiffies == 0)
        prev_jiffies = get_jiffies_64();

    net_jiffies = get_jiffies_64() - prev_jiffies;
    jiffies_to_timespec64(net_jiffies, &ts);

    sprintf(valbuf, "%llu seconds + %llu nanoseconds\n", 
        (unsigned long long)ts.tv_sec, (unsigned long long)ts.tv_nsec);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    prev_jiffies = jiffies;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*-----------------------------------------------------------------------------------------------------------------------------
                                        111. Ders 26/06/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde bazen belli bir süre bekleme yapmak gerekebilir. Bekleme işlemi çekirdek modunda çekirdeğin sağladığı 
    olanaklarla yapılabilmektedir. Eğer bekleme süresi kısa ise bekleme işlemi meşgul bir döngü ile yapılabilir. Örneğin:

    while (time_before(jiffies, jiffies_target))
        schedule();

    Burada o anki jiffies değeri hedef jiffies değerinden küçükse schedule fonksiyonu çağrılmıştır. schedule fonksiyonu thread'i 
    uykuya yatırmamaktadır. Yalnızca thread'ler arası geçiş (context switch) oluşmasına yol açmaktadır. Yani bu fonksiyon uykuya 
    dalmadan CPU'yu bırakmak için kullanılmaktadır. schedule fonksiyonunu çağıran thread çalışma kuyruğunda (run queue) kalır. Yine 
    çalışma sırası ona geldiğinde kaldığı yerden çalışmaya devam eder. Ancak meşgul bir döngü içerisinde schedule işlemi yine
    önemli bir CPU zamanın harcanmasına yol açmaktadır. Bu nedenle uzun beklemelerin yukarıdaki gibi yapılması tavsiye edilmemektedir. 
    Uzun beklemelerin uykuya dalarak yapılması gerekir.

    Uzun beklemeler bir wait kuyruğu oluşturulup wait_event_timeout ya da wait_event_interruptible_timeout fonksiyonlarıyla koşul 
    0 yapılarak gerçekleştirilebilir. Ancak bunun için bir wait kuyruğunun oluşturulması gerekir. Bu işlemi zaten kendi içerisinde 
    yapan özel fonksiyonlar vardır.

    schedule_timeout fonksiyonu belli bir jiffy zamanı geçene kadar thread'i çekirdek tarafından bu amaçla oluşturulmuş olan bir
    wait kuyruğunda bekletir.

    #include <linux/sched.h>

    signed long schedule_timeout(signed long timeout);

    Fonksiyon parametre olarak beklenecek jiffy değerini alır. Eğer fonksiyon sinyal dolayısıyla sonlanırsa kalan jiffy sayısına, 
    zaman aşımının dolması nedeniyle sonlanırsa 0 değerine geri dönmektedir. schedule_timeout fonksiyonu başarısız olmaz. Fonksiyonu 
    kullanmadan önce prosesin durum bilgisini set_current_state isimli fonksiyonla değiştirmek gerekir. Değiştirilecek durum 
    TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE olabilir. Bu işlem yapılmazsa bekleme gerçekleşmemektedir. Örneğin bu fonksiyonla
    thread'i 10 saniye bekletmek isteyelim:

    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(10 * HZ);

    Uzun beklemeyi kendi içerisinde schedule_timeout kullanarak yapan üç yardımcı fonksiyon da vardır:

    #include <linux/delay.h>

    void msleep(unsigned int msecs);
    unsigned long msleep_interruptible(unsigned int msecs);
    void ssleep(unsigned int secs);

    Buradaki mseel ve msleep_interruptible mili saniye cinsinden, ssleep ise saniye cinsinden bekleme yapmaktadır. Yukarıda da 
    belirttiğimiz gibi bu fonksiyonlar aslında schedule_timeout fonksiyonu klullanılarak yazılmıştır. Örneğin msleep fonksiyonu 
    tanımlanmıştır:

    void msleep(unsigned int msecs)
    {
        unsigned long timeout = msecs_to_jiffies(msecs);

        while (timeout)
            timeout = schedule_timeout_uninterruptible(timeout);
    }

    Aşağıdaki örnekte "jiffy-module" dizinindeki "sleep" dosyasından okuma yapıldığında 10 saniye bekleme oluşacaktır.

    $ cat /proc/jiffy-module/sleep
-----------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops = {
    .proc_read = proc_read,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("sleep", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    msleep_interruptible(10000);
    
    /*
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(10 * HZ);
    */

    printk(KERN_INFO "sleep file read...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde kısa beklemelerim yapılması gerekebilmektedir. Çünkü bazı donanım aygıtlarının programlanabilmesi 
    için bazı beklemelere gereksinim duyulabilmektedir. Kısa beklemeler meşgul döngü yoluyla yani hiç sleep yapılmadan sağlanmaktadır. 
    Ayrıca kısa bekleme yapan fonksiyonlar atomiktir. Atomiklikten kastedilen şey thread'ler arası geçiş (context switch) 
    mekanizmasının kapatılmasıdır. Yani kısa bekleme yapan fonksiyonlar bu bekleme sırasında thread'in quanta süresi bitse bile 
    bundan etkilenmemektedir. Tabii bu fonksiyonlar thread'ler arası geçiş işlemini o işlemci ya da çekirdek için kapatırlar. 
    Ancak donanım kesmeleri bu süre içerisinde oluşabilmektedir. Yani bir donanım kesmesi oluşursa buradaki bekleme belirlenen 
    süreyi aşabilir. Bu tür durumlarda programcının kendisinin donanım kesmelerini ilgili CPU ya da çekirdek için kapatması gerekir. 

    Kısa süreli döngü içerisinde bekleme yapan fonksiyonlar şunlardır:

    void ndelay(unsigned int nsecs);
    void udelay(unsigned int usecs);
    void mdelay(unsigned int msecs);

    Burada delay nanosaniye cinsinden bekleme yapmak için, udelay mikrosaniye cinsinden bekleme yapmak için, mdelay ise 
    milisaniye cinsinden bekleme yapmak için kullanılmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeklerine belli bir versiyondan sonra bir timer mekanizması da eklenmiştir. Bu sayede aygıt sürücü programcısı 
    belli bir zaman sonra belirlediği bir fonksiyonun çağrılmasını sağlayabilmektedir. Bu mekanizmaya "kernel timer" mekanizması 
    denilmektedir. Maalesef "kernel timer" mekanizması da birkaç kere arayüz olarak değiştirilmiştir. Bu mekanizma kullanılırken 
    dikkat edilmesi gereken bir nokta çağrılacak callback fonksiyonun bir proses bağlamında çağrılmadığıdır. Yani callback fonksiyon 
    çağrıldığında biz current makrosu ile o andaki prosese erişemeyiz. O anda çalışan prosesin kullanıcı alanına ilişkin kopyalamalar 
    yapamayız. Çünkü callback fonksiyon timer kesmeleri tarafından çağrılmaktadır. Dolayısıyla callback fonksiyon çağrıldığında
    o anda hangi prosesin thread'inin çalışmakta olduğu değişebilir.

    Son Linux çekirdeklerindeki kernel timer kullanımı aşağıdaki adımlardan geçilerek sağlanmaktadır:

    1) struct timer_list türünden bir yapı nesnesi statik düzeyde tanımlanır ve bu yapı nesnesine ilk değeri verilir. DEFINE_TIMER
    makrosu ile hem tanımlama hem de ilkdeğer verme işlemi birlikte yapılabilir. Makro şöyledir:

    #include <linux/time.h>

    #define DEFINE_TIMER(_name, _function)

    Örneğin:

    DEFINE_TIMER(g_mytimer, timer_proc);

    Ya da alternatif olarak struct timer_list nesnesi yaratılıp timer_setup makrosuyla da ilkdeğer verilebilir. Makronun parametrik 
    yapısı şöyledir:

    #include <linux/time.h>

    #define timer_setup(timer, callback, flags)

    Makronun birinci parametresi timer nesnesinin adresini almaktadır. İkinci parametresi çağrılacak fonksiyonu belirtir. 
    flags parametresi 0 geçilebilir.

    Örneğin:

    static struct timer_list g_mytimer;
    ...

    timer_setup(&g_mytimer, timer_proc, 0);

    Buradaki callback fonksiyonunun parametrik yapısı şöyle olmalıdır:

    void timer_proc(struct timer_list *tlist);

    2) Tanımlanan struct timer_list nesnesi add_timer fonksiyonu ile çekirdek içerisindeki bir bağlı listeye yerleştirilir. 
    Çekirdek timer nesnelerine bu bağlı listeden hareketle erişmektedir. add_timer fonksiyonunun prototipi şöyledir:

    #include <linux/time.h>

    void add_timer(struct timer_list *timer);

    3) Daha sonra callback fonksiyonun ne zaman çağrılacağını belirlemek için mod_timer fonksiyonu kullanılır. Fonksiyonun 
    prototipi şöyledir:

    #include <linux/time.h>

    int mod_timer(struct timer_list *timer, unsigned long expires);

    Buradaki expires parametresi jiffy türündendir. Ancak bu parametre hedef jiffy değerini içermelidir. (Yani jiffies + gecikme 
    jiffy değeri)

    4) Timer nesnesinin silinmesi için del_timer ya da del_timer_sync fonksiyonu kullanılmaktadır:

    #include <linux/time.h>

    int del_timer(struct timer_list * timer);
    int del_timer_sync(struct timer_list * timer);

    del_timer fonksiyonu eğer timer fonksiyonu o anda başka bir işlemcide çalışıyorsa asenkron biçimde silme yapar. Yani 
    fonksiyon sonlandığında henüz silme gerçekleşmemiş fakat göreli bir süre sonra gerçekleşecek olabilir. Halbuki del_timer_sync 
    fonksiyonu geri dönünce timer silinmesi gerçekleşmiş olur. Eğer timer silinmezse modül çekirdekten atıldığında tüm sistem 
    çökebilir.

    Normal olarak belirlenen fonksiyon yalnızca 1 kez çağrılmaktadır. Ancak bu fonksiyonun içerisinde yeniden mod_timer çağrılarak
    çağırmayı periyodik hale getirilebilir.

    Aşağıda kernel timer kullanımına basit bir örnek verilmiştir. Bu örnekte her 5 saniyede bir belirlenen callback fonksiyon
    çağrılmıştır. Çekirdek modülünün init ve exit fonksiyonları şöyle yazılmıştır:

    static void timer_proc(struct timer_list *tlist);

    static struct timer_list g_mytimer;
    ...

    static int __init timer_init(void)
    {
        timer_setup(&g_mytimer, timer_proc, 0);
        add_timer(&g_mytimer);
        mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);

        printk(KERN_INFO "timer-module module init...\n");

        return 0;
    }

    static void __exit timer_exit(void)
    {
        del_timer(&g_mytimer);

        printk(KERN_INFO "timer-module module exit...\n");
    }

    Callback fonksiyon da şöyle yazılmıştır:

    static void timer_proc(struct timer_list *tlist)
    {
        printk(KERN_INFO "timer_proc called...\n");

        mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);
    }
-----------------------------------------------------------------------------------------------------------------------------*/

/* timer-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/timer.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("timer module");

static void timer_proc(struct timer_list *tlist);

static struct timer_list g_mytimer;

static int __init timer_init(void)
{
    timer_setup(&g_mytimer, timer_proc, 0);
    add_timer(&g_mytimer);
    mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);

    printk(KERN_INFO "timer-module module init...\n");

    return 0;
}

static void __exit timer_exit(void)
{
    del_timer(&g_mytimer);

    printk(KERN_INFO "timer-module module exit...\n");
}

static void timer_proc(struct timer_list *tlist)
{
    printk(KERN_INFO "timer_proc called...\n");

    mod_timer(&g_mytimer, get_jiffies_64() + 5 * HZ);
}

module_init(timer_init);
module_exit(timer_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
    Bizim şimdiye kadar yazmış olduğumuz çekirdek modüllerindeki ve aygıt sürücülerdeki kodlarımız aşağıdaki durumlarda çalışma
    fırsatı bulmaktadır:

    1) Modül yüklenirken ve çekirdek alanından atılırken
    2) Aygıt sürücü üzerinde aygıt dosyası yoluyla dosya işlemleri yapılırken
    3) Kullanıcı modundan ioctl işlemleri yoluyla
    4) proc ve sys dosya sistemlerindeki dosyalar yoluyla
    5) En son gördüğümüz timer mekanizması yoluyla

    Bunların yanı sıra henüz görmediğimiz aşağıdaki iki durumda da çekirdek modülümüzdeki ya da aygıt sürücümüzdeki kodlar 
    çalışma fırsatı bulabilmektedir:

    6) Çekirdek thread'leri (kernel therads) yoluyla
    7) Donanım kesmeleri yoluyla

    Biz bu bölümde "çekirdek thread'leri" üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Önceki konularda da Linux sistemlerinde çekirdek mode'da çalışan işletim sistemine ait thread'lerin olduğundan bahsetmiştik. 
    Bu thread'ler çalışma kuyruğunda (run queue) bulunan ve uykuya dalabilen işletim sisteminin bir parçası durumundaki thread'lerdir. 
    İşletim sistemine ait bu thread'ler çeşitli işlemlerden sorumludurlar. Linux işletim sisteminde çekirdek thread'leri genellikle 
    "kullanıcı modundaki daemon"larda olduğu gibi sonu 'd' ile bitecek biçimde isimlendirilmiştir. Ancak çekirdeğe ait olan bu 
    thread'lerin ismi 'k' (kernel'dan geliyor) ile başlatılmıştır. Örneğin "kupdated", "kswapd", "keventd" gibi. Bu thread'ler 
    yukarıda da belirttiğimiz gibi Linux işletim sisteminin bir parçası durumundadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            12. Ders 01/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İşte çekirdek modülleri ve aygıt sürücüler de isterlerse arka planda çekirdek modunda çalışacak thread'ler yaratabilirler. 
    Bu tür thread'lere İngilizce "kernel threads" denilmektedir. Biz kurusumuzda bunlara "çekirdek modunda çalışan thread'ler"
    ya da "çekirdek thread'leri" diyeceğiz. 
    
    Çekirdek modunda çalışan thread'ler herhangi bir proses ile ilişkisiz biçimde çalıştırılmaktadır. Bu nedenle bunlar içerisinde 
    copy_to_user ya da copy_from_user gibi fonksiyonlar kullanılamaz. Çekirdek modunda çalışan thread'ler de diğer kullanıcı 
    modunda çalışan thread'lerde olduğu gibi aynı "çalışma kuyruğu (run queue)" içerisinde zaman paylaşımlı biçimde çalıştırılmaktadır.
    
    Çekirdek thread'leri sırasıyla şu adımlarlardan geçilerek kullanılmaktadır:

    1) Önce çekirdek thread'i aygıt sürücü içerisinde yaratılır. Yaratılma modülün init fonksiyonunda yapılabileceği gibi aygıt 
    sürücü ilk kez açıldığında open fonksiyonunda ya da belli bir süre sonra belli bir olay gerçekleştiğinde de yapılabilmektedir. 
    Çekirdek thread'leri kthread_create fonksiyonuyla yaratılmaktadır:

    #include <linux/kthread.h>

    struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char *namefmt);

    Fonksiyonun birinci parametresi thread akışının başlatılacağı fonksiyonun adresini almaktadır. Bu fonksiyon void * türünden 
    parametreye ve int geri dönüş değerine sahip olmak zorundadır. Fonksiyonun ikinci parametresi thread akışı başlatıldığında 
    thread fonksiyonuna geçirilecek parametreyi belirtmektedir. Eğer bir thread fonksiyonuna bir parametre geçirilmek istenmiyorsa 
    bu parametre için NULL adres girilebilir. Fonksiyonun üçüncü parametresi proc dosya sisteminde (dolayısıyla "ps" komutunda) 
    görüntülenecek ismi belirtir. Fonksiyon başarı durumunda yaratılan thread'in task_struct adresine, başarısızlık durumunda 
    negatif errno değerine geri dönmektedir. Adrese geri dönen diğer çekirdek fonksiyonlarında olduğu gibi fonksiyonun başarılı
    olup olmadığı IS_ERR makrosuyla test edilmelidir. Eğer fonksiyon başarısız olmuşsa negatif errno değeri PTR_ERR makrosuyla 
    elde edilebilir. Örneğin:

    static struct task_struct *g_kthread;

    g_kthread = kthread_create(...);
      if (IS_ERR(g_kthread)) {
        printk(KERN_ERR "cannot create kernel thread!..\n");
        return PTR_ERR(g_kthread);
    }

    Anımsanacağı gibi Linux sistemlerinde prosesler ve thread'ler task_struct yapısıyla temsil ediliyordu. İşte bu fonksiyon 
    da başarı durumunda çekirdek tarafından yaratılan task_struct nesnesinin adresini bize vermektedir.

    Çekirdek thread'leri bu fonksiyonla yaratıldıktan sonra hemen çalışmaa başlamazlar. Onları çalıştırmak için wake_up_process 
    fonksiyonun çağrılması gerekir. Fonksiyonun prototipi şöyledir:

    #include <linux/kthread.h>

    int wake_up_process(struct task_struct *tsk);

    Fonksiyon ilgili çekirdek thread'in task_struct adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda negatif errno değerine geri döner. Tabii bir çekirdek thread'i başarılı bir biçimde yaratılmışsa ve bu fonksiyona 
    onun task_struct adresi geçilmişse thread'in çalışmaya başlatılmasında bir sorun oluşmaz. Böylesi bir hata durumu zaten 
    sistemdeki ciddi sorunlara işaret etmektedir. Bu nedenle wake_up_process fonksiyonunun geri dönüş değerini kontrol etmeyebilirsiniz. 
    Çekirdek thread'in yaratılır yaratılmaz çalıştırılamsı doğru tekniktir. Henüz çalıştırılmamış ancak task_struct yapısı 
    tahsis edilmiş olan çekirdek thread'lerinin task_struct yapısını geri bırakmak için put_task_struct fonksiyonu kullanılmalıdır. 

    Aslında yukarıdaki işlemi tek hamlede yapan kthread_run isimli bir fonksiyon da vardır:

    #include <linux/kthread.h>

    struct task_struct *kthread_run(int (*threadfn)(void *data), void *data, const char *namefmt);

    kthread_run mevcut çekirdeklerde bir makro biçiminde şöyle yazılmıştır:

    #define kthread_run(threadfn, data, namefmt, ...)			   \
    ({									   \
        struct task_struct *__k						   \
            = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
        if (!IS_ERR(__k))						   \
            wake_up_process(__k);					   \
        __k;								   \
    })

    Makroda gcc derleyicilerinin "ifadesel deyim (expression statement)" eklentisinin kullanıldığına dikkat ediniz.

    2) Çekirdek thread'i kthread_stop fonksiyonuyla herhangi bir zaman yok edilebilir. Eğer çekirdek thread modülün init 
    fonksiyonunda yaratılmışsa yok edilmesi de tipik olarak modülün exit fonksiyoununda yapılmaktadır. Fonksiyonun prototipi 
    şöyledir:
    
    #include <linux/kthread.h>

    int kthread_stop(struct task_struct *ts);

    Fonksiyon çekirdek thread'in task_struct nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısız
    durumunda negatif errno değerine geri döner. Fonksiyonun normal koşullarda başarısız olması söz konusu değildir. Yani başarı 
    kontrolü hiç yapılmayabilir. Örneğin:

    kthread_stop(g_kthread);
    
    Fonksiyon thread fonksiyonu sonlanana kadar blokeye yol açmaktadır. Fonksiyon başarı durumunda thread fonksiyonunun exit 
    koduyla (yani thread fonksiyonunun geri dönüş değeri ile) geri dönmektedir. Genellikle programcılar thread fonksiyonlarını 
    başarı durumunda sıfır, başarısızlık durumunda sıfır dışı bir değerle geri döndürmektedir. Burada önemli bir nokta kthread_stop 
    fonksiyonunun çekirdek modunda çalışan thread'i zorla sonlandırılmadığıdır. Çekirdek thread'in sonlandırılması zorla yapılmaz. 
    kthread_stop fonksiyonu çekirdek thread'ine ilişkin task_struct yapısı içerisindeki bir bayrağı set eder. Çekirdek thread'i 
    de tipik olarak bir döngü içerisinde "bu bayrak set edilmiş mi" diye bakar. Eğer bayrak set edilmişse kendini sonlandırır. 
    Çekirdek thread'in bu bayrağa bakması kthread_should_stop fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/kthread.h>

    bool kthread_should_stop(void);

    Fonksiyon eğer bu bayrak set edilmişse sıfır dışı bir değere, set edilmemişse 0 değerine geri dönmektedir. Tipik olarak 
    thread fonksiyonu aşağıdaki gibi bir döngüde yaşamını geçirmektedir:

    while (!kthread_should_stop()) {
        ...
    }

    Tabii aslında biz kthread_create fonksiyonu ile bir çekirdek thread yaratmak istediğimizde thread çekirdek içerisindeki 
    başka bir fonksiyondan başlatılır. Bizim kthread_create fonksiyonuna verdiğimiz fonksiyon da aslında bu fonksiyon tarafından 
    çağrılmaktadır. Dolayısıyla bizim thread fonksiyonumuz bittiğinde akış yine çekirdek içerisindeki fonksiyona döner. O 
    fonksiyonda da yaratılmış thread kaynakları otomatik boşaltılmaktadır. Yani biz bir thread'i yarattığımız zaman onun yok 
    edilmesi thread fonksiyonu bittiğinde otomatik yapılmaktadır. Ancak thread akışı bittiğinde thread'e ilişkin task_struct 
    yapısı otomatik yok edilmez. task_struct yapısının yok edilmesi kthread_stop fonksiyonu tarafından yapılmaktadır.

    Çekirdek thread'inde thread'in sonlandırılması fonksiyonun bitmesi beklenmeden do_exit fonksiyonuyla da sağlanabilmektedir. 
    Aslında do_exit fonksiyonu prosesleri sonlandıran sys_exit fonksiyonunun doğrudan çağırdığı taban bir fonksiyondur.

    #include <linux/kernel.h>

    void do_exit(long code);

    Fonksiyon thread'in exit kodunu parametre olarak almaktadır. Çekirdek thread do_exit fonksiyonuyla kendini sonlandırmışsa 
    task_struct yapısı tread'in exit kodunu iletmek için sistem tarafından tutulur. kthread_stop fonksiyonu da bu task_struct 
    yapısını serbest bırakmaktadır. Zaten bir çekirdek thread'inin thread fonksiyonu sonlandığında da bu fonksiyon çağrılmaktadır. 
    Fakat çekirdeğin belli bir versiyonundan sonra (muhtemelen 2.6'lı çekirdeklerde olmalı) bu do_exit fonksiyonu artık export 
    edilmemektedir. Dolayısıyla bu fonksiyonu yalnızca eski çekirdek versyionlarında kullanabilirsiniz.

    Aşağıdaki örnekte modül ün init fonksiyonunda edilirken çekirdek thread yaratılmış, modülün exit fonksiyonunda da kthread_stop 
    ile çekirdek thread'in sonlanması beklenmiştir. kernel-thread içerisinde msleep fonksiyonu ile 1 saniyelik beklemeler 
    yapılmıştır.
-----------------------------------------------------------------------------------------------------------------------------*/

/* kernel-thread-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/syscalls.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("kernel thread module");

int kernel_thread_proc(void *data);

static struct task_struct *g_kthread;

static int __init generic_init(void)
{
    g_kthread = kthread_create(kernel_thread_proc, NULL, "my-kernel-thread");
    if (IS_ERR(g_kthread)) {
        printk(KERN_ERR "cannot create kernel thread!..\n");
        return PTR_ERR(g_kthread);
    }
    wake_up_process(g_kthread);

    printk(KERN_INFO "kernel-thread-module init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    int ecode;
    
    ecode = kthread_stop(g_kthread);
    printk(KERN_INFO "kernel thread exited with %d code\n", ecode);;

    printk(KERN_INFO "kernel-thread-module module exit...\n");
}

int kernel_thread_proc(void *data)
{
    int count = 0;

    while (!kthread_should_stop()) {
        printk(KERN_INFO "kernel thread running: %d\n", count);
        ++count;
        msleep_interruptible(1000);            
    }

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*-----------------------------------------------------------------------------------------------------------------------------
                                            113. Ders 03/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İşlemcinin çalıştırmakta olduğu koda ara vererek başka bir kodu çalıştırması ve çalıştırma bittikten sonra kaldığı yerden 
    devam etmesi sürecine "kesme (interrupt)" denilmektedir. Kesmeler oluşma biçimine göre üçe ayrılmaktadır:

    1) Donanım Kesmeleri (Hardware Interrupts)
    2) İçsel Kesmeler (Internal Interrupts)
    3) Yazılım Kesmeleri (Software Interrupts)

    Kesme denildiğinde akla (default olarak) donanım kesmeleri gelmektedir. Donanım kesmeleri pek çok CPU'da CPU'nun bir ucunun 
    (genellikle bu uca INT ucu denilmektedir) elektriksel olarak dışsal bir birim tarafından uyarılmasıyla oluşmaktadır. Yani 
    donanım kesmeleri o anda çalışmakta olan koddan bağımsız bir biçimde dış dünyadaki birimler tarafından oluşturulmaktadır. 
    PC terminolojisinde donanım kesmesi oluşturan kaynaklara IRQ (Interrupt Request) da denilmektedir. İçsel kesmeler CPU'nun 
    kendi çalışması sırasında kendisinin oluşturduğu kesmelerdir. Intel bu tür kesmelerin önemli bir bölümünü "fault" olarak 
    isimlendirmektedir. Örneğin fiziksel RAM'de olmayan bir sayfaya erişildiğinde CPU "page fault" denilen içsel bir kesme 
    oluşturmaktadır. Yazılım kesmeleri ise programcının program koduyla oluşturduğu kesmelerdir. Her türlü CPU'da yazılım kesmesi 
    oluşturulamamaktadır. Bir kesme oluştuğunda çalıştırılan koda "kesme kodu (interrupt handler)" denilmektedir.

    Geleneksel sistemlerde donanım kesmesi oluşturan elektronik birimlerin hepsi doğrudan CPU'nun INT ucuna bağlanmamaktadır. 
    Çünkü bunun pek çok sakıncası vardır. Genellikle bu amaçla bu işe aracılık eden denetleyiciler kullanılmaktadır. Bu denetleyicilere
    genel olarak "kesme denetleyicileri (interrupt controllers)" denilmektedir. Bazı mimarilerde kesme denetleyicisi işlemcinin 
    içerisinde bulunur. Bazı mimarilerde ise dışarıda ayrı bir birim olarak bulunmaktadır. Tabii artık pek çok entegre devre 
    "SoC (System on Chip)" adı altında tek bir entegre devrenin içerisine yerleştirilmiş durumdadır. Kesme denetleyicileri de bu 
    SoC'ların içerisinde bulunabilmektedir. Kesme denetleyicilerinin temel işlevleri şöyledir:

    1) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunları sıraya dizebilmektedir.
    2) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunlara öncelikler verebilmektedir.
    3) Belli birimlerden gelen kesme isteklerini kesme denetleyicisi görmezden gelebilmektedir. Buna ilgili IRQ'nun disable 
    edilmesi de denilmektedir.
    4) Kesme denetleyicileri çok çekirdekli donanımlarda kesmenin belli bir çekirdekte çalıştırılabilmesine de olanak 
    sağlayabilmektedir.

    Modern CPU'larda her CPU'nun (ya da çekirdeğin) içerisinde ayrı bir kesme denetleyicisi de bulunmaktadır. Genellikle bu 
    yerel kesme denetleyicileri CPU'nun bir ucu ile değil bellek tabanlı IO işlemleriyle (Yani adeta belli bir bölgesine bir 
    şey yazılarak) tetiklenmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bugün kullandığımız PC'lerde (laptop ve notebook'lar da dahil olmak üzere) eskiden kesme denetleyicisi olarak bir tane 
    Intel'in 8259 (PIC) denilen entegre devresi kullanılıyordu. Bunun 8 girişi bulunuyordu. Yani bu kesme denetleyicisinin 
    uçları 8 ayrı donanım birimine bağlanabiliyordu.
          
          | (INT ucu CPU'ya bağlanır) 
      <8259 (PIC)>
    | | | | | | | |
    0 1 2 3 4 5 6 7

    Bu uçlara IRQ uçları deniliyordu ve bu uçlar değişik donanım birimlerine bağlıydı. Böylece bir donanım birimi kesme oluşturmak
    isterse kesme denetleyicisinin ilgili ucunu uyarıyordu. Kesme denetleyicisi de CPU'nun INT ucunu uyarıyordu. İlk PC'lerde 
    toplam 8 IRQ vardı. Ancak 80'li yılların ortalarında PC mimarisinde değişiklikler yapılarak kesme denetleyicisinin sayısı ikiye 
    yükseltildi. Böylece IRQ uçlarının sayısı da 15'e yükseltilmiş oldu. (Intel'in iki 8259 işlemcisini kaskat bağlayabilmek için 
    birinci kesme denetleyicisinin (Master PIC) bir ucunun ikinci kesme denetleyicisinin INT ucuna bağlanması gerekmektedir.
    İşte PC mimarisinde birinci kesme denetleyicisinin 2 numaralı ucu ikinci kesme denetleyicisine bağlanmıştır. Böylece toplam
    IRQ'ların sayısı 16 değil, 15 olmaktadır.)

    | (INT ucu CPU'ya bağlanır)     |
      <8259 (PIC)>                     <8259 (PIC)>
    | | X | | | | |                 | | | | | | | |

    0 1 2 3 4 5 6 7                 8 9 10 11 12 13 14 15

    Ancak zamanla 15 IRQ ucu da yetersiz kalmaya başlamıştır. Yukarıda da belirttiğimiz gibi çok çekirdekli sistemlerde her 
    çekirdeğin (yani CPU'nun) ayrı bir INT ucu vardır. Yani bu çekirdekler diğerlerinden bağımsız kesme alabilmektedir. İşte 
    zamanla Intel'in klasik 8259 kesme denetleyicisi daha gelişmiş olan ve ismine IOAPIC denilen kesme denetleyicisi ile 
    değiştirilmiştir. Bugün kullandığımız Intel tabanlı bilgisayar mimarisinde artık IOAPIC kesme denetleyicileri bulunmaktadır. 
    Bu yeni kesme denetleyicisinin 24 IRQ ucu vardır. IOAPIC birden fazla çekirdeğin bulunduğu durumda tek bir çekirdeğe değil, 
    tüm çekirdeklere bağlanmaktadır. Dolayısıyla istenilen bir çekirdekte kesme de oluşturabilmektedir. IOAPIC devresinin bazı 
    uçları bazı donanım birimlerine bağlı biçimdedir. Ancak bazı uçları boştadır. Bugün kullanılan ve ismine PCI ya da PCI-X 
    denilen genişleme yuvalarının bazı uçları bu IOAPIC ile bağlantılıdır. Dolayısıyla genişleme yuvalarına takılan kartlar da 
    IRQ oluşturabilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bugün Pentium ve eşdeğer AMD işlemcilerinin içerisinde (her çekirdeğin içerisinde) aynı zamanda ismine "Local APIC" denilen 
    bir kesme denetleyicisi de vardır. Bu local APIC iki uca sahiptir. Local APIC içerisinde aynı zamanda bir timer devresi de 
    bulunmaktadır. Bu timer devresi periyodik donanım kesmesi oluşturmak için kullanılmaktadır. Intel ve AMD çekirdeklerinin 
    içerisinde bulunan APIC devresinin en önemli özelliği kesmeleri artık uçlarla değil, veri yoluyla (data bus) oluşturabilmesidir.
    Bu özellik sayesinde hiç işlemcinin INT ucu uyarılmadan çok fazla sayıda kesme sanki belleğe bir değer yazıyormuş gibi 
    oluşturulabilmektedir. Bu tekniğe "Message Signaled Interrupt (MSI)" denilmektedir. Gerçekten de bugün PCI slotlara takılan 
    bazı kartlar kesmeleri doğrudan belli bir çekirdekte MSI kullanarak oluşturmaktadır.

    O halde kullandığımız Intel tabanlı PC mimarisindeki bugünkü durum şöyledir:

    - Bazı donanım birimleri built-in biçimde IOAPIC'in uçlarına bağlı durumdadır. Bu uçlar geçmişe doğru uyumu korumak için
    eski 8259 kesme denetleyicisindeki uçlar kullanılarak donanım birimleriyle bağlanmıştır.

    - Bazı PCI kartlar slot üzerindeki 4 IRQ hattından (INTA, INTB, INTC, INTD) birini kullanarak kesme oluşturmaktadır. Bu hatlar 
    IOAPIC'in bazı uçlarına bağlıdır.

    - Bazı PCI kartlar ise doğrudan modern MSI sistemini kullanarak (yani IOAPIC'i pass geçerek) bellek işlemleriyle doğrudan 
    ilgili çekirdekte kesme oluşturabilmektedir.

    Bir aygıt sürücü programcısı mademki birtakım kartlar için onu işler hale getiren temel yazılımları da yazma iddiasındadır. 
    O halde o kartın kullandığı kesmeler için de kesme kodlarını (interrupt handlers) yazabilmelidir. Tabii işletim sisteminin 
    aygıt sürücü  mimarisinde bu işlemler de özel çekirdek fonksiyonlarıyla yapılmaktadır. Yani kesme kodu yazmanın belli bir 
    kuralı vardır.

    Peki bugünlerde kullandığımız Intel tabanlı çok çekirdekli masaüstü sistemlerinde IOAPIC yoluyla oluşturulan kesme hangi 
    çekirdek tarafından ele alınmaktadır? İşte bugünlerde kullanılan IOAPIC devreleri bu bakımdan şu özelliklere sahiptir:

    1) Kesme IOAPIC tarafından donanım biriminin istediği bir çekirdekte oluşturulabilmektedir.
    2) Kesme IOAPIC tarafından en az yüklü çekirdeğe karar verilerek orada oluşturulabilmektedir.
    3) Kesme IOAPIC tarafından döngüsel bir biçimde (yani sırasıyla her bir çekirdekte) oluşturulabilmektedir.

    IOAPIC'in en az yüklü işlemciyi bilmesi mümkün değildir. Onu ancak işletim sistemi bilebilir. İşte işlemcilerin local 
    APIC'leri içerisinde özel bazı yazmaçlar vardır. Aslında IOAPIC bu yazmaçtaki değerlere bakıp en düşüğünü seçmektedir. 
    Bu değerleri de işletim sistemi set etmektedir. İşletim sisteminin yaptığı bu faaliyete "kesme dengeleme (IRQ balancing)" 
    denilmektedir. Linux sistemlerinde bir süredir kesme dengelemesi işletim sisteminin çekirdek thread'i (irqbalance) tarafından 
    yapılmaktadır. Böylece Linux sistemlerinde aslında donanım kesmeleri her defasında farklı çekirdeklerde çalıştırılıyor 
    olabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM işlemcilerinde de genel çalışma biçimi beznerdir. Yine bazı SBC'lerde kullanılan SoC'lar içerisinde IOAPIC benzeri 
    bir kesme denetleyicisi bulunmaktadır. Bu SoC'ların bazı uçları donanım kesmelerini tetiklemek için kullanılmaktadır. Ancak
    ARM işlemcileri tıpkı Intel işlemcilerinde eolduğu gibi bellek tabanlı kesme oluşturma yeteneğine de sahiptir. Bu sistemlerde 
    de işletim sistemi tarafından aracılık edilen bir "kesme dengelemesi (IRQ load balancing)" uygulanmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pek çok CPU ailesinde toplam oluşturulabilecek donanım kesmelerinin maksimum bir sayısı vardır. Örneğin Intel mimarisinde 
    toplam kesme sayısı 256'yı geçememektedir. Yani bu mimaride en fazla 256 farklı kesme oluşturulabilmektedir. Bu mimaride 
    her kesmenin bir numarası vardır. (PC mimarisindeki IRQ numarası ile kesme numarasının bir ilgisi yoktur. IRQ numarası 
    kesmenin kesme denetleyicisinin hangi ucu uyarılarak oluşturulduğunu belirtmektedir. Biz örneğin PIC ya da IOAPIC'i programlayarak 
    belli bir IRQ için belli numaralı bir kesmenin oluşmasını sağlayabiliriz. Örneğin timer (IRQ-0) için 8 numaralı kesmenin 
    çalışmasını sağlayabiliriz. Peki bir IRQ oluşturulduğunda CPU ya da çekirdek kaç numaralı kesme kodunun çalıştırılacağını 
    nereden anlamaktadır? İşte PC mimarisinde PIC ya da IOAPIC CPU'nun INT ucunu uyararak kesme oluştururken veri yolunun ilk
    8 ucundan kesme numarasını da CPU'ya bildirmektedir. Local APIC sisteminde ise zaten oluşturulacak kesmenin numarası özel 
    bir bellek adresine yazılarak belirtilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kullanılan CPU mimarisi ne olursa olsun Linux sistemlerinde donanım kesmeleri hakkında bilgi "/proc/interupts" dosyası 
    yoluyla elde edilebilmektedir. Bu dosyanın içeriği Linux çekirdeği tarafından sürekli güncellenmektedir. Dosyanın görünümü
    şöyledir:

              CPU0       CPU1       CPU2       CPU3       
    0:         35          0          0          0   IO-APIC    2-edge      timer
    1:       1961      11907      18985      29237   IO-APIC    1-edge      i8042
    8:          1          0          0          0   IO-APIC    8-edge      rtc0
    9:          0          0          0          0   IO-APIC    9-fasteoi   acpi
    12:     178947     224775     288118     227366   IO-APIC   12-edge      i8042
    14:          0          0          0          0   IO-APIC   14-edge      ata_piix
    15:          0          0          0          0   IO-APIC   15-edge      ata_piix
    16:          0     633539          0          0   IO-APIC   16-fasteoi   vmwgfx, snd_ens1371
    17:     616310          0          0          0   IO-APIC   17-fasteoi   ehci_hcd:usb1, ioc0
    18:      13489     180886     461460     275687   IO-APIC   18-fasteoi   uhci_hcd:usb2
    19:          0          0        153     532269   IO-APIC   19-fasteoi   ens33, ens37
    24:          0          0          0          0  PCI-MSI-0000:00:15.0    0-edge      PCIe PME, pciehp
    25:          0          0          0          0  PCI-MSI-0000:00:15.1    0-edge      PCIe PME, pciehp
    26:          0          0          0          0  PCI-MSI-0000:00:15.2    0-edge      PCIe PME, pciehp
    27:          0          0          0          0  PCI-MSI-0000:00:15.3    0-edge      PCIe PME, pciehp
    28:          0          0          0          0  PCI-MSI-0000:00:15.4    0-edge      PCIe PME, pciehp
    29:          0          0          0          0  PCI-MSI-0000:00:15.5    0-edge      PCIe PME, pciehp
    30:          0          0          0          0  PCI-MSI-0000:00:15.6    0-edge      PCIe PME, pciehp
    31:          0          0          0          0  PCI-MSI-0000:00:15.7    0-edge      PCIe PME, pciehp
    32:          0          0          0          0  PCI-MSI-0000:00:16.0    0-edge      PCIe PME, pciehp
    33:          0          0          0          0  PCI-MSI-0000:00:16.1    0-edge      PCIe PME, pciehp
    34:          0          0          0          0  PCI-MSI-0000:00:16.2    0-edge      PCIe PME, pciehp
    35:          0          0          0          0  PCI-MSI-0000:00:16.3    0-edge      PCIe PME, pciehp
    36:          0          0          0          0  PCI-MSI-0000:00:16.4    0-edge      PCIe PME, pciehp
    37:          0          0          0          0  PCI-MSI-0000:00:16.5    0-edge      PCIe PME, pciehp
    38:          0          0          0          0  PCI-MSI-0000:00:16.6    0-edge      PCIe PME, pciehp
    .......

    Buradan IPAPIC yoluyla oluşturulan timer kesmesinin hep ilk çekirdek tarafından işlendiği görülmektedir. Çıktıdak, "PCI-MSI" 
    memory-mapped kesme oluşturma mekanizmasını belirtmektedir. Bazı donanım kesmelerinin IRQ dengelemesi yapılarak farklı
    çekirdeklerde çalıştırıldığına dikkat ediniz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücüler içerisinde kesmelerin nasıl ele alınacağı üzerinde duralım. Bir donanım kesmesi oluştuğunda 
    aslında işletim sisteminin kesme kodu (interrupt handler) devreye girmektedir. Ancak işletim sisteminin kesme kodu istek 
    doğrultusunda aygıt sürücülerin içerisindeki fonksiyonları çağırabilmektedir. Farklı aygıt sürücüler aynı IRQ için istekte
    bulunabilir. Bu durumda işletim sistemi IRQ oluştuğunda farklı aygıt sürücülerdeki fonksiyonları belli bir düzen içerisinde
    çağırmaktadır.

    Aygıt sürücü programcısı bir kesme oluştuğunda aygıt sürücüsünün içerisindeki bir fonksiyonunun çağrılmasını istiyorsa önce 
    onu request_irq isimli çekirdek fonksiyonuyla register ettirmelidir. request_irq fonksiyonunun prototipi şöyledir:

    #include <linux/interrupt.h>

    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev_id);

    Fonksiyonun birinci parametresi IRQ numarasını belirtmektedir. Yukarıda da belirttiğimiz gibi her donanım kesmesinin bir 
    IRQ numarası vardır. Bu numara aygıt sürücüsünü yazanlar tarafından bilinmelidir. ikinci parametresi IRQ oluştuğunda 
    çağrılacak fonksiyonu belirtmektedir. Bu fonksiyonun geri dönüş değeri irqreturn_t türünden parametreleri de sırasıyla 
    int ve void * türündendir. Örneğin:

    irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...
    }

    Buradaki irqreturn_t türü bir enum türü olarak typedef edilmiştir. Bu enum türünün elemanları şunlardır:

    enum irqreturn {
        IRQ_NONE           = (0 << 0),      /* 0 */
        IRQ_HANDLED        = (1 << 0),      /* 1 */
        IRQ_WAKE_THREAD    = (1 << 1),      /* 2 */
    };

    typedef enum irqreturn irqreturn_t;

    request_irq fonksiyonunun üçüncü parametresi bazı bayraklardan oluşmaktadır. Bu bayrak 0 geçilebilir ya da örneğin IRQF_SHARED 
    geçilebilir. Diğer seçenekler için dokümanlara başvurabilirsiniz. IRQF_SHARED aynı kesmenin birden fazla aygıt sürücü tarafından 
    kullanılabileceği anlamına gelmektedir. (Tabii biz IRQ'yu ilk register ettiren değilsek daha önce register ettirenlerin bu 
    bayrağı kullanmış olması gerekir. Aksi halde biz de bu bayrağı kullanamayız.) IRQ'yu ilk kez biz register ettiriyorsak ve bu bayrağı 
    kullanmazsak IRQ başka aygıt sürücüler tarafından kullanılamaz. Fonksiyonun dördüncü parametresi "/proc/interrupts" dosyasında 
    görüntülenecek ismi, son parametre ise programcının kesme oluştupunda çağrılacak kesme koduna geçirilmesini istediği nesnenin 
    adresini belirtmektedir. Aygıt sürücü programcıları bu parametreye tipik olarak aygıt yapısını girerler. Bu parametre IRQ oluştuğunda 
    çağrılacak olan fonksiyona ikinci parametre olarak geçilmektedir. Bu parametre NULL adres biçiminde geçilememektedir. Fonksiyon 
    başarı durumunda 0 değerine, başarısızlık durumunda negatif hata değerine geri dönmektedir. Örneğin:

    if ((result = request_irq(1, my_irq_handler, IRQF_SHARED, "my_irq", NULL)) != 0) {
        ...
        return result;
    }

    Bir kesme kodu request_irq fonksiyonuyla register ettirilmişse bunun geri alınması free_irq fonksiyonuyla yapılmaktadır:

    #include <linux/interrupt.h>

    const void *free_irq(unsigned int irq, void *dev_id);

    Fonksiyonun birinci parametresi silinecek irq numarasını, ikinci parametresi irq_reuest fonksiyonuna girilen son parametreyi 
    belirtir.  Bu parametrenin neden bu fonksiyona geçirildiğinin bazı ayrıntıları vardır. Fonksiyon başarı durumunda irq_request 
    fonksiyonunda verilen isme, başarısızlık durumunda NULL adrese geri dönmektedir. Geri dönüş değeri bir hata kodu içermemektedir. 
    Örneğin:

    if (free_irq(1, NULL) == NULL)
        printk(KERN_INFO "cannot free IRQ\n");

    Aslında her şey uygun yapılmışsa free_irq fonksiyonun da başarısız olması beklenmez. Bu nedenle eğer her şeyi düzgün yaptığınızı 
    düşünüyorsanız bu fonksiyonun geri dönüş değerini kontrol etmeyebilirsiniz. 

    Peki IRQ fonksiyonundan (IRQ handler) hangi değerle geri dönülmelidir? Aslında programcı bu fonksiyondan ya IRQ_NONE 
    değeri ile ya da IRQ_HANDLED değeri ile geri döner. Eğer programcı kesme kodu içerisinde yapmak istediği şeyi yapmışsa
    fonksiyondan IRQ_HANDLED değeri ile yapamamışsa ya da yapmak istememişse fonksiyondan IRQ_NONE değeri ile geri döner. Bazen 
    programcı bir kesmeyi ele almak ister ancak bu kesme programcının ilgilendiği durumun dışında başka nedenlerle de tetikleniyor 
    olabilir. İşte programcı eğer gerçekten kesmeyi ele alıp işlemişse kesme kpdundan IRQ_HANDLED değeri ile işlememişse IRQ_NONE 
    değeri ile geri dönmelidir. Örneğin:

    static irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...

        return IRQ_HANDLED;
    }
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            114. Ders 10/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bazen sistem programcısı belli bir IRQ'yu belli süre için disable etmek isteyebilir. Bunun için disable_irq ve enable_irq 
    isimli iki çekirdek fonksiyonu kullanılmaktadır. Bu fonksiyonlar mevcut çekirdeklere kesme denetleyicisi yoluyla (örneğin 
    PC mimariisndeki IOAPIC) disable işlemi yapmaktadır. Bu disable işlemi yapıldığında dışsal birim kesme denetleyicisini kesme 
    için uyarsa bile kesme denetleyicisi bu isteği dikkate almamaktadır. Fonksiyonların prototipleri şöyledir:

    #include <linux/interrupt.h>

    void disable_irq(unsigned int irq);
    void enable_irq(unsigned int irq);

    Fonksiyonlar IRQ numarasını parametre olarak alır. 

    Bazen aygıt sürücü içerisinde kritik birtakım işlemler yapılıyor olabilir. Bu işlemler yapılırken bir kesmenin araya girmesi 
    istenmeyebilir. Çünkü böyle bir durumda oluşcak gecikme olumsuz sonuçlar doğurabilir. İşte bu tür durumlarda yalnızca belli 
    bir IRQ'nun değil tüm IRQ'ların disable edilmesi gerekebilmektedir. Bu tür işlemler kesme denetleyicisi yoluyla değil CPU'nun 
    "kesme bayrağının (interrupt flag)" disable edilmesiyle yapılmaktadır. İşlemcilerde CPU'yu kesmelere kapatan ve açan özel 
    makine komutları vardır. (Örneğin Intel işlemcilerinde CLI (Clear Interrupt Flag) makine komutu CPU'yu kesmelere kapatmakta 
    STI (Set Interrupt Flag)" makine komutu ise CPU'yu kesmelere açmaktadır.) CPU kesmelere kapatılmışsa kesme denetleyicisi 
    CPU'yu uyarsa bile (ya da bellek tabanlı kesmeler programlama yoluyla bu işlemi yapsa bile) CPU kesme istedğini dikkate 
    almamaktadır. Yani CPU'nun içerisinde bu bakımdan "ana bir şalter" görevini yapan bir mekanizma vardır. Modern işlemciler 
    birden fazla çekirdek (core) içerebilmektedir. Burada sözünü ettiğimiz kesme bayrağı o çekirdeğe ilişkin kesme bayrağıdır. 
    Yani biz bir çekirdeği kesmelere kapatırsak diğer çekirdekler kesme almaya devam ederler. Ancak bu işlemi biz kesme denetleyicisi
    yoluyla yaparsak ilgili IRQ için kesme denetleyicisi kesme oluşturmayacaktır. Tabii ilgili çekirdek kesmelere kapatıldığında 
    artık "thread'ler arası geçiş (context switch)" de yapılmayacaktır. Dolayıısyla aygıt sürücünüzde ilgili çekirdeği kesmelere 
    kapatırsanız onu açmayı unutmamalısınız. Atomik işlemler bu sayede yapılabilmektedir. İşte program kodunun yürütüldüğü çekirdeği 
    kesmelere kapatmak için local_irq_disable, açmak için de local_irq_enable fonksiyonları kullanılmaktadır:

    #include <linux/irqflags.h>

    void local_irq_disable(void);
    void local_irq_enabled(void);

    Bu fonksiyonlar hangi CPU mimarisinde çalışılıyorsa o mimariye özgü makine komutlarını kullanmaktadır. Ayrıca bu fonksiyonların 
    aşağıdaki bayraklı biçimleri de vardır:

    #include <linux/irqflags.h>

    void local_irq_save(flags);
    void local_irq_restore(flags);

    Aslında bunlar birer makro olarak yazılmıştır. local_irq_save ilgili çekirdeği kesmelere kapatmakla birlikte bu işlemden önce 
    tüm CPU bayraklarını da bize vermektedir. Biz de bayrakları aynı konumla local_irq_restore fonksiyonu ile geri yükleyebiliriz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bilgisayar sistemlerinde dışsal bir olayın gerçekleşip gerçekleşmediğini anlamının iki temel yöntemi vardır:

    1) Yoklama (polling) yöntemi 
    2) Kesme (interrupt) yöntemi 

    Yoklama tekniğinde bir döngü içerisinde dışsal aygıta başvurularak "olay gerçekleşti mi" diye sorulur. Eğer olay gerçekleştiyse
    işlem yapılır. Ancak bu yöntem meşgul bir döngü (busy loop) oluşturmaktadır. Dolayısıyla önemli bir CPU zamanının harcanmasına 
    yol açabilmektedir. (Tabii bu tür yoklamalarda kritik bir durum söz konusu değilse döngü içerisine beklemeler yerleştirilebilir. 
    Bu önlem CPU kullanım oranını düşürecektir.)

    Kesme tekniğinde programcı sürekli yoklama yapmaz. Kodun akışı devam eder. Olay gerçekleştiğinde bir donanım kesmesi oluşturulur.
    Programcı da kesmeyi ele alır ve gerekli işlemi yapar. Tabii kesme yöntemi bir aygıt sürücüsü yoluyla kullanılmaktadır. 
    
    Örneğin gömülü aygıtımıza bir ısı sensörü yerleştirmiş olalım. Isı belli bir kritik düzeye geldiğinde birtakım işlemlerin 
    yapılması gerekiyor olsun. İşte yoklama yönteminde bir döngü içerisinde (muhtemelen bunun için bir thread kullanılacaktır)
    sürekli olarak ısı sensörüne bakmak gerekir. Ancak kesme tekniğinde donanım tasarımcısı zaten ısı kritik düzeye geldiğinde 
    kesme oluşturacak biçimde donanımı tasarlamıştır. Sistem programcısı da olay gerçekleştiğinde kesmeyi ele alarak gereken 
    işlemleri yapar. Yoklama yöntemini aygıt sürücü içerisinde kullanacaksanız "çekirdek thread'lerinden faydalanmalısınız.
    Klavye ve fare gibi dışsal birimler kesme yönetiminin kullanıldığı tipik birimelerdir. Biz kalvyeden bir tuşa bastığımızda 
    ve elimizi tuştan çektiğimizde donanım kesmesi oluşturulur. İşletim sisteminin kesme kodu basılan ve çekilen tuşun bilgilerini 
    alarak kullanır. Aynı durum fare için de söz konusudur. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Donanımsal kesme mekanizmasının tipik örneklerinden biri klavye kullanımıdır. PC klavyesinde bir tuşa basıldığında klavye 
    içerisindeki işlemci (keyboard encoder - Eskiden Intel 8048 ya da Holtek HT82K629B kullanılıyordu) basılan ya da çekilen 
    tuşun klavyedeki sıra numarasını (buna "scan code" denilmektedir) dış dünyaya DATA ve CLOCK uçlarıyla seri bir biçimde 
    kodlamaktadır. Bu bilgi PS2 soketli klavyelerde bilgisayarın içerisindeki klavye denetleyicisine (Intel 8042) gelir. Klavye 
    denetleyicisi (keyboard controller) bu scan kodu kendi içerisinde bir yazmaçta saklar. Kesme denetleyicisinin (PIC ya da 
    IOAPIC'in) 1 numaralı ucu klavye denetleyicisine bağlıdır ve kesme denetleyicisi bu uçtan IRQ1 kesmesini oluşturulmaktadır. 
    Dolayısıyla biz bir tuşa bastığımızda ve oarmağımızı tuştan çektiğimizde otomatik olarak basılan tuşa ilişkin klavye scan 
    kodu bilgisayar tarafına iletilir ve IRQ1 kesmesi oluşturulur. IRQ1 kesme kodu birincil olarak işletim sistemi tarafından 
    ele alınmaktadır. İşletim sistemi de bu IRQ oluştuğunda aygıt sürücülerin belirlediği fonksiyonları çağırmaktadır. Yukarıda 
    da belirttiğimiz gibi klavyede yalnızca bir tuşa basılınca değil, parmak tuştan çekildiğinde de yine klavye işlemcisi 
    (keyboard encoder) çekilen tuşun scan kodunu klavye denetleyicisine gönderip IRQ1 kesmesinin oluşmasına yol açmaktadır. 
    Yani hem tuşa basıldığında hem de parmak tuştan çekildiğinde IRQ1 oluşmaktadır. Klavye terminolojisinde parmağın tuşa 
    basılmasıyla gönderilen scan koda "make code", parmağın tuştan çekilmesiyle gönderilen scan koduna koda ise "break code" 
    denilmektedir. Bugün PC'lerde kullandığımız klavyelerde parmak tuştan çekildiğinde önce PC tarafında bir F0 byte'ı ve sonra 
    da tuşun scan kodu gönderilmektedir. Örneğin parmağımızı "A" tuşuna basıp çekelim. Şu scan kodlar bilgisayar tarafına 
    gönderilecektir:

    <A'nın scan kodu> <F0> <A'nın scan kodu>

    Scan kod aslında tuşun klavyenin kaç numaralı tuşu olduğunu belirten bir sayıdır. Klavyennin üzerindeki harflerin üretilen 
    scan code ile hiçbir ilgisi yoktur. Mrneğin Türkçe Q klavye ile F kalvye ve İngilizce klavye aynı tuşlar için aynı kodları 
    göndermektedir. 

    Ctrl, Shift, Alt, Caps-Lock gibi tuşların da diğer tuşlardan bir farkı yoktur. Örneğin biz önce Ctrl tuşuna sonra A tuşuna 
    basmış olalım ve sonra parmağımızı önce A tulundan sonra da Ctrl tuşundan çekmiş olalım. Klavye işlemcisi bilgisayar tarafına 
    şu kodları gönderecektir:

    <Ctrl'nin scan kodu> <A'nın scan kodu> <F0> <A'nın scan kodu> <F0> <Ctrl'nin scan kodu>

    İşte Ctrl tuşuna basıldığını fark eden işletim sistemi bir bayrağı (flag) set eder, parmak bu tuştan bırakıldığında da bu 
    bayrağı reset eder. Böylece diğer tuşlara basıldığında bu bayrağa bakılarak Ctrl tuşu ile bu tuşa birlikte basılıp basılmadığı 
    anlaşılmaktadır.

    Klavye içerisindeki işlemcinin "typematic" denilen bir özelliği vardır. Klavyeden bir tuşa basılıp parmak tuşta bekletilirse 
    belli bir periyotta o tuş için sürekli scan code gönderilmektedir. Örneğin biz parmağımızla 'A' tuluna basalım. Biraz bekleyip 
    parmağımızı çekelim klavye içerisindeki klavye işlemcisi dış dünyaya şöyle kodlar göncerecektir:

    <A'nın scan kodu> <A'nın scan kodu> <A'nın scan kodu> ... <A'nın scan kodu> F0 <A'nın scan kodu>

    Typematic yapılırken ilk basmadan typematic'e kadar olan bekleme süresi ve typematic periyodu klavye içerisindeki işlemci 
    programlanarak ayarlanabilmektedir. Örnğin PS2 klavyelerde biz Windows'tan bu ayarı değiştrdiğimizde Windows o anda 
    klavye içerisindeki işlemciyi programlar, aynı zamanda bu ayarı da saklar. Bilgisayar yeniden açıldığında klavye içerisindeki 
    işlemciyi bu ayarla yeniden programlar. Tabii PS2 kalvyeyi çıkartıp yeniden taktığımızda PS2 sistemi "plug and play" olmadığı
    için ayar default duruma gelecektir. (Ancak USB klavyeleri çıkartıp taktığımızda işletim sistemi bunu anlayıp klavye takıldığında
    klavye içerisindeki işlemciyi yeniden programlamaktadır.)

    Peki biz Linux'ta stdin dosyasından (0 numaralı betimleyici) okuma yaptığımızda neler olmaktadır? İşte aslında işletim 
    sistemi bir tuşa basıldığında basılan tuşları klavye denetleyicisinden alır ve onları bir kuyruk sisteminde saklar. Terminal 
    aygıt sürücüsü de bu kuyruk sistemine başvurur. Kuyrukta hiç tuş yoksa thread'i bu amaçla oluşturulmuş bir wait kuyruğunda 
    bekletir. Klavyeden bir tuşa basılınca da wait kuyruğunda bekleyen thread'leri uyandırır. Yani okuma yapıldığında o anda 
    klavyeden okuma yapılmamaktadır, kuyruklanmış olan tuşlar okunmaktadır.

    Yukarıda da belirttiğimiz gibi klavyedeki tuşların üzerinde yazan harflerin hiçbir önemi yoktur. Yani İngilizce klavye 
    ile Türkçe klavye aynı tuşlar için aynı scan kodlarını göndermektedir. Basılan tuşun hangi tuş olduğu aslında dil ayarlarına 
    bakılarak işletim sistemi tarafından anlamlandırılmaktadır.

    Klavye ile bilgisayar arasındaki iletişim tek yönlü değil çift yönlüdür. Yani klavye denetleyicisi de (PC tarafındaki 
    denetleyici) isterse klavye içerisindeki işlemciye komutlar gönderebilmektedir. Aslında klavye üzerindeki ışıkların 
    yakılması da klavyenin içerisinde tuşa basılınca yapılmamaktadır. Işıklı tuşlara basıldığında gönderilen scan kod klavye 
    denetleyicisi tarafından alınır eğer bu tuş ışıklı tuşlardan biri ise işletim sistemi klavye denetleyicisine "ışık yakma 
    emri" verir. Klavye denetleyicisi de klavye içerisindeki klavye işlemcisine "falanca tuşun ışığı yak" komutunu göndermektedir. 
    Özetle yeniden ifade edersek klavyedeki ışıklar klavye devresi tarafından ilgili tuşlara basılınca yakılmamaktadır. Karşı 
    taraftan emir geldiğinde yakılmaktadır. Tasarımın bu biçimde yapılmış olması çok daha esnek bir kullanım oluşturmaktadır.

    Burada önemli bir noktayı vurgulamak istiyoruz. Bugün artık bilgisayarlarda eski PS2 soketleri bulunmamaktadır. Klavyeler 
    de USB portundan bilgisayara bağlanmaktadır. USB portlarının işleyişi ve USB aygıt sürücüleri farklı bir konudur. Biz yukarıda
    PC mimarisindeki klasik PS2 soketli klavyelerdeki durumu açıkladık. Neyse ki sanal makineler default durumda ana bilgisayarda 
    (host) USB klavye kullanılıyor olsa bile sanki PS2 klavye kullanılıyormuş gibi bir etki oluşturmaktadır. Bu nedenle siz 
    aşağıda vereceğimiz örneği USB klavye kullanılan ana makinede kullanamazsınız.

    Aşağıdaki örnekte klavyeden tuşa basıldığında ve çekildiğinde oluşan 1 numaralı IRQ ele alınıp işlenmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static int g_count;
    
static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1,  &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "irq-driver exit...\n");
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    ++g_count;
    printk(KERN_INFO "IRQ1 ocurred: %d\n", g_count);

    return IRQ_HANDLED;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*-----------------------------------------------------------------------------------------------------------------------------
                                        115. Ders 17/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    CPU ile RAM arasında veri transferi aslında tamamen elektriksel düzeyde 1'lerle 0'larla gerçekleşmektedir. CPU'nun adres 
    uçları (address bus) RAM'in adres uçlarına bağlanır. Bu adres uçları RAM'den transfer edilecek bilginin fiziksel adresini 
    belirtmek için kullanılmaktadır. CPU'nun veri uçları (data bus) ise bilginin alınıp gönderilmesinde kullanılmaktadır. 
    İşlemin okuma mı yazma mı olduğu genellikle R/W biçiminde isimlendirilen ayrı bir kontrol ucuyla belirlenmektedir. Ayrıca CPU 
    ile RAM arasındaki iletişimde başka kontol uçları da kullanılmaktadır. CPU ile RAM arasındaki bağlantıyı aşağıdaik şekille 
    özetleyebiliriz:
    
        CPU
      ┌──────┐
      │      │
      │      │
      │      │
      └─┬─┬──┘
        │ │
        │ └────────────► Kontrol Yolu
        │
        ├──────────────► Adres Yolu
        │
        └──────────────► Veri Yolu
                      │
                   Memory Controller
                      │
               ┌─────────────┐
               │             │
               ▼             ▼
            RAM Slot 1    RAM Slot 2

    
    Örneğin 32 bit Intel işlemcilerinde MOV EAX, [XXXXXXXX] komutu RAM'deki XXXXXXXX adresinden başlayan 4 byte bilginin CPU 
    içerisindeki EAX yazmacına çekileceği anlamına gelmektedir. Bu makine komutu işletilirken CPU önce erişilecek adres olan 
    XXXXXXXX adresini adres uçlarına elektriksel olarak kodlar. RAM bu adresi alır, bu adresten başlayan 4 byte'lık bilgiyi 
    veri uçlarına elektriksel olarak bırakır. CPU'da bu uçlardan bilgiyi yine elektriksel olarak alır ve EAX yazmacına 
    yerleştirir. CPU'nun adres uçları RAM'in adres uçlarına, CPU'nun veri uçları ise RAM'in veri uçlarına bağlıdır. Transfer 
    yönü R/W ucuyla belirlenmektedir.  
    
    Eskiden RAM'ler CPU'lardan daha hızlıydı. 80'li yılların ortalarına doğru CPU hızları RAM'leri yakaladı ve onları geçti. 
    Bugün kullanılan CPU'lar RAM'lerden çok daha hızlıdır. Bu nedenle CPU RAM'den bir bölgenin içeriğini istediğinde RAM 
    onu verene kadar CPU beklemektedir. İşte bu bekleme süresini azaltmak için DRAM belleğin en çok erişilen kısımları 
    SRAM denilen daha hızlı RAM'lerde tutulmaya başlanıştır. Eskiden cache amacıyla kullanılan bu SRAM bellekler board 
    üzerinde bulunuyordu. Belli bir zamandan sonra CPU'nun içerisine de cache bellek yerleştirilmeye başlandı. Bugün tipik 
    olarak bilgisayar sistemlerinde L1, L2, L3 ismiyle üç kademe cache sistemleri bulundurulmaktadır. Böylece CPU RAM'den 
    bir bölgeyi okumak istediğinde önce kendi içerisindeki L1 cache belleğe, sonra sırasıyla L2 ve L3 cache belleklere 
    başvurmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde yalnızca CPU değil, aynı zamanda yerel birtakım olaylardan sorumlu yardımcı işlemciler de bulunmaktadır. 
    Bu yardımcı işlemcilere genellikle "controller (denetleyici)" denilmektedir. Örneğin klasik PC donanımında "Kesme Denetleyicisi 
    (Intel 8259-PIC)", "Klavye Denetleyicisi (Intel 8042-Keyboard Controller)", "UART Denetleyicisi (Intel 8250/NS 16550-UART)" 
    gibi pek çok işlemci vardır. Bu işlemcilere komutlar tıpkı CPU/RAM haberleşmesinde olduğu gibi elektriksel düzeyde CPU'nun 
    adres uçları ve veri uçları yoluyla gönderilmekte ve bu işlemcilerden bilgiler yine tıpkı RAM'de olduğu gibi adres uçlarıyla 
    ve veri uçlarıyla alınmaktadır. Yani CPU'nun adres uçları ve veri uçları yalnızca RAM'e değil yardımcı işlemcilere de bağlıdır. 
    
    Bilgisayar sistemindeki yerel işlemlerden sorumlu yerel işlemciler yukarıda da belirttiğimiz gibi CPU tarafından elektriksel 
    olarak programlanmaktadır. Tabii aslında CPU programcının komutlarını çalıştırır. O halde yardımcı işlemcileri de programlayan 
    aslında sistem programcısıdır. Peki CPU yardımcı işlemcilere nasıl erişmektedir? İşte bilgisayar donanım tasarımında bu
    erişim iki farklı teknikle yapılabilmektedir:

    1) Port-Mapped IO (PMIO)
    2) Memory-Mapped IO (MMIO)

    İşlemcinin yardımcı işlemcilere erişimi aynı zamanda CPU mimarisi ile de ilgilidir. Örneğin Intel işlemcileri hem "port-mappped
    IO" tekniğinin hem de "memory-mapped IO" tekniğinin kullanımına izin verecek biçimde tasarlanmıştır. Ancak ARM işlemcileri 
    yalnızca "memory-mapped IO" tekniğinin kullanımına izin vermektedir. 

    Peki "port-mapped IO" tekniğinde CPU yardımcı işlemciye nasıl erişmektedir? İşte nasıl RAM'de her byte'ın bir adresi varsa
    yardımcı işlemcilerin de ismine "port numarası" denilen donanımsal bir adresi vardır. CPU "bu yardımcı işlemcilere onların 
    port adreslerini kullanarak erişmektedir. Bazı yardımcı işlemciler tek bir port adresine sahiptir. Bazılarının ise birden fazla 
    port adresi bulunabilmektedir. Peki CPU hem RAM'e hem de yardımcı işlemcilere adres ve veri uçlarıyla bağlı olduğuna göre 
    bu durumda elektriksel düzeyde bir iletişim çatışması oluşmaz mı? İşte "port-mapped IO" tekniğini kullanan işlemcilerde 
    genellikle IO/Mem biçiminde isimlendirilen bir kontrol ucu daha vardır. Bu uç yardımcı işlemcilere erişimde aktive edilirken 
    RAM erişimlerinde aktive edilmemektedir. Böylece RAM ve yardımcı işlemciler iletişimin kendileri ile yapılıp yapılmadığını 
    bu uca bakarak anlayabilmektedir. "Port-mapped IO" kullanan CPU'larda yardımcı işlemcilere bilgi gönderip onlardan bilgi almak 
    için özel makine komutları bulunmaktadır. Örneğin Intel işlemcilerinde IN, OUT, INS, OUTS makine komutları bu amaçla 
    kullanılmaktadır. 

    Memory-mapped IO tekniğinde "sanki RAM'in bir kısmı çıkartılmış da onun yerine oraya yardımcı işlemci" yerleştirilmiş 
    gibi bir durum oluşturulmaktadır. Böylece CPU sanki RAM'deki bir bölgeye erişiyormuş gibi yardımcı işlemcilere erişmektedir. 
    Bu teknik çeşitli avantajlar sağlamaktadır:

    1) Bu teknikle yardımcı işlemcilere normal bellek komutlarıyla erişilebilmektedir. Hatta C'de bir gösterici ile bile yardımcı 
    işlemcilere komut gönderilmesi onlardan bilgilerin alınması mümkün olmaktadır.
    
    2) Bu tekniğin uygulanması donanım tasarımcıları ve sistem programcıları için daha kolaydır ve temikle daha genel bir çözüm
    oluşturulabilmekltedir.

    3) Intel gibi bazı CPU mimarilerinde "port-mapped IO" için belli sayıda port adresi kullanılabilmektedir. Ancak "memory-mapped
    IO" tekniğinde istenildiği kadar port adresi kullanılabilmektedir.

    Ancak "memory-maped IO"tekniği fiziksel RAM'in ilgili kısımlarını kullanılamaz hale getirmektedir. Bu teknikte RAM'in bazı 
    bölgelerinde adeta RAM yok gibidir bu bölgeler yardımcı işlemcilere bağlıdır. 
   
    Peki biz sistem programcısı olarak ilgilendiğimiz yardımcı işlemci eğer "port-mapped IO" kullanıyorsa yardımcı onun port 
    numaralarını nasıl öğrenebiliriz? Benzer biçimde eğer yardımcı işlemci "memory-mapped IO" kullanıyorsa onun bellek adreslerini 
    nasıl öğrenebiliriz? Kurusumuzda daha önce kendini tanıtabilen aygıtların olabildiğinden bahsetmiştik. PC mimarisinde ACPI 
    denilen arayüz sayesinde sistem BIOS yardımcı işlemcilerin hangi port numaralarını kullandığını öğrenip bunu ACPI tablosuna
    yazabilmektedir. Gömülü sistemlerde ise bunun için "aygıt ağaçlarının (device trees)" kullanıldığını anımsayınız. İşte Linux
    işletim sistemi ACPI tablosundan ya da aygıt ağacından bu bilgileri alarak "/proc/ioports" ve "/proc/iomem" dosyaları yoluyla 
    bu bilgileri dış dünyaya vermektedir. Tabii aslında yardımcı işlemcilerin kullandığı default port numaraları ve bellek adresleri 
    çoğu kez zaten sistem programcısı tarafından biliniyor durumdadır. Bu default port numaraları ve default adresler bu tür 
    yardımcı işlemcilere ilişkin çeşitli kaynaklarda belirtilebilmektedir. 

    O halde bizim bir yardımcı işlemciyi programlayabilmemiz için şu bilgileri edinmiş olmamız gerekmektedir:

    1) Yardımcı işlemci "port-mapped IO" mu yoksa "memory-mapped IO" mu kullanmaktadır?
    2) Yardımcı işlemcinin port numaraları (ya da "memory-mapped IO" söz konusu ise bellek adresleri) nedir?
    3) Bu yardımcı işlemcinin hangi portuna (ya da "memory-mapped IO" söz konusu ise hangi adrese) hangi değerler gönderildiğinde 
    bu işlemci ne yapmaktadır?
    4) İşlemci bize bilgi verecekse bunu hangi portu okuyarak (ya da "memory-mapped IO" söz konusu ise hangi adresi okuyarak) 
    vermektedir? Verilen bilginin biçimi nedir?   
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki yardımcı işlemcilerin programlanması "kullanıcı modunda (user mode)" yapılabilir mi? Bunun için aygıt sürücüsü yazmaya
    gerek var mı? Aslında Linux işletim sisteminde yardımcı işlemciler üzerinde basit IO işlemlerinin yapılabilmesini sağlamak
    için "/dev/port" ve "/dev/mem" aygıt sürücüleri hazır bulundurulmuştur. Ancak bu aygıt sürücüler yoluyla donanım aygıtlarını
    programlamak karmaşık işlemlerde hem yavaş hem de eksik kontrol sağlamaktadır. Bu nedenle donanım aygıtları genellikle 
    çekirdek modunda çalışan aygıt sürücüler yoluyla doğrudan programlanmaktadır. 

    "/dev/port" aygıt sürücüsü oldukça basit bir tasarıma sahiptir. Programcı bu dosyayı açar. Sonra lseek fonksiyonuyla dosya
    göstericisini hangi port ile ilgileniyorsa o port numarasına konumlandırır. Bu konumlandırmadan sonra bu dosyadan read ve 
    write yapıldığında aygıt sürücünün read ve write fonksiyonları aslında "port-mapped IO" için gereken IN, OUT gibi makine 
    komutlarını kullanmaktadır. read ve write işlemi dosya göstericisinin konumunu ilerletmektedir. Aynı porttan işlem yapılırken 
    dikkat etmek gerekir.  
    
    "/dev/mem" aygıt sürücüsü ise "memory-mapped IO" tekniğini kullanan aygıtların kullanıcı modunda programlanmasını sağlamaktadır. 
    Bu aygıt sürücü fiziksel RAM'i adeta bir dosya gibi göstermektedir. Tabii bu aygıt sürücüyle "memory-mapped IO" işlemi için 
    mmap fonksiyonu ile "memory mapping" yapmak gerekir. Yani adreste bu dosya bellek tabanlı biçimde açılır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki yardımcı işlemcileri programlarken onlara tek hamlede kaç byte bilgi gönderip onlardan kaç byte bilgi okuyabiliriz?
    İşte bazı işlemciler (özellikle eskiden tasarlanmış olanlar) byte düzeyinde programlanmaktadır. Bazıları ise WORD düzeyinde 
    bazıları ise DWORD düzeyinde programlanabilmektedir. O halde bizim bir haberleşme portuna 1 byte, 2 byte, 4 byte gönderip 
    alabilmemiz gerekir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            116. Ders 22/07/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki bir yardımcı işlemci çekirdek modunda aygıt sürücüler içerisinde programlanabiliyorsa kullanıcı mode programlar bu 
    yardımcı işlemciyi nasıl kullanmaktadır? İşte tipik olarak kullanıcı modundaki programlar read/write işlemleri ile ve ioctl 
    işlemleriyle aygıt sürücünün kodlarını çalıştırırlar. Aygıt sürücüler de bu kodlarda ilgili yardımcı işlemciye komutlar 
    yollayabilir. Tabii karmaşık yardımcı işlemciler için aygıt sürücüleri yazanlar faydalı işlemlerin daha kolay yapılabilmesi 
    için daha yüksek seviyeli fonksiyonları bir API kütüphanesi yoluyla da sağlayabilmektedir. Bunu şekilsel olarak şöyle 
    gösterebiliriz:

    Kütüphane fonksiyonları -----> read/write ve ioctl ----> çekirdek modundaki aygıt sürücücü kodları
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Port-mapped IO işlemlerinde kullanılması gereken işlemcilerin IN, OUT gibi makine komutları "özel (privileged)" komutlardır. 
    Bunlar kullanıcı modundan kullanılırsa işlemci koruma mekanizması gereği bir içsel kesme oluşturur, işletim sistemi de bu 
    kesme kodunda prosesi sonlandırır. Dolayısıyla bu komutları kullanarak donanım aygıtlarıyla konuşabilmek için çekirdek modunda 
    çalışan aygıt sürücülerin yazılması gerekmektedir. 

    Aygıtlara erişmekte kullanılan komutlar CPU mimarisine göre değişebildiğinden Linux çekirdeğinde bunlar için ortak arayüze 
    sahip inline fonksiyonlar bulundurulmuştur. Bu fonksiyonlar şunlardır:

    #include <asm/io.h>

    unsigned char inb(int addr);
    unsigned short inw(int addr);
    unsigned int inl(int addr);

    void outb(unsigned char b, int addr);
    void outw(unsigned short b, int addr);
    void outl(unsigned int b, int addr);

    inb haberleşme portlarından 1 byte, inw 2 byte, inl 4 byte okumak için kullanılmaktadır. Benzer biçimde haberleşme portlarına 
    outb 1 byte, outw 2 byte ve outl de 4 byte göndermektedir. Bir aygıtın portlarına kaç byte'lık komutların göndeirleceği ve 
    ondan kaç byte'lık okuma yapılacağı o aygıtın donanım tasarımını yapanlar tarafından belirlenmektedir. Eski yardımcı işlemciler
    1 byte komutlar kullanıyordu. Daha sonra 2 byte kullanan ve 4 byte kullanan yardımcı işlemciler de geliştirildi. Tek hamlede 
    8 byte (qword) gönderme ve almaya izin veren yardımcı işlemciler çok seyrek kullanılmaktadır. 

    Bazı mimarilerde bir bellek adresinden başlayarak belli bir sayıda byte'ı belli bir porta gönderen ve belli bir porttan 
    yapılan okumaları belli bir adresten itibaren belleğe yerleştiren özel makine komutları vardır. Bu komutlara string komutları 
    denilmektedir. (Intel'de string komutları yalnızca IO işlemleri ile ilgili değildir.) İşte bu komutlara sahip mimarilerde bu 
    string komutlarıyla IN, OUT yapan çekirdek fonksiyonları da bulundurulmuştur:

    #include <asm/io.h>

    void insb(unsigned long addr, void *buffer, unsigned int count);
    void insw(unsigned long addr, void *buffer, unsigned int count);
    void insl(unsigned long addr, void *buffer, unsigned int count);

    void outsb(unsigned long addr, const void *buffer, unsigned int count);
    void outsw(unsigned long addr, const void *buffer, unsigned int count);
    void outsl(unsigned long addr, const void *buffer, unsigned int count);

    insb, insw ve insl sırasıyla 1 byte 2 byte ve 4 byte'lık string fonksiyonlarıdır. Bu fonksiyonlar birinci parametresiyle 
    belirtilen port numarasından 1, 2 ya da 4 byte'lık bilgileri ikinci parametresinde belirtilen adresten itibaren belleğe 
    yerleştirirler. Bu işlemi de count kere tekrar ederler. Yani bu fonksiyonlar porttan count defa okuma yapıp okunanları buffer
    ile belirtilen adresten itibaren belleğe yerleştirmektedir. outsb, outsw ve outsl fonksiyonları ise bu işlemin tam tersini 
    yapmaktadır. Yani bellekte bir adresten başlayarak count tane byte'ı birinci parametresiyle belirtilen porta göndermektedir.

    Bazı sistemlerde aygıtlar (yani tardımcı işlemciler) yavaş kalabilmektedir. Eğer bus çok hızlı, aygıt yavaş ise o aygıt 
    portlarına peşi sıra bilgiler gönderilip alınırken sorunlar oluşabilmektedir. Bunun için bilgiyi porta gönderdikten ya da 
    bilgiyi porttan aldıktan sonra kısa bir süre bekleme yapmak gerekebilir. İşte bu nedenle yukarıdaki fonksiyonların bekleme 
    yapan p'li (pause) versiyonları da bulundurulmuştur.

    #include <asm/io.h>

    unsigned char inb_p(int addr);
    unsigned short inw_p(int addr);
    unsigned int inl_p(int addr);

    void outb_p(unsigned char b, int addr);
    void outw_p(unsigned short b, int addr);
    void outl_p(unsigned int b, int addr);
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir haberleşme portu ile çalışmadan önce o portun boşta olup olmadığını belirlemek gerekebilir. Çünkü başka aygıtların 
    kullandığı portlara erişmek sorunlara yol açabilmektedir. Tabii eğer biz ilgili portun kullanılmasının bir soruna yol 
    açmayacağından eminsek başkalarının kullandığı portları doğrudan kullanabiliriz. Çekirdek bu bakımdan bir kontrol 
    yapmamaktadır. Kullanmadan önce bir portun başkaları tarafından kullanılıp kullanılmadığının sorgulanması için request_region 
    isimli çekirdek fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

    Fonksiyonun birinci parametresi kullanılmak istenen port numarasının başlangıç numarasını, ikinci parametresi ilgili 
    port numarasından itibaren ardışıl kaç port numarasının kullanılacağını, üçüncü parametresi ise "/proc/ioports" dosyasında 
    görüntülenecek ismi belirtmektedir. Fonksiyon başarı durumunda portları betimleyen resource isimli yapının başlangıç 
    adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Örneğin:

    if (request_region(PORT_START, NPORTS, "myports) == NULL) {
        ...
    }

    Eğer talep edilen port'ları başka bir aygıt sürücü daha önce request_region fonksiyonu ile elde etmişse request_region 
    fonksiyonu başarısız olmaktadır. Yukarıda da belirttiğimiz gibi aslında bu fonksiyon hiç çağrılmadan port kullanılabilir. 
    Ancak bu mekanizma bir çeşit anlaşma sağlamaktadır. 
        
    request_region fonksiyonu ile tahsis edilen port numaraları release_region fonksiyonu ile serbest bırakılmalıdır:

    #include <linux/ioport.h>

    void release_region(unsigned long start, unsigned long n);

    Yukarıda da belirttiğimiz gibi portların kullanılması için bu biçimde tahsisat yapma zorunluluğu yoktur. Ancak programcı 
    programlanabilir IO portları söz konusu olduğunda ilgili port numaralarını başkalarının kullanmadığından emin olmak için 
    bu yöntemi izlemelidir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    PC'lerdeki klavye denetleyicisinin (klavye içerisindeki değil, PC tarafındaki denetleyicinin (orijinali Intel 8042)) 60H 
    ve 64H numaralı iki portu vardır. 60H portu hem okunabilir hem de yazılabilir durumdadır. 60H portu 1 byte olarak okunduğunda 
    son basılan ya da çekilen tuşun klavye scan kodu elde edilmektedir. Yukarıda da belirttiğimiz gibi klavye terminolojisinde 
    tuşa basılırken oluşturulan scan koduna "make code", parmak tuştan çekildiğinde oluşturulan scan koduna ise "break code" 
    denilmektedir. Klavye içerisindeki işlemcinin (keyboard encoder) break code olarak önce bir F0 byte'ını sonra da make code 
    byte'ını gönderdiğini belirtmiştik. İşte PC içerisindeki klavye denetleyicisi bu break kodu aldığında bunu iki byte olarak 
    değil, yüksek anlamlı biti 1 olan byte olarak saklamaktadır. Böylece biz 60H portunu okuduğumuzda onun yüksek anlamlı bitine 
    bakarak okuduğumuz scan kodunun make code mu yoksa break code mu olduğunu anlayabiliriz.

    Klavye denetleyicisinin 60H portuna gönderilen 1 byte değere "keyboard encoder command" denilmektedir. Bu 1 byte'lık komut 
    klavye denetleyicisi tarafından klavye içerisindeki işlemciye gönderilir. Ancak bu 1 byte'tan sonra bazı komutlar parametre 
    almaktadır. Parametreler de komuttan sonra 1 byte olarak aynı port yoluyla iletilmektedir.

    Aşağıdaki aygıt sürücü örneğinde klavyeden tuşlara basıldığında basılan ve çekilen tuşların make ve break code'ları 
    yazdırılmaktadır. Ancak burada bir noktayı belirtmek istiyoruz. Biz bu örnekte IRQ1 kesme kodunda 60h protunu okuduğumuzda 
    Linux çekirdeği de bu portu okuduğu için klavye denetleyicisinin tasarımından dolayı bazı çalışma sorunları ortaya çıkabilecektir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>
#include <asm/io.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static unsigned char g_keymap[128] = {
    [30] = 'A',
    [31] = 'S',
    [32] = 'D',
    [33] = 'F',
};
  
static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "keyboard-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "keyboard-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "keyboard-driver init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1,  &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "keyboard-driver exit...\n");
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    unsigned char code;
    char *code_type;

    code = inb(0x60);

    code_type = code & 0x80 ? "Break code: " : "Make code: ";

    if (g_keymap[code & 0x7F])
        printk(KERN_INFO "%s %c (%02X)\n", code_type, g_keymap[code & 0x7F], code);
    else
        printk(KERN_INFO "%s %02X\n", code_type, code);

    return IRQ_HANDLED;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*-----------------------------------------------------------------------------------------------------------------------------
                                            117. Ders 24/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Intel tabanlı masaüstü bilgisayarlardaki RTC (Real Time Clock) devresinden zamanı okuyan bir aygıt sürücü yazalım.
    Bugün kullandığımız PC'lerde bilgisayar kapatıldıktan sonra zamanı tutanm ismine "gerçek zaman saati (real time clock)" 
    denilen bir yardımcı işlemci (denetleyici) vardır. Masaüstü bilgisayarlarımızı açarken Del ya da F1 tuşuna basarak çıkarttığımız 
    setup ekranındaki bilgiler de (buna CMOS setup bilgileri de denilmektedir) aslında aynı denetleyicinin içerisindeki bir 
    RAM'de tutulmaktadır. RTC denetleyicisi bir pille beslenmektedir. İşletim sistemleri boot işlemi sırasında RTC denetleyicisine 
    başvurarak tarih ve zamanı alıp sonra da bu tarih ve zamanı bilgisayar açık olduğu sürece güncellemektedir. Yani genellikle 
    RTC denetleyicisine yalnızca açılış sırasında başvurulmaktadır. Tabii biz işletim sisteminde saati ve tarihi ayarladığımızda 
    işletim sistemi de RTC denetleyicisindeki saati yeniden ayarlar. 

    PC'lerimizdek RTC denetleyicisi ile port-mapped IO kullanılarak haberleşilmektedir. RTC denetleyicisinin iki portu vardır. 
    Pc'lerimizde bu portlar 70h ve 71h portlarıdır. RTC 8 bitlik bir denetleyicidir. Dolayısıyla bu portlarla 8 bitlik değerler 
    okunup yazılabilmektedir. 70h portu kontrol portudur, 71h portu ise bilgilerin alındığı ve gönderildiği porttur. Sistem 
    programcısı önce 70h portuna komut göndererek 71h prortunun hangi amaçla kullanılacağını belirler. Sonra 71h portunu okur 
    ya da ona yazma yapar. Biz aşağıdaki örneğimizde 70h portuna komut gönderdikten sonra 71h portunu okuyan bir fonksiyon 
    tanımladık:

    static inline unsigned int rtc_read(unsigned int cmd)
    {
        outb(cmd, 0x70);         
        return inb(0x71);        
    }

    RTC denetleyicisinden saat, dakika ve saniye bilgilerini de şöyle ettik:

    hour = rtc_read(0x04);
    minute = rtc_read(0x02);
    second = rtc_read(0x00);

    RTC denetleyicisi bilgileri binry ta da BCD olarak verebilmektedir. Bu durum ayarlanabilmektedir. RTC denetleyicisinin 
    verdiği bilgilerin binary mi yoksa BCD mi olduğu 70H portuna 0x0B gönderilip 71H protunun okunmasıyla elde edilebilmektedir. 
    Örneğin:

    if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
        ...
    }
    else {
       ...
    }

    Aslında RTC denetleyicisinden bilgi okunurken tesadüfen onun güncelleme işlemine denk gelinirse geçersiz değerler okunabilmektedir.
    Bu nedenle okuma işleminin daha güvenli bir biçimde yapılması gerekir. Ancak biz burada karmaşıklık oluşmasın diye bu durumu 
    göz ardı ediyourz.

    Örneğimizde bir aygıt sürücü oluşturarak aygıt sürücü için ioctl fonksiyonunu yazdık. Aygıt sürücünün iotcl fonksiyonu 
    şöyle yazılmıştır:

    static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;

        switch (cmd) {
            case IOC_RTC_GETTIME:
                result = ioctl_gettime(filp, (struct RTC_TIME *)arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    static inline unsigned int rtc_read(unsigned int cmd)
    {
        outb(cmd, 0x70);         
        return inb(0x71);        
    }

    static inline int bin_to_bcd(int val)
    {
        return (val >> 4 ) * 10 + (val & 0x0F);
    }

    static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct)
    {
        struct RTC_TIME rtm;
        int hour, minute, second;
        
        hour = rtc_read(0x04);
        minute = rtc_read(0x02);
        second = rtc_read(0x00);
        
        if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
            rtm.hour = bin_to_bcd(hour);
            rtm.minute  = bin_to_bcd(minute);
            rtm.second = bin_to_bcd(second);
        }
        else {
            rtm.hour = hour;
            rtm.minute  = minute;
            rtm.second = second;
        }

        if (copy_to_user(rtct, &rtm,  sizeof(rtm)) != 0)
            return -EFAULT;   

        return 0;
    }

    Kullanıcı modundan zaman bilgisi ioctl çağrısı ile elde edilmektedir. Örneğin:

    int fd;
    struct RTC_TIME rtct;
		
	if ((fd = open("rtc-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_RTC_GETTIME, &rtct) == -1)
        exit_sys("ioctl");

    printf("%02d:%02d:%02d\n", rtct.hour, rtct.minute, rtct.second);

    close(fd);
-----------------------------------------------------------------------------------------------------------------------------*/

/* rtc-driver.h */

#ifndef RTC_DRIVER_H_
#define RTC_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

struct RTC_TIME {
    int hour;
    int minute;
    int second;
};

#define RTC_DRIVER_MAGIC		    'r'
#define IOC_RTC_GETTIME		        _IOR(RTC_DRIVER_MAGIC, 1, struct RTC_TIME)

#endif

/* rtc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include "rtc-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("rtc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.write = generic_write,
	.release = generic_release,
    .unlocked_ioctl = rtc_driver_ioctl
};

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "rtc-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "rtc-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

	return 0;
}

static void __exit generic_exit(void)
{
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "rtc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "rtc-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "rtc-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "rtc-driver read...\n");

	return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "rtc-driver write...\n");

	return 0;
}

static long rtc_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;

    switch (cmd) {
        case IOC_RTC_GETTIME:
            result = ioctl_gettime(filp, (struct RTC_TIME *)arg);
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline unsigned int rtc_read(unsigned int cmd)
{
    outb(cmd, 0x70);         
    return inb(0x71);        
}

static inline int bin_to_bcd(int val)
{
    return (val >> 4 ) * 10 + (val & 0x0F);
}

static long ioctl_gettime(struct file *filp, struct RTC_TIME *rtct)
{
    struct RTC_TIME rtm;
    int hour, minute, second;
    
    while (rtc_read(0x0A) & 0x80)
        ;

    hour = rtc_read(0x04);
    minute = rtc_read(0x02);
    second = rtc_read(0x00);
    
    if ((rtc_read(0x0B) & 0x04) == 0) {     /* BCD? */
        rtm.hour = bin_to_bcd(hour);
        rtm.minute  = bin_to_bcd(minute);
        rtm.second = bin_to_bcd(second);
    }
    else {
        rtm.hour = hour;
        rtm.minute  = minute;
        rtm.second = second;
    }

    if (copy_to_user(rtct, &rtm,  sizeof(rtm)) != 0)
		return -EFAULT;   

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* rtc.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "rtc-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct RTC_TIME rtct;
		
	if ((fd = open("rtc-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_RTC_GETTIME, &rtct) == -1)
        exit_sys("ioctl");

    printf("%02d:%02d:%02d\n", rtct.hour, rtct.minute, rtct.second);

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve işlemciler tarafından yapılan önemli bir optimizasyon temasına "komutların yer değiştirilmesi (instruction 
    reordering)" denilmektedir. Bu optimizasyon hem derleyici tarafından hem de işlemcinin kendisi tarafından yapılabilmektedir. 
    Bu optimizasyonda birbirlerini normal bir durumda etkilemeyecek iki ya da daha fazla ayrı makine komutunun yerleri hız kazancı
    sağlamak amacıyla yer değiştirilmektedir. Bu tür yer değiştirmeler normal kullanıcı modu programlarında hiçbir davranış 
    değişikliğine dolayısıyla da soruna yol açmazlar ancak işletim sistemlerinin ve aygıt sürücülerinin yazımı sırasında bu duruma 
    dikkat edilmesi gerekir. Bu tür çekirdek kodlamalarında komutların işlemci tarafından yer değiştirilmesi potansiyel sorunların
    ortaya çıkmasına yol açabilmektedir. Örneğin birbirleriyle alakasız iki adrese yazma yapılması durumunda yazma komutlarının 
    yer değiştirmesi işlemcinin bu işleri daha hızlı yapabilmesine yol açabilmektedir. Fakat IO portları ve memory-mapped IO söz 
    konusu olduğunda bu sıralama değişikliği istenmeyen olumsuz sonuçlar doğurabilmektedir. Yalnızca bu biçimdeki IO işlemlerinde 
    değil aynı zamanda senkronizasyon nesnelerinin gerçekleştiriminde de komutların yer değiştirmesi durumuna dikkat edilmesi 
    gerekir. İşte bu yer değiştirmeyi ortadan kaldırmak için "bellek bariyeri (memory barrier)" koyma yöntemi uygulanmaktadır. 
    İşlemciler bellek bariyerininin yukarısıyla aşağısını yer değiştirmemektedir. Linux çekirdeğinde kullanılan Bariyer fonksiyonları 
    şunlardır:

    #include <asm/system.h>

    void rmb(void);
    void wmb(void);
    void mb(oid);

    rmb fonksiyonunun aşağısındaki kodlar yukarısındaki okuma işlemleri yapıldıktan sonra yapılırlar. wmb fonksiyonunda 
    ise wmb fonksiyonun yukarısındaki yazma işlemleri yapıldıktan sonra aşağıdaki kodlar çalıştırılır. mb fonksiyonu ise 
    hem okuma hem yazma için yukarıdaki ve aşağıdaki kodları birbirlerinden ayırmaktadır. Örneğin:

    ...
    wmb();
    ...

    Burada wmb fonksiyonunun yukarısındaki belleğe yazma işlemleri bittikten sonra altındaki kodlar çalıştırılacaktır. Bellek 
    bariyerleri Intel ve ARM mimarilerinde özel makine komutlarıyla sağlanmaktadır. Bu fonksiyonlar hangi mimari söz konusuysa 
    o mimariye özgü bariyer oluşturan makine komutlarını kullanmaktadır.
    
    Linux çekirdeğinde önceki paragraflarda gördüğümüz port-mapped IO fonksiyonları zaten kendi içlerinde bellek bariyerlerini 
    kullanmaktadır. Bu nedenle bizim aşağıdaki gibi port işlemlerinde ayrıca bariyer kullanmamıza gerek kalmaz:

    outb(cmd, 0x70);         
    inb(0x71);

    Bu fonksiyonlar zaten kendi içlerinde bellek bariyerlerini oluşturdukları için bunların yer değiştirilmesi söz konusu 
    olmamaktadır. Aygıt sürücü programcısı genellikle Linux çekirdek fonksiyonlarını kullanarak kodlama yapmaktadır. Bu fonksiyonlar 
    da zaten kendi içlerinde gerekli yerlere bellek bariyerlerini yerleştirmektedir. Bu nedenle aygıt sürücü programcısı açıkça 
    bellek bariyerlerini kullanmaya çoğu durumda gereksinim duyduymamaktadır. 

    C11 ve C++11 ile birlikte C'ye ve C++'a bellek atomik işlemler yapan ve bellek bariyerlerleri oluşturan fonksiyonlar da 
    eklenmiştir. Böylece artık atomik işlemler ve bellek bariyerleri taşınabilir bir biçimde oluşturulabilir hale gelmiştir. 
    Biz burada bu taşınabilir fonksiyonlar üzerinde durmayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Memory-mapped IO işlemi pek çok mimaride normal göstericilerle yapılabilmektedir. Yani aslında bu mimarilerde memory-mapped 
    IO için özel çekirdek fonksiyonlarının kullanılmasına gerek olmayabilir. Ancak bazı mimarilerde memory-mapped IO işlemi 
    için özel bazı işlemlerin de yapılması gerekebilmektedir. Bu nedenle bu işlemlerin taşınabilir biçimde yapılabilmesi için 
    özel çekirdek fonksiyonlarının kullanılması tavsiye edilir.

    Tıpkı port-mapped IO işlemlerinde olduğu gibi memory-mapped IO işlemleri için de iki farklı aygıt aynı adres bölgesini 
    kullanmasın diye bir registration işleminin yapılması tavsiye edilmektedir. Bu işlemler request_mem_region ve release_mem_region 
    fonksiyonlarıyla yapılmaktadır. request_mem_region fonksiyonunun prototipi şöyledir:

    #include <linux/ioport.h>

    struct resource *request_mem_region(unsigned long start, unsigned long len, const char *name);

    Fonksiyonun birinci parametresi başlangıç fiziksel bellek adresini, ikinci parametresi alanın uzunluğunu belirtmektedir. 
    Üçüncü parametre ise "/proc/iomem" dosyasında görüntülenecek olan isimdir. Fonksiyon başarı durumunda resource isimli bir 
    yapı nesnesinin adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Daha önce register ettirilmiş olan bellek 
    bölgesini serbest bırakmak için (yani register ettirilmemiş hale getirmek için) release_mem_region fonksiyonu kullanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    void release_mem_region(unsigned long start, unsigned long len);

    Fonksiyonun birinci parametresi başlangıç fiziksel bellek adresini, ikinci parametresi ise uzunluğu belirtmektedir.

    Donanım aygıtının kullandığı bellek adresleri fiziksel adreslerdir. Örneğin aygıt 0xFFFF8000 gibi bir adresi kullanıyorsa 
    bu adres fiziksel adrestir. Halbuki aygıt sürücünün sanal adres yoluyla bu fiziksel adrese erişebilmesi için bu dönüşümü 
    yapacak sayfa tablosu girişlerinin bulunuyor olması gerekir. Çünkü program içerisindeki sanal adresler sayfa tablosu yoluyla 
    fiziksel adreslere dönüştürülmektedir. İşte fiziksel adresler için sayfa tablosunda sanal adres girişlerini oluşturan 
    ioremap isimli bir çekirdek fonksiyonu vardır. Bu çekirdek fonksiyonuna biz fiziksel adresi ve onun uzunluğunu veririz, 
    fonksiyon da sayfa tablosunda bu fiziksel adrese erişmek için gerekli düzenlemeyi yapar ve bize erişimde kullanabileceğimiz 
    sanal adresi verir. ioremap fonksiyonun prototipi şöyledir:

    #include <asm/io.h>

    void *ioremap(unsigned long physical_address, unsigned long size);

    Fonksiyonun birinci parametresi fiziksel adresii ikinci parametresi map edilecek uzunluğu belirtmektedir. Fonksiyon başarı 
    durumunda bu fiziksel adrese erişmekte kullanılacak sanal adresi, başarısızlık durumunda NULL adrese geri dönmektedir. 
    Fonksiyon NULL adrese geri döndüüğünde aygıt sürücüdeki fonksiyonunda -ENOMEM geri döndürülmesi uygun olur. Bugünkü 
    mikroişlemciler birden fazla çekirdeğe sahip olabilmektedir. Her çekirdeğin ayrı bir cache'i vardır. (Buna L1 cache ve L2 
    cache de denilmektedir.) CPU RAM'e erişimi azaltmak için (çünkü RAM göreli olarak yavaştır) okuma ve yazma işlemleri için 
    mümkün olduğunca kendi içerisindeki cache'leri kullanır. Bunun sonucu olarak da aslında biz bir bellek adresine örneğin 
    yazma yaptığımızda CPU aslında yazmayı RAM'e değil kendi cache'ine yapıyor olabilir. Tabii bu bilgi bir süre sonra RAM'e 
    aktarılmaktadır. İşte memory-mapped IO tekniğinde donanım aygıtının kullandığı RAM bölümünün CPU tarafından cache'lenmemesi 
    gerekir. Bu işlem sayfa tablşosundaki bazı bitler ile sağlanmaktadır. İşte ioremap fonksiyonu bu işlemi de yapmaktadır. Aksi 
    takdirde donanım aygıtına göndermek istediğimiz bilgiler elektirksel olarak oraya gönderilmeyebilecektir. Ayrıca ioremap 
    işleminin CPU cache'lerini devre dışı bırakmayan ioremap_cache isimli bir biçimi de vardır. 

    ioremap işlemini geri almak için iounmap fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <asm/io.h>

    void iounmap(void *addr);

    Fonksiyon sanal bellek adresini parametre almaktadır. Uzunluk bilgisi zaten çekirdek tarafından kaydedildiği için ayrıca
    fonksiyona verilmemektedir. 

    ioremap fonksiyonu ile sanal adres elde edildikten sonra biz C'de göstericilerle doğrudan aygıta erişebilir miyiz? Aslında 
    erişebiliriz. Ancak önceki paragrafta açıkladığımız gibi erişimi sorunsuz yapabilmek için platforma bağlı olarak bellek 
    bariyerlerinin kullanılması gerekir. Bu nedenle erişimin doğrudan göstericilerle değil özel çekirdek fonksiyonlarıyla 
    yapılması tavsiye edilmektedir. Memory-mapped IO ile aygıta erişen çekirdek fonksiyonları çekirdeğin belli bir versiyonundan 
    sonra daha modern hale getirilmiştir. Biz burada daha taşınabilir daha yeni fonksiyonları tanıtacağız. Aşağıdaki fonksiyonlar 
    addr ile belirtilen bellek adresinden 1 byte, 2 byte ve 4 byte okurlar.

    #include <asm/io.h>

    u8   ioread8(const void __iomem *addr);
    u16  ioread16(const void __iomem *addr);
    u32  ioread32(const void __iomem *addr);
    u64  ioread64(const void __iomem *addr);

    Aşağıdaki fonksiyonlar ise addr ile belirtilen bellek adresine 1 byte, 2 byte ve 4 byte bilgi yazmaktadır:

    #include <asm/io.h>

    void iowrite8(u8 value, void __iomem *addr);
    void iowrite16(u16 value, void __iomem *addr);
    void iowrite32(u32 value, void __iomem *addr);
    void iowrite64(u64 value, void __iomem *addr);  

    Bazı platformlarda ioread64 ve iowrite64 fonksiyonları yoktur. Bu platformlarda 32 bitten daha fazla okumalar için 
    izleyen paragraflarda açıklayacağımız memcpy_fromio ve memcpy_toio fonksiyonlarını kullanmalısınız.  

    Bu ioreadxxx ve iowritexxx fonksyonları yerine eskiden readxxx ve writexxx fonksiyonları kullanılıyordu. ioradxxx ve 
    iowritexxx fonksiyonları 2.6 sürümleriyle çekirdeğe eklenmiştir. Ancak eski readxxx ve writexxx fonksiyonları yeni 
    çekirdeklerde de muhafaza edilmektedir. writexxx ve readxxx fonksiyonlarının listesi de şöyledir:

    readb
    readw
    readl
    readq

    writeb
    writew
    wrirel
    writeq 

    Yukarıdaki fonksiyonların rep'li (repetition/tekrar) versiyonları da vardır:

    #include <asm/io.h>

    void ioread8_rep(void *addr, void *buf, unsigned long count);
    void ioread16_rep(void *addr, void *buf, unsigned long count);
    void ioread32_rep(void *addr, void *buf, unsigned long count);

    void iowrite8_rep(void *addr, const void *buf, unsigned long count);
    void iowrite16_rep(void *addr, const void *buf, unsigned long count);
    void iowrite32_rep(void *addr, const void *buf, unsigned long count);

    Bu fonksiyonlar donanım aygıtına ilişkin bellek adresinden belli bir adrese belli miktarda (count parametresi) 
    byte, word ya da dword transfer etmektedir. 

    Tıpkı memcpy fonksiyonunda olduğu gibi memory-mapped aygıt ile bellek arasında blok kopyalaması yapan iki fonksiyon 
    da bulunmaktadır:

    #include <asm/io.h>

    void memcpy_fromio(void *dest, const void *source, unsigned int count);
    void memcpy_toio(void *dest, const void *source, unsigned int count);

    Belli bir memory-mapped IO adresinden itibaren belli bir byte'ı n defa dolduran memset_io isimli bir fonksiyon da vardır:

    #include <asm/io.h>

    void memset_io(void *dest, u8 value, unsigned int count);

    Bu fonksiyonu memset fonksiyonuna benzetebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            118. Ders 29/07/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Intel tabanlı PC mimarisinde memory-mapped IO örneği verelim. PC mimarisinde geleneksel olarak port-mapped IO 
    kullanılmaktadır. Ancak mimariye sonradan eklenen donanım bileşenleri memory-mapped IO kullanacak biçimde tasarlanmıştır. 
    
    Eskiden PC mimarisinde tek işlemci vardı ve bu işlemcinin içerisinde de APIC (yani kesme denetleyicisi ve timer devresi)
    yoktu. Eski PC'lerde zamanlama amacıyla yalnızca board üzerinde Inetl 8254 PIT (Programmable Interval Timer) devresi 
    kullanılıyordu. Gerçekten de işletim sistemlerinde preemptive bağlamsal geçiş (context switch) işlemini bu timer devresinin
    ürettiği kesme tetikliyordu. Ancak daha sonraları PC mimamrisine HPET (High Precision Event Timer) isimli modern ve yüksek
    çözünürlüklü bir timer devresi eklenmiştir. HPET  denetleyicisi aynı zamanda kesme de oluşturabilmektedir. Bu timer devresine 
    memory-mapped IO tekniğiyle erişilmektedir. Aynı zamanda Linux sistemlerinde HPET denetleyicisine erişmek için "/dev/hpet" 
    isimli bir aygıt sürücü de bulundurulmuştur. Bu aygıt sürücüden okuma yapıldığında aygıt sürücü HPET içerisindeki sayacın 
    değerini bize vermektedir. HPET sayacının frekansı bir IOCTL komut kodu ile elde edilebilmektedir. Ancak son zamanlarda 
    bazı dağıtımlar bu aygıt sürücünün read fonksiyonunun içini silip doğrudan fonksiyonu -EIO hata kodu ile geri döndürmektedir. 
    Dolaysıyla read fonksiyonu da "Input/output error" hata mesajıyla başarısız olmaktadır. Ancak biz yine de aşağıda bir kod 
    parçasının çalışma süresinin bu HPET aygıt sürücüsü yoluyla nasıl hesaplanacağına bir örnek veriyoruz.
-----------------------------------------------------------------------------------------------------------------------------*/

/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/hpet.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct hpet_info info;
    uint64_t start, end;
    double result;
		
	if ((fd = open("/dev/hpet", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, HPET_INFO, &info) == -1) 
        exit_sys("ioctl");
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / info.hi_ireqfreq;
    printf("Elapsed time: %f\n", result);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                        119. Ders 31/07/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de biz HPET denetleyicisine ilişkin bir aygıt sürücü yazalım. Aygıt sürücümüzün read fonksiyonu aygıttan 8 byte 
    okunduğunda HPET içeirsindeki sayacın değerini versin. HPET sayacının frekansını almak için de bir ioctl komutu kullanalım.
    HPET denetleyicisinin memory-mapped fiziksel adresi default durumda 0xFED00000 biçimindedir. Ancak PC'lerde plug and play 
    tekniği sayesinde ACPI protokolü tarafından çakışma durumunda bu adres değiştirilebilmektedir. Yani bu denetleyicinin 
    memory-mapped fiziksel adresini elde etmenin en güvenilir yolu ACPI tablosuna başvurmaktır. Çalışan Linux sisteminizde 
    aşağıdaki komut ile dmesg log'larından denetleyicinin adresini elde edebilirsiniz:

    $ dmesg | grep -i hpet

    Örnek çıktı şöyle olabilir:

     0.003467] ACPI: HPET 0x00000000BFEE76F7 000038 (v01 VMWARE VMW HPET 06040000 VMW  00000001)
    [    0.003475] ACPI: Reserving HPET table memory at [mem 0xbfee76f7-0xbfee772e]
    [    0.149999] ACPI: HPET id: 0x8086af01 base: 0xfed00000
    [    0.481936] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns
    [    1.218886] hpet0: at MMIO 0xfed00000, IRQs 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    [    1.218886] hpet0: 16 comparators, 64-bit 14.318180 MHz counter
    [    1.468033] rtc_cmos 00:01: alarms up to one month, y3k, 114 bytes nvram, hpet irqs
    ...

    Aygıt sürücücümüzün 0xFED00000 fiziksel adresine erişebilmesi için ioremap fonksiyonun çağrılması gerekir. Örneğimizde 
    fonksiyon şçyle çağrılmıştır:

    static void *g_hpet_base;;
    ...

    if ((g_hpet_base = ioremap(HPET_BASE_ADDR, 4096)) == NULL) {     
        ...
        return -ENOMEM;
    }
   
    HPET denetleyicisinden sayaç değerini almak için denetleyicinin taban adresinden 0xF0 byte ilerisinden 8 byte'ın okunması 
    gerekir. Bu okuma işlemi aygıt sürücü içerisinde şöyle yapılabilmektedir:

    memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
    
    HPET aygıt sürücüsü kullanıcı modundan her okunduğunda bize 8 byte'lık sayaç değerini verecektir. Dosya göstericisinin 
    kullanılmasına gerek yoktur. Her okumanın dosyanın başından itibaren yapıldığı kabul edilebilir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        u64 count_val;

        if (size < sizeof(count_val))
            return -EINVAL;

        memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
        if (copy_to_user(buf, &count_val , size) != 0)
            return -EFAULT;

        return size;
    }

    Peki elde edilen bu sayaç değerine ilişkin sayaç saniyede kaç kere güncellenmektedir? Yani bu sayacın frekeansı nedir? 
    İşte bu sayacın frekansını almak için örneğimizde IOC_HPET_GETFREQ isimli bir ioctl komutu bulundurulmuştur:

    static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
        u64 cap_id;
        u32 clk_period_fs;
        u64 frequency_hz;

        switch (cmd) {
            case IOC_HPET_GETFREQ:
                memcpy_fromio(&cap_id, (char *)g_hpet_base + HPET_GEN_CAP_ID_OFFSET, sizeof(u64));
                clk_period_fs = cap_id >> 32;      // femtosaniye per tick
                frequency_hz = 1000000000000000ULL / clk_period_fs;
                if (copy_to_user((void *)arg, & frequency_hz, sizeof(u64)) != 0)
                    return -EFAULT;     
                result = 0;         
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada frekansın nasıl alındığını anlamak HPET denetleyicisine ilişkin bazı ayrıntıların bilinmesi gerekmektedir. Biz burada
    bu ayrıntılara girmeyeceğiz. Frekansı elde etmek için ioctl fonksiyonu uint64_t türünden bir nesnenin adresiyle çağrılmalıdır. 
    Sayaç değeri bu adrese yerleştirilecektir. 

    Aygıt sürücümüz kullanıcı modundan şöyle  kullanılabilir:

    if ((fd = open("hpet-driver", O_RDONLY)) == -1)
		exit_sys("open");
        
    if (ioctl(fd, IOC_HPET_GETFREQ, &freq) == -1) 
        exit_sys("ioctl");
    
    printf("Frequency: %llu\n", freq);
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / freq;
    printf("Elapsed time: %f\n", result);

    Aygıt sürücümüzün tüm kodları aşağıda verilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* hpet-driver.h */

#ifndef HPET_DRIVER_H_
#define HPET_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define HPET_DRIVER_MAGIC		    'h'

#define IOC_HPET_GETFREQ	        _IOR(HPET_DRIVER_MAGIC, 1, unsigned long long)

#endif

/* hpet-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include "hpet-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("hpet-driver");

#define HPET_BASE_ADDR              0xFED00000
#define HPET_GEN_CAP_ID_OFFSET      0x00
#define OFFSET_MAIN_CNT             0xF0

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.release = generic_release,
    .unlocked_ioctl = hpet_driver_ioctl
};

static void *g_hpet_base;

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "hpet-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "hpet-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    if ((g_hpet_base = ioremap(HPET_BASE_ADDR, 4096)) == NULL) {
        cdev_del(&g_cdev);
        unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot remap IO device!...\n");
        return -ENOMEM;
    }
   
	return 0;
}

static void __exit generic_exit(void)
{
    iounmap(g_hpet_base);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "hpet-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "hpet-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "hpet-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    u64 count_val;

    if (size < sizeof(count_val))
        return -EINVAL;

    memcpy_fromio(&count_val, (char *)g_hpet_base + OFFSET_MAIN_CNT, size);
    if (copy_to_user(buf, &count_val , size) != 0)
        return -EFAULT;

	return size;
}

static long hpet_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
    u64 cap_id;
    u32 clk_period_fs;
    u64 frequency_hz;

    switch (cmd) {
        case IOC_HPET_GETFREQ:
            memcpy_fromio(&cap_id, (char *)g_hpet_base + HPET_GEN_CAP_ID_OFFSET, sizeof(u64));
            clk_period_fs = cap_id >> 32;      // femtosaniye per tick
            frequency_hz = 1000000000000000ULL / clk_period_fs;
            if (copy_to_user((void *)arg, & frequency_hz, sizeof(u64)) != 0)
                return -EFAULT;     
            result = 0;
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "hpet-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    uint64_t freq;
    uint64_t start, end;
    double result;
		
	if ((fd = open("hpet-driver", O_RDONLY)) == -1)
		exit_sys("open");

        
    if (ioctl(fd, IOC_HPET_GETFREQ, &freq) == -1) 
        exit_sys("ioctl");
    
    printf("Frequency: %llu\n", freq);
    
    if (read(fd, &start, 8) == -1)
        exit_sys("read");
    
    for (long i = 0; i < 10000000000; ++i)
        ;
    
    if (read(fd, &end, 8) == -1)
        exit_sys("read");

    result = ((double)end - start) / freq;
    printf("Elapsed time: %f\n", result);
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar karakter aygıt sürücüleri üzerinde durduk. Aygıt sürücülerin çok büyük kısmı karakter aygıt sürücüsü 
    biçiminde yazılmaktadır. Karakter aygıt sürücülerinde aygıttan (yani donanım biriminden)  bilgiler birkaç byte biçiminde 
    azar azar değil blok blok okunmakta ve aygıta bilgiler birkaç byte biçiminde değil blok blok yazılmaktadır. Örneğin seri 
    portu yönten bir aygıt sürücüsü karakter aygıt sürücüsüdür. Çünkü sei porttan bilgiler blok blok değil byte byte edilmektedir. 
    Yardımcı işlemcilere ilişkin aygıt sürücülerinin çoğu da karakter aygıt sürücüsü biçimindedir. Blok aygıt sürücülerinde aygıt 
    bilgileri blok blok alıp vermektedir. Karakter aygıtlarıyla blok aygıtları arasındaki en önemli farklılık iletilen bilginin 
    büyüklüğü ve iletilen bilginin bloklu yapıda olmasıdır. Blok aygıt sürücüleri karakter aygıt sürücülerine göre oldukça seyrek 
    karşımıza çıkmaktadır. Bir aygıt sürücü programcısı çoğu zaman karakter aygıt sürücülerinin yazımıyla uğraşır. Aygıt sürücü 
    programcısı seyrek bir biçimde blok aygıt sürücüleri ile çalışmaktadır. Aygıt sürücülerini konu alan kitaplar da genellikle 
    karakter aygıt sürücülerini ele almaktadır. 

    Biligsayar sistemlerinde karşılaşılan blok aygıtlarının önemli olanları şunlardır:

    - Hard Diskler 
    - SSD Diskler
    - USB bellekler
    - CD/DVD ROM'lar
    - Ramdisk'ler
    - Sanal diskler

    Linux'ta karakter aygıt sürücülerinin mimarisi ve alt sistemleri zaman içerisinde büyük ölçüde oturmuştur. Çekirdekler 
    arasında önemli farklılıklar yoktur. Ancak blok aygıt mimarisi ve alt sistemleri üzerinde maalesef Linux çekirdeklerinde 
    çokça değişiklikler yapılmıştır. Bu nedenle blok aygıt sürücülerini yazanlar versiyon değişikliklerine çok dikkat etmelidir. 
    Linux'un neredeyse her majör numarasında blok aygıt sürücüsüne ilişkin fonksiyonlarda ve veri yapılarında değişiklikler 
    yapılmıştır. Biz kurusumuzda 6'lı çekirdekleri göz önüne alarak konuyu açıklayacağız. Burada verdiğimiz örneklerin eski
    çekirdeklerde çalışmayabileceğini vurgulamak istiyoruz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri (block device drivers) disk benzeri birimlerden bloklu okuma ve bu birimlere yazma yapabilmek için 
    kullanılan özel aygıt sürücülerdir. Daha önceden de belirttiğimiz gibi disk benzeri birimlerden bir hamlede okunabilecek 
    ya da yazılabilecek bilgi miktarına "sektör" denilmektedir. İşte blok aygıt sürücüleri transferleri byte byte değil blok 
    blok (sektör sektör) yapmaktadır. Örneğin bir diskten 1 byte okuma diye bir şey yoktur ya da bir diske 1 yazma diye bir şey 
    yoktur. Diskteki 1 byte değiştirilecekse önce onun bulunduğu sektör RAM'e okunur, değişiklikler RAM üzerinde yapılır. Sonra 
    o sektör yeniden diske yazılır. Tipik transfer bu adımlardan geçilerek gerçekleştirilmektedir. Sektörler bugün kullandığımız
    sistemlerde 512 byte uzunluğundadır. 

    Bir Linux sistemini kurduğumuzda "/dev" dizininin altında disklerle işlem yapan aygıt sürücülere yönelik aygıt dosyaları
    da oluşturulmuş durumdadır. Blok aygıt sürücülerine ilişkin aygıt dosyaları "ls -l" komutunda dosya türü 'b' olarak 
    görüntülenmektedir. Örneğin:

    $ ls -l /dev
    ...
    brw-rw----  1 root disk      8,   0 Ağu  7 13:57 sda
    brw-rw----  1 root disk      8,   1 Ağu  7 13:57 sda1
    brw-rw----  1 root disk      8,   2 Ağu  7 13:57 sda2
    brw-rw----  1 root disk      8,   3 Ağu  7 13:57 sda3
    crw-rw----+ 1 root cdrom    21,   0 Ağu  7 13:57 sg0
    crw-rw----  1 root disk     21,   1 Ağu  7 13:57 sg1
    ...

    Burada "sda" aygıt dosyası diske bir bütün olarak erişmek için kullanılırken sda1, sda2, sda3 aygıt dosyaları ise diskteki 
    disk bölümlerine (partition) erişmek için kullanılmaktadır. Bu aygıt dosyalarının majör numaralarının aynı olduğuna ancak 
    minör numaralarının farklı olduğuna dikkat ediniz. Biz bir flash belleği USB soketine taktığımızda burada flash belleğe 
    erişmek için gerekli olan aygıt dosyaları otomatik biçimde oluşturulacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri bloklu çalışan aygıtlarda erişimi hızlandırmak için ismine "IO çizelgelemesi (IO Scheduling)" denilen 
    bir yöntem uygulamaktadır. Çeşitli prosesler diskten sektörleri okumak istediğinde ya da sektörleri diske yazmak istediğinde 
    bunlar işletim sistemi tarafından birleştirilerek disk erişimleri azaltılmaktadır. Yani bu tür transferlerde transfer talep 
    edildiği anda değil, biraz bekletilerek (tabii kısa bir zaman) gerçekleştirilebilmektedir. Disk sistemi bilgisayar sistemlerinin 
    en yavaş alt sistemlerinden birini oluşturmaktadır. SSD diskler bile yazma bakımından RAM'e göre neredeyse binlerce kat yavaştır. 
    İşte işletim sistemleri aslında ayrık olan birtakım okuma yazma işlemlerini diskte mümkün olduğunca ardışıl hale getirerek 
    ve gereksiz okuma yazma işlemlerini elimine ederek disk erişiminden kaynaklanan zaman kayıplarını minimize etmeye çalışmaktadır. 
    Peşi sıra blokların ayrı ayrı değil de tek hamlede okunup yazılması disklerde bir zaman kazancı sağlamaktadır. Hard disklerde 
    bu kazanç önemli bir boyuttadır. SSD'lerde de hard diskler kadar önemli boyutta olmasa da bir hız kazancı oluşturmaktadır. 
    Farklı proseslerin sektör okuma istekleri aslında bazen birbirine yakın bölgelerde gerçekleşir. İşte onların yeniden sıralanması 
    gibi faaliyetler IO çizelgeleyicisinin önemli görevlerindendir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıtlarından okumalar ve blok aygıtına yazmalar bir cache sistemi aracılıyla gerçekleştirilmektedir. Bu cache sistemine 
    işletim sistemlerinde "disk cache sistemi" ya da "buffer cache sistemi" denilmektedir. Linux işletim sisteminde eskiden bu 
    cache sistemine "buffer cache" deniliyordu. Daha sonra "page cache" denilmeye başlandı. Page cache sistemi tipik olarak 
    şöyle çalılmaktadır:

    - Bir proses blok aygıtından read fonksiyonu ile okuma yapmak istediğinde işletim sistemi önce okunacak kısmın blok aygıtının 
    neresinde olduğunu hesaplamaktadır. Sonra bu bloğu blok aygırından okuyarak page cache içerisine yazmaktadır. Prosese de 
    page cache içerisinden bilgiler verilmektedir. Böylece aynı disk bloğundan başka bir okuma yapılacağı zaman o blok zaten 
    cache içerisinde olduğu için gereksiz aygıt okuması yapılmayacaktır. Ancak bu bloğa talep yoksa artık bu blok cache'ten 
    atılıp onun yerine aygıttaki başka bir blok cache'e yerleştirilebilmektedir. Page cache sisteminde LRU (Least Recently Used)
    cache algoritması kullanılmaktadır. Cache terminolojisinde bir bilgi talep edildiğinde eğer o bilgi cache'te varsa buna 
    İngiizce "cache hit", cache'te yoksa buna da "cache miss" denilmektedir. İşletim sisteminin read fonksiyonu her zaman önce 
    page cache'e bakmaktadır. Eğer bilgi page cache'te varsa hiç bloke oluşmadan bilgi ilgili thread'e verilmektedir. Eğer 
    "cache miss" durumu oluşursa ilgili thread bloke edilip "wait kuyruklarında uykuya yatırılır" ve gerçek aygıt okuması 
    yapılır. 

    - Bir proses blok aygıtına write fonksiyonu ile yazmak yapmak istediğinde işletim sistemi eğer o blok cache'te varsa 
    yazmayı doğrudan cache'e yapmaktadır. Eğer ilgili blok cache'te yoksa bu durumda cache'e çekilip yazma cache'e yapılmaktadır. 
    Ancak cache'e yazılan bloklar elektrik kesilmesi gibi durumlarda gerçek aygıta aktarılmamış olacağından dolayı bir bilgi
    kaybı oluşabilecektir. İşte işletim sistemleri bu kayıp olasılığını azaltmak için "gecikmeli yazım (delayed write)" denilen 
    tekniği kullanmaktadır. İşletim sisteminin bir çekirdek thread'i belli periyotlarla page cache'te bozulmuş olan ("dirty" 
    olan) blokları diske yazmaktadır. Yani yazım ilk aşamada cache'e yapılmakta ancak çok da fazla bekletilmeden işletim 
    sistemi tarafından kısa bir süre sonra  aygıta aktarılmaktadır. Gecikmeli yazımın gerekçesi şunlardır:

    1) Yazma işlemi sırasında yazan thread bloke olmadan hemen geri döner. Çünkü yazma aygıta değil cache'e yapılmaktadır.
    2) İşletim sistemi yukarıda sözünü ettiğimiz IO çizelgelemesini cache üzerinde uygulamaktadır. Yani cache'te bozulmuş olan 
    blokları çizelgeleyerek daha etkin bir biçimde blok aygıtına yazabilmektedir. 
    3) Üst üste yazımlarda bu sayede gereksiz yazımlar engellenmiş olur.   
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri bazı bakımlardan karakter aygıt aygıt sürücülerine benzese de "IO çizelgelemesi" ve "page cache "
    sistemi yüzünden tasarımsal farklılıklara sahiptir. Karakter aygıt sürücülerinde her read ve write işlemi için bir IO 
    çizelgelemesi ve cache'leme işlemi yapılmadan aygıt sürücünün fonksiyonları çağrılmaktadır. Çünkü karakter aygıt sürücülerinde 
    az miktarda bilgiler aktarılmakta ve disk gibi zaman alıcı işlemlerle uğraşılmamaktadır. Ancak blok aygıt sürücülerinde 
    aktarım isteği çizelgelenerek bazen gecikmelerle yerine getirilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            120. Ders 05/08/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir blok aygıt sürücüsü oluşturmak için ilk yapılacak işlem tıpkı karakter aygıt sürücülerinde olduğu gibi blok aygıt 
    sürücüsünün bir isim altında aygıt numarası belirtilerek register ettirilmesidir. Bu işlem register_blkdev fonksiyonuyla 
    yapılmaktadır:

    #include <linux/blkdev.h>

    int register_blkdev(unsigned int major, const char *name);

    Fonksiyonun birinci parametresi aygıtın majör numarasını belirtir. Eğer majör numara olarak 0 geçilirse fonksiyon boş bir 
    majör numarayı kendisi tahsis eder. Fonksiyonun ikinci parametresi ise "/proc/devices" dosyasında görüntülenecek olan 
    ismi belirtmektedir. Fonksiyon başarı durumunda aygıt sürücünün majör numarasına, başarısızlık durumunda negatif errno 
    değerine geri dönmektedir. Örneğin:

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot alloc block driver!...\n");
        return g_major;
    }

    register_blkdev fonksiyonunun yalnızca bir majör numara aldığına dikkat ediniz. Habuki register_chrdev_region fonksiyonunda
    register ettirilecek minör numaralar da belirtiliyordu. Blok aygıt sürücüleri için minör numara tahsisatı disk tahsis edilirken 
    (yani eski versiyonlarda alloc_disk, yeni versiyonlarda blk_alloc_disk fonksiyonunda) yapılmaktadır. 

    Modül boşaltılırken bu işlemin geri alınması için unregister_blkdev fonksiyonu kullanılmaktadır:

    #include <linux/blkdev.h>

    void unregister_blkdev(unsigned int major, const char *name);

    Fonksiyonun parametrik yapısı register_blkdev fonksiyonuyla tamamen aynıdır. Örneğin:

    unregister_blkdev(g_major, "generic-blkdev");
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bizim daha önce kullandığımız "load" script'i karakter aygıt dosyası yaratıyordu. Halbuki bizim artık blok aygıt dosyası 
    yaratmamız gerekir. Bunun için "load" ve "unload" script'lerini "loadblk" ve "unloadblk" ismiyle yeniden yazacağız. (Tabii 
    aslında "unload" script'inde değiştirilecek bir şey yoktur. Ancak isimsel uyumluluk bakımından biz her iki dosyayı da 
    yeniden yeni isimlerle oluşturacağız.) Bu iki script'e de "x" haklarının verilmesi gerektiğini anımsayınız.

    $ sudo chmod +x loadblk unloadblk

    /* loadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./$module.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module b $major 0

    /* unloadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
 
    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri için en önemli nesne gendisk isimli nesnesidir. Blok aygıt sürücüsü çekirdekte bu nesne ile temsil 
    edilmektedir. gendisk nesnesi eski çekirdeklere alloc_disk isimli fonksiyonla (aslında bir makro olarak yazılmıştır) tahsis 
    ediliyordu. Ancak 5'li çekirdeklerle birlikte fonksiyonun ismi blk_alloc_disk biçiminde değiştirildi. Ayrıca aşağıdaki 
    fonksiyonların bir bölümünün bulunduğu <linux/genhd.h> dosyası da çekirdeğin 5.18 versiyonunda kaldırılmış buradaki 
    fonksiyonların prototipleri <linux/blkkdev.h> dosyasına taşınmıştır.

    #include <linux/genhd.h>                           /* #include <linux/blkkdev.h> */

    struct gendisk *alloc_disk(int minors);            /* eski çekirdek versiyonları bu fonksiyonu kullanıyor */
    struct gendisk *blk_alloc_disk(int minors);        /* yeni çekirdek versiyonları bu fonksiyonu kullanıyor */

    Fonksiyonlar parametre olarak aygıt sürücünün destekleyeceği minör numara sayısını almaktadır. Fonksiyonların geri dönüş 
    değerleri diski temsil eden gendisk isimli yapı türünden nesnenin adresidir. (Birden fazla minör numaranın söz konusu olduğu 
    durumda geri döndürülen adres aslında gendisk türünden bir dizinin adresidir.) Fonksiyonlar başarısızlık durumunda NULL adrese 
    geri dönmektedir. Başarısızlık durumunda bu fonksiyonları çağıran fonksiyonları -ENOMEM değeri ile geri döndürmek uygun olur.
    Örneğin:

    static struct gendisk *g_gdisk;

    if ((g_gdisk = blk_alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    disk sözcüğü bu bağlamda aslında fiziksel bir diskten ziyade bir blok aygıtını temsil etmektedir. Blok aygıtları tipik olarak
    disk biçiminde bulunduğu için disk terimi tercih edilmiştir.

    Son versiyonlarda Linux çekirdeğinin bu blok aygıt sürücülerine ilişkin fonksiyonlarında yine bazı değişiklikler olmuştur. 
    Örneğin 5.14 çekirdeği ile birlikte gendisk tahisatı ile kuyruk tahsisatını birlikte yapan blk_alloc_mq_disk isimli bir 
    fonksiyon eklenmiştir. Bu fonksiyon her iki tahsisatı da birlikte yaptığı için en yeni çekirdeklerde tercih edilebilir. 

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesi henüz add_disk işlemi yapılmamışsa (ya da add_disk başarısız 
    olduğunda) put_disk fonksiyonu ile serbest bırakılır. 

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesinin içinin doldurulması gerekmektedir. Bu yapının doldurulması 
    gereken önemli elemanları şunlardır:

    - Yapının major isimli elemanına aygıt sürücünün majör numarası yerleştirilmelidir. Örneğin:

    g_gdisk->major = g_major;

    - Yapının first_minor elemanına aygıt sürücünün ilk minör numarası yerleştirilmelidir (Tipik olarak 0). Örneğin:

    g_gdisk->first_minor = 0;

    - Yapının minors elemanı first_minor numaradan itibaren kaç minör numaranın kullanılacağını belirtmektedir. Biz tek bir 
    minör numara kullanacaksak buraya 1 değerini yerleştiririz:

    g_gdisk->minors = 1;

    - Yapının disk_name elemanına diske (yani blok aygıtına) ilişkin bir isim yerleştirilir. Örneğin:

    strscpy(g_disk->disk_name, "generic-blkdev", DISK_NAME_LEN);         

    - Yapının flags elemanına duruma göre bazı bayraklar girilebilmektedir. Örneğin bir ramdisk uygulaması için bu bayrak 
    GENHD_FL_NO_PART biçiminde girilebilir. Örneğin:

    g_gdisk->flags = GENHD_FL_NO_PART;

    - Yapının fops elemanına aygıt sürücü açıldığında, kapatıldığında, ioctl gibi işlemler yapıldığında çağrılacak fonksiyonların 
    bulunduğuğu block_device_operations isimli yapı türünden nesnenin adresi atanmalıdır. Yaı şöyle tanımlanmıştır:

    struct block_device_operations {
        void (*submit_bio)(struct bio *bio);
        int (*poll_bio)(struct bio *bio, struct io_comp_batch *iob, unsigned int flags);
        int (*open)(struct gendisk *disk, blk_mode_t mode);
        void (*release)(struct gendisk *disk);
        int (*ioctl)(struct block_device *bdev, blk_mode_t mode, unsigned cmd, unsigned long arg);
        int (*compat_ioctl)(struct block_device *bdev, blk_mode_t mode, unsigned cmd, unsigned long arg);
        unsigned int (*check_events) (struct gendisk *disk, unsigned int clearing);
        void (*unlock_native_capacity) (struct gendisk *);
        int (*getgeo)(struct block_device *, struct hd_geometry *);
        int (*set_read_only)(struct block_device *bdev, bool ro);
        void (*free_disk)(struct gendisk *disk);
        /* this callback is with swap_lock and sometimes page table lock held */
        void (*swap_slot_free_notify) (struct block_device *, unsigned long);
        int (*report_zones)(struct gendisk *, sector_t sector,
                unsigned int nr_zones, report_zones_cb cb, void *data);
        char *(*devnode)(struct gendisk *disk, umode_t *mode);
        /* returns the length of the identifier or a negative errno: */
        int (*get_unique_id)(struct gendisk *disk, u8 id[16],
                enum blk_unique_id id_type);
        struct module *owner;
        const struct pr_ops *pr_ops;        /*
        * Special callback for probing GPT entry at a given sector.
        * Needed by Android devices, used by GPT scanner and MMC blk
        * driver.
        */
        int (*alternative_gpt_sector)(struct gendisk *disk, sector_t *sector);
    };
        
    Bu yapı karakter aygıt sürücülerindeki file_operations yapısına benzetilebilir. Yapının üç önemli elemanı önemli elemanı 
    open ve release ve ioctl elemanlarıdır.  Burada belirtilen fonksiyonlar aygıt sürücü açıldığında, kapatıldığında ve ioctl 
    işlemi yapıldığında çağrılmaktadır. Örneğin:

    static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
    static void generic_blkdev_release(struct gendisk *disk);
    ...

    static struct block_device_operations g_blkdev_ops = {
        .open = generic_blkdev_open,
        .release = generic_blkdev_release
    };

    g_gdisk->fops = &g_blkdev_ops;

    - Eskiden gendisk yapısının queue elemanı için istek kuyruğunu (request queue) programcı yaratıyordu. Ancak blk_alloc_disk 
    fonksiyonu artık bu yaratımı da kendisi yapmaktadır. İstek kuyruğu aygıt sürücüden read/write işlemi yapıldığında çekirdeğin 
    IO çizelgeleyici alt sistemi tarafından optimize edilen işlemlerin yerleştirileceği kuyruk sistemidir. Programcı ileride 
    görüleceği üzere bu kuyruk sisteminden istekleri alarak yerine getirir. Maalesef bu kuyruğun yaratılması ve işleme sokulması 
    için gerekli çekirdek fonksiyonları çekirdeğin çeşitli versiyonlarında çok kereler değiştirilmiştir. Eskiden 4'lü çekirdeklerde 
    istek kuyruğu oluşturmak için blk_init_queue isimli bir fonksiyon kullanılıyordu. Sonra 5'li çekirdeklerle birlikte istek 
    kuyruğu işlemleri üzerinde değişiklikler yapıldı. Artık en yeni çekireklerde bu istek kuyruklarının yaratımı alloc_blk_disk 
    fonksiyonu tarafından ya da alloc_mq_blk_disk fonksiyonu tarafından yapılmaktadır. Son çekirdeklerde blk_alloc_disk fonksiyonu 
    tarafından yaratılan kuyruk nesnesinin bazı elemanlarının da programcı tarafından doldurulması gerekmektedir. 
    Bu işlemler çekirdeğe eklenmiş olan blk_queue_xxx fonksiyonları tarafından yapılmaktadır. Tipik olarak programcı 
    kuyruğun bazı özelliklerini aşağıdaki fonksiyonlarla belirlemelidir. 

    blk_queue_logical_block_size(g_disk->queue, 512);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);    /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);            /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);      /* Max segment boyutu */

    - gendisk yapısının içerisine diskin (blok aygıt sürücüsünün temsil ettiği medyanın) kapasitesi set edilmelidir. Bu işlem 
    set_capacity fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/genhd.h>

    void set_capacity(struct gendisk *disk, sector_t size);

    Fonksiyonun birinci parametresi gendisk yapısının adresini, ikinci parametresi aygıtın sektör uzunluğunu almaktadır. (Aslında 
    bu fonksiyon gendisk yapısının ilgili elemanını set etmektedir.) Fonksiyonun ikinci parametresi aygıt sürücünün temsil 
    ettiği aygıtın sektör uzunluğunu belirtmektedir. Bir sektör 512 byte'tır. Örneğin:

    set_capacity(g_gdisk, 1000);

     - Nihayet gendisk yapısının private_data elemanına programcı kendi belirlediği bir yapı nesnesinin adresini yerleştirebilir. 
    Örneğin daha önce karakter aygıt sürücülerinde yaptığımız gibi bu private_data elemanına gendisk nesnesinin içinde bulunduğu 
    yapı nesnesinin adresini yerleştirebiliriz.

    Aşağıdaki örnekte yukarıda anlatılan kısma kadar olan işlemleri içeren bir blok aygıt sürücü örneği verilmiştir. Örneğin:

    struct BLOCKDEV {
        spinlock_t sl;
        struct gendisk *gdisk;
        struct request_queue *rq;
        size_t capacity;
    };
    static struct BLOCKDEV g_bdev;
    ...
    g_gdisk->private_data = &g_bdev;

    Tabii buradaki örnekte g_bdev zaten global bir nesne olduğu için ona private_data yoluyla erişmeye gerek kalmamaktadır. 
    Ancak aygıt sürücümüz birden fazla minör numarayı destekliyorsa her aygıtın ayrı bir BLOCKDEV yapısı olacağı için ilgili 
    aygıta bu private_data elemanı yoluyla erişebiliriz.

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesi add_disk fonksiyonu ile sisteme eklenmelidir:

    #include <linux/genhd.h>

    void add_disk(struct gendisk *disk);        /* eski çekirdek versiyonlarındaki prototip */

    Bu fonksiyonun geri dönüş değeri 5'li çekirdeklerle birlikte int yapılmıştır:

    int add_disk(struct gendisk *disk);            /* yeni çekirdek versiyonlarındaki prototip */

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. Örneğin:

    if ((result = add_disk(g_gdisk)) != 0) {
        ...
        return result;
    }

    add_disk fonksiyonuyla tahsis edilen ve sisteme yerleştirilen gendisk nesnesi del_gendisk fonksiyonuyla serbest bırakılmaktadır.
    Bu fonksiyon aynı zamanda blk_alloc_disk fonksiyonu ile tahsis edilen alanı da serbest bırakır. 

    #include <linux/genhd.h>

    void del_gendisk(struct gendisk *gdisk);

    Örneğin:

    if ((g_gdisk = alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    if ((result = add_disk(g_bdev->gdisk)) != 0) {
        ...
        return result;
    }
    ...
    del_gendisk(g_gdisk);

    Aşağıda şimdiye kadar görmüş olduğumuz fonksiyonların kullanıldığı bir blok aygıt sürücüsü iskeleti verilmiştir. Ancak 
    aşağıdakii kodda henüz istek kuyruğuna yönelik bir işlem yapılmamıştır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* generic-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/blkdev.h>

#define TOTAL_CAPACITY      1000

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("generic-blkdev");

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
static void generic_blkdev_release(struct gendisk *disk);

static int g_major;
static struct gendisk *g_disk;
static struct block_device_operations g_blkdev_ops = {
    .owner = THIS_MODULE,
    .open = generic_blkdev_open,
    .release = generic_blkdev_release
};

static int __init generic_blkdev_init(void)
{
	printk(KERN_INFO "generic-blkdev initialization...\n");

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot register block device!..\n");
        return g_major;
    }

    if ((g_disk = blk_alloc_disk(1)) == NULL) {
        printk(KERN_INFO "cannot alloc gendisk!..\n");
        unregister_blkdev(g_major, "generic-blkdev");
        return -ENOMEM;
    }

    g_disk->major = g_major;
    g_disk->first_minor = 0;
    g_disk->minors = 1;
    strscpy(g_disk->disk_name, "generic-blkdev", DISK_NAME_LEN);   
    g_disk->flags = GENHD_FL_NO_PART;
    g_disk->fops = &g_blkdev_ops;

    blk_queue_logical_block_size(g_disk->queue, 512);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);    /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);            /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);      /* Max segment boyutu */
    set_capacity(g_disk, TOTAL_CAPACITY);

    if (add_disk(g_disk) != 0) {
        put_disk(g_disk);
        unregister_blkdev(g_major, "generic-blkdev");
    }

	return 0;
}

static void __exit generic_blkdev_exit(void)
{
    del_gendisk(g_disk);
	unregister_blkdev(g_major, "generic-blkdev");
    
	printk(KERN_INFO "generic-blkdev exit...\n");
}

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode)
{
    printk(KERN_INFO "generic-blkdev opened...\n");
    return 0;
}

static void generic_blkdev_release(struct gendisk *disk)
{
    printk(KERN_INFO "generic-blkdev released...\n");
}

module_init(generic_blkdev_init);
module_exit(generic_blkdev_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/*-----------------------------------------------------------------------------------------------------------------------------
                                        121. Ders 26/08/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerinde yukarıda belirtilen işlemlerden sonra artık transfer işleminin yapılması için bulundurulan fonksiyonun
    yazılması aşamasına geldik. Kullanıcı modundaki kodlar tarafından blok transferine yönelik bir istek oluştuğunda (örneğin 
    blok aygıt sürücüsünden bir sektör okunmak istediğinde) çekirdeğin IO çizelgeleyicisi bunları çizelgeleyerek uygun bir 
    zamanda transfer edilebilmesi için bizim belirttiğimiz bir fonksiyonu çağırmaktadır. Biz de bu fonksiyon çağrıldığında 
    fonksiyonun içerisinde aktarımı yapmalıyız. Bu çağırma (callback) mekanizması maalesef Linux çekirdeğinde versiyondan 
    versiyona çok fazla değişikliklere uğratılmıştır. Biz burada 6.8 ve sonrasındaki çekirdekleri dikkate alarak açıklamalar 
    yapacağız. 

    Anımsanacağı gibi kullanıcı modundan blok aygıtı için read/write işlemi yapıldığında aşağıdaki gibi bir süreç oluşmaktadır:

    read/write (kullanıcı modu) ---> sys_read/sys_write (çekirdek modu) ---> Okunacak yer "page cache içerisinde var mı"
    ---> "okunacak yer page cache'te yoksa blok aygıt sürücüsünün fonksiyonunu çağır"
    
    Eğer okunacak ya da yazılacak sektör çekirdeğin "page cache'inde yoksa" çekirdek blok aygıt sürücüsünün block_device_operations
    yapısındaki submit_bio elemanında belirtilen fonksiyonu çağırmaktadır. Bu fonksiyonun parametrik yapısı şöyle olmak 
    zorundadır:

    void submit_bio_proc(struct bio *bio);

    Callback fonksiyonun geri dönüş değerinin void olduğuna, parametresinin ise struct bio türünden bir gösterici olduğuna 
    dikkat ediniz. Çekirdek bu fonksiyonu çağırırken blok aygıtından aktarılacak sektörleri izleyen paragraflarda açıklayacağımız
    biçimde bu göstericinin gösterdiği yerdeki bio yapısına yerleştirmektedir. 
    
    Örneğin bir blok aygıt sürücüsünü kullanıcı modunda open fonksiyonuyla açıp içerisinden 10 byte'ı read fonksiyonuyla okumak 
    isteyelim. Eğer bu aygıt sürücü karakter aygıt sürücüsü olsaydı çekirdek doğrudan aygıt sürücünün read fonksiyonunu çağıracaktı. 
    Aygıt sürücü de istenen 10 byte'ı kullanıcı modundaki adrese aktaracaktı. Halbuki blok aygıt sürücüsü durumunda çekirdek 
    önce bu 10 byte'ın bulunduğu sektörün page cache içerisinde olup olmadığına bakacaktır. Eğer talep edilen yer page cache'te
    yoksa çekirdek blok aygıt sürücüsünün submit_bio fonksiyonunu çağırıp transferin aygıt sürücü tarafından yapılmasını 
    isteyecektir. Anımsanacağı gibi blok aygıtlarından transfer edilecek en küçük birim bir sektördür. Dolayısıyla kullanıcı 
    modundaki program blok aygıtından 10 byte okumak istese bile aslında aygıt sürücü en az 1 sektörlük bilgiyi işletim sisteminin 
    page cache'ine aktaracaktır.    
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek blok aygıt sürücüsünün submit_bio fonksiyonunu çağırdığında bio yapısının içerisinde birden fazla aktarım isteği 
    bulunabilmektedir. bio yapısının içerisinde birtakım gerekli bilgilerin yanı sıra bio_vec isimli yapı türünden bir dizi de 
    vardır. İşte asıl aktarım istekleri bu bio_vec yapısı içerisindedir. O halde blok aygıt sürücüsünü yazan sistem programcısı 
    bu bio_vec dizisini dolaşarak gereken aktarımları yapmalıdır. bio_vec içerisinde aktarılacak alanlara "segment" de denilmektedir. 
    bio_vec yapısı şöyle bildirilmiştir:

    struct bio_vec {
        struct page *bv_page;           /* hangi fiziksel sayfa */
        unsigned int bv_len;            /* bu segmentin uzunluğu (bayt cinsinden) */
        unsigned int bv_offset;         /* sayfa içindeki başlangıç offset’i */
    };

    Yapının bv_page elemanı page cache içerisindeki transfer edilecek sayfaya ilişkin sayfa bilgilerini belirtmektedir. Yapının 
    bv_len elemanı transfer edilecek bilginin uzunluğunu belirtir. Tabii bu uzunluk her zaman sektör katları kadardır. bv_offset 
    elemanı page cache içerisindeki 4K'lık cache page'lerinin içerisindeki aktarım offset'ini belirtmektedir. Çekirdek 4K'lık 
    bir cache sayfasının aygıt sürücüden belli bir kısmını doldurmasını isteyebilir. Burada önemli bir nokta şudur: bio_vec 
    yapısının bv_page elemanından biz 4K'lık sayfanın fiziksel adresini elde etmekteyiz. Bu adresin sanal adrese dönüştürülmesi 
    gerekir. Bunun nasıl yapılacağını izleyen paragraflarda açıklayacağız. 

    Biz bio yapısı içerisindeki bio_vec dizisini dolaşarak aktarım isteklerini ve aktarımın fiziksel RAM'de hangi uzunlukta ve 
    nereye yapılması gerektiğini elde ettik. Peki blok aygıtının neresinin aktarılacağı bilgisi nerededir? İşte bio_vec 
    yapıları her zaman blok aygıtında ardışıl sektörleri belirtmektedir. Örneğin bio yapısı içerisindeki bio_vec dizisi üç 
    elemanlı olsun. Bu üç elemandaki segment uzunlukları şöyle olsun:

    [bio_vec (512), bio_vec(1024), bio_vec(512)]

    Buradaki 512, 1024 ve 512 byte'lık bloklar blok aygıtında ardışıl olmak zorundadır. O halde bizim tek bilmemiz gereken şey 
    blok aygıtındaki başlangıç offset'idir. Bu sistemde her bio_vec için blok aygıtında bir offset belirtilmediğine toplamda 
    blok aygıtı için tek bir offset belirtildiğine dikkat ediniz. Blok aygıtındaki bşalngıç offset değerine bio yapısı 
    yoluyla (loff_t)bio->bi_iter.bi_sector * SECTOR_SIZE ifadesi ile erişilmektedir. 

    bio yapısı içerisindeki bio_vec dizisini dolaşmanın iki yolu vardır: Birincisi doğrudan dizi indekslemesi yapmaktır.
    bi_vec dizisinin adresi nio yapısının bi_io_vec elemanındadır Bu dizideki eleman sayısı da bio yapısının bi_vcnt elemanında 
    bulunmaktadır. O halde gezinti şöyle yapılabilir:

    struct bio_vec *bvec;
    int i;
    ...

    for (i = 0; i < bio->bi_vcnt; ++i) {
        bvec = &bio->bi_io_vec[i];
        ...
    }

    bio_vec dizisi alternatif olarak iteratör yoluylabir makro döngüsüyle de dolaşılabilmektedir. Aslında bazı senaryolarda 
    bu makro döngüsü daha uygun işlev görmektedir. Yani bu makro döngüsünü tercih edebilirsiniz:

    struct bio_vec bvec;
    struct bvec_iter iter;
    ...

    bio_for_each_segment(bvec, bio, iter) {
        ...
    }

    Makroya biz bio_vec türünden bir değişkeni, bio türünden göstericiyi ve iteratör görevini yapan bvec_iter türünden bir 
    değişkeni veririz. Bu makro döngüsü her yinelendiğinde bvec göstericisinin içerisine bio_vec dizisinin sıradaki elemanı
    yerleştirilmektedir.

    submit_bio fonksiyonumuz çekirdek tarafından hem okuma hem de yazma istekleri için çağrılmaktadır. Bu durumda bizim aygıt 
    sürücü içerisinde bu fonksiyonun hangi amaçla çağrıldığını belirlememiz gerekir. Bu belirleme işlemi bio_op fonksiyonuyla 
    yapılmaktadır. Bu makroya bio yapısının adresi argüman olarak verilir. Bu fonksiyon bio yapısının içerisindeki uygun alandan 
    submit_bio fonksiyonunun neden çağrıldığı bilgisini elde edip geri dönüş değeri olarak vermektedir. Mevcut çekirdeklerde 
    bu fonksiyon şöyle yazılmıştır:

    static inline enum req_op bio_op(const struct bio *bio)
    {
        return bio->bi_opf & REQ_OP_MASK;
    }

    Tabii bizim bu fonksiyonun bu bilgiyi nasıl elde ettiğini bilmemize gerek yoktur. Bu fonksiyonun geri dönüş değeri bazı 
    bayraklardan oluşmaktadır. Blok aygıt sürücüsünü yazanlar bu bayrakları ele alıp işleyebilmektedir. Buradaki her bayrağın
    blok aygıtında işlenmesine aslında gerek yoktur. Ancak tipik olarak üç bayrağın submit_bio fonksiyonu içerisinde işlenmesi 
    gerekir:
    
    REQ_OP_READ: Blok aygıtından okuma talep edilmektedir.
    REQ_OP_WRITE: Blok aygıtına yazma talep edilmektedir.
    REQ_OP_DISCARD: Blok aygıtının ilgili yerlerinin 0'lanması talep ediliyor.

    O halde bu işlem aşağıdaki gibi bir switch deyimi ile ele alınabilir:

    switch (bio_op(bio)) {
        case REQ_OP_READ:
            ...
        case REQ_OP_WRITE:
            ...
        case REQ_OP_DISCARD:
            ...
    }

    Diğer bayrakların işlenmemesi genel olarak bir sorun oluşturmamaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            127. Ders 16/09/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri için en tipik örnek ramdisk aygıt sürücüleridir. Ramdisk aygıt sürücüleri çekirdeğin alanı içerisindeki 
    bir bölgeyi sanki bir diskmiş gibi kullanmaktadır. Biz kurusumuzun başında zaten Linux sistemlerinde hazır bir biçimde 
    bulunan ramdisk dosyas sistemini ve blok aygıt sürücülerini kullanmıştık. 
        
    Ramdisk aygıt sürücümüzde bizim işin başında (yani aygıt sürücümüzün init fonksiyonu içerisinde ramdisk için dinamik bellek 
    tahsisatı yapmamız gerekir. Bu tahsisatı daha önce görmüş olduğumuz kmalloc fonksiyonu ile yapabiliriz. Ancak kmalloc 
    fonksiyonu ardışıl fiziksel bellek tahsis etmektedir. Ancak bu tür uygulamalarda eğer büyük miktarda tahsisatlar yapılacaksa 
    fiziksel ardışıllığa gerek yoktur. Fiziksel bellekte ardışıl olmayacak biçimde (ancak sanal adres alanı içerisinde ardışıllık 
    korunmaktadır) tahsisat yapan vmalloc ve zvalloc fonksiyonları da bulunmaktadır. Her iki fonksiyon da parametre olarak 
    tahsis edilecek byte miktarını almaktadır. zvalloc aynı zamanda tahsis edilen alanı da sıfırlamaktadır. Örneğin:

    ...
    if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
        printk(KERN_INFO "cannot allocate memory!..\n");
        goto EXIT3;
    }
    ...

    vzalloc ile tahsis edilen alan vfree fonksiyonu ile serbest bırakılabilir. Örneğin:

    vfree(g_diskmem);

    Ramdisk aygıt sürücümüzün init fonksiyonu şöyle olabilir:

    static int __init generic_blkdev_init(void)
    {
        printk(KERN_INFO "ramdisk-blkdev initialization with capacity = %d\n", capacity);

        if ((g_major = register_blkdev(0, "ramdisk-blkdev")) < 0) {
            printk(KERN_INFO "cannot register block device!..\n");
            return g_major;
        }

        if ((g_disk = blk_alloc_disk(1)) == NULL) {
            printk(KERN_INFO "cannot alloc gendisk!..\n");
            goto EXIT1;
        }

        g_disk->major = g_major;
        g_disk->first_minor = 0;
        g_disk->minors = 1;
        strscpy(g_disk->disk_name, "ramdisk-blkdev", DISK_NAME_LEN);   
        g_disk->flags = GENHD_FL_NO_PART;
        g_disk->fops = &g_blkdev_ops;

        blk_queue_logical_block_size(g_disk->queue, SECTOR_SIZE);       /* Mantıksal blok boyutu */
        blk_queue_physical_block_size(g_disk->queue, 4096);             /* Fiziksel blok boyutu */
        blk_queue_max_segments(g_disk->queue, 128);                     /* Max segment sayısı */
        blk_queue_max_segment_size(g_disk->queue, 65536);               /* Max segment boyutu */
        set_capacity(g_disk, capacity);

        if (add_disk(g_disk) != 0) {
            printk(KERN_INFO "cannot add disk!..\n");
            goto EXIT2;
        }

        if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
            printk(KERN_INFO "cannot allocate memory!..\n");
            goto EXIT3;
        }

        return 0;
    EXIT3:
        del_gendisk(g_disk);
    EXIT2:
        put_disk(g_disk);
    EXIT1:
        unregister_blkdev(g_major, "ramdisk-blkdev");

        return -ENOMEM;
    }

    Burada blok aygıt sürücüleri için daha önce açıkladığımız tipik işlemler yapılmıştır. Bu işlemler aygıt sürücünün exit 
    fonksiyonunda geri alınmalıdır:

    static void __exit generic_blkdev_exit(void)
    {
        vfree(g_diskmem);
        del_gendisk(g_disk);
        unregister_blkdev(g_major, "ramdisk-blkdev");
        
        printk(KERN_INFO "ramdisk-blkdev exit...\n");
    }

    Tabii aygıt sürücümüzün en önemli fonksiyonu submit_bio fonksiyonudur. sumit_bio fonksiyonunda bizim indeksleme yoluyla
    ya da iteratör yoluyla bio yapısı içerisindeki bio_vec elemanlarını alıp işleme sokmamız gerekir:

    static void submit_bio_proc(struct bio *bio)
    {
        struct bio_vec bvec;
        struct bvec_iter iter;
        sector_t sector;
        size_t offset;
        unsigned int len;
        
        sector = bio->bi_iter.bi_sector;
        
        printk(KERN_INFO "submit_bio_proc called\n");

        bio_for_each_segment(bvec, bio, iter) {
            len = bvec.bv_len;
            offset = (size_t)sector * SECTOR_SIZE;
            ...
        }
        ...
    }

    Burada döngü makrosuna dikkat ediniz:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;
        ...
    }

    Buradaki len çekirdeğin transfer edilmesini istediği uzunluktur. Bu zuunluğun aslında 512'nin (yani sektörün) katları 
    olduğunu belirtmiştirk. offset ise transfer edilecek alanın tam olarak blok aygıtının (örneğimizde ramdisk) neresinden 
    başladığını belirtmektedir. bio_vec içerisindeki segment'lerin sektörleri ardışıl olduğu için biz her yienelmede bu sector 
    değerini artırmalıyız:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;


        ...
        sector += len / SECTOR_SIZE;
    }

    Kullanıcı modundaki program lseek ile dosya göstericisini bizim blok aygıtımızının kapasitesinin ötesine konumlandırıp 
    read/write işlemi yapmış olabilir. Çekirdek burada aygıt kapasitesin kendisi kontrol etmemektedir. Çünkü blok aygıtları
    bu tür durumlarda bazı özel işlemler uygulayabilmektedir. Programcının buradaki offset değerinin kendi blok aygıtının 
    sınırları dışında olup olmadığını kontrol etmesi gerekir. Bu kontrol şöyle yapılabilir:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                    offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }
        ramdisk_addr = g_diskmem + offset;
        ...
        sector += len / SECTOR_SIZE;
    }

    Burada eğer IO isteği blok aygıtımızın sınırları dışına çıkmışsa biz submit IO fonksiyonunu sonlandırdırdık. bio_vec 
    vektörlerinin ardışıl sektörlere ilişkin segment'ler içerdiğini anımsayınız. Bir kere kapasi,te dışına çıkılmışsa döngünün
    diğer bio_vec elemanları da kapasite dışına çıkmış olacaktır. Burada önemli bir nokta fonksiyon başarısız olduğunda 
    bio_io_error(bio) fonksiyonun çağrılması zorunluluğudur. Çünkü submit_bio fonksiyonunun geri dönüş değeri void biçimdedir. 
    Başarısızlık bu fonksiyonla çekirdeğe bildirilmektedir. Bu fonksiyonun prototipi şöyledir:

    void bio_io_error(struct bio *bio);

    Fonksiyon bio yapısının adresini almaktadır. bio yapısının bir elemanına başarısılık bilgisi yerleştirilmektedir. Biz 
    bu aşamada blok aygıtının hangi offset'inden ne kadar byte transfer yapılacağını biliyor durumdayız. Ancak henüz transfer 
    ediecek adres üzerinde (transfer daha önceden de belirtitğimiz gibi "page cache" içerisinde bir yere yapılmaktadır) bir 
    işlem uygulamadık. Şimdi o kısmı halledelim. kmap_local_page isimli çekirdek fonksiyonu bizden bir page yapıs nesnesinin 
    adresini alır, bu page yapısının içerisindeki fiziksel adresi elde eder, sonra o fiziksel adrese erişmek için sayfa 
    tablosunda düzenleme yaparak bize sanal adresi verir. O halde biz bio_vec yapısı içeisindeki fiziksel adrese erişmek için 
    şu üzenlemeyi yapabiliriz:

    cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

    İşimiz bittiğinde de bu işlemi kunmap_local fonksiyonuyla geri almalıyız:

    kunmap_local(cache_addr);   

    Artık elimizde ramdiskimizdeki transfer adresi ve çekirdeğin page cache sisteminde transfer adresi vardır. Şimdi artık sıra 
    gerçek transfer işlemine gelmiştir. Bizim transferin yönüne bakıp bu işlemi yapmamız gerekir:

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                   offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }

        ramdisk_addr = g_diskmem + offset;
        cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

        switch (bio_op(bio)) {
            case REQ_OP_READ:
                memcpy(cache_addr, ramdisk_addr, len);
                break;
            case REQ_OP_WRITE:
                memcpy(ramdisk_addr, cache_addr, len);
                break;
            case REQ_OP_DISCARD:
                memset(ramdisk_addr, 0, len);
                break;
            default:
                break;  
        }
        kunmap_local(cache_addr);

        sector += len / SECTOR_SIZE;

    }

    Tabii transfer işleminden sonra kmap_local_page fonksiyonuyla değiştirilen safta tablosunun eski haline getirilmesi gerekir. 
    Bu işlem kunmap_local fonksiyonuyla yapılmaktadır. Aslında kunmap_local bir makro olarak yazılmıştır. Bu makrı sanal adresi 
    alıp ters işlemi yapmaktadır. 

    Örnel ramdisk aygıt sürücümüzü basit bir programla kullanabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <fcntl.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        int fd;
        unsigned char buf[10];
            
        if ((fd = open("ramdisk-blkdev", O_RDWR)) == -1)
            exit_sys("open");

        if (read(fd, buf, 10) == -1)
            exit_sys("read");
        
        for (int i = 0; i < 10; ++i)
            printf("%02X ", buf[i]);
        printf("\n");

        lseek(fd, 0, 0);

        if (write(fd, "abcdefghij", 10) == -1)
            exit_sys("write");
        

        close(fd);

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Aşağıda aygıt sürücünün tüm kodları verilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* ramdisk-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/blkdev.h>
#include <linux/vmalloc.h>

#define DEF_TOTAL_CAPACITY      1000

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("generic-blkdev");

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode);
static void generic_blkdev_release(struct gendisk *disk);
static void submit_bio_proc(struct bio *bio);

static int g_major;
static struct gendisk *g_disk;
static struct block_device_operations g_blkdev_ops = {
    .owner = THIS_MODULE,
    .open = generic_blkdev_open,
    .release = generic_blkdev_release,
    .submit_bio = submit_bio_proc
};

static int capacity = DEF_TOTAL_CAPACITY;
static u8 *g_diskmem;

module_param(capacity, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init generic_blkdev_init(void)
{
	printk(KERN_INFO "ramdisk-blkdev initialization with capacity = %d\n", capacity);

    if ((g_major = register_blkdev(0, "ramdisk-blkdev")) < 0) {
        printk(KERN_INFO "cannot register block device!..\n");
        return g_major;
    }

    if ((g_disk = blk_alloc_disk(1)) == NULL) {
        printk(KERN_INFO "cannot alloc gendisk!..\n");
        goto EXIT1;
    }

    g_disk->major = g_major;
    g_disk->first_minor = 0;
    g_disk->minors = 1;
    strscpy(g_disk->disk_name, "ramdisk-blkdev", DISK_NAME_LEN);   
    g_disk->flags = GENHD_FL_NO_PART;
    g_disk->fops = &g_blkdev_ops;

    blk_queue_logical_block_size(g_disk->queue, SECTOR_SIZE);       /* Mantıksal blok boyutu */
    blk_queue_physical_block_size(g_disk->queue, 4096);             /* Fiziksel blok boyutu */
    blk_queue_max_segments(g_disk->queue, 128);                     /* Max segment sayısı */
    blk_queue_max_segment_size(g_disk->queue, 65536);               /* Max segment boyutu */
    set_capacity(g_disk, capacity);

    if (add_disk(g_disk) != 0) {
        printk(KERN_INFO "cannot add disk!..\n");
        goto EXIT2;
    }

    if ((g_diskmem = (u8 *)vzalloc(capacity * SECTOR_SIZE)) == NULL) {
        printk(KERN_INFO "cannot allocate memory!..\n");
        goto EXIT3;
    }

    return 0;
EXIT3:
    del_gendisk(g_disk);
EXIT2:
    put_disk(g_disk);
EXIT1:
    unregister_blkdev(g_major, "ramdisk-blkdev");

	return -ENOMEM;
}

static void __exit generic_blkdev_exit(void)
{
    vfree(g_diskmem);
    del_gendisk(g_disk);
	unregister_blkdev(g_major, "ramdisk-blkdev");
    
	printk(KERN_INFO "ramdisk-blkdev exit...\n");
}

static int generic_blkdev_open(struct gendisk *disk, blk_mode_t mode)
{
    printk(KERN_INFO "ramdisk-blkdev opened...\n");

    return 0;
}

static void generic_blkdev_release(struct gendisk *disk)
{
    printk(KERN_INFO "ramdisk-blkdev released...\n");
}

static void submit_bio_proc(struct bio *bio)
{
    struct bio_vec bvec;
    struct bvec_iter iter;
    sector_t sector;
    size_t offset;
    unsigned int len;
    void *ramdisk_addr, *cache_addr;
    
    sector = bio->bi_iter.bi_sector;
    
    printk(KERN_INFO "submit_bio_proc called\n");

    bio_for_each_segment(bvec, bio, iter) {
        len = bvec.bv_len;
        offset = (size_t)sector * SECTOR_SIZE;

        if (offset + len > (size_t)capacity * SECTOR_SIZE) {
            printk(KERN_INFO "ramdisk-blkdev: out-of-range I/O (off=%zu len=%u cap=%zu)\n",
                   offset, len, (size_t)capacity * SECTOR_SIZE);
            bio_io_error(bio);
            return;
        }

        ramdisk_addr = g_diskmem + offset;
        cache_addr = (u8 *)kmap_local_page(bvec.bv_page) + bvec.bv_offset;

        switch (bio_op(bio)) {
            case REQ_OP_READ:
                printk(KERN_INFO "submit_bio_proc read called\n");
                memcpy(cache_addr, ramdisk_addr, len);
                break;
            case REQ_OP_WRITE:
                memcpy(ramdisk_addr, cache_addr, len);
                break;
            case REQ_OP_DISCARD:
                memset(ramdisk_addr, 0, len);
                break;
            default:
                break;  
        }
        kunmap_local(cache_addr); 

        sector += len / SECTOR_SIZE;
    }
    bio_endio(bio);
}

module_init(generic_blkdev_init);
module_exit(generic_blkdev_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* blkdev.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
	unsigned char buf[10];
		
	if ((fd = open("ramdisk-blkdev", O_RDWR)) == -1)
		exit_sys("open");

	if (read(fd, buf, 10) == -1)
		exit_sys("read");
	
	for (int i = 0; i < 10; ++i)
		printf("%02X ", buf[i]);
	printf("\n");

	lseek(fd, 0, 0);

    if (write(fd, "abcdefghij", 10) == -1)
		exit_sys("write");
	

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                            128. Ders 18/09/2025 - Perşembe 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte oluşturduğumuz ramdisk blok aygıt sürücüsü bir dosya sistemi ile formatlanarak sanki bir disk bölümüymüş 
    gibi de kullanılabilir. Zaten artık tüm işlemler rad/write gibi dosya fonksiyonlarıyla yapılmaktadır. Ramdisk aygıt sürücümüzü
    mkfs.ext4 programıyla "ext-4" ile aşağıdaki gibi formatlayabiliriz: 

    $ sudo mkfs.ext4 ramdisk-blkdev

    Formatlama işleminden sonra artık sıra blok aygıt sürücümüzün mount edilmesine gelmiştir. Anımsanacağı gibi mount işlemi 
    bir blok aygıt sürücüsü içerisindeki dosya sisteminin dizin ağacının belli bir dizinine monte edilmesi anlamına gelmektedir. 
    Dolayısıyla mount komutunda kullanıcı blok aygıt sürücüsünü ve mount edilecek dizini belirtir. Örneğin:

    $ mkdir ramdisk-drive
    $ sudo mount ramdisk-blkdev ramdisk-drive

    Burada mount noktası (mount point) ramdisk-drive dizinidir. Artık bu dizinin içerisine geçip dosya işlemleri yapabiliriz. 
    Tüm bu işlemler yapılırken aslında arka planda ramdisk aygıt sürücümüzün submit_bio fonksiyonu çağrılacaktır. 
    
    İşlemleri geri almak için önce umount işlemi yapılmalıdır:

    $ sudo umount ramdisk-drive

    Ramdisk aygıt sürücüsü kullanım bittikten sonra çekirdek alanından çıkarılabilir:

    $ sudo ./unloadblk ramdisk-blkdev

    Tabii ramdisk aygıt sürücümüzü unmount ettikten sonra artık onun içeriğine erişemeyiz. Yani yaptığımız her şey kaybolur. 
    Biz aygıt sürücümüzü yeniden yüklesek artık yeniden içi sıfırlarla dolu bir ramdisk oluşturulacaktır. Tabii aygıt sürücümüzü 
    unmount etmeden önce onun içerisindeki bilgileri "dd" programıyla bir dosyada saklayabiliriz:

    $ sudo dd if=ramdisk-blkdev of=ramdisk-drive.dat

    Aygıt sürücümüzü yeniden load ettikten sonra ters işlemi yaparak onun içeriğini oluşturabiliriz:

    dd if=ramdisk-drive.dat of=ramdisk-blkdev
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB ya da Raspberry Pi'da nasıl aygıt sürücü geliştirebiliriz? Aslında daha önceden de belirttiğimiz gibi Raspberry Pi 
    zaten yeterli bir masaüstü bilgisayar gibidir. Geliştirme doğrudan onun üzerinde yapılabilir. Yani geliştirmenin Intel 
    tabanlı makinede yapılıp aygıt sürücü dosyalarının oraya aktarılmasına hiç gerek yoktur. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB için aygıt sürücüleri BBB'nin üzerinde derlemek oldukça yavaştır. Çünkü BBB Raspberry Pi kadar güçlü bir donanıma 
    sahip değildir. Bu nedenle BBB için aygıt sürücülerin tercihen Intel tabanlı Linux sistemlerinde derlenip BBB'ye aktarılması 
    uygundur. Tabii bunun için çapraz derleyicilerin kurulu olması gerekmektedir.

    make modules_pepare
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/


