                                             C ve Sistem Programcıları Derneği

                                                   Python Uygulamaları 

                                         Sınıfta Yapılan Örnekler ve Özet Notlar 
                                                         1. Bölüm
        
                                                    Eğitmen: Kaan ASLAN   
                
                Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
                Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

                Aslan, K. (2025), "Python Uygulamaları Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                    C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                        Son Güncelleme: 12/07/2025 - Cumartesi

#------------------------------------------------------------------------------------------------------------------------------------
                                            1. Ders 23/02/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da tarih zaman işlemleri için standart kütüphane içerisindeki time ve datetime modülleri (paketleri) kullanılmaktadır. 
    time modülü aslında C Programlama Dilindeki prototipleri <time.h> dosyası içerisinde olan çeşitli standart C fonksiyonlarının 
    adeta Python karşılıklarını barındırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki time fonksiyonu epoch'tan (01/01/1970'ten) geçen saniye sayısına geri döner. Epoch olarak 01/01/1970 00:00 
    alınmaktadır. (Bu epoch C Programalama Dilinin bir çeşit doğum tarihi gibi düşünülmüştür.) time fonksiyonu float bir değere geri 
    dönmektedir. Yani elde edilen saniye sayısı noktalı bir değer olabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time

result = time.time()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    time fonksiyonu ile programın iki noktası arasında geçen zaman saniye cinsinden ölçülebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import time

t1 = time.time()

for _ in range(100000000):
    pass

t2 = time.time()

result = t2 - t1

print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki ctime fonksiyonu epoch'tan (01/01/1970'ten) geçen saniye sayısını parametre olarak alır, onu yazısal biçime
    dönüştürerek bir yazı biçiminde bize verir. Örneğin:

    import time

    t = time.time()
    s = time.ctime(t)
    print(s)

    ctime fonksyonun verdiği yazı belli bir formattadır. Biz o formatı değiştiremeyiz. Format şöyledir:

    Sun Feb 23 19:39:40 2025

    ctime fonksiyonu bilgisayarın saatine bakmaz. Yalnızca verilen saniye sayısı üzerinde ayrıştırmalar yaparak onu parçalara ayırır.
    ctime her zaman yerel saati (local time) vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time

t = time.time()
s = time.ctime(t)
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer ctime fonksiyonuna argüman girilmezse o andaki zaman dikkate alınmaktadır. Yani bu durumda fonksiyon önce time.time fonksiyonu 
    ile o andaki zamanı elde edip onu kullanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import time

s = time.ctime()
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Şu andaki tarih zamanı tek bir ifade ile aşağıdaki gibi yazdırabiliriz:

    print(time.ctime())    
#------------------------------------------------------------------------------------------------------------------------------------

print(time.ctime())

#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki localtime fonksiyonu 01/01/1970'ten geçen saniye sayısını parametre olarak alır ve struct_time türünden bir sınıf 
    nesnesine geri döner. Bu sınıf nesnesinin tm_xxx biçiminde isimlendirilmiş olan elemanlarından ilgili zaman bilgilerini
    alabiliriz. struct_time sınıfının önemli elemanları şunlardır:

    tm_gmtoff
    tm_hour
    tm_isdst
    tm_mday
    tm_min
    tm_mon
    tm_sec
    tm_wday
    tm_yday
    tm_year
    tm_zone
        
    Bu fonksiyon da parametresiz kullanımda o andaki zamana ilişkin bilgiyi vermeketedir. localtime fonksiyonun da bilgisayarın saatine
    bakmadığına yalnızca ayrıştırma işlemini yaptığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time

t = time.time()
st = time.localtime()
print(f'{st.tm_mday:02d}/{st.tm_mon:02d}/{st.tm_year:04d}-{st.tm_hour:02d}:{st.tm_min:02d}:{st.tm_sec:02d}')
      
#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki perf_counter fonksiyonu daha duyarlıklı zaman ölçmek için bulundurulmuştur. Bu fonksiyon bize float türünden bir 
    saniye sayısı verir. Ancak bu sayının nereden itibaren bir saniye sayısı belirttiği belli değildir. (Örneğin bu değer 01/01/1970'ten 
    geçen saniye sayısı değildir.) Dolayısıyla bu fonksiyon ancak iki kere çağrılıp aradaki farkı hesaplamak için anlamlıdır.
#------------------------------------------------------------------------------------------------------------------------------------

import time

t1 = time.perf_counter()
for _ in range(100_000_000):
    pass
t2 = time.perf_counter()

result = t2 - t1
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki perf_counter_ns bize geçen zaman bilgisini nano saniye (saniyenin milyarda biri) cinsinden verir. Dolayısıyla bu 
    fonksiyon noktadan sonraki yuvarlama hataları ile ilgili sorun oluşturmaz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time

t1 = time.perf_counter_ns()

for _ in range(100_000_000):
    pass

t2 = time.perf_counter_ns()

result = (t2 - t1)
print(result)

result = (t2 - t1) / 1_000_000_000
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki sleep fonksiyonu CPU zamanı harcamadan ilgili akışı (thread'i) belirtilen saniye kadar bekletir.
#------------------------------------------------------------------------------------------------------------------------------------

import time

for i in range(10):
    print(i, end=' ')
    time.sleep(0.5)
print()

#------------------------------------------------------------------------------------------------------------------------------------
    sleep gibi bir bekleme fonksiyonunu meşgul döngü (busy loop) oluşturacak biçimde gerçekleştirmeye çalışmayınız. Çünkü time.sleep 
    fonksiyonu thread'ler konusunda da göreceğimiz gibi o anda çalışmakta olan thread'i CPU zamanı harcamayacak biçimde bloke etmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time

def bad_sleep(seconds):
    t1 = time.perf_counter()
    while True:
        t2 = time.perf_counter()
        if t2 - t1 >= seconds:
            break
        
for i in range(10):
    print(f'{i} ', end='')
    bad_sleep(0.5)
    
#------------------------------------------------------------------------------------------------------------------------------------
    time modülündeki diğer fonksiyonlar için "Python Standard Library" dokümanına başvurabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    datetime isimli standart modül faydalı birkaç sınıf barındırmaktadır. datetime modülündeki date isimli sınıf bir tarih bilgisini 
    (zaman değil) tutarak bazı temel işlemleri yapmamıza olanak sağlamaktadır. date sınıfının __init__ metodu bizden yıl, ay, gün 
    bilgisini alarak nesnenin year, month, day özniteliklerinde saklar. 

    datetime.date(year, month, day)

    Nesne yaratılırken geçersiz tarih girilirse exception oluşur. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2022, 10, 21)
print(d)
print(f'{d.day:02d}/{d.month:02d}/{d.year:04d}')

#------------------------------------------------------------------------------------------------------------------------------------
    datetime sınıfının static today isimli metodu o andaki tarih bilgisini date nesnesi olarak verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2019, 12, 27)
print(d)
print(f'{d.day}/{d.month}/{d.year}')

#------------------------------------------------------------------------------------------------------------------------------------
    O anki tarihi Python'da yazdırmanın pratik bir yolu aşağıdaki gibidir.

    import datetime

    print(datetime.date.today())

    Tabii bunu yukarıda da belrttiğimiz gibi time.ctime fonksiyonuyla da yapabiliriz:

    import time

    print(time.ctime())
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

print(datetime.date.today())

#------------------------------------------------------------------------------------------------------------------------------------
    date sınıfının weekday isimli metodu bize tarihin haftanın kaçıncı günü olduğu bilgisini verir. Burada 0 = Pazartesidir. Örneğin
    weekday metodu bize 4 verdiyse bu ilgili günün Cuma olduğu anlamına gelecektir. Biz burada elde ettiğimiz değeri günlerin isimlerinin
    bulunduğu bir listeye indeks yaparak gün ismini elde edebiliriz. Örneğin:

    d = datetime.date.today()
    daytext = ('Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazar')
    print(daytext[d.weekday()])
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date.today()
daytext = ('Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazar')
print(daytext[d.weekday()])

#------------------------------------------------------------------------------------------------------------------------------------
                                            2. Ders 01/03/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    date sınıfının isoweekday isimli metodu yine bize nesnenin tuttuğu tarihin haftanın kaçıncı günü olduğu bilgisini verir. Ancak 
    haftanın başlangıç günü Pazar'dır. Yani burada 0 = Pazar'dır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date.today()
daytext = ('Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazartesi')

print(daytext[d.isoweekday()])

#------------------------------------------------------------------------------------------------------------------------------------
    date sınıfının isocalendar isimli metodu bize nesnenin tuttuğu tarihi sırasıyla yıl, yılın haftası, haftanın günü biçiminde bir 
    "isimli demet (named tuple) nesnesi olarak vermektedir. Biz bu bilgilere [] operatörü ile ya dağrudan year, week ve weekday 
    öznitelikleriyle erişebiliriz. Haftanın günü için başlangıç 0 = Pazar biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date.today()
ic = d.isocalendar()
print(ic)
print(ic.year, ic.week, ic.weekday)
print(ic[0], ic[1], ic[2])

#------------------------------------------------------------------------------------------------------------------------------------
    date sınıfının isoformat isimli metodu nesnenin tuttuğu tarihi "yyyy-mm-dd" formatında bir yazı biçiminde verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2020, 10, 5)
result = d.isoformat()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
   date sınıfının iki tarihi karşılaştıran karşılaştırma operatör netotları bulunmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d1 = datetime.date(2020, 10, 5)
d2 = datetime.date(2020, 9, 5)

if d1 > d2:
    print('d1 > d2')
elif d1 < d2:
    print('d1 < d2')
elif d1 == d2:
    print('d1 == d2')
    
#------------------------------------------------------------------------------------------------------------------------------------
    datetime modülündeki date sınıfının fromisoformat isimli sınıf metodu ISO formatındaki yazısal tarihten date nesnesi oluşturarak 
    bu date nesnesine geri dönmektedir. Örneğin:

    s = input('yyyy-mm-dd formatında bir tarih giriniz:')
    d = datetime.date.fromisoformat(s)

    date sınıfının fromisocalender isimli sınıf metodu ise bizden sırasıyla yıl, yılın haftası ve haftanın gününü (0 = Pazar) parametre
    olarak alır ve bize ilgili tarihe ilişkin date nesnesini verir. Örneğin:

    d = datetime.date.fromisocalendar(2025, 6, 3)
    print(d)

    d = datetime.date.fromisocalendar(2025, 6, 3)
    print(d)
#------------------------------------------------------------------------------------------------------------------------------------

import datetime 

s = input('yyyy-mm-dd formatında bir tarih giriniz:')
d = datetime.date.fromisoformat(s)
print(d)

#------------------------------------------------------------------------------------------------------------------------------------
    datetime sınıfının strptime isimli sınıf metodu belli belli bir formata uygun yazısal tarih bilgisinden datetime nesnesi oluşturmaktadır.
    metodun parametrik yapısı şöyledir:

    classmethod datetime.strptime(date_string, format)

    Buradakidate_string tarih belirten yazıyı, format ise o yazıdaki tarih formatını belirtmektedir. Eğer yazı bu formata uygun değilse
    ValueError exception'ı raise edilmektedir. Örneğin:

    s = input('Bir tarih giriniz:')
    try:
        dt = datetime.datetime.strptime(text, '%d/%m/%Y')
        print('Date is ok')
    except ValueError:
        print('Invalid date')

    Buradaki format karakterlerinin listesini ve anlamlarını Python Standard Library Reference içerisinden inceleyebilirsiniz:

    https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    datetime modülündeki time sınıfı zaman bilgisini tutmak ve onun üzerinde işlemler yapmak için kullanılmaktadır. Sınıfın __init__ 
    metodu bizden sırasıyla saat, dakika, saniye ve mikro saniye değerlerini almaktadır. Bu parametreler default 0 değerini almıştır. 
    Sınıfın __str__ ve __repr__ metotları yine zaman bilgisini bize bir yazı biçiminde vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

t = datetime.time(13, 42, 54)
print(t)

#------------------------------------------------------------------------------------------------------------------------------------
    time sınıfının hour, minute, second ve microsecond örnek öznitelikleri nesnenin tuttuğu zamanın saat, dakika, saniye  ve 
    mikro saniye bileşenlerini bize verir.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

t = datetime.time(13, 42, 6)
print(f'{t.hour:02d}:{t.minute:02d}:{t.second:02d}')

#------------------------------------------------------------------------------------------------------------------------------------
    time sınıfın iki time nesnesini karşılaştıran karşılaştırma operatör metotları vardır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

t1 = datetime.time(13, 42, 6)
t2 = datetime.time(9, 43, 6)

if t1 > t2:
    print('t1 > t2')
elif t1 < t2:
    print('t1 > t2')
elif t1 == t2:
    print('t1 == t2')
    
#------------------------------------------------------------------------------------------------------------------------------------
    İki time nesnesi toplanıp çıkartılamamaktadır. (Ancak ileride göreceğimiz iki timedelta nesnesi toplanıp çıkartılabilmektedir.)
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

td = datetime.timedelta(hours=30, minutes=5, seconds=10)

print(td.seconds)               # 6 * 60 * 60 + 5 * 60 + 10 = 2190
print(td.total_seconds())       # 108310.0

#------------------------------------------------------------------------------------------------------------------------------------
    datetime modülünün timedelta isimli sınıfı bir süre yani bir zaman aralığı bilgisini tutmak için kullanılmaktadır. Sınıfın __init__ 
    metodunun parametrik yapısı şöyledir:

    datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

    Sınıfın __str__ ve __repr__ metotları zaman aralığını bir yazı olarak verecek biçimde yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

td = datetime.timedelta(hours=2, minutes=12, seconds=5)
print(td)

#------------------------------------------------------------------------------------------------------------------------------------
    timedelta sınıfının days örnek özniteliği tutulan süredeki tam gün sayısını, seconds örnek özniteliği gündeki toplam saniye sayısını 
    vermektedir. (Yani seconds örnek özniteliği her zaman gece saat 00:00:00'dan itibaren geçen saniye sayısını verir.) Sınıfın microseconds 
    örnek özniteliği ise zaman aralığının yalnızca mikroseniye bileşenini vermektedir. Sınıfın total_seconds metodu tüm zaman aralığının 
    saniye değerini vermektedir. total_seconds float bir değer geri döndürmektedir ve mikro saniye de değerin içerisinde bulunmaktadır. 
    Ancak sınıfın seconds örnek özniteliği int türdendir. Onun içerisinde mikro saniye değeri yoktur. Sınıfın minutes, hours gibi 
    örnek özniteliklerinin olmaıdğına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.timedelta(days = 2, hours=5, minutes=2, seconds=10, microseconds = 35)
print(dt)

print(dt.days)              # 2
print(dt.seconds)           # 18130
print(dt.microseconds)      # 35
print(dt.total_seconds())    # 190930.000035

#------------------------------------------------------------------------------------------------------------------------------------
    timedelta sınıfında ilgili değerler herhangi biçimde verilebilir. (Örneğin hours değeri 0 ile 24 arasında olmak zorunda değildir.)   
    Bu değerler float olarak da verilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

td = datetime.timedelta(hours=1.5, minutes=12.5, seconds=5)
print(td)

#------------------------------------------------------------------------------------------------------------------------------------
    timedelta nesnesinin seconds özniteliği toplam saniye sayısını değil zaman aralığının son gün günündeki gece saat 00:00:00'dan 
    geçen saniye sayısını vermektedir. Örneğin:

    td = datetime.timedelta(hours=30, minutes=5, seconds=10)

    print(td.seconds)               # 6 * 60 * 60 + 5 * 60 + 10 = 2190
    print(td.total_seconds())       # 108310.0

    Başka bir deyişle nesnenin seconds özniteliği td.total_seconds() % 86400 değerini vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

td = datetime.timedelta(hours=30, minutes=5, seconds=10)

print(td.seconds)               # 6 * 60 * 60 + 5 * 60 + 10 = 2190
print(td.total_seconds())       # 108310.0

#------------------------------------------------------------------------------------------------------------------------------------
    İki time nesnesi toplanıp çıkartılamaz ancak iki timedelta nesnesi toplanıp çıkartılabilir. Bu durumda elde edilen değer yine 
    timedelta nesnesi olur. Örneğin:

    td1 = datetime.timedelta(hours=30, minutes=5, seconds=10)
    td2 = datetime.timedelta(hours=17, minutes=2, seconds=5)

    result = td1 - td2
    print(result)
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

td1 = datetime.timedelta(hours=4, minutes=12, seconds=5)
td2 = datetime.timedelta(hours=3, minutes=55, seconds=58)

result = td1 + td2
print(result)

result = td1 - td2
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    time nesnesi timedelta nesnesi ile toplanıp çıkartılamaz ancak date nesnesi timedelta nesnesiyle toplanıp çıkartılabilir. Sonuç 
    date sınıfı türünden olur. Tabii bu durumda timedelta nesnesindeki tam günler işleme sokulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2020, 12, 6)
td = datetime.timedelta(days=3, hours=25)

result = d + td
print(result)           # 2020-12-10

result = d - td
print(result)           # 2020-12-02

#------------------------------------------------------------------------------------------------------------------------------------
    datetime modülünün datetime isimli sınıfı hem tarih hem de zaman bilgisini bir arada aynı nesnede tutmak için bulundurulmuştur.
    Sınıfın __init__ metodunun parametrik yapısı şöyledir:

    datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

    Yine sınıfın __str__ ve __repr__ metotları datetime nesnesindeki tarih ve zaman değerlerini bize bir yazı biçiminde vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.datetime(2019, 12, 5, 12, 7, 34)
print(dt)           # 2019-12-05 12:07:34

#------------------------------------------------------------------------------------------------------------------------------------
    datetime nesnesinin year, month, day, hour, minute, second, microsecond öznitelikleri nesne içerisindeki tarih/zaman bilgisinin
    bileşenlerini elde etmek için kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.datetime(2019, 12, 5, 12, 7, 34)
print(f'{dt.day:02d}/{dt.month:02d}/{dt.year:04d} {dt.hour:02d}:{dt.minute:02d}:{dt.second:02d}')

#------------------------------------------------------------------------------------------------------------------------------------
    Yine datetime sınıfının iki datetime nesnesini karşılaştıran operatör metotları vardır.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt1 = datetime.datetime(2019, 12, 5, 12, 7, 34)
dt2 = datetime.datetime(2019, 12, 5, 12, 7, 34)

if dt1 > dt2:
    print('dt1 > dt2')
elif dt1 < dt2:
    print('dt1 < dt2')
elif dt1 == dt2:
    print('dt1 == dt2')

#------------------------------------------------------------------------------------------------------------------------------------
    İki datetime nesnesi toplanamaz ancak çıkartılabilir. Elde edilen sonuç timedelta türünden olur.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt1 = datetime.datetime(2019, 12, 5, 12, 7, 34)
dt2 = datetime.datetime(2018, 6, 4, 12, 6, 45)

td = dt1 - dt2
print(td)    

#------------------------------------------------------------------------------------------------------------------------------------
    datetime sınıfının now isimli statik metodu tarih zaman bilgisini datetime nesnesi olarak bize verir.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.datetime.now()
print(dt)
print(datetime.datetime.now())

#------------------------------------------------------------------------------------------------------------------------------------
    datetime nesnesi ile timedelta nesnesi toplanıp çıkartılabilir. Elde edilen sonuç datetime nesnesi olur.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.datetime.now()
result = dt + datetime.timedelta(days=60, hours=3, minutes=27)
print(dt)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    datetime nesnesi oluşturulurken geçersiz bir tarih ya da zaman bilgisi exception oluşmasına yol açar.
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

dt = datetime.datetime(2021, 2, 30)
result = dt + datetime.timedelta(days=1)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    datetime sınıfının combine isimli statik metodu date ve time nesnelerini alıp bir datetime nesnesi vermektedir. Örneğin:

    d = datetime.date(2020, 12, 23)
    t = datetime.time(13, 56, 34)

    dt = datetime.datetime.combine(d, t)
#------------------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2020, 12, 23)
t = datetime.time(13, 56, 34)

dt = datetime.datetime.combine(d, t)
print(dt)     # 2020-12-23 13:56:34

#------------------------------------------------------------------------------------------------------------------------------------
    datetime sınıfının diğer metotları için "Python Standard Library" dokğmantasyonuna başvurabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   datetime modülü dışında tarih ve zaman işlemleriyle ilgili diğer bir modülde calander isimli modüldür. calendar modülündeki isleap 
   isimli fonksiyon belli bir yılın artık olup olmadığını anlamakta kullanılır.   
#------------------------------------------------------------------------------------------------------------------------------------

def isleap(year):
    return year % 4 == 0 and year % 100 != 0 or year % 400 == 0

print('Artık yıl' if isleap(2020) else 'Artık yıl değil')

import calendar

print('Artık yıl' if calendar.isleap(2020) else 'Artık yıl değil')

#------------------------------------------------------------------------------------------------------------------------------------
    calendar modülündeki TextCalendar isimli sınıfın prmonth isimli metodu belli bir yılın ayının takvimini ekrana basar. Metodun yıl 
    ve ay dışında boşluk miktarlarına ilişkin iki parametresi daha vardır. 
#------------------------------------------------------------------------------------------------------------------------------------

import calendar

tc = calendar.TextCalendar()
tc.prmonth(2021, 9)

#------------------------------------------------------------------------------------------------------------------------------------
    TextCalendar sınıfının formatmonth isimli metodu prmonth gibi yılın belli bir ayının takvimini çıkartır. Ancak bunu ekrana basmaz 
    da yazı olarak (str nesnesi oalrak) verir.
#------------------------------------------------------------------------------------------------------------------------------------

import calendar

tc = calendar.TextCalendar()
s = tc.formatmonth(2021, 9)
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
   TextCalendar sınfının pryear metodu yılın tüm aylarının takvimini ekrana basar, formatyear metodu ise bunu yazı olarak (str nesnesi 
   olarak) verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import calendar

tc = calendar.TextCalendar()
tc.pryear(2021)
s = tc.formatyear(2021)
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Calendar modülünün içerisindeki sınıfların burada ele almadığımız başka metotları da vardır. Bunları "Python Standard Library" 
    dokümanlarından inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Düzenli ifadeler (regular expressions) bir yazı içerisinde belli bir kalıbın bulunması için kullanılan küçük bir dildir. Düzenli 
    ifadeler sayesinde örneğin biz bir yazı içerisindeki gg/aa/yyyy gibi bir kalıba uyan tüm tarihleri elde edebiliriz. Ya da örneğin 
    biz 192.168.2.3 gibi bir formatta bulunan tüm IP adreslerini elde edebiliriz. 

    Pek çok programlama dilinin standart kütüphanesinde düzenli ifadeler için sınıflar bulunmaktadır. Bazı dillerde ise düzenli ifadeler
    dilin sentaks yapısı içerisinde (built-in biçimde) bulunmaktadır. Yani bu dillerde yorumlayıcılar zaten düzenli ifadeleri sentaktik 
    bir öğe olarak tanımaktadır. Python'da düzenli ifadeler için re isiminde bir modül bulundurulmuştur. 

    Çeşitli kurumlar ve proje grupları tarafından düzenli ifade işlemlerini yapan aşağı seviyeli kütüphaneler oluşturulmuştur. Bunlara 
    "düzenli ifade motorları (regular expression engines)" denilmektedir. Düzenli ifadelerin belli bir standardı yoktur. Ancak pek 
    çok düzenli ifade motoru birbiriyle belli bir düzeyde uyumludur. Düzenli ifadelerin bir dil olduüunu belirtmiştik. Dolayısıyla 
    düzenli ifadelerde kalıpları ifade etmenin bir sentaksı vardır. Python'daki düzenli ifadelere ilişkin gramer "Python Standard 
    Library" dokümanlarında açıklanmıştır:

    https://docs.python.org/3/library/re.html

    Düzenli ifadeler ile ilgili denemeler yapmak için https://regex101.com/ sitesinden faydalanabilirsiniz. 

    Eskiden text editörlerin ve kelime işlem programlarının düzenli ifade arama özellikleri yoktu. Zamanla bu özellikler pek çok text 
    editöre ve kelime işlem programına eklendi. Bugün Microsoft Word gibi kelime işlemciler, VisualStudio, VSCode gibi IDE'ler ve 
    editörler düzenli ifadelerin kullanılmasına olanak sağlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                3. Ders 02/03/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Düzenli ifadelere ilişkin kalıp oluşturma kuralları özet olarak şöyledir. (Örneklerimizde iki tırnak içerisindeki kalıplar bir Python 
    string'i olarak değerlendirilmemelidir. Yani örneğin biz "ka\." biçiminde bir kalıp yazdığımızda buradaki ters bölü gerçekten ters 
    bölü karakteridir. Bilindiği gibi Python'da ters bölü karakterlerinin gerçek ters bölü karakteri olarak ele alınması için string'e 
    yapışık r ya da R harfi getirilmektedir.)

    - Kalıp oluştururken kullanılan karakterler ikiye ayrılmaktadır: Normal karakterler ve meta karakterler. Meta karakterler özel anlama 
    gelen karakterlerdir. Dolayısıyla düzenli ifadeler büyük ölçüde meta karakterlerin kullanımı ile ilgilidir. 

    - Nokta bir meta karakterdir \n (new line) dışındaki herhangi bir karakter anlamına gelir. Örneğin "al." kalıbı "al" ile başlayan 
    ve üçüncü karakteri herhangi bir karakter olan üç karakteri belirtir. Dolayısıyla "al." kalıbı "ali" ile de uyuşabilir "alm" ile 
    de uyuşabilir, "alr" ile de uyuşabilir. (Burada uyuşmak İnglizce "match" sözcüğünün karşılığı olarak kullanılmaktadır.)

    - * meta karakteri "solundaki karakterden sıfır tane ya da daha fazla" anlamına gelmektedir. Bu durumda örneğin "ka*" kalıbı "k" 
    ile, "ka" ile, "kaa" ile, "kaaa" ile "kaaaaa" ile uyuşur. Örneğin "k.*" kalıbı başı "k" ile başlayan satır sonuna kadar tüm karakterle 
    uyuşur. Nokta meta karakterinin \n karakterini içermediğine dikkat ediniz. Bu durumda "k.*" kalıbı satır sonunda etkisini kaybedecektir. 

    - + meta karakteri "solundaki karakterden bir ya da daha fazlasını" belirtir. * ile + meta karakterlerini birbirine karıştırmayınız. 
    * solundaki karakterden sıfır tane ya da çok tane ile uyuşurken, + solundaki karakterden bir tane ya da çok taneyle uyuşmaktadır. 
    Örneğin "ka+" kalıbı "k" ile uyuşmaz. Ancak "ka" ile "kaaaa" ile uyuşur. Fakat "ka*" kalıbı "k" ile "ka" ile "kaaaa" ile uyuşur.

    - ? meta karakteri "solundaki karakterden 0 tane ya da 1 tane" anlamına gelmektedir. Örneğin "ka?" kalıbı "ka" ile uyuşur "k" ile 
    de uyuşur. 
    
    - Bir meta karakter normal karakter olarak kullanılacaksa ters bölülenmelidir. Örneğin "ka\." gibi bir kalıp "ka." ile uyuşur. 
    "kal" ile "kar" ile uyuşmaz. Tabii ters bölünün kendisi için de \\ kullanılmalıdır. Eğer \ karakterinin sağındaki karakter özel
    bir ters bölü karekteri değilse ve bir meta karakter değilse ifade geçersizdir. 

    - Köşeli parantezler, "içerisindeki karakterlerin herhangi biri" anlamına gelir. Örneğin "[abc]+" kalıbı "abcaaaabc" ile ya da 
    "aaaabbbbbcccbcbcbca" ile uyşur. "a[bcd]?" kalıbı "a" ile "ab" ile "ac" ile "ad" ile uyuşur.

    - Köşeli parantez içerisinde '-' karakteri kullanılırsa "solundaki karakterden sağındaki karaktere kadar herhangi biri" 
    anlamına gelir. Örneğin "[a-z]+" kalıbı "ali" ile "veli" ile "selami" ile uyuşur. Örneğin "[a-zA-Z]+" kalıbı sözcükleri bulmak 
    için kullanılabilir. Ancak default durumda Türkçe karakter bulunamayacaktır. Lokal spesifik davranış fonksiyonların flags parametresi 
    ile ayarlanabilmektedir. Normal olarak "-" karakteri bir meta karakter değildir. Ancak köşeli parantezler içerisindeki "-" karakteri
    meta karakter olarak ele alınmaktadır. (Bir istisna olarak köşeli parantezler içerisinde - karakteri son karakter olarak bulunuyorsa
    meta karakter olarak ele alınmamaktadır.) Tabii köşeli parantezler meta karakter olduğu için gerçekten köşeli parantezleri arayacaksak 
    ters bölülemek gerekir. Örneğin amacımız köşeli parantezlerin içindekileri köşeli parantezlerle aramak ise "\[.*\]" kalıbını 
    kullanabiliriz. 

    - Köşeli parantezin başında ^ karakteri varsa bu durum "köşeli parantezin içerisinde olmayan herhangi bir karakter anlamına gelir.

    - Düzenli ifadelerde uyum sağlayan en uzun karakter kümesi elde edilmektedir. Örneğin "abcabxyz" gibi bir yazıda "[abc]+" kalıbı
    "abc" ve "ab" ile uyuşacaktır.  

    - Küme parantezleri dört biçimde kullanılabilir: {n}, {n,k} ve {n,}, {, n}. {n} kalıbı "solundaki karakterden tam olarak n tane" 
    anlamına gelmektedir. Örneğin "a{3}" "aaa" ile uyuşur. Eğer yazıda "aaaaaaaa" biçiminde a varsa bu durumda bunun ilk 3 tanesi ile 
    uyuşum sağlayacaktır. {n,k} kalıbı "solundaki karakterden n ile k arasında herhangi tane (n ve k dahil)" anlamına gelmektedir. 
    Örneğin "a{3,5}" kalıbı "aaa" ile uyuşur, "aaaa" ile uyuşur, "aaaaa" ile uyuşur. Ancak örneğin "aa" ile uyuşmaz. "aaaaaaaaaa" daki 
    ilk 5 a ile uyuşur. {n,} kalıbı "solundaki karakterden en az n tane" anlamına gelmektedir. {,n} kalıbı ise "solundaki karakterden 
    en fazla n tane" anlamına gelmektedir. Örneğin "a{,5}" kalıbı "en fazla 5 tane a ile uyuşum sağlar. Bu durumda 0 tane a ile de 
    uyuşum sağlanır. Normal olarak küme parantezlerinin içinde boşluk karakterleri bir soruna yol açmamaktadır. Yani örneğin "a{3,5}"
    kalıbını "a{3, 5}" biçiminde yazsak da bir sorun oluşmaz. Ancak siz küme parantezlerinin içerisinde SPACE karakteri kullanmayınız. 

    - ^ meta karakteri "yalnızca yazının başını" dikkate alır. Örneğin "^a+" kalıbı yazının başındaki a'larla uyuşur. Örneğin "^[0-9]+" 
    kalıbı yazının başındaki sayıları bulmaktadır. 

    - $ meta karakteri yazının sonunu temsil etmektedir. Örneğin "abc$" kalıbı yazının sonundaki "abc" ile uyuşur. Örneğin "[0-9]+$" 
    kalıbı yazının sonundaki sayıları bulur. 

    - \w meta karakterleri "herhangi bir alfabetik, nümerik ya da _ karakteri" anlamına gelmektedir. Default durumda bu kalıp 
    "[a-zA-Z_0-9]" anlammına gelmektedir. Yani Türkçe karakterler kalıba dahil değildir. Ancak pek çok regex kütüphanesinde bir 
    lokal ayarı yapılabilmektedir. Eğer regex ortamı izin veriyorsa bu ayar yapılarak bu kalıba Türkçe karakterler de dahil edilebilir. 
    Tabii Türkçe karakterleri dahil edecek biçimde kalıp manuel olarak [\wşçğüöıŞÇĞÜÖİ] biçiminde de oluşturulabilir. Düzenli ifade 
    motorlarının "UNICODE" seçeneği de bulunabilmektedir. Bu seçenek aktif hale getirildiğinde artık \w meta karakteri UNICCODE 
    tablodaki tüm alfabetik karakterleri kapsar hale gelmektedir. Yani UNICODE ayarı adeta "tüm lokalleri içerir" anlamına gelmektedir. 
    "\w+" kalıbı sözcükleri bulmak için sık sık kullanılan bir kalıptır. \W meta karakterleri ise "herhangi bir alfabetik, nümerik 
    karakter ya da _ karakterinin dışındaki karakter" anlamına gelir. Yani \w meta karakterinin tersini belirtir. 
    
    - \s meta karakterleri "herhangi bir boşluk karakteri (white space)" anlamına gelmektedir. Benzer biçimde \S meta karakterleri 
    ise "herhangi bir boşluk karakteri dışındaki karakter" anlamına gelir. 

    - \d meta karakterleri "sayısal karakterlerden herhangi birisi" \D kalıbı ise "sayısal karakter olmayan herhangi bir karakter" 
    anlamına gelmektedir. Örneğin "\d+" kalıbı ile sayıları bulabiliriz. O halde örneğin "[\-+]?\d+" kalıbı tamsayıları bulabilir. 
    Nokatalı sayıları da bulabilen kalıp "[\-+]?\d*\.?\d+" bçiminde olabilir. 

    - \b meta karakteri "sözcük başları" anlamına gelmektedir. Örneğin "\ba+" gibi bir kalıp "a" ile başlayan sözcüklerle uyuşur.

    - Parantezler gruplama için kullanılmaktadır. Örneğin "(abc)+" kalıbı ile "ab"c uyuşur, "abcabc" uyuşur, "abcabcabc" uyuşur.

    - '|' karakteri "veya" anlamına gelmektedir. Örneğin "ali|veli" kalıbı "ali" ya da "veli" ile uyuşabilmektedir. Örneğin 
#------------------------------------------------------------------------------------------------------------------------------------
                                                
#------------------------------------------------------------------------------------------------------------------------------------
    Tipik bazı kalıplar aşağıda verilmiştir:

    E-Posta kalıbı: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}"
    Noktalı sayı kalıbı: [+-]?[0-9]+\.[0-9]+|\.[0-9]+|[0-9]+\.
    Tamsayı kalıbı: [+-]?[0-9]+
    Değişken atom kalıbı: [_a-z-A-Z][_a-zA-Z-0-9]+
    day/month/year tarih kalıbı: (0?[1-9]|1[0-2])\/(0?[1-9]|1\d|2\d|3[01])\/(19|20)\d{2}
    dd/mm/yyy tarih kalıbı: (0[1-9]|1\d|2\d|3[01])\/(0[1-9]|1[0-2])\/(19|20)\d{2}
    IP adresi kalıbı: ([0-9]{1,3}\.){3}[0-9]{1,3}
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Her türlü ayrıştırma işlemi düzenli ifadelerle yapılamayabilir. Bu tür durumlarda belli noktaya kadar düzenl ifadeleri kullanıp 
    sonra manuel kontrollerle hedefe ulaşılabilir. Örneğin bir programlama dilindeki programı atomlarına ayırmak düzenli ifadeler
    yeterli olamayabilmektedir. Yani düzenli ifadeler bizim ayrıştırma ve bulma işlemlerimizde tüm isteklerimizi yerine getiremeyebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da düzenli ifadelerle işlemler re modülündeki fonksiyonlar ve sınıflarla yapılmaktadır. re modülündeki fonksiyonlar genel 
    olarak önce kalıp yazısını sonra da asıl yazıyı parametre olarak alırlar. Yine modüldeki fonksiyonların son paramatreleri düzenli 
    ifadeler üzerindeki bazı seçenekleri belirtmektedir. Bu paramtre flags olarak isimlendirilmiştir. Programcının kalıp yazısını 
    oluşturken string'i "r" ya da "R" öneki ile oluşturması "\" karakterlerinin gerçekten ters bölü karakteri olarak ele alınmasını 
    garanti edecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    re modülündeki findall isimli fonksiyonu yazıdaki regex kalıbına uyan tüm parçaları bir liste olarak bize verir. findall fonksiyonun 
    parametrik yapısı şöyledir:

    findall(pattern, string, flags=0)

    Örneğin:

    text = '17 asal bir sayıdır. 101 de asaldır. Ancak 115 asal değildir.'
    pattern = r'\d+'
    result = re.findall(pattern, text)
    print(result)

    Burada görüldüğü gibi findall fonksiyonuna önce kalıp yazısı sonra da asıl yazı argüman olarak geçirilmiştir. flags parametresi 
    default değer aldığı için hiç kullanılmamıştır.

    findall fonksiyonu parantezli grupları da ayırıp onları birer demet olarak da vermektedir. İzleyen paragraflarda gruplama konusu 
    üzerinde de duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli 123 selami 628 ayşe fatma 876'
pattern = r'\d+'

result = re.findall(pattern, text)      
print(result)           # ['123', '628', '876']

numbers = list(map(int, result))
print(numbers)          # [123, 628, 876]

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıda findall fonksiyonu ile tarihlerin elde edilmesine yönelik bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli 10/12/2009 selami 05/07/1998 ayşe fatma 23/11/2014'
pattern = r'\d\d/\d\d/\d\d\d\d'

result = re.findall(pattern, text)
print(result)       # ['10/12/2009', '05/07/1998', '23/11/2014']

#------------------------------------------------------------------------------------------------------------------------------------
    str sınıfının split metodu pek çok ayrıştırma işlemi için yetersiz kalmaktadır. Örneğin:

    text = 'ali,    veli, selami,         fatma'

    biçiminde bir yazıdaki isimleri split ile tek hamlede elde edemeyiz. Çünkü split metodu ayıraç olarak tek bir yazı almaktadır. 
    Eğer biz burada text.split(', ') çağrısıyla ayrıştırma yapmak istersek bazı isimlerin başında boşluk karakterleri de bulunur. 
    Burada düzenli ifadeler basit bir biçimde istediğimizi yapmamıza olanak sağlayabilmektedir. Örneğin:

    text = 'ali, veli,,    selami   , ayşe ,    fatma'
    pattern = '\w+'
    result = re.findall(pattern, text)   
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali, veli,,    selami   , ayşe ,    fatma'
pattern = '\w+'

result = re.findall(pattern, text)
print(result)       # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıda findall fonksiyonu ile bir yazıdaki e-posta adreslerinin bulunmasına örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = """bana e-posta atabilrsin. E-posta adresim aslank@csystem.org. 
Eğer bana ulaşamazsan info@csystem.org'ye de e-posta gönderebilirsin.'
"""
pattern = r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}'

result = re.findall(pattern, text)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
   re modülündeki split fonksiyonu str sınıfının split metodundan çok daha güçlü bir biçimde ayrıştırma yapabilmektedir. Bu fonksiyon 
   Bir regex kalıbını ayıraç olarak kabul ederek yazıyı parçalarına ayırır. split fonksiyonunda verilen kalıp ayıraçların kalıbıdır. 
   Fonksiyon bu ayıraçları diğer yazının parçalarını ayırmak için kullanacaktır. Fonksiyonun parametrik yapısı şöyledir:

   split(pattern, string, maxsplit=0, flags=0)

   split fonksiyonu her kalıba uygun ayıracı bulduğunda onun solundaki ve sağındaki yazı parçasını elde eder. Eğer yazının başında
   ve sonunda ayıraç kalıbı varsa bu ayıraç kalıbının solunda ve sağında bir yazı olmadığı için boş string verilecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali,    veli,    selami,ayşe'
pattern = r', *'

result = re.split(pattern, text)
print(result)       # ['ali', 'veli', 'selami', 'ayşe']

#------------------------------------------------------------------------------------------------------------------------------------
                                            4. Ders 08/03/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    str sınıfının split metodu tek bir ayrıça kabul ettiği için çok basit ayrımaları yapabilmektedir. Örneğin:

    text = 'ali-veli,selami-ayşe,fatma'

    Burada isimler bazen '-' ile bazen de ',' ile ayrılmıştır. Bu ayrmayı biz str sınıfının split metoduyla yapamayız. Ancak re 
    modülündeki split ile yapabiliriz:

    text = 'ali-veli,selami-ayşe,fatma'
    pattern = r'-|, '

    result = re.split(pattern, text)
    print(result)

    Burada önemli bir noktaya dikkat ediniz. Bir ayıraç bulunduğunda ondan sonra başka bir ayırç gelirse sani iki ayıraç arasında 
    bir yazı olması gerekiyormuş da bulunamamış gibi bir durum oluşur. Bu da boş string'lerin oluşmasına yol açar. Örneğin:

    text = 'ali-veli, selami-ayşe, fatma'
    pattern = r'[-, ]'
    result = re.split(pattern, text)
    print(result)

    Burada kalıp '-', ',' ve ' ' karakterlerinin herhangi birisidir. Dolayısıyla ',' karakter bulunduğunda ondan hemen sonra ' ' 
    karakteri geldiği için arada sanki bir şey yokmu gibi bir durum oluşacaktır. Burada elde edilen liste de şöyle olacaktır:

    ['ali', 'veli', '', 'selami', 'ayşe', '', 'fatma']

    Şimdi aşağıdaki kalıba dikkat ediniz:

    pattern = r'-|, '

    Burada kalıp '-' karakteri ya da ', ' karakteri biçimindedir. Tabi biz aşağıdaki gibi de bir kalığ oluşurabilirdik:

    pattern = '[\- ,]+'

    Bu durumda -, boşluk ve virgül yan yana ne kadar çok gelirse gelsin ayıraç olarak ele alınırdı.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örnekte sayılar arasındaki isimler ayrıştırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali21761veli123123selami987987ayşe9989898fatma'
pattern = '\d+'

result = re.split(pattern, text)
print(result)       # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------------------
    re modülündeki split fonksiyonunda yazının başında ya da sonunda ayıraç bulunursa boş string oluşurulmaktadır. Örneğin:

    text = '   ,,ali,,,  veli,,   selami   '
    pattern = "[ ,]+"
    result = re.split(pattern, text)
    print(result)

    Burada yazının başı ayırçlarla başlamıştır. O halde yazının başında bir tane boş string bulunacaktır. Yazının sonu da ayırçlarla
    bitmiştir o halde yazının sonunda da boş string bulunacaktır. Bu kod parçası çalıştırıldığında ekrana şunlar basılacaktır:

    ['', 'ali', 'veli', 'selami', '']
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıda re.split fonksiyonun kullanımına başka bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali+-veli-+selami--ayşe'
pattern = '[\-+]+'

result = re.split(pattern, text)
print(result)       # ['ali', 'veli', 'selami', 'ayşe']

#------------------------------------------------------------------------------------------------------------------------------------
    re modülündeki search fonksiyonu yazı içerisinde bir regex kalıbını arar. Eğer bulursa ilk bulduğu kalıba ilişkin re modülündeki 
    Match türünden bir sınıf nesnesiyle geri döner. Fonksiyonun parametrik yapısı şöyldir:

    re.search(pattern, string, flags=0)

    Yine fonksiyonun birinci parametresi aranacak kalıbı, ikinci parametresi aramanın yapılacağı yazıyı belirtmektedir. Fonksiyon başarı 
    durumunda bir Match nesnesine başarısızlık durumunda None değerine geri dönmektedir. 

    Match sınıfının start netodu kalıbın bulunduğu karakterin başlangıç index numarasını end metodu ise bitiş index numarasından bir 
    fazlasını verir. Böylece biz dilimleme yoluyla bulunan kalıbı elde edebiliriz. Örneğin:

    text = ',,,ali, veli, selami'
    pattern = r'\w+'
    m = re.search(pattern, text)

    Burada aslında yazı içerisindeki "ali" karakterleri uyuşum sağlamaktadır. Ancak search bize "ali" yazısını değil bir Match nesnesi 
    vermektedir. Bu match nesnesinin start metodu kalıbınyazı içerisindeki başlangıç index numarasını end metodu bitiş indeks numarasından 
    bir sonrak indeks numarasını verir. Dolayısıyla biz bu aralığı dilimlemede kullanabiliriz. Örneğin:

    if m:
        print(m.start(), m.end())
        print(text[m.start():m.end()])
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'my email addres is aslank@csystem.org but your email address is serce@gmail.com'
pattern = r'[a-zA-Z0–9+_.-]+@[a-zA-Z0–9.-]+'

m = re.search(pattern, text)
if m:
    result = text[m.start():m.end()]
    print(result)
else:
    print('cannot find match!..')
  
#------------------------------------------------------------------------------------------------------------------------------------
    Bir kalıp parantezler kullanılarak oluşturulmuşsa kalıbın içerisindeki parantezli kısımlara grup denilmektedir. search fonksiyonu
    yalnızca ana kalıbı değil parantezler içeirsindeki parçalar olan grup'ları da bulabilmektdir. Örneğin şöyle bir kalıp olsun: "(\d+)@(\d+)".
    123@456 gibi karakter öbeği bu kalıp ile uyuşmaktadır. İşte biz Match nesnesi ile uyuşan kısmı bir bütün olarak elde edebilceğimiz gibi 
    bunun 123 ve 456'dan oluşan gruplarını da elde edebilmekteyiz. 
    
    Match sınıfının group metodu regex kalıbındaki grupları bize vermektedir. group metodu grubun numarasını parametre olarak alır. 
    Group numaraları 1'den başlamaktadır. 0'ıncı grup numarası kalıbın tamamını belirtir. group metodu ile Match sınıfının [] operatör 
    metodu aynı işlemi yapmaktadır. Örneğin:

    text = 'ali 123@567 veli 135@854 selami'
    pattern = r'(\d+)@(\d+)'
    m = re.search(pattern, text)

    Buradaki kalıp sayı@sayı biçimindeki karakterle uyuşur. Ancak bu kalıpta @ karakterinin iki yanı birer grup biçiminde oluşturulmuştur. 
    Bu sayede biz hem uyuşan kalıbın tamamını elde edebiliriz hem de onun parçalarını elde edebiliriz. Buradaki örnekte search ilk 
    uyuşan kalıbı yani 123@567 karakterini bulacaktır. Bize bunu bir Match nesnesi biçiminde verecektir. Bu Match nesnesinin 1'inci 
    grubu 123 yazısından 2'inci grubu 567 yazısından oluşacaktır. İşte biz m[1] ya da m.group(1) ifadeseiyle 1'inci grubu m[2] ya da 
    m.group(2) ifadseiyle de 2'inci grubu elde edebiliriz. m[0] ya da m.group(0) ifadesi ile de biz tüm kalıba erişebiliriz. İster 
    gruplu bir kalıp olsun isterse grupsuz bi rkalıp olsun m[0] her zaman uyuşan kalıbı vermektedir. Match sınıfının string örnek 
    özniteliği bize search fonksiyonun çağrılmasında kullanılan asıl yazıyı da vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli selami 123@789 ayşe fatma'
m = r'(\d+)@(\d+)'

result = re.search(pattern, text)
if result:
    print(m[0])
    print(m[1])
    print(m[2])
else:
    print('kalıp bulunamadı!..')

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında daha önce görmüş olduğumuz findall metodu da grupla çalışmaktadır. Eğer kalıpta parantezler varsa findall bu grupları 
    bir demet listesi olarak bize vermektedir. Örneğin:

    text = 'ali veli selami 123@789 ayşe fatma 478@456'
    pattern = r'(\d+)@(\d+)'

    result = re.findall(pattern, text)
    print(result)       # [('123', '789'), ('478', '456')]

    Ancak kalıpta tek bir grup varsa findall bize bunları tek elemanlı demet listesi olarak değil düz bir liste olarak vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli selami 123@789 ayşe fatma 478@456'
pattern = r'(\d+)@(\d+)'

result = re.findall(pattern, text)
if result:
    print(result)       # [('123', '789'), ('478', '456')]
else:
    print('kalıp bulunamadı!..')

#------------------------------------------------------------------------------------------------------------------------------------
    Gruplama hem bir kalıbın bulunmasına hem de o kalıp içerisindeki bir parçanın elde edilmesine yol açacaktır. Örneğin birisi bize
    yazı içerisindeki tek tırnak içerisinde bulunan isimleri elde etmemizi istesin. Yazı aşağıdaki gibi olsun:

    text = "ali veli 'selami' ayşe 'fatma' hasan"

    Burada bizden tüm isimlerin değil 'selami' ve 'fatma' isimlerinin ulunması istenmiştir. Kalıbı aşağıdaki oluşturmuş olalım:

    pattern = r"'\w+'"

    Bu kalıpla biz tek tırnak içerisindeki isimleri tek tırnaklarıyla buluruz. Halbuki bizden tek tırnak içerisindeki isimlerin 
    tırnaksız bir biçimde bulunması istenmiştir. Tabii biz bu isimleri tırnaklı bulduktan sonra bu trınakları atabiliriz. Ancak bu 
    da ek bir çaba gerektirir. İşte bu durumda gruplama pratik çözüm oluşturmaktadır. Örneğin:

    pattern = r"'(\w+)'"
    result = re.findall(pattern, text)
    print(result)       # ['selami', 'fatma']
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Klavyeden (stdin dosyasından) bir sayı okumak isteyelim. Ancak sayı geçersiz girilmişse hatayı belirtip yeniden girilmesini 
    isteyelim. Ta ki doğru girilene kadar. Bunu nasıl yapabiliriz? Aslında biz buu Python kursunda exception mekanizmasından faydalanarak
    yapmıştık. int fonksiyonu eğer dönüştürmeyi yapamazsa exception fırlatıyordu. Biz de exception'ı ele alarak sayının yeniden 
    girilmesini istiyorduk. Örneğin:

    while True:
        try:
            val = int(input('Bir sayı giriniz:'))
            break
        except:
            print('geçersiz sayı!..')     
    print(val * val)

    Bu işlemi regex kullanarak da yapabiliriz:
    
    while True:
        text = input('Bir sayı giriniz:')
        m = re.search(r'^\d+', text)
        if m:
            break
        else:
            print('invalid number!..')
            
        val = int(text[m.start():m.end()])
        print(val * val)
    
    Aslında regex mekanizması exception mekanizmasından daha hızlıdır. Ancak Python'da bu tür hızlandırmaların çoğunlukla önemi yoktur. 
    Dil genel olarak zaten yavaştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    re modülündeki match fonksiyonu search fonksiyonu gibidir. Yani yine aranan kalıba ilişkin Match nesnesini verir. Ancak kalıbın 
    yazının başında olması gerekir. Yani bu fonksiyon her zaman kalıp sanki yazının başındaymış gibi arama yapar. Aşağıdaki örnekte 
    uyuşum sağlanamayacaktır.

    text = 'ali veli selami 123@789 ayşe fatma 478@456'
    pattern = r'(\d+)@(\d+)'

    m = re.match(pattern, text)
    print(m)    # None

    Tabii aslında yazının başında aramayı sağlamak için kalıbın başına da ^ meta karakteri getirilebilir. ^ meta karakterinin zaten 
    yazının başından itibaren uyuşama bakacağını daha önce belirtmiştik.
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli selami 123@789 ayşe fatma 478@456'
pattern = r'(\d+)@(\d+)'

result = re.match(pattern, text)
if result:
    print(result[0])
else:
    print('kalıp bulunamadı!..')

#------------------------------------------------------------------------------------------------------------------------------------
   re modülündeki fullmatch fonksiyonu yazının tamamının kalıba uygun olmadığını belirlemekte kullanılır. Bu fonksiyon da başarı
   durumunda Match nesnesine, başarısızlık durumunda None değerine geri dönmektedir. Fonksiyonun parametrik yapısı diğerleriyle aynıdır:

   re.fullmatch(pattern, string, flags=0)
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = '10/12/1997'
pattern = r'\d\d/\d\d/\d\d\d\d'

a = re.fullmatch(pattern, text)
if a:
    print('Uyuşum var')
else:
    print('Uyuşum yok')

text = '10/12/1997   '

a = re.fullmatch(pattern, text)
if a:
    print('Kalıba uygun')
else:
    print('Uyuşum yok')

#------------------------------------------------------------------------------------------------------------------------------------
    Düzenli ifadeler çeşitli girdilerin belirlenen sentaksa uygunluğunun kontrol edilmesi için sıklıkla kullanılmaktadır. Örneğin 
    kullanıcıdan bir e-posta adresi girmesi istenebilir. Kişinin girdiği yazının geçerli bir e-posta adresi olup olmadığı düzenli 
    ifadedelerle sınanabilir. Bu tür durumlarda fullmatch fonksiyonu tercih edilmektedir. Girilen yazıyı fullmatch fonksiyonuna 
    sokmadan önce baştaki ve sondaki boşluk karakterlerini de str sınıfının splitmetoduyla atabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

pattern = r'[a-zA-Z0–9+_.-]+@[a-zA-Z0–9.-]+'

email = input('Bir e-posta adresi giriniz:').strip()
if re.fullmatch(pattern, email):
    print('işlemler yapılıyor')
else:
    print('geçersiz bir e-posta adresi')

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir yazının float bir sayı formatına uygun olup olmadığı test edilmeye çalışılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import re

pattern = r'([\+\-]?\d+\.?\d*|\.\d+)([eE]\d+)?'

s = input('Yazı giriniz:')
m = re.fullmatch(pattern, s)
if m:
    print('float formatına uygun')
else:
    print('float formatına uygun değil')

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii her türlü sınama (validation) işlemi düzenli ifadelerle yapılamaz. Pek çok sınama işlemi düzenli ifadelerle yapılabiliyorsa 
    da oluşturulan kalıp çok karmaşık olabilmektedir. Bu tür durumlarda programcılar basit bir kalıpla temel sınamayı yapıp sonra daha 
    ayrıntılı sınamayı kodla yapabilirler. Örneğin klavyeden girilen bir tarihin geçerli bir tarih olup olmadığının sınanması tek bir 
    düzenli ifadeyle yapılamaz. Çünkü 20/02/2009 gibi bir tarihin sentaksı düzgündür ama bu tarih 2009 yılı artık olmadığı için geçerli
    değildir. Bu tür durumlarda temel sentaks düzenli ifadelerle kontrol edilebilir. Diğer ayrıntılı kontroller ise manuel biçimde kodla 
    yapılabilir. 
    
    Aşağıdaki örnekte bir tarih bilgisinin temel sentaksı düzenli ifadelerle sınanmış, geri kalan sınama da bu amaçla yazılmış başka 
    bir fonksiyonla yapılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import re
import datetime

def validate_date(day, month, year):
    try:
        datetime.date(year, month, day)
        return True
    except:
        return False 

pattern = r'(\d\d)/([01][0-9])/(\d\d\d\d)'

email = input('Lütfen gg/aa/yyyy biçiminde bir tarih giriniz:').strip()
if m := re.fullmatch(pattern, email):
    if validate_date(int(m[1]), int(m[2]), int(m[3])):
        print('geçerli tarih')
    else:
        print('geçersiz bir tarih')
else:
    print('geçersiz bir tarih')

#------------------------------------------------------------------------------------------------------------------------------------
                                            5. Ders 09/03/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    finditer fonksiyonu bir iterator nesnesi verir. Bu iterator nesnesi dolaşıldıkça bulunan kalıplara ilişkin Match nesneleri elde 
    edilmektedir. iterator yoluyla dolaşma kalıba uygun çok sayıda öğenin bulunduğu durumda yer ve zaman bakımından avantaj sağlayabilmektedir. 
    Örneğin çok büyük metnin içerisinde kalıpları buldukça bir işlem yapacak olun. Baştan tüm kalıpların bulunması kullanıyı rahatsız edecek
    derecede gecikme oluşturabilir. Aynı zamanda tüm kalıpların saklanması da önemli bir alanın tahsis edilmesini gerektirecektir. 
    Kalıpları buldukça onlar üzerinde işlem yapmak bu tür durumlarda daha etkindir. finditer fonksiyonun parametrik yapısı benzerdir:

    re.finditer(pattern, string, flags=0)
    
    Örneğin:

    text = 'ali -veli-, selami -ayşe- fatma -hayri- sibel -hasan-'
    pattern = r'-(\w+)-'

    for m in re.finditer(pattern, text):
        print(m[1])
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli selami 123@789 ayşe fatma 7890@112234 süreyya'
pattern = r'(\d+)@(\d+)'

for m in re.finditer(pattern, text):
    print(m[0], m[1], m[2])    
      
#------------------------------------------------------------------------------------------------------------------------------------
   re modğlğndeki sub fonksiyonu belli bir kalıbın yerine başka bir yazı yerleştirmek için kullanılmaktadır. Bu fonksiyon string 
   sınıfının replace metodunun düzenli ifade alan versiyonu gibi düşünülebilir. Fonksiyonun parametrik yapısı şöyledir:

   re.sub(pattern, repl, string, count=0, flags=0)

   Buradaki count parametresi kaç uyuşumun değiştirileceğini belirtmektedir. 0 değeri herpsinin değiştirileceği anlamına gelmektedir. 
   Tabii fonksiyon asıl yazıda bir değişiklik yapmaz. Bize değiştirilmiş yeni bir yazıyı vermektedir. Örneğin:

    text = 'ali -veli-, selami -ayşe- fatma -hayri- sibel -hasan-'
    pattern = r'-(\w+)-'

    result = re.sub(pattern, 'xxx', text)
    print(result)               # ali xxx, selami xxx fatma xxx sibel xxx

    Burada tireler arasındaki isimler xxx karakterleri ile yer değiştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli 12/11/1990 selami 03/05/2009 ayşe 07/11/1997 fatma'
pattern = r'\d\d/\d\d/\d\d\d\d'

result = re.sub(pattern, '----------', text)
print(result)  

#------------------------------------------------------------------------------------------------------------------------------------
    sub fonksiyonun count parametresi ilk n tane bulunan kalıp için yer değiştirme sağlamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali veli 12/11/1990 selami 03/05/2009 ayşe 07/11/1997 fatma'
pattern = r'\d\d/\d\d/\d\d\d\d'

result = re.sub(pattern, '----------', text, 2)
print(result)    

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz bir kalıbı başka bir kalıpla nasıl yer değiştirebiliriz. Örneğin tireler arasındaki isimleri yine tireler arasında 
    fakat ters yüz ederek yer değiştirmek isteeyelim. İşte bu tür işlemlerin yapılabilmesine olanak sağlamak için özel bir kullanım 
    da oluşturulmuştur. Eğer yer değiştirilecek yazı yerine çağrılabilen bir nesne girilirse kalıp bulundukça bulunan kalıbı temsil 
    eden bir Match nesnesi ile verilen fonksiyon çağrılır. Programcı bu gonksiyondan bir yazaıyla geri dönmelidir. Bu yazı değiştirilecek
    yazı olur. Örneğin:

    text = 'ali -veli-, selami -ayşe- fatma -hayri- sibel -hasan-'
    pattern = r'-(\w*)-'

    result = re.sub(pattern, lambda m: f'-{m[1][::-1]}-', text)

    Burada değiştirilecek yazı yerine lambda ifadesi girilmiştir. Bu lambda ifadesi aşağıdaki fonksiyonla eşdeğerdir:

    def lambda_func(m):
        return f'-{m[1][::-1]}-'
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ali -veli-, selami -ayşe- fatma -hayri- sibel -hasan-'
pattern = r'-(\w*)-'

result = re.sub(pattern, lambda m: f'-{m[1][::-1]}-', text)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
   re modülündeki tüm fonksiyonlarda flags isimli bir ekstra son parametre vardır. Bu flags parametresi regex araması için bazı seçenekleri 
   belirlemekte kullanılmaktadır. Örneğin bu flags parametresine re.IGNORECASE girilirse bu durumda büyük harf küçük harf duyarlılığı 
   olmadan karakter değerlendirilir. Örneğin:
   
    text = 'ali veli Ahmet, ayşe, sacit, AYLİN'
    pattern = r'\b(a\w+)'

    names = re.findall(pattern, text, re.IGNORECASE)        
    print(names)            # ['ali', 'Ahmet', 'ayşe', 'AYLİN']

    Burada başı "a" ya da "A" ile başlayan isimler bulunmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'bu bir denemedir. ANKARA-06 evet denemedir İStanbul-34 '
pattern = r'[a-z]+-\d\d'

result = re.findall(pattern, text, re.IGNORECASE)
print(result)       # ['ANKARA-06', 'İStanbul-34']

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonlardaki flags parametresi | operatörü ile birleştirilebilmektedir. Bu duurmda birden fazla flag etkili olabilmektedir. 
    Örneğin re.IGNORECASE ile re.DOTALL birlikte kullanılabilir. re.DOTALL bayrağı '.' meta karakterinin \n ile de uyuşum sağlayacağı 
    anlamına gelmektedir. Örneğin normal olarak ".+" kalıbı satır sonuna kadarki tüm karakterle uyuşur. Ancak biz bu kalıbı re.DOALL
    bayrağı ile kullanırsak "." meta karakteri artık \n ile de uyuşacağı için yazının tüm karakterleri elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'ANkara12345\n6789İZMİR'
pattern = r'ankara.*izmir'

m = re.fullmatch(pattern, text, re.IGNORECASE|re.DOTALL)
if m:
    print('uyuşum var')
else:
    print('uyuşum yok')
 
#------------------------------------------------------------------------------------------------------------------------------------
    Düzenli ifadelerle işlemler göreli biçimde yavaş işlemlerdir. İşte eğer programcı düzenli ifadelerle daha hızlı işlem yapmak isterse
    compile fonksiyonunu kullanabilir. Özellikle compile fonksiyonu aynı kalıbın birden fazla yerde kullanılacağı durumlarda bir hız 
    kazancı sağlamaktadır. Örneğin biz programımız içerisinde pek çok yerde bir e-postanın geçerliliğini test etmeye çalışıyor olabiliriz. 
    Bu durumda  compile işlemi bir hızlanma sağlayabilmektedir. compile fonksiyonun parametrik yapısı şöyledir:

    re.compile(pattern, flags=0)

    compile fonksiyonu bize re modülündeki Pattern isimli bir sınıf türünden bir nesne verir. Şimdiye kadar görmüş olduğumuz tüm regex 
    fonksiyonları aynı zamanda bu sınıfın metotları olarak da yazılmıştır. Dolayısıyla programcının yapacağı şey bu compile fonksiyonundan 
    elde ettiği nesneyi kullanarak daha önce görmüş olduğumuz fonksiyonlarla aynı isimlere sahip sınıfın metotlarını çağırmak olacaktır. 
    Tabii bu metotlarda pattern parametresi girilmez. Zaten compile edilmiş kalıp nesnenin içerisinde bulunmaktadır. Buradaki "compile" 
    teriminin programlama dillerinde kullanılan compile terimi ile bir ilgisi yoktur. compile fonksiyonu düzenli ifade kalıbını 
    daha kolay işleme sokulacak bir formata dönüştürmektedir. Örneğin:

    text = 'işte benim e-posta adresim aslan@csystem.org biçiminde ama Ali Hocanınki de ali@csystem.org biçiminde.'
    pattern = re.compile(r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}')
                     
    names = pattern.findall(text)
    print(names)            # ['aslan@csystem.org', 'ali@csystem.org']

    Burada compile metodundan bir Pattern nesnesi elde edilmiştir. Sonra bu nesne ile Pattern sınıfının findall metodu çağrılmıştır. 
    findall fonksiyonuna artık ayrıca bir kalıp yazısının verilmediğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import re

text = 'işte benim e-posta adresim aslan@csystem.org biçiminde ama Ali Hocanınki de ali@csystem.org biçiminde.'
pattern = re.compile(r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}')
                     
names = pattern.findall(text)
print(names)

m = pattern.search(text)
if m:
    print(m[0])
else:
    print('Kalıp bulunamadı!..');

#------------------------------------------------------------------------------------------------------------------------------------
    Programlamada bir programın çalışma süresinin çeşitli bakımlardan incelenmesi sürecine İngilizce "profiling" denilmektedir. 
    Bu işlemleri yapan araçlara ise "profiler" denilmektedir. İşte bir programın ya da bir program parçasının hızını tespit etmek 
    için Python Standart Kütüphanesinde "timeit" isimli bir modül bulunmaktadır. Bu modül özellikle küçük kod parçalarının çalışma 
    sürelerinin karşılaştırılması amacıyla kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    timeit modülündeki timeit isimli fonksiyon belli bir Python kod parçasının çalışma süresini kolay bir biçimde ölçmek için 
    bulundurulmuştur. Kod parçası fonksiyonun number parametresinde belirtilen sayıda art arda çalıştırılmaktadır. Bu number parametresinin 
    default değeri 1000000'dur.Fonksiyon saniye cinsinden çalışma süresini bize vermektedir. Eğer kod parçası birden fazla satırdan 
    oluşuyorsa bu durumda kod parçasının üç tırnaklı bir biçimde yazabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import timeit

result = timeit.timeit("for i in range(100000000): pass", number=1)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
                                                6. Ders 15/03/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Bir kodun çalışma süresi sistemin o anki yüküne bağlı olarak değişebilmektedir. Bu durum thread'lrin ele alındığı bölümde verilecek 
   bilgilerle daha iyi anlaşılacaktır. Ancak kodların birbirlerine göre göreli çalışma süreleri bazen daha önemli olabilmektedir. 

   Aşağıdaki örnekte bir liste içerisine 0'dan 100_000_000'a kadar sayıların kareleri yerleştirilmiştir. Bu işlem alternatif üç yöntemle 
   yapılmıştır. İlk yöntemde boş bir diziye sayıların kareleri append metoduyla eklenmiştir. İlinci yöntemde liste içlemi kullanılmıştır. 
   Üçüncü yöntemde ise map fonksiyonu kullanılmıştır. Denemenin yapıldığı bilgisayarda elde edilen sonuçlar şöyledir:
   
    Diziye eleman ekleme yoluyla: 7.447103999991668
    Liste içlemi yoluyla: 6.196832599991467
    map Fonksiyonu ile: 9.464428100007353
   
   Buradan "liste içlemlerinin" diğer alternatif yöntemlere göre daha hızlı olduğu sonucu çıkarılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import timeit

option1 = """
a = []

for i in range(100_000_000): 
    a.append(i * i)
"""

option2 = """
a = [i * i for i in range(100_000_000)]
"""

option3 = """
a = list(map(lambda i: i * i, range(100_000_000)))
"""

result = timeit.timeit(option1, number=1)
print(f'Diziye eleman ekleme yoluyla: {result}')

result = timeit.timeit(option2, number=1)
print(f'Liste içlemi yoluyla: {result}')

result = timeit.timeit(option3, number=1)
print(f'map Fonksiyonu ile: {result}')

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte 0-1-2...-98-99 biçiminde bir yazının oluşturulmasına ilişkin üç alternatif yöntem karşılaştırılmıştır.
    Elde edilen sonuçlar şmyledir:

    for döngüsü yoluyla: 13.376206700020703
    join ve map yoluyla: 9.183207199996104
    join ve liste içlemi yoluyla: 7.749387199990451
    join ve üretici ifade yoluyla: 7.744632400019327
#------------------------------------------------------------------------------------------------------------------------------------

import timeit

option1 = """
s = ''
for i in range(100):
    if i != 0:
        s += '-'
    s += str(i)
"""

result = timeit.timeit(option1)    
print(f'for döngüsü yoluyla: {result}')

option2 = """
s = '-'.join(map(str, range(100)))
"""

result = timeit.timeit(option2)    
print(f'join ve map yoluyla: {result}')

option3 = """
s = '-'.join([str(i) for i in range(100)])
"""

result = timeit.timeit(option3)    
print(f'join ve liste içlemi yoluyla: {result}')

option4 = """
s = '-'.join(str(i) for i in range(100))
"""

result = timeit.timeit(option3)    
print(f'join ve üretici ifade yoluyla: {result}')

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsayacağınız gibi Python'da Python'un çeşitli versiyonlarında formatlı yazı oluşturmak için yöntemler eklenmiştir. En eskiden 
    % operatörü ile bu işlem yapılıyordu. Sonra str sınıfına format metodu eklendi. Nihayet 3.6 ile birlikte string enterpolasyonu 
    (f'li string'ler) eklenmiştir. Pekiyi bunların hangisi daha hızlıdır. Aşağıda üç yöntemi de timeit fonksiyonu ile karşılaştırdık. 
    Çıkan sonuçlar şöyşedir:

    str.format yoluyla: 0.49234870000509545
    string enterpolasyonu yoluyla: 0.40875050000613555
    % operatör metodu yoluyla: 0.427367799973581

    Buradan en hızlı yöntemin string enterpolasyonu olduğu görülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import timeit

option1 = """
a = 10; b = 20; c = 30; d = 40; e = 50
s = 'a = {}, b = {}, c = {}, d = {}, e = {}'.format(a, b, c, d, e)
"""

result = timeit.timeit(option1)
print(f'str.format yoluyla: {result}')

option2 = """
a = 10; b = 20; c = 30; d = 40; e = 50
s = f'a = {a}, b = {b}, c = {c}, d = {d}, e = {e}'
"""

result = timeit.timeit(option2)
print(f'string enterpolasyonu yoluyla: {result}')

option3 = """
a = 10; b = 20; c = 30; d = 40; e = 50
s = 'a = %d, b = %d, c = %d, d = %d, e = %d' % (a, b, c, d, e)
"""

result = timeit.timeit(option3)
print(f'% operatör metodu yoluyla: {result}')

#------------------------------------------------------------------------------------------------------------------------------------
    timeit fonksiyonun birinci parametresiyle belirtilen kod bizim programımızdan bağımsız bir biçimde çalıştırışmaktadır. Yani bu kod 
    içerisinde biz global değişkenleri, kendi fonksiyonlarımızı kullanamyız. İşte bazen ölçülmek istenen çalışma süresi öncesinde 
    birtakım hazırlık işlemlerinin yapılması gerekebilmektedir. Örneğin biz "a = {}, b = {}, c = {}.format(a, b, c)" biçiminde oluşturulmuş 
    bir kodun çalışma süresini ölçmek isteyebiliriz. Burada önce a, b, ve c'ye değer atanması gerekir. Bu değer atamaları kodun içerisinde 
    yapılırsa bu durumda süreye dahil olacaktır. İşte bunun için setup isimli parametre bulundurulmuştur. setup parametresiyle belirtilen 
    kod süresi ölçülecek asıl koddan önce çalıştırılır ancak ölçüm süresine dahil edilmez. Ölçülecek kod böylece setup kodunda yaratılmış 
    olan değişkenleri kullanbilecektir. Örneğin:

    setup_code = """
    a = 10; b = 20; c = 30; d = 40; e = 50
    """
    measure_code = """
    s = 'a = {}, b = {}, c = {}, d = {}, e = {}'.format(a, b, c, d, e)
    """
    result = timeit.timeit(measure_code, setup=setup_code)
    
    Burada setup_code çalıştırılacak ancak ölçüme dahil edilmeyecektir. 

#------------------------------------------------------------------------------------------------------------------------------------

import timeit

setup_code = """
a = 10; b = 20; c = 30; d = 40; e = 50
"""
measure_code = """
s = 'a = {}, b = {}, c = {}, d = {}, e = {}'.format(a, b, c, d, e)
"""

result = timeit.timeit(measure_code, setup=setup_code)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
   Pekiyi zaten var olan birtakım global değişkenleri ve fonksiyonları setup parametresini kullanmadan ölçüm kodunda doğrudan kullanabilir 
   miyiz? İşte bunun için timeit fonksiyonunda globals parametresi de bulundurulmuştur. Bu paramete bir sözlük biçimindedir. Sözlüğün 
   anahtarları kullanılacak global değişkenlere bizim verdiğimiz isimlerden değeri de onların değerlerinde oluşmaktadır. Örneğin:

   result = timeit.timeit("for i in range(count): pass", globals={'count': 100})

   globals isimli built-in fonksiyonun tüm global değişkenleri bir sözlük biçiminde verdiğini anımsayınız. Bu durumda biz çağrıyı 
   aşağıdaki gibi de yapabiliriz:

   result = timeit.timeit(code, globals=globals())

   Burada kod içerisinde artık biz tüm global değişkenleri kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import timeit
import math

count = 10

code = """
for i in range(count): 
    a = [math.sqrt(i) for i in range(count)]
"""

result = timeit.timeit(code, globals=globals())
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi timeit fonksiyonu ile ölçülen zaman sistemin o anki durumuna bağlı olarak ve belki de kodun bazı 
    parametrelerine bağlı olarak farklı farlılıklar gösterebilmektedir. Bu nuedenle bazen bu çölüm işleminin kendisini belli bir miktarda 
    tekrarlayıp bir ortalama alınabilir. İşte timeit modülündeki repeat fonksiyonu repeat parametresiyle belirtilen sayıda timeit.timeit 
    fonksiyonunu çağırarak elde edilen zamanları repeat uzunlukta bir listeye yerleştirip bu listeyle geri dönmektedir. Fonksiyonun 
    parametrik yapısı şöyledir:

    timeit.repeat(stmt='pass', setup='pass', timer=<default timer>, repeat=5, number=1000000, globals=None)

    Fonksiyonun repeat dışındaki parametreleri timeit fonksiyonundaki gibidir. Yani bu parametreler aslında timeit fonksiyonuna 
    geçirilmektedir. Default repeat değerinin 5 olduğuna dikkat ediniz. Örneğin:

    code = """
    for i in range(count): 
        a = [math.sqrt(i) for i in range(count)]
    """

    result = timeit.repeat(code, repeat=5, number=1000, globals=globals())
    print(result)

    Burada biz 5 ayrı ölçüm yapmış olduk. repeat fonksiyonu bize bu 5 ayrı ölçüm değerini bir liste halinde vermektedir. 
    Denemeden makinede elde edilen liste şöyledir:

    [0.6159047000110149, 0.6150840999907814, 0.6073781999875791, 0.6185584000195377, 0.6033079999906477]
#------------------------------------------------------------------------------------------------------------------------------------

import timeit
import statistics

result = timeit.repeat("'-'.join(str(i) for i in range(10))", repeat=5)
print(result)       # [3.0629887000000053, 2.8896216000002823, 2.7409239999997226, 2.750181899999916, 2.742352899999787]
average_time = statistics.mean(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında timeit modülündeki timeit ve repeat fonksiyonları Timer isimli bir sınıf kullanılarak yazılmıştır. Yani asıl ölçme işlemleri
    bu Timer sınıfının metotları tarafıdan yapılmaktadır. Biz istersek doğrudan Timer sınıfı türünden bir nesne yaratıp ölçümü Timer
    sınıfının timeit ve repeat fonksiyonlarıyla yapabiliriz. Timer sınıfının __init__ metodunun parametrik yapısı şöyledir:

    class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>, globals=None)

    Örnek bir kullanım şöyle olabilir:

    code = """
    s = '-'.join([str(i) for i in range(100)])
    """

    timer = timeit.Timer(code)
    result = timer.timeit(number=100000)

    Görüldüğü gibi burada önce Time sınıfı türünden nesne yaratılmıştır. Çalıştırılacak kod bu nesne yaratılırken verilmiştir. 
    Bundan sonra asıl ölçüm işlemi Timer sınıfının timeit metoduyla yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import timeit

code = """
s = '-'.join([str(i) for i in range(100)])
"""

timer = timeit.Timer(code)
result = timer.timeit(number=100000)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanenin orijinal kaynak kodlarında global timeit ve repeat fonksiyonları şöyle yazılmıştır:

    def timeit(stmt="pass", setup="pass", timer=default_ timer,number=default_number, globals=None):
        """Convenience function to create Timer object and call timeit method."""
        return Timer(stmt, setup, timer, globals).timeit(number)

    def repeat(stmt="pass", setup="pass", timer=default_timer, repeat=default_repeat, number=default_number, globals=None):
        """Convenience function to create Timer object and call repeat method."""
        return Timer(stmt, setup, timer, globals).repeat(repeat, number)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir program çalıştırılırken komut satırında kullanılan argümanlara "komut satırı argümenları (command line arguments)" denilmektedir. 
    Komut satırı argümanları Python'da da benzer biçimde kullanılmaktadır. Örneğin "sample.py" isimli bir Python programını komut 
    satırından aşağıdaki gibi çalıştırmış olalım:

    python sample.py ali veli selami

    Burada çalıştırılmak istenen program "sample.py" isimli programdır. "ali veli selami" ise programın komut satırı argümanlarıdır. 
    Komut satırı argümanları programın içerisinden alınıp kullanılabilmektedir. Böylece programlar çalıştırılırken dış dünyadan programa
    parametre aktarımı yapılabilmektedir. 

    Komut satırı argümanlarını elde etmek için sys modülündeki argv isimli list türünden değişken kullanılmaktadır. Bu değişken her zaman 
    komut satırı argümanlarını bize bir liste biçiminde verir. Listenin ilk elemanı çalıştırılan Python kaynak dosyasının ismi, diğer 
    elemanlar da sırasıyla girilen komut satırı argümanı olur. Örneğin "sample.py" programımız şöyle olsun:

    import sys

    print(sys.argv)

    Biz de programı komut satırından şöyle çalıştırçalıştırmış olalım:

    python sample.py ali veli selami

    argv listesi şöyle oluşturulacaktır:

    ['sample.py', 'ali', 'veli', 'selami']

    Komutu satırı argümanları boşluk karakterlerinden ayrıştırılmaktadır. Boşluk içeren yazılar tek bir argüman olarak aktarılmak istenirse 
    tırnaklanmalıdır. Örneğin:

    python sample.py "ali veli selami"

    Burada "ali veli selami" artık tek bir argümandır. 

    Aşağıdaki örnekte komut satırı argümanı ile alınan ifade Python'un built-in eval fonksiyonuna sokulup ifadenin değeri elde edilmiş 
    ve ekrana yazıdırılmıştır. Programı şöyle çalıştırabilirsiniz:

    python sample.py "sqrt(12 - 6 * 3 + 30)"
#------------------------------------------------------------------------------------------------------------------------------------
 
 import sys
 from math import *

if len(sys.argv) != 2:
    print('wrong number of arguments!')
    sys.exit(1)

result = eval(sys.argv[1])
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Komut satırı arümanları IDE'li ortamlarda da IDE'lerin menüleriyle oluşturulabilmektedir. Yani biz IDE'lerde çalışırken sanki 
    programı komut satırından çalıştırıyormuşuz gibi argümanlar da girebiliriz. Spyder IDE'sinde "Run/configuration per file" diyalog 
    penceresinde "General settings/Command line options" edit alanında programın komut satırı argümanları girilebilmektedir. PyCharm 
    IDE'sinde de komut satırı argümanları "Run/Edit Configurations" diyalog pencersinde "Parameters" edit alanında girilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Python'un standart kütüphanesindeki modüller (yani .py dosyaları) bilindiği gibi birtakım faydalı fonksiyonları ve sınıfları 
    bulundurmaktadır. Ancak bu modüllerin bazıları (hepsi değil) aynı zamanda bir program gibi de çalıştırılabilmektedir. Yani bu 
    modüllerin bazıları hem bir kütüphane gibi kullanılmakta hem de bir program gibi çalıştırılabilmektedir. Tabii bu modüllerdeki 
    programlar bu modülleri yazanlar tarafından aşağıdaki gibi bir kontrolle çalıştırılmıştır:

    # some_module.py
    ...
    ...
    ...
    if __name__ == '__main__:
        ....

    Mademki bazı kütüphane modülleri aynı zamanda birer program gibi çalıştırılabilmektedir. Pekiyi onları program gibi nasıl çalıştırabiliriz?
    Öncelikle çalıştırma için bu modüllerin ".py" dosyalarının nerede olduğunu bilmemiz gerekir. Kurulum programı Python'u kurarken Python 
    standart kütüphanesindeki ".py" dosyalarını bazı dizinlerin içerisine çekmektedir. Her ne kadar bunların yerlerini biz bulabilirsek de 
    buradaki programları bu yöntemle çalıştırmak zahmetlidir. Mademki python yorumlayıcısı zaten bunların yerlerini bilmektedir. O halde 
    bizim python yorumlayıcısına çalıştırmak istediğimiz modülün ismini vermemiz yeterlidir. Bu işlem de python yorumlayıcısının komut 
    satırında "-m" seçeneği ile yapılmaktadır. Örneğin:

    python -m timeit "'-'.join(str(i) for i in range(10))"

    Biz "-m" seçeneği ile Python yorumlayıcısına şunu söylemekteyiz: "Python sen kendi modüllerinin nerede olduğunu biliyorsun. Beni 
    uğraştırma. Ama onun yerini bul ve onu bir program gibi çalıştır". Tabii biz bu biçimde çalıştırdığımız modüllere de komut satırı 
    argümanları da geçirebilmekteyiz. 
    
    CPython install edildiğinde genellikle standart kütüphane bileşenleri kurulum dizininin altındaki "lib" dizininde bulunmaktadır. pip 
    programı ile install edilen paketler ise genellikle "site-packages" dizininde bulıunur. Bir modülün nerede bulunduğunu modülün 
    __file__ özel değişkeni ile de öğrenebiliriz. Örneğin:

    >>> import timeit
    >>> timeit.__file__
    'C:\\Program Files\\msys64\\mingw64\\lib\\python3.9\\timeit.py'

    Aynı işlemi Linux'ta yaptığımızda şöyle bir sonuç elde ediyoruz:

    >>> import timeit
    >>> timeit.__file__
    '/usr/lib/python3.8/timeit.py'

    Tabii Python standart kütüphanesindeki modüllerde bulunan kodları "-m" seçeneği ile çalıştırmak çok daha pratiktir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   timeit modülü bir program gibi de çalıştırılabilmektedir. Yani komut satırında (kabuk üzerinde) biz "-m" seçeneği ile bu timeit 
   modülündeki programı çalıştırabiliriz. Modülün komutu satırı argümanları şunlardır:

   -n N, --number=N: How many times to execute ‘statement’
    -r N, --repeat=N: How many times to repeat the timer (default 5)
    -s S, --setup=S: Statement to be executed once initially (default pass)
    -p, --process: Measure process time, not wallclock time, using time.process_time() instead of time.perf_counter(), which is the 
    default
    -v, --verbose: Print raw timing results; repeat for more digits precision
    -h, --help

    Örneğin:

    python  -m timeit -n 100000 "'-'.join(str(i) for i in range(100))"

    Eğer komut satırında "-n" seçeneğini kullanmazsak modüldeki program kendisi çalıştırılmak istenen kodun harcadığı zamana göre 
    ölçüm için döngü değerini kendisi ayarlamaktadır. "-r" parametresi girilmezse kod default olarak 5 kez çalıştırılmaktadır. 

    Pekiyi timeit modülünü komut satırında bir program gibi çalıştırmanın bize sağladığı fayda nedir? İşte bu sayede bir editör bile 
    kullanmadan Python kod parçalarının çalışma zamanlarını komut satırından elde edebilmekteyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

python  -m timeit -n 100000 "'-'.join(str(i) for i in range(100))"

#------------------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde Python'da veritabanı işlemlerin nasıl yapıldığı üzerinde duracağız. Biz bu bölümde önce "veritabanı",  
    "veritabanı yönetim sistemler" kavralarını göreceğiz. Sonra işimizi görecek kadar SQL dilini tanıtacağız. Sonra veritabanı 
    işlemlerinin Python'da nasıl gerçekleştirildiğini açıklayacağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            7. Ders 16/03/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İçeriisnde belli bir düzende bilgilrin tutulduğu dosyalara "veritabanı (database)" denilmektedir. Örneğin bir kitapların bilgileri, 
    şahıslara ilişkin bilgiler, ürünlere ilişkin bilgiler veritabanlarında saklanabilmektedir. Veritabalarından amaç belli koşulu sağlayan 
    bilgilere hızlı bir erişimin sağlanmasıdır. Uygulama programcılığında birtakım bilgilere hızlı bir biçimde erişilmesi en önemli 
    unsurlardan birini oluşturmaktadır. Bu nedenle uygulama programcılığı için veritabanları önemli bir konudur. Örneğin biz binlerce 
    öğrencinin bilgilerini bir veritabanında saklayabiliriz. Sonra "Eskişehir'de doğan yaşı 15'ten büyük olan Lise 4'üncü sınıf öğrencilerinin"
    listesini hızlı bir biçimde elde edebiliriz. Veritabanlarında belli koşulları sağlayan kayıtların elde edilmesine "sorgulama (query)" 
    denilmektedir. 

    Veritabanı işlemleri uzmanlık gerektiren işlemlerdir. Programcının bir dosya açarak kayıtları onun içerisine yerleştirmesi ve dosya 
    içerisinden sıralı bir biçimde bunlara erişmesi oldukça ilkel bir yaklaşımdır. Veritabanı işlemleri karmaşık ve uzmanlık gerektiren 
    işlemler olduğu için bu işlemleri yapma iddiasında olan bağımsız yazılımlar oluşturulmuştur. Bunlara "Veritabanı Yönetim Sistemleri 
    VTSY (Database Management Systems - DBMS)" denilmektedir. Çeşitli firmaların paralı VTYS'leri vardır. Bazı VTYS'ler ise açık kaynak 
    kodlu dolayısıyla bedav durumdadır. Günümüzde en çok kulanılan VTYS'ler şunlardır:

    - Oracle firmasının "Oracle" isimli ürünü (paralı).
    - Microsoft firmasının "SQL Server" isimli ürünü (paralı).
    - IBM firmasının "DB2 isimli ürünü (paralı).
    - MySQL isimli VTYS açık kaynak kodludur ancak dağıtımı ve isim hakkı Oracle firmasındadır (açık kaynak kodlu ancak gelecekteki 
    durumu şüpheli).
    - MariaDB MySQL projesinde çalışanların oluşturduğu MySQL'in devamı niteliğindeki açık kaynak kodlu üründür. 
    - PostGreSQL açık kaynak kodlu oldukça popüler bir VTYS'dir.
    - SQLite açık kaynak kodlu gömülü (embedded) bir VTYS'dir.

    Eskiden VTYS kavramı yoktu. Bu kavram zamanla yaygın kazandı. VTYS kavramını IBM firması ortaya atmıştır ve dünyanın ilk VTYS'si de 
    IBM'in DB2 denilen ürünüdür. Oracle firması geliştirdiği VTYS ile dünyanın en büyük bilişim firmaları arasına girmiştir. VTYS'lerin 
    olmadığı zamanlarda veritabanı işlemleri özel kütüphanelerle yürütülüyordu. Bu kütüphanelerin kullanılması da oldukça zordu.
    
    Bir ürünün VTYS olarak adlandırılabilmesi için kabaca şu özelliklere sahip olması gerekir:

    - VTYS'lerde kullanıcı yüksek seviyeli bir biçimde işlemlerini yürütür. VTYS'ler alçak seviyeli işlemlerle kullanıcının ilgisini
    kesmiştir. Yani VTYS'lerin kayıtları hangi dosyalarda ve nasıl sakladığını kullanıcılar bilmek zorunda değildir. 

    - VTYS'ler "client-server" tarzı bir mimariye sahiptir. Yani VTYS'lere birden fazla client bağlanıp eşzamanlı olarak işlemler 
    yapabilmektedir. Bu bağlamda VTYS'lerin çoğu uzak bağlantılara izin verebilmektedir. 

    - VTYS'ler kullanıcılarına güvenli bir kullanım sunmaktadır. Buradaki güvenlik iki yönlüdür. Hem bilgilerin bozulmaması konusunda 
    bir direnci belirtmektedir. Güvenlik aynı zamanda bir kullanıcının başka bir kullanıcının bilgilerine erişimini engellemek anlamına 
    da gelmektedir. Genellikle bu sistemlerde kullanıcılara "kullanıcı ismi" ve "parola" verilir. Kullanıcılar bu bilgilerle işlemlerini 
    yaparlar. 

    - Pek çok VTYS'de birtakım hazır utility araçlar da bulunmaktadır. Örneğin backup, restore araçları gibi. Pek çok VTYS'nin işlemleri
    GUI ortamda fare ve klavye ile yapmaya olanak sağlayan yüksek seviyeli yönetim araçları da bulunmaktadır.

    - VTYS'lerin en önemli özelliklerinden biri onlara iş yaptırmak için yüksek seviyeli bazı dillerin kullanılmasıdır. Örneğin VTYS'lerin 
    çoğu SQL (Structured Query Language) denilen bir dili desteklemektedir. Kullanıcı yapmak istediği şeyi SQL denilen bir dille VTYS'ye 
    söyler. SQL veritabanı işlemlerini yapan dil değildir, kullanıcı ile arayüz oluşturan bir dildir. Asıl veritabanı işlemleri VTYS'lerin 
    motor (engine) kısımlarıyla C/C++ gibi dillerde yazılmış kodlarla yapılmaktadır. Bu nedenle programcının VTYS'lere iş yaptırabilmesi 
    için belli düzeyde SQL bilmesi gerekmektedir.

    Biz kursumuzda aşağıdaki VTYS'ler üzerinde çalışmalar yapacağız:

    - MySQL
    - Microsoft SQLServer
    - SQLite Gömülü VTYS
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    VTYS'ler kapasiteli oldukça güçlü ve büyük yazılımlardır. Halbuki bazen birkaç tablodan oluşan küçük veritabanlarının oluşturulması
    gerekebilmektedir. İşte aslıdna bir VTYS olmadığı halde bir VTYS'y takit eden sisteme önemli bir yük bindirmeyen tek bir kütüphane
    dosyası biçiminde bulunan ancak SQL kullanımına da izin veren yazılımlar oluşturulmuştur. Bunlara "Gömülü VTYS (Embedded DBMS)" 
    denilmektedir. Bunların en yaygın kullanılanı "SQLite" isimli programdır. Microsoft'un Access programında kullandığı "Access Jet 
    Motor" da bir gömülü VTYS'dir. Gömülü VTYS'ler çok az sistem kaynağı gerektirdikleri için gömülü aygıtlarda yaygın biçimde 
    kullanılmaktadır.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde VTYS'lerin nasıl kullanıma hazır hale getirildiği üzerinde duracağız.     

    MySQL kullanabilmek için "MySQL Server" isimli programı makinenize kurmanız gerekir. MySql server aşağıdaki bağlantıdan indirilip 
    kurulabilir:

    https://dev.mysql.com/downloads/mysql/

    Kurulum yapıldığında server çalışır durumda olur. Aynı zamanda "MySql Workbench" denilen bir GUI aracı da kullanıma hazır hale gelir. 
    "MySQL Workbench" MySQL VTYS'siüzerinde fare klavye yoluyla işlemler yapmayı kolaylaştıran bir GUI yönetim aracıdır. 

    Microsoft'un "SQLServer" isimli ürünü paralıdır. Ancak bunun "Express Edition" ismi altında bedava bir versiyonu da bulunmaktadır. 
    "Express Edition" aşağıdaki bağlantıdan indirilip kurulabilir. Kurulumu biraz zaman almaktadır kurulum sonrasında ve diskte 4GB 
    civarı yer kaplamaktadır. 

    https://www.microsoft.com/en-us/download/details.aspx?id=101064
    
    SqlServer'ın da "SqlServer Management Studio" isminde bir GUI aracı bulunmaktadır. 

    SQLite en çok kullanılan Gömülü VTYS'dir. SQLite aslında tek bir DLL'den oluşmaktadır. Gerçek bir server değildir. Server taklidi 
    yapan bir kütüphane gibidir. Bu nedenle küçük aygıtlarda server'sız SQL kullanımına izin vermektedir. Dolayısıyla SQLite'ı kurmak 
    aslında birkaç dosyayı indirmek anlamındadır. SQLite parasız açık kaynak kodlu bir üründür. İndirimi aşağıdaki bağlantıdan yapılabilir:

    https://www.sqlite.org/download.html

    Burada "Precompiled Binaries for XXX" bağlantısına (XXX işletim sistemini belirtiyor) tıklanırsa bir ".zip" dosyası indirilecektir. 
    Bu ".zip" dosyası açıldığında ilgili kütüphane dosyası elde edilecektir. Ancak Python'un standart kütüphanesi zaten SQLite'ı desteklemektedir. 
    Dolayısıyla SQLite kütüphaneleri zaten sizin Python paketlerinizin içerisinde bulunuyor durumdadır. Python'da SQLite için bir şey 
    indirmenize gerek yoktur.
    
    SQLite için pek çok basit GUI aracı geliştirilmiştir. Bu GUI araçlarının bazıları o kadar iyi olmasa da iş görür niteliktedir. 
    "SQLite Studio" isimli GUI aracını aşağıdaki bağlantıdan indirebilirsiniz:

    https://sqlitestudio.pl/

    "DB Browser for SQLite" isimli aracı da şu bağlantıdan indirebilirsiniz:

    https://sqlitebrowser.org/dl/

    Bunların dışında pek çok VTYS ile çalışan genel GUI araçlar da vardır. Örneğin "DBeaver" bedava ve güzel bir araçtır. DBeaver
    aşağıdaki bağlantıdan indirilebilir:

    https://dbeaver.io/

    Biz kurusumuzda önce zaten Python'a entegre edilmiş olan SQLite üzerinde işlemler yapacağız. Daha sonra MySQL ve Microsoft 
    SqlServer üzerinde duracağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veritabanı dünyasında çeşitli "modeller (paradigms)" bulunmaktadır. Bugün endüstride en yaygın kullanılam model "ilişkisel veritabanı 
    (relational database)" modelidir. Ancak bu modelin yanı sıra "nesne tabanlı (object based)", "hiyerarşik (hiearchical)", "NoSql" 
    modelleri de bulunmaktadır. Özellikle son on yıldır NoSql veritabanı modelleri yaygın kullanılmaya başlamıştır. Biz kursumuzda 
    yalnızca ilişkisel veritabanları üzerinde işlem yapacağız. Bazı veri türleri için diğer modeller daha uygun olabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanları tablolardan, tablolar sütun ve satırlardan oluşmaktadır. Tabloların sütunlarına "alan (field)" satırlarına 
    ise "kayıt (record)" ya da "satır (row)" denilmektedir. Ugulamacı tipik olarak önce veritabanını boş bir biçimde yaratır. Sonra 
    onun içerisinde tabloları oluşturur. Tabloları oluştururlen sütunları (yani alanları) belirler. Sonra da tablolara kayıt (yani satır) 
    ekler. Tabii gerektiğinde tablolardaki koşulu sağlayan kayıtları elde edip görüntüler. Bütün bunları SQL denilen bir arayüz dille 
    gerçekleştirir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    SQL'de tabloların sütunları yaratılırken onlara birer tür bilgisi atanmaktadır. Yani her sütun farklı türlerden bilgileri tutabilmektedir. 
    SQL ISO tarafından standardize edilmiş olan bir dildir. ISO standartlarında sütunlar (yani alanlar) için çeşitli türler belirtilmiştir. 
    Ancak SQL'in de ISO standartlarının dışında pek çok varyantı vardır. Microsoft'un SQL varyantına "Transact-SQL" ya da kısaca "TSQL"
    denilmektedir. Oracle firmasının SQL'ine ise "PL/SQL" denilmektedir. Dolayısıyla çeşitli SQL server yazılımları bazı standart sütun 
    türlerini destekliyor olsa da farklı türlere de sahiptir. Örneğin MySQL'deki sütun türleri çok çeşitlidir. Ancak SQLite aslında 
    içsel olarak çok az türü desteklemektedir. 

    Bugün Veritabanı işlemleri artık uzamanlık gerektiren bir iş kolu haline gelmiştir. Bu tür işlerle uğraşan kişilere "Veritabanı Yöneticisi
    (DB Admin)" denilmektedir. Veritabanı yöneticileri belli bir VTYS'yi üzerinde onların araçlarını kullanbilecek biçimde uzamanlaşmışlardır. 
    Veritabanı yöneticileri veritabanlarını oluşturup, onların sürüdürümünü yaparlar ve gerekli raporların alınması için programcılara 
    yardımcı olurlar. Tabii bir programcının veritabanı yöneticisi kadar veritabanı bilmesine gerek yoktur.

    Pek çok VTYS'nin desteklediği standart sütun türleri şunlardır:

    INTEGER: Bu tür tamsayıları turmak için kullanılan genel bir tamsayı türüdür.

    INT: Pek çok VTYS'de bu tür 4 byte'lık tamsayı türünü temsil etmektedir. 

    SMALLINT: Tipik olarak 2 byte'lık tamsayı türünü temsil eder.

    BIGINT: Tipik olarak 8 byte'lık tamsayı türünü temsil eder. 

    FLOAT: 4 byte'lık noktalı sayı türünü temsil etmektedir. 

    DOUBLE: 8 byte'lık noktalı sayı türünü temsil etmektedir. 

    NUMERIC ya da REAL: Belli bir tamsayı kısmı ve noktadan sonarki duyarlılık eşliğinde noktalı sayıyı temsil etmektedir. 

    TIME: Zaman bilgisini temsil etmektedir. 

    DATE: Tarih bilgisini temsil etmektedir. 

    DATETIME: Her tarih hem de zamanı temsil etmektedri. 

    CHAR(N): N karakterli yazıları temsil etmektedir. 

    VARCHAR(N): En fazla N karakterden oluşan değişken uzunlukta yazısal bilgiyi temsil etmektedir. 

    TINYTEXT: 256 karaktere kadar düz metin tutmak için kullanılmaktadır.

    TEXT: 64K'ya kadar yazıları temsil etmektedir. 

    LONGTEXT: 4 GB'ye kadar yazıları tutmak için kullanılmaktadır. 

    TINYBLOB: 256 byte'a kadar binary veri turmak için kullanılmaktadır.

    BLOB: 64K'ya kadar binary veri tutmak için kullanılaktadır.

    LONGBLOB: 4GB'ye kadar binary veri tutmak için kullanılmaktadır. 

    BOOLEAN: True False biçiminde ikili verileri tutmak için kullanılmaktadır. 

    Uygulamacı olarak hangi VTYS ile çalışıyorsanız ona özgü türleri gözden geçirmenizi tavsiye ederiz. Örneğin MySQL'de çok fazla 
    tür vardır. MySQL'in türlerini aşağıdaki bağlantıdan inceleyebilirsiniz:

    https://dev.mysql.com/doc/refman/8.0/en/data-types.html

    SQLite ISO standartlarındaki pek çok türü destekliyor gibi görünse de kendi içerisinde aslında birkaç tür kullanmaktadır. 
    (Yani başka bir deyişle SQLite pek çok türü kabul etmekle birlikte bunları aslında ortak birkaç tür ile ifade etmektedir.)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veritabanları için GUI araçları pek çok işlemin görsel biçimde fare ve klavye yoluyla yapılmasına izin vermektedir. Fakat aslında 
    bu GUI araçlar kullanıcının görsel yaptığı işlemleri SQL komutlarına dönüştürüp bu SQL cümlelerini VTYS'ye göndererek işlemlerini 
    yapmaktadır. Örneğin biz bir GUI araçta bir düğmeye basarak veritabanı yaratıyor olabiliriz. Aslında GUI aracı veritabanı yaratan 
    "CREATE DATABASE" isimli SQL komutunu VTYS'ye gönderip işlemini yapmaktadır. Yani GUI araçlar yalnızca kullanım kolaylığı sağlamaktadır.
    Şimdi temel SQL komutlarını görelim. GUI araçlar aynı zamanda SQL editörlerine de sahiptir. Yani biz SQL editöründe bir komutu 
    yazıp onu çalıştırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Genel olarak SQL'de yazısal bilgiler tek tırnak içerisine alınmaktadır. Her komut ';' ile sonlandırılır. Ancak pek çok VTYS bu ';' 
    ile sonlandırmayı zorunlu tutmamaktadır. SQL büyük harf küçük harf duyarlılığı olan bir dil (case sensitive) değildir. Pek çok uygulamacı 
    anahtar sözcükleri büyük harflerle diğer isimleri küçük harflerle yazma eğilimindedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veritabaını yaratmak için "CREATE DATABASE" komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    CREATE DATABASE <isim>;

    Örneğin:

    CREATE DATABASE school;

    Veritabanı silmek için DROP DATABASE komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    DROP DATABASE <isim>;

    MySQL'de "veritabanı" yerine "schema" terimi tercih edilmiştir. SQLite'ta veritabanı yaratmak için CREATE DATABASE komutu kullanılmaz. 
    SQLite veritabanları tek bir dosya biçiminde oluşturulmaktadır. Boş bir veritabanı içi boş bir dosya ile oluşturulabileceği gibi 
    GUI araçlarıyla ya da programlama yoluyla oluşturulabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veritabanı (schema) üzerinde işlem yapmadan önce o veritabanının aktif hale getirilmesi gerekir. (Başka bir deyişle bizim VTYS'ye
    hangi veritabanı üzerinde işlem yapmak istediğimizi bildirmemiz gerekir.) Bunun için USE komutu kullanılmaktadır. USE komutunun genel 
    biçimi şöyledir:

    USE <veritabanı_ismi>;

    Örneğin:

    USE school;

    SQLite'ta yine bu biçimde bir USE komutu yoktur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veritabanı yaratıldıktan sonra sıra tabloların yaratılmasına gelmiştir. Karmaşık bir veritabanı yüzlerce hatta binlerce tabloya sahip 
    olabilmektedir. Tablo yaratmak için "CREATE TABLE" komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    CREATE TABLE <tablo_ismi> (sütun_ismi1 tür, sütun_ismi2 tür, sütun_ismi3 tür, ....);

    Tablo yaratırken sütun isimleri ve onların türleri belirtilmektedir. Genellikle tablolara "birincil anahtar (primary key)" denilen 
    bir sütunun eklenmesi iyi bir tekniktir. Bu sütun aynı zamanda otomatik artırımlı (AUTO INCREMENT) yapılmaktadır. Örneğin:

    CREATE TABLE student_info(student_id INTEGER PRIMARY KEY AUTO_INCREMENT student_name VARCHAR(64), student_no INTEGER);

    Tablodaki bir sütun eğer birbirinden farklı satır değerlerine sahip olmak zorundaysa bu tür sütunlara "PRIMARY KEY" denilmektedir. 
    Örneğin student_id isimli sütun PRIMARY KEY ise Biz kayıt insert ederken aynı numaraya sahip birden fazla kaydı insert edemeyiz. 
    Ancak örneğin student_name PRIMARY KEY değilse bu durumda aynı isme sahip birden fazla kayıt tabloya eklenebilmektedir. Yukarıda da 
    belirttiğimiz gibi tavsiye edilen durum her tablonun bir sütununun PRIMARY KEY yapılmasıdır. Eğer tabloda PRIMARY KEY olmaya aday 
    bir sütun yoksa bu durumda uygulamacı dummy bir sütun yaratıp (genellikle ismine id verilir) onu PRIMARY KEY yapabilir. MySQL'de 
    sütunu PRIMARY KEY yapmak için sütun türünden sonra PRIMARY KEY anahtar sözcükleri yerleştirilebilir ya da CREATE TABLE komutundaki 
    sütun listesinde PRIMARY KEY(isim) biçiminde bir eleman bulundurulur. Örneğin:

    CREATE TABLE student_info(student_id INTEGER PRIMARY KEY AUTO_INCREMENT student_name VARCHAR(64), student_no INTEGER);

    ya da örneğin:

    CREATE TABLE student_info(student_id INTEGER PRIMARY KEY AUTO_INCREMENT student_name VARCHAR(64), 
        student_no INTEGER, PRIMARY KEY(student_id));

    Diğer pek çok SQL varyantlarında PRIMARY KEY ilk biçimde oluşturulmaktadır.

    Bir sütun AUTO_INCREMENT yapılırsa satır insert etme sırasında bu sütun değeri otomatik olarak önceki değerden bir fazla olacak 
    biçimde artırılır. Genellikle PRIMARY KEY olan sütunlar zaten otomatik olarak belirtilmese bile AUTO_INCREMENT kabul edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        8. Ders 22/03/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir tabloya satır (yani kayıt) eklemek için INSERT INTO komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    INSERT INTO <tablo ismi>(<sütun listesi>) VALUES(<değer listesi>);

    Örneğin:

    INSERT INTO student(student_no, student_name) VALUES(123, 'Ali Serçe');

    Tabloya satır eklerken tüm sütun sütunlar için değer girilmesi zorunda değildir. Bu nedenle önce hangi sütun bilgilerinin girileceği 
    belirtilmektedir. Ondan sonra VALUES anahtar sözcüğü ile bu sütunların değerleri girilir. Sıra veritabanındaki sıra olmak zorunda 
    değildir. Ancak komuttaki sıra tutarlı olmalıdır. Yazısal sütunlar için değerler tek tırnak içerisinde girilmek zorundadır. 
    Örneğin:

    INSERT INTO student_info(student_name, student_no) VALUES('Ali Serçe', 123);
    INSERT INTO student_info(student_name, student_no) VALUES('Sacit Süzülmüş', 765);
    INSERT INTO student_info(student_name, student_no) VALUES('Sibel Tektaş', 654);
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    WHERE cümleciği pek çok SQL komutuna monte edilebilen bir kalıptır. WHERE cümleciğinin amacı koşul oluşturmaktır. Cümlecikte
    temel karşılaştırma operatörleri benzer biçimde kullanılır. SQL'de AND, OR ve NOT mantıksal operatörleri koşullarda kullanılabilmektedir. 
    Örneğin:

    WHERE student_no > 700 AND student_no < 800

    Koşul oluştururken ilginç bir operatör de LIKE operatörüdür. LIKE operatörü iki operand'lı araek bir operatördür. Operatörün solundaki 
    operand bir yazısal bilgi içeren bir sütun ismi sağındaki operand ise kalıp yazısıdır. % karakteri "geri kalan hepsi" anlamına gelmektedir. 
    Örneğin:

    WHERE student_name LIKE 'A%'

    Burada "ismi A ile başlayan öğrenciler" biçiminde bir koşul oluşturulmuştur. Örneğin:

    WHERE student_name LIKE '%A%'

    Bu kalıp içinde A geçenler anlamına gelmektedir. Yazısal sütunlarda default durumda büyük harf küçük harf duyarlılığı yoktur. Yani 
    yukarıdaki koşulda içerisinde 'a' karakteri geçen isimler de koşula dahildir. Ancak bu durum VTYS'den VTYS'ye değişebilmektedir. 
    Pek çok VTYS'nin kendine özgü operatörleri de vardır. Çalıştığınız VTYS'deki SQL'de kullanılan operatörleri gözden geçiriniz. 
    Örneğin SQLite'ta REGEXP biçiminde bir operatör bulunmaktadır:

    WHERE student_name REGEXP 'A.*L'

    Bu REGEXP operatörü ile biz başı A ile başlayan sonu L ile biten koşulunu oluşturmuş olduk. IN operatörü birden fazla seçeneği 
    belirtmek için kullanılmaktadır. ÖrneğiN:

    WHERE student_birth_place IN ('Eskişehir', 'İzmir', 'Manisa')

    Burada doğum yeri "Eskişehir", "İzmir" ve "Manisa" olan öğrencilere yönelik bir koşul oluşturulmuştur. Tabii bu koşul OR operatörüyle 
    de yapılabilirdi. 
    
    Pek çok VTYS'de o VTYS'ye özgü "built-in" fonksiyonlar da bulunmaktadır. WHERE koşulları bu fonksiyonlar kullanılarak da 
    oluşturulabilmektedir. Örneğin:

    WHERE length(student_name) > 6

    Burada length fonksiyonu built-in bir fonksiyondur. Dolayısıyla yukarıdaki koşulda "ismi 6 karakterden büyükler" ifade edilmiştir. 
    Çalıştığınız VTYS'nin built-in fonksiyonlarını inceleyiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    SQL "DELETE FROM" komutu belli koşulu sağlayan kayıtların silinmesi amacıyla kullanılmaktadır. Komutunb genel biçimi şöyledir:

    DELETE FROM <tablo_ismi> [WHERE <koşul>];

    Komutta WHERE cümleciği bulundurulmazsa tablodaki tüm kayıtlar silinmektedir. Bu nedenle dikkat edilmesi gerekir. DELETE FROM
    komutunu güvenli kullanabilmek için koşu cümleceğini katı hale getirebilirsiniz. Ya da silme işlemini PRIMARY KEY sütununu 
    kullanarak yapabilirsiniz. Örneğin:

    DELETE FROM student_info WHERE student_name = 'Ali Serçe';

    Bu komut adı "Ali Serçe" olan tüm öğrencileri silecektir. Koşulu şçyle daha katı hale getirebiliriz:

    DELETE FROM student_info WHERE student_name = 'Ali Serçe' AND student_no = 123;

    Ya da önce silinecek kaydın PRIMARY KEY sütunundaki bilgi elde edilip silme buna göre de yapılabilir. Örneğin:

    DELETE FROM student_id = 123;
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen belli bir satırın (kaydın) belli bir alanını değiştirmek isteyebiliriz. Örneğin bir öğrencinin ismi veritabanına yanlış kaydedilmiş 
    olabilir. Bu öğrencinin diğer bilgilerine dokunmadan onun ismini değiştirmek isteyebiliriz. Kayıt üzerinde değişiklikler UPDATE isimli 
    SQL komutuyla yapılmaktadır. UPDATE komutunun genel biçimi şöyledir:

    UPDATE <tablo ismi> SET <değişken = değer>, <değişken = değer>, ... [WHERE <koşul>]

    Örneğin:

    UPDATE student_info SET student_name = 'Mehmet Kömcü' WHERE student_name = 'Timur Kömcü';

    Burada "Timur Kömcü" olan öğrencinin ismi "Mehmet Kömcü" biçiminde değiştirilmiştir. UPDATE komutu dikkatle uygulanmalıdır. 
    Komutun WHERE kısmı unutulursa tüm kayıtlarda değişiklik yapılmaktadır. Yani tüm kayıtların koşulu sağladığı varsayılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Koşulu sağlayan kayıtların elde edilmesi SELECT komutuyla yapılmaktadır. SELECT komutunun genel biçimi ayrıntılıdır. Çünkü komuta
    çeşitli cümlecikler monte edilebilmektedir. Komutun temel biçimi şöyledir:

    SELECT <sütun_listesi> FROM <tablo_ismi> [WHERE <koşul];

    Eğer WHERE cümleciği kullanılmazsa tablodaki tüm kayıtlar elde edilir. Sütun listesi sütunların isimlerinden oluşmaktadır. Uygulamacı 
    yalnızca bazı sütun bilgilerini elde edebilir. Örneğin:
    
    SELECT student_name, student_no FROM student_info WHERE student_no > 600;

    Burada numarası 600'den büyük olan öğrencilerin isimleri ve numaraları elde edilmektedir. Sütun istesi yerine * kullanılırsa bu 
    durum "tüm sütunlar" anlamına gelmektedir. Örneğin:

    SELECT * FROM student_info WHERE student_no > 600;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir. 

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student_info WHERE student_id > 600 ORDER BY stdent_name;

    ORDER BY default olarak kayıtları küçükten büyüğe (ASC) vermektedir. Ancak DESC ile büyükten küçüğe de sıralama yapılabilir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC;

    ORDER BY cümleciğinde birden fazla sütun belirtilebilir. Bu durumda ilk sütun değerleri aynıysa diğer sütunlar dikkate alınır. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC;

    Burada ismi aynı olanlar numaralarına göre küçükten büyüğe elde edilecektir. 

    Bazen select edilen satırlar çok fazl aolabilir. Programcı elde edilecek atır sayısı üzerinde bir kısıtlama oluşturabilir. Bunun
    için LIMIT cümleceği kullanılmaktadır. LIMIT anahtar sözcüğünün yanında bir sayı bulunur. Bu durumda koşulu sağlayan kayıtların 
    en fazla burada belirtilen kadarı elde edilir. Örneğin:

    SELECT * FROM student_info WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC LIMIT 10;

    WHERE cümleciğinde built-in fonksiyonlar kullanılabilir. Örneğin:

    SELECT * FROM city WHERE char_length(city) = 6;

    Built-in fonksiyonlar SELECT cümlesinde sütun isimlerinde de kullanılabilir. Örneğin:

    SELECT SUBSTR(student_name, 1, 3) FROM student_info;

    Burada öğrencilerin isimlerinin ilk üç karakteri elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanlarında tablolarda veri tekrarı istenmez. Örneğin bir öğrenci veritabanı oluşturacak olalım. Bir öğrencinin 
    çeşitli bilgilerinin yanı sıra onun okulu hakkında da bilgileri tutmak isteyelim. Aşağıdaki gibi bir tablo tasarımı uygun değildir:

    Adı Soyadı  No      Okul Adı                Okulun Bulunduğu Şehir      Okulun Türü
   -------------------------------------------------------------------------------------- 
    Ali Serçe   123     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    Kaan Aslan  745     Eskişehir Atatürk Lisesi    Eskişehir               Devlet Lisesi
    Hasan Bulur 734     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    ...                 ...                         ...                     ...

    Burada Okul bilgileri gereksiz bir biçimde tekrarlanmaktadır. Bu tekrarı engellemek için iki tablo oluşturabiliriz.

    Öğrenci Tablosu

    Adı Soyadı     No      Okul ID'si
    ----------------------------------
    Ali Serçe      123     100
    Kaan Aslan     745     150
    Hasan Bulur    734     100 
    ...             ...     ...

    Okul Tablosu

    Okul Id'si       Okul Adı                   Okulun Bulunduğu Şehir      Okulun Türü
    ------------------------------------------------------------------------------------
    ...              ...                        ...                         ...    
    100              Tarsus Amerikan Lisesi     Mersin                      Devlet Lisesi
    150              Eskişehir Atatürk Lisesi   Eskişehir                   Devlet Lisesi
    ...              ...                        ...                         ...

    Burada veri tekrarı oratadan kaldırılmıştır.  Tabii bu tablolarda da Okul ID'si ortak bir sütundur. Bu ortak sütun tablolar arasında 
    ilişki kurmak için gerekmektedir. Bu tür sütunlara "foreign key" de denilmektedir. Ancak yukarıdaki gibi tekrarlar engellendiğinde 
    gerekli bilgiler artık tek bir tablodan değil çeşitli tabolardan çekilip alınacaktır. İşte çeşitli tabolardan bilgilerin çekilip 
    alınması işlemine "JOIN" işlemi denilmektedir. JOIN işleminin birkaç biçimi vardır (INNER JOIN, OUTER JOIN, LEFT JOIN, RIGHT JOIN 
    gibi). Ancak en fazla kullanılan JOIN işlemi "INNER JOIN" denilen işlemdir. JOIN denildiğinde de zaten default olarak INNER JOIN 
    anlaşılmaktadır. INNER JOIN işleminde eğer iki tablo söz konusu ise önce iki tablonun kartezyen çarpımları elde edilir. Her kaztezyen 
    çarpım iki tablonun birleştirilmesi biçiminde ("join" ismi oradan geliyor) elde edilmektedir. Sonra kartezyen çarpımlarda yalnızca 
    belli koşulu sağlayan satırlar elde edilir. Bu koşul da genellikle "foreign key" eşitliğine dayalı olur. Böylece tablolar "ilişkisel 
    (relational)" biçimde birleştirilmektedir. 

    INNER JOIN sentaksı iki biçimde oluşturulabilmektedir. Birinci sentaks klasik eski tip sentakstır. İkinci sentaks daha modern biçimdir. 
    Klasik eski tip sentaks şöyledir:

    SELECT <iki tablodaki istenen sütunların listesi> FROM <birinci tablo ismi> INNER JOIN <ikinci tablo ismi> ON <koşul>;

    Örneğin:

    SELECT student.student_name, student.student_no, school.school_name, school.school.city FROM student_info INNER JOIN school_info 
    ON student.school_id = school.school_id WHERE student.student_no > 600;

    Sütun isimleri belirtilirken eğer çakışma yoksa yalnızca isimler yazılabilir. Ancak çakışma varsa tablo ismi ve nokta operatörü ile 
    sütunun hangi tabloya ilişkin olduğu belirtilmelidir. Bazı uygulamacılar çakışma olsa da olmasa da niteliklendirme yaparlar. Bazı 
    uygulamacılar yalnızca çakışan sütunlarda niteliklendirme yaparlar. Yukarıdaki örnekte tüm sütunlar niteliklendirilerek belirtilmiştir. 
    Bu örnek şöyle de yapılabilirdi:

    SELECT student_name, student_no, school_name, school_city FROM student INNER JOIN school ON student.school_id = school.school_id 
    WHERE student_no > 600;

    Modern INNER JOIN sentaksında SELECT komutunun FROM kısmında birden fazla tablo ismi belirtilir. Koşul da yine WHERE cümleciğine 
    taşınır. Bu sentaks hem dolay hem de daha anlaşılabilirdir. Örneğin:

    SELECT student_name, student_no, school_name, school_city FROM student_info, school_info WHERE student.school_id = school.school_id 
    AND student_no > 600;

    Daha çok bu modern biçim tercih edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    SQL birtakım ayrıntıları olan bir dildir. Biz kursumuzda yalnızca temel işlemleri yapabilecek kadar SQL gördük. Siz bu dilin 
    ayrıntılarına ayrıca çalışabilirsiniz ya da Dernemizde SQL'in yarıntılarıyla anlatıldığı kurslara katılabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        9. Ders 23/03/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de bütün veritabanı işlemlerinin Python'da bir program içerisinden nasıl yapıldığını göreceğiz. Python'da veritabanı işlemlerinin 
    tipik yapılış biçimi şöyledir:

    1) VTYS'ler client-server yazılım mimarisi kullanarak gerçekleştirilmiştir. Dolayısıyla önce programcının (burada programcı client 
    oluyor) VTYS'ye bağlanması gerekir. SQLite aslında bir VTYS gibi kullanılan bir kütüphanedir. Dolayısıyla SQLite'ta gerçek bağlanma 
    söz konusu değildir. Ancak MySQL gibi, SQLServer gibi, Oracle gibi VTYS'lere bağlanılırken "kullanıcı adı ve parola ve gerekli başka 
    bilgilere" gereksinim duyulmaktadır. 
    
    2)Programcı bağlantı sağlandıktan sonra SQL komutlarını VTYS'ye gönderir. VTYS de bu komutları çalıştırır. VTYS komutun sonuçları 
    hakkında programcıyı bilgilendirmektedir. Örneğin SQL komutu bir SELECT komutu ise VTYS bize SELECT cümlesinde istenen bilgileri 
    verecektir. 
    
    3) VTYS bağlantısı sonlandırılır. 

    VTYS'lerin client-server haberleşmede kullandıkları uygulama katmanı protokolleri farklıdır. Bu protokollerin aşağı seviyeli biçimde 
    uygulanması programcılariçin çok zordur. Dolayısıyla programcıların işlerini kolaylaştırmak için çeşitli yüksek seviyeli kütüphaneler 
    oluşturulmuştur. Genel olarak bu tür kütüphanelere VTYS terminolojisinde "connector" denilmektedir. Python'un yalnızca SQLite için 
    standart kütüphanesinde hazır bir modül bulundurmuştur. Başka bir deyişle Python'un standart kütüphanesinde SQLite için "connector" 
    hazır biçimde bulunmaktadır. Ancak MySql, SQlServer, Oracle, Postgre gibi VTYS'lerin connector'leri Python Standart Kütüphanesinde 
    bulunmamaktadır. Bu VTYS'lerle çalışmak isteyen programcıalrın connector'leri indirerek kurması gerekmektedir. 

    Pekiyi üçüncü parti kütüphane durumunda olan bu VTYS connector'leri kimler tarafından yazılmaktadır? Aslında genellikle connector'ler 
    VTYS'leri oluşturan kurumlar tarafından yazılırlar. Ancak bu bir kural değildir. Örneğin MySQL için farklı connector kütüphaneler 
    vardır. MySQL için connector aşağıdaki gibi pip komutuyla indirilip kurulabilir:

    pip install mysql-connector-python

    Ya da örneğin SqlServer için connector de şöyle indirilebilir:

    pip install pyodbc

    Genel olarak VTYS'ler için Python connector'lerini yazanlar API tasarımını standart kütüphanedeki SQLite sınıflarını temel alarak 
    yapmaktadırlar. Yani örneğin işlemlerin genel yapılış biçimleri bakımındamn SQLite ile MySQL arasında ya da SqlServer arasında 
    önemli farklılıklar yoktur. Çünkü bu kütüphaneleri yazanlar API tasarımını standart kütüphanedeki "sqlite3" modülündekine benzetmişlerdir. 

    SQLite modülünün dokümantasyonu "Python Standard Library" içerisinde yaplımıştır. Bu dokümantasyona aşağıdaki bağlantıdan 
    erişebilirsiniz:

    https://docs.python.org/3/library/sqlite3.html
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da SQLite ile işlemler tipik olarak şu adınmlardan geçilerek yapılmaktadır:

    1) Önce sqlite3 modülü import edilir. Örneğin:

    import sqlite3

    2) Bundan sonra sqlite3 modülündeki connect fonksiyonu çağrılarak VTYS ile bağlantı sağlanır. (Tabii aslında SQLite gerçek bir 
    VTYS değildir. Ancak API tasarımı sanki SQLite da bir VTYS imiş gibi yapılmıştır.) connect fonksiyonun parametrik yapısı şöyledir:

    sqlite3.connect(database, timeout=5.0, detect_types=0, isolation_level='DEFERRED', check_same_thread=True, 
        factory=sqlite3.Connection, cached_statements=128, uri=False, *, autocommit=sqlite3.LEGACY_TRANSACTION_CONTROL)
    
    Görüldüğü gibi fonksiyonun birinci parametresinin dışındaki parametrelerin hepsi default değer almıştır. Birinci parametre SQLite 
    veritabanı dosyasının yol ifadesini belirtmektedir. Eğer bu parametre için var olmayan bir dosyanın yol ifadesi girilirse o dosya 
    bir SQLite veritabanı dosyası biçiminde oluşturulmaktadır. connect fonksiyonu bize sqlite3 modülü içerisinde bulunan Connection 
    isimli bir sınıf türünden bir nesne vermektedir. Diğer işlemler artık bu Connection nesnesi ile yapılır. Örneğin:

    conn = sqlite3.connect('school.sqlite')

    connect fonksiyonuna biz geçersiz dizin içeren yol ifadesi verirsek connect fonksiyonu exception fırlatmaktadır.

    3) sqlite3.Connection sınıfının cursor isimli metodu çağrılarak sqlite3.Cursor sınıfı türünden bir cursor nesnesi elde edilir. 
    Örneğin:

    cur = conn.cursor()

    Programcı geri kalan işlerini bu cursor nesnesi ile görür. Cursor sınıfının execute ve executemany isimli metotları SQL cümlesini 
    VTYS'ye göndererek ona işlettirmektedir. execute metodunun parametrik yapısı şöyledir:

    execute(sql, parameters=(), /)

    Metodun birinci parametresi işletilecek SQL cümlesini belirtmektedir. İkinci parametresi ise ileride ele alacak olduğumuz komut 
    parametrelerine ilişkindir. Örneğin:

    cur.execute("INSERT INTO student(student_no, student_name, school_id) VALUES(1783, 'Abit Süzülmüş', 1)")

    execute metodunda verdiğimiz SQL cümlesi geçersiz ise metot exception fırlatmaktadır. execute komutu ile biz veritabanı üzerinde 
    bir değişiklik yapıyorsak bu değişiklik Connection sınıfının commit metodu çağrılmadan henüz veritabanına yansıtılmaz. Bu nedenle 
    yukarıdaki örnekte "INSERT INTO" SQL komutuyla veritabanına kayıt eklenmiş olsa bile bu ekleme henüz gerçek anlamda yapılmamaktadır. 
    İşlemlerin veritabanına gerçek anlamda yansıtılması için Connection sınıfının commit metodu çağrılmalıdır. commit metodu parametresizdir 
    (yani yalnızca self parametresi vardır). Örneğin:

    conn.commit()

    4) İşlemler bittikten sonra VTYS bağlantısı Connection sınıfının close metoduyla kapatılır. Örneğin:

    conn.close()

    5) Birtakım problemli durumlarda metotlar sqlite3 içerisindeki çeşitli exception sınıflarıyla exception fırlatırlar. Bu exception 
    sınıflarının hepsi sqlite3.Error isimli sınıftan türetilmiş durumdadır. O halde programcı oluşabilecek exception'ları da dikkate 
    alarak kodunu organize etmelidir. Tabii VTYS bağlantısının her durumda kapatılması gerekir. Bu nedenle close metodu tipik olarak 
    try, except bloklarının finally bölümünde çağrılır. Örneğin:

    import sqlite3

    conn = None
    try:
        conn = sqlite3.connect('school.sqlite')
        cur = conn.cursor()
        
        cur.execute("INSERT INTO student(student_no, student_name, school_id) VALUES(1783, 'Abit Süzülmüş', 1)")
        conn.commit()  
    except sqlite3.Error as e:
        print(e)
    finally:
        if conn:
            conn.close()

    Connection sınıfı "bağlam yönetim protokolünü (context management protocol)" desteklemektedir. Dolayısıyla with deyimi ile kullanılabilir. 
    Sınıfın __exit__ metodu zaten bağlantıyı kapatmaktadır. O halde biz yukarıdaki kodu with deyimi ile şöyle de organize edebiliriz:

    import sqlite3

    try:
        with sqlite3.connect('school.sqlite') as conn:
            cur = conn.cursor()
            cur.execute("INSERT INTO student(student_no, student_name, school_id) VALUES(1783, 'Abit Süzülmüş', 1)") 
            conn.commit()
    except sqlite3.Error as e:
        print(e)

    Tabii aslında biz SQL komut yazısını Python'da oluşturup execute metodunu çağırabiliriz: 

    import sqlite3

    try:
        with sqlite3.connect('school.sqlite') as conn:
            cur = conn.cursor()
            while True:
                no = int(input('No:'))
                if no == 0:
                    break
                name = input('Adı Soyadı:')
                school_id = input("Okul id'si:")
                cmd = f"INSERT INTO student(student_no, student_name, school_id) VALUES({no}, '{name}', {school_id})"
                cur.execute(cmd)
                conn.commit()
    except sqlite3.Error as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    SQL SELECT cümlesinin Python'da uygulanması üzerinde ayrıca durmak gerekir. Çünkü SELECT cümlesi ile biz VTYS'den kayıt çekmekteyiz. 
    SELECT cümlesi yine diğer cümlelerde olduğu gibi Cursor sınıfının execute metodu ile işletilir. Kayıtlar Cursor sınıfının fetchone 
    ve fetchmany isimli metotlarıyla elde edilmektedir. fetchone metodu koşulu sağlayan kayıtlardan yalnızca bir tanesini, fetchmany 
    ise n tanesini elde etmekte kullanılmaktadır. Tabii bu metotlar birden fazla kez çağrılabilirler. fetchone kaydı tek bir demet olarak 
    fetchmany ise kayıtları bir demet listesi olarak varmektedir. Demetlerin elemanları SELECT komutunda belirtilen sütun sıralarına
    göredir. 

    execute metodu ile SELECT komutu uygulandığında execute metodu select edilen tüm kayıtları VTYS'den transfer etmeyebilir. Genellikle 
    bu amaçla kullanılan kütüphaneler belirli miktardaki kaydı VTYS'den çekip bir tamponda saklamaktadır. İşte fetch metotları da her
    çağrıldığında aslında bu tampondan kayıtları vermektedir. Tabii tamponda kayıt kalmadığında arka planda tampon yeniden doldurulmaktadır.
    Bu mekanizma Cursor nesnesi tarafından arka planda sağlandığı için biz bir döngü içerisinde fetchone ve fetchmany çağrılarıyla
    tüm select edilen kayıtları elde edebiliriz. Örneğin:

    import sqlite3
    try:
        with sqlite3.connect('student.db') as conn:
            cur = conn.cursor()       
            sqlcmd = "SELECT student_name, student_no, student_school_id FROM student_info"       
            cur.execute(sqlcmd)
            while t := cur.fetchone():
                name, no, school_id = t
                print(name, no, school_id)
    except sqlite3.Error as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('student.db') as conn:
        cur = conn.cursor()       
        sqlcmd = "SELECT student_name, student_no, student_school_id FROM student_info"       
        cur.execute(sqlcmd)
        while t := cur.fetchone():
            name, no, school_id = t
            print(name, no, school_id)
except sqlite3.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz SELECT ile join işlemi de yapabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('student.db') as conn:
        cur = conn.cursor()       
        sqlcmd = "SELECT student_name, student_no, school_name, school_city FROM student_info, school_info WHERE student_school_id = school_id"       
        cur.execute(sqlcmd)
        while t := cur.fetchone():
            print(t)
except sqlite3.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi SELECT eedilen kayıtlar Cursor sınıfının fetchmany isimli metoduyla da n'er n'er elde edilebilir. 
    Metodun parametrik yapısı şöyledir:

    fetchmany(size=cursor.arraysize)

    Burada cursor sınıfının arraysize isimli property elemanı default olarak 1 değerindedir. Dolayısıyla metoda parametre geçilmezse 
    sanki 1 değeri geçilmiş gibi işlem görür. fetchmany metodu bize n tane kaydı bir demet listesi biçiminde vermektedir. Tabii 
    eğer elde n taneden daha az kayıt kalmışsa metot bize kalan kaydın hepsini verecektir. Tüm kayıtlar elde edildikten sonra fetchmany 
    metodu boş bir listeye geri dönmektedir. Örneğin:

    while  rows := cur.fetchmany(5):
        print(rows)

    burada fetchmany metodu her çağrıda 5 tane kaydı bir demet listesi biçiminde verecektir. Tabii son listede 5 tane kayıt olmak 
    zorunda değilfitr. Örneğin:

    try:
        with sqlite3.connect('student.db') as conn:
            cur = conn.cursor()       
            sqlcmd = "SELECT student_name, student_no FROM student_info WHERE student_no > 600"       
            cur.execute(sqlcmd)
            while  rows := cur.fetchmany(3):
                for name, no in rows:
                    print(name, no)
    except sqlite3.Error as e:
        print(e)

    Burada bir döngü içerisinde fetchmany metodu çağrılmıştır. fetchmany bize satırları üçer elemanlı listeler biçiminde verecektir. 
    Biz de bu listeyi demet açımı yaparak dolaştık.

    Aşağıda SELECT edilen tüm kayıtları fetchmany metodu ile alıp ekrana yazdıran bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('student.db') as conn:
        cur = conn.cursor()       
        sqlcmd = "SELECT student_name, student_no FROM student_info WHERE student_no > 600"       
        cur.execute(sqlcmd)
        while  rows := cur.fetchmany(3):
            for name, no in rows:
                print(name, no)
except sqlite3.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Cursor sınıfının fetchall isimli metodu parametresizdir. Çağrıldığında tüm SELECT edilmiş olan kayıtların hepsi bir demet listesi 
    biçiminde elde edilmektedir. Eğer SELECT edilen hiçbir kayıt yoksa fetchall metodu boş listeye geri dönmektedir. Örneğin:

    try:
        with sqlite3.connect('student.db') as conn:
            cur = conn.cursor()       
            sqlcmd = "SELECT student_name, student_no FROM student_info WHERE student_no > 600"       
            cur.execute(sqlcmd)
            for name, no in cur.fetchall():
                print(name, no)
    except sqlite3.Error as e:
        print(e)

    Biz burada fetchall metodu ile select edilen kayıtların hepsini tek hamlede elde edip onları dolaştık

    fetchone, fetchmany ve fetchall metotları birlikte de kullanılabilir. Örneğin SELECT işlemi sonrasında önce bir fetchone yapıp 
    tek kayıt elde edilebilir, sonra fetchmany yapılıp birkaç kayıt daha elde edilebilir. Sonra da fetchall yapılıp geri kalan tüm 
    kayıtlar elde edilebilir. 

    Aşağıda fetcall metodunun kullanımına ilişkin bir örnek verilmiştir.                                    
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('student.db') as conn:
        cur = conn.cursor()       
        sqlcmd = "SELECT student_name, student_no FROM student_info WHERE student_no > 600"       
        cur.execute(sqlcmd)
        for name, no in cur.fetchall():
            print(name, no)
            
except sqlite3.Error as e:
    print(e)
s
#------------------------------------------------------------------------------------------------------------------------------------
    Aslında Cursor nesnesinin kendisi de "iterator" nesnesi olarak kullanılabilektedir. Yani biz Cursor nesnesini for döngüsü ile 
    dolaştığımızda yine tek tek kayıtları elde edebilriz. Örneğin:

    try:
        with sqlite3.connect('student.db') as conn:
            cur = conn.cursor()       
            sqlcmd = "SELECT student_name, student_no FROM student_info WHERE student_no > 600"       
            for name, no in cur.execute(sqlcmd):
                print(name, no)                        
        except sqlite3.Error as e:
            print(e)
                                    
    Cursor nesnesi bir kez dolaşıldıktan sonra yeniden dolaşılamaz. Çünkü artık dolaşımın sonuna gelinmiştir. Cursor nesnesi ile 
    dolaşmak yerine fetchone, fatchmany ya da fetchall metotlarını kullanmak çoğu kez daha uygun olur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                10. Ders 06/04/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Cursor nesnesi kullanıldıktan sonra Cursor sınıfının close metodu ile onun tuttuğu kaynaklar boşaltılıp kapatılabilir. Ancak 
    açıkça kapatma yapılmadığı durumda Cursor nesnesi çöp durumuna geldiğinde sınıfın __del__ metodu yoluyla zaten nesnenin kaynakları
    boşaltılıp kapatma işlemi yapılmaktadır. Dolayısıyla çoğu durumda Cursor nesnesinin kapatılmaması bir soruna yol açmamaktadır. Cursor 
    nesneleri "bağlam yönetim protokolüne (resource management protocol)" uymamaktadır. Dolayısıyla Cursor nesnelerini with deyimi ile 
    kullanamayız. 
    
    Programcı birden fazla Cursor nesnesi ile çalışabilir. Connection sınıfının cursor metodu her çağrıldığında yeni bir Cursor nesnesi 
    elde edilmektedir. Aslında execute metodu (executemany ve executescript metotları da) Cursor nesnesinin kendisine geri dönmektedir. 
    Aşağıdaki gibi bir döngü geçerlidir:

    for name, no, school_id in conn.cursor().execute("SELECT * FROM student"):
        print(name, no, school_id)

    Burada conn.cursor() çağrısı bize bir Cursor nesnesi verir. Sonra o nesne ile execute metodunu çağırdığımızda Cursor nesnesinin 
    yine kendisini elde ederiz. İşte biz de yukarıdaki örnekte bu Cursor nesnesini dolaşmış olmaktayız. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    INSERT, UPDATE, DELETE işlemleri sonucunda bu işlemlerden etkilenen kayıt sayısı Cursor sınıfının rowcount isimli örnek özniteliğinden
    elde edilebilmektedir. Örneğin biz DELETE komutu ile bir grup kaydı sildiğimizde rowcount bize silinen kayıtların sayısını verecektir. 
    rowcount örnek özniteliği SELECT komutu uygulandığında set edilmemektedir. Yani biz SELECT edilen satırların sayısını rowcount ile
    elde edemeyiz. 
    
    Aşağıdaki örnekte biz veritabanına 1 kayıt insert ediyoruz. Dolayısıyla rowcount bize 1 değerini verecektir.                                           
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()
        cur.execute("INSERT INTO student(student_no, student_name, school_id) VALUES(2145, 'Fehmi Özışık', 2)")
        print(cur.rowcount)     # 1
        conn.commit()
except sqlite3.Error as e:
    print(e)
  
#------------------------------------------------------------------------------------------------------------------------------------
    Cursor sınıfının connection isimli örnek özniteliği bize o Cursor nesnesinin yaratıldığı connection nesnesini vermektedir. Bu 
    sayede eğer elimizde bir Cursor nesnesi varsa biz connection nesnesini de elde edebiliriz. Böylece bizim bir fonksiyona hem Cursor 
    nesnesini hem de Connection nesnesini paramete olarak geçirmemize gerek kalmaz. Zaten Cursor nesnesinden hareketle Connection 
    nesnesini elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def insert_record(cur, student_no, student_name, school_id):
    sqlcmd = f"INSERT INTO student(student_no, student_name, school_id) VALUES({student_no}, '{student_name}', {school_id})"
    cur.execute(sqlcmd)
    cur.connection.commit()

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()       
        
        student_no = int(input('No:'))
        student_name = input('Adı Soyadı:')
        school_id = int(input('School Id:'))
        
        insert_record(cur,  student_no, student_name, school_id)
    
except sqlite3.Error as e:
    print(e)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla tablo ile ilgili INSERT işlemleri yapılırken dikkatli olmak gerekir. Örneğin "student" tablosunun bir sütunu "school_id"
    biçiminde olsun. Bu sütunun da "school" tablosunun bilgilerine erişmek için "foreign key" olarak kullanıldığını düşünelim. Biz şimdi 
    bir öğrenciyi INSERT ederken school tablosunda olmayan bir school_id girmemeliyiz. Bu tür kontoller şüphesiz manuel biçimde school 
    tablosu sorgulanarak yapılabilir. Ancak VTYS'ler bu tür işlemleri kendi içlerinde yapabilmektedir. Bunlara "yabancı anahtar kısıtları
    (foreign key constraints)" denilmektedir. Yabancı anahtar kısıtları tablo yaratılırken CREATE TABLE komutunda komutun sonunda belirtilmektedir. 
    VTYS'ler arasında bu konuda farklılıklar bulunmaktadır. Örneğin SQLite'ta CREATE TABLE komutunda komutun sonuna aşağıaki gibi kısıt 
    girilebilir:

    CREATE TABLE student (
        .....
        FOREIGN KEY (school_id) REFERENCES school(school_id) 
    )

    Burada student tablosunaki school_id sütunu school tablosundaki school_id sütunu ile "foreign key" temelinde ilişkilendirilmiştir. 
    Artık biz bir örenciyi eklerken school tablosunda olmayan bir scool_id girersek işlme başarısızlıkla sonuçlanacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı tablolarda bazı sütunlar "yabancı anahtar (foreign key)" durumundadır. Öğrenğin school tablosunun school_id elemanı hem 
    PRIMARY KEY durumundadır hem de student tablosu için FOREIGN KEY durumundadır. school tablosuna bir okul eklerken ekleyen kişinin 
    school_id vermesi zor bir kullanımdır. İşte bu tür durumlarda anımsanacağı gibi ilgili sütuna AUTOINCREMENT özelliği verilebilmektedir. 
    AUTOINCREMENT bir sütun söz konusu olduğunda eğer INSERT işleminde bu sütun belirtilmezse bu durumda VTYS en büyük numaranın bir 
    fazlasını almaktadır. SQLite'ta aslında PRIMARY KEY olan tamsayı alanları aynı zamanda AUTOINCREMENT durumdadır. Ancak uygulamacı 
    AUTOINCREMENT belirlemesini yine yapabilir.                                            
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen veritabanı üzerinde birbirleriyle ilişkili olan işlemler yapılıyor olabilir. Bu tür işlemlerin "ya hep ya hiç" biçiminde 
    gereçekleştirilmesi gerelebilmektedir. İşte VTYS'lerde bir grup eylemin sanki tek bir eylemmiş gibi peşi sıra gerçekleştirilmesine 
    "transaction" denilmektedir. Örneğin bir grup bilginin birbirleriyle tutarlı bir biçimde üç farklı tabloya insert edilmek istendiğini
    düşünelim. Biz bu üç insert işlemi başarılıysa en sonunda commit yaparak bu işlemlerin veritabanına yansıtılmasını isteriz. Örneğin:

    INSERT INTO ...
    INSERT INTO ...
    INSERT INTO ...
    COMMIT

    Pekiyi bu işlemlerin herhangi birinde bir sorun çıkarsa ne olacaktır? Genel olarak bu tür sorunlarda exception oluşacağı için akış 
    commit işlemini görmeyecektir. Dolayısıyla değişikliklerin hiçbiri veritabanına yansıtılmayacaktır. Ancak exception'a yol açmayan 
    önceki INSERT INTO işlemleri eğer geri alınmazsa ilk commit işleminde veritabanına yansıtılır ki bunun sonucunda ilgili bilgi 
    tutarsız bir biçimde tablolara eklenmiş olur. İşte peşi sıra gerçekleştirilen bir grup işlemde bir işlem başarısız olduğunda önceki 
    başarılı olan işlemlerin de geri alınmasına "rollback" denilmektedir. Rollback işlemi Connection sınıfının rollback isimli metoduyla 
    yapılmaktadır. rollback metodunun self parametresinin dışında parametresi yoktur. Eğer rollback metodu çağrıldığında hiçbir transaction 
    içerisinde bulunulmuyorsa metodun bir etkisi olmaz. 

    Yukarıda da belirttiğimiz gibi VTYS'lerde bir grup komutun sanki tek komutmuş gibi "atomik" olarak işletilmesine "transaction" 
    denilmektedir. Eskiden VTYS'ler transcation işlemlerini desteklemiyordu. Sonra VTYS'ler bu özelliklere sahip oldular. Bugün SQLite da 
    dahil olmak üzere VTYS'lerin hemen hepsi "transaction" işlemlerini desteklemektedir. Pek çok VTYS'de transaction işlemleri SQL ile 
    de desteklenmektedir. Tipik olarak transaction BEGIN ya da BEGIN TRANSACTION gibi bir SQL komutuyla başlatılır. Eğer bir sorun oluşmazsa 
    COMMIT işlemi sorun oluşursa ROLLBACK işlemi yapılır. Örneğin:

    BEGIN TRANSACTION;
    BEGIN TRY
        INSERT INTO tablo_adı (kolon1, kolon2) VALUES (değer1, değer2);
        INSERT INTO tablo_adı (kolon1, kolon2) VALUES (değer3, değer4);
        INSERT INTO tablo_adı (kolon1, kolon2) VALUES (değer5, değer6);
        COMMIT;
    END TRY
    BEGIN CATCH
        ROLLBACK;
    END CATCH;

    SQL'deki transaction komutları VTYS'den VTYS'ye farklılıklar gösterebilmektedir. 

    Python'da biz çoğu kez transaction'ları SQL komutlarıyla değil metotlarla oluşutururuz. Cursor sınıfının "execute" ve "executemany" 
    isimli metotları eğer bir transaction başlatılmamışsa otomatik olarak transaction'ı başlatılırlar. Yani bizim transaction'ı başlatmak 
    için Python programcısı olarak SQL komutu kullanmamıza ya da özel bir işlem yapmamıza gerek yoktur. Bu durumda tipik bir transaction 
    Python'da şöyle yürütülmelidir:

     try:
        cur.execute(...)
        cur.execute(...)
        cur.execute(...)
        cur.commit()
    except sqlite3.Error as e:
        conn.rollback()

    Özel bir durum olarak execute işleminde eğer SELECT komutu uygulanmışsa bu durumda transcation otomatik başlatılmamaktadır. 

    Transaction kavramı ve rollback işlemi birden fazla INSERT, UPDATE ve DELETE komutlarının peşi sıra geldiği durumlarda önemli 
    olmaktadır. Yoksa tek bir INSERT, UPDATE ya da DELETE komutu için rollback uygulamaya gerek yoktur. Yukarıda da belirttiğimiz gibi 
    rollback işlemi bir grup peşi sıra yapılan işlemin bir tanesi başarısız ise onların hiçbirini yapmamayı sağlamaktadır. commit işlemi 
    ise onların hepsini tek bir işlemmiş gibi atomik yapmayı sağlar.    
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Cursor sınıfının executescript isimli metodu birden fazla SQL cümlesini alarak onları tek tek çalıştırmaktadır. Yani örneğin biz 
    5 kayıt insert edeceksek onları ayrı ayı INSERT INTO komutu oluşturup execute metodu ile insert etmek yerine tek hamlede executescript
    metodu ile insert edebiliriz. Örneğin:

    cur.executescript("""
        CREATE TABLE school (school_id INTEGER PRIMARY KEY AUTOINCREMENT, school_name TEXT(64), school_type TEXT(64));
        CREATE TABLE student(student_no INTEGER, student_name VARCHAR(64), school_id    INTEGER, 
                FOREIGN KEY("school_id") REFERENCES "school"("school_id"), PRIMARY KEY("student_no" AUTOINCREMENT));    
    """)             

    Biz executescript metodu otomatik transaction başlatmamaktadır. Eğer bu metot ile transcation yapılacaksa SQL komutunun içerisine 
    transaction'ı başlatan BEGIN (ya da BEGIN TRANSACTION) komutu eklenmelidr. Örneğin:

    cur.executescript("""
        BEGIN TRANSACTION;
        CREATE TABLE person(firstname, lastname, age);
        CREATE TABLE book(title, author, published);
        CREATE TABLE publisher(name, address);
        COMMIT;
    """)      

    Burada biz üç farklı tablo yaratmak istedik. Eğer bu üç tablonun hepsi yaratılırsa SQL içerisinde commit işlemi yapılmıştır. 
    Eğer burada bu komutlardan herhangi birinde bir sorun oluşursa bu durumda exception fırlatılır biz de bu exception içerisinde 
    rollback yapabiliriz. Örneğin:

    try:
        cur.executescript("""
        BEGIN;
        CREATE TABLE person(firstname, lastname, age);
        CREATE TABLE book(title, author, published);
        CREATE TABLE publisher(name, address);
        COMMIT;
    """)      
    except sqlite3.Error as e:
        conn.rollback()

    Tabii yukarıda da belirttiğimiz gibi execute, executemany metotları zaten otomatik trnsaction oluşturmaktadır. Python programcıları 
    da genellikle commit ve rollback gibi işlemleri SQL komutlarının içerisinde değil metot çağrılarıyla yapmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('test.sqlite') as conn:
        cur = conn.cursor()       
        cur.executescript("""
          CREATE TABLE person(person_id INTEGER PRIMARYKEY AUTO_INCREMENT person_name VARCHAR(20), person_no INTEGER);
          CREATE TABLE book(book_id INTEGER PRIMARYKEY AUTO_INCREMENT book_title VARCHAR(128), book_author VARCHAR(128));
          CREATE TABLE WRONG_COMMAND publisher(name, address);
          """)               
except sqlite3.Error as e:
    conn.rollback()
    print(e)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir uygulamada eğer veritabanı zaten yoksa onu yaratan kodlar da uygulamanın içerisinde bulundurulabilir. Yukarıda da belirttiğimiz 
    gibi connect isimli fonksiyon SQLite'ta eğer veribanı dosyası varsa olanı açmakta yoksa içi boş olarak sıfırdan yaratmaktadır. Veritabanı 
    tabloları yaratılırken eğer tablo zaten varsa exception oluşur. Ancak CREATE TABLE komutuna IF NOT EXISTS cümleceği eklenirse eğer 
    tablo varsa komut etki göstermez ancak tablo yoksa yaratılır. Örneğin:

    def create_tables(cur):
        cur.executescript("""
            CREATE TABLE IF NOT EXISTS school (school_id INTEGER PRIMARY KEY AUTOINCREMENT, school_name TEXT(64), school_type TEXT(64));
            CREATE TABLE IF NOT EXISTS student(student_no INTEGER, student_name VARCHAR(64), school_id    INTEGER,
                    FOREIGN KEY("school_id") REFERENCES "school"("school_id"), PRIMARY KEY("student_no" AUTOINCREMENT));    
        """)   

    Burada create_tables fonksiyonu veritabanı tablolarını yaratmaktadır. Ancak tablolar zaten yaratılmışsa buradaki komutların bir 
    etkisi olmayacaktır.                                          
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        11. Ders 12/04/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda "school" veritabanı üzerinde temel işlemler yapan konsol tabanlı basit bir program örneği verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def create_tables(cur):
    try:
        script = """
            BEGIN;
            CREATE TABLE IF NOT EXISTS school(school_id INTEGER PRIMARY KEY AUTOINCREMENT, school_name VARCHAR(128), school_city VARCHAR(32));
            CREATE TABLE IF NOT EXISTS student(student_id INTEGER PRIMARY KEY AUTOINCREMENT, student_no INTEGER,
                   student_name VARCHAR(64), school_id INTEGER);
        """
        cur.executescript(script)
    except Exception as e:
        print(e)
    
def disp_menu(items_list):
    while True:
        for menu_no, (menu_item, _) in enumerate(items_list, 1):
            print(f'{menu_no}) {menu_item}')
        print()
        try:
            option = int(input('Seçiminiz:'))
            if option >= 1 and option <= 9:
                break
        except:
            pass
        print('\nGeçersiz seçenek!..\n')
    
    return option

def add_school(cur):
    try:
        school_name = input('Okul ismi:').strip()
        if school_name == '':
            raise ValueError('Okulş ismi boş girilemez')
        school_city = input('Okulun bulunduğu şehir:').strip()
        if school_city == '':
            raise ValueError('Şehir boş girilemez')
        sql_cmd = f"INSERT INTO school(school_name, school_city) VALUES('{school_name}', '{school_city}')"
        cur.execute(sql_cmd)
        cur.connection.commit()
        print('\nOkul başarılı bir biçimde eklendi...\n')
    except sqlite3.Error as e:
        print(f'Eklemede sorun oluştu: {e}\n')
    except Exception as e:
        print(f'Hatalı giriş: {e}\n')
        
    return True
    
def add_student(cur):
    try:
        student_name = input('Öğrencinin adı:').strip()
        if student_name == '':
            raise ValueError('Öğrenci boş girildi')
        student_no = int(input('Öğrencinin numarası:'))
        school_id = int(input("Öğrencinin okul Id'si:"))
        sql_cmd = f"INSERT INTO student(student_name, student_no, school_id) \
                VALUES('{student_name}', {student_no}, {school_id})"
        cur.execute(sql_cmd)
        cur.connection.commit()
        print('\nÖğrenci başarılı bir biçimde eklendi...\n')
        
    except sqlite3.Error as e:
        print(f'Eklemede sorun oluştu: {e}\n')
    except Exception as e:
        print(f'Hatalı giriş: {e}\n')
        
    return True
    
def list_student(cur):
    try:
        condition = input('Öğrenci için koşul:').strip()
        sql_cmd = "SELECT student_id, student_name, student_no, school_name, school_city \
                    FROM student, school WHERE student.school_id = school.school_id"
        
        if condition != '':
            sql_cmd += f" AND {condition}"
        cur.execute(sql_cmd)
            
        print()
        print(f"{'İd':5s}{'Adı Soyadı':20s}{'No':<5s}{'Okul İsmi':<30s}{'Şehir'}")
        print('-' * 80)
                        
        for student_id, student_name, student_no, school_name, school_city in cur.fetchall():
            print(f'{student_id:<5d}{student_name:20}{student_no:<5d}{school_name:<30s}{school_city}')
        
        print('-' * 80)
        print()
                
    except sqlite3.Error as e:
        print(f'Aramada sorun oluştu: {e}\n')
    except Exception as e:
        print(f'Hatalı giriş: {e}\n')   
        
    return True
 
def erase_student(cur):
    try:
        student_id = int(input("Silinecek öğre3ncinin id'si:"))
        sql_cmd = f"""SELECT student_id, student_name, student_no, school_name, school_city FROM student, school 
                        WHERE student_id = {student_id} AND student.school_id = school.school_id"""
        cur.execute(sql_cmd)
        t = cur.fetchone()
        if t is None:
            print("\nBu id'ye ilişkin bir öğrenci yok!\n")
            return
        student_id, student_name, student_no, school_name, school_city = t
        print(f'\n{student_id:<5d}{student_name:20}{student_no:<5d}{school_name:<30s}{school_city}\n')
        confirm = input('Yukarıdaki öğrenciyi silmek istediğine emin misiniz (E)/(H):').lower()
        if confirm == 'e':
            sql_cmd = f"DELETE FROM student WHERE student_id = {student_id}"
            cur.execute(sql_cmd)
            cur.connection.commit()
            print('\n1 kayır silindi...\n')
        else:
            print()
    except sqlite3.Error as e:
        print(f'Aramada sorun oluştu: {e}\n')
    except Exception as e:
        print(f'Hatalı giriş: {e}\n')   
        
    return True
           
def list_school(cur):
    try:
        condition = input('Okul için koşul:').strip()
        sql_cmd = "SELECT school_id, school_name, school_city FROM school";
        
        if condition != '':
            sql_cmd += f" WHERE {condition}"
        cur.execute(sql_cmd)
        
        print()
        print(f"{'id':<5s}{'Okul İsmi':<40s}{'Şehir'}")
        print('-' * 80)
        
        for school_id, school_name, school_city in cur.fetchall():
            print(f'{school_id:<5d}{school_name:<40s}{school_city}')
        
        print('-' * 80)
        print()
                
    except sqlite3.Error as e:
        print(f'\nListelemede sorun oluştu: {e}\n')
    except Exception as e:
        print(f'\nHatalı giriş: {e}\n')   
    return True
        
def erase_school(cur):
    try:
        school_id = int(input("Silinecek okulun id'si:"))
        sql_cmd = f"SELECT school_id, school_name, school_city FROM school WHERE school_id = {school_id}"
        cur.execute(sql_cmd)
        t = cur.fetchone()
        if t is None:
            print("\nBu id'ye ilişkin bir okul yok!\n")
            return
        school_id, school_name, school_city = t
        print(f'\n{school_id:<5d}{school_name:<40s}{school_city}\n')
        
        confirm = input('Bir okulu sildiğiniz zaman o okuldaki tüm öğrencileri de silersiniz' + \
                        'Yukarıdaki okulu silmek istediğine emin misiniz (E)/(H):').lower()
        if confirm == 'e': 
            try:
                sql_cmd = f"""
                    BEGIN TRANSACTION;
                    DELETE FROM student WHERE school_id = {school_id};
                    DELETE FROM school WHERE school_id = {school_id};
                    COMMIT;
                """
                cur.executescript(sql_cmd)
            except sqlite3.Error as e:
                cur.connection.rollback()
                print(f'Silme işleminde hata oluştu: {e}\n')   
            print('\n1 kayıt silindi...\n')
        else:
            print()
       
    except sqlite3.Error as e:
        print(f'Aramada sorun oluştu: {e}\n')
    except Exception as e:
        print(f'Hatalı giriş: {e}\n')   
    
    return True

def exit_prog(cur):
    return False

def main():
    items_list = [
        ('Okul ekle', add_school), 
        ('Öğrenci ekle', add_student), 
        ('Öğrenci listele', list_student),
        ('Okul listele', list_school),
        ('Öğrenci sil', erase_student), 
        ('Okul sil', erase_school),
        ('Çıkış', exit_prog),
        ]
    
    try:
        with sqlite3.connect('school.sqlite') as conn:
            cur = conn.cursor()
            create_tables(cur)
            while True:
                option = disp_menu(items_list)
                _, f = items_list[option - 1]
                if not f(cur):
                    break
                                
    except sqlite3.Error as e:
        print(f'DB Error: {e}')
    except Exception as e:
        print(e)
    
main()
    
#------------------------------------------------------------------------------------------------------------------------------------
                                                12. Ders 13/04/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pek çok VTYS kütüphanesi SQL komutlarında "yer tutucu" ya da başka bir deyişle "parametre" kullanımına izin vermektedir. Python'da
    yer tutucular iki biçimde kullanılmaktadır: "?" biçiminde ya da ":isim" biçiminde. "?" yer tutucusu isimsizdir. Ancak ":isim" yer 
    tutucusu isimlidir. Bu yer tutucular komut içerisinde bir öğe gibi kullanılabilirler. Örneğin:

    sqlcmd = "INSERT INTO student(student_no, student_name) VALUES(?, ?)"

    Burada ilk "?" student_no için yerleştirilecek değeri, ikinci "?" ise student_name için yerleştirilecek değeri belirtmektedir. Aynı 
    komut şöyle de oluşturulabilirdi:

    sqlcmd = "INSERT INTO student(student_no, student_name) VALUES(:no, :name)"

    Burada :no yer tutucusu student_no için, :name yer tutucusu ise student_name için yerleştirilecek değeri belirtmektedir. Pekiyi bu 
    yer tutuculara değerleri nasıl yerleştirilmektedir? İşte aslında Cursor sınıfının execute metodu işletilecek SQL cümlesinin yanı 
    sıra ikinci parametresi ile yer tutuculara yerleştirilecek değerleri de bizden istemektedir. Eğer yer tutucular "?" işareti ile
    belirtilmişse bu durumda execute metodunun ikinci parametresi bir demet ya da liste olmalıdır. Demet ya da liste içerisindeki 
    elemanlar sırasıyla SQL komutundaki "?" yer tutucularının yerine yerleştirilmektedir. Örneğin:

    sqlcmd = "INSERT INTO student(student_no, student_name, school_id) VALUES(?, ?, ?)";
    cur.execute(sqlcmd, (523, 'Rasim Özcan', 3))
    conn.commit()

    Burada 525 değeri ilk "?" yerine, "Rasim Özcan" değeri ikinci "?" yerine ve 3 değeri ise üçüncü "?" yerine yerleştirilir. execute 
    metodu bu yerleştirmeyi yaptıktan sonra komutu VTYS'ye göndermektedir. Yerleştirme yapıldıktan sonra SQL komutu şu hale gelecektir:

    "INSERT INTO student(student_no, student_name, school_id) VALUES(523, 'Rasim Özcan', 3)"

    Yazsısal değerlerin SQL komutunda tek tırnak içerisine alınmasını execute metodu zaten sağlamaktadır. 

    Eğer yer tutucular isimliyse bu durumda execute metodunun ikinci parametresi bir sözlük nesnesi olmak zorundadır. Sözlüğün anahtarları 
    yer tutucuların isimlerinden değerleri ise ter tutuculara yerleştirilecek değerlerden oluşur. Tabii artık yer tutucuların girilme 
    sırasının bir önemi kalmamaktadır. Örneğin:

    sqlcmd = "INSERT INTO student(student_no, student_name, school_id) VALUES(:no, :name, :sid)";
    cur.execute(sqlcmd, {'no': 523, 'name': 'Rasim Özcan', 'sid': 3})
    conn.commit()

    Buradaki isimlerde ':' karakterinin kullanılmadığına dikkat ediniz.

    Pekiyi yer tutucu kullanmanın ne avantajı vardır? İşte her defasında yeniden bir komut yazısı oluşturmak yerine yer tutucularla 
    bir tane komut yazısı oluşturup hep onu kullanmak çok daha pratik ve etkindir. Yani programcı işin başında programında gerekli 
    SQL komutlarını yer tutucularla oluşturur sonra da onlar için değerleri execute metodunda belirtir. Bir kez daha anımsatmak istiyoruz: 
    Örneklerden de gördüğünüz gibi yer tutucu eğer bir string ise onu tek tırnak içerisine programcı almamaktadır. Yer tutucuyu yerleştiren 
    execute metodu bunu yapmaktadır. 

    Yer tutucuların işlevlerinin Python'a son versiyonlarla eklenen f'li string'lerle (string enterpolasyonuyla) sağlanabileceğini 
    düşünebilirsiniz. Ancak f'li string'ler programın akışı o noktaya geldiğinde bir kez oluşturulmaktadır. Örneğin:

    student_no = 123
    sql_cmd = f"SELECT * FROM student WHERE student_no = {student_no}"

    print(sql_cmd)              # SELECT * FROM student WHERE student_no = 123
    student_no = 321
    print(sql_cmd)              # SELECT * FROM student WHERE student_no = 123
#------------------------------------------------------------------------------------------------------------------------------------
                                              
#------------------------------------------------------------------------------------------------------------------------------------
    execute ve executescript metotlarının dışında Cursor sınıfının bir de executemany isimli metodu vardır. Bu metodun kullanılabilmesi 
    için SQL komut yazısının yer tutucuyla oluşturulması gerekir. executemany metodunun ikinci parametresi demetlerden ya da sözlüklerden 
    oluşan  dolaşılabilir bir nesne olabilir. Metot çağrıldığında dolaşılabilir nesnedeki elemanlar tek tek yer tutuculara yerleştirilip 
    komut birden fazla kez uygulanmaktadır. Örneğin:

    sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(?, ?, ?)"
    cur.executemany(sql_cmd, [('Tayyar Altınkulaç', 456, 3), ('Salim Dündar', 632, 2)])
    conn.commit()

    Yukarıdaki executemany birden fazla execute ile aynı işleve sahiptir:

    sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(?, ?, ?)"
    cur.execute(sql_cmd, ('Tayyar Altınkulaç', 456, 3))
    cur.execute(sql_cmd, ('Salim Dündar', 632, 2))
    conn.commit()

    Yer tutucular isimliyse executemany metodunda bir sözlük listesi ya da sözlüklerden oluşan bir demet (aslında genel olarak 
    sözlüklerden oluşan dolaşılabilir bir nesne) verilebilir. Örneğin:

    sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(:name, :no, :sid)"
    cur.executemany(sql_cmd, [{'name': 'Gökhan Abur', 'no': 387, 'sid': 5}, {'name': 'Timur Selçuk', 'no': 743, 'sid': 2}])
    conn.commit()

    executemany sayesinde bazı işlemler pratik biçimde yapılabilmektedir. Örneğin bir CSV dosyasından okuma yapan standart csv modülündeki 
    reader fonksiyonu bize dolaşılabilir bir nesne verir. Sonra her dolaşımda CSV dosyasındaki bir satır elde edilir. Biz doğrudan bu 
    reader fonksiyonunun verdiği nesneyi executemany metodunun ikinci parametresine geçirebiliriz. Örneğin:

    import sqlite3
    import csv

    try:
        with sqlite3.connect('school.sqlite') as conn, open('student.csv') as f:
            cur = conn.cursor()
            sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(?, ?, ?)"
            cur.executemany(sql_cmd, csv.reader(f))
            conn.commit()            
    except sqlite3.Error as e:
        print(e)
    except Exception as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii yer tutucular yalnızca INSERT INTO komutunda değil diğer komutlarda da kullanılabilmektedir. Örneğin:

    import sqlite3

    try:
        with sqlite3.connect('school.sqlite') as conn:
            cur = conn.cursor()
            sqlcmd = "DELETE FROM student WHERE student_no == ?";
            cur.executemany(sqlcmd, [(9981, ), (8984, )])
            conn.commit()
    except sqlite3.Error as e:
        print(e)                        
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi VTYS'lerin pek çok built-in fonksiyonları vardır. Bu fonksiyonları sorgulamalarda kullanabiliriz. 
    Aşağıda built-in length fonksiyonunun kullanımına ilişkin bir örnek görüyorsunuz:

    sql_cmd = "SELECT * FROM student WHERE length(student_name) = ?"
    cur.execute(sql_cmd, (10, ))
    students = cur.fetchall()        
    for student in students:
        print(student)            

    Burada adı soyadı 10 karakter olan öğrencilerin listesi elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()
        sql_cmd = "SELECT * FROM student WHERE length(student_name) = ?"
        cur.execute(sql_cmd, (10, ))
        students = cur.fetchall()        
        for student in students:
            print(student)            
except sqlite3.Error as e:
    print(e)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz SELECT cümlesinde veirtabanındaki sütun isimlerini bu fonksiyonlara sokarak sütun isimleri yerine bunların çıktılarını 
    da elde edebiliriz. Örneğin "school.sqlite" veritabaınındaki öğrencilerin ad ve soyadlarının uzublukları aşağıdaki gibi elde 
    edilebilir:

    sql_cmd = "SELECT length(student_name) FROM student"
    cur.execute(sql_cmd)
    students = cur.fetchall()        
    for student in students:
        print(student)            
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()
        sql_cmd = "SELECT length(student_name) FROM student"
        cur.execute(sql_cmd)
        students = cur.fetchall()        
        for student in students:
            print(student)            
except sqlite3.Error as e:
    print(e)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı built-in fonksiyonlar pek çok VTYS'de aynı biçimde bulunmaktadır. Ancak pek çok fonksiyon da VTYS'ye özgüdür. Bu nedenle hangi 
    VTYS'de çalışıyorsanız o VTYS'ye özgü fonksiyonları o VTYS'nin kendi dokümanlarından elde edebilirsiniz. 

    Kendimizin yazdığı bir Python fonksiyonunu SQL komutunda da kullanabiliriz. Bunun için kullanılacak olan fonksiyonun Connection 
    nesnesinin create_function isimli metoduyla yaratılması gerekir. create_function metodunun parametrik yapısı şöyledir:

    create_function(name, narg, func, *, deterministic=False)

    Metodun birinci parametresi fonksiyonun SQL içerisinden kullanılacak ismini belirtmektedir. Bu ismin fonksiyonun gerçek ismiyle 
    aynı olması gerekmez. İkinci parametre fonksiyonun parametre sayısını, üçüncü parametre ise Python fonksiyon nesnesini belirtmektedir. 
    Biz bu üçüncü parametreye çağrılmasını istediğimiz fonksiyonun ismini girebiliriz. create_function fonksiyonunu çağırdıktan sonra 
    artık biz belirlediğimiz bu fonksiyon ismini SQL komutunda kullanabiliriz. Fonksiyon SQL komutunda kullanıldığında komutta belirtilen 
    sütun bilgileri belirlenen fonksiyona parametre olarak aktarılacaktır. Örneğin biz komutta bu fonksiyona student_name ve student_no
    sütunlarını argüman olarak verirsek student_name sütunu fonksiyona str olarak, student_no sütunu ise int olarak aktarılacacaktır.
    Bu biçimde belirlediğimiz fonksiyon SQL komutu uygulandığında fonksiyonun geri döndürdüğü değer komutta kullanılmaktadır. SQL büyük 
    harf küçük harf duyarlılığı olan (case sensitive) bir dil değildir. Yani örneğin biz create_function metoduna fonksiyon ismini küçük 
    harfle versek bile onu komut içerisimde büyük harfle kullanabiliriz.
    Örneğin:

    sql_cmd = "SELECT myfunc(student_name), student_no FROM student"

    Bu SQL cümlesi çalıştırıldığında student_name sütunundaki her isim önce myfunc fonksiyonuna parametre olarak geçirilecek, sonra
    bu fonksiyonun geri dönüş değeri elde edilip SELECT tarafından işlenecektir.

    Aşağıdaki örnekte foo isimli fonksiyon SQL içerisinde "myfunc" ismiyle kullanılmaktadır. Bu örnekte öürencinin ismi ve numarası
    birleştirilerek tek bir sütunmuş gibi elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def foo(name, no):
    return name + ', ' + str(no)

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()
        sql_cmd = "SELECT myfunc(student_name, student_no)  FROM student"  
        conn.create_function('myfunc', 2, foo)
        
        cur.execute(sql_cmd)
        students = cur.fetchall()        
        for name,  in students:
            print(name)            
except sqlite3.Error as e:
    print(e)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
                                        13. Ders 19/04/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte zaten var olan length built-in fonksiyonunun mylength ismiyle başka bir versiyonu yazılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def mylength(name):
    return len(name)

try:
    with sqlite3.connect('school.sqlite') as conn:
        conn.create_function('mylength', 1, mylength)  
        cur = conn.cursor()
          
        sqlcmd = "SELECT student_name FROM student WHERE mylength(student_name) = 10"
        for n,  in cur.execute(sqlcmd):
            print(n)
except sqlite3.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii VTYS'de zaten var olan built-in fonksiyonları gereksiz bir biçimde yeniden yazmayınız. Çalıştığınız VTYS'deki built-in 
    fonksiyonların listesini dokümanlardan elde edip incelemelisiniz. Örneğin SQLite'taki built-in substr fonksiyonu belli bir 
    indeksten itibaren (ilk indeks 1'dir) n tane karakteri elde etmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor() 
        for record in cur.execute("SELECT upper(student_name) FROM student WHERE substr(lower(student_name), 1, 2) = 'ka'"):
            print(record)
        
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Connection sınıfının text_factory isimli örnek özniteliği bir Python fonksiyonu alır. Select edilen yazısal sütunlar için
    o sütunun değerini önce bu fonksiyona parametre yaparak fonksiyonu çağırır. Fonksiyonun geri dönüş değerini bize sanki select 
    edilen değer gibi verir. Ancak her zaman yazısal alanlar fonksiyona bytes nesnesi olarak geçirilmektedir. 

    text_factory örnek özniteliğine yerleştirilen fonksiyon yalnızca yazısal sütunlar için devreye girmektedir. Sayısal sütunlar 
    için devreye girmemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def foo(name):
    return '"' + str(name, encoding='utf-8') + '"'

try:
    with sqlite3.connect('school.sqlite') as conn:
        conn.text_factory = foo
        cur = conn.cursor()
        for school_id, school_name, school_type in cur.execute("SELECT school_id, school_name, school_type FROM school"):
            print(school_id, school_name, school_type)
        
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
   text_factory örnek özniteliği default durumda str fonksiyonunu almaktadır. Yani SELECT edilen yazısal sütunlar str fonksiyonuna 
   sokulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        conn.text_factory = str         # gerek yok, default durum zaten böyle
        cur = conn.cursor()
        for school_id, school_name, school_type in cur.execute("SELECT school_id, school_name, school_type FROM school"):
            print(school_id, school_name, school_type)
        
except Exception as e:
    print(e)
#------------------------------------------------------------------------------------------------------------------------------------
    Connection sınıfının row_factory isimli örnek özniteliği aslında text_factory örnek özniteliğinin daha genel bir biçimidir. SELECT 
    edilen tüm değerler bir demet nesnesi olarak burada girilen fonksiyonun ikinci parametresine demet biçiminde geçirilir. Programcı 
    SELECT edilen değerleri almak istediğinde artık ona bu değerler bir demet biçiminde değil bu fonksiyonun geri dönüş değeri ile belirtilen 
    biçimde verilir. row_factory örnek özniteliğine girilen fonksiyon her zaman iki parametreli olmalıdır. Fonksiyonun birinci parametresine 
    cursor nesnesi, ikinci parametresine ise SELECT edilen satır bilgileri demet olarak geçirilmektedir. Yani SELECT işlemi yapıldığında 
    SELECT edilen satır önce row_factory ile belirtilen fonksiyonun ikinci parametresine geçirilir, sonra bu fonksiyondan elde edilen 
    değer adeta SELECT işleminin sonucu gibi verilmektedir. Örneğin:

    def foo(cur, row):
        return row[0].upper() + ' ' + str(row[1])[::-1]

    with sqlite3.connect('school.sqlite') as conn:
        conn.row_factory = foo
        cur = conn.cursor()
        sql_cmd = "SELECT student_name, student_no FROM student"  
        cur.execute(sql_cmd)
        students = cur.fetchall()  
        print(students)

    Burada Connection nesnesinin örnek özniteliğine foo fonksiyonu girilmiştir. SELECT işleminde student_name ve student_no 
    kullanılmıştır. Bu durumda select edilen her satır ikili bir demet olarak foo fonksiyonunun ikinci parametresine geçirilir. 
    SELECT işleminin sonucu olarak da bu foo fonksiyonun geri dönüş değeri elde edilir. Yukarıdaki örnekte aşağıdaki gibi bir 
    çıktı elde edilecektir:

    ['ALI SERÇE 567', 'NECATI ERGIN 997', 'HALIT AKÇATEPE 289', 'HASAN KILIÇASLAN 396', 'KAMIL KOCA 096', 'BUKET İZGÜ 186', 
    'YÜCEL GÜNDÜZ 325', 'LEVENT KARLI 115', 'MEHMET ALPER 016', 'TAYYAR ALTINKULAÇ 654', 'SALIM DÜNDAR 236', 'GÖKHAN ABUR 783', 
    'TIMUR SELÇUK 347', 'HALUK LEVENT 218', 'MARK SPITZ 017', 'EKREM BORA 123', 'MEHMET ÖZ 121', 'NURI BILGE CEYLAN 099']

    Aşağıdaki örnekte "sakila.sqlite" veritabanında altı karakterli şehirler ve onların ilişkin olduğu ülkeler elde edilmiştir. 
    Ancak elde edilen kayıtlar önce foo fonksiyonuna sokulmuş, foo fonksiyonundan elde edilen değeri de sanki SELECT cümlesinden 
    elde edilmiş gibi işlem görmüştür. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def foo(cur, row):
    return str(row[0]) + ' --- ' + str(row[1])

try:
    with sqlite3.connect('sakila.sqlite') as conn:
        conn.row_factory = foo
        cur = conn.cursor()    
        for row in cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6 "):
            print(row)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
   Cursor nesnesinin description isimli örnek özniteliği son SELECT işlemindeki select edilen sütunların isimlerini bize vermektedir. 
   Ancak bu örnek özniteliği demetlerden oluşan bir demet verir. Bu demetlerin yalnızca ilk elemanında sütun bilgisi string olarak 
   bulunmaktadır. Demetlerin diğer elemanları None değerdedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('sakila.sqlite') as conn:
        cur = conn.cursor()     
        cur.execute("SELECT city, country_id FROM city WHERE length(city) = 6")        
        for t in cur.description:
            print(t[0])

except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi Cursor nesnesinin description özniteliğinin kullanımına ilişkin bir örnek verelim. SELECT ettiğimiz satırları bir demet 
    olarak değil de bir sözlük olarak elde etmek isteyelim. Sözlüğün anahtarları sütun isimlerinden değerleri de o sütuna karşı gelen 
    değerlerden oluşacak olsun. Bu işlemi yapabilmek için Connection nesnesinin row_factory örnek özniteliğine bir fonksiyon gireriz. 
    Fonksiyon içerisinde Curor sınıfının description örnek özniteliğinden faydalanarak işlemimizi yapabiliriz. Örneğin:

    def rowdict(cur, row):
        return {cur.description[index][0]: val for index, val in enumerate(row)}

    try:
        with sqlite3.connect('sakila.sqlite') as conn:
            conn.row_factory = rowdict
            cur = conn.cursor()     
            cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")     
            for d in cur.fetchall():
                print(d['city'], d['country'])

    except Exception as e:
        print(e)

    Bu örnekte iki sütun SELECT edilmiştir. Bu durumda description özniteliği iki demetten oluşan demet biçiminde olacaktır. Bu 
    demetlerin de ilk elemanları sütun isimlerindne oluşur. rowdict fonksiyonunda şöyle bir sözlüğe geri dönülmüştür:

    def rowdict(cur, row):
        return {cur.description[index][0]: val for index, val in enumerate(row)}

    Burada row parametresine iki elemanlı bir demet geçirilecektir. Bu demet enumerate fonksiyonuna sokulup elemanlar ve indeksler 
    ayrı ayrı elde edilmiştir. İndeksten hareketle sütun isimlerine erişilip sözlük içlemiyle sözlük nesnesi oluşturulmuştur.

    Aşağıdaki örnekte "sakila" veritabanında ismi 6 karakter uzunluğunda olan şehirler ve onların ilişkin olduğu ülkeler bir sözlük 
    nesnesi biçiminde SELECT işleminden elde edilmiştir. Fonksiyon içerisinde "sözlük içlemi" uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

def rowdict(cur, row):
    return {cur.description[index][0]: val for index, val in enumerate(row)}

try:
    with sqlite3.connect('sakila.sqlite') as conn:
        conn.row_factory = rowdict
        cur = conn.cursor()     
        cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")     
        for d in cur.fetchall():
            print(d['city'], d['country'])
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında text_factory ve row_factory örnek öznitelikleri için herhangi bir callable nesne de kullanılabilir. Örneğin bu amaçla 
    fonksiyon yerine __call__ operatör metodu yazılmış olan sınıflara ilişkin nesneleri kullanabiliriz. Sınıf nesneleri durumsal 
    bilgileri tutabildiği için daha esnek kullanıma olanak sağlamaktadır. Aşağıda buna ilişkin bir örnek veriyoruz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

class RowFactory:
    def __init__(self, text):
        self.text = text
    
    def __call__(self, cur, row):
        return f'{self.text}: {row[0]} ---> {row[1]}'
    
try:
    with sqlite3.connect('sakila.sqlite') as conn:
        conn.row_factory = RowFactory('result')
        cur = conn.cursor()     
        cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")
        
        for s in cur.fetchall():
            print(s)
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    SELECT edilen satırların bir sözlük nesnesi olarak elde edilmesi için aslında standart kütüphanede sqlite3.Row isimli hazır bir 
    sınıf bulundurulmuştur. Biz Connection nesnesinin row_fatory örnek özniteliğine bu sınıf ismini girersek bu durumda artık SELECT 
    işlemi yaptığımızda bize nesneler sqlite3.Row sınıfı biçiminde bize verilecektir. sqlit3.Row sınıfı tamamen bir sözlük gibi 
    davranmaktadır.

    import sqlite3

    try:
        with sqlite3.connect('sakila.sqlite') as conn:
            conn.row_factory = sqlite3.Row
            cur = conn.cursor()   
            cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")
            for d in cur.fetchall():
                print(d['city'], d['country'])               
    except Exception as e:
        print(e)
    
    Burada artık fetchall yapıldığında biz demet değil sqlite3.Row nesneleri elde ederiz. sqlite3.Row sınıfının tamamen bir sözlük 
    gibi kullanıldığını belirtmiştik. Burada yapılanlara dikkat ediniz:

    conn.row_factory = sqlite3.Row

    row_factory özniteliğine bir fonksiyon yerine bir sınıf verilmiştir. Bu durumda bu sınıf bir fonksiyon gibi çağırlacak ve aslında 
    Row nesnesi yaratılmış olacaktır. Row(cur, tuple) gibi bir ifadeden Row nesnesi elde edileceğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('sakila.sqlite') as conn:
        conn.row_factory = sqlite3.Row
        cur = conn.cursor()   
        cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")
        for d in cur.fetchall():
            print(d['city'], d['country'])          
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aslında sqlite3.Row sınıfının bir benzeri aşağıdaki gibi kolay biçimde yazılabilir. Burada biz MyRow sınıfının bir sözlük gibi 
    davranabilmesi için onun __getitem__ metodunu yazdık. Bu örnekte her kayıt SELECT edildiğinde aslında MyRow(...) çağrısı yapılacağı 
    için bize MyRow sınıfı üründen bir nesne verilecektir. Bir sınıfın sözlük gibi davranabilmesini sağlamanın bir yolu da dict sınıfından 
    türetme yapmaktır. Bu konu kursumuzda ilerideki bölümlerde ele alınmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

class MyRow:
    def __init__(self, cur, row):
       self.rowdict = {cur.description[index][0]: val for index, val in enumerate(row)}
            
    def __getitem__(self, key):
        return self.rowdict[key]

try:
    with sqlite3.connect('sakila.sqlite') as conn:
        conn.row_factory = MyRow  
        cur = conn.cursor()
        cur.execute("SELECT city, country FROM city, country WHERE city.country_id = country.country_id AND length(city) = 6")
        
        for mr in cur.fetchall():
            print(mr['city'], mr['country'])
except Exception as e:
    print(e)  

#------------------------------------------------------------------------------------------------------------------------------------
   Bir kaydı insert ederken o kaydın içerisinde foreign key olabilir. Bu durumda bu foreign key değerinin diğer tablodan SELECT edilmesi 
   gerekir. Örneğin biz student tablosuna ismini, numarasını ve okul ismini bildiğimiz bir kaydı insert etmek isteyelim. Bizim önce 
   okul ismini school_id değerine dönüştürmemiz gerekir. Bunu da ancak school tablosu üzerinde SELECT işlemi ile yapabiliriz. Yani 
   önce school tablosundan ismi verilen okulun school_id'sini elde ederiz. Sonra bu school'id'yi student tablosundaki insert işleminde
   kullanırız. Örneğin:

    sql_cmd = "SELECT school_id FROM school WHERE school_name = ?"
    cur.execute(sql_cmd, ('Murat Atılgan', ))
    row = cur.fetchone()
    if row:
        sql_cmd = "INSERT INTO student(student_name, student_no, school_id) \
        VALUES(?, ?, ?)"            
        cur.execute(sql_cmd, ('Cumali Cuma', 823, row[0]))
        conn.commit()
    else:
        print('Okul buylunamadı')
   
   
   Aslında bu işlem daha pratik bir biçimde INSERT INTO içerisinde SELECT komutu kullanılarak da tek hamlede yapılabilmektedir. 
   Örneğin:
   
    cur.execute("INSERT INTO student(student_no, student_name, school_id) \
            VALUES(?, ?, (SELECT school_id FROM school WHERE school_name = ?))", (no, name, school_name))

   Tabii foreign key alanına ilişkin bilgi ilgili tabloda bulunmayabilir. Bu durumda önce o kaydın ilgili tabloya insert edilmesi
   de gerekebilir. İşte bu tür durumlarda iki tabloya insert yapmak tasarım olarak iyi bir fikir değildir. Çünkü bu tür durumlarda 
   girişler hatalı olabilir. Hatalı girişler yanlışlıkla veritabanına yansıtılabilir. Bu tür durumlarda kullanıcıdan tablolardaki
   kayıtları ayrı ayrı girmesi istenmelidir. Örneğin "school" veri tabanında önce okul girilmeli, sonra o okula ilişkin öğrenci 
   girilmelidir. Ancak yine de bu tür durumlar için özel INSERT INTO komutları da bulundurulmuştur. Örneğin SQLite'te bir sütun 
   yaratılırken UNIQUE belirlemesi yapılmışsa artık biz o sütun için INSERT OR IGNORE INTO komutunu kullanabiliriz. Bu komut o 
   sütunda zaten o değer varsa kaydı hiç insert etmemektedir. Diğer VTYS'lerde de buna benzer INSERT INTO komutları bulunmaktadır.

   Aşağıdaki örnekte öğrencinin okulu önce okul tablosuna INSERT OR IGNORE INTO ile eklenmiş daha sonra buradaki değer alınarak
   student tablosuna çğrenci bilgisi kaydedilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3

try:
    with sqlite3.connect('school.sqlite') as conn:
        cur = conn.cursor()
        while True:
            no = int(input('No:'))
            if not no:
                break
            name = input('Adı Soyadı:')
            school = input('Okulu:')
            cur.execute("INSERT OR IGNORE INTO school(school_name) VALUES(?)", (school, ))
            cur.execute("INSERT INTO student(student_no, student_name, school_id) \
                    VALUES(?, ?,  (SELECT school_id FROM school WHERE school_name = ?))", (no, name, school))
            conn.commit()
  
        for row in cur.execute("SELECT student.student_no, student.student_name, school.school_name FROM student, school \
                WHERE student.school_id = school.school_id"):
            print(row)   
except Exception as e:
    conn.rollback()
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla tabloya foreign key eşliğinde insert işlemi VTYS'lerin bu amaçla bulundurulmuş özel fonksiyonları kullanılarak da 
    yapılabilir. Örneğin SQLite'ta last_insert_rowid isimli fonksiyon son insert işlemindeki PRIMARY KEY değerini bize vermektedir. 
    Dolayısıyla biz önce bir tabloya insert işlemi yapıp foreign key değerini bu yolla elde edebiliriz. Tabii bu durumda PRIMARY 
    KET ile foreign key aynı olmalıdır. Örneğin:

    cur.execute("INSERT INTO school(school_name) VALUES(?)", (name, city))
    cur.execute("INSERT INTO student(student_no, student_name, school_id) VALUES(?, ?,  last_insert_rowid())", (no, name))
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    SQLite'da bellek tabanlı veritabanları da oluşturulabilmektedir. Bunun için dosya ismi yerine ":memory:" biçiminde özel bir yazı 
    girilmelidir. Bu biçimde oluşturulan veritabanı tabiiki boştur. Dolayısıyla bizim tabloları ekleyip kayıtları insert etmemiz gerekir. 
    Ancak program sonlandığında bellekte yaratılmış olan tüm bilgiler yok olacaktır. Çünkü o bilgiler diskte
    bir dosyada değil bellekte bulunmaktadır.

    Aşağıdaki tamamen bellekte bir veritabanı oluşturulup ona kayıtlar eklenmniştir. Sonra da SELECT işlemi yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3
       
script = """
    CREATE TABLE student(student_id INTEGER, student_no INTEGER, student_name VARCHAR(64), PRIMARY KEY(student_id));
    INSERT INTO student(student_no, student_name) VALUES(123, 'Ali Serçe');
    INSERT INTO student(student_no, student_name) VALUES(456, 'Kaan Aslan');
    INSERT INTO student(student_no, student_name) VALUES(289, 'Ayşe Er');
"""

try:
    with sqlite3.connect(':memory:') as conn:
        cur = conn.cursor()
        cur.executescript(script)
        conn.commit()
        
        for row in cur.execute("SELECT * FROM student"):
            print(*row)
        
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bellekte oluşturulan bir veritabanını belli bir noktada Connection sınıfının backup isimli metodu ile bir veritabanı dosyası biçiminde 
    de save edebiliriz. Ancak backup fonksiyonu bizden doayanın ismini değil bir Connection nesnesi istemektedir. O halde bizim boş 
    bir veritabanını sqlite3.connect fonksiyonuyla yaratıp, yeni bir Conenction nesnesi elde edip onu kullanmamız gerekir. Örneğin:

    with sqlite3.connect('test.sqlite') as conn2:
        conn.backup(conn2)

    Burada conn bellek tabanlı veritabanını conn2 ise henüz yaratılmış olan veritabanını belirtmektedir. Aşağıdaki örnekte bellek 
    tabanlı bir SqLite veritabanı backup metoduyla disk tabanlı bir biçimde save edilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3
       
script = """CREATE TABLE student(student_id INTEGER, student_no INTEGER, student_name VARCHAR(64), PRIMARY KEY(student_id));
INSERT INTO student(student_no, student_name) VALUES(123, 'Ali Serçe');
INSERT INTO student(student_no, student_name) VALUES(456, 'Kaan Aslan');
INSERT INTO student(student_no, student_name) VALUES(289, 'Ayşe Er');
"""

try:
    with sqlite3.connect(':memory:') as conn:
        cur = conn.cursor()
        cur.executescript(script)
        conn.commit()
        
        with sqlite3.connect('backup.sqlite') as conn_backup:
            conn.backup(conn_backup)

except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir veritabanını bellek oluşturmanın ne faydası olabilir? Çünkü program sonlandığında veritabanının da tüm içeriği kaybolacaktır.
    İşte bazı programlarda karmaşık aramalar yapılabilmektedir. Biz de SQLin sunduğu bu arama mekanizmasından faydalanmak isteyebiliriz. 
    
    Aşağıdaki örnekte belli bir kök dizinden hareket edilerek dizin ağacı dolaşılıp dosyaların bilgileri bellekte oluşturulmuş olan bir 
    veritabanına kaydedilmiştir. Sonra da SELECT işlemi yapılarak belli koşulu sağlayan dosya bilgileri elde edilmiştir. Bu örnekte bir 
    iki tabloya sahip biz iki tabloya sahip bir veritabanı oluşturduk. Tablolar şöyledir:

    file Tablosu: file_id, file_name, file_size, directory_id
    directory Tablosu: directory_id directory_path

    Örneğimizde programı fonksiyonlara bölerek yazdık. create_database fonksiyonu veritabanını ve tabloları yaratmaktadır. get_all_files
    fonksiyonu dizin ağacını dolaşarak dosya bilgilerini ve onların hangi dizinlerde olduğu bilgisini veritabanına kayıt olarak 
    eklemektedir. Dosyaları özyinelemeli biçimde os.walk fonksiyonu ile elde edip onların getsize fonksiyonu ile alırken bazı sistemlerde
    dosya erişim konusunda sorunlar ortaya çıkabilir. Bu tür durumlarda bundan tüm programın etkilenmemesi için get_all_files 
    fonksiyonunda biz OSError exception'ını yerel olarak yakalıp döngünün devam etmesini sağladık.
  #------------------------------------------------------------------------------------------------------------------------------------

import os
from os.path import getsize
import sqlite3

ROOT_PATH = r'C:\Dropbox\Shared\Kurslar'

def get_all_files(cur, rootpath):
    for base, dirs, files in os.walk(ROOT_PATH):
        try:
            print(base)
            for file in files:
                sql_cmd = "SELECT directory_id, directory_path FROM directory WHERE directory_path = ?"
                cur.execute(sql_cmd, (base, ))
                t = cur.fetchone()
                if not t:
                    sql_cmd = "INSERT INTO directory(directory_path) VALUES(?)"
                    cur.execute(sql_cmd, (base, ))
                    directory_id = cur.lastrowid
                else:
                    directory_id, directory_path = t
                    
                sql_cmd = "INSERT INTO file(file_name, file_size, directory_id) VALUES(?, ?, ?)"
                cur.execute(sql_cmd, (file, getsize(f'{base}/{file}'), directory_id))
        except OSError:
            pass
  
def create_database():
    with sqlite3.connect(':memory:') as conn:
        cur = conn.cursor()
        script = """
            CREATE TABLE file(file_id INTEGER PRIMARY KEY AUTOINCREMENT, file_name VARCHAR(260), 
                    file_size INTEGER, directory_id INTEGER);
            CREATE TABLE directory(directory_id INTEGER PRIMARY KEY AUTOINCREMENT, directory_path VARCHAR(260));
        """
        cur.executescript(script)
        
        return cur
          
def main():
    try:
        cur = create_database()
        get_all_files(cur, ROOT_PATH)
        
        name = input('Aranacak dosyanın ismini giriniz:')    
        sql_cmd = "SELECT file_size, directory_path FROM file, directory WHERE file.directory_id = \
                directory.directory_id AND file_name = ? AND file_Size > ?"
        cur.execute(sql_cmd, (name, 100))
        for file_size, directory_path  in cur.fetchall():
            print(directory_path, file_size )          
    except sqlite3.Error as e:
        print(f'Database error: {e}')
    except Exception as e:
        print(f'Error: {e}')
    
    cur.connection.close()

main()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Normal durum önce Connection nesnesinin yaratılması, sonra bu connection nesnesinden Cursor nesnesinin yaratılması ve işlemlerin 
    bu cursor nesnesiyle yapılmasıdır. Ancak kolaylık olsun diye Connection sınıfının içerisine de execute, xecutemany ve executescript 
    metotları eklenmiştir. Aslında bu metotlar kendi içerisinde Cursor nesnesi yaratıp bu nesne ile ilgili metodu uygulamaktadır. 
    Bu execute metotları kendi yarattıkları Cursor nesnesine geri dönerler. Tabii bu durumda her execute işlemi yeni bir Cursor nesnesi 
    yaratmaktadır.

    Aşağıdaki örnekte bellek tabanlı bir SQLite veritabanı oluşturulup bu veritabanına kayıtlar eklenmiştir. Bu işlemler executescript
    metotdu ile yapılmıştır. Genel olarak executescript metotları bir transaction oluşturmadığı için commit işlemine de gerek kalmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3
       
script = """
    CREATE TABLE student(student_id INTEGER, student_no INTEGER, student_name VARCHAR(64), PRIMARY KEY(student_id));
    INSERT INTO student(student_no, student_name) VALUES(123, 'Ali Serçe');
    INSERT INTO student(student_no, student_name) VALUES(456, 'Kaan Aslan');
    INSERT INTO student(student_no, student_name) VALUES(289, 'Ayşe Er');
"""

try:
    with sqlite3.connect(':memory:') as conn:
        conn.executescript(script)
        cur = conn.execute("SELECT * FROM student")     
        for row in cur.fetchall():
            print(row)
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'da MySQL ile işlemler ana hatlarıyla tamamen SQLite'a benzer biçimde yapılmaktadır. Ancak "MySQL connector" kütüphanesi 
    Python standart kütüphanesinde bulunmamaktadır. Öncelikle bizim yerel makinemize MySQL için bir connector kütüphanesi indirip 
    kurmamız gerekir. 
  
    Python'da MySql için çeşitli üçüncü parti connectorpaketleri bulunmaktadır. En yaygın kullanılanı mysql-connector-python isimli 
    pakettir. Bu paket Oracle firması tarafından yazılmıştır, kullanımı SQLite'taki genel kullanıma çok benzerdir. Bu paket şöyle 
    kurulabilir:

    pip install mysql-connector-python

    Tabii bizim bir MySQL VTYS'sine erişebilir durumda olmanız da gerekmektedir. MySQL kurulduğunda kurulum sırasında "root" isimli 
    bir kullanıcı da yaratılmaktadır. Bu "root" kullanıcısı MySQL server üzerinde her türlü işlemi yapmaya yetkili bir kullanıcıdır. 
    MySQL gerçek bir VTYS olduğundan farklı kullanıcılar yaratılıp onların biribirinden izole edilmesi sağlanabilmektedir. Tabii MySQL'in 
    yerel makinede bulunuyor olması  gerekmez. VTYS'ler uzaktan bağlantılara izin vermektedir. Ancak belli bir süreden sonra MySQL'e 
    dışarıdan erişmenin yaratacağı güvenlik sorunu nedeniyle dışarıdan erişim default durumda yasaklanmıştır. Kurulumdan sonra dışarıya
    erişimi açmak server üzerinde bazı ayarların yapılması gerekmektedir. 

    MySQL'in Oracle firması tarafından geliştirilmiş olan konnektörünün dokümantasyonuna aşağıda bağlantıdan erişebilirsiniz:

    https://dev.mysql.com/doc/connector-python/en/connector-python-introduction.html

    Python'da mysql-connector-python paketi kurulduğunda konnektör kütüphanesinin impoer ismi mysql biçimindedir. Paket içerisinde 
    çeşitli modüller bulunmaktadır. Konnektörün en önemli sınıfları ve fonksiyonları mysql.connector modülündedir. Biz de kursumuzda
    bu modüle kolay erişebilmek için aşağıdaki import deyimini kullanacağız:

    import mysql.connector as mysqlc  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir MySQL VTYS'sine bağlanmak için mysql.connector modülündeki connect fonksiyonu kullanılır. connect fonksiyonunda şu parametreler 
    girilmelidir:

    host: VTYS'nin IP adresini ya da host ismini belirtir. Eğer yerel makinedeki MySQL server'a bağlanılacaksa bu parametre "127.0.0.1"
    ya da localhost" biçiminde girilebilir. 
    user: MySQL server'a her bağlanacak kullanıcının bir kullanıcı ismine sahip olması gerekmektedir. Yukarıda da belirttiğimiz gibi 
    "root" isimli kullanıcı kurulum sırasında tam yetkili bir biçimde yaratılmaktadır.
    password: Kullanıcıya ilişkin parola bilgisini belirtir. 
    
    import mysql.connector as mysqlc

    try:
        with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='xxx') as conn:
            print('Ok')
    except mysqlc.Error as e:
        print(e)
    
    MySQL'de tüm exception'lar mysql.connector modülündeki Error sınıfından türetilmiş sınıflarla temsil edilmektedir.

    Aşağıdaki örnekte tipik olarak MySql Server'a bağlantının nasıl yapıldığı görülmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import mysql.connector as mysqlc

try:
    with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='xxx') as conn:
        print('Ok')
except mysqlc.Error as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi mysql-connector-python kütüphanesinin kullanımı sqlite3 kütüphanesinin kullanımına çok benzemektedir. 
    Yine connector nesnesinin cursor isimli metodu çağrılarak cursor nesnesi elde edilir. Sorgulamalar bu cursor nesnesi ile yapılır. 
    Örneğin:

    import mysql.connector as mysqlc

    try:
        with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='school') as conn:
            cur = conn.cursor()
            sql_cmd = "SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id"
            cur.execute(sql_cmd)
            for student_name, student_no, school_name in cur.fetchall():
                print(student_name, student_no, school_name)
    except mysqlc.Error as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import mysql.connector as mysqlc

try:
    with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='school') as conn:
        cur = conn.cursor()
        sql_cmd = "SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id"
        cur.execute(sql_cmd)
        for student_name, student_no, school_name in cur.fetchall():
            print(student_name, student_no, school_name)
except mysqlc.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
   mysql'deki Cursor sınıfının execute metodu cursor nesnesinin kendisine değil None değerine geri dönmektedir. 
   Cursor nesnesiyle dolaşım yaparken dikkat ediniz. Örneğin aşağıdaki dolaım MySQL'de exception oluşturacaktır.

    for student_name, student_no, school_name in cur.execute(sql_cmd):
            print(student_name, student_no, school_name)
#------------------------------------------------------------------------------------------------------------------------------------

import mysql.connector as mysqlc

try:
    with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='school') as conn:
        cur = conn.cursor()
        sql_cmd = "SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id"
        cur.execute(sql_cmd)
        for student_name, student_no, school_name in cur:
            print(student_name, student_no, school_name)
except mysqlc.Error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
   Insert işlemi de benzer biçimdedir. Yine deafult durumda insert işleminden sonra commit uygulamak gerekmektedir. Örneğin:

   import mysql.connector as mysqlc

    try:
        with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='student') as conn:
            cur = conn.cursor()
            sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES('Kamil Şentürk', 721, 2)"
            cur.execute(sql_cmd)
            conn.commit()
    except mysqlc.Error as e:
        print(e)    
#------------------------------------------------------------------------------------------------------------------------------------

import mysql.connector as mysqlc

try:
    with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='student') as conn:
        cur = conn.cursor()
        sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES('Kamil Şentürk', 721, 2)"
        cur.execute(sql_cmd)
        conn.commit()
except mysqlc.Error as e:
    print(e)   

#------------------------------------------------------------------------------------------------------------------------------------
    Çeşitli connector'lerde yer tutucular farklı biçimlerde oluşturulabilmektedir. Örneğin mysql-connector-python connector'ü üzerinde
    yer tutucu olarak %s karakterleri kullanılmaktadır. Yer tutuculara karşılık demetler getirilebilir. Ya da sözlük nesneleri getirilebilir. 
    Eğer sözlük kullanılacaksa sözlüğün anahtarları %(isim)  biçiminde oluşturulmalıdır. Örneğin:

    import mysql.connector as mysqlc

    try:
        with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='student') as conn:
            cur = conn.cursor()
            sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(%s, %s, %s)"
            cur.execute(sql_cmd, ('Lale Şan', 690, 3))
            conn.commit()
    except mysqlc.Error as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------


    try:
        with mysqlc.connect(host='localhost', user='root', password='csd-1993', database='student') as conn:
            cur = conn.cursor()
            sql_cmd = "INSERT INTO student(student_name, student_no, school_id) VALUES(%s, %s, %s)"
            cur.execute(sql_cmd, ('Lale Şan', 690, 3))
            conn.commit()
    except mysqlc.Error as e:
        print(e)


#------------------------------------------------------------------------------------------------------------------------------------
    Homework 3-1'in Çözümü
#------------------------------------------------------------------------------------------------------------------------------------

import sqlite3
import statistics
import PIL
import IPython
import io

def disp_menu():
    while True:
        print('1) Ders Girişi')
        print('2) Öğrenci Girişi')
        print('3) Not Girişi')
        print('4) Öğrenci Sorgulama'),
        print('5) Çıkış')
        print()
   
        try:
            option = int(input('Seçiminiz:'))
            if option < 1 or option > 5:
                raise ValueError
            break
        except Exception:
            print('Geçersiz giriş!\n')
    return option
        
    
def class_input(cur):
    text = input('Dersin ismini ve haftalık ders saatini giriniz:\n')
    try:
        class_name, class_week_hours = text.split(',')
        class_name = class_name.strip().lower().title()
        class_week_hours = int(class_week_hours)

        cur.execute("INSERT INTO class(class_name, class_week_hours) VALUES(?, ?)", (class_name, class_week_hours))
        cur.connection.commit()
        print()
    except sqlite3.Error as e:
        print(e)
    except Exception:
        print('Geçersiz giriş!\n')
    
def student_input(cur):
    text = input('Öğrencinin adı soyadını, numarasını ve fotoğrafına ilişkin dosyanın yol ifadesini giriniz:\n')
    try:
        student_name, student_no, student_photo_path = text.split(',')
        student_name = student_name.strip().lower().title()
        student_no = int(student_no)
        student_photo_path = student_photo_path.strip()
        with open(student_photo_path, 'rb') as f:
            student_photo = f.read()
        
        cur.execute("INSERT INTO student(student_no, student_name, student_photo) VALUES(?, ?, ?)", (student_no, student_name, student_photo))
        cur.connection.commit()
        print()
    except sqlite3.Error as e:
        print(e)
    except OSError:
        print('Dosya bulunamadı ya da açılamadı')
    except Exception:
        print('Geçersiz giriş!\n')
    

def grade_input(cur):
    text = input('Öğrencinin adı soyadı, ders ismi, sınav numarası ve not bilgisini giriniz:\n')
    try:
        student_name, class_name, class_exam_no, class_grade = text.split(',')
        student_name = student_name.strip().lower().title()
        class_name = class_name.strip().lower().title()
        class_exam_no = int(class_exam_no)
        class_grade = int(class_grade)
        
        cur.execute("SELECT student_no FROM student WHERE student_name = ?", (student_name, ))
        t  = cur.fetchone()
        if t  == None:
            print(f'"{student_name}" isimli bir öğrenci yok! Önce öğrenciyi kaydediniz!\n')
            return
        
        student_no, = t
        
        cur.execute("SELECT class_id FROM class WHERE class_name = ?", (class_name, ))
        t  = cur.fetchone()
        if t  == None:
            print(f'"{class_name}n isminde bir ders yok! Önce dersi kaydediniz!\n')
            return
        class_id, = t
        
        cur.execute("INSERT INTO grade(student_no, class_id, class_exam_no, class_grade) VALUES(?, ?, ?, ?)", (student_no, class_id, class_exam_no, class_grade))
        cur.connection.commit()
        print()
    except sqlite3.Error as e:
        print(e)
    except Exception:
        print('Geçersiz giriş!\n')

def student_query(cur):   
    try:
        condition = ''
        text = input('Öğrencinin Numarasını giriniz:')
        print()
        if text.strip() != '':
            condition = f'WHERE student_no = {str(int(text))}'
            
        for student_no, student_name, student_photo in cur.execute("SELECT student_no, student_name, student_photo FROM student " + condition):
            print(f'Adı Soyadı: {student_name}')
            print(f'Numarası: {student_no}')
            
            cur2 = cur.connection.cursor()
            cur2.execute("SELECT DISTINCT class.class_id, class.class_name, class.class_week_hours FROM class, grade WHERE grade.student_no = ? and class.class_id = grade.class_id", (student_no, ))           
            weighted_total = 0
            class_week_hours_total = 0
            for class_id, class_name, class_week_hours in cur2.fetchall():
                print(f'{class_name}: ', end='')
                cur2.execute("SELECT grade.class_grade FROM grade WHERE student_no = ? and class_id = ? ORDER BY grade.class_exam_no", (student_no, class_id))
                grades = cur2.fetchall()
                print(*[t[0] for t in grades], sep=', ')
                weighted_total += statistics.mean([t[0] for t in grades]) * class_week_hours
                class_week_hours_total += class_week_hours        
             
            bio = io.BytesIO(student_photo)
            image = PIL.Image.open(bio)
            image.thumbnail((200, 300))
            IPython.display.display(image).
            print()
            
            print(f'Ağırlıklı Not ortalaması: {weighted_total / class_week_hours_total}')
            print()

    except sqlite3.Error as e:
        print(e)
    except Exception as e:
        print(f'Error: {e}')
  
def main():
    table_create = """CREATE TABLE IF NOT EXISTS student(student_no INTEGER, student_name VARCHAR(64), student_photo BLOB, PRIMARY KEY(student_no));
CREATE TABLE IF NOT EXISTS class(class_id INTEGER, class_name VARCHAR(32), class_week_hours INTEGER, PRIMARY KEY(class_id));
CREATE TABLE IF NOT EXISTS grade(student_no INTEGER, class_id INTEGER, class_exam_no INTEGER, class_grade INTEGER, PRIMARY KEY(student_no));
"""
    try:
        with sqlite3.connect('student_notes.sqlite') as conn:
           cur = conn.cursor()
           cur.executescript(table_create)
           conn.commit()
           while True:
              option = disp_menu()
              if option == 5:
                  break
              {1: class_input, 2: student_input, 3: grade_input, 4: student_query}[option](cur)
                   
    except Exception as e:
        conn.rollback()
        print(e)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Python ile Microsoft'un SQLServer isimli VTYS'si üzerinde işlem yapmak için pyodbc isimli connector paket kullanılmaktadır. Paketin 
    yüklenmesi şöyle yapılabilir:

    pip install pyodbc

    Bu paketteki fonksiyonların ve sınıfların genel kullanımı yine sqlite3^teki ile çok benzerdir. Veritabanı bağlantısı için pyodbc 
    modülündeki connect fonksiyonu kullanılmaktadır. connect fonksiyonunda şu parametreler girilmelidir:

    driver: Kullanılacak ODBC sürücüsünün versiyonunu belirtir. Tipik olarak bu parametre "{ODBC Driver 17 for SQL Server}" biçiminde 
    girilir.server: SQLServer'ın IP adresini belirtmektedir. IP adresi yerine "host ismi" de kullanılabilir. Yerel makine için "localhost" 
    ismi belirtilebilir.
    database: Kullanılacak veritabanının ismini belirtir.
    uid: Kullanıcıyı belirtir.
    password: Kullanıcının parolasını belitmektedir.

    pyodbc paketi aslında Microsoft'un geliştirdiği ODBC sürücücü programını kullanmaktadır. Dolayısıyla pyodbc'yi kullanırken  aynı 
    zamanda makinenizde ODB sürücüsünün yüklü olması gerekmektedir. Microsoft'un ODBC sürücüsünü Internet'ten indirebilirsiniz. Ancak 
    Windows sistemlerinde zaten sistem kurulduğu zaman bu sürücü de kurulmaktadır. Linux, macOS gibi sistemlerde bu sürücüsünün programcı 
    tarafından kurulması gerekebilmektedir. Ayrıca Microsoft'un ODBC sürücülerinin çeşitli versiyonları da vardır. Sisteminizde yüklü 
    olan ODBC sürücülerinin listesini pyodbc.drivers() çağrısı ile elde edebilirsiniz. Bu durumda "driver" parametresine buradaki yüklü 
    olan sürücülere ilişkin yazıyı girmelisiniz. Örneğin:

    import pyodbc

    try:
        with pyodbc.connect(driver='{ODBC Driver 17 for SQL Server}', server='terapikulubu.com', database='AVS', 
                    uid='aslank', password='xxxxxxxx') as conn:
            cur = conn.cursor()
            cur.execute("SELECT username, member_id FROM members WHERE username LIKE ?", ('ka%', ))
            for row in cur:
                print(row)
    except Exception as e:
        print(f'Error: {e}')


    Aşağıda SQLServer VTYS'sine bağlantı yapan örnek bir kod parçası verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import pyodbc

try:
    with open(r'c:\password.txt') as f:
        password = f.read()
    with pyodbc.connect(driver='{ODBC Driver 17 for SQL Server}', server='terapikulubu.com', database='AVS', 
                ='aslank', password=password) as conn:
        cur = conn.cursor()
        cur.execute("SELECT username, member_id FROM members WHERE username LIKE ?", ('ka%', ))
        for row in cur:
            print(row)
except Exception as e:
    print(f'Error: {e}')

#------------------------------------------------------------------------------------------------------------------------------------
                                            15. Ders 26/04/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python standart kütüphanesindeki "DBM" isimli veritabanı ilişkisel olmayan (NoSQL) anahtar-değer çiftlerini tutulan basit bir 
    veritabanıdır. Aslında bu "dbm" modülü "Berkeley DB" denilen veritabanı kütüphanesini gerçekleştirmektedir. Yani buradaki veritabanının 
    orijinal tasarımcısı Berkeley California Üniversitesi bünyesindeki iki araştırıcıdır. Berkeley DB veritabanı ilk kez UNIX'in BSD 
    gerçekleştiriminin içerisinde yer almıştır. Daha sonra bu veritabanı çeşitli kurumlar tarafından birbirine benzer biçimde 
    gerçekleştirilmiştir. Örneğin GNU projesi kapsamında "GNU dbm" isiminde, Oracle firması tarafından "ndbm" isminde gerçekleştirimleri 
    vardır. Aslında Python standart kütüphanesindeki dbm modülü bu kurumların gerçekleştirimlerini kullanmaktadır. Yani ayrıca bu 
    kütüphenin motor kısmı yazılmamıştır. Mevcut kütüphaneler için ortak bir arayüz biçiminde işlev görmektedir. DBM veritabanı da 
    bir kütüphane gibi gerçekleştirilmiştir. Dolayısıyla "gömülü bir veritabanı" gibidir. 
    
    DBM veritabanı anahtar-değer çiftlerini tutmaktadır. Burada anahtarlar ve değerler string ya da bytes nesnesi biçiminde olmak 
    zorundadır. Veritabanı kendi içerisinde anahtar ve değerleri bize bytes nesnesi olarak vermektedir.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DBM veritabanı standart kütüphanede "dbm" isimli modülde bulunmaktadır. Bu nedenle kğtüphaneyi kullanırken modül aşağıdaki import 
    edilmelidir:
    
    import dbm

    Kütüphane kullanılırken ilk adım olarak open fonksiyonu ile veritabanı dosyası açılır. open fonksiyonunun parametrik yapısı şöyledir:

    dbm.open(file, flag='r', mode=0o666)

    Fonksiyonun birinci parametresi veritabanı dosyasının yol ifadesini belirtir. İkinci parametresi yapılacak işlemi belirtmektedir. 
    İkinci parametre tek karakterli bir yazı biçiminde girilir. Seçenekler şunlardır:

    'r': Ancak varolan bir dosya açılabilir. Burada veritabanından okuma yapılabilir. Ancak veritabanına yazma yapılmaz.
    'w': Ancak varolan bir dosya açılabilir. Burada veritabanından hem okuma yapılabilir hem de veritabanına yazma yapılabilir. 
    'c': Dosya varsa olan dosyayı açar. Dosya yoksa yaratır ve açar. Veritabanından hem okuma hem de yazma yapılabilir. 
    'n': Dosya varsa exception oluşur. Dosya yoksa yaratılır ve açılır. Veritabanından hem okuma hem de yazma yapılabilir. 

    Burada açış bayrağı için default değer 'r' verilmişse de en çok 'c' bayrağı kuullanılmaktadır. open fonksiyonun son parametresi 
    UNIX/Linux sistemlerindeki dosya erişim haklarını belirtmektedir. Dosya yaratılacaksa bu erişim haklarıyla yaratılmaktadır. 
    
    open fonksiyonu başarı durumunda bize veritabanı işlemlerini yapmak üzere bir sınıf nesnesi verir. Biz bu sınıf nesnesine dbm 
    nesnesi diyeceğiz. Başarısızlık durumunda exception oluşmaktadır. Programcı işi bittiği zaman dbm nesnesinin close metodu ile 
    veritabanı dosyasını kapatmalıdır. Örneğin:

    import dbm

    db = dbm.open('test', 'c')
    ...
    db.close()

    Dosya yaratılırken "db" uzantısı eklenmektedir.

    dbm nesnesine ilişkin sınıf "bağlam yönetim protokolünü" desteklemektedir. Yani biz bu işlemi with deyimi ile yapabiliriz. with 
    deyimi bittiğinde otomatik olarak close metodu çağrılacaktır. Örneğin:

    import dbm

    with dbm.open('test', 'c') as db:
        pass

    open fonksiyonu ile yeni bir veritabanı dosyası yaratıldığında dosya isminin sonuna ".dat" uzantısı eklenmektedir. 

    Artık dbm nesnesi yaratıldıktan sonra bu nesne adeta bir sözlük gibi kullanılabilmektedir. Ancak bu nesnenin Python'daki sözlükten 
    farkı anahtar ve değerleri diskte belirttiğimiz dosyada kalıcı biçimde tutmasıdır. Anahtarlar ve değerler ancak str ya da bytes
    nesnesi biçiminde olabilmektedir. Yani biz anahtar ve değer olarak str" ve bytes nesnesi dışında başka bir nesneyi kullanamayız. 
    DBM veritabanında aslında anahtarlar ve değerler "binary" bir byte dizisi biçiminde tutulmaktadır. Biz bir anahtar verdiğimizde 
    DBM bize her zaman onun değerini bytes nesnesi biçiminde vermektedir.

    DBM modülünde bazı durumlarda dbm.error sınıfı ile raise yapılmıtır. Ancak pek çok durumda da standart Exception sınıfları
    kullamnılmıştır. Programcı tüm exception'ları standart exception sınıfı ile elabilir. Ya da bunları ayrı ayrı ele almak isteyebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

keys = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
values = ['100', '200','300', '400', '500']

try:
    with dbm.open('sample', 'c') as db:
       for key, value in zip(keys, values):
           db[key] = value           
except dbm.error as e:
    print(e)
        
#------------------------------------------------------------------------------------------------------------------------------------
    Olmayan bir anahtara erişilmek istendiğinde tıpkı sözlüklerde olduğu gibi KeyError exception'ı oluşmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('mydb', 'c') as db:
        val = db['xxxx']
        print(val)
except dbm.error as e:
    print(f'DBM Error: {e}')
except Exception as e:
    print(f'Error: {e}')
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tıpkı sözlüklerde olduğu get metodu anahtara karşı gelen değeri elde etmek için kullanılabilmektedir. Yine get metodu eğer anahtar 
    yoksa ikinci parametresinde belirtilen değeri geri döndürmektedir. İkinci parametre girilmezse metot yine None değeri ike geri döner. 
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('sample', 'c') as db:
        if value := db.get('ali'):
            print(value.decode())
        else:
            print('Böyle bir anahtar yok!')
except dbm.error as e:
    print(e)
  
#------------------------------------------------------------------------------------------------------------------------------------
    Tıpkı sözlüklerde olduğu gibi veritabanındaki tüm anahtarları keys isimli metotla elde edebiliriz. keys metodu bize anahtarlardan 
    oluşan bir bytes listesi vermektedir. (Normal sçzlüklerde keys metodunun liste değil dolaşılabilir başka bir nesne verdiğini 
    anımsayınız.)
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('mydb', 'c') as db:
       keys = db.keys()
       print(keys)
except dbm.error as e:
    print(f'DBM Error: {e}')
except Exception as e:
    print(f'Error: {e}')
    
#------------------------------------------------------------------------------------------------------------------------------------
    Anahtarları ve değerleri biz yalnızca str ve bytes nesneleri biçiminde verebilmekteyiz. Ancak biz anahtar ve değerleri str olarak 
    versek bile DBM bize her zaman bunları bytes nesnesi olarak geri vermektedir. Çünkü dbm her şeyi kendi içerisinde bytes nesneleri 
    biçiminde saklamaktadır. Yani biz DBM veritabanına anahtar ya da değeri strolarak verdiğimizde o zaten bunları bytes nesnesine 
    dönüştürüp saklamaktadır. Biz eğer değerleri yine str olarak almak istersek bytes nesnesini str türüne dönüştürmemiz gerekir. bytes 
    sınıfının decode metodunun bunu yaptığını anımsayınız. Eğer decode metodunda "encoding" belirtilmezse "utf-8" kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('mydb', 'c') as db:
        val = db['ali'].decode()
        print(val)     
except dbm.error as e:
    print(f'DBM error: {e}')
except Exception as e:
    print(f'Error: {e}')
    
#------------------------------------------------------------------------------------------------------------------------------------
    in operatörü sözlüklerde olduğu gibi ilgili anahtarın veritabanında olup olmadığı bilgisini bize verir. in operatörünün sol tarafındaki operand
    bir string ya da bytes nesnesi olabilir. Tabii bu durumda eğer sol taraftaki operand string ise anahtarla karşılaştırılırken bytes nesnesine 
    dönüştürülecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('mydb', 'c') as db:
        if 'ali' in db:
            print('var')
        else:
            print('yok')      
except dbm.error as e:
    print(f'DBM Error: {e}')
except Exception as e:
    print(f'Error: {e}')

#------------------------------------------------------------------------------------------------------------------------------------
    Tıpkı sözlüklerde olduğu gibi bir anahtar-değer çifti pop metoduyla yine silinebilmektedir. pop metodu bize yine silinen anahtara 
    ilişkin değeri verirr. del deyimi ile de anahtar verilerek silme yapılabilmektedir. Örneğin:

    del db['ali']   
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('mydb', 'c') as db:
        del db['ali'] 
except dbm.error as e:
    print(f'DBM Error: {e}')
except Exception as e:
    print(f'Error: {e}')

#------------------------------------------------------------------------------------------------------------------------------------
    dbm nesneleri de dolaşılabilir nesnelerdir. Yine dbm nesneleri dolaşıldığında anahtarlar elde edilmektedir. Örneğin:

    try:
        with dbm.open('sample', 'c') as db:
        for key in db:
            print(key)
    except dbm.error as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try:
    with dbm.open('sample', 'c') as db:
       for key in db:
           print(key)
except dbm.error as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    DBM veritabanının anahtar-değer çiftlerini bytes nesneleri biçiminde tuttuğuna dikkat ediniz. Biz int gibi float gibi değerleri 
    bu veritabanlarında saklayacaksak onları yazıya ya da bytes nesnelerine dönüştürmemiz gerekir. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
    weights = [78.2, 59.3, 85.6, 55.4, 60.8]

    try:
        with dbm.open('sample', 'c') as db:
        for name, weight in zip(names, weights):
            db[name] = str(weight)
    except dbm.error as e:
        print(e)
        
    Burada anhtarlar str türündendir ancak değerler float türündendir. Biz de bu float değerleri dbm veritabanında saklamadan önce
    str türüne dönüştürdüki Tabii biz dbm veritabanından değerleri her zaman bytes nesnesi biçiminde alırız:

    try:
        with dbm.open('sample', 'r') as db:
            for name in db:
                print(name.decode(), float(db[name].decode()))
    except dbm.error as e:
        print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
weights = [78.2, 59.3, 85.6, 55.4, 60.8]

try:
    with dbm.open('sample', 'c') as db:
        for name, weight in zip(names, weights):
            db[name] = str(weight)
except dbm.error as e:
    print(e)
    
try:
    with dbm.open('sample', 'r') as db:
        for name in db:
            print(name.decode(), float(db[name].decode()))
except dbm.error as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda benzer bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import dbm

try: 
    with dbm.open('test', 'c') as db:
        while True:
            no = int(input('No:'))
            if no == 0:
                break
            name = input('Adı:')
            db[str(no)] = name
except dbm.error as e:
    print(e)
except Exception as e:
    print(e)
    
try: 
    with dbm.open('test', 'c') as db:
        for no in db.keys():
            print(f'{no.decode()} --> {db[no].decode()}')
except dbm.error as e:
    print(e)
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi DBM veritabanı hangi durumlarda kullanılabilir? Ne de olsa sqlite çok daha genel amaçlı bir veritabanı ortamını bize sunmaktadır.
    Eğer elimizde anahtar-değer çiftleri varsa bunların saklanması ve geri alınması DBM veritabanıyla daha hızlı ve daha etkin bir 
    biçimde yapılabilmektedir. Ayrıca DBM veritabanının kullanımı da ilişkisel veritabanlarına göre daha kolaydır. Örneğin çeşitli 
    konfigürasyon bilgileri, ayar bilgileri kolay bir biçimde bu DBM veritabanı sayesinde dosyalarda saklanabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce de belirttiğimiz gibi sslında yukarıda kullandığımız dbm modülündeki fonksiyonlar ve metotlar genel bir arayüzdür. Yani 
    bunlar arka planda DBM veritabanının çeşitli gerçekleştirimlerini kullanmaktadır. Biz dbm.open fonksiyonunu çağırdığımızda bu open 
    fonksiyonu sırasıyla dbm.gnu, dbm.ndbm ve dbm.dumb gerçekleştirimlerinden hangisi sistemde varsa onu kullanmaktadır. dbm.dumb 
    gerçekleştirimi tamamen Python'da yazıldığı için genel olarak dbm.gnu ve dbm.ndbm gerçekleştirimlerinden daha yavaş olma eğilimindedir. 
    Biz yarattığımız DBM veritabanının hangi DBM gerçekleştirimi ile yaratılmış olduğunu dbm.whichdb fonksiyonu ile öğrenebiliriz. 
    Örneğin:

    import dbm

    print(dbm.whichdb('mydb'))

    Burada Windows sistemlerinde muhtemelen "dbm.dumb" biçiminde bir çıktı elde edeceksiniz. Bu çıktı default gerçekleştirimin yavaş
    olan Python gerçekleştirimi olduğu anlamına gelmektedir. macOS sistemlerinde default kullanılan gerçekleştirim ise genellikle 
    "dbm.ndbm" biçimindedir. Linux sistemlerinde ise default gerçekleştirim genellikle "dbm.gnu" biçimindedir. 

    Tabii programcı isterse ve o sistemde yüklü ise spesifik gerçekleştirimi kullanabilir. Örneğin:

    import dbm.ndbm

    try:
        with dbm.ndbm.open('mydb', 'c') as db:
            pass
    except dbm.error as e:
            print(f'DBM error: {e}')
        except Exception as e:
            print(f'Error: {e}')

    Windows sistemlerinde dbm.ndbm gerçekleştirimi ya da dbm.gnu gerçekleştirimi default durumda yüklü değildir. Ancak Linux sistemlerinde
    ve macOS sistemlerinde dbm.gnu, dbm.ndbm ve dbm.dump gerçekleştirimlerinin hepsi default durumda muhtemelen yüklü olacaktır. 
    Eğer dbm.dump gerçekleştirimi kullanılıyorsa bu gerçekleştirim ".dat" ve ".dir" uzantılı iki dosya kullanmaktadır. ".dir" dosyasında
    anahtarlar, ".dat" dosyasına değerler tutulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python ile işletim sistemi düzeyinde bazı işlemlerin gerçekleştirilmesi üzerinde üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da işletim sistemine ilişkin bazı önemli işlemleri gerçekleştirebilmek için standart kütüphane içerisinde "os" isimli bir 
    modül bulundurulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    os.getcwd fonksiyonu prosesin çalışma dizinini (current working directory) alır, os.chdir fonksiyonu ise çalışma dizinini
    değiştirir. Biz bu iki fonksiyonu aslında Python derslerinde de görmüştük. Anımsayacağınız gibi "prosesin çalışma dizini (cuurent
    woriking directory)" sistemi tarafından göreli (relative) yol ifadelerini çözmek amacıyla orijin belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import os

cwd = os.getcwd()
print(cwd)

os.chdir('c:\\')    

cwd = os.getcwd()
print(cwd)

#------------------------------------------------------------------------------------------------------------------------------------
    os.remove fonksiyonu yol ifadesiyle belirtilen dosyayı silmek için kullanılmaktadır. Dosya yoksa ya da dosyaya erişim  hakkı 
    yeterli değilse exception oluşmaktadır. Bu fonksiyon ile silinen dosyalar "geri dönüş kutusuna (recycle bin)" yerleştirilmemektedir. 
    Geri dönşüm kutuları işletim sistemlerinin çekirdeklerinin (kernels) sağladığı bir mekanizma değildir. Tamamen kabuklar (shells) 
    tarafından sağlanan bir mekanizmadır. os modülü isminden de anlaşıldığı gibi doğurdan işletim sisteminin çekirdek fonksiyonlarının 
    çağrılmasına yol açmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.remove(r'C:\Users\CSD\Desktop\test.csv')
except Exception as e:
    print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    os.rename fonksiyonu dosyanın ismini değiştirmek için kullanılır. Yine çeşitli sorunlada exception fırlatılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.rename('mydb.dat', 'mydb.dbm')
except Exception as e:
    print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Dosyanın ismini değiştirmek aslında dosyayı taşımak (move) anlamına gelmektedir. Yani eğer biz dosyanın ismini başka bir dizindeki 
    bir dosya olarak değiştirirsek onu taşımış oluruz.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.rename('mydb.dbm', 'f:\\mydb.dbm')
except Exception as e:
    print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Boş bir dizin yaratmak için os.mkdir fonksiyonu kullanılmaktadır. Yine yaratım başarısız olursa exception fırlatılır.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.mkdir('mydir')
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Dizin silmek için os.rmdir fonksiyonu kullanılmaktadır. Ancak boş bir dizin silinebilir. İçerisinde dosya ya da başka bir dizin
    bulunan dizinleri os.rmdir fonksiyonu ile silemeyiz. Silmeye çalışırsak exception oluşur. Yalnızca boş dizinlerin silinebilmesinin
    nedeni tamamen güvenliktir. Eğer içi dolu dizinler de silinebilseydi yanlışlıkla büyük bir dizin ağacı silinebilirdi. Grafik arayüze
    sahip kabuklarda içi dolu dizinlerin DEL tuşuna basılarak silinmesi sizi şaşırtabilir. Grafik arayüze sahip kabuklar bu biçimde 
    bir dizin ağacı silindiğinde onu "geri dönüşüm kutusuna" yerleştirdikleri için bir güvenlik problemi oluşturmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.rmdir('mydir')
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    os.truncate fonksiyonu bir dosyayı sondan kırparak küçültmek ya da büyütmek amacıyla kullanılmaktadır. Eğer dosya büyütülürse büyütülen 
    kısmı 0'larla doldurulur. os.truncate fonksiyonu dosyanın yol ifadesini ve dosyanın yeni uzunluğunu parametre olarak almaktadır. 
    Dosya büyütüldüğünde pek çok dosya sisteminde büyütme işlemi "dosya deliği (file hole)" oluşturularak sağlanmaktadır. Ayrıca bu 
    fonksiyonun dosya betimleyicisi (file descriptor) alan ftruncate biçiminde bir benzeri de vardır. 

    Bir dosyanın kırpılması o dosyanın içeriğinin bozluması sonucunu doğurabilir. Bir text dosyanın kırpılmasında genellikle bir sorun 
    oluşmasa da jpeg, gibi, Word ve Excel dosyaları gibi dosyaların ya da çalıştırılabilir (executable) dosyaların kırpılması o dosyaları
    kullanılamaz hale getirebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    os.truncate('test.db', 1000000)
    print('Ok')
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Komut satırında (kabuk üzerinde) çalıştırdığımız her komutu biz Python'da os.system fonksiyonu ile programlama yoluyla çalıştırabiliriz. 
    Örneğin UNIX/Linux ve macOS sistemlerinde dizin listesini almak için "ls -l" komutu kullanılmaktadır. Biz bu komutu programlama 
    yoluyla Python içerisinden aşağıdaki gibi de çalıştırabiliriz:

    os.system('ls -l')

    Komut satırında verebildiğimiz tüm komutlar bu biçimde işletilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Belli bir dosyanın metadata bilgilerini elde etmek için os.stat fonksiyonu kullanılmaktadır. Bu fonksiyon bizden dosyanın yol 
    ifadesini alır, bize stat_result isimli bir sınıf nesnesi verir. Bu stat_result sınıfının st_xxxx biçiminde isimlendirilmiş olan
    bir grup örnek özniteliği vardır. Biz dosyanın çeşitli bilgilerini bu örnek özniteliklerinden elde edebiliriz. Buradaki örnek 
    özniteliklerinin bazıları işletim sistemine bağlı aşağı seviyeli bilgiler içermektedir. Biz bu ayrıntılara grimeyeceğiz. Örneğin 
    bu sınıf nesnesinin st_size isimli özniteliği bize dosyanın uzunluğunu vermektedir. Tabii söz konusu dosya yoksa yine exception 
    oluşcaktır. stat_result nesnesinin st_atime özniteliği dosyadan son okumanın zamanını, st_mtime özniteliği ise dosyaya son yazma 
    zamanını vermektedir. Ancak bu önitelikler bu zaman bilgisini 01/01/1970'ten geçen saniye sayısı biçiminde verirler. time modülünde 
    bu bilgiyi okunaklı tarih zaman bilgisine dönüştüren fonksiyonların olduğunu anımsayınız. 
#------------------------------------------------------------------------------------------------------------------------------------

import os
import time

try:
    result = os.stat('test.txt')
    print(f'Dosya uzunluğu: {result.st_size}')
    print(f'Son okuman zamanı: {time.ctime(result.st_atime)}')
    print(f'Son yazma zamanı: {time.ctime(result.st_mtime)}')    
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
                                            16. Ders 26/04/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    os.listdir fonksiyonu bir dizin içerisindeki tüm girişlerin (yani dizin ve dosyaların) isimlerini bize bir liste olarak vermektedir. 
    Örneğin:

    dents = os.listdir('.')
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    dents = os.listdir('.')
    for dent in dents:
        print(dent)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    os.listdir fonksiyonuyla elde ettiğimiz dizin girişlerini os.stat fonksiyonuna sokarak o girişlere ilişkin dosya ve dizinlerin 
    metadata bilgilerini elde edebiliriz. Örneğin:

    dents = os.listdir('.')
    for dent in dents:
        ss = os.stat(dent)
        print(f'{dent:20s}{ss.st_size:5d}')

    Burada önce prosesin çalışma dizinindeki dizin girişleri elde edilmiş sonra bunlar stat fonksiyonun sokularak bu dizin girişlerine 
    ilişkin dosya uzunlukları elde edilerek yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    dents = os.listdir('.')
    for dent in dents:
        ss = os.stat(dent)
        print(f'{dent:20s}{ss.st_size:5d}')
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    os.scandir fonksiyonu da dizin içerisindeki dizin girişlerini bize verir. Ancak bu fonksiyon dizin girişlerini bir liste olarak 
    değil dolaşılabilir bir nesne olarak vermektedir. Böylelikle dizin girişleri aslında dolaşım sırasında elde edilmiş olur. Ayrıca 
    scandir dizin girişlerini yalnızca bir isim olarak değil os.DirEntry isimli bir sınıf nesnesi olarak bize vermektedir. os.DirEntry 
    sınıfının name isimli örnek özniteliğinden biz dizin girişinin ismini alabiliriz. Sınıfın stat metoduyla o girişin metadata bilgilerini 
    de elde edebiliriz. Ayrıca o girişin bir dizin mi yoksa dosya mı olduğunu da os.DirEntry  sınıfının is_file ve is_dir fonksiyonlarıyla 
    öğrenebiliriz. Sınıfın path isimli örnek özniteliği bize dosyanın yol ifadesini scandir fonksiyonunda girdiğimiz dizin ifadesini başa 
    ekleyerek vermektedir. Büyük dizinlerde dizin girişlerinin listdir fonksiyonu ile bir listeye doldurulması gecikmeye yol açabilmektedir. 
    Bu tür durumlarda scandir fonksiyonu tercih edilebilir.  
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
    dents = os.scandir('.')
    for dent in dents:
        print(f'{dent.name:20s}', end='')
        sr = dent.stat()
        if dent.is_dir():
            print('<DIR>')
        else:
            print(f'{sr.st_size:5d}')   
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    os.walk fonksiyonu özyinelemeli olarak dizin ağacınıdolaşan bir iterator nesnesi vermektedir. Aslında fonksiyon üretici fonksiyon 
    (generator) biçiminde yazılmıştır. Her yinelemede iç bir dizinin bilgisi elde edilmektedir. Üretici fonksiyon bize dolaşım sırasında 
    üçlü bir demet verir. Demetin ilk elemanı o anda girilen dizinin yol ifadesini, ikinci elemanı o dizindeki dizinlerin isimlerini, 
    üçüncü elemanı ise o dizindeki dosyaların isimlerini vermektedir. Fonksiyonu tipik olarak şöyle kullanırız:

    for root, dirs, files in os.walk(path):
        pass 
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
   for root, dirs, files in os.walk(r'C:\Dropbox\Shared\Kurslar\Python-App'):
       print(root)
       for file in files:
           print(f'{file:30s}')
       for file in dirs:
             print(f'{file:30s}<DIR>')      
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Dizin ağacında belli dosyaları bulmak gibi işlemlerle sık karşılaşılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import os

try:
   for root, dirs, files in os.walk('C:\\'):
     for file in files:
         if file.lower() == 'sample.py':
             print(root)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında dizin ağacını kendimiz de özyinelemeli (recursive) bir fonksiyonla dolaşabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import os

def mywalk(path):
    for de in os.scandir(path):
        try:
            if de.is_dir():
                print(de.name)
                mywalk(path + '/' + de.name)       
        except:
            pass
            
mywalk(r'f:\dropbox\kurslar\python-app')
 
#------------------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını özyinelemeli dolaşırken bir level parametresi ekleyebiliriz. Böylece bu parametre sayesinde dizin
    ağacını kademeli biçimde görüntüleyebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import os

def walk(path, level):
    for dent in os.scandir(path):
        try:
            if dent.is_dir():
                print(' ' * level * 4 + dent.name)
                walk(path + '/' + dent.name, level + 1)    
        except:
            pass
                
walk('.', 0)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodu üretici fonksiyon haline de getirebiliriz. Ancak  üretici fonkisyonların özyinelemeli olarak
    çağırırken yield from uygulamak gerekir. 
#------------------------------------------------------------------------------------------------------------------------------------

import os

def walk(path, level):
    for dent in os.scandir(path):
        if dent.is_dir():
                yield dent.name, level
                yield from walk(path + '/' + dent.name, level + 1)    
                
for name, level in walk(r'C:\Dropbox\Shared\Kurslar', 0):
    print(' ' * level * 4, name)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanedeki glob modülü de dizin içerisinde dosyaları elde etmek için kullanılmaktadır. Ancak bu modül joker karaktelerinin 
    (wild cards) kullanımına izin vermektedir. glob.glob fonksiyonunun parametrik yapısı şöyledir:

    glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)
    
    glob.glob fonksiyonu bir listeye geri dönmektedir. glob normalde dizini özyinelemeli biçimde dolaşmaz. Ancak fonksiyonun recursive 
    parametresi True geçilirse özyinelemeli dolaşım yapılabilir. 

    glob.glob fonksiyonunun birinci parametresi bir dizin olarak geçilmez. Bu parametreye dosya belirten joker karakterli bir kalıp 
    getirilmelidir. Örneğin:

    r'c:\windows\*.exe' (Windows dizinin altındaki .exe uzantılı dosyalar)
    r'c:\windows\*'     (Windows dizininin altındaki tüm dosyalar) 
    r'a*'               (Bulunulan dizindeki başı "a" ile başlayan tüm dosyalar)
#------------------------------------------------------------------------------------------------------------------------------------

import glob

result = glob.glob(r'c:\windows\*.exe')
print(result)

result = glob.glob(r'c:\windows\t*.exe')
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Özyinelemeli dolaşmak için kalıbın "**" biçiminde olması gerekmektedir. Özyinelemeli dolaşımda tüm dosyaların bir liste biçiminde 
    geri döndürülmesi uzun bekleme zamanına yol açabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import glob

files = glob.glob(r'.\**', recursive=True)

for file in files:
    print(file)

#------------------------------------------------------------------------------------------------------------------------------------
    glob.iglob fonksiyonu glob.glob fonksiyonu gibidir. Ancak üretici fonksiyon olarak yazılmıştır. Yani dizin içerisindeki
    dosyaları bir liste olarak olarak değil, dolaşılabilir bir nesne biçiminde vermektedir. Böylece fonksiyon uzun süre bekleme 
    yapmamaktadır. glob.iglob fonksiyonunun parametrik yapısı benzer biçimdedir:

    glob.iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False) 
#------------------------------------------------------------------------------------------------------------------------------------

import glob

result = glob.iglob(r'c:\windows\*.exe')

for path in result:
    print(path)
    
#------------------------------------------------------------------------------------------------------------------------------------
    glob.iglob fonksiyonu fonksiyonu ile de özyinelemeli dolaşım yapabiliriz. Ancak kalıp ** biçiminde olmak zorundadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import glob

files = glob.iglob(r'c:\**', recursive=True)

for file in files:
    print(file)

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da nesnelerin "seri hale getirilmesi (object serialization)" konusu üzerinde duracağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Nesneleri başka bir ortamda (tipik olarak dosyalarda) saklayıp geri alma işlemine "nesnelerin seri hale getirilmesi (object 
    serialization)" denilmektedir. Nesnelerin seri hale getirilmesi kolay bir işlem değildir. Çünkü nesneler nesneleri tutabildiği için 
    seri hale getirme sırasında pek çok kontrolün de yapılması gerekmektedir. Seri hale getirilerek örneğin bir dosyada saklanmış olan 
    nesne yeniden oradan alınıp bellekte oluşturulabilmektedir. Pek çok programlama dilinin standart kütüphanesinde bu işi yapacak öğeler 
    bulunmaktadır. 
        
    Python'da seri hale getirme işlemi pickle ("pickle" turşu anlamına gelmektedir) isimli bir modülle gerçekleştirilmektedir. pickle 
    modülünün  dump isimli fonksiyonu bizden seri hale getirilecek nesneyi ve dosyayı (dosya open ile açılmış olmalıdır) alır. Dosya 
    göstericisinin gösterdiği yerden itibaren nesnenin bilgilerini dosyaya yazar. Normal olarak dosyanın "binary modda ve yazılabilir 
    biçimde (tipik olarak 'wb' modeunda)" açılmış olması gerekmektedir. Örneğin:

    a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']

    with open('test.dat', 'wb') as f:
        pickle.dump(a, f)
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']

with open('test.dat', 'wb') as f:
    pickle.dump(a, f)

#------------------------------------------------------------------------------------------------------------------------------------
    pickle modlünün load fonksiyonu dump ile yapılanın tersini yapmaktadır. Yani dosya göstericisinin gösterdiği yerden itibaren 
    dosyadaki bilgileri okur. Onu orijinal nesne olarak bize verir. Tabii dosyanın yine binary modda ve okunabilir biçimde (tipik 
    olarak 'rb' modunda) açılmış olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

with open('test.dat', 'rb') as f:
    a = pickle.load(f)
    print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii her nesneyi ayrı bir dosyada saklamaya gerek yoktur. Bir dosyada peşi sıra birden fazla nesne saklanabilir. Ancak bunların 
    yine aynı sırada geri alınması gerekir. Örneğin:

    with open('test.dat', 'wb') as f:
        pickle.dump(a, f)
        pickle.dump(b, f)
        pickle.dump(c, f)
        pickle.dump(d, f)
        
    with open('test.dat', 'rb') as f:
        x = pickle.load(f)
        y = pickle.load(f)
        z = pickle.load(f)
        k = pickle.load(f)
#------------------------------------------------------------------------------------------------------------------------------------

import pickle
import datetime

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']
b = {1, 2, 'fehmi', 'ercan'}
c = (10, 20, 30, 40, 50)
d = datetime.datetime(2021, 11, 16, 20, 25, 12)

with open('test.dat', 'wb') as f:
    pickle.dump(a, f)
    pickle.dump(b, f)
    pickle.dump(c, f)
    pickle.dump(d, f)
    
with open('test.dat', 'rb') as f:
    x = pickle.load(f)
    y = pickle.load(f)
    z = pickle.load(f)
    k = pickle.load(f)
    
print(x)
print(y)
print(z)
print(k)
    
#------------------------------------------------------------------------------------------------------------------------------------
    load işlemi sırasında dosya göstericisinin aynı konumda olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pickle
import datetime

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']
b = {1, 2, 'fehmi', 'ercan'}
c = (10, 20, 30, 40, 50)
d = datetime.datetime(2021, 11, 16, 20, 25, 12)

with open('test.dat', 'w+b') as f:
    pickle.dump(a, f)
    pickle.dump(b, f)
    pickle.dump(c, f)
    pickle.dump(d, f)
    
    f.seek(0)
    
    x = pickle.load(f)
    y = pickle.load(f)
    z = pickle.load(f)
    k = pickle.load(f)
    
    print(x)
    print(y)
    print(z)
    print(k)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla nesneyi aynı dosyaya seri hale getirirken bunları karışık sırada alacaksak onların dosya içerisindeki offset 
    numaralarını bir biçimde tutup, sonra dosya göstericisini o offset'e çekip pickle.load işlemi yapılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import pickle
import datetime

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']
b = {1, 2, 'fehmi', 'ercan'}
c = (10, 20, 30, 40, 50)
d = datetime.datetime(2021, 11, 16, 20, 25, 12)

with open('test.dat', 'wb') as f:
    pos_a = f.tell()
    pickle.dump(a, f)
    pos_b = f.tell()
    pickle.dump(b, f)
    pos_c = f.tell()
    pickle.dump(c, f)
    pos_d = f.tell()
    pickle.dump(d, f)
    
with open('test.dat', 'rb') as f:
    f.seek(pos_c, 0)
    c = pickle.load(f)
    print(c)
    
    f.seek(pos_a, 0)
    a = pickle.load(f)
    print(a)
    
    f.seek(pos_d, 0)
    d = pickle.load(f)
    print(d)
    
    f.seek(pos_b, 0)
    b = pickle.load(f)
    print(b)
  
#------------------------------------------------------------------------------------------------------------------------------------
    Kendi sınıf nesnelerimizi de aynı biçimde seri hale getirip alabiliriz. Örneğin:

    class Student:
        def __init__(self, name, no):
            self.name = name
            self.no = no
            
        def __repr__(self):
            return f'{self.name}, {self.no}'
        
    ali = Student('Ali Serçe', 123)
    veli = Student('Veli Durmuş', 678)
    selami = Student('Selami Özışık', 721)

    with open('test.dat', 'wb') as f:
        pickle.dump(ali, f)
        pickle.dump(veli, f)
        pickle.dump(selami, f)
        
    with open('test.dat', 'rb') as f:
        x = pickle.load(f)
        y = pickle.load(f)
        z = pickle.load(f)
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

class Student:
    def __init__(self, name, no):
        self.name = name
        self.no = no
        
    def __repr__(self):
        return f'{self.name}, {self.no}'
    
ali = Student('Ali Serçe', 123)
veli = Student('Veli Durmuş', 678)
selami = Student('Selami Özışık', 721)

with open('test.dat', 'wb') as f:
    pickle.dump(ali, f)
    pickle.dump(veli, f)
    pickle.dump(selami, f)
    
with open('test.dat', 'rb') as f:
    x = pickle.load(f)
    y = pickle.load(f)
    z = pickle.load(f)
    
print(x)
print(y)
print(z)

#------------------------------------------------------------------------------------------------------------------------------------
    Seri hale getirme sayesinde karmaşık birtakım nesneleri tek hamlede dosyalarda saklayıp geri alabilmekteyiz.
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

graph = {'A': {'B': 70, 'D': 30}, 'B': {'C': 60, 'G': 50}, 'C': {'E': 40}, 
         'D': {'A': 30, 'C': 50}, 'E': {'G': 30, 'D': 60}, 'F': {'E': 40}}

with open('graph.dat', 'wb') as f:
    pickle.dump(graph, f)
    
with open('graph.dat', 'rb') as f:
    graph_loaded = pickle.load(f)
    
print(graph_loaded)

#------------------------------------------------------------------------------------------------------------------------------------
    Birtakım veri yapıları çok daha karmaşık görünümde olabilir. Ancak pickle modülü ile biz tek hamlede karmaşık veri yapılarını 
    saklayıp geri alabiliriz. Aşağıdaki örnekte bir graph veri yapısı Vertex, Edge ve Graph sınıflarıyla oluşturulmuştur. Vertex sınıfı 
    bir ismi, Edge sınıfı iki vertex'i ve bir değeri, Graph sınıfı ise belli bir vertex'e bağlı edge'leri tutmaktadır. Tüm graf 
    tek hamlede saklanıp geri yüklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

class Vertex:
    def __init__(self, name):
        self.name = name
        
    def __repr__(self):
        return self.name
    
class Edge:
    def __init__(self, v1, v2, val):  
        self.v1 = v1
        self.v2 = v2
        self.val = val
        
    def __repr__(self):
        return f'{self.v1.name} ---> {self.v2.name}'
        
class Graph:
    def __init__(self):
        self.vertexes = {}
        
    def add_edge(self, edge):
        if not self.vertexes.get(edge.v1):
            self.vertexes[edge.v1] = set()
            
        self.vertexes[edge.v1].add(edge)
        
    def __repr__(self):
        result = ''
        for vertex in self.vertexes:
            result += f'{vertex.name}: {self.vertexes[vertex]}\n'
        return result
                   
a = Vertex('A')
b = Vertex('B')
c = Vertex('C')
d = Vertex('D')
e = Vertex('E')
f = Vertex('F')
g = Vertex('G')

graph = Graph()

graph.add_edge(Edge(a, b, 70))
graph.add_edge(Edge(a, d, 30))
graph.add_edge(Edge(b, g, 50))
graph.add_edge(Edge(d, c, 50))
graph.add_edge(Edge(f, e, 40))
graph.add_edge(Edge(g, c, 50))

with open('graph.dat', 'wb') as f:
    pickle.dump(graph, f)
    
with open('graph.dat', 'rb') as f:
    graph_loaded = pickle.load(f)
    
print(graph_loaded)

#------------------------------------------------------------------------------------------------------------------------------------
                                        17. Ders 03/05/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Dersin başında pryear fonksiyonun yazımına ilişkin ödev yapıldı.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    pickle modülünün dumps isimli fonksiyonu nesneyi byte yığını olarak seri hale getirir. dumps bize seri hale getirilmiş nesnenin 
    byte'larını bytes nesnesi olarak vermektedir. Modülün loads fonksiyonu ise bizden bytes nesnesini alır onu deserialize ederek 
    orijinal nesneyi oluşturur. Bu iki fonksiyon özellikle nesnenin dosyada saklanması yerine başka bir yere aktarılması amacıyla 
    kullanılmaktadır. Örneğin biz bir nesneyi seri hale getirip soketten uzak makineye yollamak isteyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']

b = pickle.dumps(a)
print(b)

c = pickle.loads(b)
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Seri hale getirme ve geri alma işlemleri için pickle modülünde Pickler ve Unpickler isimli iki sınıf da bulundurulmuştur. Yani 
    biz bu işlemleri nesne yönelimli biçimde de yapabiliriz. Pickler ve Unpickler sınıflarının __init__ metotları bizden dosya 
    nesnesini alıp nesnenin özniteliğinde saklar. Pickler sınıfının dump metodu ve Unpickler sınıfının load metodu seri hale getirme 
    ve geri alma işlemlerini yapmaktadır. Örneğin:

    import pickle

    a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    with open('pickle.dat', 'wb') as f:
        pickler = pickle.Pickler(f)
        pickler.dump(a)
        
    with open('pickle.dat', 'br') as f:
        unpickler = pickle.Unpickler(f)
        b = unpickler.load()    
    
    Aslında dump ve load fonksiyonları bu sınıfları kullanan sarma (wrapper) fonksiyonlardır. Bu fonksiyonlar tipik olarak şöyle 
    yazılmıştır:

    def dump(obj, f):
        p = pickle.Pickler(f)
        p.dump(obj)
        
    def load(f):
        up = pickle.Unpickler(f)
        return up.load(up)
#------------------------------------------------------------------------------------------------------------------------------------

import pickle

a = ['ali', ['veli, selami'], {6: 'ankara', 26: 'eskişehir', 34: 'istanbul'}, 'sacit']

with open('test.dat', 'wb') as f:
    pickler = pickle.Pickler(f)
    pickler.dump(a)
    
with open('test.dat', 'rb') as f:
    unpickler = pickle.Unpickler(f)
    b = unpickler.load()
    
print(b)
    
def mydump(o, f):
    pickler = pickle.Pickler(f)
    pickler.dump(o)
    
def myload(f):
    unpickler = pickle.Unpickler(f)
    return unpickler.load()

with open('pickle.dat', 'wb') as f:
    mydump(a, f)
    
with open('pickle.dat', 'rb') as f:
    b = myload(f)

print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    shelve modülü aslında dbm ile pickle modüllerinin birleşimi gibidir. Anımsanacağı gibi dbm modülünde anahtarlar ve değerler yalnızca 
    str ve bytes nesnesi olabiliyordu. İşte shelve modülü de kullanım bakımından tamamen dbm modülü gibidir. Ancak shelve modülünde
    değerler herhangi bir türden olabilmektedir. Aslında shelve modülü kendi içerisinde nesneleri önce dumps ile seri hale getirip 
    onları bytes nesnesine dönüştürmekte ve bu bytes nesnelerini dbm modülü ile dosyaya yazamaktadır. Benzer biçimde shelve modülünde 
    biz anahtarı verdiğimizde shelve modülü önce anahtarın değerini bytes nesneleri alır ancak onu loads fonksiyonu ile orijinal türe 
    dönüştürerek verir. shelve.open fonksiyonunun bize verdiği shelve nesnesi de dolaşılabilir bir nesnedir. shelve nesnesi dolaşıldığında 
    anahtarlar elde edilmektedir. 

    shelve modülünde değerler herhangi bir türden olabilir. Ancak anahtarlar str türünden olmak zorundadır. Örneğin:

    import shelve

    s = shelve.open('shelve.dat', 'c')

    s['ali'] = 128
    s['veli'] = [10, 20, 30, 40]
    s['selami'] = {'eskişehir', 'ankara', 'izmir'}
    s.close()
#------------------------------------------------------------------------------------------------------------------------------------

import shelve

s = shelve.open('shelve.dat', 'c')

s['ali'] = 128
s['veli'] = [10, 20, 30, 40]
s['selami'] = {'eskişehir', 'ankara', 'izmir'}
s.close()

s = shelve.open('shelve.dat', 'c')

result = s['selami']
print(result)

s.close()

#------------------------------------------------------------------------------------------------------------------------------------
    Yine shelve nesnesinde de dbm'de olduğu gibi sözlük işlemleri uygulanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import shelve

with shelve.open('shelve.dat', 'c') as s:
    for key in s:
        print(key)

#------------------------------------------------------------------------------------------------------------------------------------
    open fonksiyonun writeback isimli üçüncü bir parametresi de vardır. Bu parametre default durumda False biçimdedir. Eğer bu parametre 
    True yapılırsa shelve nesnesi kapatılırken anahtarın değeri üzerinde bir değişiklik yapılmışsa (tabii bu durumda değerin değiştirilebilir
    bit türden olması gerekir) otomatik olarak bu değişiklik nesneye yansıtılmaktadır. Örneğin:

    s = shelve.open('test', 'c', writeback=True)
    a = [10, 20, 30]
    s['a'] = a
    a.append(100)
    s.close()

    Burada aslında shelve nesnesine yerleştirme yapılırken bu 100 değeri listenin içerisinde değildir. Ancak writeback parametresi 
    True yapıldığında shelve nesnesi kapatılırken bu anahtarın son hali yeniden diske kaydedilir. Artık yukarıdaki örnekte biz aynı
    dosyayı açıp 'a' anahtarını okuduğumuzda elde ettiğimiz listenin içerisinde 100 değeri de olacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    shelve modülünün dbm ve pickle modülleri kullanılarak nasıl gerçekleştirilmiş olabileceği konusunda aşağıdaki kod size bir fikir 
    verecektir.  
#------------------------------------------------------------------------------------------------------------------------------------

import dbm
import pickle

def myopen(*args, **kwargs):
    return myshelve(dbm.open(*args, **kwargs))
    
class myshelve:
    def __init__(self, db):
        self.db = db
        
    def __setitem__(self, key, value):
        self.db[key] = pickle.dumps(value)
        
    def __getitem__(self, key):
        return pickle.loads(self.db[key])
        
    def __iter__(self):
        for key in self.db.keys():
            yield key.decode()
            
    def __len__(self):
        return len(self.db)
    
ms = myopen('y.dat', 'c')
ms['ali'] = 123
val = ms['ali']
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
                                                18. Ders 04/05/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da GUI uygulamalarının yazımı üzerinde duracağız. Bunun için Qt (genellikle "kyut" biçiminde okunuyor) ortamının 
    Python'dan kullanılabilmesine olananak sağlayan PyQt kütüphanesini inceleyeceğiz. Ancak kütüphaneyi incelemeden önce GUI programlama 
    modeli için gerekli olabilecek bazı temel bilgileri de gözden geçireceğiz. Konu içerisinde "framework" sözcüğü için Türkçe daha 
    çok "ortam" sözcüğünü kullanacağız. Örneğin "Qt frameowrk" yerine "Qt ortamı" diyeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da pencereli GUI programlar yazabilmek için çeşitli seçenekler söz konusudur. Python'un standart kütüphanesinde "Tkinter" 
    ("ti key inter" ya da "tikintır" biçiminde okunuyor) isimli bir kütüphane bulunmaktadır. Bu kürüphane "Tk" ismi verilen GUI ortamının
    Python'dan kullanılmasını mümkün hale getirmektedir. Tk ortamı aslında "Tcl (tikıl diye okunuyor)" denilen bir script dili için 
    oluşturulmuştur. Ancak bu kütüphane Tcl dışında farklı programlama dillerinden kullanılabilmektedir. Python çeşitli gerekçelerle 
    (açık kaynak kodlu olması gibi) bu GUI ortamını kendi standart kütüphanesine dahil etmiştir. 

    Her ne kadar Tkinter Python'un standart bir öğesi olarak bulunuyorsa da aslında profesyonel uygulamalarda pek tercih edilmemektedir. 
    Python dünyasında en fazla tercih edilen GUI ortamı Qt (genellikle "kyut" diye okunmaktadır) ortamıdır. Qt aslında bir C++ GUI 
    ortamıdır. Cross platform olma özelliği nedeniyle son 20 senedir C++ dünyasında en çok tercih edilen GUI ortamı haline gelmiştir. 
    İşte Qt ortamı Python içerisinden de kullanılabilmektedir. Qt ortamının Python'dan kullanılabilen biçimine "PyQt" ya da "PySide" 
    denilmektedir.  

    Tkinter zaten Python'un standart kütüphanesinde bulunduğua göre onu install etmek için herhangi bir şey yapmaya gerek yoktur. 
    Ancak PyQt'nin bizim tarafımızdan kurulması gerekir. PyQt5 ya da PyQt6 aşağıdaki gibi kurulabilir:

    pip install pyqt5
    pip install pyqt6

    Bugün kullandığımız pencereli programların bir bölümü C++'ta Qt kullanılarak ya da Python'da PyQt kullanılarak geliştirilmiştir .
    Örneğin Spyder IDE'sinin kendisi de PyQt kullanılarak ile yazılmıştır. 

    PyQt "RiverBank Computing" tarafından açık kaynak kodlu biçimde geliştirilmiştir. PySide ise Qt'nin daha önceki sahibi olan 
    Nokia tarafından geliştirilmiştir. Sürdürümü Qt'nin yeni sahibi olan "The Qt Compnany" tarafından yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bilgisayar ekranları temel olarak iki modda çalışmaktadır:

    1) Text Mod
    2) Grafik Mod

    Eskiden text mod çalışma çok yaygındı. Çünkü grafik kartları henüz gelişkin değildi. Ancak son 20 senedir grafik mod çalışma 
    baskın hale gelmiştir. 

    Text modda ekrana basılabilecek en küçük birim bir karakterdir. Bu karakterler kalıp olarak ekrana basılmaktadır. Dolayısıyla 
    text modda çalışma çok hızlıdır. Ancak text modda resimler görüntülenemez, filmler izlenemez. 
    
    Grafik modda ekranda görüntülenebilen en küçük görsel öğeye "pixel" denilmektedir. Pixel bir noktadır. İşte grafik modda ekrandaki 
    tüm görsel öeğeler bu pixel'lerin bir araya getirilmesiyle oluşmaktadır. Her pixel'in rengi diğerlerinden bağımsız bir biçimde 
    ayarlanabilmektedir. Bugünkü grafik kartlarında ve monitörlerde her pixel "kırmızı (red)", "yeşil (green)" ve "mavinin (blue)"
    birer byte'lık tonal bileşimleriyle oluşturulmaktadır. Bir byte 8 bit olduğu için bir pixel 2^8 * 2^8 * 2^8 = 2^24 ≃ 16 milyon 
    renkten herhangi biriyle renklendirilebilmektedir. Aslında grafik modda tüm resimler ve yazılar bu pixel'lerin bir araya 
    getirilmesiyle oluşturulmaktadır. Ekranı bir pixel matrisi olarak düşünebilirsiniz. Örneğin 1920x1080 HD çözünürlükte matriste 
    1920 sütun 1080 tane de satır bulunmaktadır. Yani ekranda toplam 2 milyon civarı pixel bulunur. 

    Aynı monitörde çözünürlüğü yükseltirsek pixel'ler küçülür, resimler ve yazılar ekranda daha küçük görünür hale gelir, ancak 
    ekrana daha fazla içerik sığar. Eğer çözünürlük düşürülürse bu kez pixel'ler büyür, yazılar ve resimler büyük gözükür. Pekiyi 
    çözünürlük sabit bırakılıp ekran büyütülürse ne olur? Yine pixel'ler büyüyecektir. Bu durumda çözünürlük yükseltildikçe her şey 
    küçüleceği için monitörün büyütülmesi uygun olur. Monitör büyüklüğü ile pixel yoğunlu arasındaki ilişki "DPI (Dot Per Inch)" 
    bir terimle ifade edilmektedir. DPI bir inch'teki pixel saysıdır. Çözünürlük aynı kalıp monitör büyütülürse DPI düşer, çözünürlük 
    aynı kalıp monitör küçültülürse DPI yükselir. Benzer biçimde monitör aynı kalıp çözünürlüğü düşürürsek DPI düşecek, monitör 
    aynı kalıp çözünürlüğü yükseltirsek DPI artacaktır. Belli bir DPI değerinden sonra artık çözünürlüğü artırmanın da bir anlamı 
    kalmamaktadır. Çünkü insan gözündeki alglayıcı kısım olan retinanın da bir çözünürlüğü vardır. 

    Ekrandaki görüntü aslında grafik kartları (GPU) tarafından oluşturulmaktadır. Görüntüyü ekrankartları oluşturur, onu belli periyotta
    monitöre yollar, monitör de pixel'leri görüntüler. Yani monitör pasif bir aygıttır. Asıl işi yapan kısım grafik kartlarıdır. 

    Ekranın bir bölümü text modda bir bölümü grafik modda olmaz. Bugün GUI arayüzlü işletim sistemlerinde konsol pencerelerini açtığımızda
    o pencelere text modda çalışmamaktadır. Konsol pencereleri grafik modda text modu pixel'lerle simüle etmektedir. Text mod çalışma 
    çok yaygın ve pratik olduğu için bugün yine yoğun bir biçimde kullanılmaktadır. 

    Ekran koordinat sisteminde genellikle ekranın sol üst köşesi orijin noktasıdır. X ekseni sağa doğru, Y ekseni aşağıda doğru 
    ilerlemektedir. Ekran koordinat sisteminde her pixel'in bir koordinatı vardır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar "konsol tabanlı çalışma modelini" uyguladık. Bu modelde program kaynak kodun tepesinden başlamaktadır. Girdileri 
    almak için input fonksiyonu çıktıları yazdırmak için print fonksiyonu kullanılmaktadır. Konsol tabanlı çalışma modeli eski text 
    modlarda uygulanmaya başlanmış bir modeldir. Yukarıda da belirttiğimiz gibi bu mode grafik modda çalışan modern sistemlerde de 
    simüle edilerek uygulanmaktadır. Kondol mod çalışmada "kalemin ucu" görevinde bir "imleç (cursor)" vardır. print gibi ekrana yazma
    yapan fonksiyonlar bu imlecin bulunduğu yere yazarlar ve imleç otomatik olarak yazılan karakter sayısı kadar ilerletilir. Halbuki 
    GUI (Graphical User Interface) çalışma  modeli konsol çalışma modelinden olukça farklıdır. Burada önce GUI çalışma modelinden 
    bahsedeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    GUI çalışma modelinde ekranda bağımsız olarak kontrol edilebilen dikdörtgensel bölgelere "pencere (window)" denilmektedir. Bir GUI
    programın en az bir penceresi bulunur. Bu modelde kullanıcı bir programın penceresi ile ilgili bir işlem yaptığında işletim sistemi 
    ya da GUI alt sistem devreye girerek yapılan işlemi belirler. Bunu bir mesaj adı altında uygulamanın "mesaj kuyruğu (message queue)" 
    denilen kuyruğuna bırakır. Yani girdi olaylarını işletim sistemi ya da GUI alt sistem belirleyip uygulamaya bildirmektedir. Bir 
    mesaj "fare ilgili bir olay" olabildiği gibi "klavyeyle ilgili bir olay" ya da başka bir olay da olabilmektedir. Mesaj oluşmasına 
    yol açan yüzlerce farklı olay söz konusudur. Örneğin biz bir pencere üzerinde bir noktaya fare tıklayalım. İşletim sistemi ya da 
    GUI alt sistem bu olayı bir mesaj formatına dönüştürür ve uygulamanın mesaj kuyruğuna ekler. Bu mesaj içerisine "fare ile tıklandığı 
    bilgisi ve pencerenin neresine tıklandığı bilgisi" kodlanmaktadır. İşletim sistemleri ya da GUI alt sistemler mesaja ilişkin olaylara 
    birer numara vermektedir. Örneğin Windows sisteminde farenin sol tuşu ile pencereye tıklandığında WM_LBUTTONDOWN isimli bir mesaj 
    olulşturulmaktadır. Tabii aslında bu WM_LBUTTONDOWN mesajı belirten bir sayıdır. Ancak sayıları yerine programcılar bu sayılara 
    karşılık düşürülmüş isimlerle konuşmaktadır. Örneğin bir menüden bir eleman seçildiğinde WM_COMMAND isimli mesaj oluşturulur. Bir 
    uygulmanaın mesaj kuyruğunda yalnızca o uygulamayı ilgilendiren mesajlar bulunmaktadır. Yani işletim sistemi ya da GUI alt sistem 
    olay kimi ilgilendiriyorsa o olayı onun mesaj kuyruğuna yerleştirmektedir. Mesaj kuyruğunu aşağıdaki gibi temsil edebiliriz:

    Mesaj <-- Mesaj <-- Mesaj .... <--- Mesaj

    Mesaj kuyrukları aslında uygulamaya özgü değil thread'e özgü oluşturulmaktadır. Thread konusu ileride ele alınacaktır. 

    İşletim sistemi ya da GUI alt sistem kullanıcı tarafından yapılan işlemleri mesaj adı altında uygulmanın mesaj kuyruğuna eklemektedir. 
    Bu mesajların kuyruktan alınarak işlenmesi uygulamanın yani programcının sorumluluğundadır. Programcının mesaj kuyruğundan sıradaki 
    mesajı alıp, o mesajın neden gönderildiğini anlaması ve gerekli işlemleri yapması gerekir. Yani programcının tipik olarak aşağıdaki 
    gibi bir dönü oluşturması gerekmektedir:

    while True:
        <kuyruktan mesajı al>
        <mesajın ne mesajı olduğunu anla>
        <gereğini yap>

    Bir GUI program yaşamını böyle bir dögüde geçirmektedir. Bu döngüye GUI terminolojisinde "mesaj döngüsü (message loop)" denilmektedir. 
    Ancak programın mesaj döngüsünü oluşturup mesajları kuyruktan alıp işleyen bir programı oluşturmak çok zahmetlidir. 
    
    GUI sistemlerinin ilk zamanlarında programcılar mesaj döngüsünü oluşturup mesajı işleyen tüm kodları kendileri yazıyordu. Ancak daha 
    sonra bu arka plandaki karmaşık işlemleri programcının üzerinden alıp modeli çok daha basit bir biçimde programcıya gösteren GUI 
    ortamları (GUI frameworks) oluşturuldu. GUI ortamları mesaj döngülerini kendisi oluşturmakta, mesaj kuruğundan mesajları kendisi 
    almakta ve mesaja göre programcının belirlediği fonksiyonları çağırmaktadır. Bazı GUI ortamları prosedürel programalama tekniği ile 
    oluşturulmuştur. Bazıları ise nesne yönelimli teknikle oluşturulmuştur. GUI programlama modeli nesne yönelimli tekniğe çok uygun 
    düşmektedir. Dolayısıyla bu alandaki güçlü GUI ortamları sınıflar kullanılarak nesne yönelimli programlama tekniği ile oluşturulmuş 
    durumdadır. Tkinter ve PyQt nesne yönelimli bir GUI ortamıdır. Yani bu ortamlarda biz sınıflar kullanarak işlemlerimizi yaparız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    GUI dünyasında ekranda bağımsız olarak kontrol edilebilen dikdörtgensel bölgelere "pencere (window)" denilmektedir. Tipi bir 
    pencerenin bir başlık kısmı (caption) olur, sınır çizgileri (borders) olur. Başlık kısmının altındaki sınır çizgilerinin içindeki 
    alana "çalışma alanı (client area)" denilmektedir. Programcı görsel öğeleri bu alana yerleştirir. Ancak pencerelerin başlık kısmı 
    olmak zorunda dğeildir. Sınır çizgileri de olmak zorunda değildir. 

    Masaüstüne açılan pencerelere "ana pencereler (top level windows)" denilmektedir. Her GUI uygulamasının genel olarak bir ana penceresi 
    vardır. Bir ana pencerenin çalışma alanının içerisinde bulunan ve onun dışına çıkamayan pencerelere "alt pencereler (child windows)" 
    denilmektedir. Alt pencerelerin alt pencereleri de olabilir. Her pencerenin bir "üst penceresi (parent window)" vardır. Aynı üst 
    pencereye sahip olan pencerelere de "kardeş pencereler (sibling windows)" denilmektedir. Üst penceresinin her zaman yukarısında 
    görüntülenen, ancak üst penceresinin sınırları dışına çıkabilen pencerelere "sahiplenilmiş pencereler (owned window)" ya da
    programcılar arasında "diyalog pencereleri (dialog boxes)" denilmektedir. Sahiplenilmiş pencereler aslında hem bir ana pencere 
    gibi hem de bir alt pencere gibi düşünülebilir. 

    Bir pencere yaratılmış ancak o anda ekranda "görünmüyor (invisible)" durumda olabilir. Programcı pencereleri istediği zaman 
    "görünür (visible)" yapıp istediği zaman "görünmez (invisible)" yapabilmektedir. 

    Bazı işletim sistemlerinde ve ortamlarda (frameworks) "pencere (windows)" terimi yerine "widget" terimi de kullanılmaktadır. 
    Widget sözcüğü "window gadget" sözcüklerinden uydurulmuştur. Örneğin PyQt ve Tkinter ortamlarında pencere yerine "widget" sözcüğü
    kullanılmaktadır. Ancak Microsoft "pencere (windows)" terimini kullanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI programda programcı tipik olarak çalışma alanının içerisine çeşitli GUI elemanlar yerleştirir. Bu GUI elemanlar aslında 
    birer alt penceredir. Framework'ler yaygın kullanılan pek çok hazır GUI elemanlara sahiptir. Aslında programcılar da içi boş bir 
    pencereden hareketler çizim işlemleriyle düğmeler, edit alanları, listeleme kutuları gibi GUI elemanlarını kendileri oluşturabilmektedir. 
    Ancak bir GUI elemanı tasarlayıp oluşturmak uzmanlık isteyen bir iştir. Microsoft hazır olarak bulundurulan bu GUI elemanlara 
    ilişkin alt pencerelere "control" demektedir. Pek çok frameowrk ise bunları yine "widget" biçiminde isimlendirmektedir. Programcı 
    bu hazır alt pencereleri ana pencerenin içerisine yerleştirerek görsel arayüzü oluşturmaktadır. İşte GUI programcısı tipik olarak 
    önce bu alt pencereleri ana pencerenin içerisine yerleştirir. Sonra da bunlarda olan olayları ele alıp uygun işlemleri yapar.

    Ana pencerenin içerisinde GUI elemanlarını (yani alt pencereleri) yerleştirme işlemi temel olarak programlama yoluyla yapılmaktadır. 
    Ancak pek çok GUI ortamı kullanıcı arayüzünün daha kolay satarlanması için "form editor" ya da "designer" denilen özel programlar
    da bulundurmaktadır. Örneğin Qt dünyasında bu işi yapan araca "Qt Designer" denilmektedir. 

    Son 15 yıldır GUI ortamları GUI arayüzü ile program kodlarını birbirinden ayıran mekanizmlar geliştirmiştir. Bu yeni teknolojide 
    GUI arayüzü özel bir dille editörde yazılır. Sonra bu kod bir fonksiyona verilir. Fonksiyon da tüm alt pencereleri kodda belirtildiği
    gibi yaratır. Örneğin .NET ortamında bu biçimde çalışan GUI ortamına "WPF (Windows Presentation Foundation)" denilmektedir. WPF'te 
    GUI oluşturmak için XAML denilen dekleratif bir dil kullanılmaktadır. Qt'de de Qt5 ile birlikte ismine "QML (Qt Modeling Language)"
    bir dil eşliğinde GUI arayüzü oluşturulabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt ortamında tüm sınıf isimleri Q harfliyle başlatılmaktadır. Bu Q harfi Qt'den gelmektedir. Ancak Qt'teki Q'nun nereden geldiği 
    belli değildir. Öylesine uydurulmuş bir harftir. Ancak Qt İngilizce "cute" biçiminde güzel bir fonetik oluşturmaktadır. Kütüphanede 
    genel olarak sınıfların metotları ve yerel değişkenler "deve notasyonu (camel casting)" ile harflendirilmiştir. Sınıf isimlerine 
    ise Pascal tarzı harflendirme (Pascal casting) uygulanmıştır. Biz şimdiye kadar Python'da hep klasik alt tireli (yılan notasyonu) 
    harflendirme kullandık. Ancak PyQt söz konusu olduğunda kendimizi Qt ortamının harflendirme stiline uydurabilmek için biz de sınıf 
    isimleri için Pascal notasyonunu, diğer isimler için deve notasyonunu tercih edeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    PyQt dokümantasyonu için aslında çok iyi bir site yoktur. Python programcı orijinal C++ dokğmantasyonundan faydalanabilir. Ancak 
    bu dokümantasyonda C++ sentaksı kullanılmıştır. Famework'ün orijinal C++ dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://doc.qt.io/

    Doğrudan Qt sınıfları hakkında bilgi almak için aşağıdaki bağlantıyı da kullanabilirsiniz:

    https://doc.qt.io/qt-6/reference-overview.html

    Qt'nin PyQt dışında Python için diğer bir gerçekleştirimi de PySide denilen gerçekleştirimidir. Qt'nin sahibi olan firma (Qt Company) 
    bu PySide gerçekleştirimini dokümantasyon olarak desteklemektedir. Dolayısıyla aşağıdaki bağlantı Qt'nin Python dokümantasyonu olarak 
    da kullanılabilir:

    https://doc.qt.io/qtforpython/

    Bunların dışında aşağıdaki bağlantı da Python için dokümantasyon sağlamaktadır:

    https://www.riverbankcomputing.com/static/Docs/PyQt5/
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da PyQt ile uygulama geliştirirken eğer PyQt5 kullanılıyorsa PyQt5 paketindeki eğer PyQt6 kullanılıyorsa PyQt6 paketindeki
    öğeleri import ya da from import deyimleriyle erişilebilirlik sağlanmalıdır. Bir Qt programındaki sınıfların önemli bir bölümü
    PyQt5.QtWidgets ya da PyQt6.QtWidgets modülü içerisindedir. PyQt programcıları genellikle buradaki sınıfları tek tek from import 
    yapmak yerine tüm isimleri form import yapmaktadır. Örneğin:

    from PyQt6.QtWidgets import *

    Artık programcı doğrudan hiç niteliklendirme yapmadan önemli Qt sınıflarını kullanabilecektir. 

    PyQt5 ile PyQt6 arasında kursumuzu ilgilendiren önemli bir farklılık bulunmamaktadır. Eskiden PyQt6 kararlı bir durumda değildi. 
    Biz de bu kursta PyQt5 kullanıyorduk. Ancak zamanla PyQt6 kararlı bir duruma geldi. Bu nedenle artık PyQt6 da kullanabiliriz. 
    Siz bu kurs için PyQt5 ya da PyQt6 kullanabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    GUI uygulamalarını öğrenebilmek için başlangıç noktası ekranda içi boş bir ana pencerenin çıkartılmasıdır. Bu işlem adeta GUI 
    uygulamalarının "Merhaba Dünya" programı gibidir.    
    
    Qt'de uygulamanın kendisi QApplication isimli bir sınıfla temsil edilmiştir. Bu sınıfın __init__ metodu programın komutu satırı 
    argümanlarını almaktadır. Programcının öncelikle QApplication türünden bir nesne oluşturması gerekir. Bu işlem şöyle yapılmaktadır:

    import sys
    from PyQt6.QtWidgets import *

    app = QApplication(sys.argv)

    QApplication nesnesi yaratıldıktan sonra programın ana penceresinin yaratılması gerekir. Qt'de pencere kavramı QWidget sınıfıyla 
    temsil edilmiştir. Tüm GUI elemanlar QWidget sınıfından türetilmiş sınıflarla temsil edilmektedir. Programın ana penceresi QWidget 
    sınıfı kullanılarak yaratılabilir. Ana pencere yaratıldığında henüz görünür değildir. Pencereyi görünür yapmak için QWidget show
    metodu kullanılmaktadır. Örneğin:

    import sys
    from PyQt6.QtWidgets import *

    app = QApplication(sys.argv)

    mainWindow = QWidget()
    mainWindow.show()
    
    Mesaj döngüsü QApplication sınıfının exec metoduyla oluşturulmaktadır. Mesaj döngüsüne girmeden önce programcının uygulamanın ana 
    penceresini de yaratmış olması gerekir. Dolayısıyla ekrana boş pencere çıkartan iskelet GUI programı en basi bir biçimde şöyle
    oluşturulabilir:

    import sys
    from PyQt6.QtWidgets import *

    app = QApplication(sys.argv)
    mainWindow = QWidget()
    mainWindow.show()   
    app.exec()

    Aşağıda ekrana boş bir pencere çıkartan minimal PyQt programı verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

app = QApplication(sys.argv)
mainWindow = QWidget()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                            19. Ders 10/05/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir Qt GUI programı nasıl sonlanmaktadır? En tipik sonlanma şöyle olur: Kullanıcı ana pencerenin kapatma simgesine tıklar 
    (ya da bunun için kalvyeden kısa yol tuşlarını kullanır). Bu durumda işletim sistemi mesaj kuyruğuna özel bir mesaj bırakır (örneğin 
    Windows sistemlerinde bu mesaja WM_CLOSE mesajı denilmektedir). QApplication sınıfının exec metodu da bu mesajı aldığında mesaj 
    döngüsünden çıkar ve sonlanır. Yani ana pencere kapatılınca akış exec metodunun aşağısından devam edecektir. Genellikle programcılar 
    ana pencere kapatıldıktan sonra özel bir şey yapmazlar. Dolayısıyla ana pencerenin kapatılmasıyla GUI programları genellikle 
    sonlanmaktadır. Örneğin:

    import sys
    from PyQt6.QtWidgets import *

    app = QApplication(sys.argv)
    mainWindow = QWidget()
    mainWindow.show()
    app.exec()

    print('continues...')

    Burada ana pencere kapatıldığında exec metodundan çıkılacak ve konsole ekranına "continues..." yazısı basılacaktır.
    Aşağıda ana pencere kapatıldıktan sonra exec metodununun sonlandığını gösteren bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

app = QApplication(sys.argv)
mainWindow = QWidget()
mainWindow.show()
app.exec()

print('continues...')

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de her GUI eleman QWidget sınıfından türetilmiş olan bir sınıfla temsil edilmiştir. QWidget tüm pencerelerin ortak özelliklerini 
    barındıran türetme şemasının en yukarısında bulunan sınıftır. Bir GUI elemana ilişkin sınıf başka sınıflardan türetildiği için o 
    GUI eleman sınıfında taban QWidget sınıfının elemanları da kullanılabilmektedir. Yukarıda da belirttiğimiz gibi türetme şemasının 
    en tepesinde QWidget sınıfı bulunur. QWidget sınıfı ana pencere oluşturulurken de alt pencere oluşturulurken de kullanılabilmektedir. 
    Örneğin düğme (pushbutton) GUI elemanı QPushButton isimli sınıfla temsil edilmiştir. Bu sınıf QAbstractButton sınıfından, QAbstractButton 
    sınıfı da QWidget sınıfınından türetilmiş durumdadır:

    QWidget 
    QAbstractButton
    QPushButton

    Bu durumda elimizde bir QPushButton nesnesi varsa biz o nesne ile hem QPushButton sınıfının hem QAbstractButton sınıfının hem de 
    QWidget sınıfının elemanlarını kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI program oluşturabilmek için programcı önce uygulaması için bir ana pencere yaratır. Sonra bu ana pencerenin içerisine GUI 
    elemanlarını yerleştirir. Sonra da kullanıcı o GUI elemanları üzerinde işlem yaptıkça programcı yapılan işlemlere göre çeşitli kodların
    çalıştırılmasını sağlar. 
    
    Bir GUI uygulamasında pek çok GUI eleman vardır. Bu GUI elemanların bazıları çok yaygın kullanılmaktadır. Bazıları ise seyrek kullanılmaktadır. 
    Qt dünyasında GUI elemnlara "widget (window gadget sözcüklerinden uydurulmuştur)" da denilmektedir. Ancak genel olarak aşağı seviyeli 
    terminolojide GUI eleman yerine "alt pencere (child window)" ya da "kontrol (control)" terimleri tercih edilmektedir. Örneğin Microsoft 
    GUI elemanlar için "control" terimini kullanmaktadır. 

    Yukarıda da belirttiğimiz gibi Qt'de her GUI eleman bir sınıfla temsil edilmiş durumdadır. Bir GUI eleman yaratmak için tek yapılacak 
    şey o GUI eleman sınıfı  türünden bir nesne yaratmaktır. Biz bu GUI eleman sınıfları türünden nesneler yarattığımız zaman bu GUI 
    elemanlarını da yaratmış oluruz. Pek çok GUI eleman sınıfının __init__ metodunun ilk parametresi bir yazı almaktadır. Çünkü pek 
    çok GUI elemanın "bir yazısı" vardır. __init__ metotlarının ikinci parametreleri de genellikle bu GUI elemanın yerleştirileceği 
    üst pencere nesnesini belirtir. Ana pencerenin içerisine GUI eleman yerleştirilecekse ana pencere yaratıldıktan hemen sonra bunun 
    yapılması uygun olur. Örneğin:

    app = QApplication(sys.argv)
    mainWindow = QWidget()
    pushButtonOk = QPushButton('Ok', mainWindow)
    mainWindow.show()
    app.exec()

    Burada QPushButton nesnesinin nasıl yaratıldığına dikkat ediniz:

    pushButtonOk = QPushButton('Ok', mainWindow)

    Burada ilk argüman düğümenin üzerinde çıkacak yazıyı, ikinci argüman ise düğmenin hangi pencerenin içinde gözükeceğini belirtmektedir 
    Ana pencere show yapılırken alt pencereler de otomatik show yapılmaktadır. Ancak alt pencereler ana pencere show yapıldıktan sonra 
    yaratılıyorsa programcı alt pencereleri de açıkça show metodu ile görünür hale getirmelidir. Örneğin:

    app = QApplication(sys.argv)
    mainWindow = QWidget()
    mainWindow.show()
    pushButtonOk = QPushButton('Ok', mainWindow)
    pushButtonOk.show()

    Aşağıdaki örnekte bir ana pencerenin içerisaine bir düğme GUI elemanı eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

app = QApplication(sys.argv)
mainWindow = QWidget()
pushButtonOk = QPushButton('Ok', mainWindow)
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencere ile onun içerisine yerleştirilmi GUI elemanlar arasında NYPT bakımından "içerme ilişkisi (composition)" vardır. Bu 
    nedenle programcılar ana pencere içerisindeki GUI elemanları ana pencere nesnesinin içerisinde tutarlar. Tabii bunu yapabilmek için 
    QWidget sınıfından bir sınıf türetip ana pencereyi buı türemiş sınıf kullanarak yaratmak gerekir. Örneğin:

    class MainWindow(QWidget):
        pass

    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow .show()

    İşte ana pencerenin içerisindeki GUI elemanlar ana pencere için oluşturulmuş sınıfın __init__ metodunda yaratlıp ana pencere nesnesinin
    içerisinde saklanabilirler. Örneğin:
    
    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()
            self.pushButtonOk = QPushButton('Ok', self)
            
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()

    Burada mainWindow nesnes, yaratıldığında aynı zamanda QPushButton nesnesi de yaratılmış olacaktır ve bu nesne ana pencere nesnesinin 
    içerisinde saklanmaktadır. Örneğimizde MainWindow sınıfının __init__ metodunda super çağrısıyla QWidet sınıfının __init__ metodunun
    çağrıldığına dikkat ediniz.

    Aşağıdaki örnekte QWidget sınıfından MainWindow isimli bir sınıf türetilmiş programın ana penceresi bu sınıf yoluyla oluşturulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.pushButtonOk = QPushButton('Ok', self)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt her ne kadar bir GUI framework'ü ise de genel amaçlı pek çok sınıfa da sahiptir. Bu genel amaçlı sınıfların bazıları GUI 
    işlemlerinde yardımcı sınıflar olarak kullanılmaktadır. Biz de burada kısaca GUI işlemlerinde kullanılan bazı yardımcı sınıfları 
    tanıtacağız. Örneğin QPoint sınıfı ekrandaki bir pixel'in yerini temsil etmektedir. QSize sınıfı genişlik-yükseklik kavramlarını 
    temsil etmektedir. QRect sınıfı ise dikdörtgensel bir bölgeyi temsil etmektedir. Qt'deki yardımcı sınıfların sınıfların çoğu 
    PyQt6.QtCore alt paketinde bulunmaktadır. Dolayısıyla bu sınıfları kullanabilmek için aşağıdaki import işlemini yapabiliriz:

    from PyQt6.QtCore import *
#------------------------------------------------------------------------------------------------------------------------------------
       
#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi Qt aslında bir C++ framework'üdür. PyQt bu C++ framework'ünün Python'dan kullanımını sağlayan bir "sarma (wrapper)" 
    gibidir.  C++'ta sınıfın veri elemanlarının private bölümde dışarıdan gizlenmesi onlara public üye fonksiyonlarla erişilmesi yani 
    "veri elemanlarının gizlenmesi (data hiding)" özelliği yoğun kullanılmaktadır. Bu nedenle PyQt'te de (orijinali öyle olduğu için)
    örneğin bir nesnenin x veri elemanına getter/setter metotlarıyla erişilir. Genel olarak x bir nesnenin bir özelliği ise bu x 
    değerini elde etmek için x() isimli metot, bu özelliği set etmek için setX isimli metot kullanılmaktadır. Burada getter metodunun 
    başında "get" olmadığına ancak setter metodunun başında "set" olduğuna dikkat ediniz. Qt'nin orijinal dokümanlarında "get" ve "set" 
    edilebilen sınıf özelliklerine "property" denilmektedir.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QPoint bir pixel'in koordinatlarını temsil etmek için kullanılmaktadır. QPoint nesnesi x ve y değerleri verilerek yaratılır. 
    Örneğin:

    pt = QPoint(10, 20)

    Bu x ve y değerleri x ve y metotlarıyla alınıp setX ve setY metotlarıyla set edilebilir. Örneğin:

    print(pt.x(), pt.y())       # 10 20

    pt.setX(100)
    pt.setY(200)

    print(pt.x(), pt.y())       # 100 200

    İki QPoint nesnesi toplanabilir, çıkartılabilir. 

    pt1 = QPoint(10, 20)
    pt2 = QPoint(5, 8)

    result = pt1 - pt2
    print(result.x(), result.y())
#------------------------------------------------------------------------------------------------------------------------------------

from PyQt6.QtCore import *

pt1 = QPoint(10, 20)
pt2 = QPoint(5, 8)

result = pt1 - pt2
print(result.x(), result.y())

#------------------------------------------------------------------------------------------------------------------------------------
    QSize sınıfı bir pencerenin genişlik-yüksek bilgisini tutmak için düşünülmüştür. Nesne yaratılırken bu bilgi verilir. Sonra istenirse 
    width ve height metotlarıyla bu bilgiler nesnenin içerisinden alınabilir. Örneğin:

    sz = QSize(10, 20)

    print(sz.width(), sz.height())      # 10 20

    width ve height özellikleri setWidth ve setHeight metotlarıyla değiştirilebilmektedir. Örneğin:

    sz.setWidth(50)
    sz.setHeight(60)
    
    Yine iki QSize nesnesi toplanıp çıkartılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

from PyQt6.QtCore import *

sz = QSize(10, 20)
print(sz.width(), sz.height())

sz.setWidth(50)
sz.setHeight(60)
print(sz.width(), sz.height())

#------------------------------------------------------------------------------------------------------------------------------------
    QRect sınıfı bir dikdörtgenin koordinatlarını tutmak ve onun üzerinde bazı işlemleri yapabilmek için düşünülmüştür. QRect nesnesi 
    sol-üst köşe koordinatları ve genişlik-yükseklik değerleriyle yaratılabilir. Örneğin:

    rect = QRect(10, 10, 100, 100)

    Buradaki dikdörtgenin sol üst köşe koordinatı 10, 10, genişliği ve yüksekliği 100, 100 biçimindedir. Bir QRect nesnesi QPoint ve 
    QSize ikilisiyle de yaratılabilmektedir. Örneğin:

    pt = QPoint(10, 10)
    size = QSize(100, 100)

    rect = QRect(pt, size)

    QRect nesnesinin temsil ettiği dikdörtgene ilişkin çeşitli bilgiler QRect sınıfının çeşitli metotlarıyla elde edilmektedir. Bu metotların 
    listesi şöyledir:

    - x metodu dikdörtgenin sol üst köşesinin x değerini verir.
    - y metodu dikdörtgenin sol üst köşesinin y değerini verir.
    - right metodu dikdörtgenin sağ tarafının x değerinin 1 eksiğini verir. 
    - bottom metodu dikdörtgenin alt tarafının y değerinin 1 eksiğini verir. 
    - width metodu dikdörtgenin genişliğini verir.
    - height metodu dikdörtgenin yüksekliğini verir.
    - topleft dikdörtgenin sol üst köşesini, topright sağ üset köşesini, bottomleft sol alt köşesini ve bottom right ise sağ alt
    köşesini QPoint olarak vermektedir.
    - center metodu dikdörtgenin orta noktasını vermektedir. 

    Örneğin:

    rect = QRect(10, 11, 12, 13)

    print(rect.x(), rect.y())                   # 10 11
    print(rect.width(), rect.height())          # 12 13
    print(rect.left(), rect.right())            # 10 21
    print(rect.top(), rect.bottom())            # 11 23

    Bu koordinatlar QPoint ve QSize olarak da elde edilebilmektedir:

    rect = QRect(10, 11, 12, 13)

    print(rect.topLeft())           # PyQt6.QtCore.QPoint(10, 11)   
    print(rect.bottomRight())       # PyQt6.QtCore.QPoint(21, 23) 
    print(rect.size())              # PyQt6.QtCore.QSize(12, 13)

    QRect sınıfının contains isimli metodu bir noktanın dikdörtgenin içinde olup olmadığı bilgisini vermektedir. İlgili nokta 
    contains metoduna iki ayrı argüman olarak geçilebilir ya da tek bir QPoint nesnesi olarak da geçilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencerenin başlık kısmındaki yazı QWidget sınıfının setWindowTitle metoduyla set edilebilir, windowTitle metoduyla da get 
    edilebilir. Biz QWidget sınıfından MainWindow sınıfını türettiğimize göre __init__ içerisinde self aslında MainWindow türündendir. 
    türemiş sınıf taban sınıfın elemanlarını kullanabildiğine göre ana pencerenin başlık yazısı MainWindow sınıfının __init__ metodunda 
    self ile set edilebilir. Örnein:

    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()
            self.setWindowTitle('Generic GUI')

    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.setWindowTitle('Generic GUI')
    mainWindow.show()
    app.exec()

#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.setWindowTitle('Generic GUI')
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencereler için konumlandırma orijini masaüstünün sol-üst köşesidir. Ancak alt pencereler için konumlandırma orijini o alt 
    pencerenin üst penceresinin çalışma alanının (client area) sol üst köşesidir. 
    
    Pencereleri konumlandırmak için QWidget sınıfının move isimli metodu kullanılmaktadır. move metodu x ve y değerlerini alır. Yukarıda 
    da belirtildiği gibi bu x ve y değerlerinin orijin noktası ana pencereler için masaütünün sol-üst köşesi, alt pencereler için 
    onların üst pencerelerinin çalışma alanının sol üst köşesidir. move metodu pencereyi sol üst köşesi belirtilen pixel koordinatlarında 
    olacak biçimde konumlandırmaktadır. move metodu x ve y değerlerini ik ayrı parametreyle de alabilmekte, bir tane QPoint nesnesiyle de 
    alabilmektedir. 

    Aşağıdaki örnekte hem ana pencere hem de push button alt penceresi move metodu ile konumlandırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.move(100, 100)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()

mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------ 
    Aşağıdaki örnekte iki tane push button GUI elemanı yaratılmış, bunlar yan yana konumlandırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(10, 10)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.move(100, 10)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Pencerelerin boyutlarını değiştirmek için QWidget sınıfındaki resize metodu kullanılmaktadır. resize metodu genişlik-yükseklik 
    değerlerini bizden ister. Eğer alt pencereler resize edilmezse Qt onları default olarak belli bir genişlik ve yükseklik ile yaratmaktadır. 
    Örneğin bir QPushButton nesnesi default durumda içerisindeki yazıyı kapsayacak genişlikte yaratılır. resize metodu çalışma alanının 
    genişlik ve yüksekliğini belirtilen değerlere getirmektedir. Yani ana pencereler için bu genişlik ve yüksekliğe pencere başlığı 
    ve sınır çizgileri dahil değildir. 

    Burada bir noktayı yeniden vurgulamak istiyoruz. resize metodu "çalışma alanının (client area)" genişlik ve yüksekliğini ayarlamaktadır. 
    Örneğin bir ana pencereye resize metodunu w ve h dğerleriyle uygularsak tüm pencerenin genişliği ve yükseliği w ve h değerlerinde 
    olmaz. Çalışma alanının genişlik ve yüksekliği w ve h değerlerinde olur. Yani buna pencere başlığı ve sınır çizgileri dahil değildir. 
    Genellikle alt pencereler sınıf çizgilerine ve başlık kısımlarına sahip olmazlar. Böylece genellikle zaten alt pencerelerin çalışma 
    alanıyla onların bütünü aynı olur. Ancak istenirse (seyrek de olsa) alt pencereler de sınır çizgilerine ve başlık kısımlarına sahip 
    olabilmektedir.  
    
    Aşağıdaki örnekte hem ana pencere hem de push button GUI elemanları resize metoduyla istenilen bir büyüklüğe getirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.resize(620, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(10, 10)
        self.pushButtonOk.resize(100, 100)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.move(120, 10)
        self.pushButtonCancel.resize(100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Penecereleri konumlandırmak ve boyutlarını ayarlamak için yalnızca move ve resize metotları yoktur. QWidget sınıfının birbirleriyle 
    ilişkili pek çok metodu vardır. Bu metotlar Qt'yi öğrenen kişilerde biraz kafa karıştırıcı olabilmektedir. Aşağıdaki bağlantıdaki 
    şekli kafa karışıklığınızı gidermekte kullanabilirsiniz:

    https://doc.qt.io/qt-6/application-windows.html#window-geometry

    x ve y metotları pencerenin bütününe ilişkin sol üst köşe koordinatlarının x ve y değerlerini vermektedir. (Burada bütününe ilişkin 
    demekle ana pencerelerde başlık kısmı ve sınır çizgilerinin dahil olduğunu belirtmiş oluyoruz.) Bu iki metot bize bu bilgileri int 
    türden vermektedir. x ve y değerlerini QPoint olarak tek hamlede pos metoduyla da elde edebiliriz. Tabii bu metotlarla elde edilen 
    değerlerin orijin noktası ana pencereler için masaüstünün sol-üst köşesi, alt pencereler için onların üst pencerelerinin sol-üst 
    köşesidir. 

    Pencereyi konumlandırmak için kullanılan QWidget sınıfının move metodu konumlandırmayı her zaman pencerenin bütününün sol-üst köşesi 
    için yapmaktadır. 

    QWidget sınıfının geometry isimli metodu bize pencerenin çalışma alanının dikdörtgensel bölgesini QRect nesnesi olarak vermektedir. 
    Tabii buradaki orijin ana pencereler için masaüstünün sol-üst köşesi, alt pencereler için onların üst pencerelerinin sol-üst köşesidir. 
    Bu metodunun setGeometry isminde set eden bir biçimi de vardır. Tabii setGeometry de çalışma alanının dikdörtgenini set etmektedir. 
    Eğer pencere başlığı ve sınır çizgileri dahil olmak üzere tüm pencerenin dikdörtgeni alınmak isteniyorsa frameGeometry metodu kullanılır. 
    Bunu set eden setFrameGeometry metodu yoktur. 

    Pencerenin çalışma alanının genişliği width metodu ile, yükseliği ise height metodu ile alınmaktadır. setWidth ve setHeight biçiminde 
    metotlar yoktur. size metodu yine çalışma alaının genişlik ve yüksekliğini bize QSize nesnesi olarak verir. frameSize isimli metot pencerenin 
    bütünün genişliğini ve yüksekliğini QSize nesnesi olarak vermektedir. Pencerenin bütünün boyutunu ayarlayabilmek için bir metot yoktur. 
    Bu işlem dolaylı bir biçimde yapılabilmektedir. 

    QWidget sınıfının rect isimli metodu çalışma alanının dikdörtgenini çalışma alanı orijinli biçimde vermektedir. Dolayısıyla rect metodu 
    ile alınan dikdörtgensel bölgenin sol üst köşesi her zaman (0, 0) olmaktadır. rect ile geometry metotları birbirine benzer olmakla birlikte 
    geometry çalışma alanının dikdörtgenini üst pencere ya da masaüstü orijinli verirken rect yine çalışma alanı orijinli vermektedir. rect 
    ile elde edilen dikdörtgenin sol üst köşesinin her zaman (0, 0) olması kişilere anlamsız gelebilmektedir. Ancak bazı konularda bu metot 
    faydalı bir biçimde kullanılmaktadır. 

    Konumlandırmaya ilişkin QWidget sınıfının metotlarını özet olarak aşağıda yeniden veriyoruz:

    x                   sol üst köşe x değerini verir
    y                   sol üst köşe y değerini verir
    pos                 sol üst köşe x ve y değeri QPoint olarak verir
    move                sol üst köşeyi kaydırır
    size                çalışma alanının genişlik ve yüksekliğini QSize olarak verir
    resize              çalışma alanının genişlik ve yüksekliğini ayarlar
    width               çalışma alanın genişiliğini verir
    height              çalışma alanın yüksekliğini verir
    geometry            çalışma alanınının dikdörtgenini QRect olarak verir
    frameGeometry       penceenin tamamanının dikdörtgeninini QRect olarak verir
    frameSize           pencerenin tğm genişliğini ve yüksekliğini QSize olarak verir
    rect                pencerinin açlışma alanının dikdörtgeninin çalışma alanı orijini ile verir
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QWidget sınıfının setGeometry özellikle metodu move ve resize yapmadan tek hamlede pencereyi konumlandırmak için kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir pencerenin çalışma alanına ilişkin en büyük genişlik ve yüksekliğini ayarlamak için QWidget sınıfının setMaximumWidth, setMaximumHeight 
    ve setMaximumSize metotları kullanılmaktadır. Böylece kullanıcı pencereyi burada belirtilen değerlerden daha fazla büyütemeyecektir. 
    Bu değerleri almak için ise maximumWidth, maximumHeight ve maximumSize metotları bulundurulmuştur. Pencerenin çalışma alanının 
    küçültülebilecek en küçük boyutu da benzer setMinimumWidth, SetMinimumHeight ve setMinimumSize metotlarıyla belirlenip ayarlanabilmektedir.  
    En küçük boyutu elde etmek için de minimumWidth, minimumHeight ve minimumSize metotları bulunmaktadır. Tabii bu metotlar özellikle 
    ana pencereler için anlamlı olmaktadır. 

    Aşağıdaki örnekte ana pencerenin çalışma alanının maksimum genişlik ve yüsekliği 800x600 minimum genişlik ve yüksekliği 300x200
    olarak ayarlanmıştır. Programı çalıştırıp fare ile pencereyi büyütüp küçültmeyi deneyiniz. Burada belirtilen değerlerden daha fazla 
    ve daha az büyütüp küçültemediğinizi gözlemleyiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        self.setMinimumSize(300, 200)
        self.setMaximumSize(800, 600)

        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir ana pencereyi programalama yoluyla maximize, minimize, restore ve full secreen haline getirebilmek için QWidget sınıfının 
    sırasıyla showMaximum, showMinimum, showNormal ve showFullScreen metotları bulundurulmuştur. Pencerenin o anda minimum durumda olup 
    olmadığı QWidget sınıfının isMinimized metodu ile, maksimum durumda olup olmadığı isMaximized metodu ile ve full screen durumunda 
    olup olmadığı da isFullScreen metodu ile elde edilebilmektedir. Bu metotlar bize bool türden değer vermektedir. 

    Aşağıdaki örnekte ana pencere show yerine showFullScreen ile görüntülenmiştir. Dolayısıyla an pencere full screen görüntülenecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.showFullScreen()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                20. Ders 11/05/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt dünyasında bir GUI elemanda oluşan olaya "sinyal (signal)" bu olay sonucunda çağrılacak fonksiyona ya da metoda da "slot (slot)" 
    denilmektedir. Bir olay gerçekleştiğinde bir fonksiyonun (ya da metodun) çağrılmasını sağlamak için Qt terminolojisinde"sinyale 
    slotun bağlanması" gerekir. GUI eleman sınıflarının hangi sinyallerinin ve slotlarının olduğu dokümanlarda belirtilmiştir. Tabii 
    custom sinyaller de oluşturulabilmektedir. Tipik olarak bir sinyale bir slot bağlanmaktadır. Ancak sinyale sinyal de bağlanabilmektedir. 
    Bir A sinyaline bir B sinyali bağlanırsa A olayı olduğunda sanki B olayı olmuş gibi bir etki yaratılmaktadır. Bir sinyale birden 
    fazla slot ve sinyal de bağlanabilir. Bu durumda olay gerçekleştiğinde bu bağlanmış olan sinyal ve slotların hepsi sırasıyla devreye 
    girer. 

    Qt programcısının hangi GUI elemanı için hangi sinyallerin bulunduğunu biliyor olması gerekir. Bu bilgi dokümantasyonlardan elde 
    edilebilir. 

    PyQt'de bir sinyale bir slot bağlamanın genel biçimi şöyledir:

    widget.signal_name.connect(handler)

    Burada signal_name sinyalin ismidir. connect metodu bağlantıyı yapan metottur. handler ise çağrılacak fonksiyon ya da metodu belirtmektedir. 
    Tabii burada çağrılacak fonksiyon ya da metodun parametrik yapısı herhangi bir biçimde olamaz. Dokümantasyondaki belirtilen sinyalin 
    parametrik yapısına uygun olmalıdır. Yani her sinyale bağlanacak slot fonksiyonunun ya da metodunun parametrik yapısı o sinyale özgü 
    olarak değişebilmektedir. 

    Qt framework'ünde büyük bir türetme şeması vardır. Bir sınıfın kendi sinyali olmasa da onun taban sınıflarının siyali de kaltım gereği 
    kullanılabilmektedir. Örneğin QPushButton sınıfının kendi sinyali yoktur. Ama bu sınıf QAbstractButton sınıfından türetilmiştir. 
    Programcı o sınıftaki sinyalleri de sanki QPushButton sinyali imiş gibi kullanabilmektedir. O halde biz bir widget ile çalışıyorsak
    o widget'a ilişkin sınıfın ve o sınıfın tüm taban sınıflarının sinyallerini o widget'ta kullanabilriz. Nesne yönelimli bir modelle 
    çalışılıyorsa slotların da fonksiyon yerine ilgili sınıfın bir metodu yapılması iyi bir tekniktir.

    Bir sinyalin oluşmasına Qt'nin kendi terminolojisinde "sinyalin emit" edilmesi denilmektedir. Biz kursumuzda "sinyalin emit edilmesi" 
    teriminin yanı sıra "sinyalin tetiklenmesi" terimini de kullanacağız.

    Bir GUI eleman öğrenilirken o GUI elemana ilişkin sinyallerin neler olduğu da öğrenilmelidir. Bazı sinyaller çok seyrek kullanılmaktadır. 
    Örneğin QPushButton GUI elemanının en önemli sinyali clicked isimli sinyalidir. Bu GUI elemanı için diğer sinyallere neredeyse hiç 
    gereksinim duyulmamaktadır.

    Aşağıdaki örnekte iki QPushButton GUI elemanı kullanılmıştır. QPushButton sınıfının QAbstractButton sınıfından gelen clicked isimli 
    bir sinyali vardır. Biz düğme üzerinde farenin tuşuna basıp yine onu düğme üzerinde çekersek clicked sinyali tetiklenir ve slot 
    fonksiyonu ya da metodu çağrılır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedkHandler)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)
        self.pushButtonCancel.clicked.connect(self.pushButtonCancelClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        print('Ok clicked')
        
    def pushButtonCancelClickedsHandler(self):
        print('Cancel clicked')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir sinyal emir edildiğinde çalıştırılacak slot kodunun uzun bir zaman almaması gerekir. Aksi takdirde QApplication sınıfının exec 
    metodu GUI mesaj kuyruğundan sıradaki mesajı alamaz. Bu da programın sanki donmuş olduğu gibi bir durum oluşturur. Bir sinyal 
    tetiklendiğinde slot fonksiyonu hızlı bir biçimde gerekeni yapıp sonlanmalıdır. 

    Aşağıdaki örnekte Ok düğmesine basıldığında uzun bir işlem yapılmaktadır. Bu yüzden "program sanki donmuş gibi" bir etki oluşacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import time
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)
        self.pushButtonCancel.clicked.connect(self.pushButtonCancelClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        for i in range(10):
            time.sleep(1)
              
    def pushButtonCancelClickedHandler(self):
        print('Cancel clicked')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI eleman (yani bir widget) "enabled" ya da "disabled" durumda olabilir. GUI elemanın "enabled" olması demek klavye ve fare 
    işlemlerine tepki verebilmesi demektir. GUI elemanlar default durumda "enabled" biçimdedir. GUI eleman "disabled" duruma getirilirse 
    biz onun üzerine tıklasak bile bu işlem sinyal oluşturmaz. Yani GUI eleman dış dünyanın eylemlerine kapatılmış olur. Pek çok GUI 
    eleman "disabled" duruma getirildiğinde sönük bir renge boyanmaktadır. Böylece kullancılar sezgisel olarak onun disabled olduğunu 
    anlarlar. 

    GUI elemanı enabled/disabled yapmak için QWidget sınıfından gelen setEnabled metodu kullanılmaktadır. Bu metodun parametresi bool 
    türdendir. GUI elemanın enabled/disabled olup olmadığını anlamak için ise isEnabled metodu kullanılmaktadır. Bu metot da bize bool 
    bir değer geri vermektedir. (PyQt5'te ve PySide'ta bu metodun ismi enabled biçimindedir. Qt'nin orijinal C++ kütüphanesinde metot 
    enabled ismindedir.)

    Aşağıdaki örnekte ana pencere üzerinde Start ve Stop biçiminde iki düğme vardır. Start düğmesinin makineyi çalıştırdığı varsayılmaktadır. 
    Başlangıçta makine çalışmadığına göre Stop düğmesine basılmasının bir anlamı yoktur. Bu nedenle başlangıçta Stop düğmesi disabled 
    hale getirilmiştir. Start düğmesine basıldığında makine çalışacaktır. Makine çalışırken Start düğmesine yeniden basmanın da anlamı 
    olmadığı için Start düğmesi disabled Stop düğmesi enabled hale getirilmiştir. Stop düğmesine basıldığında ise tam ters işlem 
    yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt5.QtWidgets import *
import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonStart = QPushButton('Start', self)
        self.pushButtonStart.setGeometry(10, 10, 100, 100)
        self.pushButtonStart.clicked.connect(self.pushButtonStartClickedHandler)
        
        self.pushButtonStop = QPushButton('Stop', self)
        self.pushButtonStop.setGeometry(120, 10, 100, 100)
        self.pushButtonStop.clicked.connect(self.pushButtonStopClickedHandler)
        self.pushButtonStop.setEnabled(False)
        
    def pushButtonStartClickedHandler(self):
        self.pushButtonStart.setEnabled(False)
        self.pushButtonStop.setEnabled(True)

    def pushButtonStopClickedHandler(self):
        self.pushButtonStop.setEnabled(False)
        self.pushButtonStart.setEnabled(True)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI uygulamalarında print ve input fonksionlarının kullanılması uygun değildir. Çünkü bu fonksiyonlar konsol ekranına yazıp oradan 
    klavyeden (teknik anlamda stout ve stdin dosyalarından) okuma yapmaktadır. GUI pargamlarda kullanıcıya birtakım mesajlar vermek 
    için genel olarak "messagebox" denilen "owned" pencereler (diyalog pencereleri) kullanılmaktadır. 

    Qt'de messagebox oluşturmanın birkaç yolu vardır Birinci yolu QMessageBox sınıfını kullanmaktır. QMessageBox sınıfı ile messagebox 
    oluşturmanın adımları şöyledir:

    1) QMessageBox sınıfı türünden bir nesne yaratılır. Yaratım sırasında messagebox'ın üst penceresi de belirtilmektedir. Örneğin:

    mb = QMessageBox(self)

    2) Bu nesne ile sınıfın setWindowTitle metodu çağrılarak pencerenin başlık yazısı oluşturulur. Örneğin:

    mb.setWindowTitle('Sample MessageBox')

    3) Sınıfın setText metodu ile messagebox içerisindeki yazı oluşturulur. Örneğin:

    mb.setText('This is a test')

    4) Messagebox üzerinde görüntülenecek düğmelerin neler olacağı setStandardButtons isimi metotla ayarlanabilmektedir. Bu metotta programcı 
    QMessageBox sınıfının içerisindeki StandardButtons isimli enum sınıfından türetilmiş olan sınıfın çeşitli sembolik sabitlerini bit | 
    birleştirerek kullanır. Burada kullanılabilecek düğme belirten sembolik sabitlerin önemli olanları aşağıda belirtilmiştir:
    
    QMessageBox.StandardButton.Ok    
    QMessageBox.StandardButton.Open    
    QMessageBox.StandardButton.Save    
    QMessageBox.StandardButton.Cancel    
    QMessageBox.StandardButton.Close    
    QMessageBox.StandardButton.Discard    
    QMessageBox.StandardButton.Apply    
    QMessageBox.StandardButton.Reset    
    QMessageBox.StandardButton.RestoreDefaults    
    QMessageBox.StandardButton.Help    
    QMessageBox.StandardButton.SaveAll    
    QMessageBox.StandardButton.Yes    
    QMessageBox.StandardButton.YesToAll    
    QMessageBox.StandardButton.No    
    QMessageBox.StandardButton.NoToAll    
    QMessageBox.StandardButton.Abort    
    QMessageBox.StandardButton.Retry    
    QMessageBox.StandardButton.Ignore    
    QMessageBox.StandardButton.NoButton

    PyQt5'te Buradaki düğme belirten sembolik sabitler QMessageBox.StandardButtons sınıfının içerisinde değil doğrudan QMessageBox 
    sınıfının içerisindedir. Qt'nin orijinal C++ kütüphanesinde de durum böyledir. 

    Örneğin:

    mb.setStandardButtons(QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)

    Tabii burada programcı yalnızca yukarıda belirtilen düğme seçeneklerini kullanabilmektedir.

    5) Sınıfın setIcon metodu ile messagebox içerisinde görüntülenecek olan ikon ayarlanabilir. Tabii biz her ikonu burada görüntüleyemeyiz. 
    Görüntüleyebileceğimiz ikonlar QMessageBox sınıfının içerisindeki enum sınıfından türetilmiş olan Icon sınıfının içerisinde sembolik 
    sabitler biçiminde belirtilmiştir. Bunların listesi şöyledir:

    QMessageBox.Icon.NoIcon
    QMessageBox.Icon.Question
    QMessageBox.Icon.Information
    QMessageBox.Icon.Warning
    c.Critical

    Örneğin:

    mb.setIcon(QMessageBox.Icon.Question)

    PyQt5'te bu sembolik sabit QMessageBox.Icon.Question sınıfının içerisinde değil doğrudan QMessageBox sınıfının içerisindedir. 
    C++'taki orijinal kütüpahnede de böyledir.
  
    6) En sonunda sınıfın exec metodu çağrılmalıdır. Messagebox bir modal diyalog penceresidir. Dolayısıyla akış exec içerisinde 
    alır. Pencere kapatıldıktan sonra akış exec metodundan çıkar.

    Aslında QMessageBox nesnesi yaratılıp messagebox içerisinde çeşitli unsurların ilgili metotlarla set edilmesi yerine bu 
    unsurların hepsi QMessageBox sınıfının __init__ metodunda da belirtilebilir. Örneğin:

    mb = QMessageBox(self)
    mb.setWindowTitle('Warning')
    mb.setText('Save changes?')
    mb.setStandardButtons(QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)
    mb.setIcon(QMessageBox.Icon.Question)
    mb.exec()

    Burada tek tek metot çağırmak yerine bu özellikleri QMessageBox nesnesini yaratırken de verebilirdik:

     mb = QMessageBox(QMessageBox.Icon.Question, 'Warning', 'Save changes?',
            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel, self)
    mb.exec()

    Eğer QMessageBox sınıfının __init__ metodunu yukarıdaki gibi kullanacaksanız argümanları aşağıdaki sıraya göre girmelisiniz:

    QMessageBox(Icon, str, str, buttons=NoButton, parent=None, flags=Qt.Dialog|Qt.MSWindowsFixedSizeDialogHint)

    Tuş takımlarından istenilen bir tanesi default tuş olarak da belirlenebilir. Bunun için sınıfın setDefaultButton metodu çağrılmalıdır. 
    Bu belirleme yapılmazsa ilk düğme default olur. Örneğin:

    mb.setDefaultButton(QMessageBox.StandardButton.Cancel)

    Eğer messagebox içerisine birden fazla tuş yerleştirilmişse programcının messagebox pencersinin hangi tuşa basılarak kapatıldığını 
    bilmesi  gerekir. İşte exec metodunun geri dönüş değeri bize bu bilgiyi vermektedir. Bu değer bizim belirlediğimiz düğmelerden 
    birine eşit olacaktır. Örneğin:

    result = mb.exec()
    if result == QMessageBox.StandardButton.Yes:
        print('yes')
    elif result == QMessageBox.StandardButton.No:
        print('no')
    elif result == QMessageBox.StandardButton.Cancel:
        print('cancel')

    Default durumda X ikonuna tıklanarak da ESC tuşuna basılarak da messagebox penceresi kapatılabilmektedir. Aslında ESC tuşuna 
    basıldığında hangi tuşa basılmış gibi davranılacağı da değiştirilebilir. Bunun için sınıfın setEscapeButton metodu kullanılmaktadır. 
    Örneğin:

    mb.setEscapeButton(QMessageBox.StandardButton.No)

    Burada artık x ikonuna tıklandığında ya da ESC tuşuna basıldığında sanki No tuşuna basılmış gibi bir etki yaratılmaktadır. Bu 
    metot çağrılmazsa default durumda x ikonuna tıklandığında ya da ESC tuşuna basıldığında exec metodu QMessageBox.StandardButton.NoButton 
    değerine geri dönmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        mb = QMessageBox(self)
        mb.setWindowTitle('Warning')
        mb.setText('Save changes?')
        mb.setStandardButtons(QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)
        mb.setIcon(QMessageBox.Icon.Question)
        mb.setDefaultButton(QMessageBox.StandardButton.Cancel)
        mb.setEscapeButton(QMessageBox.StandardButton.Cancel)
        result = mb.exec()
        
        if result == QMessageBox.StandardButton.Yes:
            print('Yes')
        elif result == QMessageBox.StandardButton.No:
            print('No')
        else:
            print('Cancel')
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir messagebox çıkartmak için yapılması gerekenler bir fonksiyona da yaptırılabilir. İşte Qt'de QMessageBox sınıfının static 
    bazı metotları zaten yukarıda açıkladığımız metotları çağırarak çeşitli öğeleri messagebox içerisine yerleştirip mesaj penceresini 
    çıkarmaktadır. Bu metotlar şunlardır:

    about(parent, title, text)
    critical(parent, title, text[, buttons=QMessageBox.StandardButton.Ok[, defaultButton=QMessageBox.StandardButton.NoButton]])
    information(parent, title, text[, buttons=QMessageBox.StandardButton.Ok[, defaultButton=QMessageBox.StandardButton.NoButton]])
    question (parent, title, text[, buttons=QMessageBox.StandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            [, defaultButton=QMessageBox.StandardButton.NoButton]])
    warning (parent, title, text[, buttons=QMessageBox.StandardButton.Ok[, defaultButton=QMessageBox.StandardButton.NoButton]])

    Aslında bu metotların arasındaki farklar tuş takımı ve özellikle de ikonik görüntü ile ilgilidir. Genel olarak bu metotların hepsinin
    ilk parametreleri diyaog penceresinin üst penceresini belirtir. Sonraki iki parametre ise pencere başlık yazısı ve pencerenin iç 
    yazısıdır. Sonraki parametreler ise tuş takımı ve default tuş takımına ilişkindir. Örneğin:

    result = QMessageBox.information(self, 'Sample MessageBox', 'Sample text', QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
    if result == QMessageBox.Yes:
        print('yes')
    elif result == QMessageBox.No:
        print('no')
    elif result == QMessageBox.Cancel:
        print('cancel')

    Yukarıdaki metotların hepsi yine çıkılan düğme ile geri dönmektedir. about isimli metot yalnızca üç parametre alır. Bu metot 
    yalnızca "Ok" düğmesi çıkartır. Biz yazının görüntülenmesi için genellikle information ya da abaout metotları kullanılır. 
    Örneğin:

    QMessageBox.about(self, 'Message', 'this is a message')               
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        result = QMessageBox.warning(self, 'Warning', 'Save changes',
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)
        if result == QMessageBox.StandardButton.Yes:
            print('Yes')
        elif result == QMessageBox.StandardButton.No:
            print('No')
        else: 
            print('Cancel')
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi artık tek tek GUI elemanlarını inceleyeceğiz. Ancak araya başka konular da alacağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QPushButton sınıfı GUI uygulamalarında en fazla karşılaşılan düğme (pushbutton) denilen GUI elemanını temsil etmektedir. Sınıfın 
    türetme şeması şöyledir:

                QWidget
            QAbstractButton
    QPushButton QCheckBox  QRadioButton

    Görüldüğü gibi QPushButton, QCheckBox ve QReadioButton sınıflarının ortak elemanları QAbstractButton sınıfında toplanmıştır. Tüm 
    pencerelerin ortak elemanları ise QWidget sınıfında bulunmaktadır. 

    Bir QPushButton nesnesi genellikle üzerindeki yazıyla yaratılır. Örneğin:

    pushButtonOk = QPushButton('Ok', self)

    Bu GUI elemanının en önemli sinyali "clicked" isimli sinyaldir. Bu sinyali yukarıda tanıtmıştık. İstediğimiz zaman düğmenin 
    içerisindeki yazıyı text metoduyla alıp setText metodu ile değiştirebiliriz. Bu metotlar QAbstractButton sınıfından geldiği için 
    QCheckBox ve QRadioButton sınıflarında da kullanılabilir. 

    Aşağıdaki örnekte düğmenin üzerinde baştan "Start" yazısı bulunmaktadır. Bu düğmeye basıldığında yazı "Stop" haline geitirilmiştir. 
    "Stop" durumdayken yeniden düğmeye basıldığında yazı yendien "Start" haline getirilmiştir. Örneğin "Start" durumunda bu düğmeye 
    basıldığında bir makine çalıştırılıyor olabilir. Bu durumda onu durdurmak için ona yeniden basmak gerekebilir. 

    PushButton penceresinin içerisinde tıklanıp el fare düğmesinden çekildiği zaman clicked sinyali emit edilmektedir. Eskiden basında
    değil çekince işlemi başalatan düğmelere İngilizce "push button" deniliyormuş. Hala gerçek hayatta da bu tarz düğmeler kullanılmaktadır. 
    Tabii biz fareye dışarda tıklayıp düşmenin içerisinde parmağımızı tuştan çekersek ya da düğme üzerinde tıklayıp parmamığımı düğmenin
    dışında çekersek clicked sinyali emit edilmez. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.pushButtonAction = QPushButton('Start', self)
        self.pushButtonAction.setGeometry(10, 10, 100, 100)
        self.pushButtonAction.clicked.connect(self.pushButtonActionClickedHandler)
        
    def pushButtonActionClickedHandler(self):
        if self.pushButtonAction.text() == 'Start':
            self.pushButtonAction.setText('Stop')
        elif self.pushButtonAction.text() == 'Stop':
            self.pushButtonAction.setText('Start')
                     
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen birden fazla düğmenin clicked sinyaline aynı fonksiyonu yerleştirmek isteyebiliriz. Bu durumda bu düğmelerden hangisi tıklanırsa
    tıklansın aynı fonksiyon çağrılır. İşte bu sayede biz farklı düğmelere tıklandığında aynı şeylerin yapılmasını sağlayabiliriz. 
    Qt'de QPushButton sınıfının QAbstractButton sınıfından gelen clicked sinyalinde sinyale yol açan GUI nesnesini veren bir ek 
    parametre yoktur. Bu işlem Qt'de iki biçimde yapılabilmektedir. 

    Birinci yöntemde biz clicked sinyaline bir lambda ifadesi veririz. Lambda ifadeleri içinde bulunulan fonksiyondaki yerel değişkenleri 
    ve parametre değişkenlerini kullanabildiği için bu lambda ifadelerinde asıl fonksiyonu ya da metodu çağırabiliriz. Örneğin:

    self.pushButton1 = QPushButton('Button-1', self)
    self.pushButton1.setGeometry(20, 60, 100, 100)
    self.pushButton1.clicked.connect(lambda : self.buttonClickHandler(self.pushButton1))
    
    self.pushButton2 = QPushButton('Button-2', self)
    self.pushButton2.setGeometry(130, 60, 100, 100)
    self.pushButton2.clicked.connect(lambda : self.buttonClickHandler(self.pushButton2))
            
    self.pushButton3 = QPushButton('Button-3', self)
    self.pushButton3.setGeometry(240, 60, 100, 100)
    self.pushButton3.clicked.connect(lambda : self.buttonClickHandler(self.pushButton3))

    Burada aslında clicked sinyaline parametresiz bir lambda ifadesi verilmiştir. Yani aslında düğmelere tıklandığında bu lambda
    ifadeleri çalıştırılacaktır. Biz de bu lambda ifadelerinde asıl metodu ek bir parametreyle çağırdık. Bu metoda da ilgili 
    düğme nesnesini geçirdik. Burada buttonClickHandler metodu aşağıdaki parametrik yapıya sahip olmalıdır:
                  
    def buttonClickHandler(self, button):
        pass           

    Aşağıdaki örnekte bu yöntem uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)

        self.pushButton1 = QPushButton('Button-1', self)
        self.pushButton1.setGeometry(20, 60, 100, 100)
        self.pushButton1.clicked.connect(lambda : self.buttonClickHandler(self.pushButton1))
        
        self.pushButton2 = QPushButton('Button-2', self)
        self.pushButton2.setGeometry(130, 60, 100, 100)
        self.pushButton2.clicked.connect(lambda : self.buttonClickHandler(self.pushButton2))
              
        self.pushButton3 = QPushButton('Button-3', self)
        self.pushButton3.setGeometry(240, 60, 100, 100)
        self.pushButton3.clicked.connect(lambda : self.buttonClickHandler(self.pushButton3))
    
    def buttonClickHandler(self, button):
        print(button.text())
             
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    İkinci yöntemde düğmelerin hepsine yine aynı metot girilir. Sonra metot içerisinde sinyalin hangi GUI eleman tarafından gönderildiği 
    QObject sınıfının sender isimli metodundan elde edilir. Aslında tüm pencere sınıfları ve pek çok yardımcı sınıf Qt'de en tepedeki
    QObject isimli sınıftan tğretilmiştir. Bu yöntemde düğmelere aynı metot girilip hangi düğmeye basıldıüı aşağıdaki gibi tespit 
    edilebilir:

    def buttonClickHandler(self):
        button = self.sender()
        print(button.text())
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            21. Ders 17/05/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Checkbox denilen GUI elemanı QCheckBox sınıfıyla temsil edilmektedir. Bu sınıf da QAbstractButton sınıfından türetilmiştir. Bu GUI 
    eleman bir küçük kare ve onun yanında bir yazı biçiminde görüntülenir. Kullanıcı bu pencereye tıklandığında karenin içi çarpılı 
    değilse çarpılanır, çarpılıysa çarpısı kaldırılır. Karenin çarpılı olmasına İngilizce "checked" durumu çarpısız olmasına ise 
    "unchecked" durumu denilmektedir. Programcı bu GUI elemandan karenin çarpılı olup olmadığı bilgisini elde etmek ister. 
    
    Checkbox GUI elemanı "belli bir özelliğin istenip istenmediğini kullanıcının belirlemesi" amacıyla kullanılmaktadır. Örneğin 
    "settings" pencerelerinde bu GUI elemanına sıkça rastlanmaktadır. 

    QCheckBox nesnesi yaratılırken yine ilk parametre onun yazısını ikinci parametre onun hangi pencerenin içerisinde görüntüleneceğini 
    (yani onun üst penceresini) belirtmektedir. Örneğin:

    cb = QCheckBox('this is a test', self)

    CheckBox GUI elemanının çarpılı olup olmadığı QAbstractButton sınıfından gelen isChecked metoduyla belirlenir. GUI elemanının 
    yazısı yine QAbstractButton sınıfından gelen text metoduyla alınıp setText metoduyla set edilebilmektedir. Yine aynı sınıfta bulunan 
    clicked, toggled isimli sinyaller GUI elemanına tıklandığında ve çarpılanma durumu değiştirildiğinde emit edilmektedir. GUI elemanını 
    programalama yoluyla çarpılamak için (checked hale getirmek için) setChecked metodu kullanılmaktadır. setChecked metodu bool bir 
    parametre bekler. True "checked" durumunu False ise "unchecked" durumunu belirtir. 

    toggled isimli sinyale bağlanacak slot fonksiyonun bool türden bir parametresi olmak zorundadır. Bu parametre checkbox GUI elemanının 
    yeni durumun checked" mi "unchecked" mi olduğunu belirtir. toggled sinyali checked durumdan unchecked duruma, unchecked durumdan 
    checked duruma geçerken emit edilmektedir. clicked sinyali ise her tıklamada emit edilmektedir. Ancak yine de iki sinyal arasında
    önemli bir kullanım farkı yoktur. 

    Aşağıdaki örnekte bir QPushButton ve bir QCheckBox GUI elemanı pencereye yerleştirilmiş ve düğmeye basınca checkbox'ın çarpılı 
    olup olmadığı bilgisi görüntülenmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.checkBoxToolBar = QCheckBox('Araç çubuklarını görüntüle', self)
        self.checkBoxToolBar.move(50, 50)     
        self.checkBoxToolBar.setChecked(True)
        
        self.checkBoxStatusBar = QCheckBox('Durum Çubuğunu görüntüle', self)
        self.checkBoxStatusBar.move(50, 75)   
        
        self.checkBoxMenuBar = QCheckBox('Menü çubuğunu görüntüle', self)
        self.checkBoxMenuBar.move(50, 100)  
        self.checkBoxMenuBar.setChecked(True)
        
        self.checkBoxOnTop = QCheckBox('Sürekli Yukarıda Kalsın mı?', self)
        self.checkBoxOnTop.move(50, 125)
        self.checkBoxOnTop.toggled.connect(self.checkBoxOnTopClickedHandler)
        self.checkBoxOnTop.toggled.connect(self.checkBoxOnTopToggledHandler)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(50, 160)
        self.pushButtonOk.resize(70, 30)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        s = ('ToolBar checked' if self.checkBoxToolBar.isChecked() else 'ToolBar unchecked') + '\n'
        s += ('StatusBar checked' if self.checkBoxStatusBar.isChecked() else 'StatusBar unchecked') + '\n'
        s += ('MenuBar checked' if self.checkBoxMenuBar.isChecked() else 'MenuBar unchecked') + '\n'
        s += ('Sürekli yukarıda checked' if self.checkBoxOnTop.isChecked() else 'Sürekli yukarıda unchecked')
        QMessageBox.information(self, 'Bilgilendirme', s)
        
    def checkBoxOnTopClickedHandler(self):
        print(f'Clicked: {self.checkBoxOnTop.isChecked()}')
        
    def checkBoxOnTopToggledHandler(self, toggled):
        print(f'Toggled: {toggled}')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir checkbox üç konumlu (tristate) moda sokulabilir. Checkbox GUI elemanını üç konumlu moda sokmak için setTristate metodu, konumunu 
    almak için ise checkState metodu kullanılmaktadır. Bu checkState metodu şu üç değerden birini vermektedir:

    Qt.CheckState.Checked
    Qt.CheckState.Unchecked
    Qt.CheckState.PartiallyChecked

    Qt5'te bu Checked, Unchecked ve PartiallyChecked sembolik sabitleri doğrudan Qt modülünün içerisinde bulunuyordu. (Bu Qt modülü de 
    anımsanacağı gibi PyQt5.QtCore ya da PyQt6.QtCore içerisinde bulunmaktadır.) Ancak PyQt6'da Qt modülünün içerisine CheckState isimli 
    enum sınıfından türetilmiş bir sınıf yerleştirilmiş bu öznitelikler de bu sınıfa dahil edilmiştir. Yani PyQt5'te bu sabitler aşağıdaki 
    gibidir:

    Qt.Checked
    Qt.Unchecked
    Qt.PartiallyChecked
    
    Üç konumlu checkbox elemanını belli bir konuma programalama yoluyla getirilebilmek için setCheckState metodu kullanılmaktadır. 
    Bu metot da yukarıdaki üç parametreden birini almaktadır. Örneğin:

    self.checkBox.setCheckState(Qt.CheckState.PartiallyChecked)

    Pekiyi üç konumlu checkbox GUI elemanlarına neden gereksinim duyulmaktadır? İşte bazen checked ile unchecked arasında başka ara 
    durumlar da söz konusu olabilmekrtedir. Örneğin bir soruda kişi çekimser kalmak isteyebilir. Ya da örneğin bir ağaç yapısında eğer 
    alt öğelerin hepsi seçilmişse checkbox checked durumuna, hiçbiri seçilmemişse unchecked durumuna, bazıları seçilmişse partially 
    checked durumuna getirilebilir. 

    Aşağıdaki örnekte bir üç konumlu QCheckBox nesnesi bir de QPushButton nesnesi yaratılmıştır. Düğmeye tıklandığında üç konumlu 
    check box nesnesinin konumu message box ile görüntülenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.checkBox = QCheckBox('Üç konumlu checkbox', self)
        self.checkBox.move(50, 50)     
        self.checkBox.setTristate()
                   
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(50, 160)
        self.pushButtonOk.resize(70, 30)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        s = ''
        match self.checkBox.checkState():
            case Qt.CheckState.Checked:
                s = 'Checked State'
            case Qt.CheckState.Unchecked:
                s = 'Unchecked State'
            case Qt.CheckState.PartiallyChecked:
                s = 'Partially checked State'
        QMessageBox.information(self, 'CheckBox result', s)
              
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Radyo düğmeleri (Radio Buttons) çok karşılaşılan GUI elemanlardandır. Bu GUI eleman bir küçük yuvarlak ve yanında bir yazıyla 
    görüntülenmektedir. Tek bir radyo düğmesinin bir anlamı yoktur. Radyo düğmeleri bir grup olarak kullanılmaktadır. Bir radyo düğmesi 
    grubundaki bir radyo düğmesine tıklandığında daha önce çarpılı olan düğmenin çarpısı kaldırılır tıklanan düğme çarpılı hale getirilir. 
    Böylece belli bir anda yalnızca tek bir düğme çarpılı olabilmektedir. Radyo düğmeleri bir grup seçenekten kullanıcının yalnızca bir 
    tanesini seçmesinin istendiği durumlarda kullanılmaktadır. Radyo düğmeleri Qt'de QRadioButton sınıfı ile temsil edilmiştir. Bu sınıf 
    da QAbstractButton sınıfından türetilmiştir. 

                 QWidget 
             QAbstractButton 
    QPushButton  QCheckBox QRadioButton

    Radyo düğmelerini oluştururken genişlik yükseklik belirtilmezse zaten düğmeler yazının tamamını içerecek uygun bir büyüklükte 
    yaratılmaktadır. Bu nedenle bu düğmeleri oluştururken yalnızca move işlemini yapabilirsiniz. 

    Bir grup radyo düğmesinde hangi düğmenin çarpılı olduğunu anlamak için tüm radyo düğmelerine (çarpılı olanı bulana kadar) QAbstractButton
    sınıfınından gelen isChecked metodu uygulanmalıdır. Benzer biçimde belli bir düğmeyi programlama yoluyla çarpılı hale getirmek için 
    yine setCheck metodu kullanılır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.radioButtonA = QRadioButton('A', self)
        self.radioButtonA.move(50, 50)
        
        self.radioButtonB = QRadioButton('B', self)
        self.radioButtonB.move(50, 75)
        
        self.radioButtonC = QRadioButton('C', self)
        self.radioButtonC.move(50, 100)
        
        self.radioButtonD = QRadioButton('D', self)
        self.radioButtonD.move(50, 125)
        
        self.radioButtonE = QRadioButton('E', self)
        self.radioButtonE.move(50, 150)       
                           
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(50, 200)
        self.pushButtonOk.resize(70, 30)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        s = ''
        if self.radioButtonA.isChecked():
            s = 'A checked'
        elif self.radioButtonB.isChecked():
            s = 'B checked'
        elif self.radioButtonC.isChecked():
            s = 'C checked'
        elif self.radioButtonD.isChecked():
            s = 'D checked'
        elif self.radioButtonE.isChecked():
            s = 'E checked'
        else:
            s = 'No radio button checked'
        
        QMessageBox.information(self, 'Checked RadioButton', s)
              
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Çok fazla radyo düğmesi söz konusu olduğunda bunlar bir listeye yerleştirilip hangisinin çarpılandığı bir döngü içerisinde belirlenebilir. 
    Aşağıdaki örnekte bu yöntem kullanılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------
  
import sys
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.radioList = [None] * 5
        self.radioList[0] = QRadioButton('A', self)
        self.radioList[0].move(50, 50)
        
        self.radioList[1] = QRadioButton('B', self)
        self.radioList[1].move(50, 75)
        
        self.radioList[2] = QRadioButton('C', self)
        self.radioList[2].move(50, 100)
        
        self.radioList[3] = QRadioButton('D', self)
        self.radioList[3].move(50, 125)
        
        self.radioList[4] = QRadioButton('E', self)
        self.radioList[4].move(50, 150)       
                           
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(50, 200)
        self.pushButtonOk.resize(70, 30)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        s = 'no radio button checked'
        for rb in self.radioList:
            if rb.isChecked():
                s = rb.text() + ' checked'
                break 
        QMessageBox.information(self, 'Checked RadioButton', s)
              
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir pencerenin bütün alt pencereleri QWidget sınıfının children metoduyla elde edilebilir. Bu metot bize o pencerenin içerisindeki 
    tüm GUI elemanları bir liste biçiminde verecektir. O halde biz bütün alt pencereleri dolaşarak isinstance fonksiyonu ile QRadioButton
    nesnelerini bulup onlara isChecked uyguayabiliriz.  Örneğin

    def pushButtonOkClickedHandler(self):
        s = 'No radio button checked'
        for widget in self.children():
            if isinstance(widget, QRadioButton):
                if widget.isChecked():
                    s = widget.text() + ' checked'
                    break
        QMessageBox.information(self, 'Checked RadioButton', s)       

    Aşağıdaki örnekte ana pencere içerisindeki QRadioButton nesneleri tespit edilip onların üzerinde isChecked metodu uygulanmış ve 
    hangi radyo düğmesinin çarpılı olduğu bilgisi elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Generic GUI')
        self.setGeometry(100, 100, 640, 480)
        
        self.radioButtonA = QRadioButton('A', self)
        self.radioButtonA.move(50, 50)
        
        self.radioButtonB = QRadioButton('B', self)
        self.radioButtonB.move(50, 75)
        
        self.radioButtonC = QRadioButton('C', self)
        self.radioButtonC.move(50, 100)
        
        self.radioButtonD = QRadioButton('D', self)
        self.radioButtonD.move(50, 125)
        
        self.radioButtonE = QRadioButton('E', self)
        self.radioButtonE.move(50, 150)       
                           
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(50, 200)
        self.pushButtonOk.resize(70, 30)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        s = 'No radio button checked'
        for widget in self.children():
            if isinstance(widget, QRadioButton):
                if widget.isChecked():
                    s = widget.text() + ' checked'
                    break
        QMessageBox.information(self, 'Checked RadioButton', s)               
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aynı üst pencerenin kardeş radyo düğmeleri aynı grubu oluşturmaktadır. Bu nedenle iki farklı radyo düğmesi grubu oluşturabilmek 
    için radyo düğme gruplarını başka bir alt pencereye yerleştirmek gerekir. İşte bu amaçla kullanılan pencerelere "group box" denilmektedir. 
    Qt'de group box pencereleri QGroupBox sınıfı ile temsil edilmiştir. 

    QGroupBox penceresini oluştururken yine bir yazı ve üst pencere nesnesi belirtilir. Bu yazı group box penceresinin sol üst köşesinde
    görüntülenmektedir. Bir alt pencerenin koordinat bakımındna orijin noktasının onun üst penceresinin çalışma alanının sol üst 
    köşesi olduğunu anımsayınız. Bu durumda radyo düğmeleri QGoupBox nesnesine aşağıdaki gibi yerleştirilebilir:
     
    self.groupBoxFruit = QGroupBox('Meyve', self)
    self.groupBoxFruit.setGeometry(200, 20, 100, 150)
    
    self.radioButtonBanana = QRadioButton('Muz', self.groupBoxFruit)
    self.radioButtonBanana.move(15, 20)
    
    self.radioButtonOrange = QRadioButton('Portakal', self.groupBoxFruit)
    self.radioButtonOrange.move(15, 45)
    
    self.radioButtonStrawberry = QRadioButton('Portakal', self.groupBoxFruit)
    self.radioButtonStrawberry.move(15, 70)
    
    self.radioButtonCherry = QRadioButton('Kiraz', self.groupBoxFruit)
    self.radioButtonCherry.move(15, 95)

    Aşağıdaki örnekte iki ayrı grup box içerisinde iki ayrı dayo düğmesi grubu oluşturulmuştur. QGroupBox pencerelerinin içerisindeki 
    radyo düğmeleri konumlandırılırken orijin noktalarının kendi üst pencerelerinin (burada group box pencereleri) çalışma alaının 
    sol üst köşesi olacağına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QRadioButton Sample')
        self.resize(480, 350)
        
        self.groupBoxFruit = QGroupBox('Meyveler', self)
        self.groupBoxFruit.setGeometry(10, 10, 100, 150) 
        
        self.groupBoxTree = QGroupBox('Ağaçlar', self)
        self.groupBoxTree.setGeometry(130, 10, 100, 150) 
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 170, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkHandler)
        
        self.radioButtonBanana = QRadioButton('Muz', self.groupBoxFruit)
        self.radioButtonBanana.move(10, 20)
        
        self.radioButtonCherry = QRadioButton('Kiraz', self.groupBoxFruit)
        self.radioButtonCherry.move(10, 45)
        
        self.radioButtonApple = QRadioButton('Elma', self.groupBoxFruit)
        self.radioButtonApple.move(10, 70)
        
        self.radioButtonApricot = QRadioButton('Kayısı', self.groupBoxFruit)
        self.radioButtonApricot.move(10, 95)
        
        self.radioButtonDate = QRadioButton('Hurma', self.groupBoxFruit)
        self.radioButtonDate.move(10, 120)
        
        self.radioButtonPine = QRadioButton('Çam', self.groupBoxTree)
        self.radioButtonPine.move(10, 20)
        
        self.radioButtonOak = QRadioButton('Meşe', self.groupBoxTree)
        self.radioButtonOak.move(10, 45)
        
        self.radioButtonWillow = QRadioButton('Söğüt', self.groupBoxTree)
        self.radioButtonWillow.move(10, 70)
        
        self.radioButtonPlane = QRadioButton('Çınar', self.groupBoxTree)
        self.radioButtonPlane.move(10, 95)
        
        self.radioButtonPoplar = QRadioButton('Kavak', self.groupBoxTree)
        self.radioButtonPoplar.move(10, 120)
        
    def pushButtonOkHandler(self):
        selectedFruit = 'Hiçbir meyve seçilmedi'
        selectedTree = 'Hiçbir ağaç seçilmedi'
        
        for widget in self.groupBoxFruit.children():
            if widget.isChecked():
                selectedFruit = widget.text() + ' seçildi'
                break
            
        for widget in self.groupBoxTree.children():
            if widget.isChecked():
                selectedTree = widget.text() + ' seçildi'
                break
        
        QMessageBox.information(self, 'Seçilen Meyve Ve Ağaç', selectedFruit + '\n' + selectedTree)            
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                22. Ders 18/05/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi GUI uygulamalarında bir pencerenin içerisine sadece yazı yerleştirmek istersek bunu nasıl yapabiliriz? Yazı yazma aslında 
    bir çizim işlemidir. Biz de ileride pencerelerin içerisine doğrudan yazı yazmanın nasıl yapılacağını göreceğiz. Ancak genellikle 
    GUI uygulamalarında pencere içerisine yazı yazdırmak alt pencere yoluyla dolaylı bir biçimde yapılmaktadır. İsmine "label" denilen 
    bir alt pencere bu amaçla kullanılmaktadır. Label penceresinin sınır çizgileri çizilmez. Dolayısıyla kişiler orada bir alt pencere 
    olduğunu anlamayabilirler. Label pencerelerinin içi de default durumda üst pencereyle aynı renkte boyanmaktadır. Label penceresinin 
    tek işlevi içerisindeki yazının görüntülenmesini sağlamaktır. Label pencereleri Qt'de QLabel sınıfı ile temsil edilmiştir. QLabel 
    sınıfı QWidget sınıfından türetilmiştir. 
    
    QWidget
    QLabel
    
    Programcı QLabel sınıfı türünden bir nesne yaratırken diğer GUI elemanlarda olduğu görüntülenecek yazıyı üst pencere nesnesini belirtir. 
    Örneğin:
    
    labelName = QLabel('Adı Soyadı:', self)
    labelName.move(50, 50)

    QLabel nesnesi yaratılırken genellikle yalnızca konumlandırma yapılır. Zaten QLabel kendi içerisindeki yazıyı belirlenen font'ta
    görüntülemek için pencere boyutunu kendisi ayarlamaktadır. QLabel nesnesinin içersindeki yazı sınıfın text metoduyla alınıp setText 
    metoduyla değiştirebilmektedir. 

    Yukarıda da belirttiğimiz gibi QLabel nesnesini resize ya da setGeometry ile boyutlandırmazsak default olarak pencere genişlik ve 
    yüksekliği yazıyı içerecek kadar olur. Yazı birden fazla satırdan oluşsun isteniyorsa yazı içerisinde '\n' karakteri kullanılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(620, 480)
        
        self.label = QLabel('Bugün hava çok güzel\nEvet çok güzel', self)
        self.label.move(50, 50)
        
        self.pushButtonOk= QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 150, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                
    def pushButtonOkClickedHandler(self):
        text = self.label.text()
        QMessageBox.information(self, 'Message', text)
        self.label.setText('Adana')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de Font kavramı QFont isimli bir sınıfla temsil edilmiştir. QLabel sınıfı QWidget sınıfından türetilmiş durumdadır. QWidget 
    sınıfının font ve setFont metotları bize o anda kullanılan font'u get ve set eder. Bu durumda biz bir label (ya da diğer herhangi 
    bir GUI eleman) içerisindeki yazının büyüklüğünü ve biçimini değiştirmek için o nesne ile setFont metodunu çağırmalıyız. Ancak 
    setFont metodu bizden QFont nesnesi istemektedir. Bir QFont nesnesi ise tipik olarak font ailesinin ismi ve punto büyüklüğü ile 
    yaratılır. Örneğin:

    font = QFont('Timer New Roman', 20)

    QFont nesnesi yaratılırken diğer iki parametre daha girilebilir. Bu iki parametre sırasıyla yazının "boltluk durumunu" ve italiklik 
    durumunu belirtir. Bolt'luk durumu şu sembolik sabitlerden biri olabilmektedir:

    QFont.Weight.Thin    
    QFont.Weight.ExtraLight    
    QFont.Weight.Light    
    QFont.Weight.Normal    
    QFont.Weight.Medium    
    QFont.Weight.DemiBold    
    QFont.Weight.Bold    
    QFont.Weight.ExtraBold    
    QFont.Weight.Black

    PyQt5'te be bu sembolik sabitler doğrudan QFont sınıfının içerisinde bulunmaktadır. 

    İtaliklik durumu True, False biçiminde belirtilmektedir. Örneğin:

    font = QFont('Times New Roman', 20, QFont.Weight.Bold, True)

    Tabii QFont nesnesi yaratıldıktan sonra da fontun özellikleri QFont sınıfının setXXX metotlarıyla da set edilebilmektedir. 
    QFont sınıfı PyQt6.QtGui modülü içerisindedir. Dolayısıyla programcının şu import işlemini de yapması gerekir:

    form PyQt6.QtGui import *

    Yazının rengi font'un bir özelliği değildir. Yani biz font nesnesi yoluyla yazının rengini değiştiremeyiz. İzleyen paragraflarda 
    bu işlemin nasıl yapıldığı açıklanmaktadır. 
        
    Aşağıdaki örnekte bir QLabel nesnesi yoluyla bir sayaç yazısı ana pencereye yazılmıştır. Ok düğmesine her basıldığında bu yazı 
    artılarak değiştirilmektedir. Tabii mademki font özelliği QWidget sınıfından gelmektedir. Her GUI eleman sınıfı QWidget sınıfından 
    türetildiğine göre biz setFont metodula her GUI elemanının yazısının fontunu değiştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(620, 480)
        
        self.labelCount = QLabel('0', self)
        self.labelCount.move(50, 50)
        self.labelCount.resize(100, 30)
        self.labelCount.setFont(QFont('Times New Roman', 14, QFont.Weight.Bold))
                
        self.pushButtonOk= QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 150, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        self.pushButtonOk.setFont(QFont('Arial', 15))
        
        self.count = 0
                
    def pushButtonOkClickedHandler(self):
        self.count += 1
        self.labelCount.setText(str(self.count))
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLabel nesnesinin bir alt pencere oluşturduğuna yazının alt pencerenin içerisine yazıldığına dikkat ediniz. Aşağıdaki örnekte 
    henüz görmemiş olsak da Qt'nin "stylesheet" özelliği ile QLabel alt penceresinin zemin rengini ve QLabel içerisindeki yazının 
    rengini değiştiren bir kod parçası veriyoruz. 
    
    labelMessage.setStyleSheet('QLabel {background-color: yellow; color: blue}')

    Biz bu stylesheet özelliği ile yalnızca label nesnelerinin değil her GUI elemanın özelliklerini değiştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(620, 480)
        
        self.labelCount = QLabel('0', self)
        self.labelCount.move(50, 50)
        self.labelCount.resize(100, 30)
        self.labelCount.setFont(QFont('Times New Roman', 14, QFont.Weight.Bold))
        self.labelCount.setStyleSheet('QLabel {background-color: yellow; color: red}')
                
        self.pushButtonOk= QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 150, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        self.pushButtonOk.setStyleSheet('QPushButton {color: blue}')
        self.pushButtonOk.setFont(QFont('Arial', 15))    
        
        self.count = 0
                
    def pushButtonOkClickedHandler(self):
        self.count += 1
        self.labelCount.setText(str(self.count))
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLabel sınıfının setAlignment isimli metodu yazıyı QLabel penceresinin içerisinde hizalamakta kullanılır. Hizalama için yatay ve 
    düşey iki değerin bit düzeyinde | operatörü ile OR'lanması gerekmektedir. Yatay hizalama için kullanılacak sembolik sabitler 
    şunlardır:

    Qt.AlignmentFlag.AlignLeft    
    Qt.AlignmentFlag.AlignRight    
    Qt.AlignmentFlag.AlignHCenter    
    Qt.AlignmentFlag.AlignJustify

    Düşey hizalama için kullanılacak sembolik sabitler de şunlardır:

    Qt.AlignmentFlag.AlignTop
    Qt.AlignmentFlag.AlignBottom
    Qt.AlignmentFlag.AlignVCenter
    Qt.AlignmentFlag.AlignBaseline

    O halde biz örneğin label penceremiz içerisindeki yazıyı dikdörtgensel alanın içerisine şöyle ortalayabiliriz:

    labelMessage.setAlignment(Qt.AlignmentFlag.AlignHCenter|Qt.AliAlignmentFlaggnFlag.AlignVCenter)

    QLabel nesnelerinde yazılar için default alignment Qt.AlignmentFlag.AlignLeft|Qt.AlignmentFlag.AlignVCenter biçimindedir. Yani
    default durumda yazı orta sola hizalanmaktadır.

    Aşağıdaki örnekte QLabel penceresinin sınırları anlaşılsın diye pencere sarı renge boyanmıştır ve yazı pencere içerisinde sağ 
    alta hizalanmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(620, 480)
        
        self.label = QLabel('Ankara', self)
        self.label.move(50, 50)
        self.label.resize(200, 100)
        self.label.setFont(QFont('Times New Roman', 14, QFont.Weight.Bold))
        self.label.setStyleSheet('QLabel {background-color: yellow; color: red}')
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter|Qt.AlignmentFlag.AlignCenter)
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 150, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        self.pushButtonOk.setStyleSheet('QPushButton {color: blue}')
        self.pushButtonOk.setFont(QFont('Arial', 12))    
                
    def pushButtonOkClickedHandler(self):
        pass
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı framework'lerde resim görüntülemek için özel GUI elemanlar kullanılmaktadır. Genellikle de bu tür elemanlar PictureBox gibi, 
    PictureWidget gibi isimler alırlar. Qt'de resim görüntülemek için QLabel GUI elemanından faydalanılabilmektedir. (Ancak başka GUI 
    elemanlar da resim görüntülemede kullanılabilmektedir.) Programcı önce resmi bir QPixmap nesnesi biçiminde oluşturur. Sonra QLabel 
    sınıfının setPixmap metodu ile resmi QLabel nesnesine iliştirir. QPixmap sınıfı bir resim alanı (bitmap) oluşturmaktadır. QPixmap 
    nesnesi içi boş olarak genişlik ve yükseklik belirtilerek oluşturulabilir. Örneğin:

    pixmap = QPixmap(100, 100)

    QPixmap nesnesi bir resim dosyası belirtilerek de oluşturulabilmektedir. Örneğin:

    pixmap = QPixmap('AbbeyRoad.jpg')
   
    Aslında Qt'de resimler QImage sınıfı ile temsil edilmektedir. Elimizde bir QImage nesnesi varsa ondan da QPixmap nesnesini
    oluşturabiliriz. Örneğin:

    image = QImage('AbbeyRoad.jpg')
    pixmap = QPixmap(image)

    Özetle Qt'te QImage bir resmin data'larını QPixmap ise bir resim alanını temsil etmektedir. 

    Elimizde bir QPixmap nesnesi varsa biz o resim alanının genişlik ve yüksekliğini size metodu ile elde edebiliriz. Benzer biçimde 
    QPixmap nesnesinin genişlik ve yükseklikleri ayrı ayrı width ve height metotlarıyla da elde edilebilmektedir. QPixmap nesnesi 
    bir GUI eleman değildir. Dolayısıyla yalnızca QPixmap nesnesi ile biz resmi görüntüleyemeyiz. Bizim bu QPixmap nesnesini bir 
    QLabel nesnesine iliştirmemiz gerekir. Bunun için QLabel sınıfının setPixmap metodu kullanılmaktadır. Örneğin:

    pixmap = QPixmap('AbbeyRoad.jpg')
    
    labelImage = QLabel('', self)
    labelImage.setPixmap(pixmap)

    Eğer resim büyük fakat QLabel nesnesi küçük ise QLabel nesnesi üzerinde yalnızca resmin sol üst kısmı gözükür. Ancak QLabel 
    nesnesinin boyutu ayarlanmayıp yukarıdaki gibi ona doğrudan setPixmap ile bir resim resim alanı iliştirilirse bu durumda QLabel 
    nesnesi zaten otomatik olarak resim boyutuna çekilmektedir. Tabii biz ana pencereyi de istersek resim boyutuna getirebiliriz. 
    Örneğin:

    self.resize(pixmap.size())
    
    Eğer önce QLabel GUI elemanı boyutlandırıp sonra setPixmap yapılırsa bu durumda QLabel GUI elemanın boyutları resim boyutuna 
    çekilmez. QLabel GUI elemanı yalnızca resmin sol üst köşesini görüntüler. (Bu konuda bazı ayrıntılar vardır.) Örneğin:

    labelImage = QLabel('', self)
    labelImage.resize(100, 100)
    labelImage.setPixmap(pixmap)

    Burada resmin yalnızca sol üst köşesi görüntülenmektedir. Aslında aynı durum yazılarda da geçerlidir. Biz QLabel nesnesini
    boyutlandırmadan bir yazı iliştirirsek QLabel bu yazının hepsini gösterir. Ancak önce boyutlandırıp daha sonra yazı set edersek 
    QLabel boyutunu değiştirmez. 

    Aşağıdaki örnekte "AbbyRoad.jpg" isimli resim dosyası bir QLabel GUI elemanı kullanılarak görüntülenmiştir. QLabel nesnesi hiç 
    konumlandırılmadığı için (0, 0) konumumdadır. Genişlik ve yükseklik otomatik olarak resim boyutuna çakilmiştir. Biz burada ana
    pencereyi de resim boyutuna getirdik.

    (Bu örneklerde kullandığımız "AbbeyRoad.jpg" Beatles'in "Abbey Road" albümünün kapak fotoğrafıdır. Bu fotoğrafta Beatles Londra'nın
    Abbey Road denilen kayıt stüdyolarının bulunduğu bölgede yaya geçidinden karşıdan karşıya geçmektedir. "Abbey Road" albüm kapağı 
    tüm zamanların en ünlü albüm kapağıdır.)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
                
        pixmap = QPixmap('AbbeyRoad.jpg')
        self.resize(pixmap.size())
               
        self.label = QLabel('', self)
        self.label.setPixmap(pixmap)        
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer QLabel nesnesi boyutlandırılmışsa ve boyutu resimden küçükse bu durumda QLabel hizalama biçimine 
    göre resmin sol üst köşesine ilişkin kısmı gösterecektir. QLabel nesnelerinde default hizalama sol orta biçimindedir. Bu durumda 
    resimin sol orta kısmı QLabel üzerinde görüntülenir. Eğer resmin sol üst köşesini görüntüleyecekseniz label nesnesinin hizalama 
    özelliğini şöyle set etmelisiniz:

    label.setAlignment(Qt.AlignmentFlag.AlignTop|Qt.AlignmentFlag.AlignLeft)

    Eğer resim QLabel penceresinden küçük olursa resim QLabel penceresinin içerisinde alignment ile belirtilen hizalamada görüntülenmektedir. 

    Aşağıdaki örnekte biz belli büyüklükte bir QLabel GUI elemanı oluşturup bu GUI elemanının daha küçük bir resmi görüntülemesini 
    sağladık. QLabel penceresinin zemin rengini kasten sarıya boyadık. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(900, 900)
                
        pixmap = QPixmap('Chuckberry.jpg')
        self.label = QLabel('', self)
        self.label.setStyleSheet('QLabel {background-color: yellow}')
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter|Qt.AlignmentFlag.AlignVCenter)
        self.label.resize(800, 800)
        self.label.setPixmap(pixmap)        
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ancak daha çok istenen şey QLabel nesnesini resme göre boyutlandırmak değil resmi QLabel nesnesinin boyutuna getirmektir. Bu tür 
    işlemlere resmin "scale" edilmesi ya da "stretch" edilmesi denilmektedir. Bunun için QPixmap sınıfının scaled isimli metodu 
    kullanılmaktadır. Bu metot bize scale edilmiş yeni bir QPixmap nesnesi verir. Örneğin:

    pixmap = QPixmap('AbbeyRoad.jpg')
    pixmapScaled = pixmap.scaled(200, 200)

    Tabii bu işlemi tek hamlede de aşağıdaki gibi yapabiliriz:

    pixmap = QPixmap('AbbeyRoad.jpg').scaled(200, 200) 

    Ancak resimleri scale ederken dikkat etmek gerekir. Çünkü scale işlemi ile resmin en boy oranı bozulabilir. Bu bozulma sonucunda 
    resim istenmeyen biçimde görünebilir. En boy oranını koruma işlemi manuel bir biçimde yapılabilir. Ancak bunun için zaten scaled 
    metodunda üçüncü bir parametre bulundurulmuştur. Bu üçüncü parametre şu sembolik sabitlerden biri olabilmektedir:

    Qt.AspectRatioMode.IgnoreAspectRatio    
    Qt.AspectRatioMode.KeepAspectRatio    
    Qt.AspectRatioMode.KeepAspectRatioByExpanding

    PyQt5'te bu sembolik sabitler doğrudan Qt modülü içerisindedir. 

    Burada Qt.AspectRatioMode.KeepAspectRatio verilen boyutlardan birini sağlayıp diğerini küçülterek en boy oranını korur. 
    Qt.AspectRatioMode.KeepAspectRatio ise verilen boyutlardan birini koruyup diğerini yükselterek en boy oranını korumaktadır. Genellikle 
    burada Qt.AspectRatioMode.KeepAspectRatio sembolik sabiti kullanılmaktadır. Örneğin:

    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()
            self.resize(900, 900)
                    
            pixmap = QPixmap('AbbeyRoad.jpg').scaled(400, 400, Qt.AspectRatioMode.KeepAspectRatio)           
            self.label = QLabel('', self)
            self.label.move(50, 50)
            self.label.setStyleSheet('QLabel {background-color: yellow}')
            self.label.setPixmap(pixmap)  

    Burada QPixmap nesnesi yaratılıp yaratılmaz scaled metodu ile boyutlandırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(640, 480)
                
        pixmap = QPixmap('AbbeyRoad.jpg').scaled(400, 400, Qt.AspectRatioMode.KeepAspectRatio)
        
        self.label = QLabel('', self)
        self.label.move(50, 50)
        self.label.setStyleSheet('QLabel {background-color: yellow}')
        self.label.setPixmap(pixmap)         
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resim dikdörtgensel bir büyüklüğe sahiptir. Bu dikdörtgensel büyüklükte resmin içinde olan ancak resmin zeminini oluşturan 
    kısım o resmi yerleştirdiğimiz zemini bozabilmektedir. İşte bu tür durumlarda zemini bozan kısımların transparan yapılması gerekir. 
    Belli bir rengin transparan yapılması mümkünse de aslında resmin neresinin transparan yapılacağı resmi oluşturan kişi tarafından 
    daha iyi bir biçimde bilinir. Dolayısıyla resmi oluşturan kişiler nerelerin transparan yapılması gerektiğini belirleyebilirler. 
    İşte PNG dosya format'ı kendi içerisinde bu transparanlık bilgisini de bulundurduğu için PNG resimlerin başka bir zemine yerleştirilmesi 
    tam olarak onların o zemine nüfuz etmiş gibi görünmelerini sağlamaktadır. Bu tür durumlarda PNG formatını tercih etmelisiniz. 
        
    Şimdi de oyun kartlarını ayrı ayrı QLabel nesneleri ile pencere içerisinde rastgele yerlerde görüntüleyelim. Örneğimizde oyun 
    kartları "CardImages" içerisindeki bir dizinde ".png" bulunmaktadır. Biz bu dizindeki tüm dosyaların yol ifadelerini glob.glob
    fonksiyonu ile elde edip onlardan QPixmap ve QLabel nesneleri yarattık:

    SCALE_RATIO = 1.2
    ....

    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()
            self.resize(1200, 800)
                    
            for path in glob.glob('CardImages/*.png'):
                pixmap = QPixmap(path)
                scaled_bixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
                x = random.randint(0, self.width() - scaled_bixmap.width())
                y = random.randint(0, self.height() - scaled_bixmap.height())
                labelImage = QLabel('', self)
                labelImage.move(x, y)
                labelImage.setPixmap(scaled_bixmap)

    Buradaki oyun kartları default durumda 72x96 boyuttadır. Burada bir noktaya dikkatinizi çekmek istiyoruz. PNG formatı tıpkı BMP 
    formatı gibi bitmap (raster) bir formattır. Dolayısıyla bu formattaki resimler büyütülüp küçültüldüğünde görüntü çok çabuk bozulma
    eğilimindedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import random
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import glob

SCALE_RATIO = 1.2

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(1200, 800)
                
        for path in glob.glob('CardImages/*.png'):
            pixmap = QPixmap(path)
            scaled_bixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
            x = random.randint(0, self.width() - scaled_bixmap.width())
            y = random.randint(0, self.height() - scaled_bixmap.height())
            labelImage = QLabel('', self)
            labelImage.move(x, y)
            labelImage.setPixmap(scaled_bixmap)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                23. Ders 24/05/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir satranç tahtasını taşlarıyla birlikte çizdirelim. Bu çizim için gereken BMP ve PNG resimler kurs dizinindeki 
    "ChessFigures" klasörü içerisindedir. Aşağıdaki programdaki ana noktalar şunlardır:

    - Satranç tahtasını pencere içerisinde marjinle ortalamak için TOP_MARGIN ve LEFT_MARGIN isimli iki sembolik sabit kullanılmıştır. 
    - Programda karelerin ve dolayısıyla taşların büyüklükleri SQUARE_SIZE sembolik sabitiyle ayarlanabilmektedir. 
    - Önce kareler QLabel GUI elemanı ile oluşturulmuş sonra onun üzerine yine QLabel ile taş resimleri bindirilmiştir. Aslında böylece
    iki QLabel nesnesi üst üste bindirilmiştir. Ancak taşlara ilişkin QLabel nesnesinin resmi trasparan olduğu için onun altındaki kareler
    de görülmektedir.
    - Satranç tahtasındaki her karenin matriste bir satır sütun numarası vardır. Biz karenin satrançtaki koordinatı verildiğinde onun 
    sol üst köşesinin pixel koordinatları coord2pos static metoduyla elde edilmektedir. Satrançta sol alttan başlanarak karelere koordinat 
    verilmektedir. Sol alt karenin koordinatı "a1" dir. 
    - Burada henüz taşlara ilişkin QLabel nesneleri herhangi bir yerde tutulmamıştır. Eğer bu nesneler tutuluyor olsaydı biz bu QLabel 
    nesnesi üzerinde move metodunu uyguladığımızda taşı hareket ettirebilidik. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

SQUARE_SIZE = 80
LEFT_MARGIN = 10
TOP_MARGIN = 10

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(8 * SQUARE_SIZE + 2 * LEFT_MARGIN, 8 * SQUARE_SIZE + 2 * TOP_MARGIN)
        self.setMaximumSize(8 * SQUARE_SIZE + 2 * LEFT_MARGIN, 8 * SQUARE_SIZE + 2 * TOP_MARGIN)
        self.setMinimumSize(8 * SQUARE_SIZE + 2 * LEFT_MARGIN, 8 * SQUARE_SIZE + 2 * TOP_MARGIN)
                       
        whiteSquarewPixmap = QPixmap('ChessFigures/WhiteSquare.bmp').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackSquarewPixmap = QPixmap('ChessFigures/BlackSquare.bmp').scaled(SQUARE_SIZE, SQUARE_SIZE)
        
        whitePawn = QPixmap('ChessFigures/WhitePawn.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackPawn = QPixmap('ChessFigures/BlackPawn.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        whiteRook = QPixmap('ChessFigures/WhiteRook.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackRook = QPixmap('ChessFigures/BlackRook.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        whiteKnight = QPixmap('ChessFigures/WhiteKnight.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackKnight = QPixmap('ChessFigures/BlackKnight.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        whiteBishop = QPixmap('ChessFigures/WhiteBishop.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackBishop = QPixmap('ChessFigures/BlackBishop.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        whiteQueen = QPixmap('ChessFigures/WhiteQueen.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackQueen = QPixmap('ChessFigures/BlackQueen.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        whiteKing = QPixmap('ChessFigures/WhiteKing.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        blackKing = QPixmap('ChessFigures/BlackKing.png').scaled(SQUARE_SIZE, SQUARE_SIZE)
        
        whitePieces = [whiteRook, whiteKnight, whiteBishop, whiteQueen, whiteKing, whiteBishop, whiteKnight, whiteRook]
        blackPieces = [blackRook, blackKnight, blackBishop, blackQueen, blackKing, blackBishop, blackKnight, blackRook]
        
        y = TOP_MARGIN
        for row in range(8):
            x = LEFT_MARGIN
            for col in range(8):
                labelSquare = QLabel('', self)
                labelSquare.setPixmap(whiteSquarewPixmap if (row + col) % 2 == 0 else blackSquarewPixmap)
                labelSquare.move(x, y)
                x += SQUARE_SIZE
            y += SQUARE_SIZE
            
        for i in range(8):
            x, y = self.coord2pos('abcdefgh'[i], 2)
            labelFigure = QLabel('', self)
            labelFigure.setPixmap(whitePawn)
            labelFigure.move(x, y)
            
            x, y = self.coord2pos('abcdefgh'[i], 7)
            labelFigure = QLabel('', self)
            labelFigure.setPixmap(blackPawn)
            labelFigure.move(x, y)
            
            x, y = self.coord2pos('abcdefgh'[i], 1)
            labelFigure = QLabel('', self)
            labelFigure.setPixmap(whitePieces[i])
            labelFigure.move(x, y)
            
            x, y = self.coord2pos('abcdefgh'[i], 8)
            labelFigure = QLabel('', self)
            labelFigure.setPixmap(blackPieces[i])
            labelFigure.move(x, y)
            
    @staticmethod
    def coord2pos(letter, number):
        x = LEFT_MARGIN + (ord(letter.lower()) - ord('a')) * SQUARE_SIZE
        y = TOP_MARGIN + (8 - number) * SQUARE_SIZE
        
        return x, y
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI dünyasında kullanıcıdan yazı alan GUI elemanlara genellikle "edit box" ya da "text box" denilmektedir. PyQt'de tek satırlı 
    edit pencereleri QLineEdit sınıfıyla temsil edilmiştir. Sınıf nesnesi üst pencere belirtilerek yaratılır. Örneğin:

    self.lineEditName = QLineEdit(self)

    İstersek edit alanında belli bir yazı görüntülenecek biçimde de GUI elemanı yaratabiliriz. Örneğin:

    self.lineEditName = QLineEdit('This is a test', self)
    
    Konumlandırma yine move, resize ya da setGeometry metotlarıyla yapılır. Programcı edit alanı içerisine girilmiş olan yazıyı almak 
    ister. Bunun için sınıfın text isimli metodu kullanılmaktadır. Yine edit alanı içerisindeki yazı sınıfın setText metodu ile set 
    edilebilir. 
    
    QLineEdit sınıfı doğrudan QWidget sınıfından türetilmiştir:

    QWidget <--- QLineEdit
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.labelName.move(50, 50)
             
        self.lineEditName = QLineEdit(self)
        self.lineEditName.setGeometry(50, 70, 250, 30)
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 120, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
        
    def pushButtonClickedHandler(self):
        text = self.lineEditName.text()          
        QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Edit alanı içerisindeki yazı default durumda sola dayalı biçimde oluşturulmaktadır. Ancak programcı sınıfın setAlignment metodu 
    ile yazının hizalanmasını değiştirebilir. setAlignment metodunun parametresi şu sembolik sabitlerdne biri olabilir:

    Qt.AlignmentFlag.AlignLeft    
    Qt.AlignmentFlag.AlignRight    
    Qt.AlignmentFlag.AlignHCenter    
    Qt.AlignmentFlag.AlignJustify

    PyQt5'te bu sembolik sabitlerdoğrudan Qt modülü içerisindedir.

    Aşağıdaki örnekte edit alanındaki yazı ortalanmıştır. Edit alanı içerisindeki yazının hizalanma biçimi alignment isimli metotla 
    elde edilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.labelName.move(50, 50)
             
        self.lineEditName = QLineEdit(self)
        self.lineEditName.setGeometry(50, 70, 250, 30)
        self.lineEditName.setAlignment(Qt.AlignmentFlag.AlignCenter)
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 120, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
        
    def pushButtonClickedHandler(self):
        text = self.lineEditName.text()          
        QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden QWidget sınıfının içerisinde default bir font nesnesinin olduğunu belirtmiştik. Bu font nesnesi GUI eleman sınıflarının 
    QWidget sınıfından gelen font metoduyla elde edilip setFont metoduyla set edilebilir. font metodu bize QWidget nesnesinin içerisindeki 
    font'un bir kopyasını vermektedir. Örneğin biz edit alanı içerisindeki yazının yalnızca büyüklüğünü değiştirmek istiyorsak önce font 
    metodu ile font nesnesini alıp pointSize metodu ile punto büyüklüğünü ayarlayıp setFont metodu ile font nesnesini yeniden set etmeliyiz:

    font = self.lineEditName.font()
    font.setPointSize(14)
    self.lineeditName.setFont(font)

    Aşağıdaki örnekte GUI elemanların font'ları ana pencerenin default font nesnesinden hareketle büyütülmüştür.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        font = self.font()
        font.setPointSize(14)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.labelName.move(50, 50)
        self.labelName.setFont(font)
             
        self.lineEditName = QLineEdit(self)
        self.lineEditName.setGeometry(50, 80, 250, 30)
        self.lineEditName.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lineEditName.setFont(font)
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
        self.pushButtonOk.setFont(font)
        
    def pushButtonClickedHandler(self):
        text = self.lineEditName.text()          
        QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt5 ile birlikte "style sheet" kullanımı da framework'e eklenmiştir. Örneğin biz üst bir GUI elemanın "style sheet" yoluyla 
    fontu ile oynama yaparsak bütün alt GUI elemanlar bundan etkilenir. Örneğin biz ana pencere nesnesi üzerinde setStyleSheet metodu 
    ile font büyüklüğünü değiştirirsek bundan yaratılacak olan tüm alt pencereler etkilenir:
    
    self.setStyleSheet('QWidget {font-size: 12pt}')
    
    Aşağıda buna bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.labelName = QLabel('Adı Soyadı:', self)
        self.labelName.move(50, 50)
             
        self.lineEditName = QLineEdit(self)
        self.lineEditName.setGeometry(50, 80, 250, 30)
        self.lineEditName.setAlignment(Qt.AlignmentFlag.AlignCenter)
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)  
        
    def pushButtonClickedHandler(self):
        text = self.lineEditName.text()          
        QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    setInputMask metodu edit alanına girilecek karakterleri sınırlandırmak ve biçimlendirmek için kullanılmaktadır. Bu metodun parametresi 
    mask yazısını alır. Mask karakterleri için Qt dokümanlarına başvurabilirsiniz. Mask karakterlerinin tipik olanlarından biri 9'dur. 
    Buradaki 9 aslında herhangi bir sayısal karakteri temsil etmektedir. Mask karakterlerinin dışındaki karakterler ilgili pozisyonda 
    görüntülenmektedir. Örneğin:

    self.lineEditDate.setInputMask('99/99/9999)

    Bu tipik bir tarih bilgisi almak için oluşturulmuş mask'tir. Tabii bu tür bilgiler kullanıcıdan alınırken setInputMask ancak kaba 
    bir önlem oluşturmaktadır. Yukarıdaki bir mask işlemini QLineEdit nesnesine uygulamış olmamız kullanıcı girdiği tarihin geçerli 
    olduğu anlamına gelmemektedir. Tarih girişinin sınanması için ayrıca datetime sınıfının strptime metodundan faydalanılabilir. 
    Örneğin:

    def pushButtonClickedHandler(self):
        text = self.lineEditDate.text()  
        try:
            dt = datetime.datetime.strptime(text, '%d/%m/%Y')
            QMessageBox.information(self, 'Message', 'Date is ok')
        except ValueError:
            QMessageBox.warning(self, 'Warning', 'Date is not correct!')
            self.lineEditDate.setFocus()

    Burada girilen tarihin geçerliliği sınanmak istenmiştir. Eğer tarih geçerli değilse oluşan exception ile bu durum kullanıcıya 
    bildirilmektedir. Aşağıda buna ilişkin bir örnek veriyoruz.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.labelDate = QLabel('Tarih:', self)
        self.labelDate.move(50, 50)
             
        self.lineEditDate = QLineEdit(self)
        self.lineEditDate .setGeometry(50, 80, 250, 30)
        self.lineEditDate .setInputMask('99/99/9999')
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
        text = self.lineEditDate.text()  
        try:
            dt = datetime.datetime.strptime(text, '%d/%m/%Y')
            QMessageBox.information(self, 'Message', 'Date is ok')
        except ValueError:
            QMessageBox.warning(self, 'Warning', 'Date is not correct!')
            self.lineEditDate.setFocus()
                    
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Mask için '>' karakteri alfabetik karakterlerin her zaman büyük harfle '<' karakteri ise küçük harfle görüntüleneceğini belirtir. 
    'A' karakteri ise herhangi bir alfabetik karakteri temsil etmektedir. Örneğin:

    self.lineEdit.setInputMask('>99-AAA-999')

    Burada bir plake girişi için mask oluşturulmuştur. Oratadaki üç alfabetik karakter her zaman büyük harf ile görüntülenecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.labelDate = QLabel('Tarih:', self)
        self.labelDate.move(50, 50)
             
        self.lineEditDate = QLineEdit(self)
        self.lineEditDate .setGeometry(50, 80, 250, 30)
        self.lineEditDate.setInputMask('>99-AAA-9999')
             
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
        text = self.lineEditDate.text()  
        QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit GUI elemanı "read-only" moda sokulabilir. Bunun için sınıfın setReadOnly metodu True argümanı ile çağrılmalıdır. GUI 
    Elemanın read-only modda olup olmadığı da isReadOnly metodu ile elde edilebilir. QLineEdit nesnesi read-only moddayken klavye 
    ile edit alanına yazı giremeyiz. Ancak programlama yoluyla setText metodunu kullnarak edit alanına yazı girebiliriz.

    Aşağıdaki örnekte QLineEdit nesnesi read only moda sokulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.lineEdit = QLineEdit('0', self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setReadOnly(True)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
        
        self.count = 0
    
    def pushButtonClickedHandler(self):
        self.count += 1
        self.lineEdit.setText(str(self.count))
        
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                            24. Ders 25/05/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Edit alanı içerisine girilebilecek karakter sayısı QLineEdit sınıfının setMaxLength metodu ile sınırlandırılabilir. Örneğin:

    self.lineEdit.setMaxLength(10)

    Burada klavyeyle ya da setText metodu ile en fazla edit alanına 10 karakter girilebilir. Set edilen bu değer maxLength metoduyla 
    alınabilir. Pekiyi biz bu metodu hiç kullanmamışsak edit alanına girceğimiz maksimum karakter saysı ne olur? İşte bu durum Qt'nin
    versiyonundan versiyonuna değişebilmektedir. Güncel versiyonlarda bu default değer 32767'dir. 

    Aşağıdaki örnekte edit alanına girilecek karakter sayısı 10 ile sınırlandırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.lineEdit = QLineEdit(self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setMaxLength(10)
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
       ml = self.lineEdit.maxLength()
       QMessageBox.information(self, 'Message', str(ml))
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit GUI elemanı default durumda sınır çizgilerine sahiptir. Ancak biz setFrame metodunu False argümanı ile çağrırısak sınır 
    çizgilerini kaldırabiliriz. (Tabii True argümanı ile yeniden çağırırsak sınır çizgileri yenidne görünür hale gelecektir.). Sınıfın
    hasFrame metodu ise sınır çizgilerinin var olup olmadığı bilgisini bize vermektedir.

    Aşağıdaki örnekte sınır çizgileri olmayan bir edit alanı oluturulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.lineEdit = QLineEdit(self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
       text = self.lineEdit.text()
       QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit sınıfının setPlaceholderText isimli metodu edit alanı boşken gösterilecek ipucu yazısını belirtmektedir. Örneğin:

    self.lineEditName.setPlaceholderText('Adınızı soyadınızı giriniz')

    placeholderText metodu ise bu yazıyı get etmek için kullanılmaktadır.

    Tabii ipucu yazısı edit alanına giriş yapıldığında otomatik biçimde kaybolmaktadır. 

    Aşağıdaki örnekte böyle bir edit alanı oluşturulmuştur
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
           
        self.lineEdit = QLineEdit(self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
        self.lineEdit.setPlaceholderText('Adınızı ve soyadınız giriniz')
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
       text = self.lineEdit.text()
       QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit sınıfının setEchoMode metodu edit alanına yazı girilirken gösterilecek karakterleri belirlemekte kullanılır. Metodun 
    parametresi şu embolik sabitlerden biri olabilir:

    QLineEdit.EchoMode.Normal                    (Her yazılan görüntülenir)
    QLineEdit.EchoMode.NoEcho                    (Yazılanlar hiç görüntülenmez)
    QLineEdit.EchoMode.Password                  (Yazılanlar yerine * gibi bir sembol basılır)
    QLineEdit.EchoMode.PasswordEchoOnEdit        (Yazılanlar görüntülenir ama klavye odağı başka bir pencereye geçirildiğinde orası 
                                                 password girişi gibi görüntülenir)

    PyQt5'te yukarıdaki sembolik sabitler doğrudan QLineEdit sınıfı içerisindedir. Tabii Password modunda edit alanından Ctrl+C 
    ile clipboard'a kopyalama yapılamamaktadır. 

    Aşağıdaki örnekte bir parola girişi oluşturulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
        
        self.lineEdit = QLineEdit(self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
        self.lineEdit.setPlaceholderText('Parolanızı giriniz')
        self.lineEdit.setEchoMode(QLineEdit.EchoMode.Password)
                        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
       text = self.lineEdit.text()
       QMessageBox.information(self, 'Message', text)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Edit alanındaki her karakterin ilk karakter 0 olmak üzere bir index numarası vardır. Edit alanındaki yazının bir bölümünü programalama 
    yoluyla seçmek için setSelection metodu seçimin başlangıç indeks numarası ve uzunluğu ile çağrılır. Örneğin:

    self.lineEdit.setSelection(5, 10)

    Burada edit alanındaki yazıda 5'inci indeksten itibaren 10 karakter select edilecektir. Sınıfın selectionStart, selectionEnd ve 
    selectionLength isimli metotları select edilmiş olan bölge hakkında bilgileri bize vermektedir. selectedText metodu ise select 
    edilen yazıyı bize verir. 

    Biz fare ya da kalvye yoluyla edit alanındaki bir yazının belli bölümünü seçtiğimizde bu seçin "klavye odağı (keyboard focus)" 
    başka GUI elemana geçirildiğinde kaybolmaktadır. 

    Aşağıda selection için bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
        
        self.lineEdit = QLineEdit(self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
        self.lineEdit.setPlaceholderText('Parolanızı giriniz')
                                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
        self.lineEdit.setSelection(5, 5)
        selectionStart = self.lineEdit.selectionStart()
        selectionLength = self.lineEdit.selectionLength()
        selectionText = self.lineEdit.selectedText()
        QMessageBox.information(self, 'Selected text', str(selectionStart) + ' ' + str(selectionLength) + '\n' + selectionText)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()
 
#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit sınıfının isModified metodu edit alanı içerisindeki yazının güncellenip güncellenmediği bilgisini bize vermektedir. 
    Sınıfın setModified metodu False ile çağrılırsa sanki güncelleme yapılmamış gibi durum oluşturulur. Default durumda henüz edit 
    alanına yazı girilmediyse isModified metodu False değerini vermektedir. Programcı önce setModifed metodunu False ile çağırır. 
    Bir süre sonra edit alanında bir güncelleme olup olmadığını isModified metodu ile belirler. Text editörlerde "eğer editörde 
    değişiklik yapılmışsa çıkmadan önce dosyanın saklanıp saklanmayacağı sorusu" bu özellik kullanılarak sorulmaktadır. 

    Aşağıda metodun kullanımına bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
        
        self.lineEdit = QLineEdit('Ankara', self)
        self.lineEdit .setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
        self.lineEdit.setPlaceholderText('Parolanızı giriniz')
                                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
        result = self.lineEdit.isModified()
        QMessageBox.information(self, 'Message', 'Modified' if result else 'Not modified')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()


#------------------------------------------------------------------------------------------------------------------------------------
                                                    25. Ders 31/05/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QLineEdit GUI elemanının 7 farklı sinyali vardır. Bunlardan textChanged ve returnPressed isimli sinyaller sırasıyla edit alanındaki 
    yazı değiştiğinde ve edit alanı içerisinde ENTER tuşuna basıldığında emit edilmektedir. textChanged sinyali edit alanında tuşa 
    basıldıktan sonraki yazıyı veren (basılan tuş da dahil olmak üzere) bir parametreye sahiptir. returnPressed sinyalinin ise parametresi 
    yoktur. Sınıfın diğer sinyalleri çok seyrek kullanılmaktadır. Bunlar için Qt dokümanlarına başvurabilrsiniz. 

    Aşağıda QLineEdit sınıfının textChanged ve returnPressed sinyallerinin kullanımına örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')
        
        self.lineEdit = QLineEdit(self)
        self.lineEdit.setGeometry(50, 80, 250, 30)
        self.lineEdit.setFrame(False)
        self.lineEdit.textChanged.connect(self.lineEditTextChangedHandler)
        self.lineEdit.returnPressed.connect(self.lineEditreturnPressedHandler)
                                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(50, 130, 50, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
    
    def pushButtonClickedHandler(self):
        text = self.lineEdit.text()
        QMessageBox.information(self, 'Message', text)
        self.lineEdit.setText('')
        
    def lineEditTextChangedHandler(self, text):
        print(text)
        
    def lineEditreturnPressedHandler(self):
        QMessageBox.information(self, 'Message', 'ENTER key pressed')
        self.lineEdit.setText('')   
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grup elemanı listelemek için kullanılan GUI elemanına Qt'de "list widget" denilmektedir. Pek çok framework'te bu GUI eleman
    "listbox" biçiminde isimlendirilmektedir. List widget Qt'de QListWidget sınıfıyla temsil edilmiştir. Tpik kullanımda QListWidget 
    sınıfı türünden nesne yaratılır, nesne konumlandırılır sonra da elemanlar eklenir. QListWidget GUI elemanına eleman eklemek için 
    additem metodu kullanılabilir. Bu addItem metoduna biz argüman olarak bir yazı verebiliriz. Birden fazla elemanı eklemek için ise 
    addItems metodu kullanılmaktadır. addItems metodu içerisinde string'lerin bulunduğuğu dolaşılabilir bir nesneyi alıronları tek 
    tek list widget nesnesine ekler. QListWidget sınıfının insertItem isimli metodu belli bir indekse eleman insert etmektedir. 
    Örneğin:

    self.listWidget.insertItem(3, 'Kastamonu')

    Burada eleman 3'üncü indekste olacak biçimde insert edilmektedir. Bu metodun insetItems isimli çoklu insert yapan bir biçimi de 
    vardır. Örneğin:

    self.listWidget.insertItem(3, ['Adana', 'Ankara', Eskişehir'])

    Burada elemanlar üçüncü indeksten başlayacak biçimde araya insert edilmektedir. 

    Aşağıdaki örnekte bir liste widget nesnesine elemanlar eklenmiştir. Burada düğmenin henüz bir işlevi yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(250, 500)

        self.listWidgetNames = QListWidget(self)
        self.listWidgetNames.setGeometry(20, 20, 100, 200)
        self.listWidgetNames.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara'
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(130, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                  
    def pushButtonOkClickedHandler(self):
        pass
             
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii yine listwidget elemanları için font QListWidget sınıfının setFont metodu ile değiştirilebilir. Örneğin:

    self.listWidgetNames.setFont(QFont('Times New Roman', 12))

    Sınıfın QWidget sınıfından gelen setStyleSheet metodu ile de aynı şey yapılabilir. Örneğin:

    self.listWidgetNames.setStyleSheet('QListWidget {color: red; font-size: 14pt}')
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(250, 500)

        self.listWidgetNames = QListWidget(self)
        self.listWidgetNames.setGeometry(20, 20, 100, 200)
        self.listWidgetNames.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetNames.setStyleSheet('QListWidget {color: red; font-size: 14pt}')
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(130, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                  
    def pushButtonOkClickedHandler(self):
        pass
             
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında QListWidget nesnesi satırlarında yazıları tutmaz. QListWidgetItem nesnelerini tutar. Yani biz aslında QListWidgetItem
    nesnelerini yaratıp eklemeyi addItem ya da insertItem metotlarıyla da yapabiliriz. Bu sayede biz listwidget satırlarındaki 
    elemanları daha ayrıntılı biçimde oluşturabiliriz. Biz addItem, addItems, insertItem, insertItems metotlarına yazı versek de 
    bu metotlar zaten o yazılardan QListWİdgetItem nesnesi oluşturup eklemeyi yapmaktadır. Örneğin:

    self.listWidgetNames.addItem('Ali')

    Burada aslında addItem metodu bir QListWidgetItem nesnesi oluşturup onu QListWidget elemanının satırına ekler. 

    Yukarıda belirttiğimiz gibi QListWidgetItem sınıfı QListWidget nesnesindeki satırları temsil etmektedir. Bir satır yalnızca bir 
    yazıdan oluşmak zorunda değildir. Orada ikonik bir resim de bulundurulabilir. Ayrıca her satır diğerlerinden bağımsız olarak ayrı 
    bir biçimde renklendirilebilmektedir ve ayrı bir font ile görüntülenebilmektedir. Programcı QListWidgetItem sınıfı türünden bir 
    nesne yaratır. Nesneyi yaratırken satırda görüntülenecek yazıyı verebilir. Sonra sınıfın çeşitli set metotlarıyla nesnenin
    özelliklerini değiştirir. Yarattığı bu QListWidgetItem nesnesini yine addItem, addItems, insertItem  ya da insertItems metotlarıyla 
    QListWidget nesnesine ekleyebilir. 

    QListWidgetItem sınıfının öenmli metotları şunlardır:

    - foreground ve setForeground metotları satırın yazı rengini alıp değiştirmektedir.
    - background ve setBackground metotları satırın arka plan rengini alıp set etmektedir. 
    - font ve setFont metotları satırın arka plan font bilgisini alıp set etmektedir. 
    - icon, setIcon metotları satırdaki ikon görüntüsünü alp set edebilmektedir. Ikonlar QIcon sınıfıyla temsil edilmektedir. QIcon 
    nesnesi bir dosya isminden harekle ya da QPixmap nesnesinden hareketle oluşturulabilmektedir. 

    Örneğin:

    item = QListWidgetItem('Kastamonu')
    item.setForeground(QBrush(QColor.fromRgb(0, 0, 255)))
    item.setFont(QFont('Times New Roman', 16))
    item.setIcon(QIcon('exlamation-icon.png'))
                       
    self.listWidgetNames.addItem(item)

    Aşağıdaki örnekte Ok düğmesine basıldığında edit alanındaki yazıdan hareketle bir QListWidgetItem nesnesi yaratılıp QListWidget
    nesnesine eklenmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.lineEdit = QLineEdit(self)
        self.lineEdit.setGeometry(20, 20, 200, 25)
        
        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 80, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 80, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                  
    def pushButtonOkClickedHandler(self):
        text = self.lineEdit.text()
        if text.strip() == '':
            QMessageBox.warning(self, 'Warning', 'Line edit is empty!')
            return
        item = QListWidgetItem(text)
        item.setForeground(QBrush(QColor.fromRgb(0, 0, 255)))
        item.setFont(QFont('Times New Roman', 16))
        item.setIcon(QIcon('heart-icon.png'))
        self.listWidgetCities.addItem(item)
                    
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget penceresinin içerisindeki elemanların (satırların) sayısı sınıfın count isimli metodu ile elde edilebilir. Ayrıca 
    QListWidget sınıfının item isimli metodu bize ilgili indeksteki elemanı (satırı) QListWidgetItem nesnesi olarak vermektedir. 
    Örneğin:

    lwi = self.listWidgetCities.item(3)
    text = lwi.text()

    Burada QListWidget nesnesinin üçüncü satırındaki eleman QListWidgetItem nesnesi biçiminde elde edilmiştir. 

    Aşağıdaki örnekte Ok düğmesine basıldığında QListWidget nesnesi içerisindeki bütün elemanlar dolaşılıp bunlar bir diyalog
    penceresi ile görüntülenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 20, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')
                
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
                  
    def pushButtonOkClickedHandler(self):
        s = ''
        for i in range(self.listWidgetCities.count())        :
            text = self.listWidgetCities.item(i).text()
            if i != 0:
                s += '\n'
            s += text
        QMessageBox.information(self, "Cities", s)      
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget penceresinde seçili olan elemanın (satırın) indeks numarası currentRow metodu ile elde edilebilir. Eğer henüz hiçbir 
    satır seçili değilse bu metot -1 değerini vermektedir. Benzer biçimde o anda seçili olan elemanın (satırın) bilgisi de currentItem 
    metodu ile elde edilebilir. currentItem metodu bize QListWidgetItem nesnesi vermektedir. (Ancak Qt'de eğer QListWidget nesnesi 
    ana pencerenin ilk GUI elemanıysa klavye odağı oraya verildiği için sanki ilk eleman seçilmiş gibi bir etki oluşmaktadır.)

    Aşağıdaki örnekte Ok düğmesine basıldığında seçili olan elemanın yazısı messagebox ile yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 20, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')
                   
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
                  
    def pushButtonOkClickedHandler(self):
        row = self.listWidgetCities.currentRow()
        if row == -1:
            QMessageBox.warning(self, 'Message', 'No rwo selected')
            return
        text = self.listWidgetCities.item(row).text()
        QMessageBox.information(self, 'Selected City', text)
        
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget sınıfının currentItem metodu seçili olan satıra ilişkin QListWidgetItem nesnesini vermektedir. Eğer hiçbir satır 
    seçili değilse bu metot None değerini verir. (Ancak Qt'de eğer QListWidget nesnesi  ana pencerenin ilk GUI elemanıysa klavye odağı 
    oraya verildiği için sanki ilk eleman seçilmiş gibi bir etki oluşmaktadır.)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 20, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')
                   
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        lwi = self.listWidgetCities.currentItem()
        if lwi == None:
            QMessageBox.warning(self, 'Message', 'No rwo selected')
            return
        text = lwi.text()
        QMessageBox.information(self, 'Selected City', text)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Programlama yoluyla belli bir elemanı (satırı) seçili duruma getirmek için setCurrentRow metodu ya da setCurrentItem metodu 
    kullanılmaktadır. setCurrentRow metodu seçilecek elemanın satır indeksini alır. setCurrentItem metodu ise seçilecek elemanın 
    QListWidgetItem nesnesini almaktadır. Genellikle bu amaçla setCurrentRow metodu kullanılmaktadır. setCurrentRow metodu -1 
    değeriyle setCurrentItem metodu ise None değeriyle çağrılırsa nesnede eleman seçili durumda olmaktan çıkar.

    Aşağıdaki örnekte işin başında "İstanbul" satırı seçili olacak biçimde QListWidget nesnesi görüntülenmektedir. Ok d
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 20, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')
        self.listWidgetCities.setCurrentRow(5)
                   
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
       self.listWidgetCities.setCurrentRow(-1)
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Default durumda QListWidget penceresinde yalnızca tek eleman seçilebilir. Ancak seçim modu sınıfın QAbstractViewItem sınıfından 
    gelen setSelectionMode metoduyla değiştirilebilmektedir. Bu metot QListWidget sınıfındaki aşağıdaki sembolik sabitlerden bir tanesini 
    parametre olarak almaktadır:

    QAbstractItemView.SelectionMode.SingleSelection           Bu modda tek eleman seçilebilir (default)
    QAbstractItemView.SelectionMode.ContiguousSelection       Bu modda ayrık seçim yapılamaz ancak ardışık seçim yapılabilir
    QAbstractItemView.SelectionMode.ExtendedSelection         Bu modda hem ardışık hem de ayrık seçimler yapılabilmektedir
    QAbstractItemView.SelectionMode.MultiSelection            Bu modda yalnızca ayrık seçim yapılabilmektedir
    QAbstractItemView.SelectionMode.NoSelection               Bu modda seçim hiç yapılamaz, yalnızca elemanlar görüntülenir

    Bu sembolik sabitler PyQt5'te doğrudan QAbstractItemView sınıfında bulunmaktadır. En çok kullanılan çoklu seçim modu ExtendedSelection
    modudur.

    Birden fazla seçim yapıldığında currentRow ya da currentItem metotları son seçilmiş olanı bize vermektedir. Tüm seçilen elemanları 
    almak için selectedItems metodu kullanılmaktadır. Bu metot bize QListWidgetItem nesnelerinden oluşan bir liste vermektedir. Eğer 
    hiçbir eleman seçilmemişse bu metot boş bir liste veir.

    Aşağıdaki örnekte QListWidget nesnesi çoklu seçim (ExtendedSelection) moduna sokulmuştur. Seçilen elemanlar selectedItems metodu 
    ile elde edilip messagebox ile yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(350, 500)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 20, 150, 200)
        self.listWidgetCities.addItems(['Adana', 'İzmir', 'Kayseri', 'Bilecik', 'Eskişehir', 'Bolu', 'Ankara',
                                       'Sivas', 'Yozgat', 'Samsun', 'Trabzon', 'Mersin', 'Malatya', 'Hatay'])
        self.listWidgetCities.setStyleSheet('QListWidget {font-size: 12pt}')   
        self.listWidgetCities.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
                   
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(200, 20, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
       items = self.listWidgetCities.selectedItems()    
       s = ''
       for item in items:
           s += item.text() + '\n'
       QMessageBox.information(self, 'Selected Items', s)
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                    26. Ders 1/06/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget sınıfının birkaç önemli sinyali vardır. currentRowChanged isimli sinyal o anda seçili olan eleman değiştirildiğinde 
    emit edilmektedir. Bu sinyalin int bir parametresi vardır. Bu parametre yeni seçilen satırın indeks numarasını bize verir. 
    currentItemChanged isimli sinyal de yine aktif eleman değiştirildiğinde emit edilir. Ancak bu sinyalin iki parametresi vardır. 
    Birinci parametresi yeni aktif hale gelen elemanı, ikinci parametresi aktifliğini kaybeden eski elemanı belirtir. Her iki parametre
    de QListWidgetItem nesnelerini belirtmektedir. 

    Aşağıdaki örnekte iki tane QListWidget nesnesi oluşturulmuştur. Soldaki nesne şehirleri sağdaki nesne ise onun ilçelerini 
    göstermektedir. Ne zaman soldaki QListWidget penceresinde bir şehir seçilse onun ilçeleri yandaki QListWidget penceresinde 
    görüntülenmektedir. QListWidget nesnesinin içindeki tüm elemanları silmek için clear metodu kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(400, 500)
        self.setStyleSheet('QWidget {font-size: 12pt}')   

        self.labelCities = QLabel('Şehirler', self)
        self.labelCities.move(20, 10)
        
        self.labelCities = QLabel('İlçeler', self)
        self.labelCities.move(200, 10)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 35, 150, 250)
        self.listWidgetCities.currentItemChanged.connect(self.listWidgetCitiesCurrentItemChangedHandler)
        
        self.listWidgetVilliges = QListWidget(self)
        self.listWidgetVilliges.setGeometry(200, 35, 150, 250)
        
        self.cities = {
            'İstanbul': ['Şişli', 'Adalar', 'Beşiktaş', 'Pendik', 'Gaziosmanpaşa', 'Kadıköy', 'Ataşehir'],
            'Eskişehir': ['Mihalıççık', 'Sivrihisar', 'Seyitgazi', 'Alpu', 'Çifteler', 'Mahmudiye'],
            'Adana': ['Seyhan', 'Çukurova', 'Ceyhan', 'Karataş', 'Yumurtalık', 'Pozantı', 'Sarıçam'],
            'Antalya': ['Finike', 'Kaş', 'Kemer', 'Side', 'Alanya', 'Elmalı', 'Serik', 'Korkuteli'],
            'Bursa': ['Osmangazi', 'Nilüfer', 'İnegöl', 'Karacabey', 'İznik', 'Orhangazi', 'Mudanya'],
            'Çanakkale': ['Ayvacık', 'Bayramiç', 'Biga', 'Bozcaada', 'Çan', 'Eceabat', 'Ezine', 'Gelibolu'], 
            'Edirne': ['Merkez', 'Enez', 'Havsa', 'İpsala', 'Keşan', 'Lalapaşa', 'Meriç', 'Süloğlu', 'Uzunköprü'],
            'Aydın': ['Bozdoğan', 'Çine', 'Didim', 'Germencik', 'İncirliova', 'Karpuzlu', 'Koçarlı', 'Köşk', 'Nazilli'],
            'Artvin': ['Merkez', 'Ardanuç', 'Arhavi', 'Borçka', 'Hopa', 'Murgul', 'Şavşat', 'Yusufeli'],
            'Isparta': ['Merkez', 'Aksu', 'Atabey', 'Eğirdir', 'Gelendost', 'Gönen'],
            'Manisa': ['Akhisar', 'Alaşehir', 'Demirci', 'Gördes', 'Kırkağaç', 'Köprübaşı', 'Salihli' ],
            'Mardin': ['Merkez', 'Dargeçit', 'Derik', 'Kızıltepe', 'Mazıdağı', 'Midyat', 'Nusaybin']
        }
        
        self.listWidgetCities.addItems(self.cities)
        self.listWidgetCities.setCurrentRow(0)
        
    def listWidgetCitiesCurrentItemChangedHandler(self, currentItem, prevItem):
        city = currentItem.text()
        villages = self.cities[city]
        self.listWidgetVilliges.clear()
        self.listWidgetVilliges.addItems(villages)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget penceresindeki bir satıra çift tıklandığında itemDoubleClicked isimli sinyal oluşturulmaktadır. Bu sinyalin tek bir 
    parametresi vardır. O da çift tıklanan elemana ilişkin QListWidgetItem nesnesidir. 

    Aşağıdaki örnekte ilgili ilçeye çift tıklandığında bu ilçe için messagebox ile bir şirinlik yazısı yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(400, 500)
        self.setStyleSheet('QWidget {font-size: 12pt}')   

        self.labelCities = QLabel('Şehirler', self)
        self.labelCities.move(20, 10)
        
        self.labelCities = QLabel('İlçeler', self)
        self.labelCities.move(200, 10)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 35, 150, 250)
        self.listWidgetCities.currentItemChanged.connect(self.listWidgetCitiesCurrentItemChangedHandler)       
        
        self.listWidgetVilliges = QListWidget(self)
        self.listWidgetVilliges.setGeometry(200, 35, 150, 250)
        self.listWidgetVilliges.itemDoubleClicked.connect(self.listWidgetVilligesItemDoubleClickedHandler)
        
        self.cities = {
            'İstanbul': ['Şişli', 'Adalar', 'Beşiktaş', 'Pendik', 'Gaziosmanpaşa', 'Kadıköy', 'Ataşehir'],
            'Eskişehir': ['Mihalıççık', 'Sivrihisar', 'Seyitgazi', 'Alpu', 'Çifteler', 'Mahmudiye'],
            'Adana': ['Seyhan', 'Çukurova', 'Ceyhan', 'Karataş', 'Yumurtalık', 'Pozantı', 'Sarıçam'],
            'Antalya': ['Finike', 'Kaş', 'Kemer', 'Side', 'Alanya', 'Elmalı', 'Serik', 'Korkuteli'],
            'Bursa': ['Osmangazi', 'Nilüfer', 'İnegöl', 'Karacabey', 'İznik', 'Orhangazi', 'Mudanya'],
            'Çanakkale': ['Ayvacık', 'Bayramiç', 'Biga', 'Bozcaada', 'Çan', 'Eceabat', 'Ezine', 'Gelibolu'], 
            'Edirne': ['Merkez', 'Enez', 'Havsa', 'İpsala', 'Keşan', 'Lalapaşa', 'Meriç', 'Süloğlu', 'Uzunköprü'],
            'Aydın': ['Bozdoğan', 'Çine', 'Didim', 'Germencik', 'İncirliova', 'Karpuzlu', 'Koçarlı', 'Köşk', 'Nazilli'],
            'Artvin': ['Merkez', 'Ardanuç', 'Arhavi', 'Borçka', 'Hopa', 'Murgul', 'Şavşat', 'Yusufeli'],
            'Isparta': ['Merkez', 'Aksu', 'Atabey', 'Eğirdir', 'Gelendost', 'Gönen'],
            'Manisa': ['Akhisar', 'Alaşehir', 'Demirci', 'Gördes', 'Kırkağaç', 'Köprübaşı', 'Salihli' ],
            'Mardin': ['Merkez', 'Dargeçit', 'Derik', 'Kızıltepe', 'Mazıdağı', 'Midyat', 'Nusaybin']
        }
        
        self.listWidgetCities.addItems(self.cities)
        self.listWidgetCities.setCurrentRow(0)
        
    def listWidgetCitiesCurrentItemChangedHandler(self, currentItem, prevItem):
        city = currentItem.text()
        villages = self.cities[city]
        self.listWidgetVilliges.clear()
        self.listWidgetVilliges.addItems(villages)
    
    def listWidgetVilligesItemDoubleClickedHandler(self, currentItem):
        cityName = self.listWidgetCities.currentItem().text()
        villageName = currentItem.text()
        QMessageBox.information(self, 'Bilgi', f'{villageName} {cityName} şehrinin şirin bir ilçesidir')
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QListWidget nesnesinden belli bir satırı silmek için sınıfın takeItem metodu kullanılmaktadır. Bu metot silimnecek satırın indeks
    numarasını alır. 
    
    Aşağıdaki örnekte bir ilçe üzerinde çift tıklandığında o ilçe hem QListWidget nesnesinden hem de ilgili sözlükten silinmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(400, 500)
        self.setStyleSheet('QWidget {font-size: 12pt}')   

        self.labelCities = QLabel('Şehirler', self)
        self.labelCities.move(20, 10)
        
        self.labelCities = QLabel('İlçeler', self)
        self.labelCities.move(200, 10)

        self.listWidgetCities = QListWidget(self)
        self.listWidgetCities.setGeometry(20, 35, 150, 250)
        self.listWidgetCities.currentItemChanged.connect(self.listWidgetCitiesCurrentItemChangedHandler)       
        
        self.listWidgetVilliges = QListWidget(self)
        self.listWidgetVilliges.setGeometry(200, 35, 150, 250)
        self.listWidgetVilliges.itemDoubleClicked.connect(self.listWidgetVilligesItemDoubleClickedHandler)
        
        self.cities = {
            'İstanbul': ['Şişli', 'Adalar', 'Beşiktaş', 'Pendik', 'Gaziosmanpaşa', 'Kadıköy', 'Ataşehir'],
            'Eskişehir': ['Mihalıççık', 'Sivrihisar', 'Seyitgazi', 'Alpu', 'Çifteler', 'Mahmudiye'],
            'Adana': ['Seyhan', 'Çukurova', 'Ceyhan', 'Karataş', 'Yumurtalık', 'Pozantı', 'Sarıçam'],
            'Antalya': ['Finike', 'Kaş', 'Kemer', 'Side', 'Alanya', 'Elmalı', 'Serik', 'Korkuteli'],
            'Bursa': ['Osmangazi', 'Nilüfer', 'İnegöl', 'Karacabey', 'İznik', 'Orhangazi', 'Mudanya'],
            'Çanakkale': ['Ayvacık', 'Bayramiç', 'Biga', 'Bozcaada', 'Çan', 'Eceabat', 'Ezine', 'Gelibolu'], 
            'Edirne': ['Merkez', 'Enez', 'Havsa', 'İpsala', 'Keşan', 'Lalapaşa', 'Meriç', 'Süloğlu', 'Uzunköprü'],
            'Aydın': ['Bozdoğan', 'Çine', 'Didim', 'Germencik', 'İncirliova', 'Karpuzlu', 'Koçarlı', 'Köşk', 'Nazilli'],
            'Artvin': ['Merkez', 'Ardanuç', 'Arhavi', 'Borçka', 'Hopa', 'Murgul', 'Şavşat', 'Yusufeli'],
            'Isparta': ['Merkez', 'Aksu', 'Atabey', 'Eğirdir', 'Gelendost', 'Gönen'],
            'Manisa': ['Akhisar', 'Alaşehir', 'Demirci', 'Gördes', 'Kırkağaç', 'Köprübaşı', 'Salihli' ],
            'Mardin': ['Merkez', 'Dargeçit', 'Derik', 'Kızıltepe', 'Mazıdağı', 'Midyat', 'Nusaybin']
        }
        
        self.listWidgetCities.addItems(self.cities)
        self.listWidgetCities.setCurrentRow(0)
        
    def listWidgetCitiesCurrentItemChangedHandler(self, currentItem, prevItem):
        city = currentItem.text()
        villages = self.cities[city]
        self.listWidgetVilliges.clear()
        self.listWidgetVilliges.addItems(villages)
    
    def listWidgetVilligesItemDoubleClickedHandler(self, currentItem):
        city = self.listWidgetCities.currentItem().text()
        villages = self.cities[city]
        villages.remove(currentItem.text())
        self.listWidgetVilliges.takeItem(self.listWidgetVilliges.currentRow())
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de çok satırlı edit penceresi QTextEdit sınıfıyla temsil edilmiştir. Pencere yine diğer alt pencerelerde olduğu gibi yaratılır:

    self.textEdit = QTextEdit(self)

    QTextEdit içerisindeki yazı sınıfın toPlainText metodu ile elde edilebilir. Aslında bu poenceresinin içerisindeki yazı HTML ve 
    Markdown olarak da elde edilebilir. Bunun için sınıfın toMarkdown ve toHtml metotları kullanılmaktadır. 
    
    Aşağıdaki örnekte Ok düğmesine basıldığında çok satırlı edit alanının içerisindeki yazı alınıp messagebox içerisinde yazıdırlmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(400, 500)
    
        self.setStyleSheet('QWidget {font-size: 12pt}')   
        self.setMaximumSize(self.size())
        self.setMinimumSize(self.size())
                
        self.textEdit = QTextEdit(self)
        self.textEdit.setGeometry(20, 20, 360, 400)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(150, 430, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
       text = self.textEdit.toPlainText()
       QMessageBox.information(self, 'Text', text)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Yine yazının rengi sınıfın setTextColor metodu, pencerenin tüm zemin rengi ise "style sheet" yoluyla değiştirilebilmektedir. 
    (Tabii yazının rengi de style sheey yoluyla değiştirilebilmektedir.) Örneğin:

    self.textEdit = QTextEdit(self)
    self.textEdit.setGeometry(20, 20, 340, 400)
    self.textEdit.setStyleSheet('QTextEdit {color: blue; background-color: yellow}')

    Aşağıdaki örnekte edit alanı içerisindeki yazı kırmızı biçimde, edit alanının zemini ise sarı biçimde görüntülenmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(400, 500)
    
        self.setStyleSheet('QWidget {font-size: 12pt}')   
        self.setMaximumSize(self.size())
        self.setMinimumSize(self.size())
                
        self.textEdit = QTextEdit(self)
        self.textEdit.setGeometry(20, 20, 360, 400)
        self.textEdit.setStyleSheet('QTextEdit {color: #000000; background-color: #fdf6e3}')
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(150, 430, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
       text = self.textEdit.toPlainText()
       QMessageBox.information(self, 'Text', text)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Edit alanının içerisindeki yazı setPlainText metodu ile set edilebilir. 

    Aşağıdaki örnekte Ok tuşuna basıldığında QLineEdit içerisindeki yol ifadesine ilişkin dosya açılmış ve onun içerisindekiler 
    çok satırlı edit alanının içerisine setPlainTExt metoduyla yerleştirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(400, 500)
    
        self.setStyleSheet('QWidget {font-size: 12pt}')   
        self.setMaximumSize(self.size())
        self.setMinimumSize(self.size())
            
        self.labelPath = QLabel('Path:', self)
        self.labelPath.move(20, 10)
        
        self.lineEdit = QLineEdit(self)
        self.lineEdit.setGeometry(20, 35, 360, 30)
        self.lineEdit.returnPressed.connect(self.pushButtonOkClickedHandler)
            
        self.textEdit = QTextEdit(self)
        self.textEdit.setGeometry(20, 80, 360, 340)
        self.textEdit.setStyleSheet('QTextEdit {color: #000000; background-color: #fdf6e3}')
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(150, 430, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        try:
           with open(self.lineEdit.text()) as f:
               text = f.read()
               self.textEdit.setPlainText(text)
               self.lineEdit.setText('')
        except:
            QMessageBox.warning(self, 'Error', 'File not found or cannot open')

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Pencere default durumda "sarma (wrapping)" yapmaktadır. Wrapping'i kaldırmak için setLineWrapMode isimli metot 
    QLineEdit.LineWrapMode.NoWrap arümanıyla çağrılmalıdır. Satır tabanlı sarmalama için aynı metot QLineEdit.LineWrapMode.WidgetWidth 
    argümanıyla çağrılabilir. Bu sembolik sabitler PyQt5'te doğrudan QLineEdit sınıfının içerisindedir. Biz pencerenin wrapping modunu 
    lineWrapMode metoduyla elde edebiliriz.

    Aşağıdaki programda bir QTextEdit penceresi, bir düğme ve bir checkbox vardır. Bu checkbox çarpılandığında QTextEdit penceresi 
    sarma yapmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(400, 500)
    
        self.setStyleSheet('QWidget {font-size: 12pt}')   
        self.setMaximumSize(self.size())
        self.setMinimumSize(self.size())
                   
        self.textEdit = QTextEdit(self)
        self.textEdit.setGeometry(20, 20, 360, 380)
        self.textEdit.setStyleSheet('QTextEdit {color: #000000; background-color: #fdf6e3}')
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(150, 410, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
        self.checkBoxWrap = QCheckBox('Word Wrap', self)
        self.checkBoxWrap.move(270, 420)
        self.checkBoxWrap.setChecked(True)
        self.checkBoxWrap.toggled.connect(self.checkBoxWrapToggledHandler)
        
    def pushButtonOkClickedHandler(self):
        text = self.textEdit.toPlainText()
        QMessageBox.information(self, 'Message', text)
    
    def checkBoxWrapToggledHandler(self, checked):
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Çok kullanılan bir GUI eleman da "combobox" denilen elemandır. Qt'de combobox QComboBox sınıfı ile temsil edilmiştir. Combobox 
    aslında edit alanı ile listbox'ın birleşimi gibi düşünülebilir. Pencere tıklandığında açıldığı için form üzerinde daha az yer 
    kaplamaktadır. Bu nedenle programcılar çoğu kez seçim amacıyla listbox yerine combobox tercih ederler. 

    QComboBox nesnesi benzer biçimde yaratılır. Yaratılırken bir yazı verilmez. Örneğin:

    self.comboBox = QComboBox(self)

    Pencerenin geometrisi yalnızca kapalı kısmı ile belirlenmektedir. Elemanlar yine addItem, addItems, insertItem ve insertItems
    metotlarıyla eklenir. Ancak QCombox elemanları gerçekten yazılardan oluşmaktadır. Yani satırlar QListBox'taki gibi başka bir 
    sınıfla temsil edilmemektedir. Örneğin:

    self.comboBoxCities = QComboBox(self)
    self.comboBoxCities.setGeometry(20, 20, 200, 30)
    self.comboBoxCities.addItems(['Adana', 'İzmir', 'Bursa', 'Eskişehir', 'Antalya', 
                                'Kayseri', 'Ağrı', 'Manisa', 'Kahraman Maraş'])
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')   
                   
        self.comboBoxCities = QComboBox(self)
        self.comboBoxCities.setGeometry(20, 20, 200, 30)
        self.comboBoxCities.addItems(['Adana', 'İzmir', 'Bursa', 'Eskişehir', 'Antalya', 
                                      'Kayseri', 'Ağrı', 'Manisa', 'Kahraman Maraş'])
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(250, 20, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        pass
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
   QComboBox penceresinde seçili olan yazı sınıfın currentText metodu ile elde edilebilir. 

   Aşağıdaki örnekte Ok düğmesine basıldığında combox'ta seçili olan yazı messagebox ile yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')   
                   
        self.comboBoxCities = QComboBox(self)
        self.comboBoxCities.setGeometry(20, 20, 200, 30)
        self.comboBoxCities.addItems(['Adana', 'İzmir', 'Bursa', 'Eskişehir', 'Antalya', 
                                      'Kayseri', 'Ağrı', 'Manisa', 'Kahraman Maraş'])
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(250, 20, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        text = self.comboBoxCities.currentText()
        QMessageBox.information(self, 'Message', text)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QComboBox nesnesinde seçilmiş olan elemanın index numarası currentIndex metodu ile elde edilmektedir. Eğer combobox'ta herhangi 
    bir eleman seçili değilse bu metot -1 değerini vermektedir. Seçili elemanı programlama yoluyla değiştirebilmek için setCurrentIndex 
    metodu kullanılmaktadır. İndeksi bilinen comBox elemanının yazısı itemText metodu ile indeks verilerek elde edilebilmektedir. 

    Aşağıdaki örnekte önce seçili olan elemanın indeksi sonra da elemanın yazısı elde edilmiştir. (Tabii elemanın yazısı aslında 
    doğrudna sınıfın currentText metoduyla da elde edilebilmektedir.)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')   
                   
        self.comboBoxCities = QComboBox(self)
        self.comboBoxCities.setGeometry(20, 20, 200, 30)
        self.comboBoxCities.addItems(['Adana', 'İzmir', 'Bursa', 'Eskişehir', 'Antalya', 
                                      'Kayseri', 'Ağrı', 'Manisa', 'Kahraman Maraş'])
        self.comboBoxCities.setCurrentIndex(4)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(250, 20, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        index = self.comboBoxCities.currentIndex()
        text = self.comboBoxCities.itemText(index)
        QMessageBox.information(self, 'M3ssage', text)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Combobox GUI elemanının edit alanındaki yazı değiştirilebilir duruma getirilebilir. Bunun için sınıfın setEditable metodu True 
    değeri ile çağrılmalıdır. Bu yazıyı programlama yoluyla değiştirmek için ise setCurrentText metodu kullanılmaktadır. Edit alanındaki 
    yazının değiştirilmesi seçili elemanı etkilememektedir. currentIndex her zaman bize seçili elemanın indeksini verir. 

    Aşağıdaki örnekte combobox penceresi editable hale getirilmiştir. Ok düğmesine basılınca edit alanındaki yazı programlama yokuyla 
    değiştirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('My Notepad')
        self.resize(800, 600)
        self.setStyleSheet('QWidget {font-size: 12pt}')   
                   
        self.comboBoxCities = QComboBox(self)
        self.comboBoxCities.setGeometry(20, 20, 200, 30)
        self.comboBoxCities.addItems(['Adana', 'İzmir', 'Bursa', 'Eskişehir', 'Antalya', 
                                      'Kayseri', 'Ağrı', 'Manisa', 'Kahraman Maraş'])
        self.comboBoxCities.setCurrentIndex(4)
        self.comboBoxCities.setEditable(True)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(250, 20, 100, 50)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
    def pushButtonOkClickedHandler(self):
        index = self.comboBoxCities.currentIndex()
        QMessageBox.information(self, 'M3ssage', str(index))
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QComboBox sınıfının en önemli iki sinyali currentIndexChanged ve currentTextChanged sinyalleridir. currentIndexChanged yeni bir 
    eleman seçildiğinde emit edilmektedir. Bu sinyalin parametresi yeni seçilmiş olan satırın index numarasıdır. currentTextChanged 
    sinyali combobox penceresinin içerisindeki yazı her değiştiğinde mit edilmektedir. Tabii eğer combox'ın edit alanı edit edilebilir
    değilse bu sinyalin currentIndexChanged sinyalinden önemli bir farkı kalmamaktadır.

    Aşağıdaki örnekte combobox'tan bir şehir seçildiğinde onun ilçeleri yandaki listbox'a yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(400, 500)
        self.setStyleSheet('QWidget {font-size: 12pt}')   

        self.labelCities = QLabel('Şehirler', self)
        self.labelCities.move(20, 10)
        
        self.labelCities = QLabel('İlçeler', self)
        self.labelCities.move(200, 10)

        self.comboBoxtCities = QComboBox(self)
        self.comboBoxtCities.setGeometry(20, 35, 150, 30)
        self.comboBoxtCities.currentIndexChanged.connect(self.comboBoxtCitiesCurrentIndexChanged)       
        self.comboBoxtCities.currentTextChanged.connect(self.comboBoxtCitiesCurrentTextChanged)       
        
        self.listWidgetVilliges = QListWidget(self)
        self.listWidgetVilliges.setGeometry(200, 35, 150, 250)
        self.listWidgetVilliges.itemDoubleClicked.connect(self.listWidgetVilligesItemDoubleClickedHandler)
                
        self.cities = {
            'İstanbul': ['Şişli', 'Adalar', 'Beşiktaş', 'Pendik', 'Gaziosmanpaşa', 'Kadıköy', 'Ataşehir'],
            'Eskişehir': ['Mihalıççık', 'Sivrihisar', 'Seyitgazi', 'Alpu', 'Çifteler', 'Mahmudiye'],
            'Adana': ['Seyhan', 'Çukurova', 'Ceyhan', 'Karataş', 'Yumurtalık', 'Pozantı', 'Sarıçam'],
            'Antalya': ['Finike', 'Kaş', 'Kemer', 'Side', 'Alanya', 'Elmalı', 'Serik', 'Korkuteli'],
            'Bursa': ['Osmangazi', 'Nilüfer', 'İnegöl', 'Karacabey', 'İznik', 'Orhangazi', 'Mudanya'],
            'Çanakkale': ['Ayvacık', 'Bayramiç', 'Biga', 'Bozcaada', 'Çan', 'Eceabat', 'Ezine', 'Gelibolu'], 
            'Edirne': ['Merkez', 'Enez', 'Havsa', 'İpsala', 'Keşan', 'Lalapaşa', 'Meriç', 'Süloğlu', 'Uzunköprü'],
            'Aydın': ['Bozdoğan', 'Çine', 'Didim', 'Germencik', 'İncirliova', 'Karpuzlu', 'Koçarlı', 'Köşk', 'Nazilli'],
            'Artvin': ['Merkez', 'Ardanuç', 'Arhavi', 'Borçka', 'Hopa', 'Murgul', 'Şavşat', 'Yusufeli'],
            'Isparta': ['Merkez', 'Aksu', 'Atabey', 'Eğirdir', 'Gelendost', 'Gönen'],
            'Manisa': ['Akhisar', 'Alaşehir', 'Demirci', 'Gördes', 'Kırkağaç', 'Köprübaşı', 'Salihli' ],
            'Mardin': ['Merkez', 'Dargeçit', 'Derik', 'Kızıltepe', 'Mazıdağı', 'Midyat', 'Nusaybin']
        }
        
        self.comboBoxtCities.setEditable(True)
        self.comboBoxtCities.addItems(self.cities)
        self.comboBoxtCities.setCurrentIndex(0)
        
    def comboBoxtCitiesCurrentIndexChanged(self, index):
        city = self.comboBoxtCities.itemText(index)
        self.listWidgetVilliges.clear()
        self.listWidgetVilliges.addItems(self.cities[city])
        
    def listWidgetVilligesItemDoubleClickedHandler(self, currentItem):
        city = self.comboBoxtCities.currentText()
        village = currentItem.text()
        QMessageBox.information(self, 'MEssage', f'{village} {city} şehrinin şirin bir ilçesidir')
        
    def comboBoxtCitiesCurrentTextChanged(self, text):
        print(text)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü sistemi bir "menü çubuğuğundan (menu bar)", menü çubuklarına iliştirilmiş "popup pencerelerden (popup windows)", popup 
    pencerelere iliştirilmiş olan menü elemanlarından (menu items) oluşmaktadır. Qt'de menü çubuğu QMenuBar sınıfı ile, popup pencereler 
    QMenu sınıfı ile ve menü elemanları da QAction sınıfı ile temsil edilmiştir. 

    Qt'de menülü uygulamalar için programın ana penceresinin QWidget sınıfı ile değil QMainWindow sınıfı ile oluşturulması daha uygun 
    olmaktadır. QMainWindow sınıfı QWidget sınıfından türetilmiş durumdadır. Dolayısıyla menü uygulamaları için bizim kendi ana pencere 
    sınıfımızı QWidget sınıfından değil QMainWindow sınıfından türetmemiz daha uygundur. Örneğin:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()

    QMainWindow sınıfında zaten hazır bir biçimde yaratılmış olan bir menü çubuğu nesnesi vardır. Bu menu çubuğu nesnesi QMainWindow 
    sınıfının menuBar metoduyla elde edilebilmektedir. Örneğin:

    menuBar = self.menuBar()

    Tabii biz istersek yine QWidget sınıfınında türetme yapıp QMenuBar nesnesini kendimiz de yaratabiliriz. Örneğin:
    
    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()  
            self.setWindowTitle("Menu Sample")
            self.resize(640, 480)
            
            self.menuBar = QMenuBar(self)
            
    Ancak biz menülü uygulamalarda ana pencere sınıfımızı QWidget sınıfından değil QMainWindow sınıfınından türeteceğiz ve zaten QMainWindow
    sınıfında bulunan QMenuBar nesnesini kullanacağız. Örneğin:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle("Menu Sample")
            self.resize(640, 480)
            menuBar = self.menuBar()
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü çubuğu oluşturulduktan sonra ya da QManinWindow sınıfında zaten var olan menü çubuğu elde edildikten sonra artık sıra bu 
    çubuğa popup pencerelerin eklenmesine gelmiştir. Qt'de popup menü pencereleri QMenu sınıfıyla temsil edilmektedir. Bir popup pencereyi 
    oluşturabilmek için önce QMenu sınıfından bir nesne yaratılır. Nesne yaratılırken popup pencerede görünecek başlık yazısı belirtilir. 
    Sonra QMenu nesnesi QMenuBar sınıfının addMenu metoduyla menü çubuğuna eklenir. Örneğin:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.resize(800, 600)
                        
            menuBar = self.menuBar()
            self.filePopup = QMenu('File')
            self.editPopup = QMenu('Edit')
            self.helpPopup = QMenu('Help')
            
            menuBar.addMenu(self.filePopup)
            menuBar.addMenu(self.editPopup)
            menuBar.addMenu(self.helpPopup)

    Aslında alternatif olarak biz QMenuBar sınıfının addMenu metoduna QMenu nesnesi yerine bir yazı verirsek zaten addMenu bizim 
    için QMenu nesnesini yaratıp yarattığı nesneyi de bize vermektedir. Örneğin yukarıdaki işlemin eşdeğeri şöyle de oluşturulabilirdi:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.resize(800, 600)
                        
            menuBar = self.menuBar()
            self.filePopup = menuBar.addMenu('File')
            self.editPopup = menuBar.addMenu('Edit')
            self.helpPopup = menuBar.addMenu('Help')       

    Artık bu örnekte elimizde bir menü çubuğu ve popup pencereler vardır. Artık popup pencerelere menü elemanlarını ekleyebiliriz.
    Menü elemanları QAction sınıfıyla temsil edilmektedir. O halde bizim bir QAction nesnesi yaratıp bu nesneyi QMenu sınıfının 
    addAction metodu ile popup pencereye eklememiz gerekir. QAction nesnesi yaratılırken menü elemanına bir isim de verilmektedir. 
    Örneğin:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.resize(800, 600)
                        
            menuBar = self.menuBar()
            self.filePopup = QMenu('File')
            self.editPopup = QMenu('Edit')
            self.helpPopup = QMenu('Help')
            
            self.openAction = QAction('Open')
            self.closeAction = QAction('Close')

            self.filePopup.addAction(self.openAction)
            self.filePopup.addAction(self.closeAction)
            
            self.cutAction = QAction('Cut')
            self.copyAction = QAction('Copy')
            self.pasteAction = QAction('Paste')
            
            self.editPopup.addAction(self.cutAction)
            self.editPopup.addAction(self.copyAction)
            self.editPopup.addAction(self.pasteAction)
            
            self.aboutAction = QAction('About')
            self.helpPopup.addAction(self.aboutAction)
                    
            menuBar.addMenu(self.filePopup)
            menuBar.addMenu(self.editPopup)
            menuBar.addMenu(self.helpPopup)
                    
    Alternatif olarak biz QMenu sınıfının addAction metoduna doğrudan isim verebiliriz. Bu durumda addAction metodu QAction nesnesini 
    kendisi yaratıp onu ekledikten sonra bize bu yarattığı QAction nesnesini vermektedir. Yukarıdaki işlemler şöyle kısaltılabilir:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.resize(800, 600)
            
            menuBar = self.menuBar()
            self.filePopup = menuBar.addMenu('File')
            self.editPopup = menuBar.addMenu('Edit')
            self.helpPopup = menuBar.addMenu('Edit')
            
            self.openAction = self.filePopup.addAction('Open')
            self.closeAction = self.filePopup.addAction('Close')
            
            self.cutAction = self.editPopup.addAction('Cut')
            self.copyAction = self.editPopup.addAction('Copy')
            self.pasteAction = self.editPopup.addAction('Paste')
            
            self.aboutAction =  self.helpPopup.addAction('About')
            
    Ancak biz kurusumuzda genel olarak nesneleri kendimiz yaratacağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı seçildiğinde bir şeyler yapabilmek için QAction sınıfının triggered isimli sinyali kullanılmaktadır. Bu sinyal 
    isteğe bağlı bir parametreye sahiptir. Sinyal menü elemanı seçildiğinde emit edilmektedir. Sinyalin parametresi elemanın checked 
    olup olmadığını bize vermektedir. 
    
    Aşağıdaki örnekte bir menü sistemi oluşturulmuştur. Menü sistemi şöyledir:

    File    Edit    Help
    Open    Cut     About
    Close   Copy
    Exit    Paste
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('File')
        self.editPopup = QMenu('Edit')
        self.helpPopup = QMenu('Help')
        
        self.openAction = QAction('Open')
        self.closeAction = QAction('Close')
        self.exitAction = QAction('Exit')       

        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('Cut')
        self.copyAction = QAction('Copy')
        self.pasteAction = QAction('Paste')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.aboutAction = QAction('About')
        self.helpPopup.addAction(self.aboutAction)
        
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.helpPopup)
    
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi ikonlar Qt'de QIcon sınıfıyla temsil edilmektedir. Bir ikon nesnesi yaratmak için tipik olarak 
    QIcon sınıfının __init__ metodunda ikona ilişkin dosyanın yol ifadesi belirtilmektedir. Örneğin:

    icon = QIcon('test.png')

    İkon'lar çeşitli dosya formatlarıyla yaratılabilirler. Ancak ikonlar için en uygun dosya formatı "png" formatıdır. Çünkü png formatında 
    transparanlık bilgisi formatın kendi içerisinde bulunmaktadır. 

    Pekiyi biz ikonik resimleri nasıl elde edebiliriz? Aslında ikonik resimler birer sanat eseri statüsünde olduğu için telif haklarına 
    sahip olabilmektedir. Ancak kişiler telif haklarına sahip olmayan pek çok ikonik resim oluşturmuştur. Dolayısıyla para vermeden 
    ikonik resimler elde edebiliriz. Bunun için çeşitli siteler bulunmaktadır. Aşağıdaki iki site bunun için kullanılabilir:

    iconfinder.com
    flaticon.com
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                27. Ders 14/06/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Menü elemanlarına ikon iliştimek için iki yol vardır. Birincisi QAction nesnesi yaratıldıktan sonra QAction sınıfının setIcon 
    metodunun kullanılmasıdır. Örneğin:

    self.openAction = QAction('Open')
    self.openAction.setIcon(QIcon('open.png'))
    self.openAction.triggered.connect(self.openActionHandler)
    
    İkinci yol doğrudan QAction nesnesini yaratırken birinci parametre olarak ikon'u belirtmektir. QAction nesnesi tek argümanla 
    yaratılırsa o argüman menü elemanının yazısını belirtmektedir. Ancak yaratımda iki argüman kullanılırsa bu durumda birinci argüman 
    ikonu ikinci argüman menü elemanının yazısını belirtir. Örneğin:

    self.openAction = QAction(QIcon('open.png'), 'Open')
    self.openAction.triggered.connect(self.openActionHandler)       

    Menü elemanlarına iliştirilecek ikonlar tipik olarak 16x16 boyutlarındadır. PNG, BMP gibi formatlar ölçeklendirlirken görüntünün 
    bozulabileceğini belirtmiştik. Bu nedenle mümkün olduğunca menü elemanları için ikonları menü elemanının boyutuna uygun bir boyutta 
    seçmelisiniz.

    Menülerde pek çok ikon kullanıldığına göre bu ikonlara ilişkin dosyalar programda kırılganlık yaratabilmektedir. Çünkü bunlardan 
    biri kaybolsa program çalışmayacaktır. İşte gerçekten GUI framework'lerini tasarlayan kişiler bu kırılganlığı fark etmiş ve bunu 
    azaltmak için "kaynak (resource)" denilen bir kavram geliştirmişlerdir. Kaynak bir grup görüntü, ses vs gibi öğelerin tek bir 
    dosyada birleştirilmesine denilmektedir. Ancak kaynak kullanmyor olasınız bile hiç olmazsa menü resimlerini ayrı bir klasöre 
    yerleştirip daha düzenli hale getirebilirsiniz. 

    Aşağıdaki örnekte menü elemanlarına ikonlar iliştirilmiştir. Uygulamaya ilişkin ikonların hepsi "iconfinder.com" sitesinden 
    indirilmiştir ve "MenuIcons" isimli bir klasöre yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                        
        menuBar = self.menuBar()
        self.filePopup = QMenu('File')
        self.editPopup = QMenu('Edit')
        self.helpPopup = QMenu('Help')
        
        self.openAction = QAction('Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        
        self.closeAction = QAction('Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        
        self.exitAction = QAction('Exit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))

        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('Cut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        
        self.copyAction = QAction('Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        
        self.pasteAction = QAction('Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.aboutAction = QAction('About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.helpPopup)
    
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir popup pencere açıkken bir tuşa bastığımızda belli bir menü elemanının seçilmesi sağlanabilir. Bunun için menü elemanının 
    isminde istenilen harfin önüne '&' sembolü getirilmelidir. Örneğin:

    self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open')
 
    Burada '&' sembolü O'nun önüne getirilmiştir. Bu durumda"File" popup penceresi açıldığında 'O' tuşuna basılırsa sanki "Open" menü 
    elemanı seçilmiş gibi işlem yapılacaktır. Bazı ortamlarda bu '&' getirilmiş karakter altı çizgili bir biçimde görüntülenmektedir. 
    Örneğin Windows'ta eskiden bu karakterler altı çizili biçimde gözüküyordu. Sonra Windows stil değiştirdi, artık yalnızca "Alt" 
    tuşuna basıldığında bu karakter altı çizili olarak görüntülenmektedir.  Popup pencere başlık yazılarında da '&' karakteri 
    kullanılabilmektedir. Örneğin:

    self.editPopup = QMenu('&Edit')
    menuBar.addMenu(self.editPopup)

    Popup yazılarına bu biçimde '&' iliştirilirse  popup "Alt" tuşu ve ilgili tuşa basılarak klavye yoluyla açılabilmektedir. 

    Yukarıda da belirttiğimiz gibi popup ve menu elemanlarınının isimlerinde '&' kullanırsanız hiç fare kullanmadan menü elemanının 
    seçilmesini sağlayabilrisiniz. Örneğin bu sayede "Alt+F+O" tuşları ile "File/Open" menü elemanı yalnızca klavye yoluyla 
    seçilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Menü hiç açılmadan klavyeden belli bir tuş kombinasyonuna basıldığında sanki bir menü elemanı seçilmiş gibi işlem yapılmasına yol
    açan tuşlara "kısa yol tuşları (Shortcut keys / Accelarators)" denilmektedir. Qt'de menü elemanına kısa yol tuşu girmek için 
    QAction sınıfının setShortcut metodu kullanılmaktadır. Bu metoda argüman olarak kısa yol yazısı aralarına '+' karakteri getirilerek
    verilir. Örneğin:

    self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open')
    self.openAction.setShortcut('Ctrl+O')
    self.openAction.triggered.connect(self.openActionHandler)
            
    Burada kısayol yazısı "Ctrl+O" biçiminde girilmiştir. Yani kısa yol tuşu "Ctrl" ve "O" tuşuna basmak biçiminde tanımlanmıştır. 
    Kısa yol tuşu "Ctrl+Alt+O" gibi başka tuş kombinasyonlarını da içerebilmektedir. Bir menü elemanına kısa yol tuşu atandığında 
    bu kısa yol tuşu otomatik olarak menü elemanının sağında görüntülenmektedir. 

    Aşağıdaki örnekte menü elemanlarına kısa yol tuşları atanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                        
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
              
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.helpPopup)
    
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı "checkable" olabilir ya da olmayabilir. Default durumda menü elemanları checkable değildir. Menü elemanlarını
    checkable yapmak için QAction sınıfının setCheckable metodu True ile çağrılır. Eğer menü elemanı "checkable" yapılırsa o eleman 
    her seçildiğinde elemanın solunda (ikon alanında) checked sembolü çarpılanıp kaldırılmaktadır. Örneğin:

    self.fullScreenAction = QAction('Full Screen')
    self.fullScreenAction.setShortcut('Ctrl+Shift+F')
    self.fullScreenAction.setCheckable(True)

    Tabii menü elemanının checked olup olmadığı programın belli bir noktasında sorgulanmak istenebilir. Bunun için QAction sınıfının 
    isChecked metodu kullanılmaktadır. Checkable bir menü elemanını programlama yoluyla checked ya da unchecked yapabiliriz. Bu işlem 
    QAction sınıfının setChecked metodu ile yapılabilir. 

    Bir menü elemanı hem bir ikona sahipse hem de checkable biçimdeyse ikonun çevresine dikdörtgen çıkartılmaktadır. Ancak genellikle 
    checkable menü elemanlarına ikon iliştirilmez.

    Aşağıdaki örnekte "View" popup penceresindeki "Full Screen" menü elemanı checkable hale getirilmiştir. Qt'de ana pencereyi "full 
    screen" yapabilmek için QMainWindow sınıfının showFullScreen metodu, full screen modundan geri dönmek için de sınıfın showNormal 
    metodu kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------
 
 import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                        
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
              
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.fullScreenAction = QAction('&Full Screen')
        # self.fullScreenAction.setIcon(QIcon('MenuIcons/fullscreen.png'))
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
    
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        checked = self.fullScreenAction.isChecked()
        if checked:
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı "enabled" ya da "disabled" biçimde olabilir. Default durumda menü elemanları "enabled" biçimdedir. Menü elemanlarını 
    "disabled" hale getirmek için QAction sınıfının setEnabled metodu False argümanı ile çağrılır. Tabii bu metot tekrar True 
    argümanı ile çağrılırsa menü elemanı da tekrar "enabled" hale getirilecektir. Belli bir noktada bir menü elemaının aktif olmasının 
    bir anlamı yoksa onun "disabled" hale getirilmesi uygun olur. Örneğin bir text editörde bir yazı seçimi (select) yapılmamışsa Copy, 
    Cut, Paste gibi menü elemanlarını seçmenin bir işlevi olmayacağı için onlar "disabled" yapılabilir. 
    
    Aşağıdaki örnekte "File" popup penceresindeki "Open" menü elemanı seçildiğinde "Open" menü elemanı "disabled", "Close" menu elemanı
    ise "enabled" yapılmıştır. Benzer biçimde "Close" menü elemanı seçildiğinde de "Open" menü elemanı "enabled", Close menü elemanı 
    "disabled" yapılmıştır. Tabii işin başında "Open" menü elemanı "enabled" durumda "Close" menü elemanı ise "disabled" durumda 
    olmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------
 
 import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                        
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
              
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.fullScreenAction = QAction('&Full Screen')
        # self.fullScreenAction.setIcon(QIcon('MenuIcons/fullscreen.png'))
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
    
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        checked = self.fullScreenAction.isChecked()
        if checked:
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı uygulamalarda bazı menü seçenekleri en son nasıl bırakılmışsa program o biçimde başlatılmaktadır. Örneğin en son kullanıcı 
    ana penceresini "full secreen" moda geçirmiş olabilir. Bu durumda program yeniden çalıştırıldığında ana pencerenin bu modda 
    görüntülenmesi istenebilir. Bazı programlarda ana pencereler onların son kapatıldığı konumda ve büyüklükte görüntülenmektedir. 
    Bu tür program ayarları daha önce gördüğümüz shelve sınıfı ile saklanıp geri alınabilir.

    Aşağıdaki örnekte ana pencerenin son konumu, son genişlik ve yüksekliği ve "full screen" mod bilgisi shelve ile oluşturulmuş 
    bir dosyada saklanıp program yeniden çalıştırıldığında oradan yüklenmiştir. Ancak bu örnekte ana pencere kapatılırken ayarların 
    saklanmasında henüz görmediğimiz closeEvent metodundan faydalanılmıştır. Bir programda ana pencere nasıl kapatılırsa kapatılsın 
    pencere sınıfının closeEvent isimli bir metodu çağrılmaktadır. Bu çağırma sinyal slot mekanizmasıyle değil doğrudan yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
              
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                        
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.fullScreenActionTriggeredHandler()
        
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings.close()                     
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında Qt'de programın ayarlarını saklamaya olanak sağlayan QSettins isimli bir sınıf bulundurulmuştur. Biz yukarıdaki örneğimizde
    bu sınıfı kullanmadık. Bu sınıf yardımıyla program ayarlarının nasıl saklanıp geri yüklendiğini Qt dokümanlarını inceleyerek 
    öğrenebilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            31. Ders 15/06/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı bir popup menü olabilir. Bu duruma "alt menü (submenu)" de denilmektedir. Örneğin "View" menüsünü açtığımızda
    "Theme" isimli menü elemanı temaları belirten bir popup pencere olabilir. Bu biçimdeki alt menüleri oluştumak için yine alt menüler
    QMenu sınıfı kullanılarak oluşturulur. Ancak alt menünün eklenmesi QMenu sınıfının addAction metoduyla değil de addMenu metoduyla 
    yapılmaktadır. Yani eğer biz popup pencereye bir QAction eklersek menü elemanı eklemiş oluruz. Ancak bir QMenu eklersek popup menü 
    eklemiş oluruz. Örneğin:

    self.themePopup = QMenu('Theme')
    self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
    ...
    self.viewPopup.addMenu(self.themePopup)

    Aşağıdaki örnekte "File" popup penceresine "Open Recent", "View" popup penceresine de "Theme" alt menüleri eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        
        self.openRecentPopup = QMenu('Open Recent')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)

        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
       
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                        
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.fullScreenActionTriggeredHandler()
        
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    QAction sınıfının setFont metoduyla menü elemanının fontunu değiştirebilirsiniz. Ancak font değişikliği yaparken genel görünümün 
    bozulmamasına dikkat etmelisiniz. Örneğin:

    font = self.exitAction.font()
    font.setPointSize(16)
    self.exitAction.setFont(font)
        
    Burada "Exit" menü elemanının fontu büyütülmüştür. Ancak yukarıda da belirttiğimiz gibi menü elemanlarını default boyutta tutmak 
    daha uygundur. 

    Bir popup pencerenin tüm elemanlarının renkleri "style sheet" yoluyla da değiştirilebilmektedir. Örneğin "File" popup penceresinin 
    tüm elemanlarının rengini aşağıdaki gibi değiştirebiliriz:

    self.filePopup.setStyleSheet('QMenu::item { color: red; }')

    Yalnızca belli bir elemanın rengini değiştirmek biraz daha zahmetlidir. Bunun için menu elemanı QAction sınıfı kullanılarak değil 
    QWidgetAction sınıfı kullanılarak yaratılır. Bunun içerisine bir QLabel nesnesi yerleştirilir ve bu QLabel nesnesinin rengi 
    değiştirilir. Örneğin:

    self.widgetAction = QWidgetAction(self);
    label = QLabel("Exit");
    label.setStyleSheet("color: red; padding: 4px;");
    self.widgetAction.setDefaultWidget(label);
    self.filePopup.addAction(self.widgetAction);
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Fare ile bir menü elemanının üzerine gelinip biraz beklendiğinde (buna "hover" işlemi denilmektedir) çıkan yazıya "ipucu yazısı 
    (tooltip text)" denilmektedir. İpucu yazısını set etmek için QAction sınıfının setToolTip metodu kullanılmaktadır. Ancak ipucu 
    yazısının çıkması için menü elemanının ilişkin olduğu popup pencerede de setToolTipsVisible metodu True ile çağrlarak ayarlama 
    yapılması gerekir. Örneğin:

    self.filePopup.setToolTipsVisible(True)             # menü elemanının bulnduu popup için bu metodun çağrılması gerekir

    self.exitAction = QAction('E&xit')  
    self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
    self.exitAction.setShortcut('Alt+X')
    self.exitAction.setToolTip('Exits the application...')      # ipucu yazısını set eder

    Aşağıdaki örnekte "File" popup penceresi için ipucu yazılarının görüntülenmesi seToolTipsVisible metoduyla sağlanmıştır. Ondan 
    sonra "File" popup içerisindeki menü elemanları için QAction sınıfının setToolTip metotlarıyla ipucu yazıları set edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action.setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
       
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                        
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.fullScreenActionTriggeredHandler()
        
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    Birbiriyle ilişkili menü elemanlarını gruplamak için "separatör" denilen özel menü elemanları kullanılmaktadır. Bazı framework'lerde
    bu separator'ler ayrı bir sınıfla temsil edilmişlerdir. Ancak Qt'de separatör'ler de QAction sınıfıyla temsil edilmiş durumdadır. 
    Biz bir QAction nesnesi yaratıp QAction sınıfının setSeparator metodunu True parametresiyle çağrırısak artık o menü elemanı bir 
    separtör haline gelir. Tabii separatör menü elemanın artık isminin de bir önemi kalmamaktadır. Örneğin:

    self.separatorAction = QAction()
    self.separatorAction.setSeparator(True)
    self.filePopup.addAction(self.seperatorAction)

    Tabii her separatör için ayrı bir QAction nesnesinin yaratılmasına gerek yoktur. Bu nesneden bir tane yaratıp menülerde bunu farklı 
    yerlere ekleyebiliriz. 

    Aşağıdaki örnekte "File" popup penceresine "Exit" menü elemanından önce ve "View" popup penceresine de "Full Screen" menü elemanından 
    önce separatörler eklenmiştir.
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                        
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.fullScreenActionTriggeredHandler()
        
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
    Menülü ve araç çubuklu uygulamalarda menüler ve araç çubukları ana pencerenin çalışma alanı (client area) içerisinde yer kaplamaktadır. 
    Bu durumda menü ana pencerenin çalışma alanının (0, 0) orijininde konumlanır. Programcının ana pencerenin içerisine yerleştireceği 
    alt pencereler için konum belirlemesi zorlaşmaktadır. İşte GUI dünyasında bu sorunu ortadan kaldırmak için menülerin ve araç çubuklarının 
    dışında kalan ve çalışma alanını tamamen kaplayan bir dummy pencere kullanılmaktadır. Qt'de buna "merkezi pencereler (central widgets)" 
    denilmektedir. (Bazı framework'lerde bu tür pencerelere "view" pencereleri de denilmektedir.) Biz bir pencereyi QMainWindow nesnesinin 
    merkezi penceresi yaparsak artık o pencere çalışma alanının kalan kısmını kaplar duruma gelir. Biz de kendi alt pencerelerimizi bu 
    merkezi pencereye yerleştirirsek menü ve araç çubuklarının aşağısını (0, 0) orijini olarak kullanabiliriz. Merkezi pencere herhangi 
    bir pencere olabilir. Merkezi pencereyi set etmek için QMainWindow sınıfının setCentralWidget metodu kullanılmaktadır. Örneğin:

    self.cw = QWidget(self)
    self.setCentralWidget(self.cw)
    ...
    self.pushButtonOk = QPushButton('Ok', self.cw)
    self.pushButtonOk.setGeometry(0, 0, 100, 100)

    Burada görüldüğü gibi QPushButton nesnesi ana pencerenin içerisine değil merkezi pencerenin içerisine yerleştirilmiştir. Eğer 
    buradaki düğme ana pencerenin içerisine yerleştirilseydi menü ile çakışık görüntülenirdi. Merkezi pencerenin amacı menü ve araç 
    çubuklarının altında yeni bir pencere alanı oluşturmaktır. Böylece GUI elemanlar için orijin noktası menü ve araç çubuklarının 
    aşağısından başlatacaktır. 

    Aşağıdaki örnekte ana pencereye bir merkezi pencere iliştirilmiş ve düğme de bu merkezi pencerenin içerisinde yaratılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.cw = QWidget(self)
        self.setCentralWidget(self.cw)
        
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
                        
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.pushButtonOK = QPushButton('Ok', self.cw)
        self.pushButtonOK.move(0, 0)
        self.pushButtonOK.resize(100, 100)
        
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
               
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
    Merkezi pencere (central widget) boş bir QWidget penceresi olmak zorunda değildir. Başka bir GUI eleman da merkezi pencere olarak 
    kullanılabilir. Bu durumda o GUI elemanı menünün ve araç çubuklarının altında kalan tüm çalışma alanını kaplar hale gelecektir. 
    Örneğin:

    self.textEdit = QTextEdit(self)
    self.setCentralWidget(self.textEdit)

    Burada merkezi pencere olarak QTextEdit penceresi kullanılmıştır. Böylece adeta bir "notepad" ortamı oluşturulmuştur.            

    Aşağıdaki örnekte ana pencere içerisine merkezi pencere olarak bir QTextEdit penceresi yerleştirilmiştir. Sonra "word wrap" 
    işlemi için "View" popup penceresinde "checkable" bir menü elemanı bulundurulmuştur. Program bu haliyle "notepad" uygulamasına 
    benzemektedir. Ancak örneğimizde programdan çıkıldığında "word wrap" menü elemanının "checked" olup olmadığı da kaydedilmiştir.
    Böylece yeniden program çalıştırıldığında programdan son çıkıldığı durumdaki "word wrap" özelliği set edilmektedir.
 #------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    Genellikle menülerin hemen altında görüntülenen, düğmelerden oluşan, bu düğmelere tıklandığında birtakım işlemlerin gerçekleşmesini 
    sağlayan alt pencerelere "araç çubukları (toolbars)" denilmektedir. Araç çubukları Qt'de QToolBar sınıfıyla temsil edilmiştir. 
    
    PyQt'de araç çubukları şöyle oluşturulmaktadır:

    1) Önce QToolBar sınıfı türünden bir nesne yaratılır. Örneğin:

    self.toolBar = QToolBar()
    
    2) Bu nesne QMainWindow sınıfının addToolBar metodu ile ana pencereye iliştirilir. Örneğin:

    self.addToolBar(self.toolBar)

    3) QToolBar sınıfının addAction metodu ile araç çubuğuna QAction nesneleri eklenir. Yani hem menü elemanları hem de araç çubuğu
    elemanları QAction sınıfı ile temsil edilmiştir. Dolayısıyla biz zaten menüler için oluşturduğumuz QAction nesnelerini araç 
    çubuklarına da ekleyebiliriz. QToolBar sınıfının addSeparator metodu ile de araç çubuklarına ayıraç da eklenebilmektedir. Genellikle
    programcılar çok kullanılan menü elemanlarını aynı zamanda araç çubuklarına da eklemektedir. Örneğin:

    self.toolBar.addAction(self.openAction)
    self.toolBar.addAction(self.closeAction)
    self.toolBar.addSeparator()
    self.toolBar.addAction(self.copyAction)
    self.toolBar.addAction(self.cutAction)
    self.toolBar.addAction(self.pasteAction)
    self.toolBar.addAction(self.wordWrapAction)
        
    Araç çubuklarındaki düğmeler default durumda 16x16 biçimindedir. Buradaki düğmelerin büyüklüğünü değiştirmek için QToolBar 
    sınıfının setIconSize metodu kullanılmaktadır. Bu metot QSize türünden bir parametre alır. Örneğin:

    self.toolBar.setIconSize(QSize(32, 32))

    Aşağıdaki örnekte 32x32'lik araç çubuğu düğmeleri oluşturulup bu düğmelere 32x32'lik ikon'lar iliştirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addAction(self.wordWrapAction)
        
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
   
#------------------------------------------------------------------------------------------------------------------------------------
    Araç çubuklarına yalnızca QAction nesneleri değil herhangi türden GUI elemanları da eklenebilmektedir. Bunun için QToolBar 
    sınıfının addWidget metodu kullanılır. Örneğin bir araç çubuğuna bir combobox ekleyebiliriz. Bu combobox'tan seçim yapıldığında 
    combobox'ın currentIndexChanged sinyalinden hareketle istediğimiz işlemleri yapabiliriz:

    self.comboBoxFonts = QComboBox(self.toolBar)
    self.comboBoxFonts.addItems(["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", 
                                "Trebuchet MS", "Comic Sans MS", "Lucida Console", "Tahoma"])
    self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontCurrentIndexChangedHandler)
    self.toolBar.addWidget(self.comboBoxFonts)

    Aşağıdaki örnekte edit alanı içerisindeki yazının font türünü ve isimlerini değiştirmek için araç çubuğuna iki combobox 
    yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
                
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def closeEvent(self, event):
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()                     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
                                            29. Ders 21/06/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de bazı mesajlar sinyal/slot mekanizması yoluyla değil doğrudan metot çağırma yoluyla (C++'ta sanal fonksiyon mekanizmasıyla)
    işlenmektedir. Sinyal/Slot mekanizması göreli olarak yavaş bir mekanizmadır. Halbuki bazı temel pencere mesajlarının hızlı bir 
    biçimde doğrudan işlenmesi gerekebilmektedir. Bu pencere mesajlarını işleyebilmek için pencere sınıfının içerisinde xxxEvent isimli 
    özel metotlar yazılmalıdır. Bu metotların isimleri ve parametrik yapıları önceden belirlenmiştir. Dolayısıyla programcının bu 
    metotları belirlenen isimlerle ve parametrik yapıyla tanımlaması gerekir. Doğrudan fonksiyon çağırma yoluyla işlenen özel pencere 
    mesajlarının önemli olanları şunlardır:

    - mousePressEvent
    - mouseReleaseEvent
    - mouseMoveEvent
    - resizeEvent
    - keyPressEvent
    - closeEvent
    - mouseDoubleClickEvent
    - paintEvent

    Bu metotların hepsinin xxxEvent biçiminde isimlendirildiğine dikkat ediniz. paintEvent metodu çizim konusu ile ilgilidir. 
    Burada diğer mesajlar üzerinde kısaca duracağız. Custom widget yazmak için bu mesajların kullanılması gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Fare ile bir pencere üzerinde tıklanııklanmazr t (yani parmak çekilmeden ) mousePressEvent isimli metot, el farenin tuşundan 
    çekildiğinde de mouseReleaseEvent isimli metot otomatik çağrılmaktadır. Bu metotların self parametresinin dışında QMouseEvent 
    denilen bir sınıf türünden parametreleri vardır. Programcı bu sınıfın içerisinden basım ya da çekim koordinatlarını QMouseEvent 
    sınıfının pos metoduyla elde edebilmektedir. (PyQt5'te pos QMouseEvent sınıfının pos metodunun yanı sıra x ve y isimi metotları da 
    vardır.) pos metodu bize basım ya da çekim koordinatlarını "client area" orijinli olarak QPoint nesnesi biçiminde vermektedir. Biz 
    bu metotlarda koordinatları aşağıdaki gibi elde edebiliriz:

    def mousePressEvent(self, me):
        x = me.pos().x()
        y = me.pos().y()
        # ...

    Aşağıdaki örnekte farenin herhangi bir tuşuna basıldığında ve çekildiğinde farenin o anki koordinatları konsol ekranına yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()

    def mousePressEvent(self, me):
        x = me.pos().x()
        y = me.pos().y()
        print(f'mousePressEvent x = {x}, y = {y}')
        
    def mouseReleaseEvent(self, me):
        x = me.pos().x()
        y = me.pos().y()
        print(f'mouseReleaseEvent x = {x}, y = {y}')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Fare mesajları farenin herhangi bir tuşuna basıldığında oluşmaktadır. Programcı eğer spesifik bir tuşla ilgileniyorsa bu durumda 
    metot çağrıldığında QMouseEvent nesnesi ile button metodunu çağırmalıdır. Button metodu bize hangi tuşa basıldığı bilgisini 
    vermektedir. button metodunun geri dönüş değeri Qt.MouseButton isimli bir sınıf türündendir. Bu sınıf içerisinde tuşları temsil 
    eden aşağıdaki sembolik sabitler bulunmaktadır:

    Qt.MouseButton.LeftButton
    Qt.MouseButton.RightButton
    Qt.MouseButton.MiddleButton

    PyQt5'te fare tuşlarını belirten bu sembolik sabitler doğrudan Qt modülüün içerisinde tanımlanmıştır.

    Örneğin:

    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            print(f'mousePressEvent x = {x}, y = {y}')
        
    def mouseReleaseEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            print(f'mouseReleaseEvent x = {x}, y = {y}')

    Burada artık yalnızca farenin sol tuşuna basıldığında işlem yapılmaktadır.
        
    Aşağıdaki örnekte farenin sol tuşuna basılıp çekildiğinde koordinatlar yazdırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()

    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            print(f'mousePressEvent x = {x}, y = {y}')
        
    def mouseReleaseEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            print(f'mouseReleaseEvent x = {x}, y = {y}')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte farenin sol tuşuna basıldığında orta noktası basılan koordinatta olacak biçimde QPushButton nesneleri yaratılmıştır. 
    Bir GUI eleman __init__ metodunun dışında yaratılıyorsa GUI eleman yaratıldıktan sonra setVisible(True) çağrısı ile GUI elemanın 
    görünür hale getirilmesi gerekmektedir. (__init__ metodunda setVisible uygulamaya gerek yoktur. Çünkü Qt'de üst pencere görünür
    değilse üst pencere görünür hale getirildiğinde o üst pencerelerin tüm alt penceleri de otomatik olarak görünür hale getirilmektedir.)  
    Örneğimizde yarattığımız düğme nesnelerini ayrıca saklamadık. İsterseniz bunları nesnenin örnek özniteliği biçiminde yaratacağınız 
    bir listede saklayabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

BUTTON_SIZE = 50

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.count = 1
        
    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            pushButton = QPushButton(str(self.count), self)
            pushButton.setGeometry(x - BUTTON_SIZE // 2, y - BUTTON_SIZE // 2, BUTTON_SIZE, BUTTON_SIZE)
            pushButton.setVisible(True)           
            self.count += 1
           
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Çok kullanılan temel fare mesajlarından biri de "mouse move" denilen mesajdır. Kullanıcı fareyi pencerenin çalışma alanı içerisinde 
    hareket ettirdiğinde işletim sistemi ya da pencere yöneticisi alt sistem bu mesajı kuyruğa bırakmaktadır. Qt framework de bu mesajı 
    kuyruktan alınca pencere sınıfındaki mouseMoveEvent isimli metodu çağırır. Bu metodun da yine self dışında QMouseEvent sınıfı türünden 
    bir parametresi vardır. Bu parametre yoluyla biz fare sürüklendikçe fare konumunu izleyebiliriz. Metoda geçirilen QMouseEvent nesnesi 
    aynı zamanda fare sürüklenirken o anda farenin hangi tuşlarına basılı olduğu bilgisini de bize vermektedir. Tabii fare sürüklenirken 
    farenin birden fazla tuşuna basılmış olabilir. Bu nedenle basılan tuşu almak için sınıfın button metodu yerine buttons isimli metodu
    kullanılmaktadır. (moseMoveEvent metodunda button metodu her zaman 0 vermektedir.) buttons metodu bize birden fazla biti set edilmiş
    olabilen bir değer vermektedir. Dolayısıyla kontrol işlemi == operatörü ile değil bit düzeyinde AND işlemi yapan & operatörü ile 
    yapılmalıdır. Biz Python kursunda bit operatörleri üzerinde pek durmadık. Bit AND işleminden sonra maskelenen değerin orijinal 
    değerle karşılaştırılması gerekir. Örneğin:

    if me.buttons() & Qt.MouseButton.LeftButton == Qt.MouseButton.LeftButton:
        pass

    mousePressEvent ve mouseReleseEvent mesajlarında böyle bir durumun mümkün olmadığına dikkat ediniz. Örneğin mousePressEvent mesajında 
    biz bir tuşa bastığımızda metot çağrılmakta sonra o tuşa basılı olduğu durumda diğer tuşa bastığımızda da metot yeniden çağrılmaktadır. 
    Oyse mouseMoveEvent mesajı fare sürüklendiğinde oluşmaktadır. Tabii isterseniz mousePressEvent ve mouseReleaseEvent metotlarında 
    da button metodu yerine buttons metodunu kullanabilirsiniz. 

    "Mouse move" mesajlarında farenin bir yerden başka yere sürüklenmesi sırasında her pixel için mesaj oluşturulması gibi bir garanti 
    verilmemektedir. Farenin hareket ettirilmesi sırasında sistemin içinde bulunduğu yük durumuna göre çeşitli sıklıklarda bu mesaj 
    oluşturulabilmektedir. 

    Qt'de "mouse move" mesajları default durumda ancak farenin herhangi bir tuşuna basılıysa oluşturulmaktadır. Bu konuda framework'ler 
    arasında bazı farklılıklar söz konusudur. Bazı framework'lerde farenin tuşuna basılı olsa da olmasa da "mouse move" mesajı için 
    metot çağrılmaktadır. Qt'de eğer tuşa basılı olmasa da mouseMoveEvent metodunun çağrılması isteniyorsa QWidget sınıfınından
    gelen setMouseTracking metodu True argümanıyla bir çağrılmalıdır. Örneğin:

    self.setMouseTracking(True)   

    Aşağıdaki örnekte fare sol tuşa basılı bir biçimde hareket ettrildiğinde konumu pencere başlığına yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        
    def mouseMoveEvent(self, me):
        if me.buttons() & Qt.MouseButton.LeftButton == Qt.MouseButton.LeftButton:
            x = me.pos().x()
            y = me.pos().y()
            self.setWindowTitle(f'x = {x}, y = {y}')
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI çalışma modelinde her pencere diğerinden bağımsız bir biçimde mesajları işlemektedir. Dolayısıyla fare mesajları hangi pencere
    içerisinde oluşturulursa o pencereye gönderilmektedir. Örneğin biz ana pencere için mouseMoveEvent mesajını işlemiş olalım. Ancak 
    ana penceremizde bir tane de QPushButton penceresi bulunuyor olsun. Biz fareyi kendi ana penceremiz üzerinde hareket ettirdiğimizde 
    "mouse move" mesajı bizim penceremize gönderilecektir. Ancak fare QPushButton penceresi üzerine geldiği zaman artık "mouse move" 
    mesajı ana pencereye değil bu QPushButton penceresine gönderilecektir. Aşağıda bu durum küçük programla simüle edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setMouseTracking(True)
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(300, 300, 200, 200)
        
    def mouseMoveEvent(self, me):
        x = me.pos().x()
        y = me.pos().y()
        self.setWindowTitle(f'x = {x}, y = {y}')
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz zaten var olan GUI elemanında fare mesajlarını işlemek istesek bunu nasıl yapabiliriz? Bunun en normal yolu mevcut 
    GUI eleman sınıflarından türetme yapmaktır. Türetme yapılarak xxxEvent metotları türemiş sınıfta yazılırsa biz standadr GUI 
    elemanlarda da bu mesajları işleyebiliriz. Ancak burada dikkat edilmesi gereken bir nokta vardır. Biz türemiş sınıfta xxxEvent 
    metotlarını override ettiğimizde artık taban sınıftaki ilgili metotlar çalıştırılmayacaktır. GUI elemanın işlevselliği taban sınıfta 
    sağlandığı için GUI elemanın çalışması bozulabilecektir. Bunun için türemiş sınıfta kendi yazdığımız xxxEvent metotlarında taban 
    sınıfın xxxEvent metotlarını super kullanarak çağırmamız gerekir. Aşağıdaki örnekte biz QPushButton sınıfınından türetme yaparak 
    mousePressEvent ve mouseMoveEvent metotlarını oluşturduk. Ancak bu metotlarda taban QPushButton sınıfının ilgili metotlarını da 
    çağırdık. Örneğimizde QPushButton sınıfından MyPushButton sınıfı türetilmiştir. MyPushButton sınıfında da mouseMovEvent metodu 
    override edilmiştir:

    class MyPushButton(QPushButton):
        def __init__(self, text, parent):
            super().__init__(text, parent)
            self.parent = parent
            self.setMouseTracking(True)    
            
        def mouseMoveEvent(self, me):
            super().mouseMoveEvent(me)
            x = me.pos().x()
            y = me.pos().y()
            print(f'MyPushButton: x = {x}, y = {y}')

    mouseMoveEvent metodunda taban sınıfın (yani QPushButton sınıfının mouseMoveEvent metodunun da çağrıldığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

class MyButton(QPushButton):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setMouseTracking(True)
     
    def mousePressEvent(self, me):
        print(f'Pressed: {me.x()}, {me.y()}')
        super().mousePressEvent(me)
        
    def mouseMoveEvent(self, me):
        print(f'MouseMove: {me.x()}, {me.y()}')
        super().mousePressEvent(me)
    
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
    
        self.resize(800, 600)    
        self.myButtonOk = MyButton('Ok', self)
        self.myButtonOk.setGeometry(10, 10, 100, 100)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow .show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI elemanı sürükleyip bırakabilmek için tipik olarak yukarıda sözünü ettiğimiz fare mesajlarının GUI eleman üzerinde işlenmesi 
    gerekir. Sürükle bırak işlemi tipik olarak şöyle yapılmaktadır:

    1) GUI elemanın üzerinde fare tuşuna basıldığında farenin konumu GUI elemana göreli bir biçimde elde edilir ve saklanır. Bunun 
    için GUI eleman için mousePressEvent metodunun yazılması gerekir. 

    2) Fare GUI eleman üzerinde sürüklendiğinde eski yer ile yeni yer arasındaki deltax ve deltay farkı hesaplanır. GUI eleman deltax, 
    deltay kadar move metoduyle hareket ettirlir. Bu işlem tabii mouseMoveEvent metodunda yapılmaktadır. GUI eleman deltax, deltay 
    kadar hareket ettirildiğinde zaten yeniden GUI eleman farenin ilk tıklandığı pozisyona gelmektedir. Böylece "mouse move" mesajları 
    sırasında aslında ilk tıklanan nokta GUI elemanın göreli orijinine göre hiç değişmemektedir. 
    
    3) Burada önemli bir noktaya dikkat edilmesi gerekir. Genellikle sürükleme (dragging) işlemleri farenin tuşuna basılarak yapılmaktadır. 
    Bu durumda mousePressEvent ve mouseMoveEvent metotlarında farenin ilgili tuşuna basılıp basılmakdığı kontrol edilmelidir. Bunu 
    yapmanın bir yolu daha önce gördüğümüz gibi QMouseEvent sınıfının button ve buttons metotlarını kullanmaktır. Diğer yolu ise bir 
    flag değişkeninden faydalanmaktır. mousePressEvent metodunda bir flag değişkeni True yapılır. mouseMoveEvent metodunda bu değişkene 
    bakılır. mouseReleaseevent metodunda da bu flag yeniden False değerine çekilir. Aşağıdaki gerçekleştirimi inceleyiniz:

    class MyPushButton(QPushButton):
        def __init__(self, text, parent):
            super().__init__(text, parent)
            self.parent = parent
                    
        def mousePressEvent(self, me):
            super().mousePressEvent(me)
            if me.button() == Qt.MouseButton.LeftButton:
                self.pressx = me.pos().x()
                self.pressy = me.pos().y()
                self.dragFlag = True
                
        def mouseReleaseEvent(self, me):
            super().mouseReleaseEvent(me)
            if me.button() == Qt.MouseButton.LeftButton:
                self.dragFlag = False
                
        def mouseMoveEvent(self, me):
            super().mouseMoveEvent(me)
            if self.dragFlag:
                x = me.pos().x()
                y = me.pos().y()
                deltax = x - self.pressx
                deltay = y - self.pressy;
                self.move(self.x() + deltax, self.y() + deltay)

    Her durumda programcı taban sınıfın ilgili metodunu (tuşa basılı olsa da olmasa da) çağırmalıdır. Bu noktayı bir kez daha
    vurgulamak istiyoruz.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
    
        self.pushButtonOk = MyPushButton('Ok', self)
        self.pushButtonOk.setGeometry(300, 300, 100, 100)
        
class MyPushButton(QPushButton):
    def __init__(self, text, parent):
        super().__init__(text, parent)
        self.parent = parent
                
    def mousePressEvent(self, me):
        super().mousePressEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.pressx = me.pos().x()
            self.pressy = me.pos().y()
            self.dragFlag = True
            
    def mouseReleaseEvent(self, me):
        super().mouseReleaseEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = False
            
    def mouseMoveEvent(self, me):
        super().mouseMoveEvent(me)
        if self.dragFlag:
            x = me.pos().x()
            y = me.pos().y()
            deltax = x - self.pressx
            deltay = y - self.pressy;
            self.move(self.x() + deltax, self.y() + deltay)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki örneğin biraz daha karmaşık bir biçimini yapalım. Aşağıdaki örnekte ana pencere üzerinde farenin sağ tuşuna
    basıldığında o noktada bir düğme yaratılmaktadır. Sonra yaratılan her düğme farenin sol tuşuna baılarak sürüklenip bırakılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *

BUTTON_SIZE = 50

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        self.count = 1
        
    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.RightButton:
            x = me.pos().x()
            y = me.pos().y()
            pushButton = MyPushButton(str(self.count), self)
            pushButton.setGeometry(x - BUTTON_SIZE // 2, y - BUTTON_SIZE // 2, BUTTON_SIZE, BUTTON_SIZE)
            pushButton.setVisible(True)
            self.count += 1       
                        
class MyPushButton(QPushButton):
    def __init__(self, text, parent):
        super().__init__(text, parent)
        self.parent = parent
                
    def mousePressEvent(self, me):
        super().mousePressEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.pressx = me.pos().x()
            self.pressy = me.pos().y()
            self.dragFlag = True
            
    def mouseReleaseEvent(self, me):
        super().mouseReleaseEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = False
            
    def mouseMoveEvent(self, me):
        super().mouseMoveEvent(me)
        if self.dragFlag:
            x = me.pos().x()
            y = me.pos().y()
            deltax = x - self.pressx
            deltay = y - self.pressy;
            self.move(self.x() + deltax, self.y() + deltay)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                30. Ders 22/06/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir pencerenin alt pencereleri olan kardeş pencereler çakıştığında altta ya da üste gözükme durumuna "Z sırası (Z order)" denilmektedir. 
    Default durumda sonradan yaratılan kardeş pencere önceden yaratılmış olan kardeş pencerelerin üzerinde görüntülenir. Ancak bu sıra 
    değiştirilebilmektedir. Bir GUI elemanı kardeş pencereler arasındaki Z sırasında en yukarıya taşımak için QWidget sınıfınından gelen 
    raise_ metodu kullanılmaktadır. (Python'da raise bir anahtar sözcük olduğu için PyQt'de C++'takinden farklı olarak bu metodun ismi 
    raise yerine raise_ yapılmıştır.) Benzer biçimde GUI elemanı Z sırasına göre en aşağıya çekmek için de lower isimli metot kullanılmaktadır.

    Aşağıdaki örnekte oyun kartları pencere içerisine rastgele biçimde yerleştirilmiştir. Sonra da onların fare ile sürüklenmesi 
    sağlanmıştır. Oyun kartları ".png" uzantısıyla kurs klasörünün "CardImages" dizininde bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import random
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import glob

SCALE_RATIO = 1.2

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(1200, 800)
                
        for path in glob.glob('CardImages/*.png'):
            pixmap = QPixmap(path)
            scaled_bixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
            x = random.randint(0, self.width() - scaled_bixmap.width())
            y = random.randint(0, self.height() - scaled_bixmap.height())
            labelImage = CardLabel('', self)
            labelImage.move(x, y)
            labelImage.setPixmap(scaled_bixmap)
        
class CardLabel(QLabel):
    def __init__(self, text, parent):
        super().__init__(text, parent)
        self.parent = parent
                
    def mousePressEvent(self, me):
        super().mousePressEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.pressx = me.pos().x()
            self.pressy = me.pos().y()
            self.dragFlag = True
            self.raise_()
            
    def mouseReleaseEvent(self, me):
        super().mouseReleaseEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = False
            
    def mouseMoveEvent(self, me):
        super().mouseMoveEvent(me)
        if self.dragFlag:
            x = me.pos().x()
            y = me.pos().y()
            deltax = x - self.pressx
            deltay = y - self.pressy;
            self.move(self.x() + deltax, self.y() + deltay)

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte oyun kartlarının başlangıçta arka yüzü gösterilmiştir. Kapalı karta çift tıklandığında kart açılmakta, açık 
    karta çift tıklandığında ise kart kapanmaktadır. Burada biz başlangıçta arka yüz resmini MainWindow sınıfının bir sınıf değişkeninde
    sakladık. Sınıf değişkenlerine ilgili sınıf ismiyle ya da o sınıf türünden bir değişkenle erişildiğini anımsayınız. Örneğimizde 
    her QLabel nesnesini yarattığımızda onun içerisinde aynı zamanda kartın ön yün resmime ilişkin QPixmap nesnesini de tuttuk. 
    Böylece kartın arka yüzü görüntülenirken aslında onun gerçek önyüz resmi nesnenin frontPixmap özniteliğinde bulunmaktadır. Ayrıca 
    her kartın açık mı yoksa kapalı mı olduğu yine nesnenin içerisinde bool türden isFront isimli öznitelikle tutulmuştur. Karta çift 
    tıklandığında bu özniteliğe bakılarak kartın ön yüzü ya da arka yüzü gösterilmiştir. Kartlar aynı zamanda sürüklenip bırakılabilmektedir. 
    Örneğimizde dizin içerisndeki kart resimlerine ilişkin ".png" dosyalarının yol ifadeleri glob fonksiyonuyla şöyle elde edilmiştir:

    for path in glob.glob('CardImages/*.png'):
        pass

    Arka yüz resimleri "CardImages/BackImages" isimli ayrı bir klasörde tutulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import random
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import glob

SCALE_RATIO = 1.2

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(1200, 800)
                
        pixmap = QPixmap('CardImages/BackImages/back-blue.png')
        MainWindow.backPixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))

        for path in glob.glob('CardImages/*.png'):
            pixmap = QPixmap(path)
            frontPixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
            x = random.randint(0, self.width() - frontPixmap.width())
            y = random.randint(0, self.height() - frontPixmap.height())
            
            labelImage = CardLabel('', self)
            labelImage.move(x, y)
            labelImage.setPixmap(MainWindow.backPixmap)
            labelImage.frontPixmap = frontPixmap
            labelImage.isFront = False
        
class CardLabel(QLabel):
    def __init__(self, text, parent):
        super().__init__(text, parent)
        self.parent = parent
                
    def mousePressEvent(self, me):
        super().mousePressEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.pressx = me.pos().x()
            self.pressy = me.pos().y()
            self.dragFlag = True
            self.raise_()
            
    def mouseReleaseEvent(self, me):
        super().mouseReleaseEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = False
            
    def mouseMoveEvent(self, me):
        super().mouseMoveEvent(me)
        if self.dragFlag:
            x = me.pos().x()
            y = me.pos().y()
            deltax = x - self.pressx
            deltay = y - self.pressy;
            self.move(self.x() + deltax, self.y() + deltay)
            
    def mouseDoubleClickEvent(self, me):
        self.setPixmap(MainWindow.backPixmap if self.isFront else self.frontPixmap)
        self.isFront = not self.isFront

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte 52 oyun kartını her satırda belli miktar kart olacak biçimde konumlandırdık. Bu örnekte programın başında bazı 
    sembolik sabitler tanımladık:

    CARDS_PER_ROW = 10
    X_MARGIN = 10
    Y_MARGIN = 10
    CARD_XMARGIN = 5
    CARD_YMARGIN = 5
    SCALE_RATIO = 1.2

    CARDS_PER_ROW her satırda kaç kart bulunacağını, X_MARGIN ve Y_MARGIN soldan ve yukarıdan verilecek boşlukları, CARD_XMARGIN ve 
    CARD_YMARGIN ise kartlar arasındaki yatay ve düşey boşlukları belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import glob

CARDS_PER_ROW = 10
CARD_XMARGIN = 5
CARD_YMARGIN = 5
X_MARGIN = 10
Y_MARGIN = 10
SCALE_RATIO = 1.2

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(1200, 800)
                
        pixmap = QPixmap('CardImages/BackImages/back-blue.png')
        MainWindow.backPixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
        
        y = Y_MARGIN
        x = X_MARGIN
        for index, path in enumerate(glob.glob('CardImages/*.png')):
            pixmap = QPixmap(path)
            frontPixmap = pixmap.scaled(int(pixmap.width() * SCALE_RATIO), int(pixmap.height() * SCALE_RATIO))
        
            labelImage = CardLabel('', self)
            labelImage.move(x, y)
            labelImage.setPixmap(MainWindow.backPixmap)
            labelImage.frontPixmap = frontPixmap
            labelImage.isFront = False
            
            if index % CARDS_PER_ROW == CARDS_PER_ROW - 1:
                x = X_MARGIN
                y += frontPixmap.height() + CARD_YMARGIN
            else:
                x += frontPixmap.width() + CARD_XMARGIN
        
class CardLabel(QLabel):
    def __init__(self, text, parent):
        super().__init__(text, parent)
        self.parent = parent
                
    def mousePressEvent(self, me):
        super().mousePressEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.pressx = me.pos().x()
            self.pressy = me.pos().y()
            self.dragFlag = True
            self.raise_()
            
    def mouseReleaseEvent(self, me):
        super().mouseReleaseEvent(me)
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = False
            
    def mouseMoveEvent(self, me):
        super().mouseMoveEvent(me)
        if self.dragFlag:
            x = me.pos().x()
            y = me.pos().y()
            deltax = x - self.pressx
            deltay = y - self.pressy;
            self.move(self.x() + deltax, self.y() + deltay)
            
    def mouseDoubleClickEvent(self, me):
        self.setPixmap(MainWindow.backPixmap if self.isFront else self.frontPixmap)
        self.isFront = not self.isFront

app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir pencerenin boyutu değiştirildiğinde framework tarafından sınıfın resizeEvent isimli metodu çağrılmaktadır. Metodun self dışındaki
    parametresi QResizeEvent sınıfı türündendir. Bu sınıfın size metodu pencerenin yeni boyutlarını bize vermektedir. Burada verilen 
    genişlik ve yükseklik çalışma alanının genişlik ve yüksekliğidir. Bu metot sayesinde birtakım widget'lar pencere genişletme ve 
    daraltma durumunda otomatik olarak büyütülüp küçültülebilemektedir. Örneğin:

    def resizeEvent(self, re):
        width = re.size().width()
        height = re.size().height()
        # ... 
       
    Burada pencenin boyutu her değiştirildiğinde yeni boyut elde edilmektedir. Ana pencere ilk kez görünür hale getirilirken de bir kez
    resizeEvent metodu çağrılmaktadır. 
    
    Burada bir nokta üzerinde de durmak istiyoruz. Penceler boyutlandırılırken pencere yönetici sistemler bunu iki biçimde yapabilmektedir. 
    Default durumda pencere fare hareket ettrilidiğinde anbean boyutlandırılır. Ancak bu ayar değiştirilip yalnızca parmak farenin 
    tuşundan çekildiğinde boyutlandırma da yapılabilmektedir. Birinci durumda (default durum) pencere boyutlandırılırken sürekli olarak 
    resizeEvent metodu çağrılacaktır. İkinci durumda ise yalnızca parmak farenin tuşundan kaldırıldığında resizeEvent metodu çağrılacaktır. 
    Bu ayar Windows sistemlerinde "Gelişmiş Sistem Ayarları/Ayarlar/Sürüklerken pencere içeriğini göster" seçenek kutusu (checkbox) ile 
    yapılmaktadır.

    Aşağıdaki örnekte pencere boyutlandırılırken sürekli olarak pencerenin yeni boyutu pencere başlığında yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        
    def resizeEvent(self, re):
        width = re.size().width()
        height = re.size().height()
        
        print(f'width = {width}, height = {height}')       
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi biz programın ana penceresini QMainWindow sınıfından türetip bir GUI elemanı setCentralWidget metodu ile merkezi 
    pencere hale getirdiğimizde otomatik olarak bu GUI eleman pencereyi kaplayacak hale getiriliyordu. Ancak eğer ana pencereyi QWidget 
    sınıfından türeterek yaratmak istiyorsanız bu işlemi kendinizin yapmalısınız. Örneğin:

    class MainWindow(QWidget):
        def __init__(self):
            super().__init__()       
            self.resize(800, 600)
            
            self.textEdit = QTextEdit(self)
            self.textEdit.setGeometry(100, 100, 100, 100)
            
        def resizeEvent(self, re):
            width = re.size().width()
            height = re.size().height()
            self.textEdit.setGeometry(0, 0, width, height)
            
    Burada ne zaman pencerenin boyutu değişse QTextEdit penceresi yeniden boyutlandırılarak ana pencereyi kaplar hale getirilmektedir.
    Aşağıda buna bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------
    
import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.textEdit = QTextEdit(self)
        self.textEdit.setGeometry(100, 100, 100, 100)
        
    def resizeEvent(self, re):
        width = re.size().width()
        height = re.size().height()
        self.textEdit.setGeometry(0, 0, width, height)
            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()
            
#------------------------------------------------------------------------------------------------------------------------------------
    Ne zaman bir pencere kapatılmak istense ilgili pencere sınıfının closeEvent isimli metodu çağrılmaktadır. Bu metot sayesinde programcı 
    ana pencere kapatılmadan önce bazı uyarıları ekrana çıkartabilmekte ve bazı son işlemleri yapabilmektedir. Örneğin bir text editör 
    uygulamasında kullanıcı ana pencereyi kapatmak istediğinde eğer editördeki yazılar daha önce save edilmemişse bu metot yardımıyla 
    bir messagebox eşliğinde uyarıda bulunulabilir. 
    
    closeEvent metodunun self dışında bir parametresi daha vardır. Bu parametre QCloseEvent sınıfı türündendir. QCloseEvent sınıfının 
    ignore metodu ile pencerenin kapatılma işlemi iptal edilebilmektedir. 
    
    Aşağıdaki örnekte pencere kapatılırken "Save Changes?" sorusunu soran bir diyalog penceresi çıkartılmıştır. Bu pencere "Cancel" 
    düğmesi ile kapatıldığında pencerenin kapatılması iptal edilmektedir. Ancak bu diyalog penceresinden "Yes" ya da "No" ile 
    çıkıldığında pencere kapatılıp program sonlandırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
                
    def closeEvent(self, ce):
        result = QMessageBox.information(self, 'warning', 'Save changes?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)     
        if result == QMessageBox.StandardButton.Cancel:
            ce.ignore()
                        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yazmış olduğumuz "notepad" uygulamasına pencere kapatılmak istendiğinde editör içerisindeki yazının save edilip 
    edilmeyeceğini soran bir diyalog penceresi ekleyelim. Burada önemli birkaç noktayı belirtmek istiyoruz:

    1) Bu tür programlarda eğer editör üzerindeki yazıda bir değişiklik yapılmadıysa hiçbir uyarıda bulunulmadan program sonlandırılmaktadır. 
    
    2) Editör üzerinde değişiklik yapıldıktan sonra "Save" işlemi yapılırsa yine hiç uyarıda bulunulmadan program sonlandırılmaktadır.

    Biz "notepad" uygulamasında bu durumu sağlamak için menüye ve araç çubuğuna "Save" elemanı ekledik. Burada "Save" seçildiğinde
    gerçek bir save işlemi yapılmamakla birlikte editörün document nesnesi üzerinde setModified(False) işlemi uygulanmıştır:

    def saveActionTriggeredHandler(self):
        self.textEdit.document().setModified(False)

    closeEvent metodunda bu duruma bakılmış ve ancak editör "modified" durumundaysa uyarı belirten diyalog penceresi çıkartılmıştır:

    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
        # ....
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
                
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        
        self.toolBar.addWidget(self.comboBoxFontSizes)
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Open selected')
        self.openAction.setEnabled(False)
        self.closeAction.setEnabled(True)
        
    def saveActionTriggeredHandler(self):
        self.textEdit.document().setModified(False)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        self.openAction.setEnabled(True)
        self.closeAction.setEnabled(False)
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de diyalog pencerelerinin nasıl oluşturulduğu üzerinde duracağız. 
    
    Her zaman üst penceresinin üzerinde görüntülenen "owned" pencerelere diyalog pencereleri denilmektedir. Örneğin daha önce görmüş 
    olduğumuz messagebox pencereleri birer diyalog penceresidir. Messagebox pencereleri hazır bir biçimde bulunmaktadır ve önceden 
    belirlenmiş olan bir konfigürasyonla görüntülenmektedir. Yani örneğin biz bu messagebox diyalog pencerelerine edit alanları, 
    listbox ve combox gibi GUI elemanlarını yerleştiremeyiz. Bu hazır diyalog pencereleri yalnızca belirli tuş takımlarının görünmesini 
    sağlamaktadır. Halbuki programcı kendi isteğine göre kendi diyalog pencerelerini de oluşturabilir. 
    
    Diyalog pencereleri "modal" ve "modeless" olmak üzere ikiye ayrılmaktadır. Modal diyalog pencerelerinde diyalog penceresi açıldığında 
    artık o kapatılana kadar arka plan etkileşimi yapılamaz. Halbuki modeless diyalog pencerelerinde pencere yine üst penceresinin 
    üzerinde görüntülense de arka plan etkileşim yapılabilmektedir. Messagebox penceresi modal bir diyalog penceresidir.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                31. Ders 28/06/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modal bir diyalog penceresinin sıdırdan ("custom" biçimde) oluşturulması şu adımlardan geçilerek yapılmaktadır:

    1) QDialog sınıfından bir sınıf türetilir. Türemiş sınıfın __init__ metodunda diyalog penceresinin üst penceresi parametre yoluyla 
    alınır ve taban sınıf olan QDialog sınıfının __init__ metoduna geçirilir. Örneğin:

    class MyModalDialog(QDialog, parent):
        def __init__(self):
            super().__init__(parent)

    Sınıfın __init__ metodunda GUI elemanlar pencereye yerleştirilir. Dialog pencerelerine tipik olarak pencereyi kapatabilmek için 
    "Ok" ve "Cancel" biçiminde iki ayrı düğme yerleştirilmektedir. "Ok" düğmesi diyalog penceresi içerisindeki işlemleri onaylayarak 
    çıkışı, "Cancel" düğmesi ise onaylamadan (yani diyalog penceresi içerisinde yaplan işlemleri iptal ederek) çıkışı sağlamaktadır. 
    Tabii bu tipik durumdur. "Ok" ve "Cancel" düğmeleri yerine bağlama uygun başka düğmeler de kullanılabilir. Bazı diyalog pencerelerinde 
    yalnızca "Ok" ya da bu anlama gelen tek bir düğme bulundurulmaktadır. Biz aşağıdaki örnekte diyalog penceremiz üzerinde "kişinin 
    adını soyadını, numarasını, çalışmak istediği şehri ve e-posta isteyip istemediği bilgisini alan bir diyalog penceresi oluşturduk. 
    Bu diyalog penceresine aynı zamanda çıkışı sağlamak için "Ok" ve "Cancel" biçiminde iki düğme de yerleştirdik:

    class MyModalDialog(QDialog):
        def __init__(self, parent):
            super().__init__(parent)
            self.resize(580, 200)
            self.setWindowTitle('Add Record')
            
            self.labelName = QLabel('Adı Soyadı:', self)
            self.labelName.move(10, 10)
            
            self.lineEditName = QLineEdit(self)
            self.lineEditName.move(10, 35)
            self.lineEditName.resize(250, 25)
            
            self.labelNo = QLabel('No:', self)
            self.labelNo.move(10, 70)
            
            self.lineEditNo = QLineEdit(self)
            self.lineEditNo.move(10, 90)
            self.lineEditNo.resize(250, 25)
            
            self.labelCities = QLabel('Şehir:', self)
            self.labelCities.move(300, 10)
            
            self.comboBoxCities = QComboBox(self)
            self.comboBoxCities.addItems(['Ankara', 'Adana', 'İzmir', 'Eskişehir', 'Kayseri', 'Ağrı', 
                                    'İstanbul', 'Sivas', 'Tokat', 'Antalya', 'Kayseri'])
            self.comboBoxCities.setGeometry(300, 35, 150, 30)
                    
            self.checkBoxEMail = QCheckBox('E-Posta gönderilsin mi?', self)
            self.checkBoxEMail.move(10, 140)
            
            self.pushButtonOk = QPushButton('Ok', self)
            self.pushButtonOk.move(400, 150)
            self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
            
            self.pushButtonCancel = QPushButton('Cancel', self)
            self.pushButtonCancel.move(480, 150)
            self.pushButtonCancel.clicked.connect(self.pushButtonCancelClickedHandler)

    2) QDialog sınıfından türetilen sınıf türünden nesne yaratılır ve sınıfın QDialog sınıfından gelen exec metodu çağrılır. Artık modal 
    diyalog penceresi açılmıştır. Modal diyalog penceresi exec metoduyla açıldığında mesja kuyruğu bu exec metodunun içerisindeki başka 
    bir mesaj döngüsü tarafından ele alınmaktadır. Dialog penceresi kapatıldığında akış exec metodundan devam eder. Yani modal diyalog 
    pencerelerinin ayrı bir mesaj döngüsü vardır. Modal diyalog penceresi açık olduğu sürece bu mesaj döngüsü etkin olmaktadır. 

    3) Diyalog penceresinin kapatılması diyalog penceresi tarafından QDialog sınıfından gelen done metodu ile yapılır. Bu done metodunun 
    parametresine argüman olarak QDialog.DialogCode.Accepted ya da QDialog.DialogCode.Rejected sembolik sabitleri girilir. Tipik olarak 
    "Ok" düğmesine tıklandığında done metodu QDialog.DialogCode.Accepted değeri ile, "Cancel" düğmesine tıklandığında ise QDialog.DialogCode.Rejected 
    değeri ile çağrılır. Diyalog penceresinin x kutucuğu tıklanarak kapatılması sırasında done metodu QDialog.DialogCode.Rejected değeri 
    ile çağrılmaktadır. Burada done metoduna girilen QDialog.DialogCode.Accepted ya da QDialog.DialogCode.Rejected değerleri exec metodunun 
    geri dönüş değeri haline gelmektedir. Dolayısıyla exec metodunu çağıran programcı aşağıdaki gibi bir kontrol yapabilir:

    result = myModalDialog.exec()
    if result == QDialog.DialogCode.Accepted:
        # ...
    elif result == QDialog.DialogCode.Rejected:
        # ....
        
    Tabii aslında elif kullanmaya gerek de yoktur. Zaten QDialog.DialogCode.Accepted ile çıkılmamışsa QDialog.DialogCode.Rejected ile 
    çıkılmış olunacaktır.

    PyQt5'te Accepted ve Rejected sembolik sabitleri QDialog.DialogCode sınıfı içerisinde değil doğrudan QDialog sınıfı içerisindedir. 
    Bu nedenle PyQt5'te bu sembolik sabitleri QDialog.Accepted ve QDialog.Rejected biçiminde kullanmalısınız.

    4) Modal diyalog penceresinde girilen bilgilerin işleme sokulması iki biçimde yapılabilmektedir. Programcı bu bilgileri QDialog 
    sınıfından türettiği sınıfın içerisinde "Ok" düğmesine basıldığında da işleme sokabilir, diyalog penceresi kapatıldıktan sonra 
    diyalog penceresini açtığı yerde de işleme sokabilir. Genellikle diyalog penceresinin açıldığı yerde bilgilerin işleme sokulması 
    tercih edilmektedir. Pekiyi diyalog penceresi kapatıldıktan sonra pencerede oluşan bilgileri nasıl alabiliriz? Aslında pencere 
    kapatılmış olsa da pencere içerisindeki GUI eleman nesneleri yaşıyor durumdadır. Dolayısıyla biz onların bilgisini alabiliriz. 
    Tabii nesne yönelimli programlama tekniğini daha sıkı uygulayan C++ gibi programlama dillerinde genellikle programcılar GUI elemanları 
    sınıfın private bölümünde gizleyip getter/setter üye fonksiyonlarla bunlara erişmektedir. Python'da da istenirse done işlemi 
    yapılmadan önce bu bilgiler nesnenin özniteliklerine aktarılabilir, oradan daha rahat alınabilir. Diyalog penceresinde oluşan 
    bilgilerin "geçerliliğinin sınanması (validate edilmesi)" da gerekebilmektedir. Bu sınama işleminin diyalog penceresi kapatılmadan 
    yapılması daha uygun olabilmektedir. 

    Aşağıda tipik bir modal diyalog penceresi örneği verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        self.centralWidget.setStyleSheet('QWidget {font-size: 10pt}')
        
        self.menuBar = self.menuBar()
        
        self.dialogPopup = QMenu('Dialog')
        self.menuBar.addMenu(self.dialogPopup)
        
        self.modalDialogAction = QAction('&Modal Dialog...')
        self.modalDialogAction.setShortcut('Ctrl+M') 
        self.modalDialogAction.triggered.connect(self.modalDialogActionTriggeredHandler)
        self.dialogPopup.addAction(self.modalDialogAction)
        
    def modalDialogActionTriggeredHandler(self):
        myModalDialog = MyModalDialog(self.centralWidget)
        result = myModalDialog.exec()
        if result == QDialog.DialogCode.Accepted:
            infoText = myModalDialog.name + '\n' + str(myModalDialog.no) + '\n' + myModalDialog.city + '\n' + str(myModalDialog.email)
            QMessageBox.information(self, 'Message', infoText)
     
class MyModalDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.resize(580, 200)
        self.setWindowTitle('Add Record')
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.labelName.move(10, 10)
        
        self.lineEditName = QLineEdit(self)
        self.lineEditName.move(10, 35)
        self.lineEditName.resize(250, 25)
        
        self.labelNo = QLabel('No:', self)
        self.labelNo.move(10, 70)
        
        self.lineEditNo = QLineEdit(self)
        self.lineEditNo.move(10, 90)
        self.lineEditNo.resize(250, 25)
        
        self.labelCities = QLabel('Şehir:', self)
        self.labelCities.move(300, 10)
        
        self.comboBoxCities = QComboBox(self)
        self.comboBoxCities.addItems(['Ankara', 'Adana', 'İzmir', 'Eskişehir', 'Kayseri', 'Ağrı', 
                                 'İstanbul', 'Sivas', 'Tokat', 'Antalya', 'Kayseri'])
        self.comboBoxCities.setGeometry(300, 35, 150, 30)
        
        self.checkBoxEMail = QCheckBox('E-Posta gönderilsin mi?', self)
        self.checkBoxEMail.move(10, 140)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.move(400, 150)
        self.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.move(480, 150)
        self.pushButtonCancel.clicked.connect(self.pushButtonCancelClickedHandler)
               
    def pushButtonOkClickedHandler(self):
        self.name = self.lineEditName.text()
        if self.name.strip()  == '':
            QMessageBox.information(self, 'Uyarı', 'Adı soyadı girilmemiş!')
            self.lineEditName.setFocus()
            return
        
        self.no = self.lineEditNo.text()
        
        try:
            self.no = int(self.no)
        except:
            QMessageBox.information(self, 'Uyarı', 'No geçersiz!')
            self.lineEditNo.setFocus()
            return
            
        self.city = self.comboBoxCities.currentText()
        self.email = self.checkBoxEMail.isChecked()
        
        self.done(QDialog.DialogCode.Accepted)
        
    def pushButtonCancelClickedHandler(self):
        self.done(QDialog.DialogCode.Rejected)
                    
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında framework'lerde bazı standart diyalog pencereleri zaten hazır biçimde bulunmaktadır. Örneğin pek çok framework'te dosya 
    seçmek için, renk seçmek için, font seçmek için hazır diyalog pencereleri bulunmaktadır. Biz de şimdi Qt'de hazır biçimde bulunan 
    bu diyalog pencereleri üzerinde duracağız. Qt'deki bu hazır diyalog pencerelerinin hepsi QDialog sınıfından türetilmiş durumdadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QFileDialog isimli sınıf QDialog sınıfından türetilmiştir. Bu sınıfın amacı "open" ve "save as" gibi işlemlerde dosya seçimini 
    sağlamaktır. QFileDialog sınıfının kullanımı şöyledir:

    1) Önce QFileDialog sınıfı türünden bir nesne yaratılır. QFileDialog sınıfının __init__ metoduna biz üst pencerenin pencere 
    nesnesi parametre olarak verilir. Bunun dışında istersek pencere başlık yazısı, diyalog penceresi açıldığında default olarak 
    görüntülenecek dizin ve filtre yazıları verilebilir. Aslında bunların hiçbiri de verilmeyebilir. Bu durumda default seçenekler 
    devreye girer. Bu bilgileri __init__ metodunda vermek yerine nesne yaratıldıktan sonra setXXX metotlarıyla da verebiliriz. Örneğin:

    fd = QFileDialog(self, 'Choose file')

    işlemi ile aşağıdaki işlem eşdeğerdir:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose file')

    Ya da örneğin:

    fd = QFileDialog(self, 'Choose file', r'c:\windows')

    Bu işlemin de eşdeğeri şöyledir:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose a file')
    fd.setDirectory(r'c:\windows')

    2) Diyalog penceresini açmak için yine QDialog sınıfından gelen exec metodu kullanılır. exec metodunun geri dönüş değeri yine
    diyalog penceresi "Open" düğmesi ile kapatılmışsa QDialog.DialogCode.Accepted, "Cancel" düğmesi ile kapatılmışsa QDialog.DialogCode.Rejeceted 
    biçiminde olur. Tabii programcı diyalog penceresi "Ok" düğmesi ile kapatılmışsa seçilen dosyayı işleme sokar. Örneğin:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose file')
    if fd.exec() == QDialog.DialogCode.Accepted:
        pass

    Yukarıda da belirttiğimiz gibi diyalog penceresinden "Ok" düğmesi ile çıkıldığında exec metodu QDialog.DialogCode.Accepted değeri 
    ile, Cancel düğmesiyle çıkıldığında QDialog.DialogCode.Rejected değeriyle geri dönmektedir.  

    3) QFileDialog penceresi kapatıldığında programcının elde ettiği tek şey seçilen dosyanın yol ifadesidir. QFileDialog penceresi 
    birden fazla dosya seçilebilecek biçimde de kullanılabildiğinden dolayı seçilen dosyaların yol ifadeleri sınıfının selectedFiles 
    metodu ile elde edilmektedir. Bu metot bize bir string listesi vermektedir. selectedFiles bize yalnızca seçilen dosyaların yol 
    ifadelerini verir. Dosyanın açılması gibi işlemler programcının sorumluluğundadır. Default olarak QFileDialog penceresi tek bir 
    dosyanın seçilmesine olanak sağlamaktadır. Dolayısıyla programcı seçilen dosyayı şöyle alabilir:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose file')
    if fd.exec() == QDialog.DialogCode.Accepted:
        path = fd.selectedFiles()[0]

    4) QFileDialog penceresi açıldığında her dosyanın gösterilmesi uygun olmaz. Örneğin bir resim gösterme programı yalnızca resim 
    dosyalarının seçilmesine olanak sağlamalıdır. Bir text editör de örneğin yalnızca text dosyalarının seçilmesine olanak sağlamalıdır. 
    Buna filtreleme işlemi denilmektedir. Filtreleme işlemi QFileDialog sınıfının __init__ metodunda ya da nesne yaratıldıktan sonra 
    sınıfın setNameFilter metoduyla da belirtilebilir. Bu metoda biz filtreleme yazısını veriririz. Filtreleme yazısı iki parçadan 
    oluşmaktadır. Birinci parça diyalog penceresinde görüntülenecek yazıyı belirtir. İkinci parça parantez içerisine yazılan kısımdan 
    oluşmaktadır. Bu gerçek filtrelemeyi yapan kısımdır. Tabii birden fazla filtre de yerleştirilebilmektedir. Bu durumda filtreler 
    arasında iki tane ';' karakteri olmaldır. Örneğin:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose a file')
    fd.setNameFilter('Text files (*.txt);;Python files (*.py);;Doc files (*.docx);;All files (*.*)')

    Burada dört tane filtre oluşturulmuştur. Genellikle programcılar "All files (*.*)" filtresini de fitrelerinin sonuna eklemektedir. 

    Parantez içerisindeki gerçek filtreyi oluşturan kısım ';' ile birden fazla filtreyi içerecek biçimde de oluşturulabilir. Örneğin:

    fd = QFileDialog(self)
    fd.setWindowTitle('Choose a file')
    fd.setNameFilter('Text files (*.txt;*.py);;Doc files (*.docx);;All files (*.*)')

    Burada "Text files" filtresi hem ".txt" dosyalarını hem de ".py" dosyalarını filtrelemektedir. Aslında yukarıda da belirttiğimiz 
    gibi QFileDialog sınıfının  __init__ metodunda biz sırasıyla "üst pencere nesnesini", "pencere başlık yazısını", "pence açıldığında 
    gösterilecek dizini" ve "filtreleme yazısını" bu sırada belirtebiliriz. Örneğin:

    fd = QFileDialog(self, 'Choose a file', '.', 'Text files (*.txt);;All files (*.*)')

    Aşağıdaki örnekte menüden "Fle/Open" seçildiğinde QFileDialog penceresi açılmıştır. Seçilen dosya konsol ekranına yazdırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        
        self.openAction = QAction('Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.filePopup.addAction(self.openAction)
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        
        menuBar.addMenu(self.filePopup)
        
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self)
        fd.setWindowTitle('Choose a file')
        fd.setDirectory('.')
        fd.setNameFilter('Text files(*.txt;*.py);;Python files(*.py);;Doc files(*.docx);;All files(*.*)')
        if fd.exec() == QDialog.DialogCode.Accepted:
            files = fd.selectedFiles()       
            print(files[0])
                       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QFileDialog penceresinde default durumda tek bir dosya seçilebilmektedir. Dosya seçimi konusunda belirleme yapmak için QFileDialog
    sınıfının setFileMode metodu kullanılmaktadır. Bu metoda girilecek sambolik sabitler ve anlamları şöyledir:

    QFileDialog.FileMode.AnyFile: Burada tek bir dosya seçilebilir. Dosyanın var olması gerekmez. Kullanıcı dosyayı klavyeden de 
    girebilir. 
    
    QFileDialog.FileMode.ExistingFile: Burada olan tek bir dosya seçilebilir. Olmayan bir dosya seçilememektedir. Yani dosyanın olup 
    olmadığı diyalog penceresi tarafından kontrol de edilmektedir. Bu default durumdur. 

    QFileDialog.FileMode.ExistingFiles: Olan birden fazla dosyanın seçilmesine olanak sağlamaktadır.

    QFileDialog.FileMode.Directory: Bu seçenekle yalnızca dizin seçilmesine olanak sağlanır. Bazı uygulamalarda kullanıcının dosya değil 
    dizin seçmesi de istenmektedir. 

    Aşağıdaki örnekte "Open..." menü elemanı seçildiğinde dosya seçme diyalog penceresi açılmamaktadır. Ancak çoklu seçime olanak 
    sağlanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        
        self.openAction = QAction('Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.filePopup.addAction(self.openAction)
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        
        menuBar.addMenu(self.filePopup)
        
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self)
        fd.setWindowTitle('Choose a file')
        fd.setDirectory('.')
        fd.setNameFilter('Text files(*.txt;*.py);;Python files(*.py);;Doc files(*.docx);;All files(*.*)')
        fd.setFileMode(QFileDialog.FileMode.ExistingFiles)
        if fd.exec() == QDialog.DialogCode.Accepted:
            text = '\n'.join(fd.selectedFiles())
            QMessageBox.information(self, 'Selected files', text)
                                   
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yapmış olduğumuz "notepad" programına dosya açma özelliğini ekleyelim. Programımızda menüden "File/Open" 
    seçildiğinde şunlar yapılıyor:

    def openActionTriggeredHandler(self):
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.Directory)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')
        if fd.exec() == QFileDialog.DialogCode.Accepted:
            with open(fd.selectedFiles()[0]) as f:
                text = f.read()
                self.textEdit.setText(text)

    Örnek bir bütün olarak aşağıda verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('MyNotepad')
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
                
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        
        self.toolBar.addWidget(self.comboBoxFontSizes)
        self.fullScreenActionTriggeredHandler()
             
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.Directory)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')
        if fd.exec() == QFileDialog.DialogCode.Accepted:
            with open(fd.selectedFiles()[0]) as f:
                text = f.read()
                self.textEdit.setText(text)
                
    def saveActionTriggeredHandler(self):
        self.textEdit.document().setModified(False)
                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()     

try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    QFileDialog sınıfının da çeşitli sinyalleri vardır. Örneğin bir dosya seçildikten sonra ya da dosyanın seçilmesi sırasında 
    sinyaller emit edilebilmektedir. Ancak bu sinyallere seyrek biçimde gereksinim duyulmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Dosya seçme işlemini kolaylaştırmak için QFileDialog sınıfında çeşitli static metotları bulundurulmuştur. Bu metotlar getXXX 
    biçiminde isimlendirilmiştir. Bu static metotlar da aslında QFileDialog nesnesi yaratıp exec işlemi yapmaktadır. 
    
    getOpenFileName metodu bizden sırasıyla üst pencere nesnesini, pencere başlık yazısını, açılışta görüntülenecek dizini, filtreleme 
    yazısını ister ve dosya seçme diyalog penceresini çıkartır. Metot seçilen dosyanın yol ifadesi ve filtreden oluşan ikili bir demete 
    geri dönmektedir. Tabii metodun parametreleri default değerlerle geçilebilir. Eğer diyalog penceresi "Cancel" tuşuyla kapatılmışsa 
    getOpenFileName metodu iki elemanı da boş string'ten oluşan bir demet vermektedir. Örneğin:

    path, _ = QFileDialog.getOpenFileName(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
    if path != '':
        print(path)

    Aşağıdaki örnekte QFileDialog sınıfının getOpenFileName metodu kullanılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        
        self.openAction = QAction('Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.filePopup.addAction(self.openAction)
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        
        menuBar.addMenu(self.filePopup)
        
    def openActionTriggeredHandler(self):
        path, _ = QFileDialog.getOpenFileName(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
        if path != '':
            print(path)
                                   
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QFileDialog sınıfının getOpenFileNames metodu birden fazla dosyanın seçilmesine olanak vermektedir. Metot yine bize bir demet 
    verir. Ancak demetin ilk elemanı bir string listesinden, ikinci elemanı yine o andaki aktif filtreleme yazısından oluşmaktadır. 
    Eğer diyalog penceresi "Cancel" düğmesi ile kapatılırsa bize boş bir liste ve boş bir string'ten oluşan bir demet verilmektedir. 
    Örneğin:

    paths, _ = QFileDialog.getOpenFileNames(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
    if paths:
        print(paths)

    Aşağıdaki örnekte getOpenFileNames metodu ile birden fazla dosya seçilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        
        self.openAction = QAction('Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.filePopup.addAction(self.openAction)
        self.openAction.triggered.connect(self.openActionTriggeredHandler)

        menuBar.addMenu(self.filePopup)
        
    def openActionTriggeredHandler(self):
        path, _ = QFileDialog.getOpenFileName(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
        if path:
            print(path)
                                   
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                32. Ders 29/06/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QFileDialog sınıfının getSaveFileName metodu "Save As" diyalog penceresi çıkartmaktadır. Yine metot ikili bir demete geri dönmektedir. 
    Demetin birinci elemanı save as işlemi için seçilen dosya isminden, ikinci elemanı aktif filtreleme yazısından oluşmaktadır. Diyalog 
    penceresinde eğer kullanıcı zaten olan bir dosyayı seçerse diyalog penceresi "üzerine yazılsın mı" biçiminde bir uyarı yazısı da 
    çıkartmaktadır. Ancak bu uyarı yazısının dosya üzerinde bir etkisi yoktur. Eğer pencereden "Cancel"" tuşu ile çıkılırsa metot iki 
    elemanı da boş string'ten oluşan bir demetle geri dönemktedir. Örneğin:

    path, _ = QFileDialog.getOpenFileName(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
    if path:
        print(path)

    Aşağıdaki örnekte getSaveSileName metoduna bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
                
        self.openAction = QAction('Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.filePopup.addAction(self.openAction)
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        
        self.saveAsAction = QAction('Save...')
        self.saveAsAction.setShortcut('Ctrl+S')
        self.saveAsAction.setIcon(QIcon('MenuIcons/Save.png'))
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        self.filePopup.addAction(self.saveAsAction)
             
        menuBar.addMenu(self.filePopup)
        
    def openActionTriggeredHandler(self):
        path, _ = QFileDialog.getOpenFileName(self, 'Choose a file', '.', 'Text files (*.txt;*py);;All files (*.*)')
        if path:
           print(path)
           
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.',  'Text files (*.txt;*py);;All files (*.*)')
        if path:
            print(path)
                            
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yapmış olduğumuz editöre "Save" ve "Save As.." işlemlerini ekleyelim. Burada dikkat edilmesi gereken nokta henüz
    editör hiç save edilmemişse (yani dosya ismi "Noname" biçimindeyse) "Save" seçildiği zaman aslında "Save As..." işleminin yapılmasıdır. 
    Kodun ilgi kısımları şöyledir:

    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
                           
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)

    Kod tekrarını engellemek için _saveFile ve _setWindowText isimli metotlar tanımlanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
import os.path
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
                                 
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        
                
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.saveAsAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        
        self.toolBar.addWidget(self.comboBoxFontSizes)
        self.fullScreenActionTriggeredHandler()
        
        self._setWindowTitle('Noname')
    
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
           
    def openActionTriggeredHandler(self):
        if self.textEdit.document().isModified():
                result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                        QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
                if result == QMessageBox.StandardButton.Cancel:
                return
                if result == QMessageBox.StandardButton.Yes:
                    self.saveActionTriggeredHandler()

        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                self.textEdit.setText(text)
                self._setWindowTitle(path)
                
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
                                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings.close()     
        
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında QFileDialog sınıfının getXXX isimli daha fazla metodu vardır. Biz bu metotların hepsi üzeerinde burada durmayacağız. 
    Bunların listesini vermekle yetineceğiz:

    getOpenFileNames
    getOpenFileUrl
    getOpenFileUrls
    getSaveFileUrl

    Bunları ilgili dokümanlardan inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Renk seçme işlemi için QColorDialog sınıfı kullanılmaktadır. Sınıfın genel kullanımı diğer hazır diyalog pencere sınıflarına 
    benzemektedir. Programcı önce QColorDialog sınıfı türünden bir nesne yaratır. Sonra sınıfın exec metodunu çağırır. Yine exec metodu 
    QColorDialog.DialogCode.Accepted ya da QColorDialog.DialogCode.Rejected değerleriyle geri dönemektedir. Diyalog penceresi kapatıldıktan 
    sonra seçilmiş olan renk sınıfın currentColor metoyla elde edilebilir. currentColor metodu bize bir QColor nesnesi vermektedir. 
    
    Qt'de renk kavramı QColor sınıfıyla temsil edilmektedir. Bir QColor nesnesinin içerisindeki rengin RGB bileşenleri sınıfın red, 
    green ve blue metotlarıyla elde edilebilir, setRed, setGreen ve setBlue metotlarıyla set edilebilir. Bir QColor nesnesi QColor 
    sınıfın __init__ metoduyla RGB ve Alpha değerleri belirtilerek yaratılabilir. Alpha değeri belirtilezse default durumda 255 (tam 
    saydamsız) kabul edilmektedir. Örneğin:

    color = QColor(255, 0, 0)
      
    Renk seçme diyalog penceresi açıldığında belli bir rengin seçili olması sağlanabilir. Bunun için sınıfın setCurrentColor 
    metodu kullanılmaktadır. 

    Aşağıdaki örnekte bir renkte seçme diyalog penceresi çıkartılıp seçilen renkle pencerenin zemin rengi boyanmıştır. Boyama 
    işleminin nasıl yapıldığına dikkat ediniz:

    def colorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(QColor(255, 0, 0))
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            color = colorDialog.currentColor()
            red = color.red()
            green = color.green()
            blue = color.blue()
            self.centralWidget.setStyleSheet(f'QWidget {{background-color: rgb({red}, {green}, {blue})}};')

    Style sheet ile renk set ederken RGB renklerini daha önce yapmış olduğumuz gibi şöyle belirtebiliriz:

    "QWidget {background-color: rgb(128, 128, 0)}"

    Ancak aynı işlem #rrggbb biçiminde bir yazı ile dde sağlanabilmektedir. Örneğin:

    "QWidget {background-color: #808000}"

    Burada rr değerleri kırmızı rengin tonal bileşeninin hex karşılığını, gg değeri yeşil rengin hex karşılığını ve gg değeri de
    mavi rengin hex karşılığını belirtmektedir. QColor sınıfının name isimli metodu zaten nesnenin tuttuğuna renge ilişkin #rrggbb
    yazısını geri döndürmektedir. Dolayısıyla yukarıdaki örnekte biz seçilen renk ile zemini şöyle de boyayabilirdik:

    def colorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(QColor(255, 0, 0))
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            color = colorDialog.currentColor()
            self.centralWidget.setStyleSheet(f'QWidget {{background-color: {color.name()} }};')
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        
        menuBar = self.menuBar()
        self.toolsPopup = QMenu('&Tools')
                
        self.colorAction = QAction('Color...')
        self.colorAction.setShortcut('Ctrl+Shift+C')
        self.colorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.toolsPopup.addAction(self.colorAction)
        self.colorAction.triggered.connect(self.colorActionTriggeredHandler)
        
        menuBar.addMenu(self.toolsPopup)
        
    def colorActionTriggeredHandler(self):
       colorDialog = QColorDialog(self)
       colorDialog.setCurrentColor(QColor(255, 0, 0))
       if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
           color = colorDialog.currentColor()
           self.centralWidget.setStyleSheet(f'QWidget {{background-color: {color.name()} }};')
                                              
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha önce yapmış olduğumuz editör uygulamasında menüye ve araç çubuğuna editör içerisindeki yazı rengini değiştirmekte
    kullanılan elemanlar ekledik. Burada yazı rengini ve semin rengini "style sheet" yoluyla değiştirdik. Ancak Qt'nin "style sheet" 
    özelliğinde  setStyleSheet metodu uygulandığında eski uygulanan özellikler reset durumuna çekilmektedir. Yani eğer biz birkaç 
    öğenin özelliklerini değiştireceksek tüm özellikleri tek hamlede oluşturup setStyleSheet metoduna vermeliyiz. Aşağıdaki örnekte
    editördeki yazının şekil rengi değiştirilirken onun daha set edilmiş olan zemin rengi reset edilmesin diye yalnızca yazının 
    şekil rengi değil aynı zamanda zemin rengi de style sheet'te belirtilmiştir:

    def backColorActionTriggeredHandler(self):
    colorDialog = QColorDialog(self)
    colorDialog.setCurrentColor(self.backColor)
    if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
        self.backColor = colorDialog.currentColor()
        self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
import os.path
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
        self.textColor = self.app_settings.get('textcolor', QColor(0, 0, 0))
        self.backColor = self.app_settings.get('backcolor', QColor(255, 255, 255))
                
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.optionsPopup = QMenu('&Options')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.saveAsAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                 
        self.textColorAction = QAction('&Text Color...')
        self.textColorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.textColorAction.setShortcut('Ctrl+T')
        self.textColorAction.triggered.connect(self.textColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.textColorAction)
        
        self.backColorAction = QAction('&Background Color...')
        self.backColorAction.setIcon(QIcon('MenuIcons/backcolor.png'))
        self.backColorAction.setShortcut('Ctrl+T')
        self.backColorAction.triggered.connect(self.backColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.backColorAction)
        
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.optionsPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.textColorAction)
        self.toolBar.addAction(self.backColorAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
        self.pushButtonColorReset = QPushButton('Color Reset', self.toolBar)
        self.toolBar.addWidget(self.pushButtonColorReset)
        self.pushButtonColorReset.clicked.connect(self.pushButtonColorResetClickedHandler)
        
        self.fullScreenActionTriggeredHandler()
        
        self._setWindowTitle('Noname')
    
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
           
    def openActionTriggeredHandler(self):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
            
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                self.textEdit.setText(text)
                self._setWindowTitle(path)
                
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
                                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def textColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.textColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.textColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                       
    def backColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.backColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.backColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                       
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def pushButtonColorResetClickedHandler(self):
        if QMessageBox.information(self, 'Warning', 'Colors will be set with default values, are you sure?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
            self.textColor = QColor(0, 0, 0)
            self.backColor = QColor(255, 255, 255)
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings['textcolor'] = self.textColor
        self.app_settings['backcolor'] = self.backColor     
        self.app_settings.close()     
        
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
                                            33. Ders 05/07/2025 – Cumartesi                                   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında QColorDialog sınıfının getColor isimli static metoduyla da renk seçme işlemini yapabiliriz. Tabii bu metot da kendi
    içerisinde QColorDialog sınıfı türünden nesne yaratıp exec işlemi yapmaktadır. Metodun parametrik yapısı şöyledir:

    getColor(initial: Union[QColor, GlobalColor] = white, parent: QWidget = None, title: str = '', 
        options: Union[ColorDialogOptions, ColorDialogOption] = QColorDialog.ColorDialogOptions()) -> QColor
    
    Metodun birinci parametresi siyalog penceresi açıldığında default seçili olan rengi, ikinci parametresi üst pencere nesnesini, 
    üçüncü parametresi ise pencere başlığında çıkarılacak yazıyı belirtmektedir. Örneğin:

    color = QColorDialog.getColor(QColor(255, 0, 0), self, 'Choose a color')

    Tabii eğer birinci parametreyi girmek istemiyorsanız diğer parametreleri isimli vermelisiniz:

    color = QColorDialog.getColor(parent=self, title='Choose a color')

    getColor metodu yine seçilen renge ilişkin QColor nesnesi ile geri dönmektedir. Ancak diyalog penceresi "Cancel "tuşu ile 
    kapatılırsa bu durumda metot geçersiz bir QColor nesnesi verir. Bunu anlayabilmek için ise QColor sınıfının isValid metodunun 
    çağrılması gerekmektedir. Örneğin:

     def colorActionTriggeredHandler(self):
        color = QColorDialog.getColor(parent=self, title='Choose a color')      
        if color.isValid():
            self.centralWidget.setStyleSheet(f'QWidget {{background-color: {color.name()} }};')
                                              
    Aşağıdaki örnekte getColor metodu ile renk seçme diyalog penceresi açılmıştır. Sonra diyalog penceresinden "Cancel" tuşu ile
    çıkılıp çıkılmadığına bakılmıştır. En nihayetinde de pencerenin zemin rengi seçilen renk ile boyanmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        
        menuBar = self.menuBar()
        self.toolsPopup = QMenu('&Tools')
                
        self.colorAction = QAction('Color...')
        self.colorAction.setShortcut('Ctrl+Shift+C')
        self.colorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.toolsPopup.addAction(self.colorAction)
        self.colorAction.triggered.connect(self.colorActionTriggeredHandler)
        
        menuBar.addMenu(self.toolsPopup)
        
    def colorActionTriggeredHandler(self):
      color = QColorDialog.getColor(parent=self, title='Choose a color')      
      if color.isValid():
        self.centralWidget.setStyleSheet(f'QWidget {{background-color: {color.name()} }};')
                                              
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Font seçmek için de hazır bir diyalog penceresi bulunmaktadır. Bu diyalog penceresi QFontDialog sınıfıyla temsil edilmiştir. Bu 
    sınıf da QDialog sınıfınından türetilmiştir. Diyalog penceresinin genel kullanımı diğerlerinde olduğu gibidir. Yani QFontDialog
    sınıfı türünden bir nesne yaratılır ve sınıfın exec metodu çağrılır. Seçilmiş olan font sınıfın currentFont metodu ile elde edilir. 
    Diayolog penceresi açıldığında bir fontun seçili olmasını sağlamak için sınıfın setCurrentFont metodu kullanılmaktadır. Örneğin:
    Örneğin:

    fd = QFontDialog(self)
    fd.setCurrentFont(QFont('Times New Roman', 14))
    if fd.exec() == QDialog.Accepted:
        # ...

    Aşağıdaki örnekte bir QFiontDialog penceresi çıkartılmış ve seçilen font bir QLabel nesnesine uygulanarak oradaki yazının 
    fontu değiştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        
        self.label = QLabel('', self)
        self.label.setGeometry(50, 10, 600, 200)
        self.label.setFont(QFont('Times New Roman', 16))
                        
        menuBar = self.menuBar()
        self.toolsPopup = QMenu('&Tools')
                
        self.fontAction = QAction('Font...')
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.toolsPopup.addAction(self.fontAction)
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        
        menuBar.addMenu(self.toolsPopup)
        
    def fontActionTriggeredHandler(self):
        fontDialog = QFontDialog(self)
        fontDialog.setCurrentFont(self.label.font())
        if fontDialog.exec() == QFileDialog.DialogCode.Accepted:
            font = fontDialog.currentFont()  
            
            self.label.setText(f'this font is "{font.family()}, {font.pointSize()}"')
            self.label.setFont(font)
                                                          
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()

#------------------------------------------------------------------------------------------------------------------------------------
    QFontDialog sınıfının da getFont isimli static bir metodu bulunmaktadır. Bu metot kendi içerisinde QFontDialog nesnesini yaratıp 
    exec işlemi uygulamaktadır. Metodun parametrik yapısı şöyledir:

    getFont(QFont, parent: QWidget = None, caption: str = '', options: 
            Union[FontDialogOptions, FontDialogOption] = QFontDialog.FontDialogOptions()) → (QFont, bool)
    
    Metodun parametresi diyalog penceresi açıldığında görüntülenecek olan default font'u, ikinci parametresi üst pencere nesnesini, 
    üçüncü parametresi pencere başlık yazısını belirtmektedir. Metot ikili bir demetle geri dönmektedir. Demetin birinci elemanı seçilen 
    fontu ikinci elemanı "Ok" düğmesi ile mi yoksa "Cancel" düğmesi ile mi çıkıldığını belirtmektedir. Örneğin:

    font, ok = QFontDialog.getFont(QFont('Cascadia Mono'), self, 'Choose Font' )
    if ok:
        self.textEdit.setCurrentFont(font)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
                    
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        
        self.label = QLabel('', self)
        self.label.setGeometry(50, 10, 600, 200)
        self.label.setFont(QFont('Times New Roman', 16))
                        
        menuBar = self.menuBar()
        self.toolsPopup = QMenu('&Tools')
                
        self.fontAction = QAction('Font...')
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.toolsPopup.addAction(self.fontAction)
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        
        menuBar.addMenu(self.toolsPopup)
        
    def fontActionTriggeredHandler(self):
        font, ok = QFontDialog.getFont(self.label.font(), self, 'Choose a font')
        if ok:
            self.label.setText(f'this font is "{font.family()}, {font.pointSize()}"')
            self.label.setFont(font)
                                                          
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki daha önce yapmış olduğumuz "notepad" uygulamasına font seçme diyalog penceresini de ekledik. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
import os.path
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
        self.textColor = self.app_settings.get('textcolor', QColor(0, 0, 0))
        self.backColor = self.app_settings.get('backcolor', QColor(255, 255, 255))
                
        self.move(pos)            
        self.resize(size)
               
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.optionsPopup = QMenu('&Options')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.saveAsAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
                 
        self.textColorAction = QAction('&Text Color...')
        self.textColorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.textColorAction.setShortcut('Ctrl+T')
        self.textColorAction.triggered.connect(self.textColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.textColorAction)
        
        self.backColorAction = QAction('&Background Color...')
        self.backColorAction.setIcon(QIcon('MenuIcons/backcolor.png'))
        self.backColorAction.setShortcut('Ctrl+T')
        self.backColorAction.triggered.connect(self.backColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.backColorAction)
        
        self.fontAction = QAction('&Font...')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.fontAction)
                
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.optionsPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.textColorAction)
        self.toolBar.addAction(self.backColorAction)
        self.toolBar.addAction(self.fontAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
        self.pushButtonColorReset = QPushButton('Color Reset', self.toolBar)
        self.toolBar.addWidget(self.pushButtonColorReset)
        self.pushButtonColorReset.clicked.connect(self.pushButtonColorResetClickedHandler)
        
        self.fullScreenActionTriggeredHandler()
        
        self._setWindowTitle('Noname')
    
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
           
    def openActionTriggeredHandler(self):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
            
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                self.textEdit.setText(text)
                self._setWindowTitle(path)
                
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
                                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def textColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.textColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.textColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                       
    def backColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.backColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.backColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()} }}; background-color: {self.backColor.name()}; }}')
            
    def fontActionTriggeredHandler(self):
        fontDialog = QFontDialog(self.textEdit.font(), self)
        if fontDialog.exec() == QDialog.DialogCode.Accepted:
            font = fontDialog.currentFont()
            self.textEdit.setFont(font)
                       
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def pushButtonColorResetClickedHandler(self):
        if QMessageBox.information(self, 'Warning', 'Colors will be set with default values, are you sure?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
            self.textColor = QColor(0, 0, 0)
            self.backColor = QColor(255, 255, 255)
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings['textcolor'] = self.textColor
        self.app_settings['backcolor'] = self.backColor     
        self.app_settings.close()     
        
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi modeless diyalag pencereleri arka plan etkileşiminin yapılabildiği özel diyalog pencereleridir. 
    Modeless diyalog pencerelerinde de yine diyalog penceresi her zaman onun üst penceresinin üstünde gözükür ancak arka plandaki 
    pencereyle etkileşim mümkündür.

    Modeless diyalog pencereleri aşağıdaki aşamalardan geçilerek oluşturulmaktadır:

    1) Önce yine QDialog sınıfınından bir sınıf türetilir. Yine taban sınıfın __init__ metodu çağrılırken üst pencere olarak diyalog 
    penceresinin üzerine açıldığı pencere verilmelidir. Modeless diyalog pencerelerinde genellikle üst pencere üzerinde arka planda 
    bazı işlemler yapılır. Bu nedenle üst pancerenin pencere nesnesinin modeless diyalog pencere sınıfında saklanması uygun olur. 
    Her ne kadar taban sınıfın __init__ metodu zaten bu üst pencere nesnesini nesnenin parent özniteliğinde saklıyorsa da kolaylık 
    oluşturmak amacıyla üst pencere nesnesi yine oluşturduğumuz sınıfın bir örnek özniteliğinde saklanabilir. Bu okunabilirliği ve 
    yazımı kolaylaştırmaktadır. Örneğin:
    
    Örneğin:

    class FindDialog(QDialog):
        def __init__(self, parent):
            super.__init__(parent)
            self.parentWidget = parent
            ...

    Tabii diyalog penceresinin içerisine yine GUI elemanlar yerleştirilir. 

    2) Pencerenin açlması exec metoduyla değil show metoduyla yapılmalıdır. Ayrıca diyalog pencere nesnesinin sınıfın bir özniteliğinde 
    saklanması gerekir. Örneğin:

    self.fd = FindDialog(self)
    self.fd.show()

    Modeless diyalog pencereleri pencere açıldıktan sonra akışı bekletmediği için pencere nesnesinin sınıfın örnek özniteliğinde 
    saklanması uygun olur. 

    3) Modeless diyalog pencereleri genellikle kullanıcılar tarafından X simgesine basılarak kapatılmaktadır. Ancak diyalog penceresi 
    içerisinde kapatma için ayrı bir düğme de bulundurulabilmektedir. Modeless diyalog pencereleri doğrudan sınıfın close metodu ile 
    kapatılır. (Anımsanacağı gibi modal diyalog pencereleri done metodu ile kapatılıyordu). Modelesss diyalog pencereleri açıldığında 
    akış modal diyalog pencerelerinde olduğu gibi bekletilmemektedir. Bu nedenle kullanıcının hangi tuşla modeless pencereyi kapattığının 
    genellikle bir önemi yoktur. Örneğin:

     def pushButtonCloseClickedHandler(self):
        self.close()
        
    Aşağıdaki basit bir modeless diyalog penceresi örneği verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        self.centralWidget.setStyleSheet('QWidget {font-size: 10pt}')
        
        self.menuBar = self.menuBar()
        
        self.dialogPopup = QMenu('Dialog')
        self.menuBar.addMenu(self.dialogPopup)
        
        self.modelessDialogAction = QAction('&Modelss Dialog')
        self.modelessDialogAction.setShortcut('Ctrl+M') 
        self.modelessDialogAction.triggered.connect(self.modelessDialogActionTriggeredHandler)
        self.dialogPopup.addAction(self.modelessDialogAction)
        
    def modelessDialogActionTriggeredHandler(self):
       self.fd = FindDialog(self)
       self.fd.show()
       self.modelessDialogAction.setEnabled(False)
              
class FindDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.mainWindow = parent
        
        self.resize(300, 100)
        self.setMaximumSize(300, 100)
        self.setMinimumSize(300, 100)
                
        self.labelFind = QLabel('Text to find:', self)
        self.labelFind.setGeometry(10, 10, 100, 20) 
                
        self.lineEditFind = QLineEdit(self)
        self.lineEditFind.setGeometry(10, 30, 150, 20) 
        
        self.pushButtonNext = QPushButton('Next', self)
        self.pushButtonNext.setGeometry(200, 20, 70, 30)
        
        self.pushButtonClose = QPushButton('Close', self)
        self.pushButtonClose.setGeometry(200, 60, 70, 30)
        self.pushButtonClose.clicked.connect(self.pushButtonCloseClickedHandler)
        
    def pushButtonCloseClickedHandler(self):
        self.close()
        self.mainWindow.modelessDialogAction.setEnabled(True)
                                      
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de "notepad" örneğimize "find" özelliği ekleyelim. QTextEdit nesnesinde editördeki belli bölgeyi seçmek için önce QTextEdit
    sınıfının textCursor metodu çağrılarak bir textCursor nesnesi elde edilir. Sonra bu textCursor nesnesi ile setPosition metodu 
    çağrılarak seçimin ilk karakter offseti belirlenir. Sonra yeniden aynı metot çağrılarak seçimin son karakter offset'i belirlenir. 
    Ancak bu bitim offset'i belirlenirken setPosition metodunun ikinci parametresi QTextCursor.MoveMode.KeepAnchor girilmelidir. 
    Bu bitim offset'i seçime dahil değildir. Sonra bu cursor nesnesi yeniden sınıfın setTextCursor metodu ile set edilir. Örneğin:

    textCursor = c.textCursor()
    textCursor.setPosition(10)
    textCursor.setPosition(20, QTextCursor.MoveMode.KeepAnchor)
    self.textEdit.setTextCursor(textCursor)   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                34. Ders 06/07/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha önce yapmış olduğumuz "notepad" uygulamasına "find" ve "replace" modeless diyalog pencereleri eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
import os.path
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        self.move(self.app_settings.get('pos', QPoint(100, 100)))
        self.resize(self.app_settings.get('size', QSize(800, 600))) 
        self.textColor = self.app_settings.get('textcolor', QColor(0, 0, 0))
        self.backColor = self.app_settings.get('backcolor', QColor(255, 255, 255))
        
        self.textEdit = QTextEdit(self)
        self.setCentralWidget(self.textEdit)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if self.app_settings.get('wordwrap', False) 
                else QTextEdit.LineWrapMode.NoWrap)
        self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
    
        self._setMenu()
        self._setToolBar()
        self._setWindowTitle('Noname')
    
    def _setMenu(self):
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.optionsPopup = QMenu('&Options')
        self.helpPopup = QMenu('&Help')
        
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.optionsPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.filePopup.addAction(self.openAction)
                
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.filePopup.addAction(self.saveAction)
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        self.filePopup.addAction(self.saveAsAction)
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')             
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.filePopup.addAction(self.closeAction)
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        self.filePopup.addMenu(self.openRecentPopup)
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.addAction(self.separatorAction)
        
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.editPopup.addAction(self.cutAction)
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.editPopup.addAction(self.copyAction)
   
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        self.editPopup.addAction(self.pasteAction)
        
        self.editPopup.addAction(self.separatorAction)
        
        self.findAction = QAction('&Find...')
        self.findAction.setIcon(QIcon('MenuIcons/find.png'))
        self.findAction.setShortcut('Ctrl+F')
        self.findAction.triggered.connect(self.findActionTriggeredHandler)
        self.editPopup.addAction(self.findAction)
        
        self.replaceAction = QAction('&Replace...')
        self.replaceAction.setIcon(QIcon('MenuIcons/replace.png'))
        self.replaceAction.setShortcut('Ctrl+R')
        self.replaceAction.triggered.connect(self.replaceActionTriggeredHandler)
        self.editPopup.addAction(self.replaceAction)
                 
        self.textColorAction = QAction('&Text Color...')
        self.textColorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.textColorAction.setShortcut('Ctrl+T')
        self.textColorAction.triggered.connect(self.textColorActionTriggeredHandler)
        self.optionsPopup.addAction(self.textColorAction)
        
        self.backColorAction = QAction('&Background Color...')
        self.backColorAction.setIcon(QIcon('MenuIcons/backcolor.png'))
        self.backColorAction.setShortcut('Ctrl+T')
        self.backColorAction.triggered.connect(self.backColorActionTriggeredHandler)
        self.optionsPopup.addAction(self.backColorAction)
        
        self.fontAction = QAction('&Font...')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        self.optionsPopup.addAction(self.fontAction)
                
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
        self.viewPopup.addMenu(self.themePopup)
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        self.themePopup.addAction(self.classicThemeAction)
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        self.themePopup.addAction(self.darkThemeAction)
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        self.themePopup.addAction(self.lightThemeAction)
                
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(self.app_settings.get('fullScreen', False))
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        self.viewPopup.addAction(self.fullScreenAction)
                     
        self.viewPopup.addAction(self.separatorAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(self.app_settings.get('wordwrap', False))
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
   
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
             
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
        self.helpPopup.addAction(self.aboutAction)
        
        self.fullScreenActionTriggeredHandler()
        
    def _setToolBar(self):
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.textColorAction)
        self.toolBar.addAction(self.backColorAction)
        self.toolBar.addAction(self.fontAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
        self.pushButtonColorReset = QPushButton('Color Reset', self.toolBar)
        self.toolBar.addWidget(self.pushButtonColorReset)
        self.pushButtonColorReset.clicked.connect(self.pushButtonColorResetClickedHandler)
        
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
           
    def openActionTriggeredHandler(self):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
            
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                self.textEdit.setText(text)
                self._setWindowTitle(path)
                
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
                                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')

    def findActionTriggeredHandler(self):
        fd = FindDialog(self)
        fd.show()
        
    def replaceActionTriggeredHandler(self):
        rd = ReplaceDialog(self)
        rd.show()
                
    def textColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.textColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.textColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                       
    def backColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.backColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.backColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()} }}; background-color: {self.backColor.name()}; }}')
            
    def fontActionTriggeredHandler(self):
        fontDialog = QFontDialog(self.textEdit.font(), self)
        if fontDialog.exec() == QDialog.DialogCode.Accepted:
            font = fontDialog.currentFont()
            self.textEdit.setFont(font)
                       
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def pushButtonColorResetClickedHandler(self):
        if QMessageBox.information(self, 'Warning', 'Colors will be set with default values, are you sure?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
            self.textColor = QColor(0, 0, 0)
            self.backColor = QColor(255, 255, 255)
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings['textcolor'] = self.textColor
        self.app_settings['backcolor'] = self.backColor     
        self.app_settings.close()     
        
class FindDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle('Find')        
        self.mainWindow = parent
        
        self.resize(300, 100)
        self.setMaximumSize(300, 100)
        self.setMinimumSize(300, 100)
                
        self.labelFind = QLabel('Text to find:', self)
        self.labelFind.setGeometry(10, 10, 100, 20) 
                
        self.lineEditFind = QLineEdit(self)
        self.lineEditFind.setGeometry(10, 30, 150, 20) 
        
        self.pushButtonNext = QPushButton('Next', self)
        self.pushButtonNext.setGeometry(200, 20, 70, 30)
        self.pushButtonNext.clicked.connect(self.pushButtonNextClickedHandler)
        
        self.pushButtonClose = QPushButton('Close', self)
        self.pushButtonClose.setGeometry(200, 60, 70, 30)
        self.pushButtonClose.clicked.connect(self.pushButtonCloseClickedHandler)
        
        self.lastPos = 0
        
    def pushButtonNextClickedHandler(self):
        findWhat = self.lineEditFind.text()
        if findWhat == '':
            QMessageBox.information(self, 'Warning', 'find text must be specified')
            self.lineEditFind.focus()
            return 
        text = self.mainWindow.textEdit.document().toPlainText()
        startPos = text.find(findWhat, self.lastPos)
        if startPos == -1:
            startPos = text.find(findWhat, 0)
            if startPos == -1:
                QMessageBox.information(self, 'Warning', 'Text not found')
                return
        endPos = startPos + len(findWhat)
        
        textCursor = self.mainWindow.textEdit.textCursor()
        textCursor.setPosition(startPos)
        textCursor.setPosition(endPos, QTextCursor.MoveMode.KeepAnchor)
        self.mainWindow.textEdit.setTextCursor(textCursor)
        self.lastPos = endPos
    
    def pushButtonCloseClickedHandler(self):
        self.close()
    
class ReplaceDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle('Replace')        
        self.mainWindow = parent
        
        self.resize(300, 140)
        self.setMaximumSize(300, 140)
        self.setMinimumSize(300, 140)
                
        self.labelFind = QLabel('Text to find:', self)
        self.labelFind.setGeometry(10, 10, 100, 20) 
                
        self.lineEditFind = QLineEdit(self)
        self.lineEditFind.setGeometry(10, 30, 170, 20) 
        
        self.labelReplace = QLabel('Replace text:', self)
        self.labelReplace.setGeometry(10, 55, 100, 20) 
                
        self.lineEditReplace = QLineEdit(self)
        self.lineEditReplace.setGeometry(10, 75, 170, 20) 
        
        self.pushButtonNext = QPushButton('Next', self)
        self.pushButtonNext.setGeometry(210, 30, 70, 30)
        self.pushButtonNext.clicked.connect(self.pushButtonNextClickedHandler)
        
        self.pushButtonReplace = QPushButton('Replace', self)
        self.pushButtonReplace.setGeometry(210, 65, 70, 30)
        self.pushButtonReplace.clicked.connect(self.pushButtonReplaceClickedHandler)
                
        self.pushButtonClose = QPushButton('Close', self)
        self.pushButtonClose.setGeometry(210, 100, 70, 30)
        self.pushButtonClose.clicked.connect(self.pushButtonCloseClickedHandler)
        
        self.lastPos = 0
     
    def pushButtonNextClickedHandler(self):
         findWhat = self.lineEditFind.text()
         if findWhat == '':
             QMessageBox.information(self, 'Warning', 'find text must be specified')
             self.lineEditFind.focus()
             return
         text = self.mainWindow.textEdit.document().toPlainText()
         self.startPos = text.find(findWhat, self.lastPos)
         if self.startPos == -1:
             self.startPos = text.find(findWhat, 0)
             if self.startPos == -1:
                 QMessageBox.information(self, 'Warning', 'Text not found')
                 return
         endPos = self.startPos + len(findWhat)
         
         textCursor = self.mainWindow.textEdit.textCursor()
         textCursor.setPosition(self.startPos)
         textCursor.setPosition(endPos, QTextCursor.MoveMode.KeepAnchor)
         self.mainWindow.textEdit.setTextCursor(textCursor)
         self.lastPos = endPos
            
    def pushButtonReplaceClickedHandler(self):
        replaceText = self.lineEditReplace.text()
        if replaceText == '':
            QMessageBox.information(self, 'Warning', 'replace text must be specified')
            self.lineEditFind.focus()
            return
        textCursor = self.mainWindow.textEdit.textCursor()  
        textCursor.removeSelectedText()
        textCursor.insertText(replaceText)
        self.mainWindow.textEdit.setTextCursor(textCursor)
        self.pushButtonNextClickedHandler()
            
    def pushButtonCloseClickedHandler(self):
     self.close()
          
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de GUI elemanların pencere içerisine koordinat kullanılarak yerleştirilmeleri oldukça zahmetlidir. Biz şimdiye kadar böyle yaptık. 
    Ancak GUI elemanların yerleştirilmesi işlemi görsel bir biçimde ismine "Qt Designer" denilen bir araçla da yapılabilmektedir. Qt 
    daha önce de belirttiğimiz gibi aslında bir C++ GUI framework'üdür. C++ programcıları için Qt'nin ismine "Qt Creator" denilen bir 
    IDE'si de vardır. C++ için Qt Creator IDE'si kendi içerisinde Qt Designer aracını da barındırmaktadır. Ancak Qt Creator IDE'si 
    oldukça büyük bir yer kaplamaktadır. Dolayısıyla Python programcıları sadece designer için bu IDE'yi kurmak istemezler. Qt Designer
    aşağıdaki bağlantıdan bağımısz bir program olarak da indirilebilmektedir:

    https://build-system.fman.io/qt-designer-download

    Qt Creator IDE'sinin son versiyonlarında artık IDE Python uygulamalarını da destekler hale getirilmiştir. Yani siz PyQt uygulamalarını
    ya da PySide uygulamalarını Spyder ya da PyCharm yerine QtCreator IDE'sini kullanarak da yazabilirsiniz. QtCreator IDE'sinin içerisinde 
    built-in biçimde Qt Designer bulunduğundan dolayı daha derli toplu bir çalışma sağlanabilmektedir. Ancak biz kursumuzda yine Spyder
    IDE'sini kullanacağız. Qt Designer programını da ayrıca kuracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt Designer açıldığında bize nasıl bir pencere oluşturmak istediğimizi sormaktadır. Biz menülü bir ana pencere (yani QMainWindow 
    sınıfından türetilmiş olan bir pencere), menüsüz bir ana pencere (yani QWidget sınıfından türetilmiş bir pencere) ya da bir diyalog 
    penceresi oluşturabiliriz. Soldaki "Widget Box"tan GUI elemanlar sürüklenerek pencereye bırakılabilmektedir. Bir GUI eleman sürüklenip 
    pencereye bırakıldıktan sonra onun üzerine tıklandığında sağ taraftaki "Property Editotor"den onun özellikleri set edilebilir. GUI 
    elemanların programda kullanılacak isimleri Propert Editor'deaki "Object Name" sekmesinde belirtilmektedir. 
    
    Qt Designer'da oluşturulan GUI tasarımı save edildiği zaman ".ui" uzantılı bir XML dosya oluşturulmaktadır. Yani Qt Designer'dan 
    elde edilen ürün bir ".ui" dsyasıdır. Bu ".ui" dosyası içerisinde desginer'da yapılan tüm görsel tasarımın bilgileri bulunmaktadır. 
    Bizim designer'da yaptığımız GUI tasarımını kullanabilmemiz için bu ".ui" dosyasından bir Python dosyası oluşturmamız geekir. İşte 
    bu işlem "pyuic6 (ya da Qt5 için puic5)" programı taragından yapılmaktadır. ("uic" sözcüğü "user inerface compiler" sözcüklerinden 
    kısaltma yapılarak uydurulmuştur.) "pyuic6" programı komut satırından aşağıdaki gibi kullanılmaktadır:

    pyuic6 -o <isim.py> <isim.ui>

    Buradaki "-o seçeneği" çıktı dosyasını isimlendirmek için kullanılmaktadır. Örneğin designer'da save ettiğimiz dosya "mainwindow.ui" 
    isminde olsun. pyuic6 programını şöyle kullanabiliriz:

    pyuic6 -o mainwindow.py mainwindow.ui

    pyuic6 programı PyQt kurulduğunda zaten hedef sisteme kopyalanmış olmaktadır. 
    
    Artık elimizde designer'da tasarladığımız GUI ekranı oluşturan bir Python programı vardır. Bu programın içerisinde Ui_XXX biçiminde 
    bir sınıf bulunur. Bu sınıfın ismindeki XXX aslında ana pencerenin objectName property'sinde belirtilen isimdir. Biz bu ismin 
    Ui_MainWindow olduğunu varsayalım. 

    Bu işlemlerden sonra iskelet bir PyQt programı yazılır. Programda oluşturulan Python dosyası import edilir. Örneğin:

    import mainwindow

    Sonra bu modüldeki Ui_XXX sınıfı türünden (örneğimizde Ui_MainWindow) bir nesne yaratılıp bu nesne sınıfın örnek özniteliğinde 
    saklanır. Örneğin:

    self.ui = mainwindow.Ui_MainWİndow()

    Sonra Ui_XXX sınıfının setuUi isimli metodu ana pencere nesnesi argüman yapılarak çağrılır. Örneğin:

    self.ui = mainwindow.Ui_MainWindow()
    self.ui.setupUi(self)

    Asıl işlemi yapan bu setupUi metodudur. Bu metot bizim GUI ekranda oluşturduğumuz GUI elemanları verdiğimiz pencere içerisine 
    yerleştirmektedir. Burada bir noktaya dikkat ediniz. pyuic6 tarafından üretilen dosyadaki Ui_XXX sınıfı bir pencere sınıfı değildir. 
    GUI elemanları designer'da belirtildiği gibi yaratan bir yardımcı sınıftır. Aşağıda üretilen Python dosyasını kullanan örnek bir
    program verilmiştir:

    import sys
    from PyQt6.QtCore import *
    from PyQt6.QtWidgets import *
    import mainwindow

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()       
            self.resize(800, 600)
            
            self.ui = mainwindow.Ui_MainWindow()
            self.ui.setupUi(self)
                    
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()

    Burada dikkat edilmesi gereken en önemli bir nokta vardır. Designer'da yapılan her değişiklikten sonra save işlemi ile ".ui" 
    dosyasının yeniden oluşturulması ve bu ".ui" dosyasından pyuic6 ile yeniden Python dosyasının elde edilmesi gerekmektedir. Designer 
    üzerinde yapılan değişiklik otomatik bir biçimde sizin kodunuza yansıtılmamaktadır.

    Pekiyi Designer tarafından üretilen kodda sinyal/slot işlemeleri nasıl yapılmaktadır? Biz designer'da bir GUI elemanı sürükleyip 
    pencereye bıraktığımızda bu GUI eleman aslında Ui_XXX sınıfının bir örnek özniteliği biçiminde oluşturulmaktadır. Bu örnek özniteliği 
    bu GUI elemana desginer'da verdiğimiz "objectName" ismiyle oluşturulmaktadır. Örneğin biz designer'da bir düğmeyi sürükleyip bırakıp 
    "objectName" ismi olarak "pushButtonOk" vermiş olalım. Bu durumda biz bu nesneye self.ui.pushButtonOk ifadesiyle erişebiliriz. 
    Dolayısıyla sinyal bağlantısını kod üzerinden aşağıdaki gibi yapabiliriz:
    
    self.ui.pushButtonOk.clicked.connect(self.pushButtonOkHandler)

    Ayrıca istenirse built-in sinyal slot bağlantıları hiç kod yazmadan "desginer'daki sinyal slot editörüyle" de oluşturulabilmektedir. 
    Ancak PyQt'de yalnızca zaten var olan sinyal ve slot'lar da birbirine bağlanabilmektedir. Bunun için menü ya da araç çubuğundan 
    "Edit Signal/Slot" seçilir. Sonra fare hareketi ile sinyal slot bağlantısı kurulabilir. Bir GUI elemanın bir sinyali başka bir 
    GUI elemanın slotuna bu sayede bağlanabilir. 
    
    Aşağıda designer kullanılarak oluşturulmuş olan "maindow.py" dosyasının kullanılmasına ilişkin bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
import mainwindow

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.ui = mainwindow.Ui_MainWindow()
        self.ui.setupUi(self)
        
        self.ui.pushButtonOk.clicked.connect(self.pushButtonOkClickedHandler)
            
    def pushButtonOkClickedHandler(self):
        print('Ok')   
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                        35. Ders 12/07/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    GUI elemanların otomatik yerleştirilmesi için Qt'de ismine layout nesneleri denilen bir grup nesne kullanılmaktadır. Layout nesneleri 
    birer pencere değildir. Programcı bir layout nesnesini yaratır. Sonra GUI elemanlarını bu layout sınıflarının addWidget ve insertWidget 
    metotları ile layout içerisine yerleştirir. Programcı layout nesnelerinin içerisine layout nesnelerini de yerleştirebilmektedir. 
    Bunun için layout sınıflarının addLayout ve insertLayout metotları kullanılır. Yani layout içerisine widget yerleştirmek için addWidget 
    ve insertWidget metotları, layout içerisine layout yerleştirmek için addLayout ve insertLayout metotları kullanılmaktadır. Qt'deki 
    tüm layout sınıfları QLayout isimli bir sınıftan türetilmiştir. Layout sınıflarının türetme şeması şöyledir:
                            
                                                   QLayout 
             QBoxLayout               QFormLayout             QGridLayout         QStackedLayout
    QHBoxLayout       QVBoxLayout
    
    Bu türemte şemasından QHBoxLayout ve QVBoxLayout sınıflarının QBoxLayout sınıfından, QBoxLayout sınıfının da QLayout sınıfından 
    türetildiği görülmektedir. 

    Layout nesneleri birer pencere (yani widget) değildir. Dolayısıyla bunların pencerelere ilişkin özellikleri yoktur. Anımsanacağı 
    gibi tüm pencereler QWidget sınıfından türetilmiş durumdadır. Halbuki QLayout sınıfı QWidget sınıfından türetilmemiştir. 

    Bir pencereye (yani widget'a) tek bir layout nesnesi iliştirilebilir. Pencereye layout nesnesini iliştirebilmek için QWidget 
    sınıfının setLayout metodu kullanılmaktadır. Programcı tipik olarak layout nesnelerinin içerisine GUI elemanlarını ve başka 
    layout nesnelerini yerleştire yerleştire tek bir layout nesnesi elde eder. Bunu da programın ana penceresine setLayout metodu 
    ile iliştirir. QMainWindow sınıfının ana penceresinin merkezi pencere pencere olduğunu anımsayınız. Bu nedenle eğer QMainWindow 
    kullanıyorsanız teke düşürdüünüz layout nesnesini be mekezi pencereye setLayout yapmalısınız.

    Layout nesnelerinin içerisine yerleştirilen pencereler konumlandırılmaz. Zaten konumlandırma layout nesneleri tarafından yapılmaktadır. 
    Ancak bu pencereler boyutlandırılabilir. Layout nesnelerinin içerisindeki pencereler resize edildiğinde bunların davranışları layout 
    nesneleri arasında farklılık gösterebilmektedir. 

    Layout nesneleri ile hizalama yaptığımızda font gibi pek çok öğeyi değiştirdiğimiz zaman hizalama otomatik olarak yeni özelliklere
    göre ayarlanmaktadır. Halbuki manuel yerleştirme yapıldığı zaman GUI elemanlar üzerindeki değişikliklerden kod çabuk etikilenmektedir. 

    Layout nesneleri ile işlemler kodlama yoluyla yapılabileceği gibi designer yoluyla da yapılabilmektedir. Tabii daha önce belirttiğimiz
    gibi desginer da kod oluşturarak işlemini yapmaktadır. Biz kursumuzda konunun iyi anlaşılması için layout işlemlerini önce kod 
    ile sonra da designer kullanarak yapacağız.    
#------------------------------------------------------------------------------------------------------------------------------------
                                  
#------------------------------------------------------------------------------------------------------------------------------------
    QHBoxLayout nesnesi ona iliştirilmiş olan pencerereleri yatay bir biçimde görüntülemektedir. Default olarak bir pencereye setLayout 
    ile bir QHBoxLayout iliştirilirse bu QHBoxLayout düşey bakımdan pencerenin ortasında görüntülenir. Ancak yatay bakımdan pencere 
    genişletilip daraltıldıkça layout içerisindeki pencereler de "size policy" özellikleri uygunsa tüm genişliği kaplayacak biçimde 
    kendini genişletip daraltır. 

    Aşağıdaki örnekte beş tane QPushButton nesnesi addWidget metodu ile bir HBoxLayout nesnesine yerleştirilmiştir. En sonunda bu 
    HBoxLayout nesnesi de QWidget sınıfının setLayout metodu ile ana pencereye iliştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.pushButton1 = QPushButton('Button-1', self)
        self.pushButton2 = QPushButton('Button-2', self)
        self.pushButton3 = QPushButton('Button-3', self)
        self.pushButton4 = QPushButton('Button-4', self)
        self.pushButton5 = QPushButton('Button-5', self)
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addWidget(self.pushButton1)
        self.hBoxLayout.addWidget(self.pushButton2)
        self.hBoxLayout.addWidget(self.pushButton3)
        self.hBoxLayout.addWidget(self.pushButton4)
        self.hBoxLayout.addWidget(self.pushButton5)
        
        self.mainWidget.setLayout(self.hBoxLayout)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QVBoxLayout sınıfı QHBoxLayout sınıfının düşey yerleştirme yapan biçimidir. QVBoxLayout nesnesine yerleştirme yapılırsa onun 
    içerisindeki öğeler düşey bir biçimde konumlandırılır. Aşağıdaki örnekte bu kez beş tane QPushButton nesnesi QVoxLayout içerisine 
    yerleştirilmiştir. Sonra da bu nesne setLayout metodu ile ana pencereye iliştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.pushButton1 = QPushButton('Button-1', self)
        self.pushButton2 = QPushButton('Button-2', self)
        self.pushButton3 = QPushButton('Button-3', self)
        self.pushButton4 = QPushButton('Button-4', self)
        self.pushButton5 = QPushButton('Button-5', self)
        
        self.vBoxLayout = QVBoxLayout()
        self.vBoxLayout.addWidget(self.pushButton1)
        addWidget(self.pushButton2)
        self.vBoxLayout.addWidget(self.pushButton3)
        self.vBoxLayout.addWidget(self.pushButton4)
        self.vBoxLayout.addWidget(self.pushButton5)
        
        self.mainWidget.setLayout(self.vBoxLayout)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Tipik olarak programcı layout nesnelerinin içerisine GUI elemanlarını (yani widget nesnelerini) yerleştirir. Sonra layout nesnelerini 
    layout nesnelerinin içerisine yerleştire yerleştire tek bir layout nesnesi elde eder. Onu da ana pencereye setLayout metodu ile 
    iliştirir. Layout nesnelerinin genellikle sınıfın örnek özniteliği olarak saklanmasına gerek kalmamaktadır. Ancak bazı durumlarda 
    layout nesnelerine farklı metotlardan erişim istenebilir. 

    Aşağıdaki örnekte üç QHBoxLayout nesnesi bir QVBoxLayout nesnesi içerisine yereştirilmiş en sonunda bu QVBoxLayout nesnesi setLayout 
    metodu ile ana pencereye iliştirilmiştir. Yapılan işlemler sembolik olarak aşağıda gösterilmiştir:
    
    self.hBoxLayout1 => self.labelName + self.lineEditName
    self.hBoxLayout2 => self.labelNo + self.lineEditNo
    self.hBoxLayout3 => self.pushButtonOk + self.pushButtonCancel
    self.vBoxLayout => self.hBoxLayout1 + self.hBoxLayout2 + self.hBoxLayout3
    self.mainWidget => self.vBoxLayout

    Aşağıdaki örnekte QLabel nesneleri ile QLineEdit nesneleri aynı hizada gözükmeyecektir. Halbuki QLineEdit nesnelerinin aynı 
    hizada ve aynı genişlikte görüntülenmesi istenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(300, 100)
        self.setMaximumSize(300, 100)
        self.setMinimumSize(300, 100)

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.lineEditName = QLineEdit(self)
        
        self.labelNo = QLabel('No:', self)
        self.lineEditNo = QLineEdit(self)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonCancel = QPushButton('Cancel', self)
        
        self.hBoxLayout1 = QHBoxLayout()
        self.hBoxLayout1.addWidget(self.labelName)
        self.hBoxLayout1.addWidget(self.lineEditName)
                
        self.hBoxLayout2 = QHBoxLayout()
        self.hBoxLayout2.addWidget(self.labelNo)
        self.hBoxLayout2.addWidget(self.lineEditNo)
        
        self.hBoxLayout3 = QHBoxLayout()
        self.hBoxLayout3.addWidget(self.pushButtonOk)
        self.hBoxLayout3.addWidget(self.pushButtonCancel)
        
        self.vBoxLayout = QVBoxLayout()
        self.vBoxLayout.addLayout(self.hBoxLayout1)
        self.vBoxLayout.addLayout(self.hBoxLayout2)
        self.vBoxLayout.addLayout(self.hBoxLayout3)
        
        self.mainWidget.setLayout(self.vBoxLayout)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki form'da QLabel nesnelerinin ve QLineEdit nesnelerinin hizalı görünmesi isteniyorsa şöyle bir yöntem de izelenebilir:
    İki QLabel nesnesi bir VBoxLayout içerisine, iki QLineEdit nesnesi başka bir VBoxLayout içerisine yerleştirilir. Sonra bu iki 
    VBoxLoyout nesnesi bir HBoxLayout nesnesi içerieine yerleştirilir. İki düğme de bir HBoxLoayout içerisine yerleştirilirse nihai 
    olarak eleimizde iki HBoxLayout nesnesi bulunur. Bunları teke düşürmek için onları bir QVBoxLayout içerisine yerleştirebiliriz. 
    En nihayetinde onu da ana pencereye iliştirebiliriz. Bu işlemleri sembolik olarak şmyle gösterebiliriz:

    self.vBoxLayout1 => self.labelName + self.labelNo
    self.vBoxLayout2 => self.lineEditName + self.lineEditNo
    self.hBoxLayout1 => self.vBoxLayout1 + self.vBoxLayout2
    self.hBoxLayout2 => self.pushButtonOk + self.pushButtonCancel
    self.vBoxLayout3 => hBoxLayout1 + hBoxLayout2
    self.mainWidget => self.vBoxLayout3
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.setWindowTitle('Form')
        self.resize(300, 100)   
        self.setMaximumSize(500, 100)   
        self.setMinimumSize(300, 100)   
               
        self.setStyleSheet('QWidget {font: 14}')

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.lineEditName = QLineEdit(self)
        
        self.labelNo = QLabel('No:', self)
        self.lineEditNo = QLineEdit(self)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonCancel = QPushButton('Cancel', self)
        
        self.vBoxLayout1 = QVBoxLayout()
        self.vBoxLayout1.addWidget(self.labelName)
        self.vBoxLayout1.addWidget(self.labelNo)
        
        self.vBoxLayout2 = QVBoxLayout()
        self.vBoxLayout2.addWidget(self.lineEditName)
        self.vBoxLayout2.addWidget(self.lineEditNo)
        
        self.hBoxLayout1 = QHBoxLayout()
        self.hBoxLayout1.addLayout(self.vBoxLayout1)
        self.hBoxLayout1.addLayout(self.vBoxLayout2)
        
        self.hBoxLayout2 = QHBoxLayout()
        self.hBoxLayout2.addWidget(self.pushButtonOk)
        self.hBoxLayout2.addWidget(self.pushButtonCancel)
        
        self.vBoxLayout3 = QVBoxLayout()
        self.vBoxLayout3.addLayout(self.hBoxLayout1)
        self.vBoxLayout3.addLayout(self.hBoxLayout2)
        
        self.mainWidget.setLayout(self.vBoxLayout3)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki gibi form'ları daha pratik oluşturmak için QFormLayout isimli bir layout sınıfı da bulundurulmuştur. Bu layout sınıfının
    ikişerli elemanları eklemeye yarayan addRow metodu vardır. addRow metodu iki widget ya da tek bir layout nesnesi almaktadır. Tipik 
    olarak addRow metoduna bir QLabel ve bir de QLineEdit nesnesi verilir. Biz iki QPushButton nesnesini bir HBoxLayout içerisine 
    yerleştirerek bunu da addRow ile QFormLayout nesnesine ekleyebiliriz. Aşağıdaki örnekte sebolik olarak şu işlemler yapılmıştır:

    self.formLayout => addRow(self.labelName, self.lineEditName)
    self.formLayout => addRow(self.labelNo, self.lineEditNo)
    self.hBoxLayout => self.psuhButtonOk + self.pushButtonCancel
    self.formLayout => addRow(self.hBoxLayout
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.setWindowTitle('Form')
        self.resize(300, 100)   
        self.setMaximumSize(500, 100)   
        self.setMinimumSize(300, 100)   
               
        self.setStyleSheet('QWidget {font: 14}')

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.lineEditName = QLineEdit(self)
        
        self.labelNo = QLabel('No:', self)
        self.lineEditNo = QLineEdit(self)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonCancel = QPushButton('Cancel', self)
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addWidget(self.pushButtonOk)
        self.hBoxLayout.addWidget(self.pushButtonCancel)
    
        
        self.formLayout = QFormLayout()
        self.formLayout.addRow(self.labelName, self.lineEditName)
        self.formLayout.addRow(self.labelNo, self.lineEditNo)
        self.formLayout.addRow(self.hBoxLayout)
       
        self.mainWidget.setLayout(self.formLayout)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Layout nesnelerinin oluşturulması Designer'da oldukça kolaydır. Bir grup widget ve/veya layout nesnesi seçilir. Farenin sağ tuşuna 
    basılır. Bağlam menüsünden hangi layout nesnesi kullanılacaksa o seçilir. En sonunda ana pencerede sağ tuşa basılarak benzer biçimde 
    setLayout işlemi menü yoluyla yapılır. Ya da aynı işlemler Qt Designer'daki araç çubuğu ile de yapılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan layout sınıflarından biri de QGridLayout sınıfıdır. Bu sınıf sanki hücrelerden oluşan bir grid oluşturup ilgili 
    widget ya da layout nesnelerini bu grid'teki hücrelere yerleştirmektedir. Yine QGridLayout sınıfının addWidget ve addLayout metotları 
    vardır. Ancak bu metotlar grid içerisinde hücreyi belirlemek için satır ve sütun numaralarını ve düşey ve yatay yayılım (span) 
    miktarlarını bizden almaktadır. Eğer yatay ve düşey yaylım miktarları verilmezse default 1 alınmaktadır. 
    
    QGridLayout nesnesi yaratılırken matrisin satır ve sütun uzunluğu belirtilmez. Zaten addWidget ve addLayout yapılırken satır ve 
    sütun uzunlukları otomatik belirlenmektedir. 

    Aşağıdaki örnekte QGridLayout nesnesinin hücrelerine iki QLabel, iki QLineEdit ve bir de QHBoxLayout yerleştirilmiştir. İki 
    QPushButton nesnesi bir QHBoxLayout içerisine yerleştirilip span özelliği ile grid'in iki sütununun kaplanması sağlanmıştır. 
    Aşağıdaki örnekte yapılanları sembolik olarak şöyle ifade edebiliriz:

    self.gridLayout => addWidget(self.labelName, 0, 0, 1, 1)
    self.gridLayout => addWidget(self.lineEditName, 0, 1, 1, 1)
    self.gridLayout => addWidget(self.labelNo, 1, 0, 1, 1)
    self.gridLayout => addWidget(self.lineEditNo, 1, 1, 1, 1)
    hBoxLayout => self.pushButtonOk + self.pushButtonCancel
    self.gridLayout => addLayout(self.hBoxLayout, 2, 0, 1, 2)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.setWindowTitle('Form')
        self.resize(300, 100)   
        self.setMaximumSize(500, 100)   
        self.setMinimumSize(300, 100)   
               
        self.setStyleSheet('QWidget {font: 14}')

        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.labelName = QLabel('Adı Soyadı:', self)
        self.lineEditName = QLineEdit(self)
        
        self.labelNo = QLabel('No:', self)
        self.lineEditNo = QLineEdit(self)
        
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonCancel = QPushButton('Cancel', self)
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addWidget(self.pushButtonOk)
        self.hBoxLayout.addWidget(self.pushButtonCancel)
        
        self.gridLayout = QGridLayout()
        self.gridLayout.addWidget(self.labelName, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.lineEditName, 0, 1, 1, 1)
        self.gridLayout.addWidget(self.labelNo, 1, 0, 1, 1)
        self.gridLayout.addWidget(self.lineEditNo, 1, 1, 1, 1)
        
        self.gridLayout.addLayout(self.hBoxLayout, 2, 0, 1, 2)

        self.mainWidget.setLayout(self.gridLayout)
                                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
   Az kullanılan diğer bir layout sınıfı da QStackedLayout sınıfıdır. Bu layout sınıfı aynı alanı kullanan bir grup pencerenin yalnızca 
   birinin görüntülenmesini ve görüntülenen pencerenin de değiştirilebilmesini sağlamaktadır. StackedLayout sınıfının setCurrentIndex 
   ve SetCurrentWidget metotları nesnenin göstereceği pencereyi değiştirmekte kullanılmaktadır. 
   
   Programcı bir QStackedLayout nesnesi yaratır. Sonra ona addWidget metotlarıyle GUI eleman ekler. Görüntülecenek GUI eleman QStackedLayout
   sınıfının setCurrentIndex ya da setCurrentWidget metotlarıyle değiştirilebilmektedir. 

   Aşağıdaki örnekte bir QHBoxLayout içerisinde bir StackedLayout bir de QComboBox nesneleri yerleştirilmiştir. StackedLayout nesnesine 
   de içerisine çeşitli meyve resimleri QLabel nesnesi olarak yerleştirilmiştir. Combobox'tan bir seçim yapıldığında doğrudan combobox'ın 
   currentIndexChanged sinyali stackedlayout'un setCurrentIndex metoduna bağlanmıştır. Böylece combobox'tan bir seçim yapıldığında 
   ilgili resim görüntülenmektedir. Aşağıda yapılanları semboil olarak şöyle ifade edebiliriz:

    self.stackedLayout => self.labelWaterMelon + self.labelCherry + self.labelBanana + self.labelRaterMelon + self.labelRaterMelon 
            + self.Apple
    self.hBoxLayout => self.stackedLayout + self.comboBox
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import mainwindow

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)        
        
        self.labelWaterMelon = QLabel(self.mainWindow)
        self.labelWaterMelon.setPixmap(QPixmap('FruitImages/watermelon.png'))
                
        self.labelCherry = QLabel(self.mainWindow)
        self.labelCherry.setPixmap(QPixmap('FruitImages/cherry.png'))
        
        self.labelBanana = QLabel(self.mainWindow)
        self.labelBanana.setPixmap(QPixmap('FruitImages/banana.png'))
        
        self.labelMandarin = QLabel(self.mainWindow)
        self.labelMandarin.setPixmap(QPixmap('FruitImages/mandarin.png'))
        
        self.labelApple = QLabel(self.mainWindow)
        self.labelApple.setPixmap(QPixmap('FruitImages/apple.png'))
        
        self.fruitDict = {'Water Melon': self.labelWaterMelon, 
                          'Cherry': self.labelCherry, 
                          'Banana': self.labelBanana,
                          'Mandarin': self.labelMandarin, 
                          'Apple': self.labelApple}
        
        self.stackedLayout = QStackedLayout()
        for name in self.fruitDict:
            self.stackedLayout.addWidget(self.fruitDict[name])
        
        self.comboBox = QComboBox(self.mainWindow)
        self.comboBox.setGeometry(600, 10, 100, 50)
        self.comboBox.addItems(self.fruitDict)
        self.comboBox.currentIndexChanged.connect(self.stackedLayout.setCurrentIndex)
        self.comboBox.setFont(QFont('Arial', 16))
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addLayout(self.stackedLayout)
        self.hBoxLayout.addWidget(self.comboBox)
        
        self.mainWindow.setLayout(self.hBoxLayout)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                36. Ders 13/07/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'de layout nesnelerinin içerisine yerleştirilmiş olan GUI elemanların ve layout nesnelerinin "size policy" denilen bir özelliği 
    vardır. (sizePolicy özelliği Qwidget ve QLayout sınıflarında bulunmaktadır. Dolayısıyla bütün pencere sınıflarında ve layout 
    sınıflarında bu özellik vardır.) size policy yatay ve düşeyde ayrı ayrı belirlenmektedir. Bir widget yaratıldığında onun yatay 
    ve düşey size policy'si default bir değerdedir. Size policy ilgili pencere büyütülüp küçültüldüğünde layout nesnelerinin içerisindeki 
    GUI elemanların ve layout nesnelerinin nasıl davranacağını belirtmektedir. 
    
    Örneğin size policy'nin QSizePolicy.Policy.Expanding olması demek layout nesnesi içerisindeki tüm size policy'si 
    QSizePolicy.Policy.Expanding olan GUI elemanların yatay ya da düşey bakımdan eşit oranda büyütülüp küçültülmesi demektir. QPushButton 
    nesnesinin düşey size policy'si QSizePolicy.Policy.Fixed durumdadır. Ancak yatay size policy'si QSizePolicy.Policy.Minimum durumdadır. 
    Bu durumda pencere yatay olarak büyütüldüğünde QPushButton nesnelerinin genişlikleri artacak ancak yükseklikleri sabit kalacaktır. 
    Ancak düşey olarak QPushButton nesnelerinin yükseklikleri aynı kalacaktır. QSizePolicy.Policy.Expanding "bu pencere yatat ya da 
    düşeyde büyütülüp küçültüldüğünde GUI elemanların da kalan boşluğu kullanacak biçimde büyütülüp küçültüleceği anlamına gelmektedir. 

    Aşağıdaki örnekte 5 tane QPushButton nesnesi bir QHBoxLayout nesnesine yerleştirilmiştir. Pencereyi genişletip daralttığınızda 
    bu QPushButton nesnelerinin yatayda ve düşeyde genişletilip daraltılmadığını göreceksiniz. Çünkü QPushButton nesnelerinin default 
    size policiy'leri yatayda ve düşeyde QSizePolicy.Policy.Fixed biçimdedir. QSizePolicy.Policy.Fixed durumunda üst pencere pencere 
    ilgili yönde büyütülüp küçültülse bile GUI elemanın boyutu değiştirilmez. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)
        
        self.pushButton1 = QPushButton('Button1', self)
        self.pushButton2 = QPushButton('Button2', self)
        self.pushButton3 = QPushButton('Button3', self)
        self.pushButton4 = QPushButton('Button4', self)
        self.pushButton5 = QPushButton('Button5', self)
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addWidget(self.pushButton1)
        self.hBoxLayout.addWidget(self.pushButton2)
        self.hBoxLayout.addWidget(self.pushButton3)
        self.hBoxLayout.addWidget(self.pushButton4)
        self.hBoxLayout.addWidget(self.pushButton5)
        
        self.mainWindow.setLayout(self.hBoxLayout)
                        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI elemanın iyi gözükmesi için olması gereken genişlik ve yüksekliğe "size hint" denilmektedir. Minimum genişlik ve yüksekliğe 
    ise "minimum size hint" denilmektedir. sizeHint değeri GUI elemanın size değeriyle aynı anlama gelmemektedir. size GUI elemanın o 
    andaki gerçek genişlik ve yüksekliğini belirtir. sizeHint ise onun iyi bir biçimde gözükmesi için tavsiye edilen ideal genişlik 
    ve yüksekliğidir. Tabii GUI elemanın iyi bir biçimde gözükmesi için tavsiye edilen genişlik ve yükseklik onun yazı fontu gibi bazı 
    özelliklerene bağlıdır. İşte sizePolicy ayarlanırken hep sizeHint değeri dikkate alınarak ayarlamalar yapılmaktadır. Örneğin biz 
    bir QPushButton nesnesini büyüttüğümüzde onun sizeHint değerini değiştirmiş olmayız. Dolayıyla onu bir layout nesnesinin içerisine 
    yerleştirdiğimizde o yine sizeHint ile belirtilen genişlik ve yükseklikte görüntülenir. Tabii bu durum GUI elemanın size policy 
    değeriyle de ilgilidir. GUI elemanlar için yatay ve düşeyde kullanılabilecek size policy değerleri ve anlamları şöyledir:

    QSizePolicy.Policy.Fixed: Bu durumda widget her zaman sizeHint ile belirtilen boyutta tutulur. Büyütülmez ya da küçültülmez. 
    
    QSizePolicy.Policy.Minimum: Bu seçenekte widget sizeHint’ten daha fazla küçültülemez fakat büyütülebilir. 
    
    QSizePolicy.Policy.Maximum: Bu seçenekte widget sizeHint değerinden daha fazla büyütülemez ancak küçültülebilir. Fakat küçültme de 
    ancak minimumSizeHint değerine kadar yapılabilmektedir. 

    QSizePolicy.Policy.Preferred: Bu seçenekte widget minimumSizeHint değerine kadar küçültülebilir, ancak istenildiği kadar büyütülebilir. 

    QSizePolicy.Policy.Expanding: Bu seçenekte widget minimumSizeHint değerine kadar küçültülebilir, ancak istenildiği kadar büyütülebilir. 
    Bu seçeneğin Preferred seçeneğinden farkı bu widget’ların yerleştirildiği layout’lar büyütülünce eldeki boş alanı Preferred olanların 
    değil yalnızca Expanding widget’ların paylaşmasıdır.

    QSizePolicy.Policy.MinimumExpanding: Bu seçenekte widget sizeHint’ten daha fazla küçültülemez, fakat büyütülebilir. Bu özelliğe sahip 
    widget’ların yerleştirildiği layout’lar büyütülünce eldeki boş alanı Preferred değil Expanding widget’lar paylaşmaktadır. 

    QSizePolicy.Policy.Ignored: Widget her zaman geri kalan alanı almaya çalışır. 

    PyQt5'te nu sembolik sabitler doğrudan QSizePolicy sınıfının içerisindeydi. Ancak PyQt6'da artık bu sembolik sabitler QSizePolicy 
    sınıfının içerisindeki Policy sınıfının içerisine yerleştirilmiştir. 

    Bir GUI elemanın size policy değeri QWidget sınıfınından gelen setSizePolicy metoduyla değiştirilebilmektedir. Metot sırasıyla 
    yata ve düşey size policy değerlerini argüman olarak almaktadır. Örneğin:

    self.pushButton.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

    İlgili GUI elemanın size policy değeri ise yine QWidget sınıfından gelen sizePolicy metoduyla elde edilebilir. Bu metot bize bir 
    QSizePolicy nesnesi vermektedir. Bu nesne ile biz sınıfın horizontalPolicy ve verticalPolicy metotlaarıyla GUI elemanın yatay ve 
    düşey size policy değerlerini elde edebiliriz. 

    Aşağıdaki örnekte bir QHoxLayout nesnesi içerisine 5 tane QPushButton nesnesi yerleştirilmiştir. Ancak bu QPushButton nesnelerinin 
    size policy değerleri yatayda ve düşeyde QSizePolicy.Policiy.Expanding yapılımıştır. Böylece ana pencere büyütülüp küçültüldüğünde 
    toplam alan yarayda ve düşeyde bu düğmeler tarafından paylaştırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)
        
        self.pushButton1 = QPushButton('Button1', self)
        self.pushButton1.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.pushButton2 = QPushButton('Button2', self)
        self.pushButton2.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.pushButton3 = QPushButton('Button3', self)
        self.pushButton3.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.pushButton4 = QPushButton('Button4', self)
        self.pushButton4.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.pushButton5 = QPushButton('Button5', self)
        self.pushButton5.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        self.hBoxLayout = QHBoxLayout()
        self.hBoxLayout.addWidget(self.pushButton1)
        self.hBoxLayout.addWidget(self.pushButton2)
        self.hBoxLayout.addWidget(self.pushButton3)
        self.hBoxLayout.addWidget(self.pushButton4)
        self.hBoxLayout.addWidget(self.pushButton5)
        
        self.mainWindow.setLayout(self.hBoxLayout)
                        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir QGridLayout nesnesine toplamda 8x8 tane QPushButton nesnesi yerleştirilmiştir. Burada QPushButton nesnelerinin
    sizePolicy değerleri QSizePolicy.Policy.Expanding yapılmıştır. Böylece ana pencerenin boyutu değiştirildiğinde içerideki düğmelerin 
    de boyutları otomatik olarak dğeiştirilecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)
      
        self.gridLayout = QGridLayout()
        
        for row in range(8):
            for col in range(8):
                pushButton = QPushButton(f'({row},{col})', self)
                pushButton.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                pushButton.clicked.connect(self.pushButtonClickedHandler)
                self.gridLayout.addWidget(pushButton, row, col, 1, 1)
        self.mainWindow.setLayout(self.gridLayout)
        
    def pushButtonClickedHandler(self):
        pushButton = self.sender()
        QMessageBox.information(self, 'Message', pushButton.text() + ' clicked')
      
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Biz bir layout nesnesinin içerisindeki GUI elemanların birbirlerine yakınlığını ve layout nesnesinin diğer layout nesnelerine ve
    GUI elemanlarına yakınlığını margin set ederek ayarlayabiliriz. QWidget sınıfının ve layout sınıflarının setContentMargins metotları 
    bu işi yapmaktadır. setContentsMargins metotlarının sol, yukarı, sağ ve aşağı marjinleri belirten dört parametresi vardır. Örneğin 
    biz bir layout nesnesine bu metot ile marjin verirsek bu layout nesnesi ana pencereye iliştirildiğinde ana pnecerenin etrafında 
    bu metotta belirtilen miktarda boşluklar bulundurulur. 

    Aşağıdaki örnekte QGridLayout nesnesine dört taraftan da 100'lük marjin verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)
      
        self.gridLayout = QGridLayout()
        self.gridLayout.setContentsMargins(100, 100, 100, 100)
        
        for row in range(8):
            for col in range(8):
                pushButton = QPushButton(f'({row},{col})', self)
                pushButton.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                pushButton.clicked.connect(self.pushButtonClickedHandler)
                self.gridLayout.addWidget(pushButton, row, col, 1, 1)
        self.mainWindow.setLayout(self.gridLayout)
        
    def pushButtonClickedHandler(self):
        pushButton = self.sender()
        QMessageBox.information(self, 'Message', pushButton.text() + ' clicked')
      
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Layout sınıflarının setSpacing, setHorizontalSpacing, setVerricalSpacing isimli metotları layout içerisindeki elemanların arasındaki 
    açıklığı belirlemek için de kullanılabilmektedir. setContenstMargins dış aralığı belirtirken setSpacing layout nesnelerinin içerisindeki
    GUI elemanlar ve diğer layout nesnelerin arasındaki aralığı belirtmektedir. Aşağıdaki örnekte QGridLayout nesnesi içerisindeki 
    düğmeler arasına 10'ar pixel aralık yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWindow = QWidget()
        self.setCentralWidget(self.mainWindow)
      
        self.gridLayout = QGridLayout()
        self.gridLayout.setContentsMargins(10, 10, 10, 10)
        self.gridLayout.setSpacing(3)
        
                
        for row in range(8):
            for col in range(8):
                pushButton = QPushButton(f'({row},{col})', self)
                pushButton.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                pushButton.clicked.connect(self.pushButtonClickedHandler)
                self.gridLayout.addWidget(pushButton, row, col, 1, 1)
        self.mainWindow.setLayout(self.gridLayout)
        self.gridLayout.setSpacing(10)
        
    def pushButtonClickedHandler(self):
        pushButton = self.sender()
        QMessageBox.information(self, 'Message', pushButton.text() + ' clicked')
      
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca Qt'de spacer denilen özel layout nesneleri de bulundurulmuştur. Spacer nesneler default olarak QSizePolicy.Expanding 
    özelliğine sahiptir. Bu nedenle pencere genişletildiğinde ve daraltıldığında kalan alanı bunlar işgal eder. Spacer nesnelerin bir 
    görüntüsü yoktur. Pencere genişlediğinde genişleyten alanı paylaştıkları için widget'ların hizalanmasına katkı sağlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Qt5 ile birlikte fremework'e GUI elemanlarının görsel özelliklerinin ayarlanması için ismine "style sheet" denilen bir özellik 
    eklenmiştir. Bu sayede GUI elemanlar üzerinde pek çok görsel ayarlamalar yapılabilmektedir. Stylesheet sentaksı şöyledir:

    [Seçiciler (Selectortors)] { <Özellik (Attribute)> :  <Değer (Value)> ;  ...}

    Stylesheet bir yazıdır. Bu yazı oluşturulduktan sonra QWidget sınıfının setStyleSheet metodu ile GUI elemana set edilir. Bu genel 
    biçimdeki "seçiciler (selectors)" çeşitli biçimlerde olabilmektedir. En basit seçici "sınıf isminden" oluşur. bu durumda "belirlenen
    özellikler setStleSheet yapılan pencerenin seçici türünden tüm alt pencerelerini" etkileyecektir. Örneğin:

    self.mainWidget.setStyleSheet('QPushButton {color: red; font-size: 14pt}')

    Burada mainWidget isimli pencerenin alt penceresi olan tüm QPushButton pencereleri bu style sheet tarafından etkilenecektir. 
    Seçiciler birden fazla olabilir. Örneğin:

    self.mainWidget.setStyleSheet('QPushButton, QLineEdit, QComboBox { color: red }')

    Burada QPushButton, QLineEdit ve QComboBox GUI elemanlarının yazı renkleri değiştirilmek istenmiştir. 

    Özellikler bir isimden ':' ve değerden oluşmaktadır. Özellikler arasında ';' bulundurulur. Özelliklerin isimleri önceden belirlenmiştir. 
    Seçiciler yalnızca pencere sınıf isimlerinden değil başka birtakım isimlerden de oluşturulabilmektedir. Style sheet kullanımı Qt 
    dokümanlarında aşağıdaki bağlantıda resmi olarak açıklanmıştır:

    https://doc.qt.io/qt-6/stylesheet.html

    Ancak Qt'nin style sheet özellikleri oldukça ayrıntılı hale gelmiştir. Bu özelliklerin ayrıntılarını öğrenmek yerine daha pragmatik 
    biçimde LLM'leri kullanarak hedefe varabilirsiniz. 

    Bir GUI elemana bir style sheet set edildikten sonra yeniden başka bir style sheet set edilirse önce set edilen style sheet 
    özellikleri kaybedilmektedir. Yani style sheet artırımlı biçimde set edilememektedir. Tüm style sheet özellikleri tek bir yazı 
    haline getirilip set edilmelidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt5.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()    
        
        self.resize(640, 480)
        
        self.textEdit = QTextEdit(self)
        font = self.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
        
        styleSheet = """
        QTextEdit {color: red; background-color: yellow; selection-color: #FF0000; 
                   selection-background-color: magenta; margin-top: 10px; margin-left: 10px; 
                   margin-bottom: 10px; margin-right: 10px; border-style: solid; border-width: 10px; border-color: red}
        """
        
        self.textEdit.setStyleSheet(styleSheet)
        
        self.comboBox = QComboBox(self)
        self.comboBox.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.comboBox.setStyleSheet('QComboBox {color: red; font: 14px}')
        
        self.comboBox.addItems(['Ankara', 'İzmir', 'Eskişehir', 'Bolu'])
        
        hBoxLayout = QHBoxLayout()
        hBoxLayout.setContentsMargins(3, 3, 3, 2)
        hBoxLayout.addWidget(self.textEdit)
        hBoxLayout.addWidget(self.comboBox)
                
        self.setLayout(hBoxLayout)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow .show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Genel olarak stylesheet yazılarında background-image özelliği ilgili pencerenin içerisinde bir resim göstermek için kullanılmaktadır. 
    background-image özelliği şöyle belirtilmektedir:

    "QLabel {background-image: url(<dosyanın yeri>)}"

    Dosyanın yeri bir URL de olabilir yerel diskte bir yol ifadesi de olabilir. Yani bir resim göstermek için setPixmap yapmak yerine 
    doğrudan style sheet de kullanılabilmektedir. 

    Aşağıdaki örnekte QLabel içerisine stylesheet kullanılarak bir resim iliştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        self.labelPicture = QLabel(self.mainWidget)
        self.labelPicture.setStyleSheet('QLabel {background-image:url(CardImages/12.png); background-repeat: no-repeat;}')
        self.labelPicture.setGeometry(100, 100, 300, 100)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Mademki setStyleSheet metodu QWidget sınıfından gelmektedir. O halde her widget için ayrı ayrı stylesheet set edilebilir. Ancak 
    tıpkı WWW'deki CSS'lerde olduğu gibi üst pencereler için set edilen style sheet belirlemeleri eğer seçici (selector) uygunsa alt 
    pencereler için de geçerlidir. Örneğin elimizde iki tane QLabel nesnesi olsun. Her iki nesnenin de zemininde aynı resmin gözükmesini 
    isteyelim. Bizim style sheet yazısını ayrı ayrı bu iki QLabel nesnesine set etmemiz gerekmez. Biz setylesheet yazısını yalnızca 
    ana pencereye set edebiliriz. Ana pencerenin tüm QLabel türünden alt pencereleri için by style sheet etki gösterir. 

    Aşağıdaki örnekte 2x2'lik bir QGridLayout oluşturulmuştur. Bu QGridLayout nesnesinin her hücresine ayrı bir QLabel iliştirilmiştir. 
    Burada setStyleSheet metodu ana pencereye uygulanmıştır. QLabel pencereleri ana pencerenin alt pencereleri olduğu için bu belirlemeler
    alt pencereleri de içine katmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()    
        self.resize(640, 480)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.gridLayout = QGridLayout()
        
        self.labelImage1 = QLabel(self.mainWidget)
        self.gridLayout.addWidget(self.labelImage1, 0, 0 )
        
        self.labelImage2 = QLabel(self.mainWidget)
        self.gridLayout.addWidget(self.labelImage2, 0, 1)
        
        self.labelImage3 = QLabel(self.mainWidget)
        self.gridLayout.addWidget(self.labelImage3, 1, 0)
        
        self.labelImage4 = QLabel(self.mainWidget)
        self.gridLayout.addWidget(self.labelImage4, 1, 1)
        
        self.mainWidget.setLayout(self.gridLayout)
        
        self.mainWidget.setStyleSheet("""QLabel {background-image: 
                           url(AbbeyRoad.jpg);  
                           background-repeat: no-repeat; 
                           background-position: center;       
                           background-origin: content;
                           background-size: 100% 100% }""")
                
app = QApplication(sys.argv)

mainWindow = MainWindow()
mainWindow .show()

app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt'nin "stylesheet reference" dokümanı incelendiğinde her özelliğin her GUI elemanına uygulanamadığı görülmektedir. Bir grup GUI 
    elemana "box modele uygun" elemanlar denilmektedir. Bu elemanlara uygulanacak özellikler bellidir. Örneğin QLabel, QLineEdit, 
    QTextEdit  box modele uygundur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Style sheet yazısındaki "seçici (selector)" birkaç biçimde eoluşturulabilmektedir:

    sınıf_ismi: Burada özellik o sınıf ve o sınıftan türetilmiş tüm sınıflara uygulanır. 
    .sınıf_ismi: Burada özellik yalnızca ilgili sınıfa uygulanır. Ancak ondan türetilmiş sınıflara uygulanmaz. 
    sınıf_ismi#nesne_ismi: Burada özellik yalnızca "objectName" özelliği belirli biçimde olan GUI elemanlara uygulanır.

    Aşağıdaki örnekte iki QPushButton nesnesi oluşturulmuştur. Bunlardan birine isim verilip seçici olarak bu isimli QPushButton 
    seçilerek style sheet uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()    
        self.resize(640, 480)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setGeometry(100, 100, 100, 100)
        self.pushButtonOk.setObjectName('pushButtonOk')
        
        self.pushButtonCancel = QPushButton('Cancel', self.mainWidget)
        self.pushButtonCancel.setGeometry(210, 100, 100, 100)
        
        self.mainWidget.setStyleSheet('QPushButton#pushButtonOk {color: red; font-size: 14pt}')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow .show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                            37. Ders 19/07/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Belli bir GUI elemanın belli bir kısmına ilişkin özellikleri set etmek için "sınıf_ismi::kısım_ismi" sentaksı kullanılmaktadır. 
    Örneğin:

    self.mainWidget.setStyleSheet('QCheckBox::indicator {background-color: yellow; width: 50px; height: 50px;}')

    Burada checkbox'ın checked karesi büyütülüp rengi değiştirilmiştir. (Ancak checkboc'larda indicator değiştirildiğinde "checked" ve
    "unchecked"  özellikleri de set edilmelidir.)

    Aşağıdaki örnekte bir checkbox'ın bazı özellikleri değiştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        self.checkBox = QCheckBox('Test',self.mainWidget )
        self.checkBox.setGeometry(50, 50, 100, 100)
        
        self.mainWidget.setStyleSheet('QCheckBox::indicator {background-color: yellow; width: 50px; height: 50px;}')
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir seçicinin (selector) sonuna bir tane ':' sembolü getirilerek  durumsal özellik oluşturulabilmektedir. Örneğin:

    self.mainWidget.setStyleSheet("""
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 1px solid gray;
            }
            QCheckBox::indicator:unchecked {
                background-color: green;
            }
            QCheckBox::indicator:checked {
                background-color: red;
            }
    """);

     Burada checkbox seçili durumdayken kırmızı, seçili rudumda değilse yeşil olarak görüntülenecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        self.checkBox = QCheckBox('Test',self.mainWidget )
        self.checkBox.setGeometry(50, 50, 100, 100)
        
        self.mainWidget.setStyleSheet("""
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 1px solid gray;
            }
            QCheckBox::indicator:unchecked {
                background-color: green;
            }
            QCheckBox::indicator:checked {
                background-color: red;
            }

        """);
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir menü üzerinde bazı özelliklerin style sheet yoluyla değiştirilmesi örneği verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        menuBar = self.menuBar()
          
        self.filePopup = QMenu('File')
        menuBar.addMenu(self.filePopup)
        
        self.openAction = QAction('Open')
        self.openAction.setCheckable(True)
        self.filePopup.addAction(self.openAction)
        
        self.closeAction = QAction('Close')
        self.filePopup.addAction(self.closeAction)
        
        self.exitAction = QAction('Exit')
        self.filePopup.addAction(self.exitAction)
      
        ss = """
            QMenu {background-color:  #ABABAB; border: 1px solid black; margin: 10px}
            QMenu.item:selected {  background-color: #654321; }
            QMenu.icon:checked { background: gray; border: 1px inset gray; position: absolute; top: 1px; right: 1px; bottom: 1px;left: 1px; }       
        """
      
        self.filePopup.setStyleSheet(ss)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI elemanın görsel özelliklerini değiştirmek için gereken style sheet özelliklerini ChatGPT gibi LLM'leri kullanarak 
    bulabilirsiniz. Örneğin QListWidget penceresinde seçilen elemanın yeşil gözükmesini istiyor olalım. ChatGPT'ye aşağıdaki gibi bir
    prompt vererek ilgili stylesheet özelliğini elde edebiliriz:

    "PyQt'de bir listwidget'ta bir eleman seçildiğinde seçimin yeliş olmasını stylesheet kullanarak nasıl sağlarım?"

    CharCPT bize şöyle bir yanıt vermiştir:

    "QListWidget::item:selected seçicisini kullanarak seçilen öğelerin stilini tanımlayabilirsin." Şöyle de bir örnek kod vermiştir:

    list_widget.setStyleSheet("""
        QListWidget::item:selected {
            background-color: green;
            color: white;
        }
        """)

    Aşağıda bu stylesheet'in uygulandığı bir örnek veriyoruz.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        self.listWidget = QListWidget(self.mainWidget)
        self.listWidget.setGeometry(50, 50, 200, 300)
        self.listWidget.addItems(['Ankara', 'İzmir', 'Eskişehir', 'Adana', 'Samsun'])
        self.mainWidget.setStyleSheet("""
            QListWidget::item:selected {
                background-color: green;
                color: white;
            }
        """)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Slider pek çok GUI framework'ünde bulunan yaygın kullanılan bir GUI elemandır. Bu GUI elemanda bir yürüteç (thumb) vardır. Kullanıcı 
    bu yürüteci çekip bırakarak bir ayarlama yapar. Genellikle volüm kontrolü için, renk kontrolü için slider'lar kullanılmaktadır. 
    Slider GUI elemanı QSlider sınıfıyla temsil edilmiştir. Bu sınıf QAbstractSlider isimli sınıftan türetilmiş durumdadır. Yürütecin 
    minimum ve maksimum değerleri başlangıçta [0, 99] biçimindedir. Ancak bu değerler istenirse setMinimum ve setMaximum  metotlarıyla 
    değiştirilebilir. Slider'ın yatay mı düşey mi olacağı nesne yaratılırken __init__ metodunda belirlenmektedir. Burada Qt.Orientation.Horizontal 
    yatay yönelim için Qt.Oientation.Vertical düşey yönelim için kullanılmaktadır. Defult durum düşey yönelimdir. Örneğin:

    self.slider = QSlider(Qt.Orientation.Horizontal, self)
    
    Yürütecin konumu value metoduyla alınıp, setValue metoduyla programlama yoluyla değiştirilebilmektedir. Widget başlangıçta tick'sizdir. 
    Tick'li hale getirmek için setTickPosition metodu kullanılır. Bu metot aşağıdaki sembolik sabitlerden biribi argüman olarak almaktadır:

    QSlider.TickPosition.NoTicks	
    QSlider.TickPosition.TicksBothSides	
    QSlider.TickPosition.TicksAbove		
    QSlider.TicksBelow		
    QSlider.TickPosition.TicksLeft	
    QSlider.TickPosition.TicksRight
    
    Tick periyodu da setTickInterval metodu ile ayarlanmaktadır. 
    
    QSlider GUI elemanının en önemli sinyali valueChanged isimli sinyaldir. Bu sinyal ne zaman yürüteç hareket ettirilse emit edilmektedir. 
    Benzer biçimde yürüteç bırakıldığında da sliderReleased sinyali emit edilmektedir. 

    Klavye odağı QSlider nesnesi üzerindeyken ok tuşlarıyla küçük ilerlemeler, PageUp, PageDown tuşlarıyla da büyük ilerlemeler 
    yapılabilmektedir. İlerleme miktarını ayarlamak için sınıfın setSingleStep ve setPageStep metotları kullanılmaktadır. 

    Aşağıda slider kullanımına bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
       
        self.slider = QSlider(Qt.Orientation.Horizontal, self)
        self.slider.setGeometry(50, 50, 500, 30)
        self.slider.setMinimum(0)
        self.slider.setMaximum(1000)
        self.slider.setValue(300)
        self.slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        self.slider.setTickInterval(50)
        self.slider.valueChanged.connect(self.silderValueChangedHandler)
        self.slider.sliderReleased.connect(self.sliderSliderReleasedHandler)
        self.slider.setSingleStep(10)
        self.slider.setPageStep(100)
        
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setGeometry(50, 100, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkHandler)
        
    def pushButtonOkHandler(self):
        value = self.slider.value()
        print(value)
        
    def silderValueChangedHandler(self):
        """
        value = self.slider.value()
        print(value)
        """
        
    def sliderSliderReleasedHandler(self):
        value = self.slider.value()
        print(value)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Red, Green ve Blue renklerini temsil eden üç farklı slider bulunmaktadır. Bu slideer'ların yürüteçlari hareket
    ettirildiğinde aşağıdaki pebcerenin zemin rengi değiştirilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        self.mainWidget.setStyleSheet('QLabel {font-size: 12pt}')
        
        self.red = self.green = self.blue = 0
        
        self.labelRed = QLabel('Red', self.mainWidget)
        self.labelRed.setContentsMargins(0, 0, 30, 0)
        
        self.sliderRed = QSlider(Qt.Orientation.Horizontal, self)
        self.sliderRed.setMinimum(0)
        self.sliderRed.setMaximum(255)
        self.sliderRed.setValue(self.red)
        self.sliderRed.setTickPosition(QSlider.TickPosition.TicksBelow)
        self.sliderRed.setTickInterval(5)
        self.sliderRed.setSingleStep(10)
        self.sliderRed.setPageStep(100)
        self.sliderRed.valueChanged.connect(self.sliderRedValueChangedHandler)
        
        self.labelGreen = QLabel('Green', self.mainWidget)
        self.labelGreen.setContentsMargins(0, 0, 30, 0)
        
        self.sliderGreen = QSlider(Qt.Orientation.Horizontal, self)
        self.sliderGreen.setMinimum(0)
        self.sliderGreen.setMaximum(255)
        self.sliderGreen.setValue(self.green)
        self.sliderGreen.setTickPosition(QSlider.TickPosition.TicksBelow)
        self.sliderGreen.setTickInterval(5)
        self.sliderGreen.setSingleStep(10)
        self.sliderGreen.setPageStep(100)
        self.sliderGreen.valueChanged.connect(self.sliderGreenValueChangedHandler)
        
        self.labelBlue = QLabel('Blue', self.mainWidget)
        self.labelBlue.setContentsMargins(0, 0, 30, 0)
        
        self.sliderBlue = QSlider(Qt.Orientation.Horizontal, self)
        self.sliderBlue.setMinimum(0)
        self.sliderBlue.setMaximum(255)
        self.sliderBlue.setValue(self.blue)
        self.sliderBlue.setTickPosition(QSlider.TickPosition.TicksBelow)
        self.sliderBlue.setTickInterval(5)
        self.sliderBlue.setSingleStep(10)
        self.sliderBlue.setPageStep(100)
        self.sliderBlue.valueChanged.connect(self.sliderBlueValueChangedHandler)
                
        self.gridLayout = QGridLayout()
        self.gridLayout.addWidget(self.labelRed, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.sliderRed, 0, 1, 1, 1)
        self.gridLayout.addWidget(self.labelGreen, 1, 0, 1, 1)
        self.gridLayout.addWidget(self.sliderGreen, 1, 1, 1, 1)
        self.gridLayout.addWidget(self.labelBlue, 2, 0, 1, 1)
        self.gridLayout.addWidget(self.sliderBlue, 2, 1, 1, 1)
        
        self.widgetColor = QWidget(self.mainWidget)
        self.changeBackColor()
         
        self.vBoxLayout = QVBoxLayout()
        self.vBoxLayout.addLayout(self.gridLayout)
        self.vBoxLayout.addWidget(self.widgetColor)
                     
        self.mainWidget.setLayout(self.vBoxLayout)

    def sliderRedValueChangedHandler(self):
        self.red = self.sliderRed.value()
        self.changeBackColor()
    
    def sliderGreenValueChangedHandler(self):
        self.green = self.sliderGreen.value()
        self.changeBackColor()
    
    def sliderBlueValueChangedHandler(self):
        self.blue = self.sliderBlue.value()
        self.changeBackColor()
        
    def changeBackColor(self):
        self.widgetColor.setStyleSheet(f'QWidget {{background-color:rgb({self.red}, {self.green}, {self.blue})}}')
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ok tuşlarına basıldıkça bir değerin artırılıp azaldığı GUI elemanlarına "spinner" ya da "spinbox" denilmektedir. Qt'de spinbox 
    GUI elemanı QSpinBox sınıfıyla temsil edilmiştir. QSpinBox kullanımı şöyledir:

    1) Önce QSpinBox sınıfı türünden bir nesne yaratılır ve konumlandırma yapılır. 
    2) Spinbox'ın maksimum ve minimum değerleri setMaximum ve setMinimum metotlarıyla ayarlanabilmektedir. Bu değerler default durumda 
    99 ve 0 biçiminddir. 
    3) GUI elemanın içerisindeki yazı setAlignment metodu ile ayarlanabilmektedir. Bu metoda parametre olarak Qt.AlignmentFlag.XXX 
    sembolik sabitleri girilmektedir. Spinbox üzerindeki sayının sonuna ve başına  setSuffix ve setPrefix metotları ile yazılar 
    iliştirilebilmektedir. 
    4) Spinbox içerisindeki değer value metodu ile alınıp setValue metodu ile set edilebilmektedir. 
    5) Klavye odağı spinbox üzerindeyken ok tuşlarıyla küçük ilerlemeler, PageUp, PageDown tuşlarıyla büyük ilerlemeler yapılabilir. 
    Küçük ilerlemeler setSingleStep metoduyla set edilebilmektedir. Büyük ilerlemeler default olarak küçük ilerlemelerin 10 katıdır. 
    Sınıfın setWrapping metodu True ile çağrılırsa en yüksek ve en düşük değerden sarmalama yapılmaktadır. 

    Aşağıda SpinBox kullanımına bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.spinBox = QSpinBox(self.mainWidget)
        self.spinBox.setGeometry(50, 50, 150, 25)
        self.spinBox.setMaximum(100)
        # self.spinBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.spinBox.setPrefix('%')
        self.spinBox.setValue(50)
        self.spinBox.setWrapping(True)
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setGeometry(50, 120, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkHandler)
        
    def pushButtonOkHandler(self):
        value = self.spinBox.value()
        QMessageBox.information(self, 'Message', str(value))
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                        38. Ders 20/07/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Sekmelerden oluşan sekmelere tıklandığında o sekmeye ilişkin pencerenin görüntülendiği GUI elemanlarına "Tab GUI elemanları" 
    ya da "property sheet" denilemktedir. PyQt'de Tab GUI elemanı QTabWidget sınıfıyla temsil edilmiştir. QTabWidget Sınıfı şöyle 
    kullanılmaktadır: 

    1) Önce QTabWidget türünden bir nesne yaratılır ve pencere konumlandırılır. 
    
    2) QTabWidget sınıfının addTab isimli metotları ile sekmeler QTabWidget içerisine eklenir. addTab metodu bizden bir pencere nesnesi 
    ve bir de sekme yazısını istemektedir. addMetodu yeni eklenen sekmenin index numarasıyla geri dönmektedir. Programcı sekmelerdeki 
    pencere nesnelerini kendisi konumlandırmaz. Bu pencere nesneleri QTabWidget tarafından sekme aktif hale getirildiğinde otomatik 
    olarak pencereyi kaplamaktadır. 
    
    3) QTabWidget penceresine sekmeler eklendikten sonra oradaki pencereler üzerine GUI elemanlar yerleştirilebilir. (Tabii önce 
    pencerelere GUI elemanlar yerleştirilip sonra da sekme eklenebilir.)
    
    5) İki sekme arasına insertTab metodu ile sekme insert edilebilir. Belli bir sekme index numarası verilerek removeTab metoduyla 
    silinebilir. O anda aktif olan sekmenin indeks numarası currentIndex metodu ile alınabilir, aktif sekme programlama yolu ile 
    setCurrentIndex metoduyla değiştirilebilir. currentWidget metodu o andaki aktif sekmedeki pencere nesnesini bize vermektedir. 
    Sekmelerin görünümü setTabShape metodu ile üçgensel hale getirilebilir. Sekmelerin isimleri tabText metodu ile elde edilip 
    setTabText metodu ile set edilebilir. QTabWidget içeirindeki tüm sekmelerin sayısı sınıfın count metodu ile elde edilebilmektedir. 
    Belli bir indeksteki sekmeye iliştirilen pencere ise sınıfın widget metodu ile elde edilebilmektedir. Bir sekme oluşturulduğunda 
    o sekmenin üzerinde x biçiminde bir kapatma düğmesinin de olması isteniyorsa sınıfın setTabsClosable metodu True ile çağrılmalıdır. 
    Bu durumda bu x tuluna basıldığında tabCloseRequested isimli sinyali emit edilmektedir. Bu sinyalin kapatılmak istenen sekmenin 
    numarasını veren bir parametresi vardır. GUI elemanın diğer metotlarına Qt dokümanlarından erişebilirsiniz. 
    
    6) GUI elemanın en önemli sinyali bir sekme aktif hale getirildiğinde tetiklenen currrentChanged isimli sinyaldir. Bu sinyal 
    parametre yoluyla bize aktif hale gelmiş olan sekmenin indek numarasını vermektedir. 

    Aşağıda örnek bir QTabWidget kullanımı verilmiştir. Burada QTabWidget nesnesi QMainWindow için merkezi pencere haline 
    getirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.tabWidget = QTabWidget(self)
        self.setCentralWidget(self.tabWidget)
        
        self.optionsWidget = QWidget()
        self.toolsWidget = QWidget()
                
        self.checkBoxVisible = QCheckBox('Visible', self.optionsWidget)
        self.checkBoxSaveOnExit = QCheckBox('Save on Exit', self.optionsWidget)
        self.checkBoxRestoreOnExit = QCheckBox('Restore on Exit', self.optionsWidget)
        
        self.pushButtonCompile = QPushButton('Compile', self.toolsWidget)
        self.pushButtonCompile.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.pushButtonRun = QPushButton('Run', self.toolsWidget)
        self.pushButtonRun.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.pushButtonSave = QPushButton('Save', self.optionsWidget)
        self.pushButtonSave.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        vBoxLayout1 = QVBoxLayout()
        vBoxLayout1.addWidget(self.checkBoxVisible)
        vBoxLayout1.addWidget(self.checkBoxSaveOnExit)
        vBoxLayout1.addWidget(self.checkBoxRestoreOnExit)
        vBoxLayout1.addItem(QSpacerItem(0, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Expanding))
        
        vBoxLayout2 = QVBoxLayout()
        vBoxLayout2.addWidget(self.pushButtonCompile)
        vBoxLayout2.addWidget(self.pushButtonRun)
        vBoxLayout2.addWidget(self.pushButtonSave)
        vBoxLayout2.addItem(QSpacerItem(0, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Expanding))
        
        self.optionsWidget.setLayout(vBoxLayout1)
        self.toolsWidget.setLayout(vBoxLayout2)
        
        self.tabWidget.setGeometry(50, 50, 700, 500)
        self.tabWidget.addTab(self.optionsWidget, 'Options')
        self.tabWidget.addTab(self.toolsWidget, 'Tools')
        self.tabWidget.currentChanged.connect(self.tabWidgetCurrentChangedHandler)
    
    def tabWidgetCurrentChangedHandler(self):
        index = self.tabWidget.currentIndex()
        text = self.tabWidget.tabText(index)
        print(f'"{text}" tab now active!')
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                        39. Ders 26/07/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte daha önce yapmış olduğumuz "notepad" uygulaması çok tab'lı hale getirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

iimport sys
import shelve
import os.path
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        self.untitledCount = 1
        self.tabs = {}
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        self.move(self.app_settings.get('pos', QPoint(100, 100)))
        self.resize(self.app_settings.get('size', QSize(800, 600))) 
        self.textColor = self.app_settings.get('textcolor', QColor(0, 0, 0))
        self.backColor = self.app_settings.get('backcolor', QColor(255, 255, 255))
        
        self.tabWidget = QTabWidget(self)
        self.tabWidget.setTabsClosable(True)
        self.setCentralWidget(self.tabWidget)
        
        self._createNewTextEdit()       
        self._setMenu()
        self._setToolBar()
        
        self.tabWidget.tabCloseRequested.connect(self.tabWidgetTabCloseRequestedHandler)
        self.tabWidget.currentChanged.connect(self.tabWidgetCurrentChangedHandler)
        
    def _createNewTextEdit(self):
        textEdit = QTextEdit(self)
        textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        textEdit.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        textEdit.textChanged.connect(self.textEditTextChangedHandler)
        font = textEdit.font()
        font.setPointSize(14)
        textEdit.setFont(font)
        index = self.tabWidget.addTab(textEdit, f'Untitled-{self.untitledCount}')
        self.tabs[self.tabWidget.count() - 1] = (None, f'Untitled-{self.untitledCount}')
        self.untitledCount += 1
        return textEdit, index
        
    def _setMenu(self):
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.viewPopup = QMenu('&View')
        self.optionsPopup = QMenu('&Options')
        self.helpPopup = QMenu('&Help')
        
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.optionsPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.newAction = QAction('&New')
        self.newAction.setIcon(QIcon('MenuIcons/new.png'))
        self.newAction.setShortcut('Ctrl+N')
        self.newAction.setToolTip('New file...')
        self.newAction.triggered.connect(self.newActionTriggeredHandler)
        self.filePopup.addAction(self.newAction)
                
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.filePopup.addAction(self.openAction)
                
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.filePopup.addAction(self.saveAction)
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        self.filePopup.addAction(self.saveAsAction)
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setToolTip('Closes a file...')             
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.filePopup.addAction(self.closeAction)
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        self.filePopup.addMenu(self.openRecentPopup)
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.addAction(self.separatorAction)
        
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.editPopup.addAction(self.cutAction)
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.editPopup.addAction(self.copyAction)
   
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        self.editPopup.addAction(self.pasteAction)
        
        self.editPopup.addAction(self.separatorAction)
        
        self.findAction = QAction('&Find...')
        self.findAction.setIcon(QIcon('MenuIcons/find.png'))
        self.findAction.setShortcut('Ctrl+F')
        self.findAction.triggered.connect(self.findActionTriggeredHandler)
        self.editPopup.addAction(self.findAction)
        
        self.replaceAction = QAction('&Replace...')
        self.replaceAction.setIcon(QIcon('MenuIcons/replace.png'))
        self.replaceAction.setShortcut('Ctrl+R')
        self.replaceAction.triggered.connect(self.replaceActionTriggeredHandler)
        self.editPopup.addAction(self.replaceAction)
                 
        self.textColorAction = QAction('&Text Color...')
        self.textColorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.textColorAction.setShortcut('Ctrl+T')
        self.textColorAction.triggered.connect(self.textColorActionTriggeredHandler)
        self.optionsPopup.addAction(self.textColorAction)
        
        self.backColorAction = QAction('&Background Color...')
        self.backColorAction.setIcon(QIcon('MenuIcons/backcolor.png'))
        self.backColorAction.setShortcut('Ctrl+T')
        self.backColorAction.triggered.connect(self.backColorActionTriggeredHandler)
        self.optionsPopup.addAction(self.backColorAction)
        
        self.fontAction = QAction('&Font...')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        self.optionsPopup.addAction(self.fontAction)
                
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
        self.viewPopup.addMenu(self.themePopup)
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        self.themePopup.addAction(self.classicThemeAction)
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        self.themePopup.addAction(self.darkThemeAction)
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        self.themePopup.addAction(self.lightThemeAction)
                
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(self.app_settings.get('fullScreen', False))
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        self.viewPopup.addAction(self.fullScreenAction)
                     
        self.viewPopup.addAction(self.separatorAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(self.app_settings.get('wordwrap', False))
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
   
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
             
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
        self.helpPopup.addAction(self.aboutAction)
        
        self.fullScreenActionTriggeredHandler()
        
    def _setToolBar(self):
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.newAction)
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.textColorAction)
        self.toolBar.addAction(self.backColorAction)
        self.toolBar.addAction(self.fontAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
        self.toolBar.addSeparator()
        
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.tabWidget.widget(0).font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
        self.pushButtonColorReset = QPushButton('Color Reset', self.toolBar)
        self.toolBar.addWidget(self.pushButtonColorReset)
        self.pushButtonColorReset.clicked.connect(self.pushButtonColorResetClickedHandler)
        
        self.wordWrapAction.setChecked(True)
        
    def _setTabPath(self, path):
        baseName = os.path.basename(path)
        curIndex = self.tabWidget.currentIndex()
        self.tabWidget.setTabText(curIndex, baseName)
        self.tabs[curIndex] = path, baseName
                                       
    def _saveFile(self, path):
        textEdit = self.tabWidget.currentWidget()
        try:
            with open(path, 'w') as f:
                text = textEdit.document().toPlainText()
                f.write(text)
                textEdit.document().setModified(False)
                curIndex = self.tabWidget.currentIndex()
                text = self.tabWidget.tabText(curIndex)
                if text[-1] == '*':
                    _, baseName = self.tabs[curIndex]
                    self.tabWidget.setTabText(curIndex, baseName)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
            
    def tabWidgetTabCloseRequestedHandler(self, index):
        textEdit = self.tabWidget.widget(index)
        if textEdit.document().isModified():
            _, baseName = self.tabs[index] 
            result = QMessageBox.information(self, 'Warning', f'{baseName} has been modfied\nSave changes?', 
                     QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.tabWidget.removeTab(index)
        if self.tabWidget.count() == 0:
            self.newActionTriggeredHandler()
            
    def tabWidgetCurrentChangedHandler(self, index):
        textEdit = self.tabWidget.widget(index)
        font = textEdit.font()
        self.comboBoxFonts.setCurrentText(font.family())
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.wordWrapAction.setChecked(textEdit.lineWrapMode() != QTextEdit.LineWrapMode.NoWrap)
                    
    def newActionTriggeredHandler(self):
         textEdit, index = self._createNewTextEdit()
         self.tabWidget.setCurrentIndex(index)
         
    def openActionTriggeredHandler(self):
        textEdit = self.tabWidget.currentWidget()
        if textEdit.document().isModified():
            curIndex = self.tabWidget.currentIndex()
            _, baseName = self.tabs[curIndex]
            result = QMessageBox.information(self, 'Warning', f'{baseName} has been modfied\nSave changes?',  
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
            
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.txt;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                textEdit.setText(text)
                curIndex = self.tabWidget.currentIndex()
                self._setTabPath(path)
            
    def saveActionTriggeredHandler(self):
        curIndex = self.tabWidget.currentIndex()
        path, _ = self.tabs[curIndex]
        if path: 
            self._saveFile(path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.txt;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
            self._setTabPath(path)
            
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')

    def findActionTriggeredHandler(self):
        fd = FindDialog(self)
        fd.show()
        
    def replaceActionTriggeredHandler(self):
        rd = ReplaceDialog(self)
        rd.show()
                
    def textColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.textColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.textColor = colorDialog.currentColor()          
            for index in range(self.tabWidget.count()):
                textEdit = self.tabWidget.widget(index)
                textEdit.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')

    def textEditTextChangedHandler(self):
        #textEdit = self.tabWidget.currentWidget()
        curIndex = self.tabWidget.currentIndex()
        text = self.tabWidget.tabText(curIndex)
        if not text.endswith('*'):
            self.tabWidget.setTabText(curIndex, text + '*')
                               
    def backColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.backColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.backColor = colorDialog.currentColor()
            for index in range(self.tabWidget.count()):
                textEdit = self.tabWidget.widget(index)
                textEdit.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
            
    def fontActionTriggeredHandler(self):
        textEdit = self.tabWidget.currentWidget()
        fontDialog = QFontDialog(textEdit.font(), self)
        if fontDialog.exec() == QDialog.DialogCode.Accepted:
            font = fontDialog.currentFont()
            textEdit.setFont(font)
                       
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        textEdit = self.tabWidget.currentWidget()
        checked = self.wordWrapAction.isChecked()
        textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        textEdit = self.tabWidget.currentWidget()
        font = textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        textEdit = self.tabWidget.currentWidget()
        font = textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        textEdit.setFont(font)
        
    def pushButtonColorResetClickedHandler(self):
        if QMessageBox.information(self, 'Warning', 'Colors will be set with default values, are you sure?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
            self.textColor = QColor(0, 0, 0)
            self.backColor = QColor(255, 255, 255)
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        
    def closeEvent(self, ce):
        for index in range(self.tabWidget.count()):
            textEdit = self.tabWidget.widget(index)
            if textEdit.document().isModified():
                _, baseName = self.tabs[index] 
                result = QMessageBox.information(self, 'Warning', f'{baseName} has been modfied\nSave changes?', 
                        QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
                if result == QMessageBox.StandardButton.Cancel:
                    ce.ignore()
                    return
                if result == QMessageBox.StandardButton.Yes:
                    self.saveActionTriggeredHandler()
                    
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['textcolor'] = self.textColor
        self.app_settings['backcolor'] = self.backColor     
        self.app_settings.close()     
        
class FindDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle('Find')        
        self.mainWindow = parent
        
        self.resize(300, 100)
        self.setMaximumSize(300, 100)
        self.setMinimumSize(300, 100)
                
        self.labelFind = QLabel('Text to find:', self)
        self.labelFind.setGeometry(10, 10, 100, 20) 
                
        self.lineEditFind = QLineEdit(self)
        self.lineEditFind.setGeometry(10, 30, 150, 20) 
        
        self.pushButtonNext = QPushButton('Next', self)
        self.pushButtonNext.setGeometry(200, 20, 70, 30)
        self.pushButtonNext.clicked.connect(self.pushButtonNextClickedHandler)
        
        self.pushButtonClose = QPushButton('Close', self)
        self.pushButtonClose.setGeometry(200, 60, 70, 30)
        self.pushButtonClose.clicked.connect(self.pushButtonCloseClickedHandler)
        
        self.lastPos = 0
        
    def pushButtonNextClickedHandler(self):
        findWhat = self.lineEditFind.text()
        if findWhat == '':
            QMessageBox.information(self, 'Warning', 'find text must be specified')
            self.lineEditFind.focus()
            return 
        text = self.mainWindow.textEdit.document().toPlainText()
        startPos = text.find(findWhat, self.lastPos)
        if startPos == -1:
            startPos = text.find(findWhat, 0)
            if startPos == -1:
                QMessageBox.information(self, 'Warning', 'Text not found')
                return
        endPos = startPos + len(findWhat)
        
        textCursor = self.mainWindow.textEdit.textCursor()
        textCursor.setPosition(startPos)
        textCursor.setPosition(endPos, QTextCursor.MoveMode.KeepAnchor)
        self.mainWindow.textEdit.setTextCursor(textCursor)
        self.lastPos = endPos
    
    def pushButtonCloseClickedHandler(self):
        self.close()
    
class ReplaceDialog(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle('Replace')        
        self.mainWindow = parent
        
        self.resize(300, 140)
        self.setMaximumSize(300, 140)
        self.setMinimumSize(300, 140)
                
        self.labelFind = QLabel('Text to find:', self)
        self.labelFind.setGeometry(10, 10, 100, 20) 
                
        self.lineEditFind = QLineEdit(self)
        self.lineEditFind.setGeometry(10, 30, 170, 20) 
        
        self.labelReplace = QLabel('Replace text:', self)
        self.labelReplace.setGeometry(10, 55, 100, 20) 
                
        self.lineEditReplace = QLineEdit(self)
        self.lineEditReplace.setGeometry(10, 75, 170, 20) 
        
        self.pushButtonNext = QPushButton('Next', self)
        self.pushButtonNext.setGeometry(210, 30, 70, 30)
        self.pushButtonNext.clicked.connect(self.pushButtonNextClickedHandler)
        
        self.pushButtonReplace = QPushButton('Replace', self)
        self.pushButtonReplace.setGeometry(210, 65, 70, 30)
        self.pushButtonReplace.clicked.connect(self.pushButtonReplaceClickedHandler)
                
        self.pushButtonClose = QPushButton('Close', self)
        self.pushButtonClose.setGeometry(210, 100, 70, 30)
        self.pushButtonClose.clicked.connect(self.pushButtonCloseClickedHandler)
        
        self.lastPos = 0
     
    def pushButtonNextClickedHandler(self):
         findWhat = self.lineEditFind.text()
         if findWhat == '':
             QMessageBox.information(self, 'Warning', 'find text must be specified')
             self.lineEditFind.focus()
             return
         text = self.mainWindow.textEdit.document().toPlainText()
         self.startPos = text.find(findWhat, self.lastPos)
         if self.startPos == -1:
             self.startPos = text.find(findWhat, 0)
             if self.startPos == -1:
                 QMessageBox.information(self, 'Warning', 'Text not found')
                 return
         endPos = self.startPos + len(findWhat)
         
         textCursor = self.mainWindow.textEdit.textCursor()
         textCursor.setPosition(self.startPos)
         textCursor.setPosition(endPos, QTextCursor.MoveMode.KeepAnchor)
         self.mainWindow.textEdit.setTextCursor(textCursor)
         self.lastPos = endPos
            
    def pushButtonReplaceClickedHandler(self):
        replaceText = self.lineEditReplace.text()
        if replaceText == '':
            QMessageBox.information(self, 'Warning', 'replace text must be specified')
            self.lineEditFind.focus()
            return
        textCursor = self.mainWindow.textEdit.textCursor()  
        textCursor.removeSelectedText()
        textCursor.insertText(replaceText)
        self.mainWindow.textEdit.setTextCursor(textCursor)
        self.pushButtonNextClickedHandler()
            
    def pushButtonCloseClickedHandler(self):
     self.close()
          
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
  
#------------------------------------------------------------------------------------------------------------------------------------
    Çok sütunlu ve satırlı tablo oluşturmak için QTableWidget isimli bir GUI elemanı kullanılmaktadır. QTableWidget nesnesi yaratılırken 
    başlangıçtaki sütun ve satır sayıları QTableWidget sınıfının __init__ metodunda verilebilir. Örneğin:

    self.tableWidget = QTableWidget(5, 3, self)
    
    Ya da bu değerler setColumnCount ve setRowCount metotlarıyla belirlenebilir. Örneğin:

    self.tableWidget = QTableWidget(self)
    self.tableWidget.setRowCount(5)
    self.tableWidget.setColumnCount(3)

    Aslında bu GUI elemanında her hücre diğerinden bağımsızdır ve her hücre QTableWidgetItem türündnenbir nesneyle temsil edilmektedir. 
    Sütun hücreleri de aynı biçimdedir. Biz sütun isimlerini tek hamlede setHorizontalHeaderLabels metodu ile set edebiliriz. 
    Örneğin:

    self.tableWidget.setHorizontalHeaderLabels(['Adı Soyadı', 'No', 'Cinsiyet']) 

    Özetle QTableWidget GUI elemanı için önce bu türden bir nesne yaratılır. Sonra satır ve sütun sayısı belirlenir. GUI elemanın 
    sütun GUI elemanın satır ve sütun sayısı belirlendikten sonra artık sütunların yazıları setHorizontalHeaderLabels metodu ile 
    set edilir. Örneğin:

    self.tableWidget = QTableWidget(self)
    self.tableWidget.setRowCount(5)
    self.tableWidget.setColumnCount(3)
    self.tableWidget.setHorizontalHeaderLabels(['Adı Soyadı', 'No', 'Cinsiyet'])
    self.tableWidget.setGeometry(50, 50, 700, 300)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.tableWidget = QTableWidget(self)
        self.tableWidget.setRowCount(5)
        self.tableWidget.setColumnCount(3)
        self.tableWidget.setHorizontalHeaderLabels(['Adı Soyadı', 'No', 'Cinsiyet'])
        self.tableWidget.setGeometry(50, 50, 700, 300)
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında sütun başlıkları QTableWidgetItem nesneleri olarak oluşturulup QTableWidget sınıfının setHorizontalHeaderItem metoduyla 
    da set edilebilir. QTableWidgetItem nesnesi hücrenin içerisinde görüntülenecek olan yazı verilerek yaratılmaktadır. Örneğin:

    qtwiName = QTableWidgetItem('Adı Soyadı')
    qtwiNo = QTableWidgetItem('No')
    qtwiGender = QTableWidgetItem('Cinsiyet')
    
    self.tableWidget.setHorizontalHeaderItem(0, qtwiName)
    self.tableWidget.setHorizontalHeaderItem(1, qtwiNo)
    self.tableWidget.setHorizontalHeaderItem(2, qtwiGender)

    QTableWidget GUI elemanındaki sütunların genişlikleri setColumnWidth metodu ile değiştirilebilmekted.r Örneğin:

    self.tableWidget.setColumnWidth(1, 300)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.vBoxLayout = QVBoxLayout()
        
        self.tableWidget = QTableWidget(self.mainWidget)
        self.tableWidget.setRowCount(5)
        self.tableWidget.setColumnCount(3)
                
        twiName = QTableWidgetItem('Adı Soyadı')
        twiNo = QTableWidgetItem('No')
        twiGender = QTableWidgetItem('Cinsiyet')
        
        self.tableWidget.setHorizontalHeaderItem(0, twiName)
        self.tableWidget.setHorizontalHeaderItem(1, twiNo)
        self.tableWidget.setHorizontalHeaderItem(2, twiGender)
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
                
        self.vBoxLayout.addWidget(self.tableWidget)
        self.vBoxLayout.addWidget(self.pushButtonOk)
        
        self.mainWidget.setLayout(self.vBoxLayout)
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()

#------------------------------------------------------------------------------------------------------------------------------------
    QTableWidget GUI elemanın bir hücresini set etmek için tipik olarak programcı önce bir QTableWidgetItem nesnesi yaratır. Sonra 
    bu nesnenin çeşitli özelliklerini setXXX metotlarıyla set eder. Daha sonra da bu elemanı QTableWidget sınıfının setItem metoduyla 
    hücreye iliştirir. İstedinildiği zaman item metoduyla o hücreye iliştirilmiş olan QTableWidget nesnesi de programcı elde edebilmektedir. 
    QTableWidgetItem sınıfının önemli set metotları şunlardır:

    - setText metodu hücre içerisindeki yazıyı set etmektedir. (QTableWidgetItem nesnesi yaratılırken hücre yazısı zaten yaratım 
    sırasında belirtilebilmektedir.) 
    - setFont metodu hücre içerisindeki yazının fontunu değiştirmek için kullanılır. 
    - setBackground ve setFpreground metotları ile hücrenin zemin rengi ve yazı rengi değiştirilebilir. Bu metotlar QBrush türünden 
    parametre almaktadır. QBrush nesnesi yaratılırken QColor türünden bir renk verilir.
    - setIcon metodu ile hücrenin içerisine bir ikon resmi de yerleştirilebilmektedir.   
    
    QTableWidget nesnesinin hücrelerine klavye ile de giriş yapılabilmektedir. Başlangıçta hiçbir hücrede QTableWidget nesnesi yoktur. 
    Ancak klavyeye ile hücereye giriş yapılırsa bu nesneler oluşturulmaktadır. O anda seçili olan hücrenin QTableWidget nesnesi 
    currentItem metodu ile elde edilebilir. Eğer hücrede QTableWidgetItem nesnesi yoksa bu metot None değeri ile geri dönmektedir. 
    QTableWidget sınıfının  item metodu satır ve sütun numarasıyla belirtilen hücerdeki QTableWidgetItem nesnesini bize vermektedir.
    Eğer hücrede böyle bir nesne yoksa metot None değeri ile geri dönmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        self.vBoxLayout = QVBoxLayout()
        
        self.tableWidget = QTableWidget(self.mainWidget)
        self.tableWidget.setRowCount(5)
        self.tableWidget.setColumnCount(3)
        #self.tableWidget.setGeometry(50, 50, 700, 300)
        
        twiName = QTableWidgetItem('Adı Soyadı')
        twiNo = QTableWidgetItem('No')
        twiGender = QTableWidgetItem('Cinsiyet')
        
        self.tableWidget.setHorizontalHeaderItem(0, twiName)
        self.tableWidget.setHorizontalHeaderItem(1, twiNo)
        self.tableWidget.setHorizontalHeaderItem(2, twiGender)
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setFixedHeight(50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
                
        self.vBoxLayout.addWidget(self.tableWidget)
        self.vBoxLayout.addWidget(self.pushButtonOk)
        
        self.mainWidget.setLayout(self.vBoxLayout)
        
        twi = QTableWidgetItem('x.txt')
        twi.setFont(QFont('Arial', 14))
        twi.setBackground(QBrush(QColor('Yellow')))
        twi.setForeground(QBrush(QColor('Red')))
        twi.setIcon(QIcon('ChessFigures/whitebishop.png'))
        
        self.tableWidget.setItem(2, 2, twi)
    
    def pushButtonClickedHandler(self):
        twi = self.tableWidget.currentItem()
        if twi:
            print(twi.text())
        else:
            print('Hücrede QTableWidgetItem nesnesi yok')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                            40. Ders 27/07/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QTableWidget hücrelerini set etmek biraz zahmetlidir. Ancak programcı genellikle zaten elinde olan birtakım bilgilerden hareketle 
    bir döngü içerisinde bu işlemi yapar. Programcı setRowCount ile GUI elemanındaki satırları artırabileceği gibi insertRow metoduyla 
    da bu işi yapabilir. insertRow metoduba belli bir satır numarası verilir, metot oraya yeni bir satır inset eder. insertRow metodu 
    aynı zamanda append işlemini de yapabilmektedir. Ayrıca sınıfın append ya da add isimli metodu yoktur. 

    Aşağıdaki örnekte menüden bir dizin seçilmiş ve o dizin içerisindeki dosyaların isimleri, uzunlukları ve son değiştirilme zamanları
    QTableWidget içerisinde gösterilmiştir. Ok düğmesine basıldığında seçilen hücrenin içeriği 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import os
from os.path import getsize, getmtime
import time
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        menuBar = self.menuBar()
        filePopup = QMenu('&File', self)

        self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open folder...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        filePopup.addAction(self.openAction)
        
        menuBar.addMenu(filePopup)
        
        self.vBoxLayout = QVBoxLayout()
        
        self.tableWidget = QTableWidget(self.mainWidget)
        self.tableWidget.setColumnCount(3)
        self.tableWidget.setHorizontalHeaderLabels(['Dosya İsmi', 'Uzunluk', 'Değiştirilme Tarihi'])
        self.tableWidget.setColumnWidth(0, 400)
        self.tableWidget.setColumnWidth(1, 100)
        self.tableWidget.setColumnWidth(2, 300)
        self.setStyleSheet("""
                           QTableWidget {font-size: 14pt}
                           QHeaderView::section {
                            font-family: "Arial";
                            font-size: 12pt;
                            font-weight: bold;
                            color: black;
                            background-color: lightgray;
                            padding: 4px;
                            }""")
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setFixedHeight(50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
                
        self.vBoxLayout.addWidget(self.tableWidget)
        self.vBoxLayout.addWidget(self.pushButtonOk)
        
        self.mainWidget.setLayout(self.vBoxLayout)
    
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self)
        fd.setWindowTitle('Choose a folder')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.Directory)
        if fd.exec() == QDialog.DialogCode.Accepted:
            dirPath = fd.selectedFiles()[0]   
            dirList = os.listdir(dirPath)
            for index, fname in enumerate(dirList):
                path = dirPath + '\\' + fname
                size = str(getsize(path))
                lt = time.localtime(getmtime(path))
                mtime = f'{lt.tm_year:04d}.{lt.tm_mon:02d}.{lt.tm_mday:02d} {lt.tm_hour:02d}:{lt.tm_min:02d}:{lt.tm_sec:02d}'
                twiName = QTableWidgetItem(fname)
                twiSize = QTableWidgetItem(size)
                twiModifiedTime = QTableWidgetItem(mtime)
                self.tableWidget.insertRow(index)
                self.tableWidget.setItem(index, 0, twiName)
                self.tableWidget.setItem(index, 1, twiSize)
                self.tableWidget.setItem(index, 2, twiModifiedTime)
                            
    def pushButtonClickedHandler(self):
        twi = self.tableWidget.currentItem()
        if twi:
            QMessageBox.information(self, 'Info', twi.text())
        else:
            QMessageBox.information(self, 'Info', 'Invalid item')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir CSV dosyasından hareketle QTableWidget nesnesini de benzer biçimde doldurabiliriz. Aşağıda buna ilişkin bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import csv
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        menuBar = self.menuBar()
        filePopup = QMenu('&File', self)

        self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        filePopup.addAction(self.openAction)
        
        menuBar.addMenu(filePopup)
        
        self.vBoxLayout = QVBoxLayout()
        
        self.tableWidget = QTableWidget(self.mainWidget)   
        self.setStyleSheet("""
                           QTableWidget {font-size: 14pt}
                           QHeaderView::section {
                            font-family: "Arial";
                            font-size: 12pt;
                            font-weight: bold;
                            color: black;
                            background-color: lightgray;
                            padding: 4px;
                            }""")
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setFixedHeight(50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
                
        self.vBoxLayout.addWidget(self.tableWidget)
        self.vBoxLayout.addWidget(self.pushButtonOk)
        
        self.mainWidget.setLayout(self.vBoxLayout)
   
 
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self, 'Choose a file', '.', 'CSV files(*.csv);;All files(*.*)')
        fd.setWindowTitle('Choose a folder')
        fd.setDirectory('.')
        
        if fd.exec() == QDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            try:
                with open(path) as f:
                    csv_iter = csv.reader(f)
                    header = next(csv_iter)
                    self.tableWidget.setColumnCount(len(header))
                    self.tableWidget.setHorizontalHeaderLabels(header)
                    for col in range(len(header)):
                        self.tableWidget.setColumnWidth(col, 200)
                    for index, t in enumerate(csv_iter):
                        if len(t) == 0:
                            continue
                        if len(t) != len(header):
                            raise ValueError('CSV file format invalid')
                        self.tableWidget.insertRow(index)
                        for col in range(len(header)):
                            twi = QTableWidgetItem(t[col])
                            self.tableWidget.setItem(index, col, twi) 
            except Exception as e:
                QMessageBox.information(self, 'Error', str(e))
            
                            
    def pushButtonClickedHandler(self):
        twi = self.tableWidget.currentItem()
        if twi:
            QMessageBox.information(self, 'Info', twi.text())
        else:
            QMessageBox.information(self, 'Info', 'Invalid item')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QTableWidget sınıfının en önemli sinyalleri şunlardır:
    
    currentItemChanged(twiNew, twiOld)
    itemClicked(rwi)
    itemDoubleClicked(twi)
        
    Aşağıdaki örnekte currentItemChanged sinyali kullanılarak o anda seçili olan elemanın fontu büyütülü bold hale getirilmiştir. 
    Bu sinyal table widget ilk kez görüntülendiğinde de oluşturulmaktadır. Kodumuzda sinyal metodu şöyle yazılmıştır:

    def tableWidgetcurrentItemChangedHandler(self, newTwi, oldTwi):
        if oldTwi is None:
            return
        font = newTwi.font()
        oldTwi.setFont(font)
        font.setPointSize(16)
        font.setBold(True)
        newTwi.setFont(font)

    Burada table widget ilk kez görüntülendiğinde oldTwi None olacağından özel bir kontrol yapılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import csv
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        self.mainWidget = QWidget()
        self.setCentralWidget(self.mainWidget)
        
        menuBar = self.menuBar()
        filePopup = QMenu('&File', self)

        self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        filePopup.addAction(self.openAction)
        
        menuBar.addMenu(filePopup)
        
        self.vBoxLayout = QVBoxLayout()
        
        self.tableWidget = QTableWidget(self.mainWidget)   
        self.tableWidget.setStyleSheet("""
                           QTableWidget {font-size: 14pt}
                           QHeaderView::section {
                            font-family: "Arial";
                            font-size: 12pt;
                            font-weight: bold;
                            color: black;
                            background-color: lightgray;
                            padding: 4px;
                            }""")
        self.tableWidget.currentItemChanged.connect(self.tableWidgetcurrentItemChangedHandler)
        
        self.pushButtonOk = QPushButton('Ok', self.mainWidget)
        self.pushButtonOk.setFixedHeight(50)
        self.pushButtonOk.clicked.connect(self.pushButtonClickedHandler)
                
        self.vBoxLayout.addWidget(self.tableWidget)
        self.vBoxLayout.addWidget(self.pushButtonOk)
        
        self.mainWidget.setLayout(self.vBoxLayout)
        
    def tableWidgetcurrentItemChangedHandler(self, newTwi, oldTwi):
        if oldTwi is None:
            return
        font = newTwi.font()
        oldTwi.setFont(font)
        font.setPointSize(16)
        font.setBold(True)
        newTwi.setFont(font)
    
    def openActionTriggeredHandler(self):
        fd = QFileDialog(self, 'Choose a file', '.', 'CSV files(*.csv);;All files(*.*)')
        fd.setWindowTitle('Choose a folder')
        fd.setDirectory('.')
        
        if fd.exec() == QDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            try:
                with open(path) as f:
                    csv_iter = csv.reader(f)
                    header = next(csv_iter)
                    self.tableWidget.setColumnCount(len(header))
                    self.tableWidget.setHorizontalHeaderLabels(header)
                    for col in range(len(header)):
                        self.tableWidget.setColumnWidth(col, 200)
                    for index, t in enumerate(csv_iter):
                        if len(t) == 0:
                            continue
                        if len(t) != len(header):
                            raise ValueError('CSV file format invalid')
                        self.tableWidget.insertRow(index)
                        for col in range(len(header)):
                            twi = QTableWidgetItem(t[col])
                            self.tableWidget.setItem(index, col, twi) 
            except Exception as e:
                QMessageBox.information(self, 'Error', str(e))      
                            
    def pushButtonClickedHandler(self):
        twi = self.tableWidget.currentItem()
        if twi:
            QMessageBox.information(self, 'Info', twi.text())
        else:
            QMessageBox.information(self, 'Info', 'Invalid item')
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI ortamlarında "resource" denilen bir kavram sıkça kullanılmaktadır. Resource birtakım küçük görsel öğelerin, seslerin, yazılarına
    vs. bir dosya içerisine yerleştirilmesi ve mümkünse çalıştırılabilen dosyanın içerisine gömülmesi anlamına gelmektedir. Gerçekten 
    de aslında Qt'yi C++'tan kullanırken programcılar genel olarak menülerdeki ikonları, resimleri, sesleri vs. resource olarak ele 
    alıp onları çalıştırılabilen dosyanın içerisine gömerler. Ancak Python yorumlayıcı sistemle çalıştığı için bu tür öğelerin 
    çalıştrılabilir dosyalar içerisine gömülmesi mümkün olamamaktadır. Ancak yine de PyQt'de designer kullanılarak resource 
    oluşturulabilmektedir. Programcı designer'daki "resource browser"ı kullanarak uzantası .qrc olan bir xml dosyasını yaratır. 
    Sonra yine designer'dan bir prefix belirterek (bu prefix'in önemi şimdilik yoktur. / biçiminde belirlenebilir) görsel öğeleri 
    bu resource dosyasının içerisine yerleştirir. Bu resource dosyasından yine bir Python dosyasının elde edilmesi gerekmektedir. 
    Bu işlem pyrcc6 programıyla aşağıdaki gibi yapılmaktadır:

    pyrcc6 -o myresources_rc.py myresources.qrc

    Buradaki py dosyası designer'da yaratılan isimdeki .qrc dosyasının sonuna _rc getirilierek oluşturulmalıdır. Çünkü pyuic6
    programı bu resource dosyasını kendi içerisinde bu isimle import etmektedir. Böylece artık programcı bütün küçük resimcikleri 
    vs. bu py dosyasının içerisine gömmüş olur. Tabii programı konuşlandırırken bu .py dosyasının da ilgili yere götürülmesi 
    gerekmektedir. 

    Python programları bir yorumlayıcı sistemle çalıştırıldığı için resource kavramı C++'taki gibi önemli ve etkin değildir. 
    Genellikle PyQt programcıları bu tarzda resource dosyalarını kullanmamaktadır.

    Sonuç olarak resource kullanımı için yapılacak işlemler şunlardır:

    1) Küçük resimcikler, ses dosyaları vs. QT Designer'daki "Resource Browser"dan ".rc" dosyasına görsel olarak eklenir. 
    2) Daha sonra Qt Designer'da ne zaman bir resim, ikon vs. kullanılacak olsa "Choose File" yerine "Choose Resource" seçilmelidir. 
    3) Programcı artık ".ui" dosyasını da ".qrc" dosyasını da Python programı haline getirmelidir. ".qrc" dosyasını python programı 
    haline getirirken dosya ismine "_rc" eklemelidir. Örneğin ".ui" dosyasının ismi "mainwindow.ui", ".qrc" dosyasının ismi ise 
    "myresource.qrc" olsun. Dönüştürmeler şöyle yapılmalıdır:

    pyuic6 -o mainwindow.py mainwindow.ui
    pyrcc6 -o myresource_rc myresource.qrc
    
    4) Program taşınırken üç dosya taşınmalıdır: 
    
    - Asıl ".py" dosyası (sample.py), 
    - ".ui" dosyasından dönüştürülen Python dosyası (mainwindow.py) ve
    - Resource dosyasından dönüştürülen Python dosyası (myresource_rc.py)

    Aslında resource dosyasına girilen öğeler bir dosya gibi de kullanılabilmektedir. Dosya sistemlerinde dosya isimleri ':' ile 
    başlayamaz. İşte resource içerisine yerleştirdiğimiz öğeyi ':' ile başlatarak sanki bir yol ifadesiymiş gibi kullanabiliriz. 
    "Örneğin biz Qt Designer'da bir QLabel nesnesi oluşturup onun ismini labelPicture biçiminde vermiş olalım. Ancak bu QLabel 
    nesnesine resmi designer üzerinden değil programlama yoluyla iliştirmek isteyelim. İliştirmek istediğimiz resim de resource
    içerisinde "/AbbyRoad.jpg" isminde olsun. İşte sanki bu resource ismini bir yol ifadesi gibi başına ':' getirerek kod içerisinde 
    kullanabiliriz. Örneğin:

    import sys
    from PyQt6.QtCore import *
    from PyQt6.QtWidgets import *
    from PyQt6.QtGui import *

    import mainwindow
    import myresource_rc

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()       
            self.resize(800, 600)
            
            self.ui = mainwindow.Ui_MainWindow()
            self.ui.setupUi(self)
            
            self.ui.labelPicture.setPixmap(QPixmap(':/AbbeyRoad.jpg'))
                    
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()

    Burada yol ifadesinin nasıl oluşturulduğuna dikkat ediniz:

    self.ui.labelPicture.setPixmap(QPixmap(':/AbbeyRoad.jpg'))
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            41. Ders 03/08/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde PyQt'de pencere içerisine nasıl çizim yapılacağını göreceğiz. Biz şimdiye kadar zaten hazır olan GUI elemanlaır kullanarak 
    GUI denemeleri yaptık. Şimdi pencere içerisine doğrudan çizim yapacağız. Aslında şimdiye kullanmış olduğumuz GUI elemanlar bütün 
    gördüğümüz arayüzü çizim yaparak oluşturmaktadır. QCheckBox penceresini düşünelim. Bu pencerede bir küçük kare ve yanzında yazı 
    vardır. Pencereye tıklandığında bu kare çarpılanmakta bir daha tıklandığında bu karenin çarpısı gitmektedir. İşte QCheckBox sınıfını
    yazanlar bu kare şeklini, çarpılama şeklini, karenin yanındanki yazıları heo çizim yaparak oluşturmuştur. Eğer siz de kendine 
    özel alt pencereler oluşturmak istiyorsanız (bunlara "custom widget" denilmektedir) çizim konusunu biliyor olmanız gerekir. 
    Aslında pencerede bir yazının görüntülenmesi de bir çizim faaliyetidir. Biz pencerede yazı görüntülemek için QLabel nesnelerini
    kullanmıştık. Aslında yazıyı pencereye çizdiren bu QLabel sınıfıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    PyQt'de çizim yapmak için paintEvent isimli bir metodu kullanmak gerekir. Windows işletim sistemi ve bazı pencere alt sistemleri 
    bir pencere başka bir pencerenin üzerine getirilip çekildiğinde arka plandaki pencerenin görüntüsünü otomatik olarak saklayıp 
    programcı için yeniden basmamaktadır. Bu tür durumlarda örneğin Windows bir pencerenin görünmeyen bir kısmı görünür hale geldiğinde 
    çizimi kendisi saklayıp geri basmak yerine onun yeniden çizilmesi sorumluluğunu programcıya bırakmaktadır. Pencerenin görünmeyen 
    bir kısmı görünür hale geldiğinde Windows bu pencereye WM_PAINT denilen bir mesaj gönderir. Bu mesajı alan programcı çizimi yeniden 
    yaparak bozulan görüntüyü oluşturmaktadır. Bu durumda Windows gibi sistemlerde tüm çizimlerin bu mesajda yapılması gerekmektedir. 
    Aksi takdirde pencere içerisindeki görüntü bozulabilecektir. Gerçi her sistemdeki pencere yönetici alt sistemi böyle davranmamaktadır. 
    Hatta örneğin Windows 8 versiyonundan itibaren artık bazı durumlarda Windows bile pencere içeriğini kendisi saklayıp WM_PAINT 
    mesajını daha az göndermektedir. Bazı sistemler tamamen bütün çizimi kendisi saklamakta böyle bir mesaj mekanizmasını hiç bulundurmamaktadır. 
    Ancak Qt framework'ü cross platform olduğu için bu mesaj sistemi uygulanacakmış gibi programcının kodunu organize etmesi gerekmektedir. 
    Qt'de WM_PAINT gibi bir mesaj Qt tarafından alındığında Qt buna karşılık ilgili sınıfın paintEvent isimli metodunu çağırmaktadır. 
    Bu metoda QPaintEvent isimli bir nesne de parametre olarak geçirilmektedr. İşte Qt'de çizimlerin bu paintEvent metodu içerisinde 
    yapılması gerekir. Eğer çizimler paintEvent metodunun içerisinde yapılmazsa yapılan çizimler pencerenin bir kısmı "invalidate" 
    olduğunda kaybolmaktadır. 

    Pekiyi biz kendi çizimlerimizi paintEvent metodunda yapacağız. Ya penceremizin içerisinde QPushButton gibi, QListWidget gibi 
    alt pencereler varsa onların görüntüsü bozulmayacak mı? İşte işletim sistemleri ya da pencere yönetici alt sistemler ister üst 
    pencere olsun isterse alt pencere olsun görüntüsü bozulan her pencereye bunu bildiren mesajı göndermektedir. Yani her pencere 
    kendi görüntüsünü yeniden oluşturmaktan sorumludur. Örneğin QPushButton sınıfını yazanlar kendi sınıflarında paintEvent metodunu 
    yazarak zaten bozulan düğme görüntüsünü kendileri yeniden oluşturmuştur. Bizim GUI elemanların içerisindeki çizimler için 
    kaygılanmamıza gerek kalmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi painEvent metodu içerisinde biz çizimleri nasıl yapacağız? İşte QPainter isimli bir sınıf vardır. Programcı çizimleri 
    hangi pencereye yapacaksa o pencere nesnesini vererek QPainter nesnesi elde eder ve çizileri bu QPainter sınıfının metotlarıyla 
    yapar. Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        ...

    QPainter sınıfının drawXXX, fillXXX gibi metotları vardır. Çizimler bu metotlarla yapılmaktadır. Örneğin drawLine isimli metot iki 
    nokta arasında doğru çizer. drawEllipse isimli metot bir elips çizmektedir. Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawLine(0, 0, 100, 100)
        painter.drawEllipse(200, 200, 100, 100)

    Benzer biçimde drawRect bir dikdörtgen çizmekte, drawText ise bir yazı yazmaktadır. Örneğin QLabel GUI elemanının aslında yaptığı 
    şey kendi içerisinde verilen yazıyı paintEvent metodunda drawText ile yazdırmaktır. Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawEllipse(10, 10, 100, 100)
        painter.drawLine(100, 100, 200, 200)
        painter.drawRect(200, 300, 200, 100)
        painter.drawText(300, 100, 'This is a test')            
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawEllipse(10, 10, 100, 100)
        painter.drawLine(100, 100, 200, 200)
        painter.drawRect(200, 300, 200, 100)
        painter.drawText(300, 100, 'This is a test')
                
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Qt programcısının QPainter sınıfının drawXX ve fillXXX metotlarının neler olduğunu ve bu metotların parametrelerinin nasıl kullanıldığını 
    bilmesi gerekir.  Kullanılan drawXX metotlarından önemli olanları şunlardır:

    - İki noktayı birleştiren doğru parçasını çizdirmek için drawLine metodu  kullanılır:

    drawLine(pt1, pt2) 
    drawLine(x1, x2, y1, y2)

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawLine(100, 100, 200, 200)

    - drawLines metodu bir QPoint listesi alır. Listenin yan yana iki elemanından doğrular çizer. 

    drawLines(pointes)

    Örneğin:

    painter = QPainter(self)
    points = [QPoint(10, 10), QPoint(100, 10), QPoint(200, 100), QPoint(200, 200)]
    painter.drawLines(points)

    - drawPolyline ve drawPolygon metotları bir QPoint listesi alır. Listenin içerisindeki noktaları doğrularla birleştirir. 
    Ancak drawPolygon son noktayı ilk noktayla da birleştirerek şekli kapatmaktadır. 

    drawPolyline(points)
    drawPolygon(oints)

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        points = [QPoint(10, 10), QPoint(100, 10), QPoint(200, 100), QPoint(200, 200)]
        painter.drawPolygon(points)

    - Sol-üst köşe ve genişlik-yükseklik verilerek dikdörtgen çizdirmek için drawRect metodu kullanılmaktadır:
    
    drawRect(qrect) 
    drawRec(x1, y1, width, height)

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawRect(100, 100, 100, 100)

    - Bir dikdörtgenin iç teğet elipsini çizmek için drawEllipse metodu kullanılmaktadır:

    drawEllipse(qrect)                                          # dikdörtgenin iç teğet elipsi
    darwEllipse(x1, y1, width, height)                          # dikdörtgenim iç teğet elipsi
    
    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawEllipse(self.rect())
       

    - Bir elipsin belli bir yayı drawArch metoduyla çizdirilebilir. Bu metot bizden elipsin dikdörtgenini, yayın başlangıç açısını ve 
    süpürme açısını almaktadır. Açılar dercenin 16'da biridir. Yani 1 derecenin 16'da bir hassasiyetinde açı belirtilebilmektedir:

    drawArch(qrect, startAngle, spanAngle)                      # derecenin 16'da biri
    drawArch(x1, y1, width, height, startAngle, spanAngle)      # derecenin 16'da biri

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        rect = QRect(100, 100, 100, 100)
        painter.drawRect(rect)
        painter.drawArc(rect, 0 * 16, 90 * 16)

    - drawPie metodu bir elips dilimini çizdirmek için kullanılmaktadır. Parametreler drawArc ile aynıdır:

    drawPie(qrect, startAngle, spanAngle)                       # derecenin 16'da biri
    drawPie(x1, y1, width, height, startAngle, spanAngle)       # derecenin 16'da biri

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        rect = QRect(100, 100, 100, 100)
        painter.drawPie(rect, 0 * 16, 90 * 16)
        
    Bir kiriş çizmek için drawChord metodu kullanılır. Burada yay ile yayın uçları bir doğru ile birleştirilmektedir:

    drawChord(qrect, startAngle, spanAngle)                     # derecenin 16'da biri
    drawChord(x1, y1, width, height, startAngle, spanAngle)     # derecenin 16'da biri
    
    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        rect = QRect(100, 100, 100, 100)
        painter.drawPie(rect, 0 * 16, 90 * 16)

    - Belli bir noktaya tek bir pizel yerleştirmek için drawPoint metodu kullanılmaktadır:

    drawPoint(qpoint)
    drawPoint(x, y)

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawRect(100, 100, 100, 100)
        painter.drawPoint(150, 150)
       
    - Pencere içine bir yazı yazdırmak için darwText metodu kullanılır. Burada yazının sol alt köşesine (base line) ilişkin nokta ve 
    yazı metoda parametre olarak verilmektedir:

    drawText(x, y, text)
    drawText(qpoint, text)

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawText(100, 100, 'Ankara')

    - drawText metodunun ilk paraöetresi QRect olarak geçilirse ikinci parametre aşağıdaki sembolik sabitlerin | opereatörü ile 
    bit düzeyinde OR işlemine sokulmasıyla oluşturulur. 
    
    drawText(rect, flag, text)                          # dikdörtgensel bir bölgenin çeşitli yerlerine yazar
    
    Üçücüncü parametre de yazıyı belirtir. İkinci parametre yatay ve düşey için hizalama belirtmektedir. Bir dikdörtgende toplam 
    9 hizalama noktası vardır. Bu 9 hizalama noktasını aşağıdaki gibi belirtebiliriz:

    T T T
    T T T 
    T T T 

    Burada kullanılan sembolik sabitler şunlardır:

    Qt.AlignmentFlag.AlignLeft
    Qt.AlignmentFlag.AlignRight
    Qt.AlignmentFlag.AlignJustify
    Qt.AlignmentFlag.AlignTop
    Qt.AlignmentFlag.AlignBottom
    Qt.AlignmentFlag.AlignVCenter
    Qt.AlignmentFlag.AlignCenter   
  
    Yazının sarmalama yapması için Qt.TextFlag.TextWordWrap sembolik sabiti kullanılmaktadır. 

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        rect = QRect(100, 100, 100, 100)
        painter.drawRect(rect)
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter|Qt.AlignmentFlag.AlignVCenter, 'Ankara')
 

    Örneğin:
       def paintEvent(self, pe):
        painter = QPainter(self)
        rect = QRect(100, 100, 100, 100)
        painter.drawRect(rect)
        painter.drawText(rect, Qt.AlignmentFlag.AlignLeft|Qt.AlignmentFlag.AlignTop|Qt.TextFlag.TextWordWrap, 
                    'Bugün hava çok güzel, evet çok güzel')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QPainter sınıfının drawXXX metotları çizimi kalem (pen) nesnesiyle yapmaktadır. Default kalem 1 kalınlıklı, siyah, düz (solid) 
    bir kalemdir. Kalemler QPen sınıfıyla temsil edilmiştir. Yeni bir kalem kullanmak için QPen sınıfı türünden bir nesne yaratılır. 
    Sonra kalemin özellikleri QPen sınıfının __init__ metodunda ya da daha sonra setXXX metotlarıyla set edilir. Daha sonra da 
    QPainter sınıfının setPen metoduyla bu kalem aktif hale getirilir. Örneğin QPen nesnesş bir QBrusb nesnesi, kalınlık ve çizgi stili
    belirtilerek yaratılabilir:

    pen = QPen(QBrush(QColor(255, 0, 0)), 5, Qt.PenStyle.DotLine)

    Çizgi stilleri şunlardan biri olabilir:

    Qt.PenStyle.NoPen    
    Qt.PenStyle.SolidLine    
    Qt.PenStyle.DashLine    
    Qt.PenStyle.DotLine    
    Qt.PenStyle.DashDotLine    
    Qt.PenStyle.DashDotDotLine    
    Qt.PenStyle.CustomDashLine

    Tabii aslında önce QPen nesnesini parametre belirtmenden yaratıp sonra sınııfn setXXX metotlarıyla da kalemin özelliklerini set 
    edebiliriz:

    pen = QPen()
    pen.setColor(QColor(255, 0, 0))
    pen.setWidth(5)
    pen.setStyle(Qt.PenStyle.DashLine)

    Bazı çizimlerin değişik kalemlerle yapılması isteniyorsa kalemler oluşturulup setPen ile değiştirilmelidir. Mevcut kalem QPainter 
    sınıfının pen metoduyla elde edilebilir. Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        oldPen = painter.pen()
        
        pen = QPen()
        pen.setColor(QColor(255, 0, 0))
        pen.setWidth(5)
        pen.setStyle(Qt.PenStyle.DashLine)
        painter.setPen(pen)
        
        painter.drawEllipse(100, 100, 100, 100)
        painter.drawLine(10, 10, 50, 50)
       
        painter.setPen(oldPen)
        painter.drawRect(300, 300, 100, 100)

    Burada önce default kalem oldPen değişkeninde saklanmış bir kalem yaratılıp çizim bu kalemle elips ve doğru çizilmiştir. 
    Daha sonra eski kalem set edilip bu eski kalemle dikdörtgen çizilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)

    def paintEvent(self, pe):
        painter = QPainter(self)
        oldPen = painter.pen()
        
        pen = QPen()
        pen.setColor(QColor(255, 0, 0))
        pen.setWidth(5)
        pen.setStyle(Qt.PenStyle.DashLine)
        painter.setPen(pen)
        
        painter.drawEllipse(100, 100, 100, 100)
        painter.drawLine(10, 10, 50, 50)
       
        painter.setPen(oldPen)
        painter.drawRect(300, 300, 100, 100)
                        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Kapalı şekillerin içi fırçayla boyanmaktadır. Fırça kavramı QBrush sınıfı ile temsil edilmiştir. Bir fırçanın pek çok özelliği 
    vardır. Bu özelliklerin bazıları QBrush nesnesi yaratılırken __init__ metodunun parametrelerinde set edilebilir. Genel olarak 
    bütün özellikleri set eden setXXX metotları vardır. Örneğin:

    brush = QBrush()
    brush.setColor(QColor('Yellow'))
    
    Fırçalar oluşturulduktan sonra QPainter nesnesinin ilgili fırçayı kullanabilmesi için setBrush metodu ile set edilmesi gerekir. 
    Artık drawXXX metotları ile kapalı şekiller çizilirken kapalı şekillerin içi otomatik olarak bu set edilen fırça ile boyanacaktır. 
    Default fırça bir boyama yapmayan fırçadır. Örneğin:

     def paintEvent(self, pe):
        painter = QPainter(self)
        
        pen = QPen()
        pen.setColor(QColor('Red'))
        painter.setPen(pen)
        
        brush = QBrush(QColor('Yellow'))
        painter.setBrush(brush)

        painter.drawRect(100, 100, 200, 200)

        Burada önce bir kalem sonra bir fırça nesnesi yaratılıp QPainter sınıfının setPen ve setBrush metotlarıyla set edilmiştir. 
        Artık drawRect metodu dikdörtgenin sınır çizgilerini kalemle, içini de fırçayla boyayacaktır. 
    
        Fırçaların boyama biçimleri QBrush sınıfının setStyle metodu ile set edilebilir. Boyama biçimleri şunlardan biri olabilir:

        from PyQt6.QtCore import Qt

    Qt.BrushStyle.NoBrush                   # Dolgu yok
    Qt.BrushStyle.SolidPattern              # Tek renk dolgu
    Qt.BrushStyle.Dense1Pattern             # Çok sık dolgu
    Qt.BrushStyle.Dense2Pattern
    Qt.BrushStyle.Dense3Pattern
    Qt.BrushStyle.Dense4Pattern
    Qt.BrushStyle.Dense5Pattern
    Qt.BrushStyle.Dense6Pattern
    Qt.BrushStyle.Dense7Pattern             # Çok seyrek dolgu
    Qt.BrushStyle.HorPattern                # Yatay çizgiler
    Qt.BrushStyle.VerPattern                # Dikey çizgiler
    Qt.BrushStyle.CrossPattern              # Dikey + yatay çizgiler
    Qt.BrushStyle.BDiagPattern              # Ters çapraz çizgiler
    Qt.BrushStyle.FDiagPattern              # Normal çapraz çizgiler
    Qt.BrushStyle.DiagCrossPattern          # Çapraz çizgiler kesişimi
    Qt.BrushStyle.LinearGradientPattern     # Doğrusal geçiş
    Qt.BrushStyle.RadialGradientPattern     # Dairesel geçiş
    Qt.BrushStyle.ConicalGradientPattern    # Konik geçiş
    Qt.BrushStyle.TexturePattern            # Doku (pixmap) deseni

    Örneğin:

    def paintEvent(self, pe):
        painter = QPainter(self)
        
        pen = QPen()
        pen.setColor(QColor('Red'))
        painter.setPen(pen)
        
        brush = QBrush()
        brush.setColor(QColor('Red'))
        brush.setStyle(Qt.BrushStyle.BDiagPattern)
        painter.setBrush(brush)

        painter.drawRect(100, 100, 200, 200)


    Aşağıda fırça kullanmaya bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        
        pen = QPen()
        pen.setColor(QColor('Red'))
        painter.setPen(pen)
        
        brush = QBrush()
        brush.setColor(QColor('Red'))
        brush.setStyle(Qt.BrushStyle.BDiagPattern)
        painter.setBrush(brush)

        painter.drawRect(100, 100, 200, 200)

        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                                42. Ders 09/08/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    QBrush sınıfının setTexture metodu ile bir resmi fırçanın boyama resmi olarak set edebiliriz. Bu durumda boyamam yapıldıkça bu 
    resim gözükür.  Tabii bu biçimdeki resimlerin küçük resimcikler olması uygun olur. Budurumda resim yatayda ve düşeyde yinelenecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        
        pen = QPen()
        pen.setColor(QColor('Red'))
        painter.setPen(pen)
        
        brush = QBrush()
        brush.setColor(QColor('Red'))
        brush.setTexture(QPixmap('MenuIcons/open.png'))
        painter.setBrush(brush)

        painter.drawRect(100, 100, 200, 200)
   
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QPainter sınıfının fillxxx biçimindeki metotları kapalı bir çizimin sınırları olmadan yalnızca boyamasını yapmaktadır. Bu fillXXX
    metotları bizden QBrush nesnesi istemektedir. Örneğin fillRect metodu bir dikdörtgenin içini verilen fırçayla boyamaktadır. fillPath
    belli bir yolun içindeki kapalı şekli boyamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        
        painter.fillRect(500, 100, 200, 200, QBrush(QColor('yellow')))
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resmi QLabel kullanmadan doğrudan da QPainter sınıfının drawPixmap metoduyla da çizdirebiliriz. drawPixmap metodu birkaç biçimde
    kullanılabilmektedir. Metoda biz bir noktanın x ve y koordinatlarını ve bir QPixmap nesnesini verirsek metot resmin sol üst 
    köşesi belirttiğimiz koordinatta olacak biçimde resmi çizer. Örneğin:

    painter.drawPixmap(50, 50, QPixmap('AbbeyRoad.jpg'))
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawPixmap(50, 50, QPixmap('AbbeyRoad.jpg'))
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    QPixmap metoduna biz dikdörtgensel bir bölgeyi verirsek metot resmi o dikdörtgen içerisine boyutlandırarak çizer. Tabii resim 
    boyutlandırıldığı için en-boy oranı bozulabilecektir. Örneğin:

    painter.drawPixmap(100, 100, 200, 200, QPixmap('AbbeyRoad.jpg'))
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        
        painter.drawPixmap(100, 100, 200, 200, QPixmap('AbbeyRoad.jpg'))
       
        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Resmi dikdörtgen içerisine en boy oranını muhafaza ederek çizmek isiyorsanız daha önce görmüş olduğumuz gibi resmi QPixmap sınıfının 
    scaled metodu kullanılabilir. Bunun için önce sınıfın scaled metodu ile resim ölçeklendirilir. Sonra da ölçeklendirilmiş resim 
    istenilen yere çizilir. Örneğin:

    pixmap = QPixmap('AbbeyRoad.jpg').scaled(500, 500,  Qt.AspectRatioMode.KeepAspectRatio)
    painter.drawPixmap(50, 50, pixmap)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        pixmap = QPixmap('AbbeyRoad.jpg').scaled(500, 500,  Qt.AspectRatioMode.KeepAspectRatio)
        painter.drawPixmap(50, 50, pixmap)
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Biz bir resmin belli bir kısmını ölçeklendirerek de çizebiliriz. Bunun drawPixmap metoduna önce bir dikdörtgen, sonra bir pixmap 
    nesnesi, sonra da resmin ilgili kısmı dikdörtgen olarak verilir. Örneğin:

    painter.drawPixmap(50, 50, 200, 200, pixmap, 200, 200, 200, 200)
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        pixmap = QPixmap('AbbeyRoad.jpg')
        painter.drawPixmap(50, 50, 200, 200, pixmap, 200, 200, 200, 200)
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de  drawPixmap metotlarının kullanımlarını bir liste olarak verelim:

    drawPixmap(x, y, pixmap)                        # Resmin tamamını sol üst köşesi x, y koordinatında olacak biçimde çizer
    drawPixmap(qpoint, pixmap)                      # Resmin tamamını sol üst köşesi x, y koordinatında olacak biçimde çizer
    drawPixmap(x, y, width, height, pixmap)         # Resmin tamamını dikdörtgen içerisine scale ederek çizer
    drawPixmap(qrect, width, height, pixmap)        # Resmin tamamını dikdörtgen içerisine scale ederek çizer
    drawPixmap(x1, y1, width1, height1, pixmap, x2, y2, width2, height2)        # Resmin belli bir dikdörtrgensel bölgesini belli bir dikdörtgensel 
                                                                                # bölgeye scale ederek çizdirir. Birinci dikdöertgen hedef ikincisi kaynak belirtir.
    drawPixmap(rect1, pixmap, rect2)                # Resmin belli bir dikdörtrgensel bölgesini belli bir dikdörtgensel                                                                         # bölgeye scale ederek çizdirir.  Birinci dikdöertgen hedef ikincisi kaynak belirtir.

    Diğer özellikler için Qt dokümanlarına başvurabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında en boy oranının korunması manuel de yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        
        self.setWindowTitle('Drawing Example')
        self.resize(640, 420)
        self.pixmap = QPixmap('AbbeyRoad.jpg')
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        ratio = self.pixmap.width() / self.pixmap.height()
        painter.drawPixmap(10, 10, int(100 * ratio), 100, self.pixmap)
  
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Ekranlar belli bir çözünürlüktedir. Bu nedenle geometrik şekiller kırıklı gözükürler. İşte kırıklı görüntünün sınır pixellerinin 
    belli renklerde boyanması ile insan gözü bu kırıkları daha az hissetmektedir. Bu algoritmik yönteme "antialising" denilmektedir. 
    Qt'de çizim yaparken antialiasing özelliğini açmak için QPainter sınıfının setRenderHints metodu aşağıdaki gibi çağrılmalıdır:

    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.setRenderHints(QPainter.RenderHint.Antialiasing|QPainter.RenderHint.SmoothPixmapTransform)

    Aşağıdkai örnekte iki çemberi gözle karşılaştırınız.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        painter.drawEllipse(100, 100, 200, 200)
        painter.setRenderHints(QPainter.RenderHint.Antialiasing|QPainter.RenderHint.SmoothPixmapTransform)
        painter.drawEllipse(350, 100, 200, 200)
       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bizim bütün çizimleri paintEvent içerisinde yapmamız gerekir. Ancak bu paintEvent çağrısı işletim sistemi ya da pencere yönetici 
    alt sistem tarafından tetiklenmektedir. İşte bazen biz bir fare mesajında çizim yapmak isteyebiliriz. Bu durumda paintEvent 
    metodunun manuel çağrılması çizimlerin yapılmasını sağlamamaktadır. Çünkü bu metot çağrıldığında metot içeriisnde çizim yapılacak 
    "güncelleme alanı (update region)" boş kümedir. İşte bu tür durumlarda QWidget sınfının update metodu kullanılmaktadır. update 
    metodu paintEvent oluşmasına yol açar ancak bu mesajda artık güncelleme alanı boş küme değildir. Özetle şunlar söylenebilir:

    1) Çizimleri her zaman paintEvent metodu içerisinde yapmalısınız. 
    2) paintEvent dışında çizim yapılacaksa update metodu çağrılmalıdır. Bu metot paintEvent oluşmasına yol açacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir yazboz tahtası uygulaması Qt'de tipik olarak şöyle yapılır:  Fare hareket ettirildiğinde çizim o noktada yapılmaz. Çizim bilgisi 
    biriktirilir. Her fare hareketinde paintEvent oluşması sağlanır. Bunu sağlamak için QWidget sınıfının update metodu kullanılmalıdır. 
    (paintEvent metodunun manuel çağrılması update region boş küme olduğundan bir fayda sağlamaz.) Tabii kullanıcı elini fareden çektiğinde 
    o ayrı bir çizim birimi olduğu için oradaki noktaların başka bir listede saklanması da gerekmektedir. Aşağıdaki örnekte self.line 
    farenin basılıp çekiline kadarki noktaları tutmaktadır. Parmak fareden çekilince bu noktalar başka bir listede toplanmış ve paitntEvent 
    sırasında toplanan tüm noktalar yeniden çizgilerle birleştirilmiştir. 

    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = True
            self.line = [me.pos()]
            
    def mouseReleaseEvent(self, me):
        if self.dragFlag:
            self.dragFlag = False
            self.lines.append((self.line, self.mainWidget.currentWidth))
        
    def mouseMoveEvent(self, me):
        if self.dragFlag:
            self.line.append(me.pos())
            self.update()

    Burada farenin sol tuşuna basıldığında yeni bir liste yaratılmış bu liste çizgileri tutan listeye parmak fareden çekilince 
    yeerleştirilmiştir. Buradaki self.lines listesi iki elemanlı demetlerdenoluşmaktadır. Demetlerin birinci elemanı çizgileri tutan 
    listelerden ikinci elemanı da çizgilerin kalınlıklarındna oluşmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import os
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
import pickle

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()       
                
        self.resize(800, 600)
        self.mainWidget = CanvasWidget(self)
        self.setCentralWidget(self.mainWidget)
        
        self.path = 'Noname'
        
        menuBar = self.menuBar()
       
        filePopup = QMenu('&File', self)
        
        self.newAction = QAction(QIcon('MenuIcons/new.png'), '&New')
        self.newAction.setShortcut('Ctrl+N')
        self.newAction.triggered.connect(self.newActionTriggeredHandler)
        filePopup.addAction(self.newAction)
        
        self.openAction = QAction(QIcon('MenuIcons/open.png'), '&Open...')
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        filePopup.addAction(self.openAction)
        
        self.saveAction = QAction(QIcon('MenuIcons/save.png'), '&Save')
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        filePopup.addAction(self.saveAction)
        
        self.saveAsAction = QAction(QIcon('MenuIcons/saveas.png'), '&Save as...')
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        filePopup.addAction(self.saveAsAction)
                    
        filePopup.addSeparator()
        
        self.closeAction = QAction(QIcon('MenuIcons/close.png'), '&Close')
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.closeAction.setEnabled(False)
        filePopup.addAction(self.closeAction)
        
        menuBar.addMenu(filePopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.newAction)
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)  
        
        self.comboBoxWidth = QComboBox(self.toolBar)
        self.comboBoxWidth.currentIndexChanged.connect(self.comboBoxWidthCurrentIndexChangedHandler)
        
        self.comboBoxWidth.addItems([str(i) for i in range(1, 25)])
        self.toolBar.addWidget(self.comboBoxWidth)
           
    
    def comboBoxWidthCurrentIndexChangedHandler(self):
        self.currentWidth = int(self.comboBoxWidth.currentText())
            
    def newActionTriggeredHandler(self):
         pass
            
    def openActionTriggeredHandler(self):
        path, _ = QFileDialog.getOpenFileName(self, 'Open', '.', 'Scratpad files (*.scp);;All files (*.*)')
        if path:
            try:
                with open(path, 'rb') as f:
                    self.mainWidget.lines = pickle.load(f)
                    self.mainWidget.update()
                    self._setWindowTitle(path)
                    
            except Exception as e:
                QMessageBox.warning(self, 'Warning', str(e))
 
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.scp);;All files (*.*)')
        if path:
            self._saveFile(path)
        
    def closeActionTriggeredHandler(self):
        pass 
    
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyNotepad - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'wb') as f:
                pickle.dump(self.mainWidget.lines, f)       
                self._setWindowTitle(path)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
    
class CanvasWidget(QWidget):
    def __init__(self, mainWidget):
        super().__init__()
        self.mainWidget = mainWidget

        self.lines = []
        self.line = None
        
    def paintEvent(self, pe):
        painter = QPainter(self)
        pen = QPen(QColor('black'))
        
        painter.setPen(pen)
        for line, width in self.lines:
            pen.setWidth(width)
            painter.setPen(pen)
            painter.drawPolyline(line)
        if self.line:
            pen.setWidth(self.mainWidget.currentWidth)
            painter.setPen(pen)
            painter.drawPolyline(self.line)
              
    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            self.dragFlag = True
            self.line = [me.pos()]
            
    def mouseReleaseEvent(self, me):
        if self.dragFlag:
            self.dragFlag = False
            self.lines.append((self.line, self.mainWidget.currentWidth))
        
    def mouseMoveEvent(self, me):
        if self.dragFlag:
            self.line.append(me.pos())
            self.update()

       
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resmin fare ile taşınması tipik olarak şöyle yapılmaktadır: Resmin sol üst köşesi sınıfın bir örnek özniteliğinde tutulur. 
    Resmin üzerine tıklanıp tıklanmadığı belirlenir. Sonra farenin kaydırılma miktarı (deltax ve deltay) kadar resmin pozisyonu ötelenir. 
    Sonra yeni pozisyonda resim yeniden çizilir. Tabii resmi yeniden çizmek için update metodu çağrılmalıdır. update metodu paintEvent 
    oluştururken zeminin de silinmesine yol açmaktadır. Aşağıdaki örnekte satrançtaki vezir taşı fare sürüklenip bırakılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *


class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        self.picturePos = QPoint(10, 10)
        self.pixmap = QPixmap('AbbeyRoad.jpg').scaled(200, 200, Qt.AspectRatioMode.KeepAspectRatioByExpanding)
        
    def paintEvent(self, ps):
        painter = QPainter(self)
        painter.drawPixmap(self.picturePos, self.pixmap)  
        
    def mousePressEvent(self, me):
        if me.button() == Qt.MouseButton.LeftButton:
            self.prevPos = me.pos()
            self.dragFlag = True
    
    def mouseReleaseEvent(self, me):
        if self.dragFlag:
            self.dragFlag = False        
    
    def mouseMoveEvent(self, me):
        if self.dragFlag:
            self.picturePos += me.pos() - self.prevPos
            self.update()
            self.prevPos = me.pos()
                     
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz ekran yerine bir dosyaya çizim yapabilir miyiz? Evet yapabiliriz. Bunun için şu adımları uygulamak gerekir:

    1) Öncelikle çizim alanını bir QPixmap nesnesiyle oluşturmalıyız. QPixmap nesnesi bir resimden hareketle oluşturulmak zorunda 
    değildir. Boş bir QPixmap nesnesi de oluşturulabilir. Örneğin:

    pixmap = QPixmap(640, 480)

    pixmap ilk yaratıldığında içi sıfırlarla doludur. Dolayısıyla zemini siyah gibidir. Biz bu pixmap'in zeminini fill metoduyla 
    boyayabiliriz:

    pixmap.fill(Qt.white)

    2) Bu QPixmap nesnesini kullanarak bir QPainter nesnesi oluştururuz. Örneğin:

    painter = QPainter(pixmap)

    4) Artık bu QPainter nesnesi ile çizim yaptığımızda aslında bu pixmap'e çizim yapmış oluruz. 

    painter.drawEllipse(10, 10, 100, 100)

    5) Artık bu pixmap nesnesini istediğimiz formatta save edebiliriz:
         
    pixmap.save('test.png', 'png')

    6) Burada paintEvent dışında oluşturduğumuz QPainter nesnesinin yok edilmesi gerekmektedir. Bunun için QPainter sınıfının 
    end isimli metodu kullanılmalıdır. 

    painter.end()

    Aşağıda bir çizimim pixmap'e yapılıp, "png" dosyası olarak save edilmesine bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()       
        self.resize(800, 600)
        
        pixmap = QPixmap(300, 300)
        pixmap.fill(QColor('white'))
        painter = QPainter(pixmap)
        painter.drawLine(100, 100, 200, 200)
        painter.drawEllipse(100, 100, 200, 200)
        painter.end()
        pixmap.save('test.png', 'png')
                        
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
                                            41. Ders 15/05/2023 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                    Tkinter
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Ekrana boş bir ana pencere çıkartan minimal bir Tkinter programı aşağıdaki gibi oluşturulabilir. Burada tk.Tk sınıfı
   türünen nesne yaratıldığında ana pemcere yaratılmış olmaktadır. Tk sınıfının mainloop isimli metodu mesaj döngüsünü oluşturur.
   Mesaj döngüsünden ana pencere kapatılınca çıkılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencerenin boyutlandırılması ve konumlandırılması Tk sınıfının geometry isimli metoduyla yapılmaktadır. Bu metada 
    "widthxheight" biçimind ebir yazı girilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('600x480')
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer ana pencere için konum belirtilmezse konum pencere yönetici istem tarafından otomatik bir biçimde atanmaktadır. 
    Konum belirlemek için yazıda "+x+y" biçiminde belirleme yapılır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('600x480+400+100')
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    İstenirse yalnızca konum da belirtilebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('+400+100')
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencere başlığındaki yazıyı set etmek için Tk sınıfının title isimli metodu kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('640x480')
root.title('Sample Window')
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak ana pencere boyutlandırılabilir (resizable) biçimdedir. Ana pencereyi boyutlandırılabilir olmaktan çıkarmak için
    Tk sınıfının resizable metodu kullanılır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('640x480')
root.title('Sample Window')
root.resizable(width=False, height=False)
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencerenin maksimum ve minimum boyutları Tk sınıfının maxsize ve minsize metotlarıyla belirlenebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()
root.geometry('640x480')
root.title('Sample Window')
root.maxsize(800, 800)
root.minsize(200, 200)
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Boş bir ana penere bir işe yaramaz. Onun içerisine "widget" denilen GUI elemanlar yerleştirmek gerekir. GUI elemanlar
    tkinter modülünğn içerisinde çeşitli sınıflarla temsil edilmektedir. Örneğin tk.Button düğme GUI elemanını,
    tk.Label yazı GUI elemanını, tk.Entry editbox GUI elemanını temsil eder. Ancak bir GUI eleman yaratıldığında henüz
    görünür değildir. Onu görünür yapmak için "geometri yöneeticisi" denilen sınıflardan faydalanışmaktadır. Üç 
    geometri yöneticisi sınıf vardır: Place, Pack ve Grid. Tüm GUI eleman sınıfları tk.Widget isimli bir sınıftan 
    türetilmiştir. tk.Widget sınıfı da tk.Place, tk.Pack ve tk.Grid sınıfların çoklu türetilmiş durumdadır. 
    Böylece her GUI elemanı potansiyel olarak bu geometri manager sınıflarının metotlarını kullanabilir durumdadır. 
    Place geometri yöneticisi pixel cinsinden konumlandırma yapar. Place geometri yönetici sınıfının place isimli 
    metodu x ve y parametrelerini alarak konumlandırmayı pixel cinsinden yapmaktadır. Ancak alt pnecereler için orijin noktası
    her zaman üst pencerenin çalışma alanının (client area) sol üst köşesidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('640x480')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(x=200, y=100)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Ana pencereye istediğimiz kadar GUI eleman yerleştirebiliriz
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('200x150')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(x=10, y=10)

button_cancel = tk.Button(root, text='cancel')
button_cancel.place(x=50, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    place metodunda biz GUI elemanının genişlik ve yüksekliğini pixel cinsinden ayarlayabiliriz. Bunun için w,dth ve height 
    parametreleri kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(x=10, y=10, width=100, height=100)

button_cancel = tk.Button(root, text='Cancel')
button_cancel.place(x=120, y=10, width=100, height=100)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    place metodunun relx ve rely parametreleeri konumlandırmayı yüzdesel olarak yapmaktadır. Yani bu parametrelere 0 ile 1
    arasında bir değer gireriz. Pencereyi genişletip daraltsak bile bu oran korunacak biçimde GUI eleman yeniden otomatik
    konumlandırılır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(relx=0.2, rely=0.2, width=100, height=100)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde plcae metodunun relwidth ve relheight parametreleri de benişlik ve yüksekliği yüzdesel olarak almaktadır.
    Bu durumda pencere büyütülük küçültüldüğünde GUI eleman da oranı korumak için büyütülüp küçültülür.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(x=10, y=10, relwidth=0.8, relheight=0.8)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI elemanın çeşitli özellikleri vardır. Bu özelliklere Tkinter'da "seçenk (option)" denilmektedir. Seçenekler 
    "standart seçenekler" ve "widget spesifik seçenkler" olmak üzere ikiye ayrılmaktadır. Standart seçenekler her widget için
    geçerli seçeneklerdir. Widget specific seçenekler belli bir widget'a özgü seçenekleridr. 
    
    Widget seçenekleri üç biçimde değiştirilebilir. Birinci biçim nesne yaratılırken parametre yoluyla belirtmedir. Örneğin text seçeneğini
    biz böyle belirledik.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root, text='Ok')
button_ok.place(x=10, y=10, width=50, height=50)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Seçenek değiştirmenin ikinci yolu nesne yaratıldıktan sonra config isimli metodu kullanmaktır. Yine bu metottta
    seçenek = değer biçiminde parametre yoluyla seçenkler belirtilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root)
button_ok.config(text='Ok')
button_ok.place(x=10, y=10, width=50, height=50)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Üçüncü yöntem köşeli parantez yoluyla seçeneğe değer atamaktır. Burada köşeli parantezin içerisindeki seçenek ismi
    string türünden olmak zorundadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

button_ok = tk.Button(root)
button_ok['text'] = 'Ok'
button_ok.place(x=10, y=10, width=50, height=50)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Snır çizgileri olmayan yalnızca bir yazıyı göstermek için kullanılan GUI elemanlara GUI dünyasında "label" denilmektedir.
    Tkinter'da label tk.Label sınıfı ile temsil edilmiştir. Dolayısıyla bir ana pencerede bir yazı göstermek istediğimizde bu
    Label penceresini kullanırız. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Label'ın yazı rengini "foreground" ya da "fg" seçeneği ile değiştirebiliriz. Bu seçeneği doğrudan rengin ismi 
    yazı olarak girilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Renk belirtirken '#rrggbb' biçiminde RGB olarak da giriş yapılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='#ff0000')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Label'ın "background" ya da "bg" standart seçeneği zemin rengini belirlemek için kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    font isimli standart seçenek yazının fontunu belirlemekte kullanılabilir. Font bir yazı biçiminde girilebilir. Bu durumda
    font ailesi, büyüklük ve diğer font özellikleri yazıda belirtilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow', font='"Times New Roman" 20 bold italic')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Font üçlü demet biçiminde de girilebilir. Burada sıralama esnektir. Ancak tipik olarak önce font ailesi, sonra punto büyüklüğü,
    sonra da diğer özellikler belirtilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow', font=('Times New Roman', 30, 'bold italic'))
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Default font'la işlem yapılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow', font=('', 30, 'bold italic'))
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında Tkinter'da font tkinter.font modülündeki Font isimli sınıfla temsil edilmiştir. Dolayısıyla font seçeneğine
    bu sınıf türünden bir nesne de atanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

from tkinter.font import Font

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow')
label.config(font=Font(family='Times New Roman', size=30, weight='bold'))
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer pencere büyük ise yazı pencereye göre hizalanabilir. Bunun "anchor" isimli standart seçenek kullanılmaktadır. 
    anchor seçeneğinde n (north), s(south), w (west), e (east) harfleri kombine edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test', fg='red', bg='yellow')
label.place(x=10, y=10, width=100, height=100)
label['anchor'] = 'nw'

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yazı içerisinde \n ile aşağı satıra geçiş yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test, yes\nthis is a test', fg='red', bg='yellow')
label.place(x=10, y=10, width=100, height=100)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Label'da label'a özgü width ve height seçenekleri place metodundan farklı olarak karakter sayısı teemelinde genişlik yükseklik
   belirlemesi yapar. Anımsanacağı gibi place metodunda width ve height pixel cinsinden genişlik yükseklik belirtmekteydi.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

root = tk.Tk()

root.geometry('320x200')
root.title('Sample Window')

label = tk.Label(root, text='This is a test, yes\nthis is a test', fg='red', bg='yellow', width=25, font='18')
label.place(x=10, y=10)

root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Button GUI elemanında (widget) düğmeye fare ile tıklanıp parmak kaldırılınca command isimli widget spesifik seçenkte
    belirtilen fonksiyon çalıştırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

def main():
    root = tk.Tk()
    
    root.geometry('320x200')
    root.title('Sample Window')
    
    button_ok = tk.Button(root, text='Ok', command=button_ok_handler)
    button_ok.place(x=10, y=10, width=50, height=50)
    
    root.mainloop()

def button_ok_handler():
   print('Ok button clicked')

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce Label GUI elemanı için söz ettiğimiz standart seçeneklerin hepsi Button için de geçerlidir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

def main():
    root = tk.Tk()
    
    root.geometry('320x200')
    root.title('Sample Window')
    
    button_ok = tk.Button(root, text='Ok', fg='red', bg='light blue', anchor='nw',  command=button_ok_handler)
    button_ok.place(x=10, y=10, width=100, height=100)
    
    root.mainloop()

def button_ok_handler():
   print('Ok button clicked')

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğn yine düğme üzerindeki yazının biçimi font seçeneği ile belirtilebilir. width ve heiaght seçenekleri o andaki
    font karakteri cinsinden genişlik ve yükseklik belirtir.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

def main():
    root = tk.Tk()
    
    root.geometry('320x200')
    root.title('Sample Window')
    
    button_ok = tk.Button(root, text='Ok', fg='red', bg='light blue', font='16', width=10, height=4, command=button_ok_handler)
    button_ok.place(x=10, y=10)
    
    root.mainloop()

def button_ok_handler():
   print('Ok button clicked')

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Button GUI elemanının widget spesifik state isimli seçeneği "normal" ya da "disabled" olabilir. Normal durum fare 
    mesajlarının alınabildiği, disabled durum GUI elemanın fare mesajlarına kapatıldığı durumdur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

def main():
    global button_start, button_stop
    
    root = tk.Tk()
    
    root.geometry('320x200')
    root.title('Sample Window')
    
    button_start = tk.Button(root, text='Start', font='16', command=button_start_handler)
    button_start.place(x=10, y=10, width=100, height=100)
    
    button_stop = tk.Button(root, text='Stop', font='16', state='disabled',  command=button_stop_handler)
    button_stop.place(x=130, y=10, width=100, height=100)
    
    root.mainloop()

def button_start_handler():
    button_start['state'] = 'disabled'
    button_stop['state'] = 'normal'
    
def button_stop_handler():
    button_stop['state'] = 'disabled'
    button_start['state'] = 'normal'

main()
    
#------------------------------------------------------------------------------------------------------------------------------------
    GUI uygulamaları prosedürel tekniğe çok uygun değildir. Nesne yönelimli teknikle çok iyi örtüşmektedir. Dolayısıyla 
    Tkinter programcıları genellikle programlarını sınıfal bir biçimde oluştururlar. Bunun için iki yöntem çokça tercih 
    edilmektedir. Birinci yöntemde bir sınıf oluşturulup ana pencere nesnesi bu sının __init__ metoduna parametre olarak geçirilir.
    Tüm handler fonksiyonlar sınıfın metodu yapılır. Yaratılan GUI elemanlar da sınıfın örnek özniteliğinde saklanır. 
    Aşağıda bu tekniğin uygulanması görülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class GUI:
    def __init__(self, root):
         
        root.geometry('320x200')
        root.title('Sample Window')
        
        self.button_start = tk.Button(root, text='Start', font='16', command=self.button_start_handler)
        self.button_start.place(x=10, y=10, width=100, height=100)
        
        self.button_stop = tk.Button(root, text='Stop', font='16', state='disabled',  command=self.button_stop_handler)
        self.button_stop.place(x=130, y=10, width=100, height=100)
    
    def button_start_handler(self):
        self.button_start['state'] = 'disabled'
        self.button_stop['state'] = 'normal'
        
    def button_stop_handler(self):
        self.button_stop['state'] = 'disabled'
        self.button_start['state'] = 'normal'

root = tk.Tk()
gui = GUI(root)
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI programını nesne yönelimli hale getirmek için diğer bir yöntem doğrudan ana pencere sınıfını tk.Tk sınıfından 
    türetmektir. Böylece biz türemiş sınıfta self değişkeni yoluyla zaten tk.Tk sınıfının elemanlarını kullanabilriz.
    Biz kursumuzda daha çok bu yöntemi tercih edeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('320x200')
        self.title('Sample Window')
        
        self.button_start = tk.Button(self, text='Start', font='16', command=self.button_start_handler)
        self.button_start.place(x=10, y=10, width=100, height=100)
        
        self.button_stop = tk.Button(self, text='Stop', font='16', state='disabled',  command=self.button_stop_handler)
        self.button_stop.place(x=130, y=10, width=100, height=100)
    
    def button_start_handler(self):
        self.button_start['state'] = 'disabled'
        self.button_stop['state'] = 'normal'
        
    def button_stop_handler(self):
        self.button_stop['state'] = 'disabled'
        self.button_start['state'] = 'normal'

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Düğmelerin command seçeneklerinde doğrudan lambda ifadeleri kullanılabilir. Ancak Python'da lambda ifadeleri tek bir 
    ifade olmak zorundadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('320x200')
        self.title('Sample Window')
        
        self.button_ok = tk.Button(self, text='Ok', font='16', command=lambda: print('Ok'))
        self.button_ok.place(x=10, y=10, width=100, height=100)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir döngü içerisinde birden çok GUI elemanı yaratabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x310')
        self.title('Sample Window')
        self.button_lists = []
        
        y = 10
        for i in range(5):
            buttons = []
            x = 10
            for k in range(5): 
                button = tk.Button(self, text=f'{i * 5 + k}')
                button.place(x=x, y=y, width=50, height=50)
                buttons.append(button)
                x += 50 + 10
            self.button_lists.append(buttons)
            y += 50 + 10
                
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla düğmenin bir döngü içerisinde yaratıldığı durumda bu düğmelerin her birine farklı bir command fonksiyonu
    atamak zor olabilmektedir. Aşağıdaki örnekte command metotları bir listede toplanıp nesne yaratılırken listenin içerisinden
    alınarak verilmiştir. Dolayısıyla her düğmenin handler fonksiyonu birbirinden farklı olacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x70')
        self.title('Sample Window')
        
        self.button_handlers = [self.button_handler1, self.button_handler2, self.button_handler3, self.button_handler4, self.button_handler5]
        
        x = 10
        for k in range(5): 
            button = tk.Button(self, text=f'{k + 1}', command=self.button_handlers[k])
            button.place(x=x, y=10, width=50, height=50)
            x += 50 + 10

    def button_handler1(self):
        print('bir')
        
    def button_handler2(self):
        print('iki')
    
    def button_handler3(self):
        print('üç')
        
    def button_handler4(self):
        print('dört')
        
    def button_handler5(self):
        print('beş')

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    GUI programlarında kullanıcıdan bir giriş almak için Entry isimli GUI elemanı kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x70')
        self.title('Sample Window')
        
        self.label_name = tk.Label(self, text='Adı Soyadı')
        self.label_name.place(x=10, y=10)
        self.entry_name = tk.Entry(self)
        self.entry_name.place(x=10, y=30)
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Entry GUI elemanının da standart seçenkleri diğerlerinde olduğu gibidir. Yani biz editbox içerisindeki yazının
    şekil ve zemin rengini değiştirebiliriz. Fontunu istediğimiz gibi belirleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x90')
        self.title('Sample Window')
        
        self.label_name = tk.Label(self, text='Adı Soyadı', font='10')
        self.label_name.place(x=10, y=10)
        self.entry_name = tk.Entry(self, font='10', fg='red', bg='light blue')
        self.entry_name.place(x=10, y=40, width=200)
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Entry GUI eelemanındaki yazı Entry sınıfının get metoduyla string olarak alınabilmektedir
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x90')
        self.title('Sample Window')
        
        self.label_name = tk.Label(self, text='Adı Soyadı', font='10')
        self.label_name.place(x=10, y=10)
       
        self.entry_name = tk.Entry(self, font='10', fg='red', bg='light blue')
        self.entry_name.place(x=10, y=40, width=200)
        
        self.button_ok = tk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.place(x=220, y=40, width=50)
        
    def button_ok_handler(self):
        name = self.entry_name.get()
        print(name)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Entry ve Button nesneleri kullanılarak Veritabanına kayıt ekleyen GUI uygulaması
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk
import sqlite3

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('350x225')
        self.title('Database Insert GUI App')
        self.resizable(width=False, height=False)
        
        self.label_no = tk.Label(self, text='No', font=('', 14))
        self.label_no.place(x=10, y=10)
       
        self.entry_no = tk.Entry(self, font=('', 14))
        self.entry_no.place(x=10, y=40, width=250)
        
        self.label_name = tk.Label(self, text='Adı Soyadı', font=('', 14))
        self.label_name.place(x=10, y=75)
        
        self.entry_name = tk.Entry(self, font=('', 14))
        self.entry_name.place(x=10, y=110, width=250)
        
        self.button_record = tk.Button(self, text='Kaydet', font=('', 14), command=self.button_record_handler)
        self.button_record.place(x=125, y=160, width=80)
        
        self.button_clear = tk.Button(self, text='Temizle', font=('', 14), command=self.button_clear_handler)
        self.button_clear.place(x=225, y=160, width=80)    
        
        self.conn = sqlite3.connect('student.sqlite')

    def button_record_handler(self):
        student_no = self.entry_no.get().strip()
        student_name = self.entry_name.get().strip()
        cursor = self.conn.cursor()
        cursor.execute('INSERT INTO student(student_no, student_name) VALUES(?, ?)', (student_no, student_name))
        self.conn.commit() 
        self.button_clear_handler()
               
    def button_clear_handler(self):
        self.entry_no.delete(0, tk.END)
        self.entry_name.delete(0, tk.END)
        self.entry_no.focus()
        
root = Root()   
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla düğme için command seçeneğinde aynı fonksiyon belirtilebilir. Ancak bu durumda söz konusu fonksiyonun
    hangi düğmeden dolayı çalıştırılmış olduğu fonksiyon içersinde anlaşılamaz. Bu sorunu gidermenin en basit yolu 
    command seçeneği için lambda fonksiyonu kullanıp orada ortak handler fonksiyonunu farklı parametrelerle çağırmaktır.
    Anımsanacağı gibi her lambda ifadesi aslında farklı bir fonksiyon belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('400x300')
        
        self.button1 = tk.Button(self, text='Button1', command=lambda: self.button_handler(self.button1))
        self.button1.place(x=10, y=10, width=100, height=100)
        
        self.button2 = tk.Button(self, text='Button2', command=lambda: self.button_handler(self.button2))
        self.button2.place(x=120, y=10, width=100, height=100)
        
        self.button3 = tk.Button(self, text='Button3', command=lambda: self.button_handler(self.button3))
        self.button3.place(x=230, y=10, width=100, height=100)

    def foo(self, button):
        pass
        
    def button_handler(self, button):
        print(button['text'])
           
root = Root()   
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Farklı düğmeler için aynı command fonksiyonun kullanılması durumunda bu fonksiyonun hangi düğmeden dolayı çağrıldığının 
    anlaşılması döngü içerisinde aynı lambda ifadesinin kullanıldığı durumlarda problemlidir. Bu tür durumlarda Pythonic bir
    hileye başvurmak gerekmektedir. lambda x = y: button_handler(x) gibi bir işlemde lambda fonksiyonun parametresi
    aslında artık o andaki y'ye bağlanmış durumdadır. Dolayısıyla farklı y'ler için aslında button_handler farklı y değerlerini
    parametre olarak alacaktır.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.geometry('310x310')
        self.title('Sample Window')
        self.button_lists = []
        
        y = 10
        for i in range(5):
            buttons = []
            x = 10
            for k in range(5): 
                button = tk.Button(self, text=f'{i * 5 + k}')
                button.place(x=x, y=y, width=50, height=50)
                button['command'] = lambda b = button: self.button_handler(b)
                buttons.append(button)
                
                x += 50 + 10
            self.button_lists.append(buttons)
            y += 50 + 10
            
    def button_handler(self, button):
        print(button['text'])
                
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Veri bağlama (data binding) pek çok GUI framework'ta GUI eleman içerisindeki bilgileri alıp değiştirmeyi kolaylaştırmak
    için bulunan bir mekanizmadır. Bu mekanizma tkinter'da tk.StringVar, tk.IntVar, tk.DoubleVar, tk.BooleanVar 
    ieimli özel nesnelerle yapılmaktadır. Bu sınıflar türünden nesneler yaratıldıktan sonra bunlar textvariable ya da benzeri
    özel seçeneklere girilirler. Artık bu nesnelerin get metotları bize GUI eleman içerisindeki bilgiyi verir, set metotları
    o GUI elemanın değerin değiştirilmesine yol açar.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.entry_text = tk.StringVar()
        
        self.entry = tk.Entry(self, font=('', 14), textvariable=self.entry_text)
        self.entry.place(x=10, y=10, width=200)
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=10, y=50, width=100, height=100)
                                                 
    def button_ok_handler(self):
       self.entry_text.set('this is a test')
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tk.Checkbutton "checkbox" denilen GUI elemanını oluşturmaktadır. Bu GUI eleman fare ile tıklanarak checked ya da unchecked 
    duruma geçirilebilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.check_button = tk.Checkbutton(self, text='Test')
        self.check_button.place(x=10, y=10)
        self.check_button.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=10, y=50, width=100, height=100)
                                                 
    def button_ok_handler(self):
       self.check_button.deselect()
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    CheckButton nesnesinin durumunu almak için tipik olarak veri bağlama yapılır. Veri bağlama işlemi için sınıfın "variable"
    isimli seçeneği kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.check_button_stat = tk.BooleanVar()
        
        self.check_button = tk.Checkbutton(self, text='Test', font=('', 14), variable=self.check_button_stat)
        self.check_button.place(x=10, y=10)
        self.check_button.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=10, y=50, width=100, height=100)
                                                 
    def button_ok_handler(self):
       stat = self.check_button_stat.get()
       print(stat)
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Checkbutton nesneleri, için de command belirtilebilir. Bu durum özellikle check button nesnesi checked ya da unchecked
    yapıldığında diğer GUI elemanlarının durumlarını ayarlamak için kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.check_button_stat = tk.BooleanVar()
        self.label_text = tk.StringVar()
        
        self.check_button = tk.Checkbutton(self, text='Test', font=('', 14), variable=self.check_button_stat, command=self.check_button_handler)
        self.check_button.place(x=10, y=10)
        self.check_button.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=10, y=50, width=100, height=100)
        
        self.label = tk.Label(self, font=('', 14), textvariable=self.label_text)
        self.label.place(x=120, y=75)
                                                 
    def button_ok_handler(self):
       stat = self.check_button_stat.get()
       print(stat)
       
    def check_button_handler(self):
       self.label_text.set('Checked' if self.check_button_stat.get() else 'Unchecked')
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Radyo düğmeleri bir grup olarak kullanılmaktadır. Bunlar yaratılırken value parametresi birbirinden farklı olarak
    int türden ya da str türünden girilmelidir. İşin başında bir tane düğmenin select ile seçilmesi gerekir.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.radio_buttonA = tk.Radiobutton(self, text='A', font=('', 14), value=1)
        self.radio_buttonA.place(x=10, y=10)
        
        self.radio_buttonB = tk.Radiobutton(self, text='B', font=('', 14), value=2)
        self.radio_buttonB.place(x=10, y=40)
        
        self.radio_buttonC = tk.Radiobutton(self, text='C', font=('', 14), value=3)
        self.radio_buttonC.place(x=10, y=70)
        
        self.radio_buttonD = tk.Radiobutton(self, text='D', font=('', 14), value=4)
        self.radio_buttonD.place(x=10, y=100)
        
        self.radio_buttonE = tk.Radiobutton(self, text='E', font=('', 14), value=5)
        self.radio_buttonE.place(x=10, y=130)
        
        self.radio_buttonA.select()
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Hangi radyo düğmesinin seçikdiği veri bağlaması ile anlaşılmaktadır. Bağlama işleminde IntVar ya da StringVAr kullanılır.
    Bu nesneler Radiobutton sınıfının "variable" seçeneğine girilmelidir. Ne zaman bir radyo düğmesi seçilse value seçeneğindeki değer
    bağlanan nesneye yerleştirilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.radio_button_var = tk.IntVar()
        
        self.radio_buttonA = tk.Radiobutton(self, text='A', font=('', 14), value=1, variable=self.radio_button_var)
        self.radio_buttonA.place(x=10, y=10)
        
        self.radio_buttonB = tk.Radiobutton(self, text='B', font=('', 14), value=2, variable=self.radio_button_var)
        self.radio_buttonB.place(x=10, y=40)
        
        self.radio_buttonC = tk.Radiobutton(self, text='C', font=('', 14), value=3, variable=self.radio_button_var)
        self.radio_buttonC.place(x=10, y=70)
        
        self.radio_buttonD = tk.Radiobutton(self, text='D', font=('', 14), value=4, variable=self.radio_button_var)
        self.radio_buttonD.place(x=10, y=100)
        
        self.radio_buttonE = tk.Radiobutton(self, text='E', font=('', 14), value=5, variable=self.radio_button_var)
        self.radio_buttonE.place(x=10, y=130)
        
        self.radio_buttonA.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=120, y=10, width=100, height=100)
        
    def button_ok_handler(self):
        value = self.radio_button_var.get()
        print(value)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    value seçeneklerine yazı girebiliriz. Bu durumda bağlama StringVAr nesnesiyle yapılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.radio_button_var = tk.StringVar()
        
        self.radio_buttonA = tk.Radiobutton(self, text='A', font=('', 14), value='A', variable=self.radio_button_var)
        self.radio_buttonA.place(x=10, y=10)
        
        self.radio_buttonB = tk.Radiobutton(self, text='B', font=('', 14), value='B', variable=self.radio_button_var)
        self.radio_buttonB.place(x=10, y=40)
        
        self.radio_buttonC = tk.Radiobutton(self, text='C', font=('', 14), value='C', variable=self.radio_button_var)
        self.radio_buttonC.place(x=10, y=70)
        
        self.radio_buttonD = tk.Radiobutton(self, text='D', font=('', 14), value='D', variable=self.radio_button_var)
        self.radio_buttonD.place(x=10, y=100)
        
        self.radio_buttonE = tk.Radiobutton(self, text='E', font=('', 14), value='E', variable=self.radio_button_var)
        self.radio_buttonE.place(x=10, y=130)
        
        self.radio_buttonA.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=120, y=10, width=100, height=100)
        
    def button_ok_handler(self):
        value = self.radio_button_var.get()
        print(value)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aynı pencere içerisinde farklı radyo düğme gruplarını oluşturabilmek için grupları farklı nesnelere bağlamak gerekmektedir. 
    Bu yöntem diğer framework'tekilerden farklıdır. Örneğin PyQt'de bir pencerenin bütün kardeş radyo düğmeleri aynı
    grubu oluşturmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('300x200')
        
        self.radio_button_var1 = tk.StringVar()
        self.radio_button_var2 = tk.StringVar()
        
        
        self.radio_buttonA = tk.Radiobutton(self, text='A', font=('', 14), value='A', variable=self.radio_button_var1)
        self.radio_buttonA.place(x=10, y=10)
        
        self.radio_buttonB = tk.Radiobutton(self, text='B', font=('', 14), value='B', variable=self.radio_button_var1)
        self.radio_buttonB.place(x=10, y=40)
        
        self.radio_buttonC = tk.Radiobutton(self, text='C', font=('', 14), value='C', variable=self.radio_button_var1)
        self.radio_buttonC.place(x=10, y=70)
        
        self.radio_buttonD = tk.Radiobutton(self, text='D', font=('', 14), value='D', variable=self.radio_button_var1)
        self.radio_buttonD.place(x=10, y=100)
        
        self.radio_buttonE = tk.Radiobutton(self, text='E', font=('', 14), value='E', variable=self.radio_button_var1)
        self.radio_buttonE.place(x=10, y=130)
        
        self.radio_buttonA.select()
        
        self.radio_buttonX = tk.Radiobutton(self, text='X', font=('', 14), value='X', variable=self.radio_button_var2)
        self.radio_buttonX.place(x=120, y=120)
        
        self.radio_buttonY = tk.Radiobutton(self, text='Y', font=('', 14), value='Y', variable=self.radio_button_var2)
        self.radio_buttonY.place(x=160, y=120)
        
        self.radio_buttonZ = tk.Radiobutton(self, text='Z', font=('', 14), value='Z', variable=self.radio_button_var2)
        self.radio_buttonZ.place(x=200, y=120)
        
        self.radio_buttonX.select()
        
        self.button_ok = tk.Button(self, text='Ok', font=('', 14), command=self.button_ok_handler)
        self.button_ok.place(x=120, y=10, width=100, height=100)
        
    def button_ok_handler(self):
        value = self.radio_button_var1.get()
        print(f'First Group: {value}')
        value = self.radio_button_var2.get()
        print(f'SecondGroup: {value}')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da bir resim göstermek için genellikle Label nesneleri kullanılır. Label sınıfının "image" isimli seçeneğine
    tk.PhotoImage nesnesi atanırsa Label bu fotoğrafı göstermektedir. Aslında image seçeneği Button gibi sınıflarda da 
    bulunmaktadır. Burada kullanım konusunda bir noktaya dikkat etmek gerekir. Widget sınıfları PhotoImage nesnesinin referans
    sayacını artırmamaktadır. Bu nedenle PhotoImage nesnesinin kalıcılığının programcı tarafından sağlanması gerekmektedir. 
    Bunun bir yolu Label nesnesi için bir örnek özniteliği yaratıp PhotoImage nesnesini bunun içerisine atamaktır. Buradaki 
    örnek özniteliğinin isminin bir önemi yoktur. 

    Ancak maalesef tk.PhotoImage yalnızca "gif", "png", "pgm" ve "ppm" formatlarını desteklemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
      
        pi = tk.PhotoImage(file='AbbeyRoad.png')
        self.label_picture = tk.Label(self, image=pi)
        self.label_picture.image = pi
        self.label_picture.place(x=10, y=10, width=200, height=200)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer JPG ve pek çok formatı göstermek istiyorsak bu durumda PIL (pillow) isimli üçüncü parti bir kütüphaneden 
    faydalanabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------
   
import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage

IMAGE_PATH = 'KızKulesi.jpg'

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title(IMAGE_PATH)

        image = Image.open(IMAGE_PATH)
        pi = PhotoImage(image)
                
        self.geometry(f'{image.width}x{image.height}')
        self.resizable(width=False, height=False)
                 
        self.label_picture = tk.Label(self, image=pi)
        self.label_picture.image = pi
        self.label_picture.place(x=0, y=0, width=image.width, height=image.height)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   GUI uygulamalarında kullanıcıya mesajlar print fonksiyonuyla konsol ekranına yazdırma yoluyla verilmez. Bunun için
   "messagebox" denilen modal diyalg pencereleri kullanılmaktadır. tk.messagebox modülü içerisinde bir grup fonksiyon
   bazı tuş takımlarıyla messagebox pencereleri çıkarmaktadır. Örneğin showinfo bir mesajı göstermek için kullanılır. 
   Yalnızca Ok tuşu pencerede bulunur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=10, y=10, width=100, height=100)
        
    def button_ok_handler(self):
        tk.messagebox.showinfo('Title', 'Message Text')
        tk.messagebox.showerror('Title', 'Message Text')
        tk.messagebox.showwarning('Title', 'Message Text')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    askxxxx biçimindeki messagebox fonksiyonları bize ilgili tuş takımını çıkartıp bizden bir seçim yapmamızı ister.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=10, y=10, width=100, height=100)
        
    def button_ok_handler(self):
        result = tk.messagebox.askyesno('Title', 'Message Text')
        print(result)
        
        result = tk.messagebox.askokcancel('Title', 'Message Text')
        print(result)
        
        result = tk.messagebox.askyesnocancel('Title', 'Message Text')
        print(result)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox GUI elemanı bir grup bilgiyi listelemek için kullanılır. Listelenmiş bilgilerden bir ya da birden fazlasını 
    kullanıcı seçebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self)
        self.listbox.place(x=10, y=10, width=100, height=200)
        
        for i in range(100):
            self.listbox.insert(tk.END, i)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox sınıfının get metodu iki indeks arasındaki elemanları almak için kullanılmaktadır. Eğer tek parametre girilirse
    o indeksteki eleman alınır. tk.ACTIVE ya da 'active' özel değeri o anda aktif elemanın indeksi anlamına gelmektedir. 
    Hiçbir eleman seçili değilse tk.ACTIVE değeri default 0'dır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self)
        self.listbox.place(x=10, y=10, width=100, height=200)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 'Eskişehir', 
                'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=150, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
      items = self.listbox.get(tk.ACTIVE)
      print(items)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox sınıfının curselection isimli netodu bize o andaki aktif elemanların indekslerini bir demet olarak verir. Eğer hiç bir 
    eleman seçilmemişse (yani aktif değilse) bu durumda metot bize boş bir demet verecektir. Seçilen elemanı bu metotla almak daha 
    uygun olmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self)
        self.listbox.place(x=10, y=10, width=100, height=200)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 'Eskişehir', 
                'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=150, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
        selections = self.listbox.curselection()
        print(selections)
        if len(selections) == 0:
            print('Hiçbir eleman seçili değil!')
        else:
            selected_item = self.listbox.get(selections[0])
            print(selected_item)
      
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekteki bilgileri messagebox ile de yazdırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self)
        self.listbox.place(x=10, y=10, width=100, height=200)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 
                'Eskişehir', 'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=150, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
        selections = self.listbox.curselection()
        print(selections)
        if len(selections) == 0:
            tk.messagebox.showerror('Bilgi', 'Hiçbir eleman seçilmedi')
        else:
            selected_item = self.listbox.get(selections[0])
            tk.messagebox.showerror('Bilgi', f'Seçilen eleman: {selected_item}')
      
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Standart seçenekler Listbox için de geçerlidir. Yani biz Listbox penceresinin örneğin zemin rengini, yazı rengini, fontunu vs. 
    değiştirebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self, fg='red', bg='light blue', font=('', 14))
        self.listbox.place(x=10, y=10, width=150, height=300)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 'Eskişehir', 
                'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=180, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
        selections = self.listbox.curselection()
        print(selections)
        if len(selections) == 0:
            tk.messagebox.showerror('Bilgi', 'Hiçbir eleman seçilmedi')
        else:
            selected_item = self.listbox.get(selections[0])
            tk.messagebox.showerror('Bilgi', f'Seçilen eleman: {selected_item}')
      
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox sonıfının selectmod isimli seçeneği tk.MULTIPLE ya da 'multiple' olarak girilirse birden fazla eeleman seçilebilmektedir.
    tk.EXTENDED bir noktadan sıralı seçim yapmaya olanak sağlar. Yani tk.MULTIPLE seçeneğini kapsamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self, fg='red', bg='light blue', font=('', 14), selectmode=tk.MULTIPLE)
        self.listbox.place(x=10, y=10, width=150, height=300)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 
                'Eskişehir', 'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=180, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
        selections = self.listbox.curselection()
        print(selections)
        if len(selections) == 0:
            tk.messagebox.showerror('Bilgi', 'Hiçbir eleman seçilmedi')
        else:
            text = ''
            for selection in selections:
                item = self.listbox.get(selection)
                text += item + ' '
            tk.messagebox.showinfo('Bilgi', f'Seçilen elemanlar:\n{text}')
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox üzerinde çift tıklandığında genellijle tıklanan eleman hakkında birtakım işlemler yapılmaktadır. Tkinter'da listbox elemanı 
    üzerinde tıklama işlemi için "event binding" uygulamak gerekmektedir. Bu konu izleyen örneklerde ele alınmaktadır. Farenin sol 
    tuşu için çift tıklama '<Double-Button-1>' yazısıyla temsil edilmektedir. Aşağıdaki örnekte Listbox elemanına çift tıklandığında 
    tıklanan eleman elde edilip mesagebox üzerinde yazdırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self, fg='red', bg='light blue', font=('', 14), selectmode=tk.EXTENDED)
        self.listbox.place(x=10, y=10, width=150, height=300)
        self.listbox.bind('<Double-Button-1>', self.listbox_doubleclick_handler)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 
                'Eskişehir', 'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=180, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):    
        selections = self.listbox.curselection()
        print(selections)
        if len(selections) == 0:
            tk.messagebox.showerror('Bilgi', 'Hiçbir eleman seçilmedi')
        else:
            text = ''
            for selection in selections:
                item = self.listbox.get(selection)
                text += item + ' '
            tk.messagebox.showinfo('Bilgi', f'Seçilen elemanlar:\n{text}')
    
    def listbox_doubleclick_handler(self, event):
       selection = self.listbox.curselection()
       item = self.listbox.get(selection[0])
       tk.messagebox.showinfo('Bilgi', f'{item} şehri seçildi')
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Listbox'taki seçilen eleman değiştiğinde bir fonksiyonumuzun çağrılmasını sağlayabiliriz. Bu işlem de "event binding" mekanizmasıyla 
    yapılmaktadır. Buradaki event yazısı "<<ListboxSelect>>" biçiminde olmalıdır. Aşağıdaki örnekte listbox üzerindeki seçilen eleman 
    değiştiğinde o eleman yandaki label üzerine yazdırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox = tk.Listbox(self, fg='red', bg='light blue', font=('', 14), selectmode=tk.EXTENDED)
        self.listbox.place(x=10, y=10, width=150, height=300)
         
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 
                'Eskişehir', 'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        for city in cities:
            self.listbox.insert(tk.END, city)
            
        self.listbox.bind('<<ListboxSelect>>', self.listbox_select_handler)
            
        self.label = tk.Label(self, font=('', 18))
        self.label.place(x=170,y=10)
   
   
    def listbox_select_handler(self, event):
       selection = self.listbox.curselection()
       item = self.listbox.get(selection[0])
       self.label['text'] = item
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Listbox sınıfının "listvariable" isimli veri bağlama seçeneği StringVAr nesnesi ile ilişkilendirilmelidir. Bu nesne get edildiğinde 
   listbox'taki tüm elemanlar string'lerden oluşan bir demet biçiminde verilmektedir. Bu nesne yazılardan oluşan dolaşılabilir bir 
   nesne argümanı verilerek set edildiğinde ise listbox elemanları set edilmektedir. Bu seçenek özellikle bir grup elemanın tek 
   hamlede listbox'a yerleştirilmesi için kullanılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.listbox_var = tk.StringVar()
        
        self.listbox = tk.Listbox(self, font=('', 14), listvariable=self.listbox_var)
        self.listbox.place(x=10, y=10, width=150, height=300)
        
        cities = ['Adana', 'Adıyaman', 'Afyon', 'Ağrı', 'Amasya', 'Bilecik', 'Bingöl', 'Edirne', 
                'Eskişehir', 'İstanbul', 'İzmir', 'Sakarya', 'Siirt', 'Sinop', 'Elazığ']
        
        self.button_ok = tk.Button(self, text='ok', command=self.button_ok_handler)
        self.button_ok.place(x=180, y=10, width=100, height=100)
        
        for city in cities:
            self.listbox.insert(tk.END, city)
        
    def button_ok_handler(self):  
        self.listbox_var.set(['Ali', 'Veli', 'Selami'])
        print(self.listbox_var.get())
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da çok satırlı editbox pencerelerine "Text" denilmektedir. Text aslında Entry penceresinin çok satırlı biçimidir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.text = tk.Text(self, font=('', 12))
        self.text.place(x=10, y=10, width=300, height=200)
        
        self.button = tk.Button(self, text='Ok')
        self.button.place(x=330, y=10, width=100, height=100)
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Text GUI elemanındaki yazıyı almak için get metodu kullanılmaktadır. get metoduna başlangı ve bitiş indeksi verilir. Başlangıç 
    indeksi dahil, bitiş indeksi dahil değildir. İndeksler yazısal olarak verilir. İndeks vermenin değişik biçimleri vardır. En çok 
    kullanılan biçim "satır.sütun" biçimindedir. Satırlar 1'den, sütunlar 0'dan başlamaktadır. 

    - Tüm yazıyo elde etmek için '1.0' ile tk.END ya da 'end' indeksleri kullanılmaktadır.
    - 'satır.end' ilgili satırın sonu anlamına gelir. Ancak satırın sonundaki '\n' dahil değildir. 
    - tk.INSERT ya da 'insert' o andaki imlecin konumu anlamına gelir.
    - tk.SEL_FIRST ya da 'sel.first' seçimin başındaki indeksi tk.SEL_LAST ya da 'sel.last' seçimin sonundaki indeksi verir. Yani tüm 
    seçim 'sel.first', 'sel.last' ile alınabilmektedir. 
    - ' satır.sütun + n chars' n sonraki karakter 'satır.sütun - n chars' n önceki karakter anlamına gelir.
    - 'satır.sütun + lines' n sonraki satır, 'satır.sütun - n lines' n önceki satır anlamına gelmektedir. 

#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12))
        self.text.place(x=10, y=10, width=300, height=200)
        
        self.button = tk.Button(self, text='Ok', command=self.button_handler)
        self.button.place(x=330, y=10, width=100, height=100)
        
    def button_handler(self):
        s = self.text.get('1.0', '3.0')
        print(s)
   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Text sınııfnın delete metodu aynı indeksleme biçimiyle edit alanındakş karakterlerden silme yapar.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12))
        self.text.place(x=10, y=10, width=300, height=200)
        
        self.button = tk.Button(self, text='Ok', command=self.button_handler)
        self.button.place(x=330, y=10, width=100, height=100)
        
    def button_handler(self):
       self.text.delete('1.0', '2.0')
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Text sınıfının insert metodu belli bir yazıyı yukarıda belirtildiği biçimde bir indeksten itibaren insert etmektedir. Aşağıdaki 
    örnekte yazı 2'inci satırın 10'uncu karakterinden itibaren insert edilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12))
        self.text.place(x=10, y=10, width=300, height=200)
        
        self.button = tk.Button(self, text='Ok', command=self.button_handler)
        self.button.place(x=330, y=10, width=100, height=100)
        
    def button_handler(self):
       self.text.insert('2.10', 'Bugün hava çok güzel')
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Text sınıfının "wrap" isimli seçeneği tk.NONE ya da 'none' yapılırsa "word wrapping" kaldırılır. Bu seçenek tk.CHAR ya da 'char' 
    olarak girilirse karakter temelli sarma, tk.WORD ya da "word" olarak girilirse sözcük temelli sarma yapılmaktadır. Default durum 
    tk.CHAR biçimindedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12), wrap=tk.CHAR)
        self.text.place(x=0, y=0, width=480, height=350)
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Text GUI elemanının içerisindeki yazının çeşitli bölümleri farklı biçimde formatlanabilir. Bunu yapabilmek için önce bir "tag"
    oluşturmak gerekir. Tag oluşturma işlemi Text sınıfının tag_add metoduyla yapılmaktadır. Daha sonra Text sınıfının tag_config
    metoduyla ilgili bölge çeşitli seçenekler kullanılarak formatlanabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, font=('Consolas', 12), wrap=tk.CHAR)
        self.text.place(x=0, y=0, width=480, height=350)
        
        with open('sample.py') as f:
            s = f.read()
            self.text.insert('1.0', s)
            
        self.text.tag_add('tag1', '1.0', '1.10')
        self.text.tag_config('tag1', background='light blue', foreground='red')
        
        self.text.tag_add('tag2', '3.0', '3.end')
        self.text.tag_config('tag2', font=('Consolas', 16))
        
        self.text.tag_add('tag3', '4.0', '4.end')
        self.text.tag_config('tag3', font=('Consolas', 16, 'italic'))
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tkinter.filedialog.askopenfilename isimli fonksiyon dosya seçme diyalog penceresini çıkartır. Fonksiyon bize seçilen dosyanın yol 
    ifadesini verir. Eğer bir seçim yapılmazsa boş string geri döndürmektedir. Filtreleme yazısı için filetypes isimli parametresi 
    kullanlmaktadır. Bu parametreye iki elemanlı demetlerden oluşan girilmelidir. defaultextension isimli parametesi eğer uzantı 
    girilmezse otomatik olarak eklenecek uzantıyı nbelirtmektedir. Default durumda diyalog penceresi çalışma dizinini gösterecek 
    biçimde açılmaktadır. Ancak initialdir isimli parametresi ile açık sırasında gösterilecek dizin belirlenebilir. title isimli 
    parametresi açılacak diyalog penceresinin başlık yazısını  belirlemekte kullanılır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12), wrap=tk.CHAR)
        self.text.place(x=10, y=10, width=480, height=350)

        self.button = tk.Button(self, text='Open', command=self.button_handler)
        self.button.place(x=500, y=10, width=100, height=100)
        
    def button_handler(self):
        path = tk.filedialog.askopenfilename(filetypes=[('Text files', '*.txt'), ('Python files', '*.py')], defaultextension='.txt', initialdir=r'C:\Users\aslan\Dropbox\Shared\Kurslar\Python-App', title='Lütfen bir dosya seçiniz')
        if path != '':
            with open(path) as f:
                s = f.read()
                self.text.delete('1.0', 'end')
                self.text.insert('1.0', s)
        else:
            print('hiçbir dosya seçilmedi!')
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tkinter.filedialog.asksaveasfilename fonksiyonu save etme amaçlı bir dosya isminin seçilmesi için kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12), wrap=tk.CHAR)
        self.text.place(x=10, y=10, width=480, height=350)

        self.button = tk.Button(self, text='Save', command=self.button_handler)
        self.button.place(x=500, y=10, width=100, height=100)
        
    def button_handler(self):
        path = tk.filedialog.asksaveasfilename(filetypes=[('Text files', '*.txt'), ('Python files', '*.py')], defaultextension='.txt', title='Lütfen bir dosya ismi seçiniz')
        if path != '':
            with open(path, 'w') as f:
                s = self.text.get('1.0', 'end')
                s = f.write(s)
        else:
            print('hiçbir dosya seçilmedi!')
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Birden fazla dosya seçmek için tkinter.filedialog.askopenfilenames fonksiyonu kullanılır. Burada seçilen dosyaların
   yol ifadeleri string'ler oluşan bir demet biçiminde verilmektedir. Seçim yapılmazsa fonksiyon bıoş bir string'e geri 
   dönmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('320x200')

        self.button = tk.Button(self, text='Open', command=self.button_handler)
        self.button.place(x=10, y=10, width=100, height=100)
        
    def button_handler(self):
        paths = tk.filedialog.askopenfilenames()
        print(paths)
        print(type(paths))
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    askopenfilename fonksiyonunun yanı sıra askopenfile, asksaveasfilename fonksiyonunun yanı sıra da asksaveasfile 
    fonksiyonu vardır. Bu fonksiyonlar bize yol ifadesi vermez bizzat dosyasyı açarak verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12), wrap=tk.CHAR)
        self.text.place(x=10, y=10, width=480, height=350)

        self.button = tk.Button(self, text='Open', command=self.button_handler)
        self.button.place(x=500, y=10, width=100, height=100)
        
    def button_handler(self):
        f = tk.filedialog.askopenfile(filetypes=[('Text files', '*.txt'), ('Python files', '*.py')], defaultextension='.txt', initialdir=r'C:\Users\aslan\Dropbox\Shared\Kurslar\Python-App', title='Lütfen bir dosya seçiniz')
        if f is not None:
            s = f.read()
            self.text.delete('1.0', 'end')
            self.text.insert('1.0', s)
            f.close()
        else:
            print('hiçbir dosya seçilmedi!')
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Renk seçme seçme diyalog penceresi tkinter.colorchooser.askcolor fonksiyonuyla oluşturulmaktadır. Bu fonksiyon seçim 
    yapıldığında bir demet ile geri döner. Demetin birinci elemanı 3 elemanlı RGB renklerinden, ikinci elemanı #'li renk kodundan
    oluşmaktadır. Diyalog penceresinde seçim yapılmazsa fonksiyon None değeri ile geri dönmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.colorchooser

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        self.resizable(width=False, height=False)
        
        self.text = tk.Text(self, fg='red', bg='light blue', font=('', 12))
        self.text.place(x=10, y=10, width=480, height=350)

        self.button_background = tk.Button(self, text='Background', command=self.button_background_handler)
        self.button_background.place(x=500, y=10, width=100, height=100)
        
        self.button_foreground = tk.Button(self, text='Foreground', command=self.button_foreground_handler)
        self.button_foreground.place(x=500, y=120, width=100, height=100)
        
    def button_background_handler(self):
        color = tk.colorchooser.askcolor(color='light blue')
        self.text['bg'] = color[1]
        
    def button_foreground_handler(self):
        color = tk.colorchooser.askcolor(color='red')
        self.text['fg'] = color[1]
     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Belli bir olay (mesaj) gerçekleştiğinde istediğimiz bir fonksiyonun çağrılmasını sağlayabiliriz. Bu konuya "event binding"
    denilmektedir. Olay bağlama işlemi ilgili widget sınıfının bind isimli metoduyla yapılır. Bu bind metodunun iki parametresi
    vardır. Birinci parametre olayın ne olduğunu belirtir. İkinci parametre çağrılacak fonksiyonu belirtmektedir. Çağrılacak fonksiyonun
    her zaman bir event parametresi vardır. 

    bind fonksiyonun birinci parametresinde olay belirtmenin belli bir sentaksı vardır. Açısal parantezler içerisinde "modifier"
    denilen özel sözcükler bazı olaylar anlatmaktadır. Örneğin "<Button-1>" farenin sol tuşuna basılma olayını, "<Double-Button-1>"
    farenin sol tuşuna çift tıklama olayını belirtir. "<Motion>" olayı diğer framework'lerdeki "MOUSE_MOVE" mesajını belirtmektedir. 
    Yani fare sürüklendiğinde belirtilen fonksiyon çağrılacaktır. "<KeyPress>" belli bir tuşa basıldığında, "<KeyRelease>" 
    tuştan el çekildiğinde tetiklenmektedir. Burada istenirse "detailed" denilen ek bilgi verilebilmektedir. Örneğin "<KeyPress-x>" x tuluna basılması durumunu belirtir. "<Control>"kontrol tuşunu belirtmektedir. Örneğin "<Control-O>" control ve o tuşuna basımı belirtir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        
        self.frame = tk.Frame(self, bg='yellow')
        self.frame.place(x=10, y=10, width=100, height=100)
              
        self.frame.bind('<Button-1>', self.frame_button_left_press_handler)
 
    def frame_button_left_press_handler(self, event):
        print('frame')
  
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Fare mesajlarında event parametresinin x ve y örnek öznitelikleri farenin o andaki durumunu çalışma alanı orijinli 
    olarak vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        
        self.bind('<Button-1>', self.root_button_left_press_handler)
 
    def root_button_left_press_handler(self, event):
        print(f'x = {event.x}, y = {event.y}')
  
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda fare hareket ettirildikçe farenin korrdinatları yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        
        self.label = tk.Label(self)
        self.label.place(x=10, y=10)
        
        self.bind('<Motion>', self.root_button_motion_handler)
 
    def root_button_motion_handler(self, event):
        print(f'x = {event.x}, y = {event.y}')
  
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir tuşa basıldığında istediğimiz bir fonksiyonun çağrılmasını sağlayabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        
        self.label = tk.Label(self)
        self.label.place(x=10, y=10)
        
        self.bind('<Control-o>', self.control_o_handler)
        self.bind('<KeyPress>', self.keypress_handler)
 
    def control_o_handler(self, event):
        print('Control-o')
        
    def keypress_handler(self, event):
        print(f'Key pressed: {event.char}')
  
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Parmağımızla bir tuşa bastığımızda paramağımızı çeekmnezsek typematic denilen olay gerçekleşir. Typematic sanki
    tuşa belli bir periyotta hem basılıyormuş etkisine denilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('620x350')
        
        self.label = tk.Label(self)
        self.label.place(x=10, y=10)

        self.bind('<KeyPress>', self.keypress_handler)
        self.bind('<KeyRelease>', self.keyrelease_handler)

    def keypress_handler(self, event):
        print(f'Key pressed: {event.char}')
        
    def keyrelease_handler(self, event):
        print(f'Key released: {event.char}')
  
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Menu çubuğu tk.Menu sınıfyla oluşturulur. Menu çubuğu oluşturuylduktan sonra ana pencereye ana pencere sınıfının 
    "menu" seçeneği ile bağlanması gerekir. Popup pencereler de yime tk.Menu sınıfyla oluşturulmaktadır. Popup pencerelerin
    menu çubuğuna bağlanması için tk.Menu sınıfının add_cascade metodu kullanılır. Popup pencerelere menü elemanlarının yerleştirilmesi
     için ise Menu sınıfının add_commmand metotları kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.menu_bar = tk.Menu(self)
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open')
        self.file_popup.add_command(label='Close')
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut')
        self.edit_popup.add_command(label='Copy')
        self.edit_popup.add_command(label='Paste')

        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)

        self['menu'] = self.menu_bar
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı seçildiğinde çağrılacak fonksiyon add_command metodunun "command" isimli parametresiyle belirtilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', command=self.file_open_handler)
        self.file_popup.add_command(label='Close', command=self.file_close_handler)
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', command=self.edit_cut_handler)
        self.edit_popup.add_command(label='Copy', command=self.edit_copy_handler)
        self.edit_popup.add_command(label='Paste', command=self.edit_paste_handler)

        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)

        self['menu'] = self.menu_bar
        
    def file_open_handler(self):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz')
        if path != '':
            print(f'Seçilen dosya: {path}')
        
    def file_close_handler(self):
        self.destroy();
        
    def edit_cut_handler(self):
        print('Cut')
        
    def edit_copy_handler(self):
        print('Copy')
        
    def edit_paste_handler(self):
        print('paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Menü elemanlarının şekil ve zemin renkleri ve fontları değiştirilebilir, menü elemanları "disabled" yapılabili.r
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', command=self.file_open_handler, font=('', 12), foreground='red')
        self.file_popup.add_command(label='Close', command=self.file_close_handler, background='yellow')
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', command=self.edit_cut_handler, state='tk.DISABLED')
        self.edit_popup.add_command(label='Copy', command=self.edit_copy_handler)
        self.edit_popup.add_command(label='Paste', command=self.edit_paste_handler)

        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)

        self['menu'] = self.menu_bar
        
    def file_open_handler(self):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz')
        if path != '':
            print(f'Seçilen dosya: {path}')
        
    def file_close_handler(self):
        self.destroy();
        
    def edit_cut_handler(self):
        print('Cut')
        
    def edit_copy_handler(self):
        print('Copy')
        
    def edit_paste_handler(self):
        print('paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Menü elemanına kısayol tuşu atayabilmek için add_command metodunda "accelerator" isimli parametresi ile kısa yol tuş
    yazısı belirtilir. Ancak bu belirtmenin yapımnası yalnızca menü elemanında kısayol tuş yazısının çıkmasını sağlamaktadır. 
    İlgili tuşa basıldığında o menü elemanı seçilmiş gibi bir işlmein oluşması için ana pencere nesnesi üzerinde event binding
    yapılmalıdır. Menü elemanında "command" parametresi ile girilen fonksiyonun parametre sayısı ile event binding için
    girilen fonksiyonun parametrik yapıları farklıdır. Bunun için lambda işlemlerinden ya da default argüman kullanımından 
    faydalanılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')
        
        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', command=self.file_open_handler, accelerator='Ctrl+O')
        self.file_popup.add_command(label='Close', command=self.file_close_handler)
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', command=self.edit_cut_handler)
        self.edit_popup.add_command(label='Copy', command=self.edit_copy_handler)
        self.edit_popup.add_command(label='Paste', command=self.edit_paste_handler)

        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)

        self['menu'] = self.menu_bar
        
        #self.bind('<Control-o>', lambda event: self.file_open_handler())
        self.bind('<Control-o>', self.file_open_handler)
        
    def file_open_handler(self, event=0):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz')
        if path != '':
            print(f'Seçilen dosya: {path}')
                
    def file_close_handler(self):
        self.destroy();
        
    def edit_cut_handler(self):
        print('Cut')
        
    def edit_copy_handler(self):
        print('Copy')
        
    def edit_paste_handler(self):
        print('paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Menü elemanlarında ikon göstermek için add_command metodunda "image" ve "compound" isimli parametreleri kullanılır. 
    Menü ikonlarının .png formatı biçiminde seçilmesi otomatik transparanlık için tercih edilmelidir. compound parametresi
    ikonun yazının neresinde bulunacağını belirtir. Genellikle tk.LEFT (ya da 'left') biçiminde girilmektedir. 

    Aşağıdaki programı çalıştırabilmek için çalışma dizininizde "open.png", "cut.png", "copy.png" ve "paste.png" dosyalarının 
    bulunuyor olması gerekir. Menü ikonları tipik olarak 16x16 biçimdedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')

        self.open_image = tk.PhotoImage(file='open.png')
        self.cut_image = tk.PhotoImage(file='cut.png')
        self.copy_image = tk.PhotoImage(file='copy.png')
        self.paste_image = tk.PhotoImage(file='paste.png')
   
        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', accelerator='Ctrl+O', image=self.open_image,  compound=tk.LEFT, command=self.file_open_handler)
        self.file_popup.add_command(label='Close', command=self.file_close_handler)
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', image=self.cut_image, compound=tk.LEFT, command=self.edit_cut_handler)
        self.edit_popup.add_command(label='Copy', image=self.copy_image, compound=tk.LEFT, command=self.edit_copy_handler)
        self.edit_popup.add_command(label='Paste', image=self.paste_image, compound=tk.LEFT, command=self.edit_paste_handler)

        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)

        self['menu'] = self.menu_bar
        
        #self.bind('<Control-o>', lambda event: self.file_open_handler())
        self.bind('<Control-o>', self.file_open_handler)
        
    def file_open_handler(self, event=0):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz')
        if path != '':
            print(f'Seçilen dosya: {path}')
                
    def file_close_handler(self):
        self.destroy();
        
    def edit_cut_handler(self):
        print('Cut')
        
    def edit_copy_handler(self):
        print('Copy')
        
    def edit_paste_handler(self):
        print('paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir menü elemanı başka bir popup olabilir. Aşağıdaki örnekte Options popup penceresinin Fruits elemanı da bir popup 
    elemandır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')

        self.open_image = tk.PhotoImage(file='open.png')
        self.cut_image = tk.PhotoImage(file='cut.png')
        self.copy_image = tk.PhotoImage(file='copy.png')
        self.paste_image = tk.PhotoImage(file='paste.png')
   
        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', accelerator='Ctrl+O', image=self.open_image,  compound=tk.LEFT, command=self.file_open_handler)
        self.file_popup.add_command(label='Close', command=self.file_close_handler)
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', image=self.cut_image, compound=tk.LEFT, command=self.edit_cut_handler)
        self.edit_popup.add_command(label='Copy', image=self.copy_image, compound=tk.LEFT, command=self.edit_copy_handler)
        self.edit_popup.add_command(label='Paste', image=self.paste_image, compound=tk.LEFT, command=self.edit_paste_handler)

        self.options_popup = tk.Menu(tearoff=0)
        
        self.fruits_popup = tk.Menu(tearoff=0)
        self.fruits_popup.add_command(label='Apple')
        self.fruits_popup.add_command(label='Banana')
        self.fruits_popup.add_command(label='Orange')
        self.options_popup.add_cascade(label='Fruits', menu=self.fruits_popup)
       
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)
        self.menu_bar.add_cascade(label='Options', menu=self.options_popup)

        self['menu'] = self.menu_bar
        
        #self.bind('<Control-o>', lambda event: self.file_open_handler())
        self.bind('<Control-o>', self.file_open_handler)
        
    def file_open_handler(self, event=0):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz')
        if path != '':
            print(f'Seçilen dosya: {path}')
                
    def file_close_handler(self):
        self.destroy();
        
    def edit_cut_handler(self):
        print('Cut')
        
    def edit_copy_handler(self):
        print('Copy')
        
    def edit_paste_handler(self):
        print('paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Menu elemanı checked/uncked biçiminde yapılabilir. Bunun için tk.Menu sınıfının add_checkbutton metodu kullanılmaktadır. 
    Bu elemanın checked mi unchecked mi olduğu "data binding" işlemi belirlenebilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')

        self.checked_wrapping = tk.BooleanVar()

        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', compound=tk.LEFT, )
        self.file_popup.add_command(label='Close')
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', compound=tk.LEFT)
        self.edit_popup.add_command(label='Copy', compound=tk.LEFT)
        self.edit_popup.add_command(label='Paste', compound=tk.LEFT)

        self.options_popup = tk.Menu(tearoff=0)
        self.options_popup.add_checkbutton(label='Wrapping', variable=self.checked_wrapping, command=self.options_wrapping_handler)
    
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)
        self.menu_bar.add_cascade(label='Options', menu=self.options_popup)
        
        self['menu'] = self.menu_bar
        
    def options_wrapping_handler(self):
        print(f'{"Checked" if self.checked_wrapping.get() else "Unchecked"} yapıldı')
                
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grup menü elemanı radyo düğmesi gibi de davranabilir. Bunun bu elemanların tk.Menu sınıfının add_radiobutton 
    metodu ile eklenmesi gerekmektedir. Bu elemanların kullaımları tamamen tk.Checkbox GUI elemanında olduğu gibidir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('480x350')

        self.selected_fruit = tk.StringVar(value='Elma')

        self.menu_bar = tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', compound=tk.LEFT, command=self.file_open_handler)
        self.file_popup.add_command(label='Close')
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut', compound=tk.LEFT)
        self.edit_popup.add_command(label='Copy', compound=tk.LEFT)
        self.edit_popup.add_command(label='Paste', compound=tk.LEFT)

        self.fruits_popup = tk.Menu(tearoff=0)
        self.fruits_popup.add_radiobutton(label='Apple', value='Elma', variable=self.selected_fruit)
        self.fruits_popup.add_radiobutton(label='Banana', value='Muz', variable=self.selected_fruit)
        self.fruits_popup.add_radiobutton(label='Orange', value='Portakal', variable=self.selected_fruit)
        self.fruits_popup.add_radiobutton(label='Apricot', value='Kayısı', variable=self.selected_fruit)
            
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.edit_popup)
        self.menu_bar.add_cascade(label='Fruits', menu=self.fruits_popup)
        
        self['menu'] = self.menu_bar
        
    def options_wrapping_handler(self):
        print(f'{"Checked" if self.checked_wrapping.get() else "Unchecked"} yapıldı')
        
    def file_open_handler(self)        :
        path = tk.filedialog.askopenfile(title=f'Lütfen bir {self.selected_fruit.get()} seçiniz')
        print(path)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir GUI elemanını sürükleyebilmek için iki event'in binding yoluyla işlenmesi gerekir: '<Button-1>' ve '<B1-Motion>'
    Fare le GUI elemana ilk bastığımızda yeri sınıfın örnek özniteliğinde saklarız. Sonra fareyi sürüklediğimizde 
    kaymanın deltax ve deltay miktarlarını hesaplayıp GUI elemanı o miktarda öteleriz.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('800x600')

        self.button = tk.Button(self, text='Ok')
        self.button.place(x=10, y=20, width=150, height=150)
        
        self.button.bind('<Button-1>', self.button_press_handler)
        self.button.bind('<B1-Motion>', self.button_motion_handler)
        
    def button_press_handler(self, event):
        self.first_x = event.x
        self.first_y = event.y
        
    def button_motion_handler(self, event):
        deltax = event.x - self.first_x
        deltay = event.y - self.first_y
        
        newx = self.button.winfo_x() + deltax
        newy = self.button.winfo_y() + deltay
        self.button.place(x=newx, y=newy)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Farenin sağ tuşuna basıldığında basılan yerde bir düğmenin yaratılması örneği.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

BUTTON_SIZE = 100

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('800x600')
        
        self.counter = 1
        
        self.bind('<Button-3>', self.button_right_press_handler)
     
        
    def button_right_press_handler(self, event):
        button = tk.Button(self, text= f'{self.counter}', font=('', 14))
        button.place(x=event.x - BUTTON_SIZE / 2, y=event.y - BUTTON_SIZE / 2, width=BUTTON_SIZE, height=BUTTON_SIZE)
        
        self.counter += 1
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Farenin sağ tuşuna basılınca düğme yaratan ve yaratılmış olan düğmelerin fare ile sürüklenmesini sağlayan
    örnek program.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

BUTTON_SIZE = 100

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('800x600')
        self.counter = 1
        self.bind('<Button-3>', self.button_right_press_handler)
             
    def button_right_press_handler(self, event):
        print(dir(event))
        button = tk.Button(self, text= f'{self.counter}', font=('', 14))
        button.place(x=event.x - BUTTON_SIZE / 2, y=event.y - BUTTON_SIZE / 2, width=BUTTON_SIZE, height=BUTTON_SIZE)
        button.bind('<Button-1>', self.button_left_press_handler)
        button.bind('<B1-Motion>', self.button_left_motion_handler)
        
        self.counter += 1
        
    def button_left_press_handler(self, event):
        self.first_x = event.x
        self.first_y = event.y
     
    def button_left_motion_handler(self, event):
        deltax = event.x - self.first_x
        deltay = event.y - self.first_y
        
        newx = event.widget.winfo_x() + deltax
        newy = event.widget.winfo_y() + deltay
        
        event.widget.place(x=newx, y=newy)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    PNG formatındaki bir oyun kartının bir düğme biçiminde gösterilmesi örneği
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage

IMAGE_WIDTH = 72
IMAGE_HEIGHT = 96

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
                
        self.button = tk.Button(self)
        self.image = tk.PhotoImage(file='CardImages/1.png')
        self.button.pi = PhotoImage(Image.open('CardImages/1.png'))
        self.button['image'] = self.button.pi
        self.button.place(x=10, y=10, width=IMAGE_WIDTH, height=IMAGE_HEIGHT)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Oyun kartlarının aralarına boşluk bırakılarak gösterilmesi
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage
import glob

IMAGE_WIDTH = 72
IMAGE_HEIGHT = 96
PADDING_X = 10
PADDING_Y = 10

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.title('Playing Cards')
        self.geometry('1200x800')
        
        xpos = PADDING_X
        ypos = PADDING_Y
        for index, path in enumerate(glob.iglob('CardImages/*.png')):
            button = tk.Button(self)
            button.image = PhotoImage(Image.open(path).resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
            button['image'] = button.image
            
            button.place(x=xpos, y=ypos)
            xpos += IMAGE_WIDTH + PADDING_X
            if index % 10 == 9:
                ypos += IMAGE_HEIGHT + PADDING_Y
                xpos = PADDING_X
            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Oyun kartlarının hareket ettirilmesi
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage
import glob

IMAGE_WIDTH = 72
IMAGE_HEIGHT = 96
PADDING_X = 10
PADDING_Y = 10

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.title('Playing Cards')
        self.geometry('1200x800')
        
        xpos = PADDING_X
        ypos = PADDING_Y
        for index, path in enumerate(glob.iglob('CardImages/*.png')):
            label = tk.Label(self)
            label.image = PhotoImage(Image.open(path).resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
            label['image'] = label.image
            label.place(x=xpos, y=ypos)
            
            label.bind('<Button-1>', self.button_left_press_handler)
            label.bind('<B1-Motion>', self.button_left_motion_handler)
           
            xpos += IMAGE_WIDTH + PADDING_X
            if index % 10 == 9:
                ypos += IMAGE_HEIGHT + PADDING_Y
                xpos = PADDING_X
             
    def button_left_press_handler(self, event):
         self.first_x = event.x
         self.first_y = event.y
         
         event.widget.lift()
     
    def button_left_motion_handler(self, event):
        deltax = event.x - self.first_x
        deltay = event.y - self.first_y
        
        newx = event.widget.winfo_x() + deltax
        newy = event.widget.winfo_y() + deltay
        
        event.widget.place(x=newx, y=newy)            
            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Kartların arka yüzünün gösterilmesi ve double click yapıldığında açılması örneği
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage
import glob

IMAGE_WIDTH = 72
IMAGE_HEIGHT = 96
PADDING_X = 10
PADDING_Y = 10

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.title('Playing Cards')
        self.geometry('1200x800')
        
        self.back_image = PhotoImage(Image.open('CardImages/blue-back.png').resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
        
        xpos = PADDING_X
        ypos = PADDING_Y
        for index, path in enumerate(glob.iglob('CardImages/??.png')):
            label = tk.Label(self)
            label.image = PhotoImage(Image.open(path).resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
            label['image'] = self.back_image
            label.place(x=xpos, y=ypos)
            
            label.bind('<Button-1>', self.button_left_press_handler)
            label.bind('<B1-Motion>', self.button_left_motion_handler)
            label.bind('<Double-1>', self.button_left_doubleclick_handler)
           
            xpos += IMAGE_WIDTH + PADDING_X
            if index % 10 == 9:
                ypos += IMAGE_HEIGHT + PADDING_Y
                xpos = PADDING_X
             
    def button_left_press_handler(self, event):
         self.first_x = event.x
         self.first_y = event.y
         
         event.widget.lift()
     
    def button_left_motion_handler(self, event):
        deltax = event.x - self.first_x
        deltay = event.y - self.first_y
        
        newx = event.widget.winfo_x() + deltax
        newy = event.widget.winfo_y() + deltay
        
        event.widget.place(x=newx, y=newy)     
        
    def button_left_doubleclick_handler(self, event):
        event.widget['image'] = event.widget.image
        
            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Kartlar kapalıysa açan, açıksa kapatan örnek
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage
import glob
import os.path

IMAGE_WIDTH = 72
IMAGE_HEIGHT = 96
PADDING_X = 10
PADDING_Y = 10

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.title('Playing Cards')
        self.geometry('1200x800')
        
        self.back_image = PhotoImage(Image.open('CardImages/back-blue.png').resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
        
        xpos = PADDING_X
        ypos = PADDING_Y
        for index, path in enumerate(glob.iglob('CardImages/*.png')):
            if os.path.basename(path).startswith('back'):
                continue
            label = tk.Label(self)
            label.image = PhotoImage(Image.open(path).resize((IMAGE_WIDTH, IMAGE_HEIGHT)))
            label['image'] = self.back_image
            label.place(x=xpos, y=ypos)
            label.closed = True
            
            label.bind('<Button-1>', self.button_left_press_handler)
            label.bind('<B1-Motion>', self.button_left_motion_handler)
            label.bind('<Double-1>', self.button_left_doubleclick_handler)
           
            xpos += IMAGE_WIDTH + PADDING_X
            if index % 10 == 9:
                ypos += IMAGE_HEIGHT + PADDING_Y
                xpos = PADDING_X
             
    def button_left_press_handler(self, event):
         self.first_x = event.x
         self.first_y = event.y
         
         event.widget.lift()
     
    def button_left_motion_handler(self, event):
        deltax = event.x - self.first_x
        deltay = event.y - self.first_y
        
        newx = event.widget.winfo_x() + deltax
        newy = event.widget.winfo_y() + deltay
        
        event.widget.place(x=newx, y=newy)     
        
    def button_left_doubleclick_handler(self, event):
        if event.widget.closed:
            event.widget['image'] = event.widget.image
        else:
            event.widget['image'] = self.back_image
            
        event.widget.closed = not event.widget.closed
            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    pack geometri yöneticisi ixel belirtmeden otomatik yerleştirme için çoça tercih edilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.label1 = tk.Label(self, text='Ali', bg='yellow')
        self.label1.pack()
        
        self.label2 = tk.Label(self, text='Veli', bg='light blue')
        self.label2.pack()

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    pack geometri yöneticisinin side isimli parametresi 'top' (tk.TOP), 'bottom' (tk.BOTTOM), 'right' (tk.RIGHT)
    ya da 'left' (tk.LEFT) değerlerini alabilmektedir. Bu değerler GUI elemanın hangi köşeye yaslaanacağını belirtir. 
    Yukarı ve aşağı yaslanmada GUI elemanları yatay ortada görünrülenir, sola ve sağa yaslanmada düşey ortada görüntülenmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.label1 = tk.Label(self, text='Ali', bg='yellow')
        self.label1.pack(side='top')
        
        self.label2 = tk.Label(self, text='Veli', bg='light blue')
        self.label2.pack(side='left')
        
        self.label1 = tk.Label(self, text='Selami', bg='yellow')
        self.label1.pack(side='right')
        
        self.label2 = tk.Label(self, text='Ayşe', bg='light blue')
        self.label2.pack(side='bottom')

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Birden fazla GUI elemanı aynı göşeye yaslandırılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.label1 = tk.Label(self, text='Ali', bg='yellow')
        self.label1.pack(side='top')
        
        self.label2 = tk.Label(self, text='Veli', bg='light blue')
        self.label2.pack(side='top')
        
        self.label1 = tk.Label(self, text='Selami', bg='yellow')
        self.label1.pack(side='left')
        
        self.label2 = tk.Label(self, text='Ayşe', bg='light blue')
        self.label2.pack(side='left')

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    pack metodunun anchor parametresi coğrafi yöne ilişkin kısaltmaları parametre olarak alır. ('w', 'e', 'n', 's', 
    ve kombinasyonları. tk.W, tk.E, tk.N, tk.S ve kombinasyonları da kullanılabilmektedir.) Bu parametre side ile belirtilen
    ters yönde GUI elemanını hizalamakta kullaılmaktadır. 

    anchor parametresi GUI elemanın ilgili köşeye ya da köşelere demirlenmesine yol açmaktadır. Örneğin biz bir 
    GUI elemanını side='top' yaptığımızda o GUI elemanı yukarıya yapışık hale gelir. Ancak pencereyi genişletip daralttığımızda
    yukarıya ortalı olarak konumlandıırlır. İşte ana pencerenin daraltılması ve genişletilmesinde GUI elemanın konumunun değiştirilmeyeceği 
    anlamına gelir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('320x200')
        
        self.label_name = tk.Label(self, text='Adı Soyadı:', font=('', 12))
        self.label_name.pack(side='top', anchor='w')
        
        self.entry_name = tk.Entry(self, font=('', 12), width=20)
        self.entry_name.pack(side='top', anchor='w')

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    pack metodunun padx parametresi GUI elemana soldan ve sağdan padding vermek için kullanılır. Bu parametre tek bir değer
    olarak girilirse hem soldan hem sağdan aynı padding kullanılır. Bir demet olarak girilirse sol ve sağ padding'ler 
    değiştirilebilir. pack metodunun pady parametresi de benzerdir. Bu parametre GUI elemanın yukarı ve aşağısana padding
    vermek için kulanılır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('320x200')
        
        self.label_name = tk.Label(self, text='Adı Soyadı:', font=('', 12))
        self.label_name.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_name = tk.Entry(self, font=('', 12), width=20)
        self.entry_name.pack(side='top', anchor='w', padx=5)
        
        self.label_no = tk.Label(self, text='No:', font=('', 12))
        self.label_no.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_no= tk.Entry(self, font=('', 12), width=20)
        self.entry_no.pack(side='top', anchor='w', padx=5)

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Label ve Entry GUI elemanları side='top', Button GUI elemanları side='left' yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.geometry('320x200')
        self.resizable(width=False, height=False)
                
        self.label_name = tk.Label(self, text='Adı Soyadı:', font=('', 12))
        self.label_name.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_name = tk.Entry(self, font=('', 12), width=20)
        self.entry_name.pack(side='top', anchor='w', padx=5)
        
        self.label_no = tk.Label(self, text='No:', font=('', 12))
        self.label_no.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_no= tk.Entry(self, font=('', 12), width=20)
        self.entry_no.pack(side='top', anchor='w', padx=5)
        
        self.button_ok = tk.Button(self, text='ok', width=8, font=('', 12))
        self.button_ok.pack(side='left', anchor='nw', padx=(100, 0), pady=20)
                
        self.button_cancel = tk.Button(self, text='cancel', width=8, font=('', 12))
        self.button_cancel.pack(side='left', anchor='nw', padx=20, pady=20)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında GUI elemanları ana pencereye pack yapmak yerine tk.Frame isimli içi boi pencerelere pack yapıp bu Frame pence
    relerini de kendi aralarında pack yapmak daha kolay bir tasarıma yol açmaktadır. 
    
    pack metodunun fill isimli parametresi ilgili GUI elemanın ana pencere genişliğiğini ya da yüksekliğini tamamen kaplamasını sağlar. 
    Bu parametre tk.X ('x'), tk.Y ('y') ya da tk.BOTH ('both') değerlerini alabilmektedir. 
    
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title('Pack Manager')
        self.geometry('320x190')
        self.resizable(width=False, height=False)
                
        self.frame1 = tk.Frame(self)
        self.label_name = tk.Label(self.frame1, text='Adı Soyadı:', font=('', 12))
        self.label_name.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_name = tk.Entry(self.frame1, font=('', 12), width=20)
        self.entry_name.pack(side='top', anchor='w', padx=5)
        
        self.label_no = tk.Label(self.frame1, text='No:', font=('', 12))
        self.label_no.pack(side='top', anchor='w', padx=5, pady=5)
        
        self.entry_no= tk.Entry(self.frame1, font=('', 12), width=20)
        self.entry_no.pack(side='top', anchor='w', padx=5)
        
        self.frame2 = tk.Frame(self)
        
        self.button_ok = tk.Button(self.frame2, text='ok', width=8, font=('', 12))
       
        self.button_cancel = tk.Button(self.frame2, text='cancel', width=8, font=('', 12))
        self.button_cancel.pack(side='right', padx=10)
        self.button_ok.pack(side='right')
        
        self.frame1.pack(side='top', anchor='w')
        self.frame2.pack(side='top', anchor='w', pady=20, fill='x')       
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneğin bir alternatifi
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title('Sample Form')
        self.resizable(width=False, height=False)

        self.frame1 = tk.Frame(self)
        self.label_name = tk.Label(self.frame1, text='Adı Soyadı', width=9, anchor='e')
        self.label_name.pack(side='left', padx=(0, 5))

        self.entry_name = tk.Entry(self.frame1, width=30)
        self.entry_name.pack(side='left')

        self.frame1.pack(side='top', anchor='w', padx=(0, 10), pady=(10, 5))

        self.frame2 = tk.Frame(self)
        self.label_no = tk.Label(self.frame2, text='No', width=9, anchor='e')
        self.label_no.pack(side='left', padx=(0, 5))

        self.entry_no = tk.Entry(self.frame2, width=30)
        self.entry_no.pack(side='left')

        self.frame2.pack(side='top', anchor='w', padx=(0, 10))

        self.frame3 = tk.Frame(self)

        self.button_ok = tk.Button(self.frame3, text='Ok', width=5)
        self.button_cancel = tk.Button(self.frame3, text='Cancel', width=5)

        self.button_cancel.pack(side='right')
        self.button_ok.pack(side='right', padx=(0, 5))

        self.frame3.pack(side='top', anchor='w', fill='x', pady=10, padx=(0, 10))

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki formun sağ tarafa şkon eklenmniş biçimi
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL import ImageTk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title('Sample Form')
        self.resizable(width=False, height=False)

        self.frame1 = tk.Frame(self)
        self.frame2 = tk.Frame(self.frame1)
        self.frame3 = tk.Frame(self.frame2)
        self.frame4 = tk.Frame(self.frame2)
        self.frame5 = tk.Frame(self)

        self.label_name = tk.Label(self.frame3, text='Adı Soyadı', width=9, anchor='e')
        self.label_name.pack(side='left', padx=(0, 5))
        self.entry_name = tk.Entry(self.frame3, width=30)
        self.entry_name.pack(side='left')

        self.label_no = tk.Label(self.frame4, text='No', width=9, anchor='e')
        self.label_no.pack(side='left', padx=(0, 5))
        self.entry_no = tk.Entry(self.frame4, width=30)
        self.entry_no.pack(side='left')

        img = Image.open('Copy.png')
        img = img.resize((60, 50))
        img = ImageTk.PhotoImage(img)

        label_image = tk.Label(self.frame1, image=img)
        label_image.image = img

        label_image.pack(side='right', padx=10)

        self.button_ok = tk.Button(self.frame5, text='Ok', width=7)
        self.button_cancel = tk.Button(self.frame5, text='Cancel', width=7)
        self.button_cancel.pack(side='right')
        self.button_ok.pack(side='right', padx=(0, 5))

        self.frame1.pack(side='top', pady=(5, 0), padx=5)
        self.frame2.pack(side='top')
        self.frame3.pack(side='top', pady=5)
        self.frame4.pack(side='top')
        self.frame5.pack(side='top', fill='y', anchor='e', pady=(15, 10), padx=(0, 20))

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    pack metodundaki fill side belirtilen yatay düşey yönün ters yönündeki açıklığı doldurmaktadır. Yani örneğin 
    biz bir düğmeyi side='left' ile sola yaslamışsak bu durumda fill='y' ile onun düşey alanı doldurmasını sağlarız.
    side = 'left' ile fill='x' beklenen etkiyi yaratmaz. Ancak biz GUI elemanının yasladığımız yatay ya da düşeyle aynı yönde 
    tüm alanı kaplamasını istiyorsak bu durumda expand=True parametresini de kullanmalıyız.

#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title('Pack Manager')
        self.geometry('320x200')
        
        self.button1 = tk.Button(self, text='1')
        self.button1.pack(side='left', fill='x', expand=True)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yatay ve düşey bakımdan birbirlerine ters olarak yaslanan GUI elemanları yatay ve düşeyi kendi aralarında 
    bölüşmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title('Pack Manager')
        self.geometry('320x200')
        
        self.button1 = tk.Button(self, text='1')
        self.button1.pack(side='left', fill='y')
        
        self.button2 = tk.Button(self, text='2')
        self.button2.pack(side='top', fill='x')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer GUI elemanının her iki yönde tüm geri kalan alanı kaplaması isteniyorsa fill='both' yapılmalıdır. Pencere 
    daraltılıp genişletildiğinde GUI elemanın yeni boyutta yeniden tüm alanı kaplamasıiçin expand=True da gereklidir. 
    Normal olarak yukarıda da belirtildiği gibi fill parametresi side parametresinin ters yönünde zaten GUI elemanın 
    tüm alanı kaplamasını sağlar. Ancak diğer yönde kaplama için expand=True yapılmalıdır. 

    Aşağıdaki örnekte Text boc GUI elemanının tüm pencerenin çalışma alanınını kaplaması sağlanmıştır. Burada side='left'
    kullanılmış olsa da fill='both' ce expand=True nedeniyle aslında yaslama herhangi bir yere yapılabilirdi.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title('Pack Manager')
        self.geometry('320x190')
        
        self.text = tk.Text(self)
        self.text.pack(side='left', fill='both', expand=True)

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir chat ekranının pack geometri yöneticisi kullanılarak oluşturulması
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.scrolledtext

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        
        self.title('Pack Manager')
        self.geometry('420x800')
        
        self.text = tk.scrolledtext.ScrolledText(self, font=('', 14))
        self.text.pack(side='top', fill='both', expand=True, padx=10, pady=10)
        
        self.entry = tk.Entry(self, font=('', 14))
        self.entry.pack(side='top', fill='x', padx=10)      
        
        self.button = tk.Button(self, text='Send', width=8, height=3, command=self.button_click_handler)
        self.button.pack(side='top', pady=10, padx=20, fill='x')
        
        self.bind('<Return>', self.button_click_handler)

    def button_click_handler(self, event=0):
        s = self.entry.get()
        self.text.insert('end', s + '\n')
        self.entry.delete(0, 'end')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Basit bir hesap makinesi programı
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title('Calculator')
        self.resizable(width=False, height=False)

        self.frame_main = tk.Frame(self)
        self.frame_main.pack(side='top', expand=True, fill='both', padx=10, pady=10)

        self.textvariable = tk.StringVar()
        self.entry = tk.Entry(self.frame_main, justify='right', font='calibri 12', width=25, textvariable=self.textvariable, state='disabled', disabledbackground='white', disabledforeground='black')
        self.entry.pack(side='top', fill='x', pady=(0, 15))

        self.frame1 = tk.Frame(self.frame_main)

        self.button_backspace = tk.Button(self.frame1, text='Back Space', width=10)
        self.button_backspace['command'] = lambda: self.button_handler(self.button_backspace)
        self.button_backspace.pack(side='left', padx=(0, 10))

        self.button_clear = tk.Button(self.frame1, text='Clear All', width=10)
        self.button_clear['command'] = lambda: self.button_handler(self.button_clear)
        self.button_clear.pack(side='left')

        self.frame1.pack(side='top', anchor='w')

        self.frame2 = tk.Frame(self.frame_main)

        self.button_7 = tk.Button(self.frame2, text='7', width=4)
        self.button_7['command'] = lambda: self.button_handler(self.button_7)
        self.button_7.pack(side='left', padx=(0, 5))

        self.button_8 = tk.Button(self.frame2, text='8', width=4)
        self.button_8['command'] = lambda: self.button_handler(self.button_8)
        self.button_8.pack(side='left', padx=(0, 5))

        self.button_9 = tk.Button(self.frame2, text='9', width=4,)
        self.button_9['command'] = lambda: self.button_handler(self.button_9)
        self.button_9.pack(side='left', padx=(0, 5))

        self.button_slash = tk.Button(self.frame2, text='/', width=4)
        self.button_slash['command'] = lambda: self.button_handler(self.button_slash)
        self.button_slash.pack(side='left', padx=(0, 5))

        self.button_sqrt = tk.Button(self.frame2, text='sqrt', width=4)
        self.button_sqrt['command'] = lambda: self.button_handler(self.button_sqrt)
        self.button_sqrt.pack(side='left', padx=(0, 5))

        self.frame2.pack(side='top', anchor='w', pady=(10, 5))

        self.frame3 = tk.Frame(self.frame_main)

        self.button_4 = tk.Button(self.frame3, text='4', width=4)
        self.button_4['command'] = lambda: self.button_handler(self.button_4)
        self.button_4.pack(side='left', padx=(0, 5))

        self.button_5 = tk.Button(self.frame3, text='5', width=4)
        self.button_5['command'] = lambda: self.button_handler(self.button_5)
        self.button_5.pack(side='left', padx=(0, 5))

        self.button_6 = tk.Button(self.frame3, text='6', width=4)
        self.button_6['command'] = lambda: self.button_handler(self.button_6)
        self.button_6.pack(side='left', padx=(0, 5))

        self.button_multiply = tk.Button(self.frame3, text='*', width=4)
        self.button_multiply['command'] = lambda: self.button_handler(self.button_multiply)
        self.button_multiply.pack(side='left', padx=(0, 5))

        self.button_inverse = tk.Button(self.frame3, text='1/x', width=4)
        self.button_inverse['command'] = lambda: self.button_handler(self.button_inverse)
        self.button_inverse.pack(side='left', padx=(0, 5))

        self.frame3.pack(side='top', anchor='w', pady=(10, 5))

        self.frame4 = tk.Frame(self.frame_main)

        self.button_1 = tk.Button(self.frame4, text='1', width=4)
        self.button_1['command'] = lambda: self.button_handler(self.button_1)
        self.button_1.pack(side='left', padx=(0, 5))

        self.button_2 = tk.Button(self.frame4, text='2', width=4)
        self.button_2['command'] = lambda: self.button_handler(self.button_2)
        self.button_2.pack(side='left', padx=(0, 5))

        self.button_3 = tk.Button(self.frame4, text='3', width=4)
        self.button_3['command'] = lambda: self.button_handler(self.button_3)
        self.button_3.pack(side='left', padx=(0, 5))

        self.button_subtract = tk.Button(self.frame4, text='-', width=4)
        self.button_subtract['command'] = lambda: self.button_handler(self.button_subtract)
        self.button_subtract.pack(side='left', padx=(0, 5))

        self.button_pow = tk.Button(self.frame4, text='pow', width=4)
        self.button_pow['command'] = lambda: self.button_handler(self.button_pow)
        self.button_pow.pack(side='left', padx=(0, 5))

        self.frame4.pack(side='top', anchor='w', pady=(10, 5))

        self.frame5 = tk.Frame(self.frame_main)

        self.button_0 = tk.Button(self.frame5, text='0', width=4)
        self.button_0['command'] = lambda: self.button_handler(self.button_0)
        self.button_0.pack(side='left', padx=(0, 5))

        self.button_plusminus = tk.Button(self.frame5, text='+/-', width=4)
        self.button_plusminus['command'] = lambda: self.button_handler(self.button_plusminus)
        self.button_plusminus.pack(side='left', padx=(0, 5))

        self.button_dot = tk.Button(self.frame5, text='.', width=4)
        self.button_dot['command'] = lambda: self.button_handler(self.button_dot)
        self.button_dot.pack(side='left', padx=(0, 5))

        self.button_plus = tk.Button(self.frame5, text='+', width=4)
        self.button_plus['command'] = lambda: self.button_handler(self.button_plus)
        self.button_plus.pack(side='left', padx=(0, 5))

        self.button_equal = tk.Button(self.frame5, text='=', width=4)
        self.button_equal['command'] = lambda: self.button_handler(self.button_equal)
        self.button_equal.pack(side='left', padx=(0, 5))

        self.frame5.pack(side='top', anchor='w', pady=(10, 5))

        self.lastkey_op = False
        self.prev_val = 0
        self.last_op = None

    def button_handler(self, button):
        if button['text'] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:
            if self.lastkey_op:
                if self.last_op != '=':
                    self.prev_val = float(self.textvariable.get())
                self.textvariable.set('')
                self.lastkey_op = False
            self.textvariable.set(self.textvariable.get() + button['text'])
        elif button['text'] in ['+', '-', '*', '/'] and not self.lastkey_op:
            if self.last_op != None:
                if self.last_op == '+':
                    result = self.prev_val + float(self.textvariable.get())
                elif self.last_op  == '-':
                    result = self.prev_val - float(self.textvariable.get())
                elif self.last_op == '*':
                    result = self.prev_val * float(self.textvariable.get())
                elif self.last_op == '/':
                    result = self.prev_val / float(self.textvariable.get())

                self.textvariable.set(int(result) if int(result) == result else result)

            self.lastkey_op = True
            self.last_op = button['text']

        elif button['text'] == '=' and self.last_op != None:
            if self.last_op == '+':
                result = self.prev_val + float(self.textvariable.get())
            elif self.last_op == '-':
                result = self.prev_val - float(self.textvariable.get())
            elif self.last_op == '*':
                result = self.prev_val * float(self.textvariable.get())
            elif self.last_op == '/':
                result = self.prev_val / float(self.textvariable.get())

            self.textvariable.set(int(result) if int(result) == result else result)
            self.last_op = None
            self.lastkey_op = True
            self.prev_val = 0
            self.start_flag = False
        elif button['text'] == 'Clear All':
            self.lastkey_op = False
            self.prev_val = 0
            self.last_op = None
            self.textvariable.set('')
        elif button['text'] == 'sqrt':
            result = float(self.textvariable.get()) ** 0.5
            self.textvariable.set(int(result) if int(result) == result else result)
        elif button['text'] == '1/x':
            result = 1 / float(self.textvariable.get())
            self.textvariable.set(int(result) if int(result) == result else result)
        elif button['text'] == 'Back Space':
            self.textvariable.set(self.textvariable.get()[:-1])
        elif button['text'] == '+/-':
            result = float(self.textvariable.get()) * -1
            self.textvariable.set(int(result) if int(result) == result else result)

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da hazır bir Toolbar GUI eleman sınıfı yoktur. Programcının kendi toolbar'ını kendisinin yapması gerekmektedir. 
    Bunun için bir Frame penceresi alınır. Bu pencere yukarıya yaslanır. Sonra o frame penceresinin içerisine düğmeler
    yerleştirilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
import tkinter.filedialog
import tkinter.scrolledtext

class Root(tk.Tk):
    def __init__(self):   
        super().__init__()
        self.title('ToolBar Sample')
        self.geometry('480x320')
        
        self.menu_bar= tk.Menu()
        
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open', command=self.file_open_handler, accelerator='Ctrl+O')
        self.bind('<Control-o>', self.file_open_handler)
        
        self.file_popup.add_command(label='Save')
        self.file_popup.add_command(label='close')
        
        self.edit_popup = tk.Menu(tearoff=0)
        self.edit_popup.add_command(label='Cut')
        self.edit_popup.add_command(label='Copy')
        self.edit_popup.add_command(label='Paste')
        
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self.menu_bar.add_cascade(label='Edit', menu=self.file_popup)
        
        self['menu'] = self.menu_bar
        
        self.toolbar_frame = tk.Frame(self)
        self.toolbar_frame.pack(side='top', fill='x')

        image = tk.PhotoImage(file='open-64.png')
        self.toolbar_open_item = tk.Button(self.toolbar_frame, image=image, command=self.file_open_handler)
        self.toolbar_open_item.image = image
        self.toolbar_open_item.pack(side='left')    
        self.toolbar_frame.pack(side='top', fill='x', padx=1)
        
        image = tk.PhotoImage(file='save-64.png')
        self.toolbar_save_item = tk.Button(self.toolbar_frame, image=image)
        self.toolbar_save_item.image = image
        self.toolbar_save_item.pack(side='left', padx=2) 
             
        image = tk.PhotoImage(file='cut-64.png')
        self.toolbar_cut_item = tk.Button(self.toolbar_frame, image=image)
        self.toolbar_cut_item.image = image
        self.toolbar_cut_item.pack(side='left', padx=2) 
        
        image = tk.PhotoImage(file='copy-64.png')
        self.toolbar_copy_item = tk.Button(self.toolbar_frame, image=image)
        self.toolbar_copy_item.image = image
        self.toolbar_copy_item.pack(side='left', padx=2) 
        
        image = tk.PhotoImage(file='paste-64.png')
        self.toolbar_paste_item = tk.Button(self.toolbar_frame, image=image)
        self.toolbar_paste_item.image = image
        self.toolbar_paste_item.pack(side='left', padx=2) 
                  
        self.text = tk.scrolledtext.ScrolledText(self, font=(', 14'))
        self.text.pack(side='top', fill='both', expand=True)
       
    def file_open_handler(self, event=0):
        path = tk.filedialog.askopenfilename(title='Bir dosya seçiniz', filetypes=[('Python files', '*.py')])
        if path != '':
            with open(path) as f:
                s = f.read()
                self.text.insert('1.0', s)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Grid geometri yöneticisi widget sınıflarının grid isimli metodu eşliğinde kullanılmaktadır. Baştan grid'in kaça kaç
   olacağı belirtilmez. Yerleşim grid metodunda row ve xolumn isimli parametresinde hücrenin yeri belirtilerek yapılır.
   Hücre yeri belirtilirken tipik olarak row ve column 0'dan başlatılmaktadır. Ancak numaralandırma bu biçimde yapılmak
   zorunda dğeildir. Fakat numaralar küçükten büyüğe sıraya dizildiğinde aslında bunlar ardışık satır ve sütun numaralarını
   belirtir. 

   Aşağıdaki örnekte 9 tane düğme 3x3 bir grid'in hücrelerine yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_00 = tk.Button(self, text='Button-00')
        self.button_01 = tk.Button(self, text='Button-01')
        self.button_02 = tk.Button(self, text='Button-02')
        
        self.button_10 = tk.Button(self, text='Button-10')
        self.button_11 = tk.Button(self, text='Button-11')
        self.button_12 = tk.Button(self, text='Button-12')
        
        self.button_20 = tk.Button(self, text='Button-20')
        self.button_21 = tk.Button(self, text='Button-21')
        self.button_22 = tk.Button(self, text='Button-22')
        
        self.button_00.grid(row=0, column=0)
        self.button_01.grid(row=0, column=1)
        self.button_02.grid(row=0, column=2)
        
        self.button_10.grid(row=1, column=0)
        self.button_11.grid(row=1, column=1)
        self.button_12.grid(row=1, column=2)
        
        self.button_20.grid(row=2, column=0)
        self.button_21.grid(row=2, column=1)
        self.button_22.grid(row=2, column=2)
                       
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    widget sınıflarının onların içerisindeki gridlerin özelliklerini ayarlamak için rowconfigure ve columnconfigure 
    isimli metotları vardır. Bu metotların birinci parametreleri ilgili satır ya da sütunun numarasını belirtir. 
    weight isimli parametreleri ise ilgili satır sütunun diğer satır ve sütunlara göre pencere genişletildiğinde ya da daraltıldığında
    hangi oranda büyütülüp küçültüleceğini belirtmektedir. Burada yalnızca weight değerleri girilmiş olan satır ya da sütunlar üzerinde
    ağırlıklı ortalama alınmaktadır. Daraltma durumunda yine weight ile belirtilen ağırklılı değerde daraltma yapılmaktadır.

    Aşağıdaki örnekte 3x3'lük bir grid'in birinci satırı ikinci ve üçüncü satırından genişlitildiğinde iki kat daha geniş gözükecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_00 = tk.Button(self, text='Button-00')
        self.button_01 = tk.Button(self, text='Button-01')
        self.button_02 = tk.Button(self, text='Button-02')
        
        self.button_10 = tk.Button(self, text='Button-10')
        self.button_11 = tk.Button(self, text='Button-11')
        self.button_12 = tk.Button(self, text='Button-12')
        
        self.button_20 = tk.Button(self, text='Button-20')
        self.button_21 = tk.Button(self, text='Button-21')
        self.button_22 = tk.Button(self, text='Button-22')
        
        self.button_00.grid(row=0, column=0, sticky='nwes')
        self.button_01.grid(row=0, column=1, sticky='nwes')
        self.button_02.grid(row=0, column=2, sticky='nwes')
        
        self.button_10.grid(row=1, column=0, sticky='nwes')
        self.button_11.grid(row=1, column=1, sticky='nwes')
        self.button_12.grid(row=1, column=2, sticky='nwes')
        
        self.button_20.grid(row=2, column=0, sticky='nwes')
        self.button_21.grid(row=2, column=1, sticky='nwes')
        self.button_22.grid(row=2, column=2, sticky='nwes')
        
        self.rowconfigure(0, weight=2)
        self.rowconfigure(1, weight=1)
        self.rowconfigure(2, weight=1)
               
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Üst pencere genişletildiğinde ya da daraltıldığında grid hücerelerinin genişletilmesi ve daraltılması için
    rowconfigure ve/veya columnconfigure ile wight değerlerini belirtilemsi gerekir. Eğer satır ya da sütun için
    weight değeri belirtilmezse üst pencere daraltıldığında ya da genişletildiğinde ilgili satır ya da sütunda 
    bir değişiklik olmaz. 

    Aşağıdaki örnekte 3x3 lik grid içerisindeki tüm satırların ve sütunların weight değerleri aynı yapılmıştır. Bu durumda
    satırlar ve sütunlar pencere daraltıldığında ya da genişletildiğinde aynı oranda büyütülüp küçültülürler.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_00 = tk.Button(self, text='Button-00')
        self.button_01 = tk.Button(self, text='Button-01')
        self.button_02 = tk.Button(self, text='Button-02')
        
        self.button_10 = tk.Button(self, text='Button-10')
        self.button_11 = tk.Button(self, text='Button-11')
        self.button_12 = tk.Button(self, text='Button-12')
        
        self.button_20 = tk.Button(self, text='Button-20')
        self.button_21 = tk.Button(self, text='Button-21')
        self.button_22 = tk.Button(self, text='Button-22')
        
        self.button_00.grid(row=0, column=0, sticky='nwes')
        self.button_01.grid(row=0, column=1, sticky='nwes')
        self.button_02.grid(row=0, column=2, sticky='nwes')
        
        self.button_10.grid(row=1, column=0, sticky='nwes')
        self.button_11.grid(row=1, column=1, sticky='nwes')
        self.button_12.grid(row=1, column=2, sticky='nwes')
        
        self.button_20.grid(row=2, column=0, sticky='nwes')
        self.button_21.grid(row=2, column=1, sticky='nwes')
        self.button_22.grid(row=2, column=2, sticky='nwes')
        
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.rowconfigure(2, weight=1)
        
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=1)
                            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    grid metodundaki sticky parametresi gridin ilgi hücresi büyütüldüğünde ya da küçültüldüğünde o hücre içerisindeki
    GUI elemanın hücreye nasıl yerleşeceği üzerinde etkili olmaktadır. Bu parametre 'w', 'e', 'n', 's' değerlerinin bir 
    ya da birden fazlasını alabilmektedir. stciky='nwse' ilgili GUI elemanın hücreyi tam olarak kaplayacağı anlamına gelmektedir. 
    Buradaki yön belirten harfler herhangi bir sırada belirtilebilirler.

    Aşağıdaki örnekte değişik stick belirlemelri yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_00 = tk.Button(self, text='Button-00')
        self.button_01 = tk.Button(self, text='Button-01')
        self.button_02 = tk.Button(self, text='Button-02')
        
        self.button_10 = tk.Button(self, text='Button-10')
        self.button_11 = tk.Button(self, text='Button-11')
        self.button_12 = tk.Button(self, text='Button-12')
        
        self.button_20 = tk.Button(self, text='Button-20')
        self.button_21 = tk.Button(self, text='Button-21')
        self.button_22 = tk.Button(self, text='Button-22')
        
        self.button_00.grid(row=0, column=0, sticky='ewns')
        self.button_01.grid(row=0, column=1, sticky='ew')
        self.button_02.grid(row=0, column=2, sticky='ns')
        
        self.button_10.grid(row=1, column=0)
        self.button_11.grid(row=1, column=1)
        self.button_12.grid(row=1, column=2)
        
        self.button_20.grid(row=2, column=0)
        self.button_21.grid(row=2, column=1)
        self.button_22.grid(row=2, column=2)
        
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.rowconfigure(2, weight=1)
        
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=1)
                   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    rowconfigure ve columnconfigure metotlarının minsize isimli parametreleri ilgili satır ya da sütununun en küçük
    uzunluğunu belirlemek için kullanılmaktadır. İşin başında hücrelerin bu uzunluklarda yaratılması da yine minsize 
    parametresiyle sağlanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_x = tk.Button(self, text='X')
        self.button_y = tk.Button(self, text='Y')
              
        self.button_z = tk.Button(self, text='Z')
        self.button_k = tk.Button(self, text='K')
      
        self.button_x.grid(row=0, column=0, columnspan=2, sticky='nsew')
        self.button_y.grid(row=0, column=2, rowspan=2, sticky='nsew')
        
        self.button_z.grid(row=1, column=0, sticky='nsew')
        self.button_k.grid(row=1, column=1, sticky='nsew')
        
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        
        self.rowconfigure(0, weight=2, minsize=100)
        self.rowconfigure(1, weight=1, minsize=50)
                     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    grid metodunda yine pack metodunda olduğu gibi padx ve pady parametreleri vardır. Bu parametreler hücre içerisindeki
    GUI elemanın saol, sağ, üst ve altında ne kadar boşluk bırakılacağını belritmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.button_x = tk.Button(self, text='X')
        self.button_y = tk.Button(self, text='Y')
              
        self.button_z = tk.Button(self, text='Z')
        self.button_k = tk.Button(self, text='K')
      
        self.button_x.grid(row=0, column=0, columnspan=2, sticky='nsew', padx=10, pady=10)
        self.button_y.grid(row=0, column=2, rowspan=2, sticky='nsew', padx=20)
        
        self.button_z.grid(row=1, column=0, sticky='nsew', padx=10)
        self.button_k.grid(row=1, column=1, sticky='nsew', padx=10)
        
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        
        self.rowconfigure(0, weight=2, minsize=100)
        self.rowconfigure(1, weight=1, minsize=50)
                     
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Veri girişi için basit form penceresinin yalnızca grid kullanılarak gerçekleştirilmesi
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.resizable(width=False, height=False)

        self.label_name = tk.Label(self, text='Adı Soyadı')
        self.entry_name = tk.Entry(self, width=30)
        
        self.label_no = tk.Label(self, text='No')
        self.entry_no = tk.Entry(self, width=30)
        
        self.button_ok = tk.Button(self, text='Ok', width=5)
        self.button_cancel = tk.Button(self, text='Cancel', width=5)
        
        image = tk.PhotoImage(file='open-64.png')
        self.label_image = tk.Label(self, image=image)
        self.label_image.image = image
        
        self.label_name.grid(row=0, column=0, sticky='e', padx=(0, 10))
        self.entry_name.grid(row=0, column=1, pady=8)
        
        self.label_no.grid(row=1, column=0, sticky='e', padx=(0, 10))
        self.entry_no.grid(row=1, column=1, pady=(0, 10))
        
        self.label_image.grid(row=0, column=2, rowspan=2, padx=10)
        
        self.button_ok.grid(row=2, column=1, sticy='e', pady=(0, 10))
        self.button_cancel.grid(row=2, column=2, padx=(0, 10), pady=(0, 10))
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki GUI yerleşiminin aynısı değişik biçimlerde de yapılabilir. Örneğin üst kısım bir frame içerisine grid
    ile yerleştirilirken alt kısım (yani düğmeler) bir frame içeriisne pack ile yerleştirilebilir. Bu iki frame de yine
    ana pencereye pack ile yerleştirilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.resizable(width=False, height=False)

        self.frame1 = tk.Frame(self)

        self.label_name = tk.Label(self.frame1, text='Adı Soyadı')
        self.entry_name = tk.Entry(self.frame1, width=30)
        
        self.label_no = tk.Label(self.frame1, text='No')
        self.entry_no = tk.Entry(self.frame1, width=30)
        
        image = tk.PhotoImage(file='open-64.png')
        self.label_image = tk.Label(self.frame1, image=image)
        self.label_image.image = image
        
        self.label_name.grid(row=0, column=0, sticky='e', padx=(0, 10))
        self.entry_name.grid(row=0, column=1, pady=8)
        
        self.label_no.grid(row=1, column=0, sticky='e', padx=(0, 10))
        self.entry_no.grid(row=1, column=1, pady=(0, 10))
        
        self.label_image.grid(row=0, column=2, rowspan=2, padx=10)
                       
        self.frame2 = tk.Frame(self)
        
        self.button_ok = tk.Button(self.frame2, text='Ok', width=8)
        self.button_cancel = tk.Button(self.frame2, text='Cancel', width=8)
             
        
        self.button_cancel.pack(side='right')
        self.button_ok.pack(side='right', padx=(0, 10))
        
        self.frame1.pack(side='top', fill='x')
        self.frame2.pack(side='top', fill='x', pady=20, padx=20)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bağlam menüsü oluşturmak için önce yine tk.Menu sınıfı kullanılarak bir popup pencere oluşturulur. Sonra farenin sağ
    tuşuna basıldığında Menu sınıfının post metodu ile bağlam menüsü açılır. Ancak post metodunda bağlam menüsüün açılacağı 
    koordinat çalışma alanı orijinli değil masaüstü orijinli olarak verilmelidir. Masaüstü orijinli koordinatlar event sınıfının 
    x_root ve y_root örneközniteliklerinden elde edilebilir. Ayrıca handler fonksiyonundan 'break' biiminde bir yazıyla geri dönülmesi
    bazı nedenlerden dolayı gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.context_menu = tk.Menu(tearoff=0)
        self.context_menu.add_command(label='Open', command=self.menu_open_handler)
        self.context_menu.add_command(label='Close', command=self.menu_close_handler)
        self.context_menu.add_command(label='Exit', command=self.menu_exit_handler)
        
        self.bind('<Button-3>', self.context_menu_handler)
 
    def context_menu_handler(self, event):
        self.context_menu.post(event.x_root, event.y_root)
        return 'break'
    
    def menu_open_handler(self):
        print('Open')
        
    def menu_close_handler(self):
        print('Close')
        
    def menu_exit_handler(self):
        self.destroy()
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Farklı yerlere tıklandığında farklı bağlam menülerinin çıkartılması istenebilmektedir. Eğer form üzerinde alt pencereler 
    varsa bind işlemi o pencerelere yönelik nesneler kullanılarak yapılırsa bu işlem kolay olur. Fakat bu biçimde alt pencereler yoksa
    programcı tıklanan yeri belirleyerek manuel biçimde istediği bağlam menüsünü göstermelidir. 

    Aşağıdaki örnekte pencerenin sol ve sağ bölgesinde farklı bağlam menüleri çıkartılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.context_menu1 = tk.Menu(tearoff=0)
        self.context_menu1.add_command(label='Open', command=self.menu_open_handler)
        self.context_menu1.add_command(label='Close', command=self.menu_close_handler)
        self.context_menu1.add_command(label='Exit', command=self.menu_exit_handler)
        
        self.context_menu2 = tk.Menu(tearoff=0)
        self.context_menu2.add_command(label='Cut', command=self.menu_cut_handler)
        self.context_menu2.add_command(label='Copy', command=self.menu_copy_handler)
        self.context_menu2.add_command(label='Paste', command=self.menu_paste_handler)
        
        self.bind('<Button-3>', self.context_menu_handler)
 
    def context_menu_handler(self, event):
        if event.x <= self.winfo_width() / 2:
            self.context_menu1.post(event.x_root, event.y_root)
        else: 
            self.context_menu2.post(event.x_root, event.y_root)
        
        return 'break'
    
    def menu_open_handler(self):
        print('Open')
        
    def menu_close_handler(self):
        print('Close')
        
    def menu_exit_handler(self):
        self.destroy()
        
    def menu_cut_handler(self):
        print('Cut')
        
    def menu_copy_handler(self):
        print('Copy')
        
    def menu_paste_handler(self):
        print('Paste')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
   Tkinter'da bazı GUI elemanlarının scroll özellikleri kendi içlerinde bulunmamaktadır. (ScrolledText isimli bir GUI
   elemanının daha sonra eklendiğini anımsayınız) Tkinter'da scroll çubuğu ayrı bir GUI elemandır. Programcı örneğin
   Listbox GUI elemanına bir scroll çubuğu iliştirecekse bu iki GUI elemanını birbirlerine işlevsel biçimde bağlamalıdır.
   Bu bağlama sonucunda Listbox'taki kaydırmalar Scrollbar'a Scrollbar'daki kaydırmalar ise Listbox'a yansıtılır. Bunu 
   sağlamak için iki şey yapılmalıdır:

   1) Scrollbar sınıfının command isimli konfigürasyon parametresine Listbox sınıfının yview ya da xview metotları atanır.
   2) Listbox sınıfının xscrollcommand ya da yscrollcommand konfigürasyon parametrelerine Scrollbar sınıfının set metodu
   atanır. 

   Tabii görsel olarak iki GUI elemanının pack ile yan yana getirilmesi uygun olur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.listbox = tk.Listbox(self, height=20)
        self.listbox.pack(side='left', fill='y')
        
        for i in range(100):
            self.listbox.insert(tk.END, i)
               
        self.scrollbar = tk.Scrollbar(self, command=self.listbox.yview)
        self.scrollbar.pack(side='left', fill='y')
        self.listbox.configure(yscrollcommand=self.scrollbar.set)        
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii ilgili GUI eleman Scroolbar nesnesi ile birleştirilerek bir sınıf biçiminde de oluşturulabilir
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.slb = ScrolledListbox(self, bg='yellow', height=20, width=10, font=('', 14))
        self.slb.pack(side='top')
        
        for i in range(100):
            self.slb.listbox.insert(tk.END, i)
            
        self.button_ok = tk.Button(self, text='Ok', width=8, command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=20)
        
    def button_ok_handler(self):
        s = self.slb.listbox.get('active')
        print(s)
        
class ScrolledListbox(tk.Frame):
    def __init__(self, master, *args, **kwargs):
        super().__init__(master)
        
        self.listbox = tk.Listbox(self, *args, **kwargs)
        self.listbox.pack(side='left', fill='y')
        
        self.scrollbar = tk.Scrollbar(self, command=self.listbox.yview)
        self.scrollbar.pack(side='left', fill='y')
        self.listbox.configure(yscrollcommand=self.scrollbar.set)        
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Pencerenin kapatma ikonuna tıklandığında işlem yapabilmek için ana pencere nesnesi ile protocol isimli metoduna
    'WM_DELETE_WINDOW' parametresiyle çağrılması gerekir. Ancak bu mesaj işlenirse pencerenin kapatılması artık Programcının
    sorumluluğunda olur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
       
        self.protocol('WM_DELETE_WINDOW', self.window_delete_handler)
        
    def window_delete_handler(self):
        print('closing...')
        self.destroy()
          
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da çizim yapmak için Canvas denilen özel bir pencere (widget) kullanılmaktadır. Programcı tk.Canvas türünden
    bir nesne yaratır. Sonra bu Canvas sınıfının create_xxx biçiminde isimlendirilmiş olan metotlarını çağırır.

    Aşağıda bu işlemin bir örneği görülmektedir:
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.place(x=10, y=10, width=200, height=200)

        self.canvas.create_line(0, 0, 100, 100)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında genellikle programcılar canvas'ın tüm çalışma alanını kaplamasını isterler. Böylece çisim sanki
    ana pencereye yapılıyormuş gibi bir etki oluşur.    
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self)
        self.canvas.pack(fill='both', expand=True)

        self.canvas.create_line(0, 0, 100, 100)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yazboz tahtası uygulaması şöyle yapılır: Fare ile tıklandığında tıklanan yer seınıfın örnek niteiklerinde saklanır. 
    Sonra fare her sürüklendiğinde önce noktayla sonraki nokta arasına bir doğru parçası çizilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

LINE_WIDTH = 3
LINE_COLOR = 'red'

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)

        self.bind('<Button-1>', self.button_press_handler)
        self.bind('<B1-Motion>', self.button_motion_handler)
        
    def button_press_handler(self, event):
        self.prevx = event.x
        self.prevy = event.y
    
    def button_motion_handler(self, event):
        self.canvas.create_line(self.prevx, self.prevy, event.x, event.y, fill=LINE_COLOR, width=LINE_WIDTH)
        self.prevx = event.x
        self.prevy = event.y
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Canvas sınıfının create_arc isimli metodu yay çizmek için kullanılmaktadır. Burada ilk 4 parametre bir dikdörtgen koordinatını
    alır. Bu dikdörtgenin iç teğet elipsine ilişkin yay çizdirilmektedir. start ile başlangıç açısı, extent ile süpürme açısı 
    verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)
        
        self.canvas.create_arc(100, 100, 200, 200, width=3, start=0, extent=100, style=tk.ARC)
      
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Canvas sınıfının create_image isimli metodu bizden bir koordinat ve image isimli parametresiyle çizdirilecek resmi alır. 
    Resmi resmin ortası o koordinatta olacak biçimde çizdirir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image   
from PIL.ImageTk import PhotoImage

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)
        
        image = Image.open('AbbeyRoad.jpg').resize((200, 200))
        self.image = PhotoImage(image)
        
        self.canvas.bind('<Button-1>', self.button_press_handler)
  
    def button_press_handler(self, event):
         self.canvas.create_image(event.x, event.y, image=self.image)
         
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resmin taşınması label içerisindeki bir resmin taşınmasından daha zordur. Çünkü resmin konumunun hit testing 
    için tutulması gerekir. Oysa widget'ların üzerine tıklanıp tıklanmadığı zaten sistem tarafından belirlenmketdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from PIL import Image
from PIL.ImageTk import PhotoImage

IMAGE_WIDTH = 200
IMAGE_HEIGHT = 200

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)
        
        image = Image.open('AbbeyRoad.jpg').resize((IMAGE_WIDTH, IMAGE_HEIGHT))
        self.image = PhotoImage(image)
        
        self.canvas.bind('<Button-3>', self.button_right_press_handler)      
        self.canvas.bind('<Button-1>', self.button_left_press_handler)
        self.canvas.bind('<B1-Motion>', self.button_left_motion_handler)
        
    def button_right_press_handler(self, event):
        self.image_id = self.canvas.create_image(event.x, event.y, image=self.image)
        self.imagex = event.x - IMAGE_WIDTH / 2
        self.imagey = event.y - IMAGE_HEIGHT / 2
        
    def button_left_press_handler(self, event):
         self.prevx = event.x
         self.prevy = event.y
         
    def button_left_motion_handler(self, event):
        if self.pt_in_rect(self.imagex, self.imagey, IMAGE_WIDTH, IMAGE_HEIGHT, event.x, event.y):
            deltax = event.x - self.prevx
            deltay = event.y - self.prevy
            
            self.canvas.move(self.image_id, deltax, deltay)
            
            self.prevx = event.x
            self.prevy = event.y
            
            self.imagex += deltax
            self.imagey += deltay
            
    @staticmethod
    def pt_in_rect(x, y, width, height, ptx, pty):
         return x < ptx < x + width and y < pty < y + height
         
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Canvas sınıfının create_polygon isimli metodu bir demet listesini parametre olarak alır. Oradaki noktaları birleştirir. 
    Son nokta ile ilk noktayı da birleştirerek kapalı bir şekil elde eder.     
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)
        
        self.canvas.create_polygon([(10, 10), (200, 100), (50, 90)], fill='red', outline='black')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Canvas sınıfının create_rectangle metodu dikdörtgen, create_oval metodu da bir dikdörtgenin iç teğet elipsini çizmektedir. 
    Genel olarak bu metotların fill parametreleri iç bölgeyi boyamak için kullanılan rengi, outline metodu ise dış çizgi
    rengini belitmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()

        self.geometry('800x600')
        
        self.canvas = tk.Canvas(self, bg='yellow')
        self.canvas.pack(fill='both', expand=True)
        
        self.canvas.create_rectangle(100, 100, 200, 200, fill='red', outline='black')
        self.canvas.create_oval(100, 100, 200, 200, outline='blue')   
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tkinter.ttk alt paketinde bir grup modern görünüşlü GUI elemanı bulunmaktadır. Bu GUI elemanlarına "ttk GUI elemanları (ttk widgets)"
    denilmektedir. Buradaki GUI elemanlarının bir bölümü tk paketindeki GUI elemanlarına çok benzerdir. Ancak diğer bölümü tk paketinde
    olmayan GUI elemanlarından oluşmaktadır. ttk paketindeki GUI elemanlarının foreground, background, font gibi seçenekleri yoktur. Bu işlemler
    Style denilen bir yöntem ile gerçekleştirilmektedir.    

    Aşağıdaki örnekte ttk.Button GUI elemanı oluştrulmuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')

        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.pack()
        self.button_ok = ttk.Button(self, text='Cancel', command=self.button_cancel_handler)
        self.button_ok.pack()
         
    def button_ok_handler(self):
        print('Ok')
        
    def button_cancel_handler(self):
        print('Cancel')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Entry GUI elemanı tk.Entry GUI elemanına kullanım olarak çok benxemektedir. Ancak foregound, background
    gibi seçenekler Style yoluyla gerçekleştirilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.text_var = tk.StringVar()

        self.entry = ttk.Entry(self, width=30, font='Arial 12', textvariable=self.text_var)        
        self.entry.pack(side='top', anchor='w', padx=10, pady=10)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='top', anchor='w', padx=10, pady=10)
 
    def button_ok_handler(self):
        s = self.text_var.get()
        print(s)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Label GUI elemanı da tk.Label GUI elemanına benzemektedir. Bu elemanda font, foreground ve background seçenekleri de 
    kullanılabilmektedir. Ancak bunlar için "fg" ve "bg" kısaltmaları geçeri değildir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.text_var = tk.StringVar()

        self.label = ttk.Label(self, text='Adı Soyadı', font='Arial 12', foreground='blue')
        self.label.pack(side='top', anchor='w', padx=10, pady=10)
        self.entry = ttk.Entry(self, width=30, font='Arial 12', textvariable=self.text_var)        
        self.entry.pack(side='top', anchor='w', padx=10, pady=10)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='top', anchor='w', padx=10, pady=10)
 
    def button_ok_handler(self):
        s = self.text_var.get()
        print(s)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Checkbutton GUI elemanı da tk.Checkbutton GUI elemanı gibidir. Ancak font, background ve foreground seçenekleri 
    bulunmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.check_button_var = tk.BooleanVar()
        
        self.check_button = ttk.Checkbutton(self, text='E-posta gönderilsin', variable=self.check_button_var)
        self.check_button.pack(side='top', anchor='w', padx=10, pady=10)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='top', anchor='w', padx=10, pady=10)
 
    def button_ok_handler(self):
       print('Checked' if self.check_button_var.get() else 'Unchecked')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Radyo düğmelerinin kullanılması ttk'da tk'dakine benzerdir. Ancak ttk.Radiobutton'da font, background ve foreground 
    gibi bazı seçenekler yoktur. Bu işlemler ttk.Style sınıfı yardımıyla gerçekleştirilmektedir.   
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.radio_button_var = tk.StringVar()
        
        self.radio_button_a = ttk.Radiobutton(self, text='A', variable=self.radio_button_var, value='A')
        self.radio_button_a.pack(side='top', anchor='w', padx=10, pady=5)
        
        self.radio_button_b = ttk.Radiobutton(self, text='B', variable=self.radio_button_var, value='B')
        self.radio_button_b.pack(side='top', anchor='w', padx=10, pady=5)
        
        self.radio_button_c = ttk.Radiobutton(self, text='C', variable=self.radio_button_var, value='C')
        self.radio_button_c.pack(side='top', anchor='w', padx=10, pady=5)
        
        self.radio_button_d = ttk.Radiobutton(self, text='D', variable=self.radio_button_var, value='D')
        self.radio_button_d.pack(side='top', anchor='w', padx=10, pady=5)
        
        self.radio_button_e = ttk.Radiobutton(self, text='E', variable=self.radio_button_var, value='E')
        self.radio_button_e.pack(side='top', anchor='w', padx=10, pady=5)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='top', anchor='w', padx=10, pady=10)
        
    def button_ok_handler(self):
       result = self.radio_button_var.get()
       print(f'{result} selected')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Combobox combobox GUI elemanını oluşturmak için kullanılmaktadır. Combobox içerisindeki yazılar "values" isimli
    seçenek ile oluşturulur. Bu seçenek bir demet biçimindedir. Combobox'ın edit alanındaki yazı sınıfın get metoduyla elde 
    edilmektedir. Combobox'ın edit alanı default durumda değiştirilebilir biçimdedir. Bu edit alanının değiştirilebilir olması
    istenmiyorsa state='readonly' kullanılmalıdır. Sınıfın height elemanı en fazla kaç satır içerik gösterileceğii belirtmektedir. 
    Combobox'tan bir eleman seçildiğinde '<<ComboboxSelected>>' isimli bu GUI elemanına özgü bir event (virtual event) tetiklenmektedir. wrap
    seçeneği sona ya da başa gelindiğinde yeniden başa ya da sona dönülüp dönülmeyeceğini belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        cities = ('Ankara', 'Adana', 'İzmir', 'Eskişehir', 'Gaziantep', 'Urfa', 'Trabzon')
        
        self.combobox = ttk.Combobox(self, values=cities, height=10, state='readonly')
        self.combobox.pack(side='left', anchor='n', padx=10, pady=10)
        
        self.combobox['values'] += ('İstanbul', 'Kayseri')
        
        self.combobox.current(3)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='left', anchor='n', padx=10, pady=10)
        
    def button_ok_handler(self):
       s = self.combobox.get()
       print(s)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Spinbox yukarı aşağı sayacı biçimindeki GUI elemanlara deniilmektedir. Hem tk paketinde hem de ttk paketinde Spinbox
    GUI elemanı bulumaktadır. Gösterilecek değerlerin skalası from_ ve to seçenekleriyle belirlenmektedir. incremenet seçeneği
    artım azaltım miktarını belirtir. wrap seçeneği sona ya da başa gelindiğinde yeniden başa ya da sona dönülüp dönülmeyeceğini belirtmektedir. 
    Spinbox yine edit edilebilir olmaktan state='readonly' seçeneği ile çıkartılabilir. get metodu spinbox içerisindeki değeri string olarak 
    almaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.spinbox = ttk.Spinbox(self, from_=1, to=10, width=10, state='readonly', increment=1, wrap=True, font=('', 12))    
        self.spinbox.pack(side='left', anchor='n', padx=10, pady=10)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='left', anchor='n', padx=10, pady=10)
        
    def button_ok_handler(self):
       val = self.spinbox.get()
       print(val)
       print(type(val))
       
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında spinbox yazılardan da oluşturulabilir. Bunun için from_ ve to yerine values seçeneği kullanılır. Spinbox'ta
    başlangıçta görüntülenecek değer set metoduyla ayarlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        categories = ('Çok az', 'Az', 'Orta', 'Çok', 'Çok fazla')
        self.spinbox = ttk.Spinbox(self, values = categories, width=10, state='readonly', increment=1, wrap=True, font=('', 12))    
        self.spinbox.pack(side='left', anchor='n', padx=10, pady=10)
        
        self.spinbox.set('Orta')
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='left', anchor='n', padx=10, pady=10)
        
    def button_ok_handler(self):
       val = self.spinbox.get()
       print(val)
       print(type(val))
       
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tk.Spinbox kullanımı ile ttk.Spinbox kullanımı biribirine çok benzerdir. Bazı küçük farklılıklar için dokğmanlara başvurabilirisniz. 
    (Örneğin tk.Spinbox'ta set metodu yerine setvar metodu kullanılmaktadır.) Genel görüntü olarak ttk.Spinbox, tk.Spinbox'tan
    daha iyidir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        categories = ('Çok az', 'Az', 'Orta', 'Çok', 'Çok fazla')
        self.spinbox = tk.Spinbox(self, values = categories, width=10, state='readonly', increment=1, wrap=True, font=('', 12))    
        self.spinbox.pack(side='left', anchor='n', padx=10, pady=10)
        
        self.spinbox.setvar('Orta')
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)        
        self.button_ok.pack(side='left', anchor='n', padx=10, pady=10)
        
    def button_ok_handler(self):
       val = self.spinbox.get()
       print(val)
       print(type(val))
       
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Progressbar GUI elemanı tipik olarak bir sürecin ne kadarının tamamlandığını görsel biçimde göstermek için kullanılmaktadır. 
    Sınıfın "maximum" isimli seçeneği progressbar'ın son değerini belirtir. "value" seçeneği progressbar'ın ne kadarının doldurulacağını
    belirtmektedir. Buradaki value değeri maximum değeriyle orantılı bir biçimde boyama yapar. 

    Aşağıdaki örnekte henüz görülmemiş olan thread kullanılmıştır. Çünkü progressbarın ilerletilmesi genellikle başka bir thread 
    tarafından yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk
import tkinter.messagebox
import threading

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        

        self.progressbar = ttk.Progressbar(self, maximum=100)
        self.progressbar.pack(side='top', fill='x', anchor='w', padx=10, pady=10)
        
        self.button_start = ttk.Button(self, text='Start', command=self.button_start_handler)        
        self.button_start.pack(side='top', anchor='w', padx=10, pady=10)
        
    def button_start_handler(self):
        self.timer = threading.Timer(0.1, self.timer_handler)
        self.timer.start()
        
    def timer_handler(self):
        if self.progressbar['value'] >= self.progressbar['maximum']:
            tk.messagebox.showinfo('Message', 'Installation completed')
            return
        self.progressbar['value'] += 5
        self.timer = threading.Timer(0.1, self.timer_handler)
        self.timer.start()
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Şiddet ya da miktar ayarlamak çin kullanılan GUI elemanlara genellikle "slider" ya da "trackbar" denilmektedir. 
    Tkinter'da bunun ismi "Scale" biçimindedir. Bir scale nesnesi yine from_ ve to değerleri belirtilerek yaratılır. 
    Yürütecin değeri get metoduyla alınıp set metoduyla set edilebilmektedir. Yine veri bağlama işlemi variable üzerinden
    IntVar ya da DoubleVar türleriyle yapılabilir.

    Aslında Scale hem tk paketinde hem de ttk paketinde bulunmaktadır. Ancak ttkçScale daha modern bir görübtüye sahiptir.  
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.scale_var = tk.DoubleVar(value=20)
        
        self.scale = ttk.Scale(self, from_=0, to=100, variable=self.scale_var)
        self.scale.pack(side='top', fill='x', padx=20, pady=20)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=10)
        
    def button_ok_handler(self):
        value = self.scale.get()
        print(value)
        
        value = self.scale_var.get()
        print(value)
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Scale GUI elemanında yürüteci hareket ettirirken şiddet ayarlaması gerçek zamanlı yapılabilmektedir. Bunun için
    Scale sınıfının command metodu kullanılır. Bu metodun yürütecin o anki konumunu string olarak veren bir parametresi de vardır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('320x200')
        
        self.scale_var = tk.DoubleVar(value=20)
        
        self.scale = ttk.Scale(self, from_=0, to=100, variable=self.scale_var, command=self.scale_motion_handler)
        self.scale.pack(side='top', fill='x', padx=20, pady=20)
        
        self.label = ttk.Label(self, text='20', font=('', 16))
        self.label.pack(side='top', pady=10)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=10)
        
    def button_ok_handler(self):
        value = self.scale.get()
        print(value)
        
        value = self.scale_var.get()
        print(value)
        
    def scale_motion_handler(self, value):
        self.label['text'] = str(int(float(value)))
        
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Notebook isimli GUI elemanına diğer framework'lerde "Tab Control" ya da "Property Sheet" denilmektedir. Bu GUI 
    elemanında tablar tipik olarak Frame pencerelerindne oluşturulur. Bir taba basıldığında o taba ilişkin Frame penceresi 
    aynı alan içerisinde aktif hale getirilir. 

    Aşağıdaki örnekte Spider'daki bir tab kontrolünün benzeri oluşturulmuştur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('640x480')
        
        self.resolution_var = tk.IntVar(value=1)
        
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(side='top', fill='both', expand=True)
        
        self.button_ok = ttk.Button(self, text='Ok', width=10, command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=10)
        
        self.frame_interface = ttk.Frame()
        self.notebook.add(self.frame_interface, text='Interface')
        self.notebook.bind('<<NotebookTabChanged>>', self.notebook_tab_changed_handler)
        
        self.frame_advanced_settings = ttk.Frame()
        self.notebook.add(self.frame_advanced_settings, text='Advanced settings')
                
        self.label_resolution = ttk.Label(self.frame_interface, text='Screen resolution', font='Arial 10 bold')
        self.label_resolution.pack(side='top', anchor='w', padx=10, pady=10)
        
        self.radiobutton_normal = ttk.Radiobutton(self.frame_interface, text='Normal', value=1, variable=self.resolution_var)
        self.radiobutton_enable= ttk.Radiobutton(self.frame_interface, text='Enable', value=2, variable=self.resolution_var)
        
        self.radiobutton_normal.pack(side='top', anchor='w', padx=10)
        self.radiobutton_enable.pack(side='top', anchor='w', padx=10)
        
        self.frame1 = ttk.Frame(self.frame_interface)
        
        self.radiobutton_custom= ttk.Radiobutton(self.frame1, text='Custom', value=3, variable=self.resolution_var, 
                command=lambda: self.entry_dpi.configure(state='normal') )
        self.radiobutton_custom.pack(side='left')
        
        self.entry_dpi = ttk.Entry(self.frame1, width=50, state='disabled')
        self.entry_dpi.pack(side='left', padx=(30,), fill='x', expand=True)
        self.frame1.pack(side='top', anchor='w', padx=10, fill='x')
        
        self.label_general = ttk.Label(self.frame_advanced_settings, text='General', font='Arial 10 bold')
        self.label_general.pack(side='top', anchor='w', padx=10, pady=10)
        
        self.frame2 = ttk.Frame(self.frame_advanced_settings)
        
        self.label_language = ttk.Label(self.frame2, text='Language:')
        self.label_language.grid(row=0, column=0, sticky='w')
        
        self.combobox_language = ttk.Combobox(self.frame2, values=['Almanca', 'İngilizce', 'Türkçe'], width=10, state='readonly')
        self.combobox_language.grid(row=0, column=1, padx=10)
        self.combobox_language.current(2)
        
        self.label_rendering = ttk.Label(self.frame2, text='Rendering Engine:')
        self.label_rendering.grid(row=1, column=0)
        
        self.combobox_rendering = ttk.Combobox(self.frame2, values=['Software', 'Desktop', 'Automatic'], width=10, state='readonly')
        self.combobox_rendering.grid(row=1, column=1, padx=10, sticky='w', pady=10)
        self.combobox_rendering.current(0)
        
        self.frame2.pack(side='top', anchor='w', padx=10)
        
    def notebook_tab_changed_handler(self, event):
        print('Tab changed')
        
    def button_ok_handler(self):
        self.notebook.select(1)
                
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tk ve ttk paketlerindeki GUI elemanlarının hepsinin cursor isimli bir seçeneği vardır. Bu cursor seçeneği fare o 
    GUI eleman penceresinin üzerine getirildiğinde görüntülenecek fare okunu belirtir. (GUI dünyasında fare okuna "cursor"
    denilmektedir.) cursor seçeneğine atanabilecek cursor ok şekilleri dokümanlarda belirtilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('640x480')
        
        self.button_ok = ttk.Button(self, text='Ok', cursor='pencil')
        self.button_ok.place(x=10, y=10, width=100, height=100)
                   
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
     Tabii bir pencere içerisinde de fare okunu o andaki konuma dayalı olarak değiştirebiliriz. Aşağıdaki örnekte
     fare pencerenin sol bölgesine çekildiğinde ayrı bir fare oku, sağ bölgesine çekildiğinde ayrı bir fare oku gösterilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('640x480')
       
        self.bind('<Motion>', self.motion_handler)
        
    def motion_handler(self, event):
        if event.x < self.winfo_width() / 2:
            self['cursor'] = 'plus'
        else:
            self['cursor'] = 'crosshair'
            
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk.Treeview GUI elemanı hiyerarşik olguları ağaç biçiminde görüntülemek için kullanılmaktadır. Burada ağaca eklenen her 
    düğümün bir id değeri vardır. Eklemanin neyin altına yapılacağı bu id değeri ile belirlenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('800x600')
        
        self.treeview = ttk.Treeview(self)
        self.treeview.pack(side='top', anchor='w', padx=10, pady=10)     
        
        id_department = self.treeview.insert('', index=0, text='Bölümler')
        self.treeview.insert(id_department , index='end', text='İnsan Kaynakları')
        self.treeview.insert(id_department , index='end', text='Kalite Kontrol')
        self.treeview.insert(id_department , index='end', text='Yönetim')
        self.treeview.insert(id_department , index='end', text='İmalat')
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında insert metodunun üçüncü parametresi ile insert edilen düğümün id değeri yazı olarak girilebilmektedir.
    Ancak eğer bir giriş yapılmazsa id değerleri otomatik olarak üretilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Treeview')
        self.geometry('800x600')
        
        self.treeview = ttk.Treeview(self)
        self.treeview.pack(side='top', anchor='w', padx=10, pady=10, fill='both', expand=True)     
        
        id_department = self.treeview.insert('', index=0, text='Bölümler')
        self.treeview.insert(id_department, index='end', text='İnsan Kaynakları')
        self.treeview.insert(id_department, index='end', text='Kalite Kontrol')
        self.treeview.insert(id_department, index='end', text='Yönetim')
        self.treeview.insert(id_department , index='end', iid='id_production', text='İmalat')
        
        self.treeview.insert('id_production', index='end', text='Sabah')
        self.treeview.insert('id_production', index='end', text='Öğle')
        self.treeview.insert('id_production', index='end', text='Akşam')
        
        self.button_ok = ttk.Button(self, text='Ok')
        self.button_ok.pack(side='top', pady=20)
    
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Treeview bir eleman seçildiğinde '<<TreeviewSelect>>' isimli event tetiklenmektedir. O anda seçili elemanlar Treeview sınıfının
    selection isimli metodu çağrılarak elde edilir. Default durumda bird'en fazla eleman seçilebilmektedir. selection metodu bize 
    seçilmiş elemanların id'lerini bir demet dizisi olarka vermektedir. '<<TreeviewOpen>>' bir düğüm açıldığında, '<<TreeviewClose>>' ise
    bir düğüm kapatıldığında tetiklenmektedir. Bir düğümün tüm alt düğümleri Treeview sınıfının get_children metoduyla elde edilebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Treeview')
        self.geometry('800x600')
        
        self.treeview = ttk.Treeview(self)
        self.treeview.pack(side='top', anchor='w', padx=10, pady=10, fill='both', expand=True)     
        
        id_department = self.treeview.insert('', index=0, text='Bölümler')
        self.treeview.insert(id_department, index='end', text='İnsan Kaynakları')
        self.treeview.insert(id_department, index='end', text='Kalite Kontrol')
        self.treeview.insert(id_department, index='end', text='Yönetim')
        self.treeview.insert(id_department , index='end', iid='id_production', text='İmalat')
        
        self.treeview.insert('id_production', index='end', text='Sabah')
        self.treeview.insert('id_production', index='end', text='Öğle')
        self.treeview.insert('id_production', index='end', text='Akşam')
        
        self.treeview.bind('<<TreeviewSelect>>', self.treeview_select_handler)
        self.treeview.bind('<<TreeviewOpen>>', self.treeview_open_handler)
        self.treeview.bind('<<TreeviewClose>>', self.treeview_close_handler)
        
        self.button_ok = ttk.Button(self, text='Ok')
        self.button_ok.pack(side='top', pady=20)
        
    def treeview_select_handler(self, event):
        selected_items = self.treeview.selection()
        print(selected_items)
        
    def treeview_open_handler(self, event): 
        print('Open')
        
    def treeview_close_handler(self, event):
        print('Close')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Seçilen elemanın bilgileri item metouyle elde edilebilmektedir. Örneğin eleman id'si selected_item olmak üzere:

    text = self.treeview.item(selected_item, option='text')

    işlemi ile seçilen elemanın yazısı alınabilmektedir. Benzer biçimde item metodu aslında elemanın bilgilerini değiştirmek için 
    de kullanılabilmektedir. Örneğin:

    self.treeview.item(selected_item, text='xxx')
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Treeview')
        self.geometry('800x600')
        
        self.treeview = ttk.Treeview(self)
        self.treeview.pack(side='top', anchor='w', padx=10, pady=10, fill='both', expand=True)     
        
        id_department = self.treeview.insert('', index=0, text='Bölümler')
        self.treeview.insert(id_department, index='end', text='İnsan Kaynakları')
        self.treeview.insert(id_department, index='end', text='Kalite Kontrol')
        self.treeview.insert(id_department, index='end', text='Yönetim')
        self.treeview.insert(id_department , index='end', iid='id_production', text='İmalat')
        
        self.treeview.insert('id_production', index='end', text='Sabah')
        self.treeview.insert('id_production', index='end', text='Öğle')
        self.treeview.insert('id_production', index='end', text='Akşam')
        
        self.treeview.bind('<<TreeviewSelect>>', self.treeview_select_handler)
        self.treeview.bind('<<TreeviewOpen>>', self.treeview_open_handler)
        self.treeview.bind('<<TreeviewClose>>', self.treeview_close_handler)
        
        self.button_ok = ttk.Button(self, text='Ok')
        self.button_ok.pack(side='top', pady=20)
        
    def treeview_select_handler(self, event):
        selected_item = self.treeview.selection()[0]
        item_text = self.treeview.item(selected_item, option='text')
        print(item_text)
        
    def treeview_open_handler(self, event): 
        print('Open')
        
    def treeview_close_handler(self, event):
        print('Close')
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da treeview GUI elemanı ile listview elemanı birleştirimiştir. Yani treeview yalnızca treeview olarak, listview gibi
    hem treeview hem de listviee gibi kullanılabilmektedir. Treeview GUI elemanının columns isimli seçeneği yataılacak sütunların
    isimlerini bizden bir demet olarak ister. Ana eleman zaten treeview elemanıdır. Sütunlar için değerler insert işleminde values isimli
    parametresi ile oluşturulmaktadır. Benzer biçimde oluşturulan değerler item metodunda optin='text', option='values' 
    değerleriyle geri alınabilmektedir. İstenirse heading metodunda sütun isimleri '#n' (burada n sütunun index numarasıdır) biçiminde de verilebilir. 
    İlk sütuna isim vermek için mecburen '#0' kullanılmaktadır. Treeview sınıfının column isimli metodu ile de sütunların genişlikleri, hizalamaları vs. 
    ayarlanabilmektedir. Ayrıca insert işlemi sırasında tag isimli parametresiyle elemana istenilen bilgiler iliştirilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Treeview')
        self.geometry('800x600')
        
        self.treeview = ttk.Treeview(self, columns=('No', 'Department'))
        self.treeview.pack(side='top', fill='both', expand=True)  
        
        self.treeview.heading('#0', text='Adı Soyadı')
        self.treeview.heading('No', text='No')
        self.treeview.heading('Department', text='Bölüm')
        
        self.treeview.column('No', width=20, anchor='e')
        self.treeview.column('Department', anchor='center')
        
        
        self.treeview.insert('', index='end', text='Ali Serçe', values=('123', 'Üretim'))
        self.treeview.insert('', index='end', text='Sacit Akyol', values=('567', 'İnsan Kaynakları'))
        self.treeview.insert('', index='end', text='Ayşe Er', values=('345', 'İnsan Kaynakları'))
        self.treeview.insert('', index='end', text='Hasan Uslu', values=('983', 'Kalite Kontrol'))
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=20)
        
    def button_ok_handler(self):
        selected_item = self.treeview.selection()[0]
        name = self.treeview.item(selected_item, option='text')
        values = self.treeview.item(selected_item, option='values')
        print(name, values[0], values[1])
              
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Treeview GUI elemanında da maalesef builty-in bir scrollbar yoktur. Dolayısıyla scroll çubuğu için daha Listbox 
    örneğinde yapılanlar yapılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Treeview')
        self.geometry('800x600')
        
        self.frame = ttk.Frame(self)
        self.treeview = ttk.Treeview(self.frame, columns=('No', 'Department'))
        self.treeview.pack(side='left', fill='both', expand=True)  
        
        self.treeview.heading('#0', text='Adı Soyadı')
        self.treeview.heading('No', text='No')
        self.treeview.heading('Department', text='Bölüm')
        
        self.treeview.column('No', width=20, anchor='e')
        self.treeview.column('Department', width=20, anchor='center')
        
        
        self.treeview.insert('', index='end', text='Ali Serçe', values=('123', 'Üretim'))
        self.treeview.insert('', index='end', text='Sacit Akyol', values=('567', 'İnsan Kaynakları'), tag=('Ali', 'Veli', 'Selami'))
        self.treeview.insert('', index='end', text='Ayşe Er', values=('345', 'İnsan Kaynakları'))
        self.treeview.insert('', index='end', text='Hasan Uslu', values=('983', 'Kalite Kontrol'))
        
        for i in range(100):
            self.treeview.insert('', index='end', text=f'{i}')
               
        self.scrollbar = tk.Scrollbar(self.frame, command=self.treeview.yview)
        self.scrollbar.pack(side='left', fill='y')
        self.treeview.configure(yscrollcommand=self.scrollbar.set)  
            
        self.frame.pack(side='top', fill='both', expand=True)
        
        self.button_ok = ttk.Button(self, text='Ok', command=self.button_ok_handler)
        self.button_ok.pack(side='top', pady=20)
        
    def button_ok_handler(self):
        selected_item = self.treeview.selection()[0]
        name = self.treeview.item(selected_item, option='text')
        values = self.treeview.item(selected_item, option='values')
        print(name, values[0], values[1])
        
        tag = self.treeview.item(selected_item, option='tag')
        print(tag)
              
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk GUI elemanlarının yazı renkleri, fontları vs. genel olarak style denilen bir kavramla değiştirilmektedir. Programcı
    ttk.Style sınıfı türünden bir nesne yaratır. Sonra bu nesne ile sınıfın configure metodunu çağırır. Buradaki configure 
    metodunun birinci parametresi hangi ttk GUI elemanının stilinin değiştirileceğine yönelik bir isim almaktadır. GUI elemanlarının
    style isimleri genel olarak sınıf isminin önüne bir T getirilmiş biçimdedir. Örneğin, 'TButton', 'TEntry' gibi. Burada 
    istisna olarak Treeview için bu isim 'TTreeview' değil 'Treeview' biçimindedir. configure metodunun diğer parametreleri 
    ilgili ttk GUI elemanına yönelik stil bilgilerini belirtir. Her GUI elemanın bir stil listesi vardır. Bu liste tkdocs 
    dokümantasyonun öğrenilebilir. Ancak burada önemli bir nokta belli bir GUI elemanın stili değiştirildiğinde artık
    daha sonra yaraılacak aynı türden tüm GUI elemanların aynı stilden olmasıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('480x320')
        
        style = ttk.Style()
        style.configure('TEntry', foreground='red', background='yellow')
        style.configure('TButton', font=('', 16), foreground='red')
        
        self.entry1 = ttk.Entry(self, font=('', 16))
        self.entry1.pack()
        
        self.entry2 = ttk.Entry(self, font=('', 16))
        self.entry2.pack()

        self.button = ttk.Button(self, text='ok')
        self.button.pack()
                      
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aynı sınıftan oluşturulan farklı GUI elemanlarına farklı stiller atayabilmek için programcının bir stil ismi
    uydurması ve o ismi de GUI eleman yaratılırken style parametresinde belirtmesi gerekir. İsim uydurma ilgili GUI 
    elemanın ismi 'TX' olmak üzere 'Name.TX' biçiminde yapılmak zorundadır. Aşağıdaki örnekte farklı ttk.Entry nesnelerinin 
    farklı yazı renkleri olsun diye iki farklı style ismi uydurulmuştur. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('480x320')
        
        style = ttk.Style()
        style.configure('Blue.TEntry', foreground='blue')
        style.configure('Red.TEntry', foreground='red')
        
        self.entry1 = ttk.Entry(self, font=('', 16), style='Blue.TEntry')
        self.entry1.pack()
        
        self.entry2 = ttk.Entry(self, font=('', 16), style='Red.TEntry')
        self.entry2.pack()
        
        self.entry3 = ttk.Entry(self, font=('', 16))
        self.entry3.pack()

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ttk.Combobox GUI elemanının bazı özellikleri Style yoluyla değiştirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('480x320')
        
        style = ttk.Style()
        style.configure('TCombobox', foreground='red', selectforeground='yellow')
       
        self.combobox = ttk.Combobox(self, values=['Ali', 'Veli', 'Selami'], state='readonly')
        self.combobox.pack(pady=10)

root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    PanedWindow ana pencereyi dinamik olarak genişletip daraltmak için kullanılmaktadır. Hem tk hem de ttk paketlerinde 
    buGUI elemanından bulunmaktadır. Burada programcı bir PanedWindow yarattıktan sonra add ya da insert metodu ile pane'leri oluşturur. 
    Tipik olarak iki pane oluşturulmaktadır. Ancak daha fazla pane de oluşturulabilir. PanedWindow nesnesi yaratılırken genişletilme çubuğuna
    handle denilmektedir. Default durumda bu handle görüntülenmez. showhandle=True parametresiyle bu çubuk görüntülenir. handlesize parametresi
    bu çubuğun genişliğini belirlemek için kullanılmaktadır. Programcı tipik olarak önce Frame nesneleri yaratır. Bu frame nesnelerini pane polarak eklenmiştir
    kendi GUI elemanlarını da bu Frame nesnelerinin içerisine yerleştirir. Aşağıdaki örnekte yan yana iki frame pane olarak PanedWindow
    içerisine eklenmiştir. Sonra bu frame'lere Text GUI elemanları da eklenmiştir. Tabii aslında hiç Frame oluşturmadan bu Text GUI elemanları da
    pane olarak eklenebilirdi. Ancak Frame kendi içerisinde pek çok GUI elemanını barındırabildiği için daha genel bir durum oluşturmakttadır. 
    PanedWindow sınıfının add metodunda weight belirtilerek pane'lerin başlangıçta birbirlerine göre genişlikleri belirlenebilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('PanedWindow')
        self.geometry('800x600')
        
        self.panedwindow = tk.PanedWindow(self, orient=tk.HORIZONTAL, showhandle=True, handlesize=10)
        self.panedwindow.pack(fill='both', expand=True)
        
        self.frame_left = tk.Frame(self.panedwindow)
        self.frame_right = tk.Frame(self.panedwindow)
     
        self.panedwindow.add(self.frame_left, minsize=100, weight=1)
        self.panedwindow.add(self.frame_right, minsize=100, weight=1)
        
        self.text_left = tk.Text(self.frame_left, font=('', 18), foreground='red')
        self.text_left.pack(side='top', fill='both', expand=True)
        
        self.button_ok_left = tk.Button(self.frame_left, text='Ok')
        self.button_ok_left.pack(pady=10)
        
        self.text_right = tk.Text(self.frame_right, font=('', 18), foreground='blue')
        self.text_right.pack(side='top', fill='both', expand=True)
        
        self.button_ok_right = tk.Button(self.frame_right, text='Ok')
        self.button_ok_right.pack(pady=10)
        
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki uygulamanın aynısı ttk kullanılarak aşağıdaki oluşturulabilir. ttk.PanedWindow için bazı özellikler style biçiminde
    belirlenmektedir. Ayrıca her style özelliği de her ttk temasında bulunmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('PanedWindow')
        self.geometry('800x600')
        
        self.panedwindow = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        self.panedwindow.pack(fill='both', expand=True)
        
        self.frame_left = ttk.Frame(self.panedwindow)
        self.frame_right = ttk.Frame(self.panedwindow)
     
        self.panedwindow.add(self.frame_left, weight=1)
        self.panedwindow.add(self.frame_right, weight=1s)
        
        self.text_left = tk.Text(self.frame_left, font=('', 18), foreground='red')
        self.text_left.pack(side='top', fill='both', expand=True)
        
        self.button_ok_left = ttk.Button(self.frame_left, text='Ok')
        self.button_ok_left.pack(pady=10)
        
        self.text_right = tk.Text(self.frame_right, font=('', 18), foreground='blue')
        self.text_right.pack(side='top', fill='both', expand=True)
        
        self.button_ok_right = ttk.Button(self.frame_right, text='Ok')
        self.button_ok_right.pack(pady=10)
        
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    ttk themed tk anlamına gelmektedir. Çalıştığımız işletim sisteminde GUI elemanların görüntülenme biçimi üzerinde etkili olan
    temalar vardır. Biz tema değiştirsek aslında bu görüntü biçimlerini bir takım olarak değiştirmiş oluruz. Çalıştığımız sistemdeki 
    temalar ttk.Style sınıfının theme_names isimli metoduyla elde edilebilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.geometry('800x600')
        
        style = ttk.Style()
        print(style.theme_names())
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir temayı aktif hale getirdiğimizde o anda yaratılmış ve yaratılacak olan tüm GUI elemanlarının görüntüsü o temadan olacak 
    biçimde değişecektir. Tema değiştirmekl için style nesnesi ile use_theme metodu çağrılır. Aşağıdaki örnekte tüm temalar
    radyo düğmesi olarak oluşturulmuş ve bu düğmeler yoluyla değiştirilmiştir. Default tema use_themes metodunda ilk bulunan temadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk
from tkinter import ttk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.geometry('800x600')
        
        self.radio_var = tk.StringVar()
        
        self.style = ttk.Style()
        
        self.frame = ttk.Frame(self)
        tnames = self.style.theme_names()
        for i, name in enumerate(tnames):
            radio = ttk.Radiobutton(self.frame, text=name, command=self.radio_handler, value=name, variable=self.radio_var)
            radio.grid(row=i, column=0, sticky='w')
            
        self.frame.pack(side='left')
        
        self.button_ok = ttk.Button(self, text='Ok', width = 10)
        self.button_ok.pack(side='left', padx=20)
        
        self.entry = ttk.Entry(self, width = 20)
        self.entry.pack(side='left', padx=20)
        
        self.radio_var.set(tnames[0])
        
    def radio_handler(self):
        self.style.theme_use(self.radio_var.get())
        
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    tk.Tk sınıfı hem programın ana penceresini hem de uygulamanın kendisini temsil etmektedir. Ancak bir uygulamada birden fazla
    birbirinden bağımsız ana pencere de olabilir. Ana pencereler tk.Toplevel isimli sınıf ile temsil edilmektedir. Programcı ne zaman 
    bu sınıf türünden nesne yaratsa yeni bir ana pencere oluşturmuş olur. Toplevel sınıfın pek çok elemanı (title gibi, geometry gibi)
    tk.Tk sınıfı ile aynıdır. Aşağıdaki örnekte menüden her seçim yapıldığında yeni bir ana pencere oluşturulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Main Application Window')
        self.geometry('800x600')
        
        self.count = 1
        
        self.menu_bar = tk.Menu(self)
       
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Open Toplevel',              command=self.open_toplevel_handler)
 
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self['menu'] = self.menu_bar
        
    def open_toplevel_handler(self):
         toplevel = tk.Toplevel()
         toplevel.title(f'Toplevel Window {self.count}')
         toplevel.geometry('800x600')
         self.count += 1
               
root = Root()
root.mainloop()

#------------------------------------------------------------------------------------------------------------------------------------
    Tkinter'da modal dialog penceresi oluşturmak biraz zahmetlidir. Dialog penceresinin kapatılmasının beklenmesi için 
    wait_window metodu kullanılır. Aynı zamanda dialog penceresinde aşağıdaki metotlar çağrılmalıdır:

    self.master = master
    self.transient(master)
    self.grab_set()

    Burada master dialog penceresinin üst penceresini temsil etmektedir. Dialog penceresi kapatıldığında maaleset GUI elemanlarındaki bilgiler
    yerinde kalmaz. O halde pencere kapatılmadan önce GUI elemanlarındaki bilgilerin dialog pencere sınıfının örnek özniteliklerinde saklanması 
    uygun olur. Yine Tkinter'da dialog penceresinden hangi tuşla çıkıldığını belirlemenin pratik bir yolu yoktur. Programcının da bunu sınıfın bir örnek
    özniteliğinde oluşturması gerekir. 
#------------------------------------------------------------------------------------------------------------------------------------

import tkinter as tk

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title('Main Application Window')
        self.geometry('800x600')
        
        self.menu_bar = tk.Menu(self)
        self.file_popup = tk.Menu(tearoff=0)
        self.file_popup.add_command(label='Modal Dialog', command=self.modal_dialog_handler, accelerator='Ctrl+M')
        self.menu_bar.add_cascade(label='File', menu=self.file_popup)
        self['menu'] = self.menu_bar
        
        self.bind('<Control-m>', self.modal_dialog_handler)   
        
    def modal_dialog_handler(self, event=None):
         mydialog = MyDialog(self)
         mydialog.title('My Dialog')
         self.wait_window(mydialog)
         
         if mydialog.reason == 'Ok':
             print(mydialog.name)
             print(mydialog.no)
             print(mydialog.check_stat)
         else:
             print('Cancel')
    
class MyDialog(tk.Toplevel):
    def __init__(self, master):
        super().__init__()
        self.master = master
        self.resizable(width=False, height=False)
        self.transient(master)
        self.grab_set()
        self.reason='Cancel'
        
        self.entry_name_var = tk.StringVar()
        self.entry_no_var = tk.StringVar()
        self.check_button_var = tk.BooleanVar()
        
        self.label_name = tk.Label(self, text='Adı Soyadı')
        self.label_name.grid(row=0, column=0, pady=(10, 5), padx=(10, 5), sticky='w')

        self.entry_name = tk.Entry(self, width=30, textvariable=self.entry_name_var)
        self.entry_name.grid(row=0, column=1, pady=(10, 5))

        self.label_no = tk.Label(self, text='No')
        self.label_no.grid(row=1, column=0, padx=(10, 5), sticky='w')

        self.entry_no = tk.Entry(self, width=30, textvariable=self.entry_no_var)
        self.entry_no.grid(row=1, column=1)

        self.check_button = tk.Checkbutton(self, text='E-Posta', variable=self.check_button_var)
        self.check_button.grid(row=2, column=0, columnspan=2, sticky='w', padx=10, pady=10)

        img = tk.PhotoImage(file='person.png')

        self.label_image = tk.Label(self, image=img)
        self.label_image.grid(row=0, column=2, columnspan=2, rowspan=2, sticky='wens')

        self.label_image.image = img

        self.button_ok = tk.Button(self, text='Ok', width=10, command=self.button_ok_handler)
        self.button_ok.grid(row=2, column=2, stick='w', padx=(0, 7))

        self.button_cancel = tk.Button(self, text='Cancel', width=10, command=self.button_cancel_handler)
        self.button_cancel.grid(row=2, column=3, sticky='w', padx=(0, 10))
        
    def button_ok_handler(self):
        self.name = self.entry_name_var.get()
        self.no = self.entry_no_var.get()
        self.check_stat = self.check_button_var.get()

        self.reason = 'Ok'
        self.destroy()
    
    def button_cancel_handler(self):
        self.reason='Cancel'
        self.destroy()
             
root = Root()
root.mainloop()
