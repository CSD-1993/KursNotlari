/*--------------------------------------------------------------------------------------------------------------------------

                                                C ve Sistem Programcıları Derneği

                                    Rust Programlama Dili Kursunda Yapılan Örnekler ve Özet Notlar

                                                    Eğitmen: Kaan ASLAN

		Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                                Son Güncelleme: 22/05/2025 - Perşembe

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            1. Ders 24/02/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurs katılımcıları ile tanışıldı.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzda önce Rust'ın nasıl bir programlama dili olduğunu açıklyacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust genel amaçlı, yapısal, prosedürel ve fonksiyonel programlama modellerini destekleyen çok modelli (multi paradigm),
    statik tür sistemine sahip modern bir programlama dilidir. Tasarımında özellikle eşzamanlı (concurrent) programlama 
    etkinliklerinin daha güvenli biçimde sağlanması ön planda tutulmuştur. Bunun sağlanabilmesi için de bellek erişim güvenliğine 
    (memory safety) özel bir önem verilmiştir.
    
    Rust bir sistem programlama dili olarak kullanılabilecek biçimde tasarlanmıştır. Bu nedenle C Programlama Diline ve kısmen 
    de C++ Programlama Diline yenilikçi bir seçenek oluşturmaktadır. Rust C Programlama Dilinden biraz daha yüksek seviyeli 
    bir dildir. Birtakım modern özellikler performans kaybına yol açmayacak biçimde dile entegre edilmiştir.

    Rust nesne yönelimli ya da nesne tabanlı bir programlama dili değildir. Ancak nesne yönelimli programlama tekniğindeki 
    bazı prensiplerin uygulanabileceği bir tasarım özelliğine sahiptir.

    Rust çeşitli programlama dillerinden ilham alınarak tasarlanmıştır. Rust'ı etkileyen programlama dilleri şunlardır:

    - C/C++
    - ML / OCaml
    - Erlang
    - Scheme
    - Haskell 
    - Go
    - Swift 
    - Kotlin
    - Python

    Rust'ın temel bir kütüphanesi vardır. Ayrıca zamanla kendine özgü bir ekosistem de oluşmuştur. Bu ekosistemde Rust 
    programcıları kendi çalışmalarını başkalarıyla paylaşmaktadır. Dolayısıyla daha spesifik gereksinimler için "crates.io"
    deposu içerisindeki üçüncü parti kütüphanelerden faydalanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                         2. Ders 26/02/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust nispeten yeni bir programlama dilidir. Dolayısıyla kısa bir tarihi vardır. 
    
    Rust'ın tasarımına 2006 yılında Mozilla şirketi çalışanı olan "Graydon Hoare" ("Greydın Ho:r" biçiminde okunuyor) tarafından 
    başlanmıştır. Hoare bu çalışmaları 2009'a kadar tek başına ve ancak boş zamanlarında yürütmüştür. Hoare 2009 yılından itibaren 
    yaptığı çalışmaları Mozilla'daki çalışma arakadaşlarıyla paylaşmaya başlamıştır. İlk Rust derleyicisi de deneysel amaçla 
    OCaml Dili kullanılarak yazılmıştır. Mozilla 2009 yılında Rust projesine sponsor olmaya başlamıştır. Rust derleyicisi 2010 
    yılında LLVM kullanan Rust derleyicisi ile yeniden yazılmıştır. (Bir derleyicinin kendisiyle derlenmesine İngilizce "self 
    hosting compiler" denilmektedir.) Rust'ın ilk resmi sürümü (0.1 versiyonu) 2012 yılında herkesin kullanımına sunulmuştur. 
    Bu yıllarda Rust projesine Mozilla dışında pek çok gönüllü de katılmaya başlamıştır. Mozilla tam zamanlı çalışmak üzere çeşitli 
    geliştiricileri de işe almıştır. Rust 2012 yılından sonra sürekli iyileştirilmeye çalışılmıştır. Graydon Hoare 2013 yılında 
    Rust'ın geliştirilme sürecinde kendini geri plana çekmiştir. Dil üzerindeki pek çok değişiklikten sonra 2015 yılında Rust'ın 
    1.0 versiyonu kullanıma sunulmuştur. Bu süreçte Rust topluluğu da gitgide büyümüştür. 

    Rust'ın ilk versiyonu çıktıktan sonra Mozilla dışında Facebook (Meta), DropBox, Amazon gibi şirketler de Rust'a ilgi göstermeye 
    başlamıştır. University of Minho, NOVA University Lisbon, ve University of Coimbra yaptığı araştımalara göre Rust Java'dan 
    iki kat daha az elektrik harcamaktadır. Ancak C ile kıyaslandığında C'den biraz daha fazla elektrik harcamaktadır. 

    Mozilla 2020 yılında Covid salgınının da etkisiyle Rust projesinden çekilme kararı almıştır. Böylece sponsorluk bağlamında 
    işe aldığı kişileri de işten çıkarmıştır. 2021 yılında Amazon Web Services, Google, Huawei, Microsoft, Mozilla şirketlerinin 
    desteğiyle "Rust Foundation" isimli bir kurum oluşturulmuştur. 2021'de Google Andorid'te Rust'ın da kullanılacağını
    belirtmiştir. 2024'te Beyaz Saray Rust'ın kullanılmasını teşvik eden 19 sayfalık bir doküman yayınlamıştır. Her ne kadar 
    Beyaz Saray'ın bu konuyla doğrudan bir ilgisi yoksa da bu rapor Rust'ın geleceği konusunda iyimser bir hava estirmiştir. 

    Rust'ın geliştirilmesine halen "Rust Foundation" kurumu tarafından devam edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ın versiyonlarının tarihsel gelişimi şöyledir:
    
    2006: Rust geliştirilmesine başlandı.
    2009: Mozilla, Rust projesini desteklemeye başladı.
    2010: İlk bootstrap (ön-yükleme) derleyicisi yayımlandı.
    2012: Rust’un kendini derleyen (self-hosted) derleyicisinin alfa sürümleri (örneğin, 0.3 alfa) yayımlandı.
    Mayıs 2015: Rust 1.0 stabil sürümü piyasaya sürüldü; dil, artık üretim ortamında kullanılmaya hazır hale geldi.
    Temmuz 2016: 1.10 sürümü piyasaya sürüldü.
    Ağusatos 2017: 1.20 sürümü piyasaya sürüldü
    Ekim 2018: 1.30 sürümü piyasaya sürüldü.
    Aralık 2019: 1.40 sürümü piyasaya sürüldü.
    Şubat 2021: 1.50 sürümü piyasaya sürüldü.
    Nisan 2022: 1.60 sürümü piyasaya sürüldü.
    Temmuz 2023: 1.70 sürümü piyasaya sürüldü.
    Temmuz 2024: 1.80 sürümü piyasaya sürüldü.

    Kursun başladığı sırada en son stabil versiyonu 1.85'tir ve Ocak 2025'te piyasaya sürülmüştür.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust Foundation Rust Programlama Dilinin geliştirilmesinden ve sürüdümünde sorumludur. Resmi sitesine aşağıdaki bağlantıdan 
    erişilebilir:
    
    https://www.rust-lang.org
    
    Rust'ın üç önemli dokümanı vardır. 

    1) The Rust Reference (https://doc.rust-lang.org/reference/index.html)
    2) The Rust Standard Library (https://doc.rust-lang.org/std/index.html)
    3) The Rustonomicon (https://doc.rust-lang.org/nomicon/index.html)

    "The Rust Reference" dokümanı programlama dilinin resmi (formal) açıklamasını içermektedir. Yani bu doküman adeta Rust 
    Programalama Dilinin standart dokümanı gibi düşünülmelidir. Ancak bu tür referans dokümanlarını oluşturmak kolay değildir. 
    Dolayısıyla kursun yapıldığı tarihlerde bu dokümanda boşluklar da vardır. "The Rust Standard Library" dokümanları Rust'ın 
    standart  kütüphanesini açıklamaktadır. "The Rustonomicon" dokğmanları ise Rust'ta unsafe özellikler ve unsafe kodların 
    oluşturulmasına ilişkin bilgiler içermektedir. Ayrıca Rust'ın resmi sitesinde "tutorial" biçiminde "The Rust Programming 
    Language" isimli bir kitap da bulunmaktadır. Bu kitap aynı zamanda basılı biçimde de kitapçılarda satılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şüphesiz Rust'ı öğrenirken ilk yapılması gereken şey Rust derleyicisinin ve gerekli birtakım araçların bilgisayara 
    yüklenmesidir. Bu işlem "rustup" isimli program tarafından yapılmaktadır. Bu rustup programı güncelleme amacıyla da 
    kullanılmaktadır. Windows sistemlerinde bu "rustup" gerçekten çalıştırılabilir (executable) bir programdır. Unix/Linux 
    sistemlerinde ve macOS sistemlerinde kurulum işlemi "sh.rustup.rs" bir shell script tarafından yapılmaktadır. Bu sistemlerde
    tek yapılacak şey aşağıdaki komutu komut satırına yazıp ENTER tuşuna basmaktır:

    $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

    rustup bir konsol programı gibi çalışmaktadır. Program çalıştırıldığında bir seçenek menüsü çıkartır. Kurulumu kendisi yapar. 
    Bu kurulum yapıldığında PATH çevre değişkeni otomatik olarak güncellenmektedir. Dolayısıyla bir terminal açıldığında 
    rust derleyicisi ve cargo gibi araçlar çalıştırılabilmektedir. Kurulum için aşağıdaki bağlantıyı kullanabilirsiniz:

    https://www.rust-lang.org/tools/install
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de "Hello world" programının nasıl derlenerek çalıştırılacağını görelim. Rust'ın derleyicisi diğer derleyicilerde 
    olduğu gibi bir konsol uygulaması biçiminde yazılmıştır. Derleyici programın ismi "rustc" biçimindedir. Bunun için önce
    herangi bir editörde "Hello world" programı yazılır ve dosya uzantısı ".rs" olacak biçimde save edilir. Rust kaynak 
    dosyalarının doğal uzantıları ".rs" biçimindedir. Aşağıdaki programı herhangi bir text editörde yazarak "sample.rs" biçiminde 
    save edelim:
    
    fn main() {
        println!("Hello world");
    }

    Rust kaynak dosyalarının UNICODE UTF-8 kodlamasıyla oluşturulmuş olması gerekmektedir. Yani Rust derleyicisi kaynak kodun 
    bu kodlama biçimine sahip olduğunu varsaymaktadır.

    Derleme oldukça basittir. Derlenecek program dosyası rustc derleyicisine komut satırı argümanı olarak verilir:

    rustc sample.rs

    Bu işlemle önce kaynak dosya derlenecek sonra link edilerek çalıştırılabilen dosya oluşturulacaktır. Windows sistemlerinde 
    komut satırında doprundan dosya ismini yazarak programı çalıştırabilirsiniz. UNIX/linux ve macOS sistemlerinde çalıştırma
    aşağıdaki gibi yapılmalıdır:

    $ ./sample

    Rust'ı Windows'a yüklediğimizde rustc default durumda link işlemi için Microsoft'un "link.exe" programını kullanmaktadır. 
    Dolayısıyla Windows sistemlerinde MSVC araçlarının yüklü olması gerekir. Kurulum sırasında "rustup" programı bu 
    kontrolü yapmakta ve eğer MSVC aracı yoksa bunu kullanıcya sorarak yüklemektedir. Ancak Windows sistemlerinde "GNU Araç 
    Zinciriyle (GNU Toolchain)" çalışılabilmektedir. 

    Tıpkı gcc ve clang derleyicilerinde olduğu gibi rustc derleyicisi de link işleminden sonra "amaç dosyayı (object file)"
    silmektedir. Dolayısıyla rustc programını çalıştırdıktan sonra bir amaç dosya göremezseniz şaşırmayınız. 

    Link işlemini yapmadan yalnızca amaç dosya oluşturmak için "--emit=obj" seçeneği kullanılmaktadır. Örneğin:

    rustc --emit=obj sample.rs

    Bu işlemle "sample.o" isminde bir amaç dosya oluşturulacaktır. Ancak link işlemi yapılmayacaktır.

    Tıpkı gcc ve clang derleyeicilerinde olduğu gibi "-o <hedef_dosya_ismi>" seçeneği ile hedef dosyaya istenilen bir isim 
    verilebilmektedir. Örneğin:

    rustc -o project.exe sample.rs

    Burada artık Winodws'ta çalıştırılabilen dosya "sample.exe" isminde değil "project.exe" isminde olacaktır. Tabii UNIX/Linux 
    ve macOS sistemlerinde çalıştırılabilen dosyaların belli bir uzantısı yoktur. Aynı işlem bu sistemlerde şöyle yapılabilir:

    rustc -o project sample.rs
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                3. Ders 03/03/2025 - Pazartesi 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Rust programcıları kaynak dosyaları komut satırından doğrudan "rustc" derleyicisi ile derlemek yerine genellikle 
    "cargo" isimli bir programla  derleme işlemini yaparlar. cargo hem bir paket yöneticisi hem de bir build otomasyon aracıdır. 
    Yani cargo programı hem depolardan çeşitli kütüphaneleri (crates) indirip projeye dahil edebilmekte hem de birden fazla 
    kaynak dosyayı derleyerek link işlemini yapabilmektedir. Rust paket olarak yüklendiğinde zaten cargo aracı da bilgisayarınıza 
    yüklenmiş olacaktır. Biz kurusumuzda cargo programının ayrıntılı kullanımını ileride ele alacağız. Ancak burada bu 
    programın bir proje (paket) oluşturup onu derlemek ve çalıştırmak için yalın bir biçimde nasıl kullanılacağını göreceğiz. 

    Rust dünyasında çalıştırılabilir bir dosya ya da bir kütüphane dosyası elde etmek için oluşturulmuş olan bir ya da birden 
    fazla Rust kaynak dosyasına "crate" denilmektedir. Crate "derlendiğinde çalıştırılabilir dosya elde edilecek olan bir ya da 
    birden Rust kaynak dosyasını" belirtebileceği gibi "derlendiğinde bir kütüphane oluşturan bir ya da birden fazla Rust kaynak 
    dosyasını" da belirtebilmektedir. Crate kavramı diğer programlama ortamlarındaki "proje" kavramına benzemektedr. Örneğin 
    biz C++'ta çalışırken bir proje yaratıp o projenin içerisine birden fazla kaynak dosya yerleştirip projeyi build edebiliriz. 
    İşte aynı biçimde Rust dünyasında da bir crate'in içerisinde birden fazla kaynak dosya bulunabilmektedir. Rust dünyasında 
    "paket (package)" crate'leri tutan mantıksal bir kap gibidir. Bir pakette birden fazla crate olabilir. Örneğin "Visual Studio"
    IDE'sinde projeleri tutan mantıksal kaba "çözüm (solution)" denilmektedir. Rust'taki paket Visual Studio'daki çözüm kavramına
    benzetilebilir. Paket sözcüğü aslında diğer başka programlama dillerinde de benzer anlamda kullanılabilmektedir. Örneğin 
    Python dünyasında paket denildiğinde bir grup modül anlaşılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    cargo ile yeni bir paket (proje de diyebiliriz) oluşturmak için "cargo new" komutu kullanılmaktadır. Komutun genel 
    biçimi şöyledir:

    cargo new <paket_ismi>
    
    Bu işlemden sonra ismi paket_ismi olan bir dizin yaratılır. Yaratılan dizinin içeriği şöyle olacaktır:

    23.11.2022  13:50    <DIR>          .
    23.11.2022  13:50    <DIR>          ..
    23.11.2022  13:50                 8 .gitignore
    23.11.2022  13:50               175 Cargo.toml
    23.11.2022  13:50    <DIR>          src
                2 File(s)            183 bytes
                3 Dir(s)  679.902.699.520 bytes free

    Buradaki "Cargo.toml" dosyası paketin ana yönetim dosyasıdır. Pakete ilişkin öğelerle ilgili bilgiler bu dosyada tutulmaktadır.
    Yeni yaratılmış olan minimal bir projede bu dosyanın içeriği aşağıdaki gibi çok küçüktür:

    [package]
    name = "myproject"
    version = "0.1.0"
    edition = "2021"

    [dependencies]

    "src" dizininin altında "main.rs" isminde aşağıdaki gibi bir "Hello World" programı oluşturulmaktadır:

    fn main() {
        println!("Hello, world!");
    }

    Burada paketin ana crate'i bu "main.rs" dosyasındna oluşan binary bir crate'tir. Aslında paket yaratımı sırasında "--bin" 
    ya da "--lib" seçenekleri de kullanılabilmektedir. Bu durumda çalıştırılabilir ya da kütüphane projeleri oluşturulmaktadır. 
    Default durum eskiden "--lib" biçimindeydi ancak sonraları sürümlerde "--bin" haline getirildi. 

    Projeyi built etmek için proje dizinine geçilip "cargo build" komutu uygulanır. Örneğin:

    cargo build

    Build işleminden sonra "target" isimli bir dizin ve onun içerisinde de "debug" isimli bir dizin oluşturulacaktır. 
    "cargo build" komutu proje dizininde ya da onun alt dizinlerinde uygulanabilir. Ancak proje dizini dışından uygulanamaz. 
    Build işlemi sonucunda çalıştırılabilen dosya ya da kütüphane dosyası default durumda "target/debug" dizininde paket 
    ismiyle oluşturulacaktır. 

    Build işleminden sonra oluşturulan çalıştırılabilir dosyayı çalıştırmak için doğrudan "cargo run" komutu kullanılabilir. 
    Örneğin:

    cargo run

    Bu komut da proje dizinin de ya da projenin bir alt dizininde uygulanabilmektedir. Tabii pek çok benzer build sisteminde 
    de olduğu gibi sonraki aşama önceki aşamaların yapılmasına da yol açmaktadır. Yani biz "cargo build" komutundan önce
    "cargo run" komutunu kullanırsak zaten önce build işlemi yapılıp sonra oluşturulan çalıştırılabilir dosya çalıştırılacaktır. 

    "cargo build" komutuyla yapılan işlemlerin ortadan kaldırılması için "cargo clean" komutu kullanılmaktadır. Örneğin:

    cargo clean
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yazılım geliştirmekte kullanılan çeşitli araçların bir araya getirilmesiyle oluşturulmuş araçlara IDE (Integrated Development
    Environment) denilmektedir. Yazılım geliştirme sürcinde IDE'ler özellikle bazı dillerde yoğun olarak kullanılmaktadır. 
    Microsoft'un ünlü IDE'sine "Visual Studio" denilmektedir. Apple firmasının da "XCode" isimli bir IDE'si vardır. Bazı IDE'ler
    açık kaynok kodlu biçimde yazılmıştır. Dolayısıya bu IDE'ler aynı zamanda bedavadır. Bazı IDE'ler paralı olsa da bunların 
    parasız versiyonları da oluşturulmuştur. Yine IDE'lerin bazıları "cross platform" özelliğe sahiptir. Yani hem Windows 
    sistemlerinde hem macOS sistemlerinde hem de Linux sistemlerinde aynı arayüz ile kullanılabilmektedir. Belli bir süredir 
    IDE'ler artık bir plugin mimarisi ile tasarlanmaktadır. Böylece IDE'lerin işlevleri üçüncü parti plugin'lerle değiştirilebilmektedir. 
    Bazı IDE'ler yalnızca belli bir programlama dili için oluşturulmuştur. Bazı IDE'ler ise pek çok programlama dilini desteklemektedir. 
    Bazı araçlar tam bir IDE gibi olmasa da IDE'ye benzer özelliklere sahiptir. Bunlar adeta editör ile IDE arasında bir konumda 
    bulunmaktadır. İngilizce bunlara "lightweight IDE (hafif siklet IDE)" de denilmektedir. 

    Rust nispeten yeni bir programlama dili olduğu için Rust IDE'leri ve plugin'leri de yeni yeni geliştirilmeye başlanmıştır. 
    Rust için çok kullanılan IDE'ler ve IDE benzeri editörler şunlardır:

    - VSCode (Cross Platform)
    - RustRover (Cross Platform)
    - Eclipse (Cross Platform)
    - Sublime Text (Linux/macOS)

    Biz kurusumuzda Microsoft'un cross platform editör ile IDE arasındaki VSCode'unu ve JetBrains firmasının nispeten yeni
    olan RustRover IDE'sini kullanacağız. VSCode bedava bir araçtır. RustRover da şimdilik bedavadır. İleride paralı versiyonu 
    oluşturulduğunda muhtemelen bedava versiyonu da devam ettirilecektir. Biz kurusumuzda VSCode için genellikle "editör" 
    terimini kullanacağız. 
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    VSCode editöründe Rust ile çalışmak için pek çok plugin bulunmaktadır. Önemli Rust plugin'leri şunlardır:

    - Rust Analyzer
    - crates
    - Better ToML
    - CodeLLDB
    - cargo

    "Rust Extension Pack" isimli plugin'ler zaten yukarıdaki plugin'lerin çoğunu yüklemektedir. 

    VSCode editöründe program çalıştırmak için bazı JSON dosyaları üzerinde değişiklikler yapmak gerekebilir. Ancak pratik 
    bir biçimde program çalıştırmak için de plugin'ler vardır. "Code Runner" isimli plugin bu amaçla yaygın biçimde kullanılmaktadır. 
    Bu plugin tek bir tuşla (Ctrl+Alt+N) pek çok programlama dilinde yazılmış programı derleyerek çalıştırmaktadır. Biz kursumuzda 
    VSCode'da bu "Code Runner" plugin'ini kullanacağız. 

    Code Runner plugin'i kurulduğunda Rust için derleme default biçimde "rustc" derleyicisi ile yapılmaktadır. Yani "cargo"
    ile yapılmamaktadır. Eğer derleme ve çalıştırmada cargo'yu kullanmak istiyorsanız bunun için "settings.json" dosyasını 
    uygun biçimde güncellemeniz gerekir. VSCode'ta üç önemli JSON dosyası vardır:

    Default Settings JSON dosyası
    User Settings JSON dosyası
    Workspace Settings JSON dosyası

    Belirlemeyi hangi JSON dosyasında yaparsanız yukarıdakileri geçersiz hale getirecektir. Burada "User Settings JSON" 
    dosyasını kullanabilirsiniz. Bu dosyayı edit ederek dosyada "code-runner.executorMap" kısmına gelip "rust" satırında 
    şu değişikliği yapabilrisiniz:

     "code-runner.executorMap": {
        ...
        "rust": "cd $dir && cargo run"
        ...
    }

    Code Runner plugin'inin default "rust" satırı aşağıdaki gibidir:

    "rust": "cd $dir && rustc $fileName && $dir$fileNameWithoutExt"

    Tabii eski duruma dönmek için bu satırı değiştirmek yerine orijinal ismi de değiştirebilirsiniz. İsmini nasıl değiştirdiğinizin
    bir önemi yoktur. Örneğin:

      "code-runner.executorMap": {
        ...
        "rust_old": "cd $dir && rustc $fileName && $dir$fileNameWithoutExt"
        "rust": "cd $dir && cargo run"
        ...
    }

    Şimdi artık "Ctrl+Alt+N" tuşlarına bastığınızda "cargo run" komutu çalıştırılacak dolayısıyla derleme ve çalıştırma 
    cargo tarafından yapılacaktır. Tabii cargo bir paket (proje de diyebiliriz) dizinini kullandığı için sizin daha önce 
    "cargo new" ile yeni bir paket dizini oluşturmuş olmanız gerekir. Bunu oluşturduktan sonra editöre "src" dizini içerisindeki
    "main.rs" dosyasını çekip Ctrl+Alt+N tuşlarına basarsanız programınız cargo ile program sorunsuz derlenip çalıştırılacaktır. 
    Aslında VSCode bir klasörü de "File/Open Folder" menüsü ile açabilmektedir. Dolayısıyla editöre tek bir dosyayı çekmek 
    yerine dizini açıp dosyayı oradan seçmek daha kolay bir kullanım sunacaktır. 

    VSCode'da "Code Runner" ile çalışırken edit ettiğiniz kaynak dosyanın Ctrl+Alt+N tuşlarıyla çalıştırma sırasında save 
    edilmiş olduğuna emin olunuz. Bu tuşlara basmadan önce kaynak dosyanın otomatik save edilmesi "Code Runner" plugin'in 
    kendi ayar menüsünden "Save File Before Run" ile yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------*/
  
/*--------------------------------------------------------------------------------------------------------------------------
                                                4. Ders 05/03/2025 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    RustRover IDE'si ile bir proje (paket) oluşturmak oldukça kolaydır. Bunun için menüden "New Project" seçilir. Proje için 
    bir dizin ismi belirlenir. Zaten RustRover arka planda işlemlerini cargo ile yapmaktadır. Dolayısyla ilgili proje zaten 
    cargo ile yaratılmış olacaktır. Burada tek bir düğmeye tıklamayla (Windows'ta kısa yol tuşu Shift+F10) proje derlenip 
    çalıştırılabilir. 
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yeni bir programama diline başlarken ilk öğrenilmesi gereken şey o programlama dilinin tür sistemidir. Tür (type) nesnelerin
    (ya da değişkenlerin) bellekte ne kadar yer kaplayacağını, onların içerisindeki 1'lerin 0'ların nasıl ele alınacağını, 
    onların hangi operatörlerle işleme sokulabileceğini belirten temel kavramlardan biridir. 

    Programlama dillerinde türler genel olarak "temel türler" ve "bileşik türler" olmak üzere ikiye ayrılmaktadır. Temel türler 
    tekil nesnelerin türlerini belirtmektedir. Bileşik türler ise birden fazla nesnenin bir araya gelmesiyle oluşturulan türleri 
    belirtmektedir. Birden fazla nesnenin bir araya gelmesiyle oluşturulan topluluğa "veri yapısı (data structure)" da denilmektedir. 
    Fakat "temel tür" ve "bileşik tür" kavramları değişik programlama dillerinde değişik biçimde isimlendirilmiştir. Örneğin 
    bazı programlama dillerinde"temel türlere için İngilizce "primitive types" denilmektedir. Temel türler de genellikle 
    programlama dillerinde kendi içerisinde birkaç grubu ayrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    "The Rust Reference" dokümanlarına göre Rust'taki türler şu kategorilerden oluşmaktadır:

    Primitive types:
        Boolean 
        Numeric 
        Textual 
        Never  
    Sequence types:
        Tuple
        Array
        Slice
    User-defined types:
        Struct
        Enum
        Union
    Function types:
        Functions
        Closures
    Pointer types:
        References
        Raw pointers
        Function pointers
    Trait types:
        Trait objects
        Impl trait

    Biz burada önce temel türleri (primitive types) sonra ilerleyen bölümlerde de demet (tuple), dizi (array) ve dilim (slice) 
    gibi dizilim türlerini (sequence types) ve kullanıcı tanımlı türleri göreceğiz. 
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta nümerik türler kendi aralarında tamsayı türleri ve gerçek sayı türleri biçiminde ikiye ayrılmaktadır. Tamsayı 
    türleri de kendi aralarında "işaretli tamsayı türleri", "işaretsiz tamsayı türleri" ve "makine bağımlı tamsayı türleri" 
    olmak üzere üçe ayrılmaktadır. Rust'ta işaretli tamsayılar 2'ye tümleyen artimetiği ile tutulmaktadır. (Halbuki örneğin C 
    ve C++ standartlarında her ne kadar tüm derleyiciler 2'ye tümleyen artimetiğini kullanıyor olsa da işaretli tamsayıların 
    2'ye tümleyen aritmetiği ile tutulacağı konusunda bir garanti verilmemiştir.) Rust'ta tamsayı türlerinin isimleri oldukça 
    kısa bir biçimde oluşturulmuştur. N bit sayısını belirtmek üzere işaretli tamsayı türlerinin isimleri iN biçiminde, işaretsiz 
    tamsayı türlerinin isimleri de uN biçimindedir. Rust'ın tüm tamsayı türlerinin isimleri aşağıda verilmiştir:

    İşaretli Tamsayı Türleri
    ------------------------
    i8
    i16
    i32
    i64
    i128
    
    İşaretsiz Tamsayı Türleri
    -------------------------
    u8
    u16
    u32
    u64
    u128

    Makine Bağımlı Tamsayı Türleri
    ------------------------------
    isize 
    usize

    Anımsanacağı gibi 2'ye tümleyen artimetiğinde N bitlik bir işaretli tamsayının sınır değerleri [-2^N, +2^N - 1] aralığındadır. 
    Rust'ta 128 bitlik tamsayı türünün de olduğuna dikkat ediniz. Henüz 128 bitlik işlemciler kullanılmıyor olsa da bazı durumlarda 
    (özellikle bit işlemlerinde) 128 bitlik tamsayılar daha verimli kod yazımını sağlayabilmektedir. 

    Rust'ta ayrıca çalışılan sisteme bağlı uzunlukta olan isize ve usize isimli iki tamsayı türü de vardır. Bu tamsayı türleri 
    çalışılan sistemdeki teorik bellek büyüklüğüne hizalanmış olan bir uzunluğa sahiptir. Dolayısıyla bu türler 32 bit sistemlerde 
    32 bit (4 byte), 64 bit sistemlerde 64 bit (8 byte) uzuznluğundadır. Bugün artık 16 bit işlemcilerin kullanımı oldukça 
    azalmıştır. Ancak 16 bit işlemcilerin kullanıldığı sistemlerde bu türler 16 bit uzunluğunda olacaktır. "The Rust Reference" 
    dokümanlarına göre bu tür ilgili sistemdeki göstericilerin bit uzunuğu kadar olmak zorundadır. usize türünü C'deki size_t 
    türüne benzetebilirsiniz. C'de de size_t türünün ilgili sistemdeki teorik bellek büyüklüğüne göre typedef edildiğini anımsayınız. 
    Böylece sistem programcısı farklı işlemcilerin kullanıldığı sistemlerde daha taşınabilir kodlar yazabilmektedir. İki adres 
    bilgisini çıkardığımızda sonuç negatif de olabilir pozitif de olabilir İşte isize türü iki adres farkını tutabilen usize 
    türünün işaretli biçimidir. Pek çok işletim sisteminde proseslerin sanal bellek alanları isize büyüklüğündedir. usize ve 
    isize türleri aynı bit uzunluğuna sahiptir. Ayrıca "The Rust Reference" dokümanları bir yapı nesnesinin ya da dizinin bellekte 
    kapladığı alanın en fazla isize kadar olabileceğini söylemektedir. Yukarıda da belirttiğimiz gibi bugün yaygın sistemlerde 
    usize ve isize ya 64 ya da 32 bit uzunluğundadır. Yukarıda da belirttiğimiz gibi 16 bit işlemciler artık çok seyrek 
    kullanılmaktadır. 128 bit işlemciler ise henüz kullanıma girmemiştir. Şimdilik 128 bitlik işlemcilere gereksinim duyulmamaktadır.
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta iki gerçek sayı türü vardır. Bunlar f32 ve f64 türleridir. "The Rust Reference" dokümanlarında bu türlerin IEEE 
    754 formatlarına sahip olduğu belirtilmektedir. Bugün artık matematik işlemciler ve emülasyon araçları hep bu formatı 
    kullanmaktadır. C Pprogramlama Dilinin standartlarında açıkça bu formatın kullanılacağı söylenmemiştir. Oysa Rust'ta bu 
    durum garanti edilmektedir. Rust'ın f32 türü C'nin float türüyle, Rust'ın f64 türü C'nin double türüyle örtüşmektedir. 
    C'de long double isminde bir gerçek sayı türünün daha olduğunu anımsayınız. C'nin long double pek çok derleyicide double 
    türüyle aynı uzunluktadır. (Tabii aslında C'de float türünün 4 byte double türünün 8 olacağının da bir garantisi de 
    yoktur. Ancak yaygn derleyicilerin hepsinde durum böyledir.)
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta pek çok programlama dilinde olduğu gibi true ve false değerlerinin tutulduğu bool isminde bir tür de vardır. 
    Rust'ta bool türünün 1 byte yer kaplayacağı garanti edilmiştir. (C ve C++'ın böyle bir garanti vermediğini anımsayınız.)
    Ayrıca false değerinin bitsel olarak 0 ve true değerinin de bitsel olarak 1 olduğu da "The Rust Reference" dokümanlarında 
    açıkça belirtilmiştir. C ve C++ standartlarında böyle bir belirlemede bulunulmamıştır.
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            5. Ders 10/03/2025 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta iki yazısal tür (textual type) vardır:

    char
    str 

    char türü bir karakterin Unicode UTF-32 kod numarasını (code point) tutmaktadır. Dolayısıyla char türü 4 byte uzunluğundadır.
    Biz char türden bir değişkene tek tırnak içerisine aldığımız bir Unicode karakteri atayabiliriz. Buradaki "Unicode UTF-32" 
    teriminin anlaşılmasını sağlamak için karakter tablolama sistemleri hakkında bazı temel bilgiler üzerinde rumak itiyoruz.

    Karakterlerin bilgisayardaki temsili için oluşturulan tablolara "karakter tabloları (character sets)" denilmektedir. Dünyanın 
    bilgisayar alanında kullanılan ilk karakter tablosu ASCII (American Standard Code Information Interchange) denilen tablodur. 
    Bu tablo 60'ların başlarında tasarlanmaya başlamış ve 1963 yılında ANSI (American National Standard Institute) tarafından 
    standardize edilmiştir. ASCII tablosunun dışında EBCDIC gibi WISCII gibi başka karakter tabloları da geliştirilmiştir. 
    Bunlar arasında en yaygın kullanılanı ASCII tablosu olmuştur. ASCII tablosu 7 bitlik bir tabloydu. Yani 128 karakter içeriyordu. 
    Sonra zamanla 8'inci bit değişik ülkeler tarafından değişik biçimlerde organize edildi ve "code page" varyasyonları ortaya 
    çıkmaya başladı. Örneğin bugün Türkçe için ilk yarısı standart ASCII tablosunun aynısı olan ikinci yarısı değişik düzenlenmiş 
    olan üç farklı code page varyasyonu bulunmaktadır: IBM 857 (eski DOS sistemlerinde kullanılıyordu), Microsoft 1254 (Windows'ta 
    kullanılıyor) ve ISO 8859-9 (ISO standardı, Microsoft 1254'e çok benziyor). Bu karakter tablolarının hepsi temelde 8 bit
    tablolardır. Yani en fazla 256 farklı karakteri barındırabilmektedir. Eskiden belleklerin çok kıt olduğu dönemlerde karakterlerin
    az bitle ifade edilmesi anlamlıydı. Ancak bellekler bollaşınca artık bunun önemi de kalmamıştır. 8 bitlik code page'ler 
    dünyanın tüm dillerini ve çeşitli işaret dillerini temsil edememektedir. Ayrıca farklı dillerdeki yazıların aynı doküman 
    içerisinde tutulduğu durumlarda 8 bitlik code page'ler sorunlara yol açmaktadır. İşte son 30 yıldır her bir karakterin kabaca 
    1 byte ile değil 2 byte ile kodlandığı ismine "Unicode" denilen bir tablo oluşturulmuştur. Unicode tablo zamanla programlama 
    dillerini de etkisi altına almış ve diller de bu tabloyu destekleyecek biçimde evrim geçirmişlerdir. Unicode karakter tablosu 
    ISO tarafından "ISO/IEC 10646" kod numarasıyla da standardize edilmiştir. Unicode tablodaki karakterlerin kod numaraları (code 
    points) için ilk zamanlar 2 byte yeterli oluyordu. Ancak zamanla Unicode'un çeşitli versyionlarında tabloya karakterler eklendi. 
    Bugün Unicode tabloda yaklaşık 150,000 karakter bulunmaktadır. Yani artık Unicode karakterler için 2 byte da yetmemektedir. 

    Karakter tablolarını anlayabilmek için bazı terimlerin anlamlarının bilinemsi gerekir. Bir karakter tablosundaki karakterlerin 
    görüntülerine İngilizce "glyph" denilmektedir. Karakter tablosundaki her karaktere 0'dan başlanarak bir artan sırada bir sayı 
    karşılık getirilir. Karakterin bu sıra numaralarına "kod numarası (code point)" denilmektedir. Örneğin ASCII tablosunda 'a' 
    karakterinin kod numarası 97'dir. Bir karakter tablosundaki kod numaralarının 2'lik sistemde nasıl ifade edileceğine de "karakter 
    kodlaması (character encoding) denilmektedir. 

    Unicode tablonun ilk 128 kod numarasına ilişkin karakterleri standart ASCII karakterleriyle aynıdır. Unicode tablonun 
    128 ile 255 arasındaki kod numaralarına ilişkin karakterler de ASCII Latin-1 (ISO 8859-1) code page'i ile aynıdır. Türkçe
    özel karakterlerin Unicode tablodaki kod numaraları 200'lü ve 300'lü sıralardadır ve bunların sıraları Türk alfabesindeki 
    sıra ile uyumlu değildir. 

    Unicode tablonun üç temel encoding'i bulunmaktadır: UTF-8, UTF-16 ve UTF-32. Unicode'un UTF-8 kodlaması multibyte bir kodlamadır. 
    Bu kodlamada çok kullanılan karakterler az byte ile az kullanılan karakterler çok byte ile kodlanmaktadır. Örneğin standart 
    ASCII karakterlerine ilişkin kod numaralarının hepsi UTF-8 kodlamasında 1 byte ile, Türkçe karakterler 2 byte ile, Japonca 
    ve Çince'deki kanji karakterleri ise 3 byte ile ve çok az kullanılan karakterler de 4 byte ile kodlanmaktadır. Bu nedenle 
    Unicode UTF-8 kodlanmış bir yazının byte sayısına bakarak onun kaç karakter içerdiği anlaşılamaz. Unicode UTF-16 kodlamasında 
    her karakter 2 byte ile kodlanır. Eskiden Unicode tablonun tüm karakterleri böyle 2 byte ile kodlanabiliyordu. Ancak Unicode 
    tablo büyüyünce artık bazı karakterler UTF-16 encoding'inde iki ayrı iki byte ile kodlanmaktadır. Zaten tüm dillerin karakterlerinin 
    kod numaraları 65535 içerisindedir. İşte UTF-32 de her karakterin sabit 4 byte ile kodlandığı encoding'tir. Yukarıda Unicode 
    tablonun ilk 128 karakterinin kod numaraları ile ASCII tablosundaki karakterlerin kod numaralarının aynı olduğunu belirtmiştik. 
    Bu durumda standarT ASCII ile kodlanmış bir yazı ile Unicode UTF-8 kodlanmış bir yazı arasında bir farkın kalmadığına dikkat 
    ediniz. 

    Java ve C# dillerindeki char türü Unicode UTF-16 encoding'ini kullanmaktadır. Zaten bu diller Unicode tablonun daha büyük 
    kod numaralarını doğrudan desteklememektedir. Python'daki CPython  yorumlayıcısı da Unicode UTF-16 encoding'ini kullanmaktadır. 
    C++'a UTF-8, UTF-16 ve UTF-32 desteği C++11 standartları ile, C'ye de C11 standartları ile eklenmiştir. 

    İşte Rust'ta char türü en genel Unicode encoding'i olan UTF-32 encoding'ini kullanmaktadır. Bu nedenle char türü Rust'ta
    4 byte uzunluktadır. 

    Rust'ta str türü iki tırnak içerisindeki string'leri temsil etmektedir. Bu türe Rust'ta "string dilimi (string slice)" 
    de denilmektedir. Ancak bu tür genel olarak referanslı bir biçimde yani &str biçiminde kullanılır. &str türüne ise 
    "string dilimi referansı (string slice reference)" denilmektedir. Biz Rust'ta iki tırnak içerisindeki yazıları str türünden 
    değişkenlere değil &str türünden değişkenlere atayabiliriz. Referans kavramının ve dilim kavramının Rust'ta ne anlam 
    ifade ettiği kursumuzun ilerleyen bölümlerinde ayrıntılarıyla ele alınacaktır.

    Rust'ta iki tırnak içerisindeki yazılar Unicode UTF-8 encoding'iyle tutulmaktadır. Yukarıda da belirttiğimiz gibi Unicode 
    UTF-8 encoding'i ile kodlanmış yazıların karakter uzunlukları yazının kapladığı byte uzunluğuna bakarak anlaşılamamaktadır. 

    Rust'ta iki tırnak içerisindeki yazıların sonunda C'de ve C++'ta olduğu gibi bir null karakter ('\0' karakteri) 
    bulunmamaktadır. Bu nedenle Rust'ya yazının sonu özel bir karakterle değil yazının uzunluğundan hareketle belirlenmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta ! ile temsil edilen ismine "never türü" denilen bir tür de vardır. Bu never türü "akışın o noktadan devam etmeyeceği
    anlamına gelmektedir. Never türü özellikle fonksiyonların geri dönüş değerlerinde kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi Rust'ta değişken tanımlamaları üzerinde duracağız. Rust yeni bir programlama dilidir. Bu nedenle dilin terminolojisi 
    de maalesef tam olarak oturulamamıştır. Bir değişkenin oluşturulmasına yani faaliyet alanına sokulmasına bazı dillerinde 
    "bildirim (declaration)" bazı dillerde "tanımlama (definition)" denilmektedir. Ancak genel olarak Rust bu iki terimi de 
    kullanmamaktadır. Rust programcıları bu terimler yerine "değişkeni bağlamak (variable binding)" terimini tercih etmektedir. 
    "The Rust Reference" dokümanlarında da diğer dillerdeki bildirim ya da tanımlama işlemi için şimdilik açık bir terim 
    kullanılmamıştır. Ancak dokümanların değişik yerlerinde "bağlama" teriminin kullanıldığı görülmektedir. Biz kursumuzda 
    bir değişkenin faaliyet alanına sokulması için "bağlama (binding)" bazen de tanımlama (definition) terimini kullanacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta bir değişkenin faaliyet alanına sokulması (yani bağlanması) let deyimiyle yapılmaktadır. let deyiminin genel 
    biçimi biraz ayrıntılıdır. Biz bu bölümde temel kullanım üzerinde duracağız. 

    Rust'ta bir değişkenin faaliyet alanına sokulması (yani bağlanması) let deyimiyle yapılmaktadır. let deyiminin genel 
    biçimi biraz ayrıntılıdır. Biz bu bölümde temel kullanım üzerinde duracağız. let deyiminin yalın kullanımının genel biçimi 
    şöyledir:

    let <değişken_ismi> [: <tür>] [= <ilkdeğer>];

    Bu yalın genel biçime göre let deyiminin üç temel kullanım biçimi vardır:

    1) let <değişken_ismi>: <tür>;
    2) let <değişken_ismi> = <ilkdeğer>;
    3) let <değişken_ismi>: <tür> = ilkdeğer;

    let deyimi ile bir değişken bağlanırken değişken isminden sonra ':' atomu ve sonra değişkin türü belirtilebilir. Örneğin:

    let a: i32;
    let b: f64;
    let c: bool;

    Eğer bağlanan değişkene ilkdeğer veriliyorsa tür belirtilmeyebilir. Örneğin:

    let a = 10;
    let b = 3.14;
    let c = true;

    Bu durumda değişkenin türü ona verilen ilkdeğerden hareketle tespit edilmektedir. let deyiminde hem tür belirtilebilir 
    hem de değişkene ilkdeğer verilebilir. Örneğin:

    let a: i32 = 10;
    let b: f64 = 3.14;
    let c: bool = true;

    Aşağıdaki bağlama geçersizdir:

    let a;          // geçersiz!

    Çünkü burada a'nın türü belirtilmemiştir ve ilkdeğer de verilmediği için otomatik tespit de yapılamamaktadır. 

    Aslında verilen ilkdeğerden hareketle otomatik tür tespiti pek çok programlama diline sokulmuştur. C'de böyle bir özellik 
    yoktur ancak C++11 ile birlikte C++'a auto anahtar sözcüğü ile bu özellik eklenmiştir. Örneğin:

    auto a = 123;       // 123 int türden olduğu için a da int türden

    Java ve C#'ta da aynı özellik var anahtar sözcüğü ile sağlanmaktadır. Örneğin:

    var a = 10;

    Pek çok programlama dilinde aynı türden birden fazla değişkenin bildirimi tek hamlede yapılabilmektedir. Örneğin C'de 
    aşağıdaki gibi bir bildirim geçerlidir:

    int a = 10, b, c = 20;

    Ancak Rust'taki let deyimi "kalıp uyuşumu (pattern matching)" ile çalışır. Rust'ta bu biçimde tek hamlede bağlama 
    yapılamamaktadır. Örneğin:

    let a = 10, b = 20;         // error!

    Rust'ta bu işlem tipik olarak demet (tuple) kalıbı ile yapılmaktadır. Örneğin:

    let (a, b) = (10, 20);      // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            6. Ders 17/03/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust "büyük harf küçük harf duyarlılığı olan (case sensitive)" bir programlama dilidir. Yani büyük harfler ve küçük 
    harfler farklı karakterler olarak ele alınmaktadır. Rust'ta değişken isimlendirmesinde Unicode tablodaki tüm dillerin
    alfabetik ve nümerik karakterleri kullanılabilmektedir. Örneğin biz bir değişken ismini Türkçe karakterlerden oluşturabiliriz:

    let ağrı_dağının_yüksekliği = 5137;

    Her ne kadar böyle bir serbestlik varsa da diğer pek çok dilde olduğu gibi değişken isimlendirmesinde yoğun olarak İngilizce 
    karakterler tercih edilmektedir. Birden fazla sözcük içeren değişkenlerin harflendirilmesi (capitalization) için Rust'ta 
    genel olarak C'deki gibi "yılan notasyonu (snake casting)" tercih edilmektedir. Ancak "yapı, enum, trait gibi "elemanlar 
    (items)" genellikle Pascal tarzı, sembolik sabitler ise genellikle Pascal tarzı ya da tüm harfleri büyük olacak biçimde 
    harflendirilmektedir. Biz de kursumuzda Rust'taki bu geleneğe uyacağız. 

    Rust'ta bir değişken isminin başında '_' karakteri varsa bu durum Rust derleyicisi tarafından özel bir anlama gelmektedir. 
    Rust derleyicisi default durumda bağlanmış (tanımlanmış) ancak kullanılmamış değişkenler için uyarı vermektedir. Ancak 
    eğer değişkenin başında '_' varsa bu uyarıyı vermemektedir. Yani programcı ismini '_' ile başlattığı değişken için derleyiciye 
    "Ben bu değişkeni kullanmayabilirim. Belki de daha sonra kullanacağım. Bunun için bana uyarı verme" demek istemektedir. 
    Örneğin:

    let _number = 123;

    Biz burada artık bu number değişkenini kullanmasak bile derleyici bunun için bize uyarı vermeyecektir. 

    Rust'ta tek bir _ karakterinden oluşan değişkenler bir yer tutucu olarak görev yapmaktadır. Örneğin:

    let _ = foo();

    Burada programcı foo fonksiyonunun geri dönüş değerinden faydalanmak istemediğini dolaylı bir biçimde derleyiciye 
    söylemektedir. Tabii aslında Rust derleyicisi bu _ değişkeni için bellekte bir yer ayırmaz. Zaten programcı da bu _ 
    ismini programının içerisinde bir değişken ismi gibi kullanamaz. Örneğin:

    let _ = 123;

    println!("{}", _);      // error!

    Belli bir versiyondan sonra Rust'ta _ isimli değişken hiç bağlama yapmadan atama işleminde de kullanılabilir hale gelmiştir. 
    Örneğin:

    _ = foo();

    Burada bizim _ isminde bir değişkeni daha önce tanımlamış olmamız gerekmez. Değişken isimleri yerine _ kullanımı ile özellikle 
    demet açımlarında sıkça karşılaşılmaktadır. Demetler ileride ele alınacaktır. 

    Rust'ta değişkenlerin maksimum karakter uzunluğu konusunda "The Rust Reference" dokümanlarında bir belirlemede bulunulmamıştır. 
    Bu konuda bir belirlemede bulunulmamış olması bu durumun derleyicileri yazanların isteğine bırakıldığı anlamına gelmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta bir değişken bağlandığında (tanımlandığında) o değişken default olarak "değiştirilemez (immutable)" durumdadır. 
    Yani o değişken C'deki const nesne gibidir. Örneğin:

    let a = 10;

    Burada a değişkeni default olarak değiştirilemez (immutable) durumdadır. Ancak değiştirilemez nesneye ilkdeğer verilmesi 
    zorunlu da değildir. Bu değişkene bağlamadan sonra da değer atanabilir. Ancak ne olursa olsun değiştirilemez değişkenlere
    toplamda yalnızca bir kez değer atanabilmektedir. Örneğin:

    let a: i32;

    a = 10;         // geçerli
    a = 20;         // error!

    Değişkenlerin default durumda değiştirilemez olması Rust'a özgü bir özellik değildir. Swift gibi Kotlin gibi yeni programlama 
    dillerinde de Erlang ve Haskell gibi fonksiyonel dillerde de değişkenler default durumda değiştirilemez biçimdedir. Değişkenin
    değiştirilebilir (mutable) olmasını sağlamak için değişken isminin soluna mut anahtar sözcüğü getirilir. Örneğin:

    let mut a: i32 = 10;

    a = 20;         // geçerli
    //...
    a = 30;         // geçerli

    Örneğin:

    let mut a: i32;

    a = 10;
    println!("{}", a);              // 10
    a = 20;                         // geçerli
    println!("{}", a);              // 20
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Java, C# ve yeni tasarlanmış olan bazı dillerde olduğu gibi Rust'ta da henüz değer atanmamış bir değişkenin kullanılması
    (içerisindeki değerin elde edileceği bir ifadede kullanılması) derleme aşamasında error oluşturmaktadır. Örneğin:

    let a: i32;

    prinln!("{}", a);       // derleme aşamasında error oluşur!

    C'de değer atanmamış nesnelerin kullanılabildiğini ancak bu durumun "tanımsız davranışa (undefined behavior)" yol açtığını
    anımsayınız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta C, C++, Java, C# gibi dillerde bulunmayan ismine "gölgeleme (shaowing)" denilen bir faaliyet alanı (scope) özelliği 
    vardır. Rust'ta aynı faaliyet alanında aynı isimli değişkenler bağlanabilir (tanımlanabilir). Bu durumda ikinci bağlamaya 
    kadar ilk değişken faaliyet göstermeye devam eder. Ancak ikinci bağlamadan sonra artık ilk değişken kullanılamaz, ancak 
    ikinci değişken kullanılabilir. Örneğin:

    let a: i32 = 10;
    
    println!("{}", a);      // 10

    let a: f64 = 3.14;      // geçerli, gölgeleme (shadowing) deniyor
   
    println!("{}", a);      // 3.14

    Burada aynı fonksiyon içerisinde aynı isimli değişken let deyimi ile birden fazla kez bağlanmıştır. Bu tür bildirimlerin
    C, C++, Java ve C# gibi pek çok dilde geçerli olmadığını anımsayınız. 

    "The Rust Reference" dokümanlarına göre gölgeleme sırasında türler aynı olsa bile farklı bir değişken yaratılır. Örneğin:

    let a: i32 = 10;
    //...
    let a: i32 = 20;

    Burada iki a'nın adresi alındığında farklı adresler görülecektir. Tabii kodun gözlemlenebilen davranışı değişmedikten sonra
    derleyiciler kodu daha hızlı çalışacak ya da daha az yer kaplayacak biçimde düzenleyebilirler. Buna derleyicilerin "kod
    optimizasyonu" denilmektedir. Aşağıdaki kodu inceleyiniz:

    let a: i32 = 10;
    
    println!("{}", a);      // 10

    let a: i32 = 20;    

    println!("{}", a);      // 20

    Bu kodda biz a için ikinci kez farklı bir yer ayrılıp ayrılmadığını anlayamayız. Çünkü kodumuzda bu gözlemi yapabilecek
    bir durum oluşmamıştır. Dolayısıyla derleyici burada tek bir a oluşturup kodu optimize etmeye çalışabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Statik tür sistemine sahip olan programlama dillerinde yalnızca değişkenlerin değil sabitlerin de (genel olarak tüm 
    ifadelerin (expression) de) bir türü vardır. Sabitlerin türleri onların yazım biçimlerine göre ve niceliklerine göre 
    (yani değerlerine göre) değişebilmektedir. Bir programlama dilini öğrenirken ilk öğrenilecek konulardan birisi de o 
    programlama dilindeki sabitlerin nasıl oluşturulduğu ve türlerinin nasıl belirlendiğidir. Biz de bu bölümde Rust
    dilindeki sabitlerin nasıl oluşturulduğunu ve türlerinin nasıl belirlendiğini ele alacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Program içerisinde doğrudan yazılmış olan değerlere "sabit (literal)" denilmektedir. Örneğin:

    a = b + 10;

    Burada a ve b birer değişken 10 ise bir sabittir. Biz burada b'nin içerisindeki değerle doğrudan 10'u topluyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust katı tür kontrolüne (strict type checking) sahip bir programlama dilidir. Atama sırasında kaynak değerin türüyle 
    hedef değerin türünün aynı olması gerekir. Örneğin:

    let a: i8 = 10;
    let b: i32;

    b = a;      // error!

    Burada her ne kadar i8 türündeki her değer i32 türüyle ifade edilebiliyorsa da başka bir deyişle atamada bilgi kaybının 
    oluşması söz konusu değilse de bu atama error ile sonuçlanacaktır. Çünkü kaynak türle hedef tür birbirinden farklıdır. 
    Yukarıdaki gibi atamaların C, Java ve C# gibi programlama dillerinde tamamen normal ve geçerli olduğunu anımsayınız.

    Rust'ta iki operand'lı operatörlerde operand'ların türleri de aynı olmak zorundadır. Örneğin:

    let a: i8 = 10;
    let b: i32 = 20;
    let c: i32;

    c = a + b;      // error!
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            7. Ders 19/03/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta nokta içermeyen ve sonunda tür eki bulunmayan sabitler onların kullanıldığı bağlama göre gereksinim duyulan türün
    sınırları içerisinde kalıyorsa o türden kabul edilmektedir. Örneğin:

    let a: i8 = 127;        // geçerli

    Burada 127 sabitinin sonunda bir tür eki yoktur. i8 türünün sınır değerlerinin [-128, +127] olduğuna dikkat ediniz. İşte 
    burada 127 değeri bu sınırlar içerisinde olduğu için sanki i8 türündenmiş gibi işlem görmektedir. Örneğin:

    let a: u16 = 50000;

    Burada 50000 değeri içinde bulunulan bağlamda u16 türüne atanmak amacıyla kullanılmıştır. 50000 değeri u16 sınırları 
    içerisinde kaldığı için sanki u16 türünden bir sabitmiş gibi ele alınmaktadır. Örneğin:

    let a: i8 = 10;
    let b: i8;

    b = a + 10;

    İki operand'lı operatörlerin operand'larının aynı türden olması gerektiğini belirtmiştik. Buradaki a + 10 işleminde 10
    sanki i8 sabit gibi ele alınacaktır. Çünkü 10 sayısı i8 türünün sınırları içerisinde kalmaktadır. Örneğin:

    let a: u16;

    a = 70000;      // error!

    Burada 70000 değeri u16 sınırlarının içerisinde kalmadığı için u16 türünden bir sabit gibi ele alınmayacaktır. 

    Ancak let ile bağlama yapılırken verilen ilkdeğer tür eki içermeyen bir tamsayı ise bu durumda sabit her zaman i32 türünden 
    kabul edilmektedir. Örneğin:

    let a = 3000000000;         // error!

    Burada 3 milyar değeri i32 türünün sınırları dışındadır. Dolayısıyla error oluşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta tıpkı Python'da olduğu gibi sayıların daha kolay algılanabilmesi için basamaklar '_' karakteriyle ayrıştırılabilmektedir. 
    Örneğin:

    let a: u64 = 3_000_000_000;     // geçerli

    Burada basamakları ayıran '_' karakterinin sayı üzerinde bir etkisi yoktur. Tabii '_' karakteri ile üçerli ayrıştırma 
    yapmak zorunlu değildir. Ayrıştırma herhangi bir basamakta bir ya da birden fazla '_' karakteri kullanılarak yapılabilir. 
    Örneğin:

    a = 3_0_0_0_0_0_0_0_0_0;        // geçerli

    Sayının sonunda da '_' karakteri bulunabilir, ancak başında bulunamaz. Yukarıda da belirttiğimiz gibi birden fazla '_'
    karakterinin peşi sıra kullanılmasına da izin verilmiştir. Örneğin:

    a = 3___0_0_0_0_0_0_0_0_0__;        // geçerli

    Tabii bu '_' karakterlerinin amacı okunabilirliği artırmak olduğu için bunlar 10'luk sistemde tipik olarak binli basamakları 
    ayrıştırmak için kullanılmaktadır. 

    Basamak ayırçaları eski dillerin yeni sürümlerine de zamanla eklenmiştir. Örneğin C++'a C++14 ile C'ye de C23 ile bu 
    özellik eklenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tamsayı sabitlerinin sonlarına onların türlerini belirten ekler getirilebilmektedir. Bu sonekler tamsayı türlerinin 
    isimlerinden oluşmaktadır:

    i8
    u8
    i16
    u16
    i32
    u32
    i64
    u64
    i128
    u128

    Biz tamsayı sabitlerinin sonuna yapışık bir biçimde bu sonekleri getirirsek artık sabitler kesinlikle bu türlerden olur. 
    Örneğin:

    123i32
    3000000000u32
    10i8
    20u64

    Örneğin:

    let a: u64;

    a = 10u64;

    Burada 10 sabitinin açıkça u64 türünden olduğu belirtilmiştir. Örneğin:

    let a = 10;

    Burada a değişkeni i32 türündendir. Fakat örneğin:

    let a = 10u32;

    Burada ise a değişkeni u32 türündendir. 

    Basamakları ayrıştırmak için kullanılan '_' karakterlerinin sayının sonunda da bulunabileceğini belirtmiştik. Tür soneklerinin
    okunabilirliği bozmasını engellemek amacıyla soneklerden önce '_' karakteri de kullanılabilir. Örneğin:

    let a = 10_u32;

    Bazı Rust programcıları soneklerden önce '_' karakterini kullanmaktadır. Bazı programcılar ise yalnızca büyük sabitlerde 
    kullanmayı tercih etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tamsayı sabitleri 2'lik (binary) sistemde, 8'lik (octal) sistemde ve 16'lık (hexadecimal) sistemde yazılabilmektedir. 
    Bunun için sabitin önüne 2'lik sistem için 0b, 8'lik sistem için 0o ve 16'lık sistem için 0x önekleri getirilmektedir. 
    (Bu öneklerin 0B, 0O ve 0X biçiminde büyük harfli biçimleri yoktur.) Örneğin aşağıdaki sabitler geçerlidir:

    0b1010
    0b_1_0_1_0_
    0b1010_1010
    0o712_564
    0xFC_16_FD_32

    C'de 0o biçiminde bir önek bulunmadığını sayının başındaki 0'ın 8'lik sistem anlamına geldiğini anımsayınız. Oysa Rust'ta
    sayının başındaki 0 rakamı 8'lik sistem anlamına gelmemektedir. 8'lik sistem için zaten 0o kullanılmaktadır. C'de 2'lik 
    sistemde sabit belirtilemiyordu. Ancak C'nin en yeni standardı olan C23 sürümünde bu özellik eklenmiştir. 

    Sabitin kaçlık sistemde yazıldığı ile tür arasında bir ilişki yoktur. Örneğin:

    let a = 0x1234;    

    Buradaki 0x1234 değeri i32 türünün sınırlrı içerisindedir. Bu nedenle a da i32 türündendir. Örneğin:

    let a = 0x123456789;        // error!

    Buradaki sayı i32 türünün sınırları dışındadır. Dolayısıyla bu bağlama error oluşturacaktır. Örneğin:

    let a: i8 = 100;
    let b: i8;

    b = a + 0x10;           // geçerli

    Buradaki 0x10 aslında 10'luk sistemdeki 16 sayısıdır. Dolayısıyla bu bağlamda bu sayı i8 türünün sınırları içerisinde 
    olduğu için i8 sabit olarak ele alınacaktır. 

    Tabii biz 2'lik, 8'lik ve 16'lık sistemlerde yazdığımız sabitlerin sonuna da yine tür ekleri getirebiliriz. Örneğin:

    let a = 0x123456789u64;        

    Burada artık sabit u64 türündendir. Tabii basamak ayıraçları yine bu sistemlerde yazılan sayılarda da kullanılabilir. 
    Örneğin 2'lik sistemdeki sayıların dörderli biçimde gruplanması bir gelenektir:

    let a = 0b_1010_0101;

    Burada a i32 türündendir.     
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta sayı nokta içeriyorsa ve sabitin sonunda bir tür eki yoksa ve bu biçimde yazılan sabitler onların kullanıldığı 
    bağlama göre gereksinim duyulan türün sınırları içerisinde kalıyorsa o türden kabul edilmektedir. Örneğin:

    let f: 32 = 3.14;       // geçerli

    Burada 3.14 sabiti f32 türü ile ifade edilebilmektedir. Bu nedenle sanki f32 türünden bir sabitmiş gibi kullanılabilmiştir. 
    Örneğin:

    let a: f32 = 12.3;
    let b: f32;

    b = a + 1.2;            // geçerli

    Burada 1.2 bağlam içerisinde f32 türünden bir sabit olarak ele alınacaktır. Çünkü 1.2 sayısı f32 türü ile ifade edilebilmektedir. 
    Ancak bu durum tamsayılar için geçerli değildir. Örneğin:

    let a: f32 = 10;        // error

    Burada her ne kadar 10 sabiti f32 türü ile ifade edilebiliyorsa da tamsayı sabiti olduğu için bağlama geçersizdir. Noktalı 
    bir sayı eğer f32 türünün basamaksal olarak (duyarlılık olarak değil) sınıfları dışında kalırsa bu durum derleme aşamasında 
    error oluşturmaktadır. Örneğin:

    let a: f32 = 1e50;      // error! 

    Burada 1e50 sabiti basamaksal olarak f32 türünün sınırları içerisinde kalmamaktadır. Bu nedenle bu sabit ataması error 
    ile sonuçlanacaktır. Eğer noktalı sayı basamaksal değil de mantis bakımından f32 türü ile ifade edilemiyorsa bu durum error 
    oluşturmaz. f32 ile ifade edilebilen ona en yakın değer elde edilir. (Bu durumda f32 türüne dönüştürme kuralı uygulanmaktadır.
    Bu dönüştürme kuralını tür dönüştürme operatörünü anlatırken ele alacağız.) Diğer pek çok dilde olduğu gibi '.' karakterinin 
    sağına bir şey yazılmazsa sabit sanki .0 gibi ele alınmaktadır. Örneğin:

    let a: f64 = 1.;        // geçerli

    Ancak gerçek sayı sabitlerinde noktanın solu boş bırakılamaz. Örneğin:

    let a: f64 = .10;       // error!
    
    Tabii noktanın solundaki ve sağındaki sayılarda istenildiği kadar '_' ile ayrıştırma yapılabilir. Örneğin:

    let a: f64 = 123_456.789_012;       // geçerli

    Ancak noktadan hemen sonra '_' ayrıştırma karakteri kullanılamamaktadır. Örneğin:

    let a: f64 = 1._234;       // error!

    let deyiminde değişkenin türü belirtilmezse ve verilen ilkdeğer sonek içermeyen bir noktalı sayı ise bu durumda sabit 
    f64 türünden kabul edilir, değişken de o türden olur. Örneğin:

    let a = 3.14;

    Burada a değişkeni f64 türündendir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Gerçek sayı sabitlerinin sonuna da onların türünü belirten tür soneki getirilebilmektedir. Bunun için aşağıdaki iki tür 
    soneki kullanılmaktadır:

    f32
    f64

    Örneğin:

    let a = 3.14f32;

    Burada a değişkeni artık f32 türünden olacaktır. Halbuki örneğin:

    let a = 3.14;

    Burada a değişkeni f64 türünden olur. Tabii yine tür sonekinden önce okunabilirliği artırmak için '_' ile ayrıştırma 
    tercih edilebilir. Örneğin:

    let a = 3.14_f32;

    Gerçek sayı sabitlerinde tür soneki noktadan hemen sonra başlatılamaz. Örneğin:

    let a: f64 = 1.f64;         // error!
    let b: f64 = 1._f64;        // error!

    Gerçek sayı sabitlerinde açıkça tür belirtmek iyi bir tekniktir. Gerçek sayı sabitibe f32 ve f64 soneki getirmiş olsak 
    bile eğer sabit basamaksal olarak soneke ilişkin türün sınırları dışında kalıyorsa sabit geçersiz olmaktadır. Örneğin:

    let a: f32 = 1e50;      // error! sabit f32 sınırlarını basamaksal olarak aşıyor

    C'de gerçek sayı soneklerini (f ve lf) kullanabilmek için sabitin nokta içermesi gerekmektedir. Rust'ta sabit nokta içermese
    de sabitin sonuna f32 ve f64 sonekleri getirilebilmektedir. Örneğin:

    let f: 64 = 1f64;       // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pek çok programlama dilinde olduğu gibi Rust'ta da gerçek sayı sabitleri (f32 ve f64 türünden sabitler) üstel biçimde 
    belirtilebilmektedir. Gerçek sayı sabitleri üstel biçimde belirtilirken e ya da E harfi 10'un kuvveri anlamına gelmektedir. 
    Örneğin:

    let f = 1.23e12;        

    Bu sabit 1.23 * 10^12 anlamına gelmektedir. Örneğin:

    let f = 1.23e-12; 

    Bu sabit 1.23 * 10^-12 anlamına gelmektedir. Gerçek sayı sabitleri üstel biçimde belirtilirken yine basamak ayıracı olarak 
    _ karakteri kullanılabilmektedir. Aşağıdaki sabitte her ne kadar basamak ayıraçlarının kullanılması gereksizse de sabit
    geçerlidir:

    let f = 1_.2_3E_10;

    Diğer pek çok dilde olduğu gibi gerçek sayı sabitleri üstel formatta yazılırken nokta içermese bile gerçek sayı sabiti 
    olarak ele alınmaktadır. Örneğin:

    let f: f64 = 1e5;       // geçerli
    let f: i64 = 1e5;       // error!
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta bool türden iki sabit vardır. Bunlar true ve false anahtar sözcükleridir. Örneğin:

    let b = true;

    Burada b değişkeni bool türdendir 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir Unicode karakter tek tırnak içerisine alınırsa char türden sabit belirtir. Örneğin:

    let c = 'x';

    Burada c değişkeni char türdendir. Rust'ta da diğer bazı dillerde olduğu gibi tek tırnağın içerisinde ters bölü karakter
    sabitleri kullanılabilmektedir. Ancak Rust'ta biz C'deki tüm ters bölü karakterlerini kullanamamaktayız. Rust'ta kullanabileceğimiz
    ters bölü karakterleri şunlardır:

    \n
    \r
    \t
    \\
    \'
    \"
    \0

    Diğer dillerde olduğu gibi tek tırnak içerisinde Unicode kod numarası belirtilerek de herhangi bir Unicode karakterden 
    karakter sabiti oluşturulabilmektedir. Bunun için tek tırnak içerisinde önce \u sonra da küme parantezleri içerisinde 
    Unicode kod numarası girilmelidir. Örneğin:

    let c = '\u{6728}'

    println!("{}", c);      // 木
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            8. Ders 24/03/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tek tırnak içeisine bir ASCII karakteri yerleştirilip başına da bununla yapışık b karakteri getirilirse bu biçimdeki 
    sabitlere Rust'ta "byte sabitleri (byte literals)" denilmektedir. Byte sabitleri u8 türündendir. Byte sabitleri tek 
    tırnak içerisindeki ASCII karakterinin kod numarasına ilişkin bir sayı belirtirler. Örneğin:

    let b: u8;

    b = b'a';       // geçerli, b'a' u8 türünen

    Burada b'a' sabiti bir byte sabitidir. Byte sabitler u8 türünden kabul edikleri için biz onları ancak u8 türünden bir değişkene
    atayabiliriz. Byte sabitlerinde tek tırnak içerisine yalnızca standart ASCII karalterlerinden biri yerleştirilebilir. Yani 
    tek tırnak içine yerleştirilecek karakterin Unicode kod numarasının [0, 127] aralığında olması gerekir. Örneğin:

    let b: u8 = b'ş';                // error!

    Burada 'ş' karakteri bir ASCII karakter olmadığı için byte sabit geçersiz bir biçimde oluşturulmuştur. Tabii Rust'ın 
    yukarıda belirtmiş olduğumuz ters bölü karakter sabitleri aynı zamanda ASCII karakterleri olduğu için byte sabit olarak 
    kullanılabilir. Örneğin:

    let b: u8 = b'\n';               // geçerli

    Byte sabitleri oluştururken tek tırnak içerisine \u {...} biçiminde Unicode kod numarası belirtilerek karakterler yerleştirilemez. 
    Örneğin:

    let b: u8 = b'\u{61}';           // error!

    'a' gibi bir sabitin char türden olduğuna ama b'a' biçiminde bir sabitin u8 türünden olduğuna dikkat ediniz. 

    Aşağıdaki bağlamaya dikkat ediniz:

    let b: u8 = b'a';

    Burada aslında b'nin içerisinde 97 sayısı vardır. Biz b'yi yazdırırsak 97 görürürüz. Örneğin:

    println!("{}", b);      // 97

    Pekiyi o halde yukarıdaki bağlamanın aşağıdakinden ne farkı vardır?

    let b: u8 = 97;

    Aslında bu iki bağlama arasında işlevsel bir farklılık yoktur. Ancak byte sabitler özellikle standart ASCII karakterlerin 
    kod numaralarının oluşturulması için tercih edilmektedir. Yani bağlamına göre b'a' gibi bir sabit amaçlanan şeyi daha 
    iyi ifade edebilecektir. 

    Byte sabitlerini oluştururken tek tırnak içerisine yalnızca ASCII karakterlerinin yazılabileceğini belirtmiştik. Ancak 
    eğer istenirse [128, 255] arasındaki kod numaraları '\xHH' (Burada HH iki hex digit belirtmektedir) biçiminde de belirtilebilir. 
    Örneğin:

    let b: u8 = b'\xFC';        // geçerli

    Byte sabitleri Python'da uzun süredir bulunmaktadır. Tabii Python'da bir byte'lık başka bir tür olmadığı için oradaki
    byte türü ve byte sabitlerinin yeri başka biçimde doldurulamamaktadır. Python'da byte sabitlerin öneki 'b' ya da 'B' 
    olabilmektedir. Halbuki Rust'ta bu önek yalnızca 'b' biçimindedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta iki tırnak içerisine yazılmış olan karakterlere iki tırnaklarıyla birlikte "string sabiti (string literal)" 
    denilmektedir. Daha önceden de belirttiğimiz gibi Rust iki tırnak içerisindeki karakterleri Unicode UTF-8 kodlamasıyla
    tutmaktadır. Bu nedenle biz iki tırnak içerisinde tüm Unicode karakterleri, Rust'ın ters bölü karakterlerini \u{...}
    biçiminde Unicode kod numarasıyla belirttiğimiz karakterleri kullanabiliriz. Rust'ın stringlerinin sonuna null karakter 
    yerleştirilmediğini de daha önce belirtmiştik. C'den geçen kişiler özellikle şu iki noktaya dikkat etmelidirler:

    1) Rust'taki string'lerin içerisindeki karakterler Unicode UTF-8 kodlamasıyla tutulmaktadır.
    2) Rust'ta string'lerin sonunda null karakter yoktur. 

    C'de string'ler ifade içerisinde kullanıldığında char * türünden, C++'te const char * türünden kabul edilmektedir. 
    Java, C# ve Python gibi dillerde string'ler o dillerin String sınıfı türünden (Python'da str sınıfı türünden) nesne 
    referansı belirtmektedir. Örneğin Java ve C#'ta iki tırnak ifadeleri o dillerin String sınıfı türünden bir değişkene 
    atanabilmektedir. 

    Rust'ta iki tırnak içerisindeki string'ler str türündendir. Ancak str türü hep referanslı bir biçimde kullanılır. Dolayısıyla
    Rust'ta biz bir string'i &str türünden bir değişkene atayabiliriz. &str türüne "string dilim referansı" denilmektedir. 
    Referanslar ve dilimler ilerideki bölümlerde ele alınacaktır. Örneğin:

    let s: &str;

    s = "ağrı dağı";            // geçerli

    Unicode UTF-8 kodlamasıyla oluşturulan bir yazının n'inci karakterine tek hamlede (tek makine komutuyla) erişilememektedir. 
    Çünkü bu kodlamada daha önce belirttiğimiz gibi her karakter farklı byte uzunluklarında olabilmektedir. Dolayısıyla biz 
    böyle bir string'in n'inci karakterini ancak string'in başından itibaren ilerleyerek bulabiliriz. Programda dillerinde []
    operatörü ratgele erişimlerde (O(1) erişim de denilmektedir) kullanılmaktadır. Bu nedenle Rust'ın string'lerinin karakterlerine 
    bu operatörle erişilemez. Örneğin:

    let s: &str = "ağrı dağı";
    let c = s[4];               // error!

    Rust string'lerinde s[4] biçiminde bir erişim yoktur.

    Rust'ta string'ler tek satıra yazılmak zorunda değildir. Yani biz string'leri birden fazla satıra yazabiliriz. Tabii istersek 
    \ karakteri ve hemen ardından \n karakteri lle (yani editörde \ karakterine bastıktan sonra ENTER tuşuna basıp) "aşağı 
    satırdan devam et" diyerek de aynı şeyi yapabiliriz. Örneğin:

    let s: &str;

    s = "Ankara Türkiye'nin         // geçerli
    başkentidir";                       

    Ancak örneğin:

    s = "Ankara Türkiye'nin \       // geçerli
    başkentidir";                       

    \ karakteri ile farklı satırların sanki tek bir satırmış gibi birleştirilmesi özelliği C'de ve diğer bazı dillerde de
    bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta "saf string sabitleri (raw string literals)" adında string sabitleri de vardır. Aslında Rust'taki bu saf string 
    sabitleri farklı isimlerle pek çok programlama dilinde de bulunmaktadır. Örneğin C#'ta bu tür string'lere "verbatim string", 
    Python'da "regular string" denilemektedir. C++'a da C++11 ile birlikte bu özellik eklenmiştir. Rust gibi nispeten yeni 
    tasarlanan dillerde de artık doğuştan itibaren bu biçimde string sabitleri bulunmaktadır.

    Rust'ta saf string sabitleri (kısaca "saf string'ler" de diyebiliriz) içerisindeki '\' karakterleri gerçekten '\' karakteri 
    anlamına gelmektedir. Yani bu string'ler içerisindeki ters bölü karakterleri ters bölü karakter sabiti oluşturma anlamında
    ele alınmamaktadır. Örneğin:

    let s: &str = "ali\nveli";

    Buradaki string'te \n tek bir karakterdir. Bu yazı ekrana yazdırıldığında bu \n karakteri imlecin aşağı satırın başına
    geçirilmesine yol açacaktır. Eğer buradaki string saf string olsaydı bu \n karakterleri "new line" karakteri yerine 
    ayrı ayrı '\' karakteri ve 'n' karakteri anlamına gelecekti. 
    
    Rust'ta saf string'ler iki tırnağın başına onunla yapışık r öneki getirilerek oluşturulmaktadır. Örneğin:

    let s: &str = r"ali\veli";

    println!("{}", s);          // ali\nveli

    Saf string sabitleri ters bölü karakteri içeren yazıların daha kolay ve okunabilir bir biçimde oluşturulmasına olanak 
    sağlamaktadır. Örneğin:

    let path: &str = r"c:\temp\test.txt";

    Eğer saf string sabitleri olmasaydı biz bu yazıyı şöye oluşturmak zorunda kalırdık:

    let path: &str = "c:\\temp\\test.txt";

    Pekiyi biz iki tırnak içerisinde iki tırnak karakteri içeren bir yazıyı nasıl oluşturabiliriz? Bu Rust'ta diğer dillerde 
    olduğu gibi \" kullanılarak yapılabilmektedir. Örneğin:

    let s = "\"ankara\"";
    
    println!("{}",s);       "ankara"

    Tabii iki tırnak içerisinde tek tırnak karakteri kullanmanın, tek tırnak içerisinde de iki tırnak karakteri kullanmanın 
    bir sakıncası olmadığını biliyorsunuz.

    Rust'ta saf string'ler ayrıca r önekininin yanında bir ya da birden fazla # ile de oluşturulabilmektedir. Ancak bu durumda 
    kapanış iki tırnak karakterinden sonra açılış iki tırnak karakterinin önündeki sayıda # karakterinin bulundurulması 
    gerekmektedir. Örneğin:

    let s: &str = r#"ankara"#;
    println!("{}", s);          // ankara

    Burada r önekinden sonra iki tırnağın başına ve sonuna # karakterinin getirildiğine dikkat ediniz. #'lerin sayısı birden 
    fazla olabilir ancak kapanışta da aynı sayıda # karakterinin bulundurulması gerekir. Örneğin:

    let s: &str = r###"ankara"###;
    println!("{}", s);      // ankara

    Burada açılış iki tırnak karakterinin solunda üç tane # karakteri olduğu için sağında da üç tane # karakteri bulunmak zorundadır. 
    Pekiyi saf string'lerde # karakterlerini bulundurmanın anlamı nedir? İşte bunun amacı iki tırnak içerisindeki iki tırnak 
    karakterlerinin kolay yazılmasını sağlamaktır. Örneğin biz JSON formatına benzer bir formatta anahtar değer çiftlerini bir yazı 
    biçiminde oluşturmak isteyelim. Ancak anahtarların da iki tırnaklı yazılardan oluştuğunu varsayalım. Bu durumda aşağıdaki gibi 
    bir string geçersiz olacaktır:

    let s: &str = "{"ali": 123, "veli": 234}";      // error!

    Çünkü burada iki tırnak içerisindeki iki tırnak karakteri iki tırnağı kapatmak anlamına gelmektedir. Bu string'in başına r 
    öneki getirerek de bunu geçerli yapamayız:

    let s: &str = r"{"ali": 123, "veli": 234}";         // error!

    Tabii bu string'i geçerli bir biçimde şöyle belirtebilirdik:

    let s: &str = "{\"ali\": 123, \"veli\": 234}";      // geçerli

    Fakat bu durumda da yazı okunabilir olmaktan çıkmaktadır. İşte #'li saf string'ler bu kolaylığı sağlamaktadır:

    let s: &str = r#"{"ali": 123, "veli": 234}"#;      // geçerli

    Pekiyi neden artık bu string geçerli olmuştur? Çünkü string #" ile başlatıldığı ve bitimi de "# biçiminde olacağı için 
    bunun içerisindeki çift tırnak karakteri artık string'i bitirmek anlamına gelmemektedir. Şimdi de aşağıdaki string'e 
    dikkat ediniz:

    let s: &str = r#"ben "#" karakterini çok seviyorum"#;      // error!

    Bu string geçersizdir. Çünkü burada yazı içerisinde tesadüfen bulunan "# karakterleri saf string'i bitiren karakterler 
    olarak ele alınacaktır. İşte bu tür durumlarda #'lerin sayısını artırabiliriz:

    let s: &str = r##"ben "#" karakterini çok seviyorum"##;     // geçerli

    Burada artık string ##" ile başlatıldığı için bitimi de "## ile yapılmaktadır. 

    Saf string'lerin farklı bir tür belirtmediğine yalnızca yazının içeriği konusunda etkili olduğuna dikkat ediniz. Normal
    string'ler de saf string'ler de &str türündendir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta diğer bir string sabiti de "byte string sabiti (byte string literals)" denilen sabittir. Bu sabitlere kısaca "byte
    string'ler" de denilmektedir. Byte string'ler iki tırnağın önünde ona yapışık bir biçimde b öneki ile oluşturulmaktadır. 
    byte string'ler u8 türünden bir dizi dilimi belirtmektedir. Dolayısıyla &[u8] türünden bir değişkene atanabilirler. 
    Örneğin:
    
    let bs: &[u8] = b"ankara";

    println!("{:?}",bs);        // [97, 110, 107, 97, 114, 97]

    Tabii byte string'lerin içerisindeki karakterlerin de yine byte sabitlerde olduğu gibi yalnızca ASCII karakterlerinden 
    oluşturulması gerekir. Örneğin:

    let bs: &[u8] = b"ağrı dağı";       // error!

    Burada byte string'in içerisinde Türkçe karakterler bulundurulmuştur. Ancak byte sabitlerinde olduğu gibi byte string 
    sabitlerinde de [128, 255] arasındaki karakterler \xHH (Burada HH iki hex digit belirtmektedir) ifade edilebilir. Örneğin:

    let bs: &[u8] = b"abc\xFF\xFCdef";       // geçerli   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Byte string sabitleri de "saf (raw)" biçimde oluşturulabilmektedir. Bunlara "saf byte string sabitleri (raw byte string 
    literals)" denilmektedir. Bunun için iki tırnağa yapışık br öneki bulundurulmaktadır.  Buradaki semantik saf string 
    sabitlerinde olduğu gibidir. Yani iki tırnağın içerisindeki ters bölü karakterleri ters bölü karakter sabitleri olarak değil
    gerçekten ters bölü karakterleri olarak ele alınmaktadır. Örneğin:

    let bs: &[u8] = br"a\nb";

    Burada \n "new line" karakterini değil \ ve n karalterlerini belirtmektedir. Dolayısıyla burada byte string'i 3 uzunlukta 
    değil 4 uzunluktadır. 

    Yine saf byte string sabitlerinde br önekinden sonra bunlara yapışık bir ya da birden fazla # karakteri bulundurulabilir. 
    Saf string sabitlerinde olduğu gibi bu da iki tırnak içerisinde iki tırnak karakterinin daha kolay kullanılmasını sağlamaktadır. 
    Örneğin:

    let bs: &[u8] = br#"ankara""#;
    let bs: &[u8] = br##""#"##;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                        9. Ders 26/03/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ı C Programala Dili ile birlikte kullanabilmek için C tarzı string'ler de bulundurulmuştur. Bunlara "C string sabitleri
    (C string lietarls)" denilmektedir. C string sabitleri iki tırnağın soluna onunla yapışık c harfi getirilerek oluşturulmaktadır. 
    Örneğin:

    let cs = c"ankara";

    C String sabitleri &CStr türündendir. Yani CStr türünden bir dilim referansı belirtmektedir. Ancak CStr türü ffi isimli 
    modülün içerisindedir ve otomatik olarak derleyici tarafından tanınmamaktadır. (Bu durum "prelude" denilen bir konu içerisinde 
    ileride ayrı bir başlık halinde ele alınacaktır.) CStr türü std::ffi modülünün içerisinde tanımlanmıştır. Bu tür std::ffi::CStr 
    biçiminde niteliklendirme yapılarak kullanılabilir ya da ileride de göreceğimiz gibi niteliklendirmeyi ortadan kaldırıp 
    kolay bir kullanım oluşturmak için aşağıdaki gibi use bildirimi de yapılabilir:

    use std::ffi::CStr;

    ffi sözcüğü "foreign function interface" sözcüklerinden kısaltılmıştır. Aslında C string sabitlerinin normal string 
    sabitlerinden en önemli farklılığı C string sabitlerinin sonunda '\0' (null karakter) bulunmasıdır. Yani bu sabitlerde 
    Rust derleyicisi yazının sonuna '\0' karakterini de yerleştirmektedir. Böylece örneğin biz C'de yazılmış ve parametresi 
    char * ya da const char * türünden olan fonksiyonlara C'deki beklentiyi karşılamak için '\0' ile biten bir C string sabiti 
    gönderebiliriz. C'de yazılmış olan fonksiyonların Rust'tan, Rust'ta yazılmış olan fonksiyonların C'den kullanılabilmesi 
    kursumuzda ayrı bir başlık altında ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C String sabitleri de "saf (raw)" biçimde kullanılabilmektedir. Bunun için iki tırnağa yapışık onun önünce cr öneki 
    getirilmektedir. Semantik tamamen diğer saf string'lerde olduğu gibidir. Örneğin:

    let cs: &std::ffi::CStr = cr"a\nb";

    Burada \n karakterleri "new line" karakterini değil ayrı ayrı \ ve n karakterlerini belirtmektedir. Yine aynı biçimde C 
    string sabitlerinde de yazının içerisinde iki tırnak karakterinin kolay kullanılması için iki tırnakların başına ve sonuna 
    aynı sayıda  # karakteri getirilebilmektedir. Örneğin:

    let cs: &std::ffi::CStr = cr#""ankara""#;       // geçerli
    let cs: &std::ffi::CStr = cr##""#"##;           // geçerli
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta never türünden (! türünden) bir sabit ya da da değer yoktur. Yani Rust'ta ! bir değer değil tür belirtmektedir. 
    Never türünden bir değerin olmamasının nedeni bu türün "akış buradan devam etmeyecek" anlamına gelmesindendir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta fonksiyon tanımlaması ve fonksiyonların çağrılması üzerinde duracağız. Böylece artık örneklerimizde
    fonksiyonları da kullanabileceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta bir fonksiyon tanımlamanın temel genel biçimi şöyledir:

    fn <fonksiyon_ismi>([parametre_tanımlamaları]) [ -> <geri_dönüş_değerinin_türü>] {
        //...
    }

    Bu temel bir genel biçimdir. Fonksiyon tanımlamanın genel biçiminde henüz üzerinde durmayacağımız bazı ayrıntılar da vardır. 
    Şimdi bu temel genel biçim üzerinde duralım. Bir fonksiyon tanımlarken tanımlamanın başında fn anahtar sözcüğü bulundurulmaktadır. 
    Bu fn anahtar sözcüğünü fonksiyon ismi izler. Fonksiyon isminden sonra parantezlerin açılıp kapanması gerekir. Ancak parantezlerin 
    içerisinde fonksiyonun parametre değişkenleri tanımlanabilmektedir. Tabii fonksiyonlar parametreye sahip olmak zorunda değildir. 
    Bir fonksiyonun onu çağıran fonksiyona ilettiği değere "geri dönüş değeri (return value)" denildiğini biliyorsunuz. Fonksiyonların
    geri dönüş değerlerinin türleri Rust'ta fonksiyonun parametre parantezinden sonra -> atomu ve sonra tür yazılarak belirtilmektedir. 
    Örneğin:

    fn foo() -> i32 {
        //...
    }

    Burada foo fonksiyonu parametreye sahip değildir ve geri dönüş değeri i32 türündendir. Tabii fonksiyonların geri dönüş değerleri 
    olmak zorunda değildir. Bu durumda parametre parantezinden sonra geri dönüş değeri belirtilmez. Örneğin:

    fn bar() {
        //...
    }

    Burada fonksiyonun geri dönüş değeri yoktur. C'de fonksiyonun geri dönüş değerinin olmadığını belirtmek için void  anahtar 
    sözcüğünün kullanıldığını anımsayınız. Örneğin:

    void bar(void)
    {
        //...
    }

    Rust'ta böyle bir void anahtar sözcüğü yoktur. Ancak onun yerine () ile temsil edilen ve ismine "birim (unit)" ya da "birim
    türü (unit type)" denilen bir sentaks kullanılmaktadır. Örneğin:

    fn bar() -> () {
        //...
    }

    Fonksiyonun geri dönüş değerinin türünün belirtilmemesiyle -> () biçiminde belirtilmesi tamamen aynı anlama gelmektedir. 
    Aslında Rust'ta bu birim türü boş bir "demet (tuple)" belirtmektedir. Örneğin:

    let s: (i32, i32) = (10, 20);

    Burada s iki elemanlı bir demettir. s'in türü de (i32, i32) biçiminde ifade edilmektedir. Örneğin:

    let s: () = ();

    Burada s elemanı olmayan (yani sıfır elemanlı) bir demettir. Bunun türü de () biçiminde ifade edilmektedir. Yani aslında 
    "birim (unit)" ya da "birim türü (unit type)" sıfır elemanlı bir demet belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de ve C++ programcılarının büyük çoğunluğu (fakat hepsi değil) fonksiyonların ana bloklarındaki küme parantezlerini 
    genellikle aşağı satırın başında açarlar. Örneğin:

    void foo(void)
    {
        //...
    }

    Fakat Rust'ta ana blok küme parantezinin aynı satırda açılması bir gelenek biçiminde yerleşmiştir. Örneğin:

    fn foo() {
        //...
    }

    Biz Derneğimizde hangi programlama dilinde çalışıyorsa o dilin geleneklerine uygun bir kod yerleşimi kullanıyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta fonksiyonlar diğer pek çok dildeki gibi çağrılmaktadır.

    fonksiyon_ismi([argüman_listesi])

    Örneğin:

    foo();
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta fonksiyonların geri dönüş değerleri diğer pek çok dilde olduğu gibi return deyimiyle oluşturulabilmektedir. 
    return deyiminin genel biçimi şöyledir:

    return [ifade];

    return deyimi hem fonksiyonu sonlandırır hem de geri dönüş değerini oluşturur. Eğer fonksiyonun geri dönüş değeri yoksa
    (yani geri dönüş değeri "birim (unit)" türündense) return anahtar sözcüğünün yanına bir ifade yazılmayabilir. Bu durumda 
    örneğin:

    return;

    kullanımı ile aşağıdaki kullanım tamamen eşdeğerdir:

    return ();

    Rust "katı bir tür kontrolüne sahip (strict type checking)" programlama dili olduğu için bir fonksiyonun geri dönüş 
    değeri hangi türdense onu aynı türden bir değişkene atamak gerekir. Örneğin:

    fn main() {
        let result: i32;

        result = foo();
        println!("{}", result);     // 100
    }

    fn foo() -> i32 {
        println!("foo");
        return 100;
    }

    Tabii Rust'ta da fonksiyonun geri dönüş değerinin olması onu kullanmayı zorunlu hale getirmemektedir. Örneğin:

    fn main() {
        foo();          // geçerli, fonksiyonun geri dönüş değerini kullanmak zorunda değiliz
    }

    fn foo() -> i32 {
        println!("foo");
        return 100;
    }

    Bazı "statik analiz araçları" bu tür durumlarda uyarı üretebilmektedir. Bundan kaçınmak için _ ile temsil edilen ve yer 
    tutucu olarak kullanılan isme bağlama yapabilrisiniz. Örneğin:

    let _ = foo();
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta Fonksiyonlar "Öğe (Item)" denilen bir sentaks grubuna ilişkindir. Genel olarak öğelerde tanımlama sırasının bir 
    önemi yoktur. Yani biz örneğin bir fonksiyonu aşağıda tanımlayıp onu yukarıda çağırabiliriz. Halbuki C ve C++'ta derleyici
    derleme işlemini yukarıdan aşağıya doğru yapmaktadır. Bu dillerde bir değişken görüldüğünde onun daha önce bildirimin 
    görülmüş olması gerekmektedir. Bu nedenle C ve C++'ta eğer çağrılan fonksiyon çağıran fonksiyonun daha altında tanımlanmışsa 
    çağırma noktasının yukarısında bir yerde "prototip bildiriminin" yapılması gerekmektedir. Ancak modern dillerin hemen hespinde 
    bu kısıtlama artık kaldırımıştır.
    
    Örneğin aşağıdaki gibi bir tanımalama ve çağırma C'de ve C++'ta geçerli değildir:

    int main(void)
    {
        foo();          // geçersiz!
    }

    void foo(void)
    {
        //...
    }

    Çünkü derleyici yukarıdan aşağıya doğru kodu derlerken foo çağrısına geldiğinde henüz foo hakkında bir bilgi edinememiştir.
    (C90'da bu kuralda bazı ayrıntıların olduğunu anımsayınız.) Halbuki bunun eşdeğeri Rust'ta geçerlidir:

    fn main() {
        foo();          // geçerli
    }

    fn foo() {
        //...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta fonksiyonların parametre değişkenleri parametre parantezinin içerisinde bir argüman listesi biçiminde tanımlanmaktadır:

    <değişken_ismi>: <tür>, <değişken_ismi>: <tür>, ....

    Örneğin:

    fn add(a: i32, b: i32) -> i32 {
        return a + b;
    }

    Burada add fonksiyonunun iki parametre değişkeni vardır. Fonksiyon da iki parametresinin toplamını geri döndürmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    if gibi, switch gibi deyimlerin de birer ifade gibi kullanılabildiği programlama dillerine "ifadesel diller (expression 
    languages)" denilmektedir. C ve C++, Java ve C# gibi diller bu bağlamda ifadesel bir diller değildir. İfadesel dillerde 
    deyimler birer değer de üretmektedir. Dolayıyla bu dillerde deyimlerin ürettikleri değerler başka ifadelerde kullanılabilmekte 
    ve değişkenlere atanabilmektedir. Örneğin:

    x = if (koşul) {
        //...
    }
    else {
        //..        
    }

    Böyle bir kullanım C'de ve C++'ta geçerli değildir ancak ifadesel dillerde geçerlidir. Yeni ve modern dillerin çoğu ifadesel 
    özelliklere sahip olarak tasarlanmaktadır. Örneğin Swift, Kotlin gibi yeni diller, Ruby, Haskell, Scheme gibi eski diller 
    bu özelliklere sahiptir. İşte bu bağlamda Rust da ifadesel bir dildir. Dolayısıyla Rust'ta biz deyimlerin ürettiği değerleri 
    yukarıdaki örnekte olduğu gibi kullanabiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de ve C++'ta olduğu gibi Rust'ta da bloklar bir deyim belirtir. Rust'ta bloklara "blok deyimi (block statement)" ya da 
    "block ifadesi (block expression)" denilmektedir. Rust'ta bir blok deyimi çalıştırılırken bu blok içerisindeki deyimler 
    sırasıyla tek tek çalıştırılır, blok deyimi de bloğun sonundaki ifadenin (expression) değerini üretir. İfade (expression) 
    kavramı izleyen bölümlerde ele alınacağı gibi ';' içermemektedir. Örneğin:

    let x: i32;

    x = {
        prinln!("one");
        prinln!("two");
        prinln!("three");
        100
    };

    Burada x'e 100 değeri atanacaktır. Blok içerisindeki deyimlerin ';' ile sonlandırıldığına ancak bloğun sonundaki ifadenin 
    ';' ile sonlandırılmadığına dikkat ediniz. Rust'ta eğer bloğun sonunda bir ifade yoksa o blok "birim türünü" üreti. 
    Örneğin:

    let x = {
        prinln!("one");
        prinln!("two");
        prinln!("three");
    };

    Burada bloğun sonunda bir ifade yoktur, dolayısıyla x değişkeni () türündendir. Anımsanacağı gibi Rust'ta birim türü 
    "olmamayı, boş olmayı" temsil etmektedir. 

    Biz ifadeler ve deyimleri izleyen bölümlerde zaten ele alacağız. Burada ifadesel dil kavramına bir giriş yapmış olduk. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Rust'ta bir fonksiyon bir blok deyiminden oluşmaktadır. Fonksiyonun çağrılması da o blok deyiminin çalıştırılması
    anlamına gelmektedir. Bu nedenle Rust'ta (ve diğer pek çok ifadesel dilde) aslında fonksiyonun ana bloğunun sonundaki 
    ifade aynı zamanda fonksiyonun geri dönüş değerini oluşturmaktadır. Örneğin:

    fn foo() -> i32 {
        println!("foo");
        100
    }

    Burada fonksiyonun geri dönüş değerini oluşturmak için return deyimi yerine doğrudan blok deyiminin ürettiği değer olan 
    100 ifadesi yerleştirilmiştir. Tabii aslında yukarıdaki ile aşağıdaki arasında işlevsel bir farklılık yoktur:

    fn foo() -> i32 {
        println!("foo");
        return 100;
    }

    Şimdi size sanki Rust'ta return deyimi gereksizmiş gibi gelebilir. Ancak fonksiyonun ortasında yani bir bloğun içerisinde 
    fonksiyonu sonlandırmak istediğimizde mecburen yine return deyimini kullanmak zorunda kalırız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            10. Ders 07/04/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta da bazı programlama dillerinde olduğu gibi "iç içe (nested)" fonksiyonlar tanımlanabilmektedir. İç içe fonksiyon 
    tanımlamaları C'de ve C++'ta yoktur. Eski dillerden Pascal'da iç içe fonksiyon tanımlamaları vardı. Nispeten yeni tasarlanan
    Swift, Kotlin gibi programlama dillerinde de bu özellik bulunmaktadır. C# gibi bazı dillere ise bu özellik sonradan eklenmiştir. 
    Örneğin:

    fn foo() {
        //...
        fn bar() {
            //...
        }
        //...
    }

    Burada bar fonksiyonu foo fonksiyonun içerisinde tanımlanmıştır. Bir fonksiyon başka bir fonksiyonun içerisinde tanımlanmışsa
    o fonksiyon ancak tanımlandığı fonksiyonun içerisinden çağrılabilir. Yani dışarıdan iç bir fonksiyon çağrılamamaktadır. 
    Örneğin:

    fn main() {
        foo();
        bar();      // error!
    }

    fn foo() {
        println!("foo");

        fn bar() {
            println!("bar");
        }

        bar();      // geçerli
    }
    
    Bu örnekte br fonksiyonunun main fonksiyonu içerisinden çağrılamadığına foo fonksiyonun içerisinden çağrılabildiğine dikkat
    ediniz.

    Rust'ta fonksiyonlar için prototip bildiriminin bulunmadığını ve zaten buna gerek de olmadığını belirtmiştik. Genel olarak 
    Rust'ta aşağıda tanımlanan bir fonksiyon daha yukarıda çağrılabilmektedir. Dolayısıyla iç bir fonksiyonu aşağıda tanımlayıp 
    daha yukarıda çağırabiliriz. Örneğin:

    fn foo() {
        println!("foo");
        bar();      // geçerli

        fn bar() {
            println!("bar");
        }
    }

    Tabii iç fonksiyonun da geri dönüş değeri söz konusu olabilir. Örneğin:

    fn foo() {
        let val: i32;

        val = bar(10);
        println!("{}", val);

        fn bar(a: i32) -> i32 {
            a * a
        }
    }

    İç içe fonksiyon tanımlamalarının yapıldığı pek çok dilde iç fonksiyonlar dış fonksiyonların yerel değişkenlerini doğrudan
    kullanabilmektedir. Ancak Rust'ta bu mümkün değildir. Örneğin:

    fn foo() {
        let val = 123;

        fn bar() {
            println!("{}", val);        // error!
        }
        //...
    }

    Burada bar içerisinden foo fonksiyonun yerel değişkenlerini kullanamayız.

    Pekiyi iç içe fonksiyon tanımlamalarına neden gereksinim duyulmaktadır? İşt bunun en önemli nedeni iç fonksiyonun dışarıdan 
    gizlenmek istenmesidir. Bir fonksiyon dışarıda tanımlanmışsa kodu inceleyen kişiler o fonksiyonun daha genel bir işlem 
    yaptığını düşünürler. Ancak bir fonksiyon başka bir fonksiyonun içerisinde tanımlanmışsa kodu inceleyen kişiler iç fonksiyonun 
    "genel bir işlem değil yalnızca dış fonksiyon için anlamlı bir işlem yaptığını" düşünürler. Bu düşünce de kodu inceleyenin 
    algısını güçlendirir ve mantıksal karmaşıklığı azaltır. O halde biz eğer bir fonksiyonu yalnızca başka bir fonksiyonun yazımını 
    kolaylaştırmak için tanımlayacaksak onu dışarıda değil ilgili fonksiyonun içerisinde tanımlayabiliriz. Örneğin do_something 
    isimli bir fonksiyon belli bir işin parçalarını foo, bar ve tar fonksiyonlarına yaptırıyor olsun. Bu örnekteki fooi bar ve tar 
    fonksiyonlarının dışarıdan kullanımları anlamlı değildir. Bunlar do_something fonksiyonun yazımını kolaylaştımak amacıyla 
    tanımlanmıştır. O halde bizim bu foo, bar ve tar fonksiyonlarını do_something fonksiyonun içerisinde tanımlamamız daha uygun 
    olur. Örneğin:

    fn do_something() {
        fn foo() {
            //...
        }

        fn bar() {
            //...
        }

        fn tar() {
            //...
        }
        
        //...
        foo();
        //...
        bar();
        //...
        tar();
        //...
    }

    Pekiyi okunabilirlik sağlamak için iç fonksiyonu dış fonksiyonun neresinde tanımlamak uygun olur? Genellikle Rust programcıları
    iç fonksiyonu dış fonksiyonun hemen başında tanımlarlar. Ancak bazı programcılar bunun tam tersini de yapmaktadır. Yani 
    iç fonksiyonu dış fonksiyonun sonunda tanımlamaktadır. Bazı programcılar ise iç fonksiyonu kullanıldığı yerin hemen yukarısında 
    tanımlamayı tercih etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta "ifade (expression)" ve "deyim (statement)" kavramları üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Programlama dillerinde "değişkenlerin, sabitlerin ve operatörlerin her bir bileşimine ifade (expression)" denilmektedir. 
    Örneğin:

    a 
    10
    a + 10
    a[i] + b + 10
    10 + 20

    birer ifadedir. Tek başına bir sabitin ifade belirttiğine, tek başına bir değişkenin ifade belirttiğine ancak tek başına 
    bir operatörün ifade belirtmediğine dikkat ediniz. Bir ifade alt ifadelerden oluşuabilir. Yani bir ifade başka ifadelerin
    operatörlerle bir araya getirilmesinden oluşabilir. Örneği a * b + c * d ifadesi a * b ifadesi ile c * d ifadesinin + operatörü
    ile birleştirilmesiyle oluşturulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta ifadeler iki sınıfa ayrılmaktadır:

    1) Yer belirten ifadeler (place expression)
    2) Değer belirten ifadeler (value expression)

    Yer belirten ifadeler C'deki "sol taraf değeri (lvalue)", yer belirtmeyen ifadeler ise C'deki "sağ taraf değeri (rvalue)" 
    ile aynı anlamdadır. "The Rust Reference" dokümanları bu konuda şöyle demektedir:

    "Note: Historically, place expressions were called lvalues and value expressions were called rvalues."

    Yer belirten ifadeler (place expressions) ismi üzerinde bellekte bir yer belirtmektedir. Dolayısıyla bu ifadelere atama 
    yapılabilir ve bu ifadelerin adresleri alınabilir. Değer ifadeleri ise bellekte bir yer belirtmeyen ifadelerdir. Bir operatörün 
    operand'ı kullanıldığı bağlamda ya yer ifadesi ya da değer ifadesi durumundadır. Örneğin:

    a = b + 10;

    Burada a ifadesi bir yer ifadesi, b ve 10 birer değer ifadesi belirtmektedir. "The Rust Reference" dokümanlarında hangi 
    operatörlerin hangi operand'larının yer belirten ifade olarak ele alınacağı belitrilmiştir. Geri kalan durumlarda operatörlerin 
    operand'ları değer belirten ifade olarak ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Programlama dillerindeki çalıştırma birimlerine "deyim (statement)" denilmektedir. Bir program deyimlerin çalıştırışmasıyla 
    çalışmaktadır. Örneğin aşağıda C'de yazılmış olan kod parçasına bakınız:

    ...
    max = a[0];        
    for (int i = 1; i < size; ++i)
        if (a[i] > max)
            max = a[i];
    printf("%d\n", max);
    ...

    Bu kod parçasında üç deyim vardır. Bunları birer satır boşluk vererek belirtmek istiyoruz:

    max = a[0];    
    
    for (int i = 1; i < size; ++i)
        if (a[i] > max)
            max = a[i];
    
    printf("%d\n", max);

    Burada for döngüsünün tamamının tek bir deyim olduğuna dikkat ediniz. Genel olarak programlama dillerinde for gibi, if 
    gibi programın akışı üzerinde etkili olan deyimlere "kontrol deyimleri (control statements)", Rust Programlama Dilinde 
    ise böyle deyimlere "bloklu deyimler (expression with block)" denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C, C++, Java ve C# gibi imperative dillerin büyük çoğunluğunda bir ifade bir sonlandırıcı (tipik olarak ';') ile sonlandırıldığında
    bu ifade deyim haline gelmektedir. Bu tür deyimlere pek çok programlama dilinde "basit deyim (simple statement)" ya da 
    "ifadesel deyim (expression statement)" denilmektedir. Örneğin:

    max = a[0] 

    biçimindeki atom yığını C'de bir ifade belirtmektedir, deyim belirtmemektedir. Ancak örneğin:

    max = a[0];    

    artık burada ifadenin sonuna ';' yerleştirildiği için bu atom yığını bir deyim belirtmektedir. Benzer biçimde örneğin:

    printf("%d\n", max)

    biçimindeki atom yığını bir ifade belirtirken bunun sonuna ';' yerleştirirsek artık bu bir deyim belirtir hale gelmektedir:

    printf("%d\n", max);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir öğenin kendisi gibi başka öğeleri içermesi durumuna "özyineleme (recursion)" denilmektedir. Doğada ve bilgisayar 
    bilimlerinde özyinelemeyle sıkça karşılaşılmaktadır. Örneğin bir dizin (directory) kendisi gibi dizinleri içerebilmektedir. 
    İşte bir deyim de başka deyimleri içerebilir. Örneğin:

    if koşul {
        ifade1;
        ifade2;
        loop {
            //...
        }
    }
    else {
        ifade3;
        ifade4;
    }

    Burada bloklar da bir deyimdir. Ancak bu bloklar bağımsız birer deyim değil if deyiminin içerisindeki deyimlerdir. Blok 
    deyimlerinin içerisinde de başka deyimler vardır. Bu durumu bir kutunun içerisinde başka kutuların olduğu duruma benzetebiliriz. 
    Örneğin bir kutunun içerisinde birtakım nesneler ve başka kutular olsun. O kutuların içerisinde de başka kutular olsun. 
    Böyle bir kutuya dışarıdan baktığımızda yalnızca bir tane kutu görürüz. Çünkü diğer kutular bu kutunun içerisindedir. 
    İşte benzer biçimde yukarıdaki kod parçasına dışarından bakıldığında tek bir deyim görülecektir. Diğer deyimler buradaki
    if deyiminin içerisindedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ın bir "ifadesel dil (expression language)" olduğunu belirtmiştik. Rust'ta for gibi if gibi bloklu yapılar bir ifade 
    belirtmektedir. "The Rust Reference" dokümanlarında "deyim (statement)" için BNF grameri şöyle verilmiştir:
    
    Statement :
      ;
   | Item
   | LetStatement
   | ExpressionStatement
   | MacroInvocationSemi

   Burada bir deyimin yalnızca bir ';' atomundan(C, Java ve C# gibi  dillerdeki boş deyim), bir program öğesinden (Item),
   bir ifadeden (ExpressionStatement) ve bir makro çağrımından (MacroInvocationSemi) oluşturulabileceği belirtilmektedir. 
   Biz bu gramerdeki ExpressionStatement ara sembolüne "ifadesel deyim" diyeceğiz. Gramerdeki ExpressionStatement ise şöyle 
   açılmaktadır:

   ExpressionStatement :
      ExpressionWithoutBlock ;
   | ExpressionWithBlock ;? 

    Buradaki "ExpressionWithoutBlock ;" bir ifadenin sonuna ';' getirilerek deyim oluşturulabileceğini belirtmektedir. 
    ExpressionWithBlock ise küme parantezlerine sahip olan sentaktik yapıları (yani diğer dillerdeki bileşik deyimleri, if gibi, 
    for gibi deyimleri) belirtir. Gramerdeki ExpressionWithBlock bir ifadenin parçası olmaksızın bu bloklu yapıların tek başına 
    kullanılması durumunu anlatmaktadır. Ayrıca bu BNF gramerine göre ExpressionWithBlock sembülünden sonra ';' yerleştirilebilir
    ya da yerleştirilmeyebilir. Bu gramerden çıkan sonuçları birkaç örnekle açıklamak istiyoruz. Aşağıdaki ifadesel deyime dikkat 
    ediniz:

    x = if (koşul) {
        //...
    }
    else {
        //...
    };

    Burada aslında bir atama işlemi söz konusudur. Dolayısıyla bu kod parçası gramerde "ExpressionWithoutBlock ;" biçiminde
    açılmaktadır. Burada ';' atomunun deyim oluşturmak için ifadenin sonuna yerleştirilmesi zorunludur. Aşağıdaki kod parçasına
    dikkat ediniz:

    if (koşul) {
        //...
    }
    else {
        //...
    }

    Burada bloklu sentaks yapısı kendi başına kullanılmıştır. Dolayısıyla bu sentaks gramerde "ExpressionWithBlock ;?" ile
    açılır. Bu durumda ';' atomunun kullanılıp kullanılmayacağı isteğe bağlıdır. Yani bu gramere göre yukarıdaki if deyimi
    şöyle de yazılabilirdi:

    if (koşul) {
        //...
    }
    else {
        //...
    };  

    Ancak izleyen paragraflarda ele alınacağı gibi eğer bloklu deyimler değer üretiyorsa ("birim (unit)" dışında bir değer 
    üretiyorsa) onların ';' ile sonlandırılması zorunludur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta tıpkı C'de olduğu gibi etkisiz kodlar geçersiz kabul edilmemektedir. Örneğin:

    a + b;
    10 + 20;
    30;
    a[i];

    gibi deyimler pogramda bir durum değişikliği yaratmadığı halde Rust'ta geçerlidir. Tabii etkisiz deyimlerin geçerli olduğu
    programlama dillerinde derleyiciler uyarı mesajı (warning) verebilmektedir. Java ve C# gibi bazı dillerde ise etkisiz 
    ifadelerden deyim yapılamamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta if gibi, while gibi for gibi deyimlerin sonuna bazen açıkça ';' atomunun getirilmesi gerekebilmektedir. Eğer bloklu 
    deyimler bir değer üretmiyorsa (yani () dışında bir değer üretmiyorsa) onların sonuna ';' getirmeye gerek yoktur. Ancak 
    bunlar bir değer üretiyorsa onların sonuna ';' getirilmesi zorunludur. Örneğin:

    if koşul {
        println!("doğru");
    }
    else {
        println!("yanlış");
    }

    Burada if ifadesi bir değer üretmemektedir. (Yani () değeri üretmektedir). Bu durumda bu ifadeyi deyim haline getirmek için 
    ifadenin sonuna ';' getirilmeyebilir. Ancak örneğin:

    if koşul {
        println!("doğru");
        10
    }
    else {
        println!("yanlış");
        20
    };

    Burada if ifadesi bir değer üretmektedir. Artık bunun deyim haline getirilmesi için bunun sonuna ';' getirilmesi gerekir. 
    Tabii yine de yukarıdaki kodda mantıksal bir sorun vardır. Bu kodda if ifadesi değer ürettiği halde bu değer kullanılmamıştır. 
    Bu durumda if ifadesinin bir değer üretmesinin anlamı da kalmamıştır. Örneğin:

    x = if koşul {
        println!("doğru");
        10
    }
    else {
        println!("yanlış");
        20
    };

    Burada artık gramere göre bloklu bir ifade söz konusu değildir. Bu bir atama deyimidir. Atama deyimin solundaki ifade 
    bloklu bir ifadedir. Dolayısıyla buradaki son ';' atama deyiminin sonundaki olması gereken ';' atomudur. 

    Aşağıdaki gibi bir deyim söz konusu olsun:

    if koşul {
        //...        
    }
    else {
        //...
    } [2];

    Burada iki deyim mi vardır yoksa tek deyim mi vardır? İşte Rust derleyicisi burada if ifadesinin bir değer üretip 
    üretmediğine (yani () değerini üretip üretmediğine) bakmaktadır. Eğer if ifadesi bir değer üretmiyorsa bu if ifadesinin
    sonunda ';' olmak zorunda değildir, dolayısıyla burada iki ayrı deyim vardır. Ancak if ifadesi bir değer üretiyorsa burada 
    tek bir deyim vardır. Tabii bu durumda if ifadesinden üretilen değere [] operatörü uygulanamazsa derleme zamanında error
    oluşacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi Rust gramerine göre Rust'taki if gibi while gibi bloklu yapılar bir deyim midir yoksa bir ifade midir? İşte Rust 
    gramerine göre bu bloklu yapılar birer ifadedir. Ancak bunların deyim haline getirilmesi için eğer bu ifadeler bir değer 
    üretmiyorsa ';' kullanmaya gerek yoktur, ancak değer üretiyorsa ';' kullanılması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programlama dilinde ilk öğrenilmesi gereken konulardan biri de dildeki temel operatörlerdir. Bu bölümde Rust'taki 
    temel operatörleri ele alacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Programlama dillerinde bir işleme yol açan ve işlem sonucunda bir değer üretilmesini sağlayan atomlara "operatör (operator)"
    denilmektedir. Örneğin +, -, *, /, >, < birer operatör atomdur. Tabii dillerdeki operatörlerin sayısı fazla olduğunda artık
    klavyedeki özel semboller de yetmediği için anahtar sözcüklerden de operatörler oluşturulmaktadır. Örneğin C'deki sizeof 
    bir sembol olmadığı halde bir operatör belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Operatörler konusunun iyi anlaşılması için öncelikle operatörlerin sınıflandırılması üzerinde durmak gerekir. Operatörler 
    üç biçimde sınıflandırımaktadır:

    1) Operatörün İşlevine Göre
    2) Operand Sayılarına Göre
    3) Operatör Konumuna Göre

    İşlevlerine göre operatörler çeşitli biçimlerde sınıflandırılabilmektedir. Örneğin:

    - Artimetik Operatörler (Arithmetic Operators): +, -, *, / gibi artimetik işlemler yapan operatörlere "aritmetik operatörler"
    denilmektedir. 
    
    - Karşılaştırma Operatörleri (Comparision Operators/Relational Operatos): >, <, >=, <= gibi iki değeri karşılaştıran operatörlere
    karşılaştırma operatörleri denilmektedir. 

    - Mantıksal Operatörler (Logical Operators): Programlama dillerinde AND, OR, NOT gibi mantıksal işlemler yapan operatörlere 
    mantıksal operatörler denilmektedir. 

    - Bit Operatörleri (Bitwise Opeators): Değeri bir bütün olarak değil de bit bit ele alıp bitsel düzeyde işlemleri yapan 
    operatörlerdir. 

    - Adres Operatörleri (Pointer Operators): Adres bilgileri üzerinde işlem yapan yapan operatörlerdir. 

    - Özel Amaçlı Operatörler (Special Purpose Operators): Yukarıdaki amaçların dışında kullanılan operatörlerdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            11. Ders 09/04/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir operatörün işleme soktuğu ifadelere "operand" denilmektedir. Örneğin:
    
    a + b 
    
    ifadesinde + operatör a ve b bu operatörün operand'larıdır. Örneğin:

    a + b * c

    Bu ifadede önce * operatörü yapılacaktır. * operatörünün operand'ları b ve c'dir. + operatörünün operand'ları ise a ve
    b * c'dir. 

    Operand sayılarına göre operatörler üç gruba ayrılmaktadır:

    1) İki Operand'lı operatörler (Binary Operators)
    2) Tek Operand'lı Operatörler (Unary Operators)
    3) Üç operand'lı Operatörler (Ternary Operators)

    Operatörlerin büyük bölümü iki operand'lıdır. Örneğin biz * operatörünü kullanırken onun soluna ve sağına iki operand 
    yerleştiririz. ! operatörü gibi, işaret - operatörü gibi operatörlerin ise tek operand'ı vardır. Örneğin biz iki değeri 
    mantıksal NOT işlemine sokmayız, tek bir değeri mantıksal NOT işlemine sokarız. Nihayet çok seyrek olarak programlama 
    dillerinde üç operand'lı operatörler de bulunabilmektedir. Örneğin C, Java ve C# gibi dillerdeki ?: operatörü üç operand'lı
    bir operatördür. Rust'ta üç operand'lı bir operatör yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Operatörler konumlarına göre de üçe ayrılmaktadır:

    1) Araek Oeratörler (Infix Operatos)
    2) Önek Operatörler (Prefix Operators)
    3) Sonek Operatörler (Postfix Operators)

    Araek operatörler operand'larının arasına getirilerek kullanılır. Örneğin / operatörü araek bir operatördür. Biz bu 
    operatörü a / b biçiminde kullanırız. Operand'ının önüne getirilerek kullanılan operatörlere önek operatörler denir. 
    Örneğin ! operatörü işaret - operatörü önek operatörlerdir. Bazı operatörler ise operand'larının sonuna getirilerek 
    kullanılmaktadır. Bunlara da sonek operatörler denir. Örneğin fonksiyon çağırma operatörü ve [] operatörü sonek 
    operatörlerdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Programlama dillerinde operatörler açıklanırken önce operatörün yukarıda belirttiğimiz üç sınıflandırmada da nereye 
    düştüğü belirtilir. Sonra operatörün ne yaptığı ve diğer özellikleri açıklanır. Örneğin "/ operatörü iki operand'lı araek 
    (binary indifx) bir operatördür, soldaki operand'ın sağdaki operand'a bölüm değerini üretir" gibi. Örneğin "işaret - operatörü 
    tek operand'lı önek (unary prefix) bir operatördür, operand'ının negatif değerini üretir" gibi. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aynı ifade içerisinde birden fazla operatör kullanıldığında bunlar birbirilerine göre belli sırada işleme sokulurlar. 
    Buna "operatörler arasındaki öncelik ilişkisi (operator precedency)" denilmektedir. Örneğin:

    a = b + c * d

    ifadesinde önce * işlemi sonra toplama işlemi sonra atama işlemi yapılır:

    İ1: c * d
    İ2: b + İ1
    İ3: a = İ2

    Aynı öncelikli operatörler kendi aralarında soldan sağa ya da sağdan sola öncelikli yapılmaktadır. Örneğin + ve - operatörleri 
    soldan sağa önceliklidir:

    a = b - c + d - e  

    Burada işlemler şu sırada yapılır:

    İ1: b - c
    İ2: İ1 + d
    İ3: İ2 - e
    İ4: a = İ4

    Ancak örneğin işaret - operatörü sağdan sola önceliklidir:

    a = ---b;

    İ1: -b
    İ2: -İ1
    İ3: -İ2
    İ4: a = İ3

    Operatörler arasındaki öncelik ilişkisi "operatörlerin öncelik tablosu" denilen bir tabloyla betimlenmektedir. Bu tablo 
    satırlardan oluşur. Üst satırdaki operatörler alt satırdaki operatörlerden daha yüksek önceliklidir. Aynı satırdaki
    operatörler eşit önceliklidir. Bu satırların sağında "Soldan Sağa (Left to Right)" ya da "Sağdan Sola (Right to Left)" 
    ibaresi bulunur. Buna İngilizce "Associativity" denilmektedir. Associativity eşit ölçekli operatörlerin hangisinin önce 
    yapılacağını belirtir. "Soldan Sağa" öncelik "o satırdaki operatör aynı ifadede birlikte bulunuyorsa ifade içerisinde hangisi 
    daha soldaysa önce o yapılır" anlamına gelmektedir. "Sağdan Sola" öncelik de ifade içerisinde sağda olan operatör daha önce 
    yapılır" anlamına gelir. 

    Bir operatörü diğer operatörden daha önce işleme sokmak istiyorsanız parantezlerek ona öncelik kazandırmalısınız. Örneğin:

    a = (b + c) * d;

    İ1: b + c
    İ2: İ1 * d
    İ3: a = İ2

    Operatörlerin öncelik tablosunun en yalın hali şöyle oluşturulabilir:

    ()      Soldan Sağa
    * /     Soldan Sağa
    + -     Soldan Sağa
    =       Sağdan Sola

    Burada en tepedeki () hem fonksiyon çağırma operatörünü hem de öncelik parantezini temsil etmektedir. Biz bu yalın tabloyu
    temel alacağız. Operatörleri gördükçe bu tabloya ekleyeceğiz. 

    Operatörlerin öncelik tablosu pek çok programlama dilinin standart dokümanlarında ya da referans kitaplarında verilmemektedir. 
    Çünkü zaten öncelik çoğu durumda BNF gramerinden doğal olarak elde edilmektedir. Yani BNF grameri zaten öncelik tablosunu
    da oluşturmaktadır. Ancak "The Rust Reference" dokümanlarında operatörler arasındaki öncelik ilişkisi ayrı bir başlık altında
    bir tabloyla açıklanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta daha önceden de belirttiğimiz gibi iki operand'lı operatörlerin operand'ları aynı türden olmak zorundadır. Dolayısyla
    Rust'ta "işlem öncesi otomatik tür dönüştürmesi (usual arithmetic conversion)" yoktur. Benzer biçimde Rust'ta "işlem öncesinde
    int türüne dönştürme  (integral promotion)" biçiminde de bir kural da yoktur. Örneğin C'de biz int ile long değeri artimetik 
    işleme sokarsak long türünden bir değer elde ederiz. Ancak Rust'ta i64 ile i32 türlerini zaten işleme sokamayız. Rust'ta 
    operand'lar aynı türden olmak zorunda olduğu için işlemin sonucu da aynı türden olur. Örneğin Rust'ta iki i8 türünden değeri 
    toplarsak sonuç i8 türünden olur. Fakat örneğin C'de iki char türünden değer toplanırsa "int türüne yükseltme kuralı" gereği 
    sonuç int türden elde edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de ce C++17'ye kadar C++'ta artimetik operatörlerin operand'larının ele alınış sırası belirsiz (unspecified) bırakılmıştır. 
    C ve C++ programcılarının önemli bir bölümü operatörlerin öncelik tablosunun etkisi altında kalarak bu kuralı yanlış 
    bilmektedir. Çünkü operatörlerin öncelik tablosu pratik bir anlatım sağlamak için oluşturulmuştur; durumu kesin betimlemek 
    için yetersiz kalmaktadır. Örneğin:

    result = foo() + bar();

    Pek çok C programcısı burada önce foo fonksiyonun çağrılacağını samnmaktadır. Derleyicilerin hemen hepsi böyle yapsa da 
    aslında C standartlarına göre önce bar fonksiyonu da çağrılabilir. Çünkü +, -, * / gibi operatörlerin soldaki operand'ının 
    mı önce ele alınacağı yoksa sağdaki operand'ının mı önce ele alınacağı konusunda bir belirleme yapılmamıştır (unspecified).
    Tabii öncelik tablosuna bakanlar () operatörünün yanında "Soldan Sağa" ibaresini görünce önce foo fonksiyonun çağrılacağını 
    sanmaktadır. Zaten bu nedenden dolayı C'de aşağıdaki gibi bir ifade tanımsız davranış oluşturmaktadır:

    result = a + ++a;

    Çünkü burada + operatörünün sol tarafı önce yapılırsa farklı bir sonuç sağ tarafı önce yapılırsa farklı bir sonuç elde 
    edilir. Tabii kural "önce soldaki operand ele alınır, sonda sağdaki operand ele alınır" biçiminde olsaydı hiçbir karışıklık 
    oluşmazdı. Bu durumda kesinlikle ilk örnekte önce foo fonksiyonu sonra bar fonksiyonu çağrılırdı. İşte temel sentaksı ve 
    semantiği büyük ölçüde C'den alınmış olan Java ve C# gibi dillerde kesinlikle soldaki operand önce ele alınmaktadır. Bu 
    nedenle bu dillerde a + ++a gibi bir ifadeden ne elde edileceği bellidir. Örneğin a'nın içerisinde 3 değeri varsa bu dillerde 
    bu ifade 3 + 4 değerini üretir. (İfade ++a + a biçiminde olsaydı 4 + 4 değerini üretecekti.) C++17'de radikal bir değişiklik 
    yapılarak operand'ların ele alınma sırası "öncek soldaki sonra sağdaki" biçiminde değiştirilmiştir. Dolayısıyla artık C++'ta 
    da a + ++a ve ++a + a gibi ifadeler tanımsız davranış olmaktan çıkmıştır. İşte Rust'ta da aritmetik operatörlerin kesinlikle
    önce soldaki operand'ı sonra sağdaki operand'ı ele alınmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    *, /, + ve - operatörleri iki operand'lı araek aritmetik operatörlerdir. Klasik dört işlemi yaparlar. Öncelik tablosunda 
    * ve / operatörleri, + ve - operatörlerinden daha yüksek öncelikli grupta bulunmaktadır:

    ()      Soldan Sağa
    * /     Soldan Sağa
    + -     Soldan Sağa
    =       Sağdan Sola

    Aritmetik operatörlerde operand'lar aynı türden olmak zorunda olduğuna göre ya sonuç bu türün sınırlarının dışına çıkarsa 
    ne olacaktır? Bu duruma programlama dillerinde "taşma (overflow)" denilmektedir. C ve C++'ta işaretli tamsayı türlerinde 
    taşma oluşursa "tanımsız davranış (undefined behavior)" oluşmaktadır. Ancak işaretsiz tamsayı türlerinde taşma oluşursa 
    yüksek anlmlı bitler atılmakta başka bir deyişle "sarma (wrapping)" yapılmaktadır. C#'ta checked ve unchecked bağlam kavramı 
    vardır. Rust'ta ise taşma olduğunda default durumda panic oluşmaktadır. (panic bir programın umulmadık bir durumla karşılaştığında 
    çökmesi anlamına gelmektedir. Bu nesne yönelimli dillerdeki exception'a benzer bir kavramdır. panic durumu Rust'ta programcı 
    tarafından panic fonksiyonuyla da oluşturulabilmektedir.) Ayrıca Rust derleyicisi taşmayı derleme aşamasında belirleyebiliyorsa 
    error de oluşturabilmektedir. Ancak bu durum "The Rust Reference" dokümanlarında derleyicileri yazanların isteğine bırakılmıştır.
    "The Rust Reference" dokümanları şöyle söylemektedir:
    
    "Outside of const contexts, whether overflow is detected at compile time or not is unspecified and may change across compiler 
    versions."
    
    Örneğin:

    fn foo(a: i8, b: i8) {
        let c: i8;

        c = a + b;
        println!("{}", c);
    }

    Biz bu fonksiyonu aşağıdaki çağırmış olalım:

    let a: i8 = 127;
    let b: i8 = 1;

    foo(a, b);

    Bu çağrıda panic oluşacaktır. Örneğin:

    let a:u8 = 255;
    let b: u8 = 1;
    let c: u8;

    c = a + b;      // bu satırda error oluşabilir

    Burada a + b işlemindeki taşmanın derleme aşamsında kontrol edilip edilmeyeceği derleyicileri yazanların isteğine 
    bırakılmıştır. Kursun yapıldığı zamanda kullanılan Rust derleyicisi bu satırda error oluşturmaktadır. 

    Rust'ta temel türler sanki bir yapıymış gibi de kullanılmaktadır. Bu nedenle i32, f64 gibi temel türler bazı metotlara 
    da sahiptir. Eğer taşma durumunda "sarma (wrapping)" yapılması istiyorsa bu türlerin wrapping_ttt isimli metotları 
    kullanılabilir. Burada ttt işlemin türünü belirtmektedir. Örneğin:

    fn foo(a: i8, b: i8) {
        let c: i8;

        c = a.wrapping_add(b);
        println!("{}", c);
    }

    Şimdi fonksiyonu şöyle çağırmış olalım:

    let a: i8 = 127;
    let b: i8 = 1;

    foo(a, b);

    Artık sarma yapılacağı için +127'den sonraki işaretli sayı -128 olduğu için -128 elde edilecektir. Temel türlerin taşma
    için yalnızca wrapping_xxx metotları yoktur, başka metotları da vardır. Ancak biz bu bağlamda diğer metotlar üszerinde 
    durmayacağız.

    Rust'ta gerçek sayı türlerindeki taşmalarda +inf ya da -inf değerleri üretilmektedir. Geçersiz bir değere sahip işlemlerden 
    de ise NaN değeri elde edilmektedir. "The Rust Reference" dokümanları bu konuda şöyle demektedir:

    "Overflow in floating-point operations does not cause a panic. Instead, the result is ±∞ or NaN, following IEEE 754 rules."
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    % operatörü iki operand'lı araek aritmetik operatördür. Tıpkı C'deki gibi soldaki operandın sağdaki operand'a bölümünden
    elde edilen kalan değerini üretir. Öncelik tablosunda * ve / ile aynı öncelik grubunda bulunmaktadır:

    ()          Soldan Sağa
    * /  %      Soldan Sağa
    + -         Soldan Sağa
    =           Sağdan Sola

    Aslında programlama dillerinde a % b gibi bir işlemin sonucu şöyle oluşturulmaktadır:

    a - a / b * b

    Bu durumda örneğin C, Java, C# ve Rust'ta -10 % 4 işleminin sonucu -2'dir:

    -10 - -10 / 4 * 4 = -2

    Ancak bu dillerde 10 % -4 işleminin sonucu 2'dir:

    10 - 10 / -4 * -4 = 2

    Python'da tamsayılı bölmenin // operatörüyle yapıldığını ve bu operatöre "floordiv" dendiğini anımsayınız. floor işlemi 
    kendisinden "küçük ilk tamsayı anlamına" gelmektedir. Örneğin -2.5 değerinin floor sonucu -3'tür. Bu durumda Python'da 
    -10 % 4 işleminin sonucu 2 olur:

    -10 - -10 // 4 * 4 = 2

    C ce C++ dillerinde % operatörünün iki operandının da tamsayı türlerine ilişkin olması zorunludur. Ancak Rust'ta tıpkı
    C#, Java ve Python'da olduğu gibi bu operatörün operand'ları gerçek sayı türlerine ilişkin de olabilir. Örneğin:

    let a: f64 = 10.5;
    let result: f64;

    result = a % 2.0;
    println!("{}", result);     // 0.5
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            12. Ders 14/04/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta işaret - operatörü vardır ancak gereksiz olduğu nedeniyle işaret + operatörü dile sokulmamıştır. İşaret - operatörü 
    tek operand'lı önek (unary prefix) bir operatördür ve operand'ının negatif değerini (ikiye tümleyen değerini) üretir. Ancak 
    Rust'ta işaret - operatörü işaretsiz tamsayı türlerine uygulanamamaktadır. Yani bu operatörün operand'ı işaretli tamsayı 
    türünden ya da gerçek sayı türünden olmak zorundadır. Halbuki C'de ve C#'ta işaret - operatörü işaretsiz tamsayı türlerine 
    de uygulanabilmektedir. 

    İşaret - operatörü öncelik tablosunda *, / ve % operatörlerinin yukarısında sağdan sola grupta bulunmaktadır:

    ()          Soldan Sağa
    -           Sağdan Sola
    * /  %      Soldan Sağa
    + -         Soldan Sağa
    =           Sağdan Sola

   Örneğin:

    a = ---3;

    Burada işlemler şu sırada yapılacaktır:

    İ1: -3 => -3
    İ2: -İ1 => 3
    İ3: -İ2 => -3
    İ4: a = İ3 => ()
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de, Java'da ve C#'ta bulunan ++ ve -- operatörleri Rust'ta yoktur. Aslında fonksiyonel programlama modelini (functional
    programming paradigm) destekleyen yeni programlama dillerinin bazılarına da bu operatör sokulmamıştır. Örneğin bu operatörler
    Python'da da yoktur. Swift'te eskiden vardı ancak 2.0 versiyonu ile birlikte dilden çıkartıldı. Bu operatörlerin ifade 
    içerisinde yan etkiye yol açması fonksiyonel programlamaya uygun değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta diğer dillerin çoğunda da var olan olan altı karşılaştırma operatörü bulunmaktadır. Bu operatörlerin hepsi iki 
    operand'lı araek (binary infix) operatörlerdir. Karşılatırma operatörleri Rust'ta bool türden değer üretmektedir. Halbuki 
    C'de karşılaştırma operatörlerinin int türden değer ürettiğini anımsayınız. C++ gibi, Java, C# ve Python gibi bool türünün 
    olduğu programlama dillerinde de karşılaştırma operatörleri bool değer üretmektedir. Örneğin:

    let a:i32 = 10;
    let b:i32 = 20;
    let result: bool;

    result = a < b;
    println!("{}", result);     // true

    C'de ve C++'ta karşılaştırma operatörleri de kombine edilerek kullanılabilmektedir. Örneğin:

    result = a == b > c;

    Böyle bir ifade C'de geçerlidir. Burada önce b > c işlemi yapılır. Buradan int türden 1 ya da 0 değeri elde edilir. Bu int 
    değer a ile karşılaştırılır. Ancak Rust'ta bu operatörler parantezsiz biçimde birbirleriyle kombine edilerek kullanılamamaktadır. 
    C'de >, <, >=, <= operatörlerinin öncelik tablosunda ==, != operatörlerinden daha yüksek önclikte bulunduğunu anımsayınız. 
    Rust'ta zaten bunlar parantezsiz biçimde kombine edilemediği için bunların aralarında da bir öncelik ilişkisi de yoktur. 
    Python gibi bazı dillerde karşılaştırma operatörlerinin kombine edilmesi ise tamamen başka bir anlama gelmektedir. Örneğin:

    result = a == b > c

    Bu ifade Python'da aşağıdaki ile eşdeğerdir:

    result = a == b and b > c

    Programlama dillerinin büyük çoğunluğunda karşılaştırma operatörleri artimetik operatörlerden düşük önceliktedir. Rust'ta
    da durum böyledir. Örneğin:

    result = a + b > c + d;

    Burada a + b ile c + d karşılaştırılmaktadır. 

    ()                      Soldan Sağa
    -                       Sağdan Sola
    * /  %                  Soldan Sağa
    + -                     Soldan Sağa
    < > >= <= == !=         Parantezsiz Kombine Edilemez
    =                       Sağdan Sola

    Tüm iki operand'lı aritmetik operatörlerde olduğu gibi karşılaştırma operatörlerinin de operand'larının aynı türden olması
    gerekir. Aksi takdirde error oluşur. Örneğin.

    let a: i32 = 10;
    let b: i16 = 20;
    let result: bool;
    
    result = a > b;     // error! operand'lar farklı türlerden

    Rust'ta karşılaştırma operatörlerinin operand'ları bool türden de olabilmektedir. Karşılaştırma true değerinin false 
    değerinden büyük olduğu kabulü ile yapılmaktadır. Örneğin:

    let mut result: bool;

    result = true > false;
    println!("{}", result);     // true

    result = true == true;
    println!("{}", result);     // true

    Karşılaştırma operatörlerinin parantezsiz kombine edilemediğini belirtmiştik. Ancak parantezler kullanılarak bir karşılaştırma
    operatörünün ürettiği bool değer diğer bir karşılaştırma operatörüne operand yapılabilmektedir. Örneğin:

    let result: bool;

    result = (true > false) == true;
    println!("{}", result);     // true

    Ancak böylesi kullanımlara çok seyrek gereksinim duyulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta da tıpkı C, Java ve C#'ta olduğu gibi üç mantıksal operatör vardır:

    !       Mantıksal NOT operatörü
    &&      Mantıksal AND operatörü
    ||      Mantıksal OR operatörü

    && ve || operatörleri iki operand'lı araek (binary infix), ! operatörü ise tek operand'lı önek (unary prefix) operatörlerdir.
    && ve || operatörleri öncelik tablosunda karşılaştırma operatörlerinden daha düşük öncelikli, ! operatörü ise arirmetik
     operatörlerden daha yüksek önceliklidir:

    ()                      Soldan Sağa
    - !                     Sağdan Sola
    * /  %                  Soldan Sağa
    + -                     Soldan Sağa
    < > >= <= == !=         Parantezsiz Kombine Edilemez
    &&                      Soldan Sağa
    ||                      Soldan Sağa
    =                       Sağdan Sola

    Bu operatörlerin operand'ları bool türden olmak zorundadır. Bu operatörler bool türden değer üretirler. 

    && ve || operatörlerinin diğer dillerde olduğu gibi "kısa devre (short circuit)" özelliği vardır. Bu operatörlerin önce 
    sol tarafındaki ifade yapılır. Eğer && operatörünün sol tarafındaki ifade false ise, || operatörünün sağ tarafındaki ifade 
    true ise bunların sağ tarafındaki ifade hiç yapılmaz, sonuç hemen belirlenir. Tabii && operatörünün solundaki ifade true 
    ise || operatörünün sol tarafındaki ifade false ise gerçekten bu operatörlerin sağ tarafındaki ifadeler de yapılır. Örneğin:

    result = foo() || bar();

    Burada foo ve bar fonksiyonlarının geri dönüş değerlerinin bool türden olması zorunludur. Önce foo fonksiyonu çağrılır. 
    Eğer bu fonksiyondan true değeri elde edilirse bar fonksiyonu hiç çağrılmaz. 
    
    && ve || operatörleri kombine edildiğinde soldaki operatörün sol tarafı önce yapılmaktadır. Bu durum kişilere tuhaf gelebilmektedir.
    Örneğin:

    result = foo() || bar() && tar();

    Her ne kadar && operatörü || operatöründen daha yüksek öncelkliyse de burada önce foo fonksiyonu çağrılır. Eğer foo 
    true değere geri dönerse diğer fonksiyonlar hiç çağrılmaz. Eğer foo false değerine geri dönerse bu durumda bar fonksiyonu
    çağrılır. bar da true değerine geri dönerse tar fonksiyonu çağrılır. Ancak bar false değerine geri dönerse tar fonksiyonu 
    çağrılmaz. Bu durum size && operatörünün || operatörüne göre öncelikli olmasıyla çelişiyormuş gibi gelebilir. Ancak aslında 
    önce && operatörünün yapılmasıyla önce || operatörünün sol tarafınının yapılması arasında elde edilen sonuç bakımından bir 
    farklılık yoktur. Önce foo fonksiyonun çağrılması bu sonucun daha hızlı elde edilemsine yol açmaktadır. Biz önce && sonra 
    || operatörünün işletildiğini varsayalım:

    İ1: bar() && tar()
    İ2: foo() || İ1
    İ3: result = İ2

    && operatörünün ve || operatörünün önce sol tarafı yapılmak zorundadır. Bunun da tek yolu aslında önce foo fonksiyonun 
    çağrılmasıdır. Örneğin:

    result = foo() && bar() || tar();

    Burada da önce foo fonksiyonu çağrılır. Eğer foo false değerine geri dönerse bar fonksiyonu çağrılmaz ama tar fonksiyonu 
    çağrılır. Eğer foo true değerine geri dönerse bar fonksiyonu çağrılır. bar da true değerine geri dönerse tar fonksiyonu 
    çağrılmaz. 

    Rust'ta tıpkı Java ve C#'ta olduğu gibi mantıksal işlemler kısa devre özelliği olmadan da yapılabilmektedir. Bunun için 
    & ve | operatörleri kullanılmaktadır. Bu operatörler aslında bit düzeyinde (bitwise) işlem yapmaktadır. Ancak bu operatörler
    eğer tamsayı türlerine ilişkin operand almayıp bool operand alırlarsa mantıksal işlem yaparlar. Fakat bu durumda kısa devre 
    özelliğine sahip olmazlar. Dolayısıyla Rust'ta & operatörü && operatörünün kısa devre özelliği olmayan biçimi gibi, | operatörü 
    de || operatörünün kısa devre özelliği olmayan biçimi gibi kullanılabilmektedir. Örneğin:

    result = foo() | bar() & tar();

    Burada kısa devre özelliği olmadığı için foo, bar ve tar fonksiyonları önce çağrılır. Sonra & işlemi ve | işlemi yapılır. 
    Dolayısıyla mantıksal işlemler kısa devre özelliksiz yapılmış olur.

    Rust'ta ! operatörü mantıksal NOT işleminin yanı sıra bitsel NOT işlemi de yapmaktadır. Eğer ! operatörünün operand'ı 
    bool türdense operatör true için false, false için true değerini üretir. ! operatörünün sağdan sola öncelik grubunda 
    olduğuna dikkat ediniz. Örneğin:

    result = !!!true

    İ1: !true => false
    İ2: !İ1 => true
    İ3: !İ2 => false
    İ4: result = İ3 

    Aşağıdaki örneği tamel alarak yukarıda anlattıklarımız üzerinde denemeler yapabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let result: bool;

    result = foo() || bar() && tar();
    println!("{}", result);
}

fn foo() -> bool {
    println!("foo");
    false
}

fn bar() -> bool {
    println!("bar");
    false
}

fn tar() -> bool {
    println!("tar");
    false
}

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta bit düzeyinde işlem yapan (bitwise) altı operatör vardır: 

    !           Bit NOT operatörü
    << >>       Sola öteleme ve sağa öteleme operatörleri
    &           Bit AND operatörü
    ^           Bit EXOR operatörü
    |           Bir OR operatörü

    Bu operatörlerin C'de, Java ve C#'ta da bulunduğuna dikkat ediniz. Ancak yukarıda da belirttiğimiz gibi bit düzeyinde NOT 
    işlemi için C'deki ~ operatörü yerine yine ! operatörü kullanılmıştır. Bit operatörleri sayıları bir bütün olarak değil
     bit bit ele alarak işlem yapmaktadır. ! operatörü yukarıda da belirttiğimiz gibi tek operand'lı önek (unary prefix) bir 
     operatördür. Ancak diğer bit operatörlerinin hepsi iki operand'lı araek (binary infix) operatörlerdir. 

    C'de (ve tabii C++'ta) &, ^ ve | operatörleri karşılaştırma operatörlerinden daha düşük önceliklidir. Bu durum C'de uzun 
    süredir eleştirilmektedir. Aşağıdaki C koduna dikkat ediniz:

    if (val & 1 == 0) {
        //...
    }
    else {
        //...
    }

    Burada programcı muhtemelen val değişkeninin en düşük anlamlı bitinin 0 olup olmadığını kontrol etmek istemiştir. Ancak 
    C'de == operatörü & operatöründen daha yüksek öncelikli olduğu için burada önce 1 == 0 karşılaştırması yapılıp buradan 
    0 değeri elde edilir. val & 0 işleminden de 0 elde edileceği için niyet edilen işlemler gerçekleşmez. C'de bu karşılaştırmanın 
    paranteze alınarak yapılması gerekmektedir:

    if ((val & 1) == 0) {
        //...
    }
    else {
        //...
    }

    Halbuki Rust'ta bu üç operatör karşılaştırma operatörlerinden daha yüksek önceliğe sahiptir. Dolayısıyla Rust'ta bu biçimde
    paranteze almaya gerek kalmamaktadır.

    Rust'ta yine tıpkı C'de olduğu gibi bit operatörlerinin de operand'larının tamsayı türlerine ilişkin olması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            13. Ders 16/04/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    & operatörü iki tamsayının karşılıklı bitlerini AND işlemine, | operatörü ise tamsayının karşılıklı bitlerini OR işlemine 
    sokmaktadır. Bu operatörlerin operand'larının yine aynı türden olması gerekir. Örneğin:

    let a: u8 = 0xC5;       // 1100 0101
    let b: u8 = 0x3C;       // 0011 1100
    let mut result: u8;

    result = a & b;
    println!("{:x}", result);     // 4

    result = a | b;
    println!("{:X}", result);     // FD

    Genellikle programcılar bit düzeyinde AND ve OR işlemlerini işaretsiz tamsayı türler üzerinde yaparlar. Ancak işaretli 
    sayılar üzerinde de bu işlemler uygulanabilmektedir. Burada işaretli bir tamsayı türünden değişkene değer atarken bir 
    noktaya dikkatinizi çekmek istiyoruz. Aşağıdaki bağlamaya dikkat ediniz:

    let a: i8 = 0xC3;       // error

    Bu bağlama error ile sonuçlanacaktır. Çünkü sayının kaçlık sistemde yazıldığının sayının türü üzerinde bir etkisi yoktur. 
    Buradaki 0xC3 yazmakla 195 yazmak arasında hiçbir farklılık yoktur. 195 de hedef türün sınırları içerisinde kalmadığı 
    için error oluşmaktadır. 

    Bilindiği gibi EXOR işlemi bitler aynıyken 0 değerini, bitler farklıyken 1 değerini veren bir işlemdir. EXOR geri 
    dönüşümlü bir işlem olduğu için özellikle kriptoloji alanında yaygın biçimde kullanılmaktadır. a ^ b = c ise, c ^ a = b 
    ve c ^ b = a'dır.

    Rust'ta ^ operatörünün iki openad'ı da bool türdense EXOR işlemi bool düzeyde yapılmaktadır. Örneğin true ^ true işlemi 
    geçerlidir ve burada false değeri elde edilir. true ^ false işlemi geçerlidir buradan true değeri elde edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta da C'de (Java ve C#'ta da) olduğu gibi >> (sağa öteleme) ve << (sola öteleme) operatörleri bulunmaktadır. Bu 
    operatörler de iki operand'lı araek operatörlerdir. İşaretsiz bir tamsayı sağa bir kez ötelendiğinde tüm bitler bir sağa 
    kaydırılır sayı en soldan 0 ile beslenir. Bu da aslında sayının 2'ye bölünmesi anlamına gelmektedir. İşaretli negatif 
    tamsayıların sağa ötelenmesi biraz kafa karıştırabilmektedir. Çünkü bu durumda eğer en soldan 0 ile besleme yapılırsa 
    negatif sayı pozitif haline gelir. Negatif sayının negatifliğinin korunması için en soldan 1 ile beslenmesi gerekir. 
    Negatif tamsayıların en soldan  1 ile beslenmesine makine dillerinde "arithmetic right shift" denilmektedir. C Programlama
    Dilinde işaretli negatif tamsayıların sağa ötelnmesinde beslemenin en soldan 0 ile mi yoksa 1 ile mi yapılacağı derleyicileri 
    yazanların isteğini bırakışmıştır (implementation depenedent). Ancak yaygın derleyicilerin hemen hepsi en soldan beslemeyi 
    1 ile yapmaktadır. En soldan besleme 1 ile yapıldığında sayı negatifliği korunarak 2'ye bölünmüş olur. Örneğin bir byte 
    içerisinde (yani i8 olarak) -10 değerini yazalım. bunu önce +10 yazıp 2'ye tümleyenini alarak yapabiliriz:

    0000 1010       +10
    1111 0110       -10

    Şimdi bu -10 değerini işaret bitini koruyarak 1 kez sağa öteleyelim:

    1111  1011       

    Bu sayı -5'tir. Sayının -5 olduğunu 2'ye tümleyenini alarak anlayabilirsiniz:

    0000 0101       +5

    Ancak işaretli negatif tamsayı eğer tek ise kişileri tereddüte sevkeden bir durum oluşmaktadır. -5 sayısının aritmetik 
    biçimde sağa ötelenmesi sonucunda -2 değil -3 değeri elde edilmektedir. Örneğin:

    1111  1011      -5

    Bu sayıyı sağa ötelediğimizde şu bitleri elde ederiz:

    1111 1101       -3

    Bu değerin -3 olduğunu sayının 2'ye tümleyenini alarak anlayabiliriz:

    0000 0011       +3

    Her ne kadar C'de işaretli negatif tamsayıların sağa ötelenmesi derleyiciye bağlı olarak değişebiliyorsa da Rust'ta 
    işaretli negatif tamsayılar sağa ötelendiğinde her zaman en soldan besleme işaret biti korunacak biçimde 1 ile yapılmaktadır.
    Örneğin:

    let a: i8 = -10;            // 1100 0101
    let mut result: i8;

    result = a >> 1;
    println!("{}", result);     // -5

    result = a >> 2;
    println!("{}", result);     // -3

    Bir tamsayı sola bir kez ötelendiğinde tüm bitler bir sola kaydırılır, sayı en sağdan 0 ile beslenir. Bu da sayıyı 2 
    ile çarpmak anlamına gelmektedir. Rust'ta sayı ister işaretli olsun isterse işaretsiz olsun sola öteleme aynı biçimde 
    yapılmaktadır ve taşma dikkate alınmamaktadır. Oysa C'de işaretli bir tamsayı sola ötelenirken taşma olursa bu durumun 
    "tanımsız davranışa (undefined behavior)" yol açtığını anımsayınız. C'de de işaretsiz tamsayılarda her zaman bitler bir 
    sola ötelenmektedir. Örneğin:

    let a: u8 = 0x78;            // 120
    let result: u8;

    result = a << 1;
    println!("{}", result);     // 240 = F0

    Tabii iaşertli bir tamsayı sola ötelenirken taşma nedeniyle işaretini de deiiştirebilir. Örneğin:

    let a = 120;                // hex 78
    let result: i8;

    result = a << 1;
    println!("{}", result);     // -16 hex F0

    Rust'ta genel olarak iki operand'lı operatörlerin operand'larının aynı türden olması gerektiğini belirtmiştik. Ancak 
    öteleme operatörleri buna bir istisna oluşturmaktadır. Öteleme operatörlerinde ötelenecek miktar (yani sağ taraftaki 
    operand) herhangi bir tamsayı türünden olabilir. Ancak öteleme miktarı (yani sağdaki operand'ın değeri) negatifse ya da 
    ötelenecek türün bit uzunluğunu aşarsa panic oluşmaktadır. Örneğin:

    fn main() {
        foo(-5);     // panic oluşur!
        foo(10);     // sorun yok
    }

    fn foo(n: i32) {
        let a: u8 = 1;
        let result: u8;

        result = a << n;
        println!("{}", result);
    }

    "The Rust Reference" dokümanlarına göre ötelenecek değerde (yani sağ taraftaki operand'da) yukarıda bahsettiğimiz anomali 
    eğer derleme aşamasında tespit edilebiliyorsa derleyicileri yazanların isteğine bağlı olarak derleyici error de 
    oluşturabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mantıksal operatörleri ele aldığımız paragrafta da belirttiğimiz gibi Rust'ta ! operatörü hem mantıksal NOT hem de bit
    düzeyinde NOT işlemi yapmaktadır. Yani Rust'ta C'deki bit NOT işlemi için bir ~ operatörü bulunmamaktadır. Örneğin:

    let a: u8 = 0xC5;               // 1100 0101
    let result: u8;

    result = !a;
    println!("{:X}", result);         // 0011 1010 = 3A

    Rust'ta işaretli tamsyılar üzerinde de ! operatörü uygulanabilmektedir. Örneğin:

    let a: i8 = 0x1A;               // 0001 1010
    let result: i8;

    result = !a;
    println!("{:X}", result);         // 1110 1010 = EA
    println!("{}", result);           // -27
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    &, | ve ^ operatörleri kendi aralarında öncelik tablosunda pek çok programlama dilinde şu sırada bulunmaktadır:

    &       Soldan Sağa
    ^       Soldan Sağa
    |       Soldan Sağa

    ! operatörünün tek operand'lı operatörlerin grubunda solduğunu görmüştük. << ve >> operatörleri pek çok programlama dilinde
    hemen aritmetik operatörlerden sonraki satırdadır. Rust'ta (tıpkı Java ve C#'ta olduğu) &, | ve ^ operatörleri karşılaştırma
    operatörlerinden daha yüksek önceliğe konumlandırılmıştır. Konuya girişte de belirttiğimiz gibi C'de durum böyle değildir. 
    Örneğin:

    if x & 1 == 0 {
        //...
    }
    else {
        //...
    }

    Burada önce x & 1 işlemi yapılıp daha sonra karşılaştırma yapılmaktadır. Halbuki C'de önce 1 == 0 işlemi yapılıp bunun 
    sonucu & işlemine sokulmaktadır. 

    Bu operatörleri de yerleştirdiğimizde Rust'ta görmüş olduğumuz operatör için öncelik tablosu şöyle olaacaktır:

    ()                      Soldan Sağa
    - !                     Sağdan Sola
    * /  %                  Soldan Sağa
    + -                     Soldan Sağa
    <<  >>                  Soldan Sağa
    &                       Soldan Sağa
    ^                       Soldan Sağa
    |                       Soldan Sağa
    < > >= <= == !=         Parantezsiz Kombine Edilemez
    &&                      Soldan Sağa
    ||                      Soldan Sağa
    =                       Sağdan Sola
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Atama operatör iki operand'lı araek bir operatördür. Ancak Rust'ta atama işlemi "taşıma" ya da "sahipliği devretme"
    işlemlerini de yapmaktadır. Bu nedenle Rust'taki atama operatörü diğer dillerdeki atama operatöründen daha farklı bir 
    semantiğe sahiptir. Rust'ta yapı gibi bazı türler hedefe atandığı zaman tuttukları kaynakları taşıyabilecek biçimde 
    bir semantik uygulanmaktadır. Ancak atamanın yapıldığı hedef nesne üzerinde "bırakma (drop)" işlemi gerçekleşmektedir. 
    Rust'a özgü olan bu konu Rust için oldukça önemlidir. Biz bu konuyu ayrı başlık halinde ele alacağız. Ancak bu konu 
    C++'taki "taşıma atama operatör fonksiyonuna (move assignment operator function)" oldukça benzemektedir. C++11 ile 
    eklenen bu özelliğe İngilizce "move semantic" denilmektedir. Şimdiye kadar gördüğümz i32, i64, f64 gibi temel türler
    atama sırasında tıpkı C'de olduğu gibi kopyalanmaktadır. Temel türlerin Copy trait'ini desteklediği varsayılmaktadır. 
    Örneğin:

    a = b;

    Burada örneğin eğer a ve b birer yapı türünden değişken ise atama işlemi sırasında önce a bırkılır (drop edilir) sonra
    b'nin sahipliği a'ya devredilir. Yani b'nin içerisindeki bilgiler a'ya taşınır. Bu konu ileride ayrıntılarıyla zaten 
    ele alınacaktır. 

    Rust'ta atama operatörü kombine edilemez. Örneğin aşağıdaki gibi zincirli atama geçerli değildir:

    let a: i32;
    let b: i32;
    let c: i32 = 10;

    a = b = c;          // error!

    Bu durum geçerli olsaydı c'nin sahipliği b'ye, b'nin sahipliği de a'ya aktarılırdı. Bu durumda bu işlemin a = c; 
    işleminden bir farkı kalmazdı. Dolayısıyla a = b = c; gibi bir işlem anlamsız olduğu gerekçesiyle yasaklanmıştır. 
    Aslında teknik olarak Rust'ta atama operatör birim (unit) değerini (yani () değerini) üretmektedir. Biz birim değerini 
    de ancak birim türünden bir değeişkene atayabiliriz. Aşağıdaki atama geçerli fakat anlamlı değildir:

    let a: ();
    let b: i32;
    let c: i32 = 20;

    a = b = c;          // b = c işleminden () elde edilir

    println!("{:?}, {}, {}", a, b, c);          // (), 20, 20

    Burada b = c işlemindne birim değeri elde edildiği için a da birim türünden olduğu için b = c işleminin sonucu a'ya 
    atanabilmiştir. Ancak işleme bir bütün olarak baktığımızda anlamlı gözükmemektedir. 

    Atama operatörünün öncelik tablosunun en sonunda (her ne kadar kombine etmek anlamsızsa da) sağdan sola grupta bulunduğuna 
    dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta da tıpkı C, Java ve C#'ta olduğu gibi "bileşik atama operatörleri de (compund assignment operators)" bulunmaktadır.
    Bunların listesi şöyledir:

    += -= *= /= %= &= |= ^= <<= >>= 

    op bir operatör olmak üzere a op= b tamamen a = a op b ile eşdeğerdir. Bileşik atama operatörleri öncelik tablosunda atama 
    operatöryle sağdan sola aynı gruptadır:

    ()                                      Soldan Sağa
    - !                                     Sağdan Sola
    * /  %                                  Soldan Sağa
    + -                                     Soldan Sağa
    <<  >>                                  Soldan Sağa
    &                                       Soldan Sağa
    ^                                       Soldan Sağa
    |                                       Soldan Sağa
    < > >= <= == !=                         Parantezsiz Kombine Edilemez
    &&                                      Soldan Sağa
    ||                                      Soldan Sağa
    = += -= *= /= %= &= |= ^= <<= >>=       Sağdan Sola

    Bileşik atama operatörlerinden de yine birim (unit) değeri (yani () değeri) elde edilmektedir. Yabi bu operatörler de 
    kombine edilememektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            14. Ders 21/04/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'ta tür dönüştürmelerini göreceğiz. Anımsanacağı gibi Rust'ta bir atama işlemi söz konusu olduğunda kaynak
    türle hedef türün aynı olması gerekiyordu. (Bunun referanslar ve göstericiler bağlamında bazı istisnalar vardır.) Tabii 
    programlama dillerinin büyük çoğunluğunda ilkdeğer verme de, fonksiyon çağırılırken argümanlardan parametre değişkenlerine 
    aktarım da, fonksiyonun geri dönüş değerinin oluşturulması da bir çeşit atama işlemi gibi ele alınmaktadır. Yani bu bağlamlarda 
    da atama işlemindeki semantik uygulanmaktadır. Dolayısıyla Rust'ta nasıl atama operatörünün kaynak ve hedef türleri aynı
    olmak zorundays argümanın türüyle parametre değişkeninin türünün, return ifadesinin türüyle fonksiyonun geri dönüş değeri 
    türünün de aynı olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta farklı türleri birbirine atamak için ya da iki operand'lı operatörlerle işleme sokmak için programcının as operatörü
    ile açıkça tür dönüştürmesi yapması gerekmektedir. as operatörü iki operand'lı araek (binary infix) bir operatördür. Operatörün
    sol tarafındaki operand dönüştürülecek ifadeyi sağ tarafındaki operand dönüştürülecek türü belirtmektedir. Örneğin:

    let a: i32 = 10;
    let b: i16;

    b = a as i16;

    Burada a değişkeni açıkça (explicitly) i16 türüne dönüştürülmüştür. Tabii programlama dillerinde genel olarak tür dönüştürmesi 
    hep geçici nesne yoluyla yapılmaktadır. Yani biz bir ifadeyi bir türe dönüştürürken önce derleyici hedef tür türünden 
    geçici bir nesne oluşturur, kaynak değeri bu geçici nesneye atar, işlemde bu geçici nesneyi kullanır, işlem bitince de 
    geçici nesneyi yok eder. Örneğin:

    b = a as i16;

    Burada a'nın türü i16 olarak değiştirilmemektedir. i16 türünden geçici bir nesne yaratılıp a'nın içerisindeki değer o nesneye 
    atanıp işlemde o nesne kullanılmaktadır. Tabii derleyiciler buradaki geçici nesneyi olnak elveriyorsa CPU'nun yazmaçlarında 
    yaratmaktadır. Yani bu geçici nesnenin yaratılması genellikle bir performans kaybına yol açmaz. 

    Rust'ta iki operand'lı operatörlerin operand'larının da aynı türden olması gerektiğini anımsayınız. Aşağıdaki toplama 
    işlemi operand'lar farklı türlerden olduğu için error ile sonuçlanacaktır:

    let a: i32 = 10;
    let b: i16 = 20;
    let result: i32;
    
    result = a + b;       // error!

    Bu tür durumlarda da bir operand'ın açıkça diğerinin türüne as operatöryle dönüştürülmesi gerekmektedir. Örneğin:

    let a: i32 = 10;
    let b: i16 = 20;
    let result: i32;

    result = a + b as i32;          // geçerli
    print!("{} ", result);          // 30

    as operatörü öncelik tablosunda artimetik operatörlerden daha yüksek öncelikli grupta bulunmaktadır. 

    ()                                      Soldan Sağa
    - !                                     Sağdan Sola
    as                                      Soldan Sağa
    * /  %                                  Soldan Sağa
    + -                                     Soldan Sağa
    <<  >>                                  Soldan Sağa
    &                                       Soldan Sağa
    ^                                       Soldan Sağa
    |                                       Soldan Sağa
    < > >= <= == !=                         Parantezsiz Kombine Edilemez
    &&                                      Soldan Sağa
    ||                                      Soldan Sağa
    = += -= *= /= %= &= |= ^= <<= >>=       Sağdan Sola

    Örneğin:

    result = a + b as i16;

    işleminde operatörler şu sırada işleme sokulacaktır:

    İ1: b as i16 
    İ2: a + İ1
    İ3: result = İ2

    Eğer bir işlem sonucunu bir türe dönüştürmek istiyorsanız parantez kullanmalısınız:

    c = (a + b) as i32;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı dönüştürmeler bilgi kaybına yol açmazlar. Örneğin i16 türünden bir ifadenin i32 türüne dönüştürülmesi sırasında
    bir bilgi kaybı oluşmaz. Genel olarak küçük türden büyük türe yapılan dönüştürmeler bilgi kaybına neden olmamaktadır. 
    C gibi bazı programlama dillerinde temel türlerin her biri diğerine otomatik olarak (implicitly) dönüştürülebilmektedir. 
    Java ve C# gibi bazı dillerde ise yalnızca bilgi kaybına yol açmayacak dönüştürmeler otomatik yapılabilmektedir. Örneğin 
    Java ve C#'ta int türünden long türüne otomatik dönüştürme olduğu için int türü long türüne atanabilmektedir. Ancak long 
    türünden int türüne otomatik dönüştürme olmadığı için long türü int türüne atanamamaktadır. İşte tür dönüştürmeleri ele 
    alınırken bilgi kaybına yol açabilecek dönüştürmelerin nasıl gerçekleştiği üzerinde durulmalıdır. Biz de izleyen paragraflarda 
    tek tek bu durumun üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    - Küçük işaretli tamsayı türünden büyük işaretli tamsayı türüne, küçük işaretsiz tamsayı türünden büyük işaretsiz tamsayı
    türüne yapılan dönüştürmelerde bilgi kaybı oluşmaz. Kaynak değer aynı biçimde hedef türle ifade edilir. 

    - Aynı tamsayı türünün işaretli ve işaretsiz biçimler arasında yapılan dönüştürmelerde sayının bitleri değişmez, yalnızca
    işaret bitinin anlamı değişir. Örneğin:

    let a: i32 = -1;            // 0xFFFFFFFF
    let b: u32;

    b = a as u32;
    println!("{}", b);      // 4394967395

    i32 içerisindeki -1 değeri tüm bitler 1 olan bir değerdir. Tüm bitleri 1 olan bir sayı u32 türünden bir değişkenin içerisine 
    yerleştirilirse bu değer en büyük pozitif sayı haine gelir. Örneğin:

    let a: u32 = 4294967294;            // 0xFFFFFFFE
    let b: i32;

    b = a as i32;
    println!("{}", b);                  // -2

    - Büyük tamsayı türünden (işaretli ya da işaretsiz) küçük tamsayı türüne (işaretli ya da işaretsiz) dönüştürmelerde 
    sayının yüksek anlamlı bitleri atılır, düşük anlamlı bitleri atanır. Ancak eğer kaynak türe ilişkin değer hedef türün 
    sınırları içerisinde kalıyorsa bir bilgi kaybı söz konusu olmaz.
    
    Örneğin:

    let a: i32 = -2;            // 0xFFFFFFFE
    let b: i16;

    b = a as i16;
    println!("{}", b);          // -2

    Burada i32 içerisindeki -2 değeri 0xFFFFFFFE bitlerine sahip olacaktır. Biz yüksek anlamlı 2 byte'ı atıp düşük anlamlı 
    2 byte'ı elde edersek 0xFFFE bitleri oluşur. Bu da zaten i16 türü için -2'dir. Görüldüğü gibi i32 içerisindeki -2 değeri 
    i16 ile temsil edilebildiğinden dolayı bilgi kaybı söz konusu olmamıştır. Örneğin:

    let a: i32 = -2;            // 0xFFFFFFFE
    let b: u8;

    b = a as u8;
    println!("{}", b);          // 254

    Burada yine i32 içerisindeki değerin yüksek anlamlı byte'ları atılıp düşük anlamlı byte'ları elde edilmiştir. Bu da 
    0xFE bitleridir. Tabii bu bitler işaretsiz 1 byte'lık bir değişkenin içerisine yerleştirildiği için 254 olarak ele alınacaktır. 

    - Küçük işaretli tamsayı türünden büyük işaretli ya da büyük işaretsiz türe dönüştürme yapılırken önce küçük işaretli 
    türdeki bitlerin hepsi büyük tamsayı türünün düşük anlamlı bitlerine yerleştirilir. Sonra geri kalan bitler kaynak türe 
    ilişkin değer negatif ise 1'lerle pozitif ise 0'larla doldurulur. Örneğin:

    let a: i8 = -1;             // 0XFF
    let b: u32;

    b = a as u32;
    println!("{}", b);          // 4294967295 = 0xFFFFFFFF

    Burada kaynak türdeki değer işaretli ve negatiftir. 1 byte içerisinde -1 değeri 0xFF bitlerinden oluşmaktadır. Buradaki 
    sayı negatif olduğu için u32'ye dönüştürme yapılırken geri kalan 3 byte 1'lerle doldurulacaktır. Dolayısıyla sayı çok 
    büyük pozitif bir sayı haline gelmektedir. Burada i8 içerisindeki -1 değerinin u32 türüne +1 olarak dönüştürülmediğine 
    dikkat ediniz. Tabii yukarıdaki örnekte küçük türle belirtilen değer pozitf olsaydı doldurma 0 bitleriyle yapılacak ve 
    aslında yine aynı pozitif sayı elde edilecektir. Örneğin:

    let a: i8 = 1;              // 0X01
    let b: u32;

    b = a as u32;
    println!("{}", b);          // 0x00000001 = 1

    Aslında C'de de aynı durum söz konusudur. Yalnızca C standartlarında anlatım değişik yapılmıştır. C standartlarında küçük 
    işaretli tamsayı türünden büyük işaretsiz tamsayı türüne dönüştürmeninm iki aşamada yapılacağı söylenmiştir: Önce kaynak 
    değer hedef türün işaretli biçimine sonra hedef türün işaretli biçiminde işaretsiz biçimine dönüştürülmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    - f32 ya da f64 türünden bir değer tamsayı türlerine dönüştürüldüğünde noktadan sonraki kısım atılır, tam kısım elde 
    edilir. (Noktalı pozitif ya da negatif bir sayının noktadan sonraki kısmının atılmasına İngilize "truncation toward zero" 
    denilmektedir.) Pekiyi sayının noktadan sonraki kısmı atıldıktan sonra tam kısmı hedef türün sınırları içerisinde kalmıyorsa
    ne olacaktır? İşte Rust'ta bu durumda eğer gerçek sayı poiztifse hedef türle ifade edilebilen en büyük pozitif tamsayı, 
    gerçek sayı negatif ise hedef türle ifade edilebilen en küçük negatif sayı elde edilmektedir. Örneğin:

    let f: f64 = 1000.12;
    let b: u8;

    b = f as u8;
    println!("{}", b);      // 255

    Burada 1000.12 sayısının noktadan sonraki kısmı atıldıktan sonra 1000 değeri elde edilir. Ancak bu 1000 değeri hedef tür 
    olan u8'in sınırları dışında kalmaktadır. u8 ile ifade edilecek en büyük pozitif sayı 255'tir. Örneğin:

    let f: f64 = -1000.12;
    let b: i8;

    b = f as i8;
    println!("{}", b);      // -128

    C'de gerçek sayı türlerine ilişkin bir değerin noktadan sonraki kısmı atılıp tam kısmı elde edildiğine bu değer hala 
    hedef türün sınırları içerisinde kalmıyorsa "tanımsız davranış (undefined behavior)" oluşmaktadır. (Ancak C derleyicilerinin 
    hemen hepsi bu tür durumlarda noktadan sonraki kısmı atılmış olan sayının yüksek anlamlı byte'larını atarak dönüşürmeyi 
    yapmaktadır.)

    - Tamsayı türlerinden f32 ve f64 türlerine dönüştürme yapılırken bir bilgi kaybı oluşmayabilir ya da bilgi kaybı oluşabilir. 
    Bu tür durumlarda basamaksal kayıp değil mantis kaybı oluşuyorsa (yani sayının mertebesi aynı ama sayı tam olarak ifade
    edilemiyorsa) dönüştürülmek istenen tamsayıya en yakın hedef türe ilişkin gerçek sayı elde edilir. Burada en yakın demekle 
    dönüştürülmek istenen tamsayıdan büyük ya da küçük olan (yani mutlak değerce) sayı kastedilmektedir. Örneğin i64 türünden 
    bir değer tam olarak f32 türü ile ifade edilemeyebilir. Bu durumda i64 değerine en yakın f32 değeri elde edilmektedir. 
    (Bazen dönüştürülecek tamsayı değere en yakın ondan büyük ve ondan küçük iki gerçek sayı birlikte bulunuyor olabilir. 
    Bu durumda çift olan sayı tercih edilmektedir.) Örneğin:

    let a: i32 = 1234567890;
    let b: f32;

    b = a as f32;
    println!("{}", b);      // 1234568000

    Burada 1234567890 sayısı f32 türü ile tam olarak ifade edilememiştir. Ancak mantis kaybıyla ona en yakın bir sayı elde 
    edilmiştir. 

    Tamsayı türlerinden gerçek sayı türlerine dönüştürme yapılırken aynı basamakta bir sayı elde edilemiyorsa (yani hedef 
    gerçek sayı türünün basamaksal sınırları aşılıyorsa) bu duruma "basamaksal kayıp" denilmektedir. Programlama dillerinde 
    genel olarak basamaksal kayıplar tolere edilmemektedir. Rust'ta eğer dönüştürülecek tamsayı türünden değer hedef türün 
    sınıtları içerisinde kalmıyorsa (yani basamaksal bir kayıp oluşuyorsa) bu durumda kaynak tamsayı pozitifse hedef türdne 
    +inf, kaynak tamsayı negatifse hedef türden -inf değeri elde edilmektedir. Fakat böylesi bir durum ancak u128'den f32 
    yapılan dönüştürmelerde söz konusu olabilir. 

    - f32 türünden f64 türüne dönüştürmelerde bilgi kaybı oluşmaz. Dolayısıyla sayı tam olarak hedef türle ifade edilir. 

    - f64 türünden f32 türüne dönüştürme yapılırken eğer mantis kaybı oluşuyorsa f32 ile temsil edilen dönüştürülecek sayıya 
    en yakın sayı elde edilir. Yine eşit uzaklıkta sayılarda çift olan tercih edilmektedir. Eğer basamaksal bir kayıp söz 
    konusu olursa dönüştürülecek sayı pozitifse +inf, negatifse -inf değeri elde edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            15. Ders 28/04/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    char türü as operatörü ile tamsayı türlerine dönüştürülebilir, ancak f32 ve f64 türlerine dönüştürülemez. char türü tamsayı 
    türlerine dönüştürüldüğünde ilgili karakterin Unicode UTF-32 kod numarasına (code point) ilişkin sayı elde edilmektedir. 
    Rust'ta char türü Unicode UTF-32 kod numaralarını tutabilen 4 byte genişlikte olduğu için char türünün dönüştürüleceği 
    en uygun tamsayı türü de u32 türüdür. Örneğin:

    let c: char = 'a';
    let a: u32;

    a = c as u32;
    println!("a: {}", a);           // 97

    char türü u32 türünden daha küçük türlere dönüştürüldüğünde yüksek anlamlı byte'lar kırpılmaktadır. Örneğin:

    let c: char = 'ş';
    let a: i8;

    a = c as i8;            // kırpılma olacak
    println!("a: {}", a);  

    Rust'ta yalnızca u8 türü as operatörüyle char türüne dönüştürülebilmektedir. Diğer türlerinden char türüne dönüştürme 
    yoktur. Örneğin:

    let c: char;
    let a: u8 = 97;

    c = a as char;
    println!("a: {}", c);       // a
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   bool türü as operatörüyle tamsayı türlerine dönüştürülebilir. Bu durumda true için 1, false için 0 elde edilmektedir. 
   Ancak bool türü gerçek sayı türlerine (f32 ve f64 türlerine) dönüştürülemez. Tamsayı ya da gerçek sayı türlerinden bool 
   türüne de as operatörüle dönüştürme yapılamamakatdır. Örneğin:

    let b: bool = true;
    let a: i32;

    a = b as i32 + 10;
    println!("{}", a);      // 11
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de hangi temel türlerden hangi temel türlere as operatörüyle dönüştürme yapılacağını özet bir tabloyla belirtelim:

    Kaynak Tür                  Hedef Tür                   Dönüştürme Durumu
    -------------------         -------------------         -----------------
    Tamsayı Türleri             Gerçek Sayı Türleri         VAR
    Gerçek Sayı Türleri         Tamsayı Türleri             VAR
    bool Türü                   Tamsayı Türleri             VAR
    bool Türü                   Gerçek Sayı Türleri         YOK
    Herhangi Bir Tür            bool Türü                   YOK
    char Türü                   Tamsayı Türleri             VAR
    char Türü                   Gerçek Sayı Türleri         YOK
    u8 Türü                     char Türü                   VAR
    u8 Dışındaki Türler         char Türü                   YOK
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Temel türleri görürken ! ile temsil edilen "never" isimli bir tür de görmüştük. Bu tür fonksiyonların geri dönüş değerlerinde 
    kullanıldığında fonksiyonların geri dönmeyeceği anlamına geliyordu. Örneğin:

    fn foo() -> ! {
        //...
    }

    Burada foo fonksiyonu çağrıldığında akış bu fonksiyondan geri dönmeyecektir. Yani fonksiyonu yazan kişi derleyiciye fonksiyonun
    geri dönmeyeceği sözünü vermektedir. Ancak programcı bu sözünde durmazsa derleme aşamasında error oluşur. Örneğin:

    fn foo() -> ! {
        println!("foo");
    }

    Burada programcı foo fonksiyonu çağrıldığında fonksiyonun geri dönmeyeceği sözünü vermiştir. Ancak bu sözü yerine getirmemiştir. 
    Buradaki foo fonksiyonu çağrıldığında fonkiyon geri dönecektir. Bu nedenle bu fonksiyonda derleme sırasında error oluşacaktır. 
    Örneğin:

    fn foo() -> ! {
        loop {
        }
    }

    loop deyimi izleyen paragraflarda görecek olduğumuz sonsuz döngü oluşturan bir deyimdir. Dolayısıyla burada foo fonksiyonu 
    geri dönmeyecektir. Programcı verdiği sözü tutumuştur. Örneğin:

    fn foo() -> ! {
        println!("foo");
        std::process::exit(0);
    }

    Burada foo içerisinde exit fonksiyonu ile program sonlandırılmıştır. exit fonksiyonu da ! geri dönüş değerine sahiptir. 
    Dolayısıyla derleyici exit fonksiyonu geri dönmediği için foo fonksiyonun da geri dönmeyeceğini anlar. Kod geçerli olarak
    derlenir. 

    Bir fonksiyonun geri dönmeyeceği bilgisi derleyicinin o fonksiyon için daha kısa bir kod üretmesini sağlamaktadır. C++'a
    bu özellik resmi olarak C++11 ile eklenen [[noreturn]] özniteliği ile gelmiştir. Örneğin:

    [[noreturn]] void foo()
    {
        //...

        exit(0);
    }

    C11 ile C'ye _Noreturn anahtar sözcüğü eklenmiştir. Ancak C23 ile birlikte C'ye de C++'taki gibi öznitelikler (attributes) 
    eklenince bu işlem artık C'de de C++'ta olduğu gibi [[noreturn]] ile yapılabilmektedir. 

    Rust'ta never türü "akış geriye gelmeyecek" anlamına geldiği için never türünden herhangi bir türe otomatik dönüştürme
    vardır. Örneğin:

    fn main() {
        let a: i32;
        
        a = foo();      // geçerli
        //...
    }

    fn foo() -> ! {
        println!("foo");
        std::process::exit(0);
    }

    Burada foo fonksiyonun geri dönüş değeri never türündendir. Never türü de "fonksiyon geriye dönmeyecek" anlamına gelir. 
    Akış zaten geriye dönmeyeceğine göre foo() çağrım ifadesinin herhangi bir türe atanmasında sakınca görülmemiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda tüm temel türler arasındaki dönüştürmeleri gördük. Ancak bu dönüştürmelerin dışında enum dönüştürmeleri ve
    adres dönüştürmeleri bu konuların anlatıldığı bölümlerde ele alınacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdiye kadar klavyeden (stdin dosyasından) okuma yapmadık. Maalesef Rust'ta klavyeden okuma yapmak ancak birkaç satırlık 
    kodla sağlanabilmektedir. Bu birkaç satırlık kod içerisinde henüz görmediğimiz birtakım konular da kullanılmaktadır. Biz 
    de bu bölümde ayrıntılara girmeden klavyeden okumanın kalıp olarak nasıl yapıldığı üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ın stdout dosyası default olarak "satır tabanlı (line buffered)" tamponlanmaktadır. Dolayısıyla yazılanların ekranda
    görünmesi için ya yazının sonuna \n karakterinin iliştirilmesi ya da stdout dosyasının flush edilmesi gerekmektedir. stdout 
    dosyasının flush edilmesi şöyle yapılmaktadır:

    use std::io::Write;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush().expect("cannot flush stdout!..");

    Burada std::io::stdout() çağrısı stdout dosya nesnesine erişmeyi sağlamaktadır. Bu nesneyle yapının flush metodu çağrılmıştır. 
    Ancak flush metodu başarısız da olabilmektedir. Burada expect çağrısının agrümanı flush başarısız olursa stderr dosyasına 
    (default olarak ekrana) basılacak yazıyı belirtmektedir. Bu yazı basıldıktan sonra panic oluşacak ve programın çalışması 
    sonlanacaktır. Tabii stdout dosyasının flush edilmesinde bir sorun ortaya çıkması normal koşullarda mümkün değildir. Aslında 
    biz flush metodunun geri dönüş değerini hiç dikkate almayabilirdik:

    use std::io::Write;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush();

    Ancak bu durumda Rust derleyicisi bir uyarı verecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta klavyeden (stdin dosyasından) i32 gibi bir türden okuma yapmak için önce bir satır String olarak okunur, sonra 
    bu satır parse edilerek hedef türe (örneğin i32 türüne) dönüştürülür. Bu işlem şöyle yapılmaktadır:

    let val: i32;
    let mut s: String = String::new();

    std::io::stdin().read_line(&mut s).expect("cannot read line!..");
    val = s.trim().parse().expect("cannot parse!..");

    Bu kodu satır satır ele alıp açıklayalım:

    let mut s: String = String::new();

    Burada String isimli bir yapı nesnesi içi boş olarak yaratılmaktadır. String yapısı Rust'ın standart kütüpahensinde 
    bulunan string işlemleri yapan bir yapıdır. Bu yapıyı nesne yönelimli programlama dillerindeki string sınıflarına
    benzetebilirsiniz. Şimdi aşağıdaki satırı açıklayalım:

    std::io::stdin().read_line(&mut s).expect("cannot read line!..");

    Burada önce std::io::stdint() çağrısı ile stdin dosyasına ilişkin nesne elde edilmiştir. Bu nesneyle yapının read_line 
    metodu çağrılmıştır. Bu metot klavyeden (stdin dosyasından) bir satır okuyarak okunanları String nesnesinin içine yerleştirmektedir. 
    read_line metodunu çağırırken String nesnesinin adresi &mut operatöryle alınarak metoda verilmiştir. read_line metodu 
    başarısız olabilmektedir. Örneğimizde metrodun başarısı ele alınmış ve eğer metot başarısız olursa (gerçi başarısız olması  
    pek de mümkün değildir) stderr dosyasına bir mesaj bastırılarak panic oluşturulmuştur. Şimdi de aşağıdaki satırı açıklayalım:

    val = s.trim().parse().expect("cannot parse!..");

    read_line metodu klavyeden (stdin dosyasından) bir satır okuduğunda satırın sonundaki '\n' karakterini de String nesnesine 
    yerleştirmektedir. Dolayısıyla bu yazıyı parse etmeden önce bu '\n' karakterinden kurtulmak gerekir. String yapısının trim 
    metodu yazının başındaki ve sonundaki boşluk karakterlerini (white space) atmaktadır. trim metodu string dilimine (&str 
    türüne) geri dönmektedir. Bu string dilimi ile str yapısının parse metodu çağrılmıştır. İşte yazıyı i32 türüne dönüştüren 
    bu parse metodudur. Ancak parse metodu da başarısız olabilmektedir. Aynı gerekçelerle metodun başarısı yine yapının expect 
    metodu ile ele alınmıştır. Eğer parse metodu başarısız olursa stderr dosyasına bir mesaj basılacak ve panic durumu oluşacaktır. 
    Ancak yukarıdaki kodda kişilerin bir nokta kafasını karıştırmaktadır. parse metodu hangi türe dönüştürme yapacağını nereden 
    bilmektedir? İşte bu konu Rust'ın "generic" mekanizmasıyla ilgilidir ve ileride ele alınacaktır. Yukarıdaki kodda derleyici 
    ifade i32 türüne atandığı için i32'ye dönüştürme yapan parse metodunu çağırmaktadır. Örneğin biz yukarıdaki kodda f64 türünden 
    okuma yapmak isteseydik yalnızca val değişkenin türünü değiştirmemiz yeterli olacaktı:

    let val: f64;
    let mut s: String = String::new();

    std::io::stdin().read_line(&mut s).expect("cannot read line!..");
    val = s.trim().parse().expect("cannot parse!..");

    Yukarıdaki işlemleri nit fonksiyona da yaptırabiliriz. Örneğin:

    fn getval() -> i32 {
        let mut buf: String = String::new();

        std::io::stdin().read_line(&mut buf).expect("read line failed");
        buf.trim().parse().expect("parse into number")
    }

    Burada getval fonksiyonu klavyeden okunan i32 türünden bir değerle geri dönmektedir. Bu fonksiyonu farklı bütü okuyacak
    hale getirmek için tek yapılacak şey geri dönüş değerinin türünü değiştirmektir:

    fn getval() -> f64 {
        let mut buf: String = String::new();

        std::io::stdin().read_line(&mut buf).expect("read line failed");
        buf.trim().parse().expect("parse into number")
    }

    Artık fonksiyon f64 türünden (C'deki double türünden) değerle geri dönmektedir. 

    Aslında yukarıdaki fonksiyonu "genel (generic)" biçimde de yazabiliriz. Biz "genel fonksiyonlar (generic functions)" 
    konusunu ileride göreceğiz. Ancak burada açıklama fonksiyonun genelleştirilmiş halini aşağıda veriyoruz.

    fn getval<T>() -> T
    where
        T: std::str::FromStr,
        <T as std::str::FromStr>::Err: std::fmt::Debug,
    {
        let mut buf = String::new();
        std::io::stdin()
            .read_line(&mut buf)
            .expect("cannot read line!..");
        buf.trim()
            .parse::<T>()
            .expect("cannot parse!..")
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::Write;

fn main() {
    let val: i32;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush().expect("cannot flush stdout!");

    val = getval();
    print!("{}\n", val * val);
}

fn getval<T>() -> T
where
    T: std::str::FromStr,
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    let mut buf = String::new();
    std::io::stdin()
        .read_line(&mut buf)
        .expect("cannot read line!..");
    buf.trim()
        .parse::<T>()
        .expect("cannot parse!..")
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Rust'taki if gibi, for gibi temel kontrol deyimlerini ele alacağız. Bazı kontrol deyimleri "kalıp uyuşumu 
    (pattern matching)" konusu ile ilgili olduğu için enum, struct gibi temel veri yapıları görüldükten sonra ele alınacaktır. 
    Rust'ta deyimlerin de birer ifade gibi kullanılabildiğini dolayısıyla deyimlerin de değer ürettiğini belirtmiştik. Bu 
    nedenle Rust dünyasında "if deyimi, while deyimi" gibi terimler yerine "if ifadesi", "while ifadesi" gibi terimler tercih 
    edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    "The Rust Reference" dokümanlarında "deyimler (statements)" için oluşturulan BFN grameri şöyledir:

    Statement :
      ;
      | Item
      | LetStatement
      | ExpressionStatement
      | MacroInvocationSemi

    Burada ExpressionStatement ara sembolü şöyle açılmaktadır:

    ExpressionStatement :
      ExpressionWithoutBlock ;
      | ExpressionWithBlock ;?

    Bu BNF grameri ifadesel deyimlerin iki biçimde oluşturulabileceği belirtilmektedir:

    1) Bir ifadenin sonuna ';' getirilerek o ifade deyim yapılabilir. 
    2) Blok içeren sentaktik yapılar sonunda ';' olmasa da deyim belirtmektedir. 

    Biz daha önceki konularda bloklu yapıların sonunda ifade varsa bloklarının sonuna ';' atomunun getirilmesi gerektiğini 
    görmüştük. Anımsayacağınız gibi blokların sonunda ifade yoksa ya da () ifadesi varsa bloklardan sonra ';' atomunun 
    getirilmesi zorunlu değildir. 

    Gramerdeki ExpressionWithBlock ara sembolü de şöyle açılmıştır:

    ExpressionWithBlock :
      OuterAttribute*†
      (
      BlockExpression
      | ConstBlockExpression
      | UnsafeBlockExpression
      | LoopExpression
      | IfExpression
      | IfLetExpression
      | MatchExpression
      )
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Rust'ta küme parantezi içerisindeki kod parçası da bir deyim dolayısıyla bir ifade 
    belirtmektedir. Blok deyimi de bir değer üretmektedir. Blok deyiminin ürettiği değer bloğun sonundaki ifadedir. Örneğin:

    let result: i32;

    result = {
        println!("this is a block");
        100
    };

    Burada result değişkenşne blok ifadesinin ürettiği değer atanmıştır. Rust gramerinde blok ifadelerinin ExpressionWithBlock
    ara sembolü içerisinde bulunduğuna dikkat ediniz. Daha önceden de belirttiğimiz gibi blok ifadeleri eğer birim dışında 
    (yani () dışında) bir değer üretiyorsa tek başlarına kullanıldığında bloğun sonunda bir ';' gerekmektedir. Örneğin:

    {
        println!("this is a block");
        100
    }               // error!

    Burada blok ifadesi birim değerini üretmediği için bloğun sonunda sonunda ';' bulunmak zorundadır:

    {
        println!("this is a block");
        100
    };               // geçerli

    Tabii yukarıdaki kod geçeli olsa da mantıksal bakımdan anlamsızdır. Blok ifadesinin değeri kullanılmadıktan sonra ondan 
    bir değerin elde edilmesinin anlamı yoktur. Örneğin:

    result = {
        println!("this is a block");
        100
    };

    Buradaki ';' her durumda bulundurulmak zorundadır. Çünkü bu ';' artık atama operatörünün sonundaki ';' durumundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta if ifadesinin genel biçimi şöyledir:

    if <ifade> {
        //...
    }
    [ 
    else {
        //...
    }
    ]

    if anahtar sözcüğünü bool türden bir kontrol ifadesi izlemek zorundadır. Bu kontrol ifadesinin paranteze alınmadığına dikkat 
    ediniz. (C, C++, Java ve C# gibi dillerde if deyimindeki kontrol ifadesinin paranteze alınmasının zorunlu olduğunu anımsayınız.)
    if ifadesinin doğruysa ve yanlışsa kısmında bir blok ifadesinin bulunması zorunludur. (Halbuki C, C++, Java ve C# gibi dillerde 
    eğer if deyiminin doğruysa ve yanlışsa kısmında tek deyim varsa bloklama yapmak zorunlu değildir.) Diğer dillerde olduğu 
    gibi if ifadesinin else kısmı da bulunmayabilir. "The Rust Reference" dokümanlarında if ifadesinin  BNF grameri ise şöyle 
    verilmiştir:

    IfExpression :
      if Expression BlockExpression
      (else ( BlockExpression | IfExpression | IfLetExpression ) )? 

    if ifadesi şöyle çalışmaktadır: Derleyici if anahtar sözcüğünün yanındaki kontrol ifadesinin değerini hesaplar. Eğer bu 
    değer true ise yalnızca doğruysa kısmındaki blok deyimini, false ise yalnızca yanlışsa kısmındaki blok deyimini çalıştırır. 

    if anahtar sözcüğünden sonra neden parantezlerin gerekmediğini (ya da C, C++, Java ve C# gibi dillerde neden gerektiğini) 
    merak edebilirsiniz. Rust'ta if ifadesinin doğruysa ve yanlışsa kısmında bloklama yapmak zorunlu olduğu için bu parantezlere 
    gerek kalmamıştır. Halbuki C, C++, Java ve C# gibi dillerde tek deyim için bloklama zorunlu olmadığından kontrol ifadesiyle 
    if deyiminin doğruysa kısmınadaki ifadenin ayrıştırılabilemsi için parantezler gerekmektedir. Örneğin:

    if (a > 0) x = 10; else  y = 20;

    Burada parantezler olmasaydı kontrol ifadesiyle doğruysa kısmındaki ifade ayrıştırılamazdı. Parantezleri kaldırarak aynı 
    ifadeyi yeniden veriyoruz:

    if a > 0  x = 10; else y = 20;

    Bloklu deyimlerde parantezin bulunmaması Rust'a özgü değildir. Swift, Kotlin, Go, Python gibi dillerde de benzer 
    nedenlerden dolayı kontrol ifadesinin paranteze alınmasına gerek duyulmamaktadır. 

    Tabii biz yine de if ifadesindeki kontrol ifadesini paranteze alabiliriz. Fakat buradaki parantezler artık öncelik 
    parantezi olur. Zaten biz her ifadeyi paranteze alabiliriz. Tabii parantezleri kullanmak iyi bir teknik değildir. Rust 
    derleyicisi bu tür gereksiz parantezlere uyarı da vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                         16. Ders 30/04/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavyeden (stdin dosyasından) okunan i32 türünden bir değerin pozitf olup olmadığı ekrana (stdout 
    dosyasına) yazdırılmıştır. if ifadesi şöyle kullanılmıştır:

    if val > 0 {
        println!("pozitif");
    }
    else {
        println!("negatif ya da sıfır");
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::Write;

fn main() {
    let val: i32;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush().expect("cannot flush stdout!");

    val = getval();

    if val > 0 {
        println!("pozitif");
    }
    else {
        println!("negatif ya da sıfır");
    }
}

fn getval() -> i32 {
    let mut buf: String = String::new();

    std::io::stdin().read_line(&mut buf).expect("read line failed");
    buf.trim().parse().expect("parse into number")
}

/*--------------------------------------------------------------------------------------------------------------------------
    if ifadesinin else kısmında başka bir if ifadesi varsa yazım biraz karnaşık hale gelmektedir. Örneğin:

    if val > 0 {
        println!("pozitif");
    }
    else {
        if val < 0 {
            println!("negatif");
        }
        else {
            println!("sıfır");
        }
    }
    
    İşte bu karmaşıklığı azaltmak için if gramerine şu özellik eklenmştir: "Eğer else anahtar sözcüğünden sonra hemen başka bir 
    if ifadesi geliyorsa bloklama yapmaya gerek yoktur." Bu kural sayesinde else-if merdivenleri daha kolay yazılabilmektedir. 
    Örneğin:

    if val > 0 {
        println!("pozitif");
    }
    else if val < 0 {
        println!("negatif");
    }
    else {
        println!("sıfır");
    }

    Tabii if ifadesinin doğruysa kısmına başka bir if ifadesi yerleştirilecekse içteki if ifadesini blok açmadan yazmanın 
    bir yolu yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    if bir ifade olduğu için bir değer de üretmektedir. Biz if ifadesinden elde edilen değeri doğrudan kullanabiliriz. Örneğin 
    onu bir değişkene atayabiliriz:

    result = if val > 0 {
        //...
        100
    }
    else {
        //...
        200
    };

    if ifadesinin doğruysa ve yanlışsa kısmında aynı türden değerlerin oluşturulması zorunludur. Örneğin:

    result = if val > 0 {
        //...
        10
    }
    else {
        //...
        20.5
    };

    Yukarıdaki kod error oluşturacaktır. Çünkü if ifadesinin kolları aynı türden değer oluşturmamaktadır. 

    if ifadesinin else kısmının olmayabileceğini belirtmiştik. Pekiyi durumda aşağıdaki gibi bir atama işleminde ne olacaktır:

    result = if val > 0 {
        //...
        100
    };

    Burada koşul sağlanıyorsa result değişkenine 100 değeri atanır. Pekiyi ya koşul sağlanmıyorsa? İşte "The Rust Reference"
    dokümanlarında "eğer if ifadesinin else kısmı yoksa sanki boş bir else kısmı varmış ve oradan "birim (unit) değeri elde 
    ediliyormuş gibi bir işlemin" uygulandığı belirtilmiştir. Dolayısıyla yukarıdaki atama işleminde if ifadesinin doğruysa 
    ve yanlışsa kısımları farklı türlerden ifade oluşturduğu için error oluşacaktır. Tabii aşağıdaki gibi bir atama error 
    ile sonuçlanmaz:

    result = if val > 0 {
        //...
        ()
    };

    Burada result değişkeninin birim türünden olması gerekir. Fakat böyle bir atamanın da mantıksal bir anlamı yoktur. 
    O halde Rust'ta else kısmı olmayan if ifadesinden bir değer oluşturmaya çalışmak anlamlı değildir. 

    else-if merdivenlerinde yine her bloğun oluşturduğu değerin aynı türden olması gerekmektedir. Örneğin:

    result = if val == 1 {
        //...
        10
    }
    else if val == 2 {
        //...
        20
    }
    else if val == 3 {
        //...
        30
    }
    else {
        0
    };
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta if ifadesinin yanı sıra if let biçiminde if ifadesine benzeyen başka bir ifade daha vardır. Ancak if let ifadesi
    "kalıp uyuşumu (pattern matching)" özelliği ile çalışmaktadır. Biz kalıp uyuşumunu başka bir başlık altında ve çeşitli 
    konuların içerisine yaydırarak inceleyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir program parçasının yinelemeli olarak çalıştırılmasını sağlayan deyimlere "döngü deyimleri (loop statements)" denilmektedir. 
    Örneğin pek çok programlama dilinde döngü oluşturmak için while ve for deyimleri bulunmaktadır. Bir süredir programlama 
    dillerine "dolaşılabilir (iterable)" nesneleri dolaşan özel for döngüleri de sokulmuştur. Bu for döngülerine örneğin 
    C++11'de "aralık tabanlı for döngüleri (range based loop)", C#'ta foreach döngüleri denilmektedir. Rust'ta deyimler birer 
    ifade gibi olduğu için biz "döngü deyimleri" terimi yerine "döngü ifadeleri (loop expressions)" terimini kullanacağız.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'taki döngü ifadeleri şunlardır:

    - loop döngüleri
    - while döngüleri
    - while let döngüleri
    - for döngüleri

    "The Rust Reference" dokümanlarında döngü ifadeleri için BNF grameri şöyle verilmiştir:

    LoopExpression :
      LoopLabel? (
        InfiniteLoopExpression
        | PredicateLoopExpression
        | PredicatePatternLoopExpression
        | IteratorLoopExpression
        | LabelBlockExpression
   )

    Burada InfiniteLoopExpression ara sembolü loop döngülerini, PredicateLoopExpression ara sembolü while döngülerini, 
    PredicatePatternLoopExpression ara sembolü while let döngülerini, IteratorLoopExpression ara sembolü de for döngülerini
    belirtmektedir. LabelBlockExpression ara sembolü aslında bir döngü belirtmez. Ancak gramer olarak buraya yerleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta loop ifadesi sonsuz döngü oluşturmak için kullanılmaktadır. Genel biçimi şöyledir:

    loop {
        //...
    }

    loop anahtar sözcüğünden sonra bir blok ifadesi bulunmak zorundadır. Döngü sürekli olarak buradaki deyimleri çalıştırır. 
    Örneğin:

    fn main() {
        let mut i = 0;

        loop {
            println!("{}", i);
            i += 1;
        }
    }

    Burada bir sonsuz döngü içerisinde i değişkeni sürekli artırılıp değeri yazdırılmıştır. Tabii ileride göreceğimiz gibi 
    sonsuz döngülerden break ifadesi ile çıkabiliriz. 

    loop ifadesi içerisinde eğer break ifadesi kullanılmamışsa loop ifadesi never türünden (! türünden) değer üretir. Never 
    türünün herhangi bir türe doğrudan dönüştürülebildiğini anımsayınız. Bu durumda biz loop ile oluşturduğumuz sonsuz döngüyü 
    herhangi bir türe atayabiliriz. Ancak bunun bir anlamı olmaz. Örneğin:

    let result: f64;
    
    result = loop {         
        //...
    }

    Bu kod parçası geçerli olsa da anlamsızdır. Zaten loop döngüsünden çıkılamadığına göre onun sonucunu değişkene atamanın 
    da bir anlamı yoktur. Rust terminolojisinde bir akışın bir biçimde geri dönmemesi durumuna "divergent" ya da "diverging"
    denilmektedir. Eğer loop döngüsünden break ile çıkılırsa (yani loop döngüsü "divergent" değilse) bu durumda loop ifadesi 
    break anahtar sözcüğünün yanındaki ifadenin değerini oluşturur. Örneğin:

    fn main() {
        let mut i = 0;
        let result: i32;

        result = loop {
            println!("{}", i);
            i += 1;
            if i == 10 {
                break 100;
            }
        };

        println!("{}", result);       // 100
    }

    Burada loop içerisinden break ifadesi ile çıkılmıştır. Artık loop never değil 100 değerini oluşturmaktadır. Eğer break 
    anahtar sözcüğünün yanında bir ifade kullanılmazsa bu durumda sanki birim (unit) ifadesi kullanılmış gibi işlem yapılır. 
    Örneğin:

    result = loop {
        println!("{}", i);
        i += 1;
        if i == 10 {
            break;
        }
    };

    Burada result birim (unit) türünden olmak zorundadır. Tabii bu durumda loop ifadesinin bir değişkene atanmasının da anlamı 
    kalmamaktadır. loop ifadesinde birden fazla ifadeli break kullanılıyorsa bütün break ifadelerinin de aynı türden olması 
    gerekir. Örneğin:

    result = loop {
        //...
        if ifade1 {
            break 10;
        }
        //...
        if ifade2 {
            break 3.14;     
        }
    }

    Burada eğer result değişken tamsayı türlerine ilişkinse error ikinci break ifadesinde rapor edilecektir. 

    loop ifadesinin bir blok ifadesi içerdiğini belirttik. Ancak loop ifadesindeki bloğun sonuna bir ifade yerleştirilemez. 
    (Halbuki genel olarak blok ifadelerinin sonuna bir ifade yerleştirilebilmektedir.) Örneğin:

    result = loop {
        //...
        100             // anlamsız, error oluşacaktır!
    };

    Burada loop bloğunun sonuna yerleştirilen ifade error oluşturacaktır. Ancak burada ilginç bir durumdan bahsetmek istiyoruz. 
    Aşağıdaki gibi bir döngüde Rust derleyicisi error oluşturmamaktadır:

    result = loop {
        //...
        ()
    };

    Aslında Rust'ta () atomları hem bir ifade hem de bir tür belirtmektedir. Zaten bunun için () atomlarına "birim (unit)" 
    de denilmektedir, "birim türü (unit type)" da denilmektedir. Örneğin aşağıdaki gibi bir bağlama geçerlidir:

    let a: () = ();

    İşte Rust'ta () atomlarının bir tür mü yoksa bir değer mi (yani ifade mi) belirttiğine içinde bulunulan bağlama göre karar 
    verilmektedir. Yukarıdaki loop ifadesinin sonundaki () ifade olamayacağı için Rust derleyicisi tarafından bir tür tanımlaması 
    olarak ele alınmaktadır. Bu da Rust'ta geçerlidir. Yani aşağıdaki gibi bir loop deyimi nasıl geçerliyse yukarıdaki de aynı 
    biçimde geçerlidir:

    result = loop {
        //...
        struct Point {
            x: i32, 
            y: i32
        }
    };

    Dolayısıyla sonu () ile biten loop ifadesi divergent biçimdedir ve yine never türüne ilişkindir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta diğer pek çok programlama dilinde oluduğu gibi while döngüleri de bulunmaktadır. while döngülerinin genel biçimi 
    şöyledir:

    while <ifade> {
        //...
    }

    while anahtar sözcüğünden sonra yine parantez kullanmaya gerek yoktur. Ancak yinelenen deyimler blok içerisinde bulunmak 
    zorundadır. while döngülerinde kontol ifadesinin bool türden olması zorunludur. 

    while döngüsü şöyle çalışmaktadır: Kontrol ifadesinin değeri elde edilir. Eğer bu değer true ise döngü deyimleri (yani 
    blok ifadesi) çalıştırılır ve başa dönülür. Kontrol ifadesi false ise döngüden çıkılır. Yani while döngüleri "koşul 
    doğru olduğu sürece" yinelenmeye yol açmaktadır. 

    Rust'ta kontrolün sonda yapıldığı while döngüleri (yani do-while döngüleri) bulunmamaktadır. Eğer bu tarzda bir algoritmik
    yapı ile kaşılaşırsanız (zaten seyrek karşılaşılmaktadır) bunu kontrolün başta yapıldığı while döngüsü ile sağlamalısınız.
    
    Aşağıda while döngüsünün örnek bir kullanımını görüyorsunuz:

    fn main() {
        let mut i = 0;

        while i < 10 {
            println!("{}", i);
            i += 1;
        }
    }

    Rust'ta atama operatörü birim değerini (yani () değerini) ürettiği için C gibi dillerde çokça yaptığımız "önce ata, sonra
    atanmış değeri karşılaştır" işlemini yapamamaktayız. Örneğin:

    while (val = getval()) != 0 {           // Rust'ta error oluşturur! 
        //...
    }

    Bu durumu sağlamanın bir yolu döngüyü sonsuz döngü biçimine dönüştürmektir:

    loop {
        val = getval();
        if val == 0 {
            break;
        }
        //...
    }

    Ya da aynı şey koşul parantez içerisindeki ifadenin iki kez yazılmasıyla da yapılabilirdi:

    val = getval();
    while val != 0 {           
        //...
        val = getval();
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            17. Ders 05/05/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta while ifadesi her zaman birim değerini (yani () değerini) üretmektedir. Bu nedenle biz while ifadesinde bloğun 
    sonuna bir ifade yerleştiremeyiz. (Bloğun sonuna () ifadesi yerleştirilirse bu bir tür tanımlaması (item) olarak ele 
    alınmaktadır.) Bu durumda Rust'ta while ifadesini bir değişkene atamanın da pratik bir faydası yoktur. Örneğin:

    result = while i < 10 {
        println!("{}", i);
        i += 1;
    };
    println!("{:?}", result);           // ()

    Örneğin:

    result = while i < 10 {
        println!("{}", i);
        i += 1;
        100             // error!
    };

    while bloğunun sonuna bir ifade yerleştirmenin bir anlamı olmadığı için bu sentaks yasaklanmıştır. 

    while döngülerinde de break ifadesi kullanılabilir. Yani while döngüleri de break ile sonlandırılabilir. Örneğin:

    while true {
        println!("{}", i);
        i += 1;
        if i == 10 {
            break;
        }
    };

    Fakat while içerisinde kullanılan break ifadesinin yanına bir ifade yerleştirilemez. ifadeli break yalnızca loop döngüsünde 
    kullanılabilmektedir. Örneğin:

    result = while true {
        println!("{}", i);
        i += 1;
        if i == 10 {
            break 100;      // error! 
        }
    };

    while ifadesi her zaman birim değerini (yani () değerini) üretmektedir. Dolayısıyla while içerisinde ifadeli break 
    kullanmak geçerli değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klavyeden (stdin dosyasından) bir döngü içerisinde getval isimli bir fonksiyonla bir sayı okuyup o sayının karesini 
    yazdırmak isteyelim. Ancak 0 girildiğinde döngüyü sonlandırılacak olsun. Yukarıda da belirttiğimiz gibi bu işlem C, C++, 
    Java ve C# gibi dillerde pratik bir biçimde aşağıdaki gibi yapılabilmektedir:

    while ((val = getval()) != 0) 
        printf("%d\n", val * val);
    
    Ancak Rust'ta atama operatörü birim değerini (yani () değerini) ürettiği için bu işlem yukarıdaki gibi yapılamamaktadır. 
    Bu tür durumalarda loop döngüsünü tercih edebilirsiniz:

    loop {
        val = getval();
        if val == 0 {
            break;
        }
        println!("{}", val * val);
    };
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::Write;

fn main() {
    let mut val;

    loop {
        print!("Bir sayı giriniz:");
        std::io::stdout().flush();
        val = getval();
        if val == 0 {
            break;
        }
        println!("{}", val * val);
    };
}

fn getval() -> i32 {
    let mut buf: String = String::new();

    std::io::stdin().read_line(&mut buf).expect("read line failed");
    buf.trim().parse().expect("parse into number")
}

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta nasıl if ifadesinin kalıp uyuşumuyla çalışan if let isminde bir biçimi varsa while ifadesinin de while let isminde
    kalıp uyuşumuyla çaışan bir biçimi de vardır. Biz while let döngüsünü kalıp uyuşumu (pattern matching) konusundan sora 
    ele acağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta dolaşım (iteratör) mekanizmasıyla çalışan bir for döngüsü de bulunmaktadır. Bu for döngüsü ancak dolaşım (iterator) 
    nesneleriyle kullanılabilmektedir. Biz kurusumuzda  dolaşım (iterator) yapılarının nasıl oluşturulduğunu sonraki bölümlerde 
    göreceğiz. Ancak burada genel olarak Rust'ın for döngüsünü ele alacağız. 

    Dolaşım mekanizmasıyla çalışan döngüler Rust gibi C# gibi yeni programlama dillerinde doğuştan bulunmaktadır. Eski bazı 
    dillere ise bu döngüler belli zamandan sonra eklenmiştir. Örneğin C++'a dolaşım yoluyla çalışan döngüler "aralık tabanlı
    fo döngüleri (range based for loops)" ismi ile C++11 standartlarında eklenmiştir. Java'ya ise bu döngüler 2004 yılında 
    "Java Language Specification 5" ile eklenmiştir. C#'ta bu döngülere foreach döngüleri, Java'da ise "genişletilmiş for 
    döngüleri (enhanced for loops)" denilmektedir. 

    Rust'ta dolaşım mekanizmasıyla çalışan for döngülerinin genel biçimi şöyledir:

    for <kalıp> in <dolaşım_nesnesi> {
        //...
    }

    for anahtar sözcüğünden sonra bir kalıp ifadesi gelmektedir. Burada tipik olarak bir değişken ismi (variable pattern)
    kullanılabilir. Daha sonra bu kalıbı in anahtar sözcüğü ve bir dolaşım nesnesi izler.

    Dolaşım nesneleri dolaşıldığında dolaşan kişiye değerler vermektedir. Nesne her dolaşım sırasında bir değer verir, en 
    sonunda nesnenin verecek değeri kalmadığında dolaşım sonlanır. Rust'taki bazı yapılar zaten dolaşım özelliğine sahiptir.
    Dolayısıyla onları for döngüleriyle dolaşabiliriz. 

    Rust'ta for döngüleri kabaca şöyle çalışmaktadır: Dolaşım nesnesi bir değer verir. Bu değer kalıpla belirtilen değişkenlere
    aktarılır. Döngünün bloğu çalıştırılır. Sonra dolaşım nesnesi yeni bir değer verir bu değer de kalıp belirtilen değişkenlere
    aktarılır yine döngünün bloğu çalıştırılır. En sonunda dolaşım nesnesi artık değer vermez duruma gelir. Çünkü verecek değeri 
    kalmamıştır. Döngü de sonlanır. 

    Rust'ın for döngülerinin bazı dillerdeki for (i = 0; i < 10; ++i) biçimindeki for döngüleri gibi çalılmadığına dikkat ediniz. 
    Rust'ın for döngülerinin iyi anlaşılabilmesi için iki konusunun bilinmesi geremektedir:

    1) Kalıp uyuşumu (pattern matching) konusu.
    2) Dolaşım nesnelerinin nasıl oluşturulduğu konusu.

    Biz bu konuları ilerde ayrı bir bölümde ele alacağız. Ancak burada Rust'ın for döngülerinin temel kullanımı üzerinde 
    duracağız. 

    Dolaşım mekanizmasıyla çalışan for döngülerinin en önemli avantajı "farklı veri yapılarının aynı biçimde dolaşılmasına" 
    olanak sağlamasıdır. Biz bu tür for döngüleriyle tüm dolaşım (iterator) nesnelerini aynı biçimde dolaşabilmekteyiz. Örneğin:

    fn main() {
        let a: [i32;5] = [1, 2, 3, 4, 5];

        for val in a {
            print!("{} ", val);
        }
        println!("");

        let v: Vec<i32> = vec![1, 2, 3, 4, 5];

        for val in v {
            print!("{} ", val);
        }
        println!("");
    }

    Burada bir dizi ve bir vektör nesnesi aynı biçimde dolaşılmıştır. Tabii biz henüz dizileri ve vektörleri görmedik. Yalnızca
    bu örneği aynı biçimde dolaşıma bir örnek olarak verdik.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dolaşım mekanizmasıyla çalışan for döngüleri ile klasik "for (i = 0; i < 10; ++i)" biçimindeki for döngülerini oluşturmak 
    için Rust'ın standart kütüphanesinde Range, RangeInclusive ve RangeFrom  isimli yapılar bulunmaktadır. Dolaşımda kullanılan 
    bu yapılar "genel (generic)" yapılardır. Bir genel yapı kullanılırken tür parametreleri için türler açıkça ya da gizlice 
    belirtilmektedir. Genel bir türün belli türler için açılmasına Rust'ta "monomorfize edilmesi (monomorphize)" denilmektedir. 
    Genel türler kurusumuzda ileride başka bir bölümde ele alınmaktadır. 
    
    Range isimli yapı türünden bir nesne for döngüsü ile dolaşılmak istendiğinde bu nesne dolaşım sırasında start değerinden 
    itibaren end değerine kadar (end değeri dahil değil) tamsayı değerleri vermektedir. Böylece klasik for döngüleri bu Range 
    yapısı yoluyla oluşturulabilmektedir. Örneğin:

    let r: std::ops::Range<i32> = std::ops::Range {start: 0, end: 10};

    for i in r {
        //...
    }
    
    Burada r nesnesi Range<i32> türündendir. Dolaşım sırasında bu nesne 0'tan itibaren 10'a kadar (10 dahil değil) i32 tamsayı
    değerlerini verecektir. Dolayısıyla bu döngü C, C++, Java ve C#'taki aşağıdaki döngüyle işlevsel olarak eşdeğer hale 
    gelmektedir:

    for (int i = 0; i < 10; ++i) {
        //...
    }

    Range yapısının std::ops modülünde bulunduğuna dikkat ediniz. Yazımı kolaylaştırmak için use deyimini kullanabilirsiniz:

    use std::ops::Range;

    let r: Range<i32> = Range {start: 0, end: 10};

    for i in r {
        print!("{} ", i);
    }

    Tabii let deyiminde bağlama yapılırken değişken için tür de belirtilmeyebilir. Örneğin:

    let r = Range {start: 0, end: 10};

    Range nesnesinin yaratılması for döngüsünün içerisinde de yapılabilmektedir. Ancak bu durumda ifadenin paranteze 
    alınması gerekir. Örneğin:

    for i in (Range {start: 0, end: 10}) {
        print!("{} ", i);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik for döngülerine benzer döngüler çok sık oluşturulduğu için Rust'ta Range nesnelerinin .. operatörü ile daha kolay 
    bir biçimde oluşturulmasına olanak sağlanmıştır. .. opertatörüne İngilizce "exlusive range" operatörü denilmektedir. 
    Örneğin:

    for i in 1..10 {
        //...
    }

    biçimindeki for döngüsü tamamen aşağıdakiyle eşdeğerdir:

    for i in (Range {start: 0, end: 10}) {
        //...
    }   

    Range nesnelerinde start değerinin aralığa dahil olduğunu ancak end değerinin aralığa dahil olmadığını bir kez daha 
    vurgulamak istiyoruz. 

    Range nesnesi yaratılıken tür parametresi herhangi bir tamsayı türü olarak belirlenebilir. Ancak tür parametresi f32 
    ya da f64 olursa Range nesnesi dolaşım nesnesi olmaktan çıkmaktadır. Örneğin:

    let r: Range<u8> = Range {start: 0, end: 10};

    for i in  r {
        //...
    }

    Yukarıdaki işlemi .. operatörüyle aşağıdaki gibi de yapabilirdik:

    for i in  0u8..10u8 {
        //...
    }

    Fakat biz Range yapısını f32 ya da f64 türüyle "monomorfize" edersek artık onu for döngüsüyle dolaşamayız. Çünkü nesne 
    dolaşım nesnesi olmaktan çıkar. Örneğin:

    let r: Range<f64> = Range {start: 0., end: 10.};

    for i in  r {           // error! Range<f64> dolaşım nesnesi olmaktan çıktı
        //...
    }

    Tabii biz f64 türünden Range nesnesini .. operatörü ile örneğin 0.0..10.0 biçiminde ya da 0f64..10f64 biçiminde de 
    oluşturabilirdik.

    Pekiyi Range nesnesi ile atlamalı (yani step değeri ile) dolaşım sağlayabilir miyiz? İşte Range yapısının step_by metodu
    parametre olarak atlama miktarını (step miktarını) bizden alır, bize başka bir dolaşım nesnesi verir. Bu dolaşım nesnesini 
    dolaştığımızda artık değerleri atlamalı biçimde elde ederiz. Örneğin:

    let r: Range<i32> = Range {start: 0, end: 10};

    for i in  r.step_by(2) {
        //...
    }

    Burada döngünün her yinelenmesinde sırasıyl 0, 2, 4, 6, 8 değerleri elde ediliecektir. step_by metodunun parametresi 
    usize türündendir. Dolayısıyla biz Range sınıfı ile noktalı artırımlar (örneğin her defasında 0.5 artırım) yapamayız. 
    Noktalı artırımlara pek çok programlama dilinde "sorunlu olduğu gerekçesiyle" izin verilmemiştir. (Eğer noktalı artırım 
    yapılabilseydi yuvarlama hataları nedeniyle bazı durumlarda döngünün yinelenme miktarı farklı olabilirdi.) Artırımlı 
    dolaşım için Rust'ta .. operatörüyle ilgili başka pratik bir sentaks bulunmamaktadır. Bunun en pratik yolu aşağıdaki 
    gibidir:

    for i in  (0..10).step_by(2) {
        //...
    }

    Burada .. operatörünün önceliği nedeniyle paranteze alındığına dikkat ediniz. Öncelik tablosunda .. operatörü düşük 
    bir önceliktedir:

    ()                                      Soldan Sağa
    - !                                     Sağdan Sola
    as                                      Soldan Sağa
    * /  %                                  Soldan Sağa
    + -                                     Soldan Sağa
    <<  >>                                  Soldan Sağa
    &                                       Soldan Sağa
    ^                                       Soldan Sağa
    |                                       Soldan Sağa
    < > >= <= == !=                         Parantezsiz Kombine Edilemez
    &&                                      Soldan Sağa
    ||                                      Soldan Sağa
    .. ..=                                  Parantezsiz Kombine Edilemez
    = += -= *= /= %= &= |= ^= <<= >>=       Sağdan Sola

    Pekiyi elimizde bir dolaşım nesnesi varsa biz onu tersten dolaşabilir miyiz? İşte bir dolaşım nesnesinin tersten dolaşılabilirliği
    o dolaşım nesnesine ilişkin yapıyı yazanlar tarafından belirlenmektedir. Başka bir deyişle eğer dolaşım nesnesine ilişkin 
    yapıyı yazanlar izin vermişse tersten dolaşım mümkün olmaktadır. Range nesnesini tersten dolaşabilmek için Range yapısının 
    rev metodu kullanılmaktadır. rev metodu parametresizdir. rev metodu bize tersten dolaşım yapılabilecek yeni bir dolaşım 
    nesnnesi vermektedir. Örneğin:

    let r: Range<i32> = Range {start: 0, end: 10};

    for i in  r.rev() {
        //...
    }

    Burada yine start değeri aralığa dahildir ancak end değeri aralığa dahil değildir. Yani burada i değişkenine sırasıyla
    9, 8, 7, 6, 5, 4, 3, 2, 1, 0 değerleri yerleştirilecektir. Tabii biz rev metodunun verdiği dolaşım nesnesi üzerinde de 
    yeniden step_by metodunu çağırabiliriz. Örneğin:

    let r: Range<i32> = Range {start: 0, end: 10};

    for i in  r.rev().step_by(2) {
       //...
    }

    Burada i değişkeni sırasıyla 9, 7, 5, 3, 1 değerlerini alacaktır. Tabii biz rev metodunu .. operatörü üzerinde de 
    uygulayabilirdik. Örneğin:

    for i in  (0..10).rev() {
        //...
    }

    Benzer biçimde rev netodunun verdiği dolaşım nesnesi üzerinde yine step_by metodunu uygulayabiliriz:

    for i in  (0..10).rev().step_by(2) {
        //...
    }

    Pekiyi burada rev ve step_by çağrılarının sırasını değiştirirsek ne olur?

    for i in  (0..10).step_by(2).rev() {
        //...
    }

    Burada önce step_by ile verilen dolaşım nesnesi dolaşıldığında 0, 2, 4, 6, 8 değerleri elde edileceğine göre bu değerler 
    de tersten dolaşıldığında i değişkeni sırasıyla 8, 6, 4, 2, 0 değerlerini alacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen dolaşıma end değerinin de dahil edilmesini isteyebiliriz. Örneğin şağıdaki C döngüsünün Rust eşdeğerini yazmak 
    isteyelim:

    for (int i = 0; i <= 10; ++i) {
        //...
    }

    Burada i değişkeni 10 değrini de almaktadır. İşte bunu sağlamak için Rust'ın strandart kütüphanesinde std::ops modülünde 
    RangeInclusive isimli bir yapı bulundurulmuştur. Ancak RangeInclusive yapısının start ve end elemanları private durumdadır. 
    Bu nedenle RangeInclusive nesnesinin yaratılması yapının new isimli "ilişkili fonksiyonuyla (associated function)" 
    yapılmaktadır. Tabii RangeInclusive yapısı da "genel (generic)" bir yapıdır. Örneğin:

    use std::ops::RangeInclusive;

    let ri: RangeInclusive<i32> = RangeInclusive::new(0, 10);
 
    for i in  ri {
        //...
    }

    Burada artık dolaşıma 10 değeri de dahil edilecektir. RangeInclusive nesnesini kolay oluşturabilmek için ..= operatörü 
    de bulundurulmuştur. ..= operatörüne İngilizce "inclusive range" operatörü denilmektedir. Bu durumda yukarıdaki işlemin 
    işlevsel eşdeğeri basit bir biçimde aşağıdaki gibi oluşturulabilmektedir. 
    Örneğin:

    for i in  0..=10 {
        //...
    }

    Burada dolaşıma 10 da dahil edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                        18. Ders 07/05/2025 - Çarşamba       
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    std::ops modülünde RangeFrom isimli bir dolaşım türü daha vardır. RangeFrom isimli yapı start değeri olan ancak end değeri 
    olmayan dolaşımlar için kullanılmaktadır. Bu türden bir nesne for döngüsüyle dolaşılmaya çalışılırsa start değerinden 
    başlanarak artan sırada tamsayılar elde edilir. Ancak end değeri olmadığı için nesne bize sürekli olarak değer verecektir. 
    Böylece bir sonsuz döngü oluşacaktır. Örneğin:

    use std::ops::RangeFrom;

    let rf: RangeFrom<i32> = RangeFrom{start: 5};
    for i in rf {
        //...
    }

    Burada 5'ten başlanarak sürekli artan tamsayılar elde edilecektir. 

    RangeFrom yapısının da genel (generic) bir yapı olduğuna dikkat ediniz. Bu yapı da f32 ve f64 türleriyle "monomorfize 
    (monomophize)" edilirse artık elde edilen nesne dolaşım nesnesi olmaktan çıkmaktadır. 

    .. operatöründe sol taraftaki operand belirtilir ancak sağ taraftaki operand belirtilmezse bu durum RangeFrom nesnesinin 
    yaratılacağı anlamına gelmektedir. Örneğin:

    for i in 5.. {
        //...
    }
    
    Burada 5.. ifadesi RangeFrom nesnesinin yaratılıp kullanılması anlamına gelmektedir. Yani yukarıdaki for ifadesi aşağıdakiyle
    eşdeğerdir:

    for i in (RangeFrom {start: 5}) {
        //...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    std::ops modülünde dolaşım sağlayamayan RangeTo, RangeToInclusive ve RangeFull isimli üç yapı daha vardır. RangeTo yapısı 
    start değeri olmayan ancak end değeri olan bir range nesnesi oluşturmaktadır. Ancak RangeTo yapısı yukarıda da belirttiğimiz 
    gibi bir dolaşım türü (iterator type) değildir. Yani biz bir RangeTo türünden bir nesneyi for döngüsünde kullanamayız. Bu 
    nedenle aşağıdaki kod error oluşacaktır. Örneğin:

    use std::ops::RangeTo;

    let rt: RangeTo<i32> = RangeTo {end: 10};
    for i in rt  {          // error! RangeTo nesnesi bir dolaşım nesnesi değildir
        //...
    }

    Yukarıda for döngüsünde RangeTo nesnesi bir dolaşım nesnesi olmadığı için error oluşacaktır. RangeTo nesnesi de .. operatörüyle
    oluşturulabilmektedir. Bunun için operatörün sol tarafındaki operand'ı boş bırakılır, yalnızca sağ tarafındaki operand'ı 
    belirtilir. Örneğin:

    use std::ops::RangeTo;

    let rt: RangeTo<i32> = ..10;

    RangeTo nesnelerinde end değeri aralığa dahil değildir. RangeTo konusunda iki soru akla gelmektedir: Birincisi "start değerinin 
    kaç olduğu" sorusudur. İkincisi de "bu türden bir nesneyi for döngüsüyle dolaşılmadığına göre bu nesne ne işe yarıyor" sorusudur. 

    RangeTo yapısında start değerinin ne olduğuna yönelik bir açıklamada bulunulmamıştır. Ancak pek çok bağlamda bu değer 0 olarak 
    kabul edilmektedir. RangeTo yapısı aslında değişik bağlamlarda kullanılabilmektedir. Programcılar da kendi yapılarında eğer 
    anlamlıysa RangeTo kullanımını mümkün hale getirebilmektedir. Yani RangeTo yapısı dolaşım amaçlı değil de başka amaçlarla 
    kullanılabilmektedir. Örneğin bir diziyi dilimlerken biz RangeTo nesnesini kullanabiliriz. RangeTo nesnelerinin bu tür kullanımları 
    ilgili konuların ele alındığı yerde açıklanacaktır. 

    RangeTo yapısının semantiğinde end değeri aralığa dahil değildir. Eğer end değerinin de aralığa dahil olması isteniyorsa 
    RangeToInclusive yapısı kullanılmalıdır. RangeToInclusive türünden nesne benzer biçimde yaratılmaktadır:

    let rti: RangeToInclusive<i32> = RangeToInclusive { end: 10 };

    Tabii RangeToInclusive yapısı da bir dolaşım türü belirtmemektedir. Yani bu yapı türünden nesne de for döngüsüyle dolaşılamamaktadır. 
    RangeToInclusive türünden nesne ..= operatörü ile "sol taraftaki operand boş bırakılıp sağ taraftaki operand belirtilerek" 
    de yaratılabilmektedir. Örneğin:

    let rti: RangeToInclusive<i32> = ..=10;

    Son range yapsı da RangeFull isimli yapıdır. RangeFull yapısı genel (generic) bir yapı değildir. Bu yapı da semantik bakımdan 
    start ve end değeri olmayan bir aralık oluşturmak için kullanılmaktadır. Örneğin:

    let rf: RangeFull = RangeFull {};

    RangeFull yapısı da bir dolaşım türü belirtmez. Yani biz bu yapı türünden nesnesiyi de for döngüsünde kullanamayız. Bu yapı 
    çeşitli bağlamlarda "bütünü temsil etmek için" kullanılmaktadır. RangeFull nesnesi .. operatörü ile "operatörün sol tarafındaki 
    ve sağ tarafındaki operand boş bırakılarak" oluşturulabilmektedir. Örneğin:

    let rf: RangeFull = ..;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıda tek tek gördüğümüz range yapılarını bir tablo biçiminde özetleyelim:

    Yapı İsmi               Range Operatör İle Yaratım                  Dolaşılabilirlik
    ------------            --------------------------                  -----------------
    Range                   a..b                                        Dolaşılabilir
    RangeInclusive          a..=b                                       Dolaşılabilir
    RangeFrom               a..                                         Dolaşılabilir
    RangeTo                 ..b                                         Dolaşılamaz
    RangeToInclusive        ..=b                                        Dolaşılamaz
    RangeFull               ..                                          Dolaşılamaz
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta sonek almayan tamsayı sabitlerinin bağlama göre değerlendirildiğini yani ilgili türün sınırları içerisinde 
    kalıyorsa o türden kabul edildiğini belirtmiştik. Bu durum range operatörlerinde de geçerlidir. Örneğin:

    let r: Range<i8> =1..10;

    Burada 1..10 range ifadesindeki 1 ve 10 zaten i8 türünden kabul edilecektir. Yani türlerin aşağıdaki gibi açıkça 
    yazılmasına gerek yoktur:

    let r: Range<i8> =1i8..10i8;

    Tabii bağlam belli değilse sabitlerin i32 türündne olduğu varsayılır. Örneğin:

    let r = 1..10;

    Bu bağlamanın eşdeğeri şöyledir:

    let r = 1i32..10i32;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda 1'den n'e kadar sayıların toplamını döngü yoluyla hesaplayan bir fonksiyon örneği verilmiştir. (Tabii aslında 
    1'den n'e kadar sayıların toplamını döngüyle hesaplamaya gerek yoktur.) 
---------------------------------------------------------------------------------------------------------------------------*/

fn main() {
    let result: i32;

    result = get_total(100);
    println!("{}", result);
}

fn get_total(n: i32) -> i32 {
    let mut total = 0;

    for i in 1..=n {
        total += i;
    }
    total
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir sayının asal olup olmadığını belirleyen isprime isimli bir fonksiyon yazılmıştır. Fonsiyon i32 türünden 
    bir parametreye sahiptir. Eğer girilen argüman asalsa fonksiyonu true değerine asal değilse false değeerine geri dönmektedir.
    Fonksiyon şöyle yazılmıştır:

    fn isprime(val: i32) -> bool {
        let end = (val as f64).sqrt() as i32;

        if val % 2 == 0 {
            return val == 2;
        }
        for i in (3..=end).step_by(2) {
            if val % i == 0 {
                return false;
            }
        }
        true
    }

    Öklit teoremine göre asal olmayan her sayının en az iki asal çarpanı vardır. Bu iki asal çarpanın ikisi de sayının 
    karekökünden büyük olmaz. O halde sayı asal değilse sayının kareköküne kadar (karekökü de dahil) en bir asal çarpanı 
    olmak zorundadır. Yani kontrol sayının karekökükne kadar yapılabilir. Bütün çift sayıları kontrol etmeye de gerek yoktur. 
    En başta sayının çift olup olmadığı yalnızca bir kez kontrol edilebilir. Sonra hep tek sayılarla kontrol yapılabilir. 
    Rust'ta bir sayının karekökü f32 ve f64 türleri üzerinde sqrt metodu çağrılarak elde edilebilir. Yukarıdaki isprime 
    fonksiyonunun parametresi i32 türündendir. Bu nedenle önce bu parametre f64 türüne dönüştürülüp sqrt metodu çağrılmıştır. 
    Tabii elde edilen değer yeniden i32 türüne dönüştürülmüştür. Aşağıda 2'den kalvyedne girilen sayıya kadarki tüm asal 
    sayılar yazdırılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::{stdin, Write};

fn main() {
    let val: i32;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush().expect("Can't flush stdout");
    val = getval();

    for i in 2..=val {
        if isprime(i) {
            print!("{} ", i);
        }
    }
}

fn isprime(val: i32) -> bool {
    let end = (val as f64).sqrt() as i32;

    if val % 2 == 0 {
        return val == 2
    }
    for i in (3..=end).step_by(2) {
        if val % i == 0 {
            return false;
        }
    }
    true
}

fn getval() -> i32 {
    let mut buf: String = String::new();

    stdin().read_line(&mut buf).expect("cannot read line..");
    buf.trim().parse().expect("not a number")
}

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta diğer pek çok dilde de olduğı gibi break ifadesi bulunmaktadır. Biz de zaten break ifadesini bazı örneklerimizde 
    kullanmıştık. break ifadesinin genel biçimi şöyledir:

    break [etiket] [ifade];

    "The Rust Reference" dokümanlarında "break ifadesi" yerine "break ifadesi" terimi kullanılmıştır. Tabii break anahtar 
    sözcüğünün yanına ';' konulduğunda zaten bu ifade de bir deyim olmaktadır. Biz kursumuzda "break ifadesi" demeyi tercih 
    edeceğiz.  

    break ifadesi döngü deyimini sonlandırmak için kullanılmaktadır. Genel biçimden break anahtar sözücüğünün yanında bir etiket 
    (label) bulunabileceği anlaşılmaktadır. Pekiyi bu etiket ne anlama gelmektedir? İşte eğer break ifadesi etiketsiz kullanılırsa 
    yalnızca içinde bulunduğu döngü deyimini sonlandırmaktadır. Örneğin:

    for i in 0..10 {
        for k in 0..10 {
            println!("({}, {})", i, k);
            if i == 5 && k == 5 {
                break;
            }       
        }
    }

    Burada i == 5 ve k == 5 durumunda programın akışı break ifadesini görecektir. Ancak yalnızca içteki döngü sonlanacaktır. 
    Anımsanacağı gibi C, C++, C# gibi dillerde iç bir döngüde tek hamlede tüm döngülerden çıkmak için goto deyimi kullanılıyordu. 
    Ancak Java gibi Rust gibi bazı dillerde goto deyimi bulunmamaktadır. İşte bu dillerde iç döngüden tek hamlede çıkışı sağlamak 
    için etiketler kullanılmaktadır. Döngü deyimlerinin BNF gramerini hatırlayalım, şöyleydi:

    LoopExpression :
      LoopLabel? (
        InfiniteLoopExpression
        | PredicateLoopExpression
        | PredicatePatternLoopExpression
        | IteratorLoopExpression
        | LabelBlockExpression
      )

    Bu gramerde tüm döngü deyimlerinin başında isteğe bağlı olarak bir etiketin (label) bulunabileceği anlaşılmaktadır. Rust'ta 
    etiketler tek tırnak karakterine yapışık bir değişken isminden oluşmaktadır. Döngü etiketlerinde yine etiket isminden 
    sonra ':' atomu da kullanılmak zorundadır. Örneğin:

    'lbl: loop { 
        //...
    }

    Burada 'lbl etiketi belirtmektedir. İşte break işlemi yapılırken break anahtar sözcüğünün yanına "hangi döngünün kırılacağını
    belirten" bir etiket getirilebilmektedir. Örneğin:

    'lbl: loop {
        i += 1;
        if i == 10 {
            break 'lbl;
        }
        println!("{}", i);
    }

    Tabii iç içe döngü söz konusu olmadıktan sonra döngüye etiket iliştirmenin ve etiketli break kullanmanın anlamı yoktur. 
    Fakat iç içe döngülerden tek hamlede çıkmak için etiketli break kullanmak gerekir. Örneğin:

    'lbl:
    for i in 0..10 {
        for k in 0..10 {
            println!("({}, {})", i, k);
            if i == 5 && k == 5 {
                break 'lbl;
            }
        }
    }

    Burada break ile tek hamlede iki döngüden de çıkılmıştır. Döngü bir etikete sahipse ancak break ifadesinde etiket 
    kullanılmamışsa Rust derleyicisi uyarı vermektedir. 

    Biz daha önce break ifadesinin yanında bir ifade de kullanmıştık. Rust'ta ifadeli break yalnızca loop döngüsü içerisinde 
    kullanılabilmektedir. Bu durumda loop döngüsü "divergent" olmaktan çıkıp break ifadesindeki değeri üretiyordu. Örneğin:

    let mut i = 0;
    let result: i32;

    result = loop {
        println!("{}", i);
        i += 1;
        if i == 10 {
            break 1000;
        }
    };
    println!("{}", result);

    Burada ifadeli break ifadesi nedeniyle loop döngüsünden i32 türünden değer elde edilmiştir. Tabii loop döngüsü içerisinde 
    hem etiket hem de ifade birlikte kullanılabilir. Örneğin:

    let mut i = 0;
    let result: i32;

    result = 'lbl: loop {
        //...
        i += 1;
        if i == 10 {
            break 'lbl 1000;
        }
    };
    println!("{}", result);

    Burada break anahtar sözcüğünde önce etiket sonra ifade bulundurulmuştur. Bunları ters sırada yerleştiremeyiz. Burada 
    bir kez daha anımsatmak istiyoruz: ifadeli break ifadesi yalnızca loop döngüsü içerisinde kullanılabilmektedir. while 
    ve for döngülerinde kullanılamamaktadır. Örneğin:

    let result = for i in 0.100 {
        //...
        if i == 5 {
            break 1000;         // error
        }
    }

    C, C++, Java ve C# gibi dillerde break ifadesi o dillerin switch deyimleri içerisinde de kullanılabilmektedir. Rust'taki 
    switch benzeri deyime match deyimi denilmektedir. match deyimi içerisinde break kullanımı yoktur.

    break ifadesinin kendi ürettiği değer (yani deyimin yerleştirildiği yerden elde edilen değer) ! türündendir. Yani break 
    ifadesi divergent biçimdedir. ! türünün herhangi bir türe otomatik dönüştürüldüğünü anımsayınız. Bu durumda örneğin anlamlı
    olmasa da biz break ifadesini herhangi bir değişkene atayabiliriz:

    loop {
        //...
        if ifade {
            x = break;      // x hangi türden olursa olsun geçerli!
        }
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            19. Ders 12/05/2025 - Pazartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Burada konuya devam etmeden önce sınıfta sorulan bir sorunun yanıtı hakkkında bir açıklamada bulunmak istiyoruz. Soru 
    şöyle: "Neden aşağıdaki kodda break ifadesinden sonra ';' konulmadığında error ortaya çıkmıyor?". Yani aşağıdaki kodda 
    neden ';' bulunmaması soruna yol açmıyor?

    fn main() {
        let mut i = 0;
        let result: i32;

        result = loop {
            if i == 10 {
                break 1000
            }
            println!("{}", i);
            i += 1;
        };

        println!("\n{}", result);
    }

    Burada break ifadesi if ifadesinin doğruysa bloğunun son ifadesi durumunda olduğu için, blokların da değer üretmesinden 
    dolayı ';' kullanılmasa da ifade geçerli olmaktadır. break ifadesinin ! türünden değer ürettiğini anımsayınız. Bu durumda 
    if ifadesinin else kısmı olmadığı için else kısmından () değerinin elde edildiği kabul edilmektedir. ! türü de her türe 
    otomatik dönüştürülebildiği için bu if ifadesinden () değeri elde edilecektir. Tabii burada if ifadesinin else kısmı olsaydı 
    ve else kısmından başka türdne bir değer elde edilseydi kod anlamsız fakat yine geçerli olurdu. Örneğin:
    Örneğin:

    fn main() {
        let mut i = 0;
        let result: i32;

        result = loop {
            if i == 10 {
                break 1000
            }
            else {
                //...
                100         // anlamsız ama geçerli
            };
            println!("{}", i);
            i += 1;
        };

        println!("\n{}", result);
    }

    Burada if ifadesinden i32 türünden değer elde edilecektir. Ancak bu değer kullanılmadığı için else kısmın bir değer 
    üretmesi anlamsızdır. 

    Tabii if ifadesinin hem doğruysa hem de yanlışsa kısmında break ifadesi varsa bu durumda if ifadesi de ! türünden değer 
    üretir. Örneğin:

    loop {
        //...
        if koşul {
            //...
            break
        }

        else {
            //...
            break
        }
    }

    Burada if deyimi ! türünden değer vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta aslında bir döngü belirtmediği halde gramerde LoopExpression ara sembolünün altına yerleştirilen ve ismine 
    "etiketli block ifadesi (labeled block expression)" denilen bir deyim daha vardır. LoopExpression ara sembolünün açılımını
    aşağıda yeniden veriyoruz:

    LoopExpression :
    LoopLabel? (
      InfiniteLoopExpression
      | PredicateLoopExpression
      | PredicatePatternLoopExpression
      | IteratorLoopExpression
      | LabelBlockExpression
   )

   Bir blok ifadesi içerisinde break ifadesi kullanılabilir. Ancak bu durumda break ifadesinde bir etiketin olması ve bloğun 
   başında da bir etiketin bulunması gerekir. Örneğin:

    val = getval();
    'a: {
        println!("block begins");
        if val > 0 {
            break 'a;
        }
        println!("block ends");
    };

    Bu blok ifadesi geçerlidir. İşte bu blok ifadesine "etiketli blok ifadesi" denilmektedir. Yukarıda da belirttiğimiz 
    gibi bir bloğun içerisinde break ifadesinin kullanılabilmesi için break ifadesinin etiketli olması zorunludur. Örneğin:

    val = getval();
    {
        println!("block begins");
        if val > 0 {
            break;          // error!
        }
        println!("block ends");
    };

    Bu blok ifadesinde break etiketsiz kullanıldığı için error oluşacaktır. Etiketli blok ifadelerinde hiç break kullanılmaması 
    error oluşturmasa da anlamsız olduğu gerekçesiyle uyarı mesajı oluşturmaktadır. Örneğin:

    'a: {
        println!("block begins");
        //...
        println!("block ends");
    };

    Yukarıdaki kod geçerlidir fakat bloğa etiket iliştirilmesi anlamsız olduğu için uyarı oluşturacaktır. Tabii etiketli blok 
    ifadelerindeki break ifadesinde break anahtar sözcüğünün yanında hem etiket hem de ifade bulunabilir. Bu durumda önce etiketin 
    sonra ifadenin bulundurulması zorunludur. Örneğin:

    val = getval();
    result = 'a: {
        println!("block begins");
        if a > 0 {
            break 'a 100;
        } 
        println!("block ends");
    };
    println!("{}", result);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pek çok programlama dilinde bulunan break ifadesi Rust'ta da bulunmaktadır. break ifadesinin genel biçimi şöyledir:

    continue [etiket];

    continue anahtar sözcüğü de sonunda ';' olmazsa bir ifade gibi kullanılabildiği için biz "break ifadesi" yerine "continue 
    ifadesi" demeyi tercih edeceğiz.  

    break ifadesi ancak döngü deyimlerinin içerisinde kullanılabilir. Etiketli blok deyimi içerisinde continue kullanılamaz. 
    Programın akışı break ifadesini gördüğünde akış sonraki yinelemeye geçer. Yani break ifadesi döngü deyimini değil döngü 
    deyimi içerisindeki blok ifadesini sonlandırmaktadır. break ifadesinin döngü deyimini sonlandırdığına continue deyiminin 
    ise döngünün içerisindeki blok ifadesini sonlandırdığına dikkat ediniz. Döngü içerisindeki blok ifadesi bittiğinde ne oluyorsa 
    progamın akışı break ifadesini gördüğünde aynısı olmaktadır. Örneğin:

     for i in 0..10 {
        if i % 2 == 0 {
            continue;
        }
        println!("{}", i);
    }

    Burada ekrana tek sayılar basılacaktır. Programın akışı break ifadesini gördüğünde sanki döngü içerisindeki blok sonlanmış
    gibi bir etki oluşacağı için Range iteratörü de yeni bir değer verecektir. 

    Genel biçimden contine deyiminin de bir etikete sahip olabileceğini görüyorsunuz. Diğer pek çok dilde iç içe döngülerde 
    continue yalnızca kullanıldığı döngünün deyimini sonlandırmaktadır. Ancak Rust'taki bu etiket sayesinde iç içe döngülerde 
    dıştaki döngü üzerinde de continue yapılabilmektedir. Örneğin:

    'a: for k in 0..10 {
        for i in 0..10 {
            //...
            if ifade {
                continue 'a;
            }
        }
        //...
    }

    Burada artık break ifadesi içteki döngünün blok ifadesini değil dıştaki döngünün blok ifadesini sonlandırmaktadır. 

    Biz yukarıdaki break ifadesinin çalışmasını açıklayacak örnekler verdik. Bu örneklerde aslında continue kullanılmadan 
    da hedeflenen işlemler yapılabilirdi. Pekiyi break ifadesine hangi durumlarda gereksinim duyulmaktadır? Bazı algoritmalarda
    (özellikle switch içeren kodlarda) break ifadesinin kullanılması kodu kısaltabilmektedir. Ancak break ifadesi çoğu 
    kez döngü içerisinde büyük if bloklarını elimine etmek için kullanılmaktadır. Aşağıdaki gibi kod parçası olsun:

    loop {
        val = getval();
        if val > 0 {
            //...
        }
    }

    Burada döngü içerisindeki if ifadesinin çok uzun olduğunu varsayalım. BU if ifadesinin içerisinde de pek çok kontrol 
    deyimi kullanılmış olsun. Biz yukarıdaki döngüde bu geniş if bloğunu continue sayesinde elimine edebiliriz.

    loop {
        val = getval();
        if val <= 0 {
            continue;
        }
        //...
    }

    continue ifadesi de tıpkı break ifadesi gibi ! değerini üretmektedir. Yani continue ifadesi de "divergent" durumdadır. 
    continue ifadesini biz herhangi türden bir değişkene atayabiliriz. Örneğin yukarıdaki if ifadesinde else kısım herhangi 
    bir türden olabilirdi:

    loop {
        val = getval();
        if val <= 0 {
            continue;
        }
        else {
            100         // geçerli ama anlamsız!
        };
        //...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde göreceğimiz son kontrol deyimi match deyimidir. Rust'taki match deyimi C, C++, Java ve C# gibi dillerdeki 
    switch deyimine benzemektedir. Ancak Rust'taki match deyimi bu dillerde switch deyiminden çok daha fazla olanaklara sahip 
    bir deyimdir. Dolayısıyla match deyiminin Rust'ta kullanımı bu dillerdeki switch deyiminin kullanımından çok daha yoğundur. 

    Rust'ta match deyimi "kalıp uyuşumu (pattern matching)" kurallarıyla çalışmaktadır. Kalıp uyuşumu konusu ise oldukça 
    ayrıntılıdır. Bu konunun henüz görmediğimiz dizilerle, demetlerle, enum türleriyle, yapılarla bağlantısı vardır. Bu nedenle
    bir bu bölümde match deyimini henüz geldiğimiz noktaya kadarki konular eşliğinde ele alacağız. Sonra bu konuların anlatıldığı 
    yerde çeşitli eklemeler yapacağız. En sonunda da kalıp uyuşumu konusunu bütünsel olarak yeniden gözden geçireceğiz. 

    Aslında kalıp uyuşumuyla çalışan switch ya da match deyimleri Rust'a özgü değildir. Ruby gibi, Swift gibi, Kotlin gibi,
    hatta Python gibi dillerde de kalıp uyuşumuyla çalışan match benzeri deyimler bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta match ifadesinin genel biçimi şöyledir:

    match <ifade> {
        <kalıp1> => ifade1, 
        <kalıp2> => ifade2, 
        <kalıp3> => ifade3, 
        ....
    }

    match anahtar sözcüğünü bir ifade izlemek zorundadır. Buradaki ifade herhangi bir türe ilişkin olabilir. match ifadesinin
    aslında çalışması oldukça basittir. Derleyici match anahtar sözcüğünün yanındaki ifadeyi inceler. Sonra match kalıplarını 
    yukarıdan aşağıya doğru ele alır. Kalıbın uyuştuğu ilk ifadeyi çalıştırır. match ifadesinden bu çalıştırılan ifadenin değeri 
    elde edilir. match ifadesinde diğer bazı dillerdeki case anahtar sözcüğünün bulunmadığına dikkat ediniz. match ifadesinde 
    break ifadesi kullanılırsa bu break ifadesinin match ifadesi ile biri ilgisi yoktur. match ifadesinin içinde bulunduğu 
    döngü ile ilgisi vardır. match deyiminde C gibi, Java gibi dillerdeki "aşağıya düşme (fall through)" mekanizması da yoktur. 
    Dolayısıyla Rust'taki match deyiminde yalnızca uyuşan ilk kalıbın ifadesi işletilmektedir. 
    
    "The Rust Reference" dokümanlarında match deyimindeki => içeren her kısma "match kolu (match arm)" denilmektedir. match 
    deyiminde akışın hangi kola aktaralıcağını anlayabilmek için kalıp uyuşumu konusunun bilinmesi geremektedir. Biz burada 
    geldiğimiz noktaya kadarki kalıp uyuşumları üzerinde duracağız. Rust'ta match deyiminde mutlaka bir match kolunun kalıp 
    uyuşumunu sağlaması gerekir. Aksi takdirde derleme sırasında error oluşmaktadır. Bu duruma Rust'ta match deyiminin 
    "exhaustive" olması denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    "The Rust Reference" dokümanlarında kalıpların (patterns) BNF grameri şöyle verilmiştir:

    Pattern :
      |? PatternNoTopAlt ( | PatternNoTopAlt )*

    PatternNoTopAlt :
        PatternWithoutRange
    | RangePattern

    PatternWithoutRange :
        LiteralPattern
      | IdentifierPattern
      | WildcardPattern
      | RestPattern
      | ReferencePattern
      | StructPattern
      | TupleStructPattern
      | TuplePattern
      | GroupedPattern
      | SlicePattern
      | PathPattern
      | MacroInvocation

    Görüldüğü gibi her kalıp bir isimle belirtilmektedir. En basit kalıp "sabit kalıbı (literal pattern)" denilen kalıptır.
    İsmi üzerinde sabit kalıbında kalıp ifadesi sabitlerden oluşturulmaktadır. Bu durumda match deyimi C'deki switch deyimine 
    benzer hale gelmektedir. match anahtar sözcüğünün yanındaki ifadeyle ilk eşleşen sabit kalıbının ifadesi çalıştırılacaktır. 
    match deyiminin exhaustive olmasını sağlamak için _ kalıbı kullanılır. Bu kalıba "wildcard kalıbı (wildcard pattern)" da 
    denilmektedir. Wildcard kalıbı her ifadeyle uyuşum sağlamaktadır. Bu nedenle wilkcard kalıbı genellikle match ifadesini 
    "exhaustive" hale getirmek için match ifadesinin son kolunda bulundurulur. Örneğin:

    match val {
        1 => println!("bir"),
        2 => println!("iki"),
        3 => println!("üç"),
        _ => println!("hiçbiri"),
    }

    Burada val ifadesinin çeşitli değerleri için farklı ifadeler yapılmaktadır. Tabii bu örnekte println! makrosu birim değeri 
    ürettiği için math ifadesi de birim değerini üretmektedir. 

    match ifadesinin son kolunun ',' atomu ile bitirilmesi zorunlu değildir. Ancak Rust programcılarının çoğu son kola da ','
    atomunu yerleştirmektedir. Örneğin yukarıdaki match ifadesi aşağıdaki gibi de olabilirdi:

     match val {
        1 => println!("bir"),
        2 => println!("iki"),
        3 => println!("üç"),
        _ => println!("hiçbiri")
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::Write;

fn main() {
    let val: i32;

    print!("Bir sayı giriniz:");
    std::io::stdout().flush().expect("cannot flush stdout!..");
    val = getval();
    match val {
        1 => println!("bir"),
        2 => println!("iki"),
        3 => println!("üç"),
        _ => println!("hiçbiri"),
    }
}

fn getval() -> i32 {
    let mut buf: String = String::new();

    std::io::stdin().read_line(&mut buf).expect("read line failed");
    buf.trim().parse().expect("parse into number")
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sabit kalıbında (literal pattern) kullanılacak sabit herhangi bir türe ilişkin olabilir. Örneğin:

     match val {
        'a' => println!("a"),
        'b' => println!("b"),
        'c' => println!("c"),
        _ => println!("hiçbiri"),
    }

    C, C++, Java ve C# gibi dillerde switch anahtar sözcüğünün yanındaki kontrol ifadesinin tamsayı türlerine ilişkin olması 
    gerekmektedir. Ancak Rust'ta böyle bir zorunluluk yoktur. Ancak ne olursa olsun yuvarlama hatalarından dolayı sabit 
    kalıplarında gerçek sayı sabitlerini kullanmak kötü bir tekniktir. Örneğin:

    match val {
        1.0 => println!("bir"),
        2.0 => println!("iki"),
        3.0 => println!("üç"),
        _ => println!("hiçbiri"),
    }

    Sabit kalıbında sabitlerin match anahtar sözcüğünün yanındaki kontrol kalıbındaki tür türünden olması gerekmektedir. 

    Sabit kalıbında eğer match anahtar sözcüğünün yanındaki ifade &str türündense sabitler string de olabilmektedir. Örneğin:

    let city: &str = "eskişehir";
    //...
    
    match city {
        "ankara" => println!("6"),
        "izmir" => println!("35"),
        "adana" => println!("1"),
        "eskişehir" => println!("26"),
        _ => println!("hiçbiri"),
    }

    Burada da görüldüğü gibi eğer match kollarında sabit kalıbı olarak string sabiti kullanılacaksa match anahtar sözcüğünün 
    yanındaki ifadenin de &str türünden olması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                20. Ders 14/05/2025 - Çarşamba 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda basit bir komut satırı örneği verilmiştir. Bu örnekte bir döngü içerisinde stdin dosyasından komutlar alınmış 
    ve match ifadesi ile bu komutlar işlenmiştir. Programdaki match deyiminin nasıl oluşturulduğuna dikkat ediniz:

    match getstr().as_str() {
        "" => continue,
        "dir" => println!("dir command"),
        "copy" => println!("copy command"),
        "rename" => println!("rename command"),
        "quit" => break,
        _ => println!("unknown command"),
    }

    Tabii burada komutların işlenmesi için fonksiyonlar oluşturulup her match kolunda da ilgili fonksiyon çağrılabilirdi.
    Örneğin:

    match getstr().as_str() {
        "" => continue,
        "dir" => dir_proc(),
        "copy" => copy_proc(),
        "rename" => rename_proc(),
        "quit" => break,
        _ => println!("unknown command"),
    }
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::{self, Write};

fn main() {
   loop {
      print!("CSD>");
      io::stdout().flush().expect("cannot flush stdout!");

      match getstr().as_str() {
         "" => continue,
         "dir" => println!("dir command"),
         "copy" => println!("copy command"),
         "rename" => println!("rename command"),
         "quit" => break,
         _ => println!("unknown command"),
      }
   }
}

fn getstr() -> String {
   let mut buf: String = String::new();

   std::io::stdin().read_line(&mut buf).expect("read line failed");
   buf.trim().to_string()
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir match kolunda birden fazla deyim bulundurulmak isteniyorsa blok ifadesi oluşturulmalıdır. Örneğin:

    match val {
        1 => {
            //...
        },
        2 => {
            //...
        },
        3 => {
            //...
        },
        _ => ()
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii match ifadesi de diğer deyimlerde olduğu gibi bir değer de üretmektedir. match ifadesinden elde edilen değer çalıştırılan 
    match kolundaki ifadenin değeridir. Tabii bu durumda match ifadesinin bütün kollarından elde edilen değerlerin aynı türden 
    olması gerekir. Örneğin:

    loop {
        print!("CSD>");
        io::stdout().flush().expect("cannot flush stdout!");
        let result: i32;

        result = match getstr().as_str() {
            "" => continue,
            "quit" => break,
            "dir" => {
                println!("dir command");
                1
            },
            "copy" => {
                println!("copy command");
                2
            },
            "rename" => {
                println!("rename command");
                3
            },
            _ => {
                println ! ("unknown command");
                0
            }
        };
        println!("result: {}", result);
   }

    Burada match ifadesinin her kolu i32 türünden değer üretmektedir. break ve continue ifadelerinin never türünden (! türünden) 
    değer ürettiğini anımsayınız. Never türü diğer her türe otomatik dönüştürülebildiği için diğer her türle bu bağlamda bir 
    arada bulunabilmektedir. 

    Pekiyi aşağıdaki gibi bir match ifadesindeki result değişkeninin match kolundaki kullanımı geçerli midir?

    let result: i32;

    result = match val {
        1 => {
            println!("{}", result),         // error!
            10
        }
        //...
        _ => 0
    };

    Bu örnekte result değişkeni match ifadesi bittiğinde değer alacaktır. Dolayısıyla bu kullanım "içerisinde henüz değer 
    atanmamış değişkenin içerisindeki değerin" kullanılması nedeniyle error oluşturacaktır. Tabii biz baştan result değişkenine 
    değer atamış olsaydık bu durum soruna yol açmayacaktı:

    let mut result: i32 = 0;

    result = match val {
        1 => {
            println!("{}", result),         // geçerli
            10
        }
        //...
        _ => 0
    };
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi match ifadesinin son koluna wildcard kalıbı getirildiğinde bu wildcard kalıbındaki ifade ne olmalıdır? match ifadesinin 
    wildcard kolu diğer kollarla aynı değeri üretmelidir. Eğer diğer kollar unit değeri üretiyorsa bu durumda wildcard ifadesinde 
    de bir şey yapmak istemiyorsanız oaradaki oradaki () biçiminde ya da eşdeğer olarak {} biçiminde oluşturabilirsiniz. 
    Örneğin:

    match val {
        1 => println!("bir"),
        2 => println!("iki"),
        3 => println!("üç"),
        _ => (),
    }
    
    Daha önceden de belirttiğimiz gibi match ifadesinde match kollarına yukarıdan aşağıya doğru sırasıyla bakılmaktadır. 
    Rust'ta birden fazla match kolunda kalıp uyuşumu sağlanabilir. Bu durum error oluşturmamaktadır. Bu durumda yukarıdan 
    aşağıya doğru ilk uyuşan kalıbım match ifadesi işletilmektedir. Tabii bazen derleyici sabit kalıplarında ya da diğer bazı 
    kalıplarda bir durum tespiti yapıp uyarı mesajı verebilmektedir. Örneğin:

    match val {
        1 => println!("bir"),
        1 => println!("yine bir"),
        _ => (),
    }
    
    Burada val değeri 1 ise ilk koldaki ifade çalıştırılacaktır. Bu durumda açıkça diğer ikinci kol "erişilemeyen (unreachable)
    durumda olur. Rust derleyicisi bunu tespit edip bir uyarı mesajı oluşturacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Bazen farklı değerler için aynı şeylerin yapılması istenebilir. Bunun için match ifadesinde "veya kalıbı (or pattern) 
   kullanılmaktadır. Veya kalıbı | atomuyla oluşturulmaktadır. Örneğin.

   match val {
      1 | 2 | 3 => println!("bir ya da iki ya da üç"),
      4 => println!("dört"),
      5 => println!("beş"),
      _ => println!("diğer bir sayı")
   }

   Burada birinci match kolu aşağıdaki gibidir:

    1 | 2 | 3 => println!("bir ya da iki ya da üç"),

    Bu kalıp 1 ya da 2 ya da 3 anlamına gelmektedir. Örneğin daha önce yazmış olduğumuz komut satırı uygulamasında biz 
    döngüden "quit" ya da "exit" komutu girildiğinde çıkmak isteyebiliriz:

      loop {
        //...
        match getstr().as_str() {
            "" => continue,
            "dir" => println!("dir command"),
            "copy" => println!("copy command"),
            "rename" => println!("rename command"),
            "quit" | "exit" => break,
            _ => println!("unknown command"),
        }
    }

    Tabii veya kalıbındaki kalıplar sabit kalıplarıysa bunların aynı türden olması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    match ifadelerinde çok kullanılan diğer bir kalıp da range kalıbıdır. range kalıbı bir değerin bir aralık içerisinde olup 
    olmadığını belirlemekte kullanılmaktadır. Range kalıbını oluşturabilmek için yine daha önce görmüş olduğumuz .. ve ..= 
    operatörleri kullanılmaktadır. Range kalıbında kullanılabilecek range ifadeleri şunlardır:

    a..b
    a..=b
    ..b
    ..=b
    a..

    Bu range ifadelerinin ne anlama geldiğini daha önce görmüştük. Bir kalıp olarak kullanıldığında bu range kalıpları şu 
    anlamlara gelmektedir (a ve b'nin aynı tamsayı türlerine ilişkin değerler olduğunuvarsayıyoruz):

    a..b        a'dan b'ye b dahil olmamak üzere (exclusive range) tamsayıların herhangi biri
    a..=b       a'dan b'ye b dahil olmak üzere (inclusive range) tamsayıların herhangi biri
    ..b         b'ye kadar olan fakat b dahil değil (range to) tamsayıların herhangi biri (negatif değerler de dahil)
    ..=b        b'ye kadar olan fakat b de dahil (range to inclusive) tamsayıların herhangi biri (negatif değerler de dahil)
    a..         a'dan başlayan tamsayıların herhangi biri (range from)
   
   Örneğin:
        
    let val = getval()

    match val {
        0 => break,
        1 => println!("1"),
        2..5 => println!("2..5"),
        5 => println!("5"),
        6..=8 => println!("6..=8"),
        ..10 => println!("..10"),
        ..=20 => println!("..=20"),
        21.. => println!("30.."),
    }

    Burada çeşitli kalıplar birlikte kullanılmıştır. Bu örnekte ilginç olan bir durum hiç wildcard kalıbının kullanılmamış 
    olmasıdır. Çünkü bu örnekte zaten match "exhaustive" durumdadır. Yani i32 türünün her değeri için çalıştırılacak bir 
    match kolu bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::{self, Write};

fn main() {
   loop {
      let val: i32;

      print!("Bir değer giriniz:");
      io::stdout().flush().expect("cannot flush stdout!");

      val = getval();
      match val {
         0 => break,
         1 => println!("1"),
         2..5 => println!("2..5"),
         5 => println!("5"),
         6..=8 => println!("6..=8"),
         ..10 => println!("..10"),
         ..=20 => println!("..=20"),
         21.. => println!("30.."),
      }
   }
}

fn getval() -> i32 {
   let mut buf: String = String::new();

   std::io::stdin().read_line(&mut buf).expect("read line failed");
   buf.trim().parse().expect("parse into number failed")
}

/*--------------------------------------------------------------------------------------------------------------------------
    Range kalıplarında match anahtar sözcüğünün yanındaki ifadenin türü ile range ifadesindeki türlerin aynı olması gerekmektedir. 
    Örneğin:

    let val: i8;

    val = getval();
    match val {
        1..10 => println!("1..10"),
        _ => (),
    }

    Burada val ifadesi i8 türündendir. 1..10 range kalıbı bağlama göre 1i8..10i8 gibi ele alınmaktadır. Dolayısıyla buradaki 
    range kalıbı geçerlidir. Örneğin:

    let val: i32;

    val = getval();
    match val {
        1i8..10i8 => println!("1i8..10i8"),            // error!
        _ => (),
    }

    Bu örnekte val değişkeni i32 türündendir. Ancak range kalıbı i8 türüne ilişkindir. Bu nedenle error oluşacaktır. 

    Tabii range kalıbında çok seyrek olsa da f32 ve f64 türleri kullanılabilmektedir. Örneğin:

    let val: f64;

    val = getval();
    match val {
        1.0..3.0 => println!("1.0..3.0"),
        _ => ()
    }

    Burada val f64 türündendir. Range kalıbı da f64 türüne ilişkindir. Yani örneğimizde val değeri 1 ile 3 arasında herhangi 
    bir gerçek sayı değeri ise uyuşum sağlanacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Range kalıbında kalıp range operatörleriyle oluşturulmalıdır. Eğer biz bir match koluna Range türünden bir değişken
    yerleştirirsek bu bir range kalıbı olmaz. Sonraki paragrafta göreceğimiz gibi bir değişken kalıbı olur. Örneğin.

    let a = 10;
    let r = 1..100;

    match a {
        r => println!("{}", r),     // dikkat! bu bir range kalıbı değil
        //...
    }

    match kolundaki r yeni bir değişkendir ve bu değişken izleyen paragrafta da görüleceği üzere a'nın türünden, yani örneğimizde
    i32 türünden olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Diğer ilginç bir kalıba da "değişken kalıbı (identifer pattern)" denilmektedir. Değişken kalıbında kalıp bir değişken 
    olur. Bu durumda uyuşum her zaman sağlanır. Değişken kalıbında kalıpla uyuşan değer kalıpta belirtilen değişkene yerleştirilir. 
    Örneğin:

    val = getval();
    match val {
        a => println!("a = {}", a),
    }

    Burada bu değişken kalıbı tüm val değerleriyle uyuşum sağlayacaktır. Uyuşum sağlandığında val değişkeninin içerisindeki 
    değer a değişkenine atanacaktır. a değişkeninin yukarıda let ile bağlanmış olması gerekmez. Çünkü zaten match kolunda 
    yeni bir değişken bağlaması yapılmaktadır. Bu kalıpta değişkene bir tür bilgisi iliştirilmez. Değişkenin türünün match 
    anahtar szöcüğünün yanındaki ifadenin türüyle aynı olduğu kabul edilir. Örneğin yukarıdaki match ifadsinde a değişkenin 
    türü val değişkenin türü ile aynıdır. Yani a değişkeni de i32 türündedir. Burada ayrıca match ifadesinin "exhaustive" 
    olduğuna dikkat ediniz. Dolayısıyla wildcard kalıbı gerekmemektedir. Kalıpta belirtilen değişken yalnızca o match kolunda 
    kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            21. Ders 21/05/2025 - Çarşamba
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    match kollarına yukarıdan aşağıya doğru bakıldığını anımsayınız. Bu durumda biz değişken kalıbını örneğin sabit kalıplarından
    sonraya yerleştirebiliriz:

    val = getval();
    match val {
        10 => println!("this is literal pattern 10"),
        x => println!("{}", x),
    }

    Burada eğer val 10 ise birinci kol, val 10 dğeilse ikinci kol işletilecektir. 

    Değişken kalıbı size biraz anlamsız gelebilir. Ne de olsa match edilen değer zaten match anahtar sözcüğünün yanındaki 
    değerdir. Yani örneğin yukarıdaki örnek işlevsel olarak aşağıdakiyle eşdeğerdir:

    val = getval();
    match val {
        10 => println!("this is literal pattern 10"),
        _ => println!("{}", val),
    }

    Pekiyi o zaman gerçekten değişken kalıbı gereksiz midir? Yanıt hayır. Biz henüz pek çok kalıbı görmedik. Başka kalıplarda
    uyuşum sağlayan değerlerin değişkenlere atanmasının önemi ortaya çıkmaktadır. 

    Değişken kalıbında ayrıca değişkenin önüne mut anahtar sözcüğü de getirilebilir. Bu durumda değişken "mutable" olur. Örneğin:

    val = getval();
    match val {
        mut x => {
            println!("{}", x);
            x = 20;
            println!("{}", x);
        }
    }

    Eğer burada x'i mut yapmasaydık blok içerisinde x'in değerini değiştiremezdik.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    if anahtar sözcüğü ile kalıplara bir koşul da eklenebilir. Bu durumda kalıp şu hale gelmektedir:
    
    <kalıp> if <koşul>

    Burada uyuşum ancak ilgili koşul sağlandığında sağlanmaktadır. Örneğin:

    val = getval();
    match val {
        x if x > 0 => println!("positive: {}", x),
        _ => println!("zero or negative"),
    }

    Buradaki if anahtar sözcüğünün else kısmı yoktur. if anahtar sözcüğünü bir koşul izelemek zorundadır. Tabii böyle bir 
    koşul eklendiğinde artık match ifadesi "exhaustive" olmaktan çıkmaktadır. Değişken kalıbına if kullanma durumuna "match 
    guard" denilmektedir. Yukarıda da belirttiğimiz gibi tipik olarak match guard değişken kalıplarında kullanılıyor olsa da 
    istenirse diğer kalıplarda da kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    match kollarındaki kalıplarda "bağlama (binding)" da oluşturulabilmektedir. Bağlama @ atomu ile yapılır. Bu atomun soluna 
    bir değişken sağına ise bir kalıp getirilir. Bağlama yapılmış kalıplara "at kalıpları (at patterns) " da denilmektedir. 
    Eğer @ atomunun sağındaki kalıp uyuşum sağlarsa uyuşan değer soldaki değişkene yerleştirilmektedir. Örneğin:

    val = getval();
    match val {
        x @ 1..20 => println!("{}", x),
        _ => println!("zero or negative"),
    }

    Burada at kalıbının kullanıldığı kola dikkat ediniz:

    x @ 1..20 => println!("{}", x),

    Eğer match anahtar sözcüğünün yanındaki ifadenin değeri 1..20 aralığındaysa uyuşum sağlanacak ve bu değer x'e atanacaktır. 
    Bağlama işleminde @ atomunun sağındaki kalıbın uyuşumu dikkate alınmaktadır. Uyuşum sağlanırsa ilgili değer x değişkenine
    bağlanmaktadır. Tabii yukarıdaki örnekte siz yine "bu durumda x'e bağlamaya ne gerek var, zaten ilgili değer val değişkeni 
    içerisinde bulunuyor" diye düşünebilirsiniz. Ancak ileride göreceğimiz başaka kalıplarda bu "at kalıbının" daha anlamlı 
    kullanımlarıyla karşılaşacağız. Burada önemli olan nokta bu at kalıbında match yanındaki değerin değil uyuşan değerin 
    değişkene yerleştirilmesidir. Bu konu hakkında ileride açıklamalar yapılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz bu bölümde match kalıplarının şimdilik bu kadarını gördük. Başka konular işlendikçe o konulara ilişkin kalıplar ayrıca 
    ele alınacaktır. Henüz ele almadığımız tipik kalıplar şunlardır:

    - enum kalıpları
    - Yapı kalıpları
    - Demet kalıpları
    - Dizi kalıpları
    - ref ve ref mut kalıpları
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    match deyimi aynı zamanda bir ifade belirttiğine göre bir match kolunda başka bir match ifadesi bulunabilir. Örneğin:

    match val1 {
        1..20 => match val2 {
            //...
        },
        _ => (),
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Rust'ta let deyimi de match gibi kalıp uyuşumu ile bağlama yapmaktadır. Yani match ifadesindeki kalıpların hepsi 
    olmasa da birçoğu aslında let deyiminde de kullanılabilmektedir. Örneğin:

    let a = 10;

    Bu let deyimini biz match ifadesinde gördüğümüz "değişken kalıbı (identifier pattern)" biçiminde ele alabiliriz. Örneğin:

    let (a, b) = (10, 20);

    Burada aslında kaynak değer bir demettir. let deyiminde de "demet kalıbı (tuple pattern)" kullanılmıştır. Örneğin:

    let a = [10, 20, 30];
    let [x, y, z] = a;

    Burada biz aslında x, y, ve  değişkenlerini oluşturmuş olmaktayız. x'in içerisine 10, y'nin içerisine 20 ve z'nin 
    içerisine 30 yerleştirilecektir. Bu kalıba "dizi kalıbı (array pattern)" denilmektedir. Bu kalıpları ileride ilgili 
    konuların içerisinde göreceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz deyimler kısmında Rust'ta if let ve while let isimli iki deyimin daha bulunduğunu belirtmiştir. Ancak bu deyimler 
    hakkında bir şey söylememiştik. Şimdi bu deyimlerin çalışma biçimini açıklayacağız. Aslında bu deyimler özellikle enum 
    denilen türlerle (yani enum kalıplarıyla) kullanılmaktadır. enum türlerini ileride ayrı bir başlık altında inceleyeceğiz. 
    Biz kontrol deyimlerinde olduğu gibi if let ve while let deyimleri için if let ifadesi ve while let ifadesi terimlerini 
    kullanacağız. 

    if let ifadesi "kalıp uyuşuyorsa doğruysa kısmın, kalıp uyuşmuyorsa yanlışsa kısmın çalıştırıldığı" ilginç bir if deyimdir. 
    if let ifadesinin genel biçimi şöyledir:

    if let <kalıp> = <ifade> {
        //...
    }
    [ else {
        //...
    }
    ]

    if let anahtar sözcüklerinin yanında bir kalıp bulunur, bu kalıbı '=' atamu ile bir ifade izler. Eğer kalıp uyuşumu sağlanırsa
    if let deyiminin doğruysa kısmındaki blok deyimi, kalıp uyuşumu sağlanmazsa yanlışsa kısmındaki blok deyimi çalıştırılır. 
    if let ifadesi de if ifadesi gibi bir değer üretmektedir. Örneğin:

    val = getval();
    if let 1..10 = val {
        //...
    }
    else {
        //...
    }

    Bu örnekte kalıp 1..10 biiminde belirtilmiş olan range kalıbıdır. Eğer val değeri bu aralıktaysa bu kalıp uyuşumu sağlanacak
    dolayısıyla if deyiminin doğruysa kısmı çalıştırılacaktır. Eğer val bu aralıkta değilse if deyiminin yanlışsa kısmı 
    çalıştırılacaktır. Tabii biz match deyiminde gördüğümüz ve henüz görmediğimiz kalıpları if let ifadesinde de kullanabiliriz. 
    Örneğin:

    val = getval();
    if let x @ 1..10 = val {
        println!("matched 1..10, x = {}", x);
    }
    else {
        println!("pattern cannot match!");
    }

    Burada at kalıbı (@ kalıbı) uygulanmıştır. Bağlanan x değeri yalnızca if ifadesinin doğruysa kısmında kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

use std::io::Write;

fn main() {
    let val: i32;
    print!("Bir değer giriniz:");
    std::io::stdout().flush().expect("Can't flush stdout");

    val = getval();
    if let Some(x) = val {
        println!("matched 1..10, x = {}", x);
    }
    else {
        println!("pattern cannot match!");
    }
}

fn getval() -> i32 {
    let mut buf: String = String::new();

    std::io::stdin().read_line(&mut buf).expect("read line failed");
    buf.trim().parse().expect("parse")
}

/*--------------------------------------------------------------------------------------------------------------------------
    if let ifadesinde de else if kısmı ya da else if let kısmı kullanılabilir. Benzer biçimde if ifadesinde de else if kısmının 
    yanı sıra else if let kısmı da bulundurulabilmektedir. Örneğin:

    val = getval();
    if let 0..10 = val {
        println!("matched");
    }
    else if val % 2 == 0 {
        println!("val is even");
    }
    else {
        println!("other...");
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında if let ifadesi tamamen iki kollu match ifadesi ile karşılanabilir. Örneğin:

    if let pattern = expression {
        //...
    }
    else {
        //...
    }

    ifadesinin match eşdeğeri şöyledir.

    match expression {
        pattern => {
            //...
        }
        _ => {
            //...
        }
    }

    Tabii bu tür durumalarda if let ifadesini okunabilirlik bakımından tercih edebilirsiniz. match ifadesi çok kollu durumlar
    için tercih edilmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    while let döngüsü de "kalıp uyuştuğu sürece yinelenen" bir döngüdür. while let ifadesinin genel biçimi şöyledir:

    while let <pattern> = <ifade> {
        //...
    }

    Burada da match deyiminde görmüş olduğumuz ve henüz görmemiş olduğumuz kalıplar kullanılabilmektedir. Döngü kalıp 
    uyuştuğu sürece yinelenmektedir. Örneğin:

    i = 0;
    while let 0..10 = i {
        print!("{} ", i);
        i += 1;
    }

    Burada bir range kalıbı kullanılmıştır. Bu kalıp uyuşumu i'nin 0 ile 9 arasındaki değerleri için sağlanacaktır. Ancak 
    i = 10 olduğu zaman kalıp uyuşumu artık sağlanmayacak ve döngüden çıkılacaktır. Örneğin:

    while let x @ 1..=10 = getval() {
        //...
    }

    Burada klavyeden (stdin dosyasından) girilen değer 1 ile 10 arasında olduğu sürece x'e yerleştirilip blok deyimi çalıştırılacaktır. 
    Eğer girilen değer bu aralıkta değilse kalıp uyuşmayacağı için döngü sonlanacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    if let ve while let ifadelerinin daha uygun kullanımları ile kursumuzun ilerleyen aşamalarında karşılaşacağız. Burada 
    biz bu deyimlerin kalıp uyuşumu ile nasıl çalıştığını açıkladık.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Diziler elemanları aynı türden olan ve bellekte ardışıl bir biçimde bulunan veri yapılarıdır. Genellikle programlama dilleri 
    tarafından "built-in" biçimde desteklenmektedir. Biz de bu bölümde Rust'ta diziler üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda belirttiğimiz gibi diziler aynı türden elemanlara sahiptir ve dizi elemanları bellekte fiziksel bakımdan ardışıl
    bir biçimde tutulmaktadır. Dizi elemanlarının ardışıl biçimde tutulması iki bakımdan önemlidir:

    1) Bu sayede dizinin bir elemanına çok hızlı (buna "rastege erişim (random access)" ya da O(1) karmaşıklıkta erişim de 
    denilmektedir) bir biçimde erişilir. İşlemciler belli bir adresten n uzaklıktaki nesnelere tek bir makine komutuyla 
    erişebilmektedir. 

    2) Dizi elemanlarının ardışıl olması nedeniyle diziler fonksiyonlara başlangıç adresleriyle aktarılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Rust'ta dizi türleri [tür; uzunluk] biçiminde ifade edilmektedir. Örneğin:

    let a: [i32; 5];

    Yazım biçimi olarak noktalı virgülden sonra boşluk bırakmaka daha yaygındır. Ancak boşluk bırakmayan Rust programcıları 
    da vardır. Biz kurusumuzda buradaki nokralı virgülden sonra boşuk bırakacağız. Dizi bildirirken uzunluğun sabit ifadesi 
    biçiminde belirtilmesi zorunludur. Örneğin:

    let n = 5;
    let a: [i32; n];        // error! uzunluk sabit ifadesi biçiminde belirtilmemiş

    Yukrıdaki dizi bildirimi error oluşturacaktır. Çünkü dizi uzunluğu sabit ifadsi ile belirtilmemiştir.

    Rust'ta bir dizi oluşturulurken tipik olarak dizi elemanlarına ilkdeğerleri verilmektedir. Bu işlem köşeli parantezlerlerle
    yapılmaktadır. (Dizi elamanlarına C'de küme ğarantezleri içerisinde ilkdeğer verildiğini anımsayınız.) Örneğin:

    let a: [i32; 5] = [10, 20, 30, 40, 50];

    Tabii verilen her ilkdeğerin dizi türünden olması gerekir. Örneğin:

    let a: [i32; 5] = [10, 20, 30, 40, 50.5];       // error!

    Rust'ta dizi elemanlarına ilkdeğer verilirken veilen ilkdeğerlerin tam olarak dizi uzunluğu kadar olması zorunludur. 
    Örneğin:

    let a: [i32; 5] = [10, 20, 30, 40];      // error!

    Burada a dizisi 5 elemanlı olduğu halde biz bu diziye 4 tane ilkdeğer verdik. Bu durum error oluşturacaktır. Halbuki
    örneğin C ve C++'ta dizinin az sayıda elemanına ilkdeğer verilebilmektedir. Bu durumda diğer elemanlara 0 yerleştirilmektedir.
    Rust'ta böyle bir durum söz konusu değildir. Rust'ta da dizi elemanlarına verilen ilkdeğerlerin sabit ifadesi olması zorunlu
    değildir. Örneğin:

    let (x, y, z) = (10, 20, 30); 
    let a: [i32; 3] = [x, y, z];      // geçerli
 
    Rust'ta dizi elemanlarına ilkdeğer verirken köşeli parantez içerisindeki değerlerin hepsinin aynı türden olması gerekir. 

    Dizilere ilkdeğer verilirken let deyiminde tür belirtilmezse derleyici tür çıkarımını aşağıda belirtildiği gibi yapmaktadır:

    - Dizi uzunluğu köşeli parantez içerisindeki eleman sayısı kadardır. 
    - Dizinin türü verilen ilkdeğerlerin türünden olur.
    <BURADA KALDIK>
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
           
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
           
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
           
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
           
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
           
---------------------------------------------------------------------------------------------------------------------------*/



