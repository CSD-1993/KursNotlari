/*---------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                UNIX/Linux Sistem Programlama Kursunda Yapılan Örnekler ve Özet Notlar
                                                      1. Bölüm

                                                Eğitmen: Kaan ASLAN

            Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
            Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

            Aslan, K. (2025), "UNIX/Linux Sistem Programlama Kursu, Sınıfta Yapılan Örnekler ve Özet Notlar", 
                C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                          Son Güncelleme: 09/05/2025 - Cuma

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kursumuzun başında iki hafta bazı temel kavramlar ve konular üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bilgisayar donanımıyla arayüz oluşturan, uygulama programlarına çeşitli bakımlardan hizmet veren programlara "sistem
    programları", programlamanın bunlarla ilgili alanına da "sistem programlama (system programming)" denilmektedir.
    Sistem programlama etkinlikleri aşağı seviyeli olma eğilimindedir. Bunları yazmak için önemli ölçüde teorik bilgiye ve
    uygulama becerisine gereksinim duyulmaktadır. Sistem programlama "programlamanın yükte hafif pahada ağır" bir alanını
    oluşturmaktadır. Bu yönüyle adeta yazılımın ağır sanayisi niteliğindedir. Bilişim sektöründeki Microsoft, Apple, Google 
    gibi pek çok büyük kurum geliştirdikleri sistem programlarıyla bu hale gelmişlerdir. Tipik sistem programlama uygulamalarından 
    bazıları şunlardır:

    - İşletim Sistemleri
    - Derleyiciler ve Yorumlayıcılar
    - Editörler
    - Gömülü Sistem Uygulamaları
    - Debug Programları
    - Aşağı Seviyeli Haberleşme Programları
    - Virüs ve Antivirüs Yazılımları
    - Çevre Birimlerinin ve Diğer Donanımsal Aygıtların Programlanması ve Aygıt Sürücüleri
    - Veritabanı Motorları
    - Sanallaştırma Yazılımları ve Emülatör Yazılımları
    - Oyun Motorları
    ...

    Sistem programlama etkinlikleri için en çok kullanılan programlama dilleri C, C++ ve Sembolik Makine Dilleri'dir. Rust
    Programlama Dili de son yıllarda bu alanda bir yer edinmeye çalışmaktadır. Her ne kadar sistem programlama denildiğinde 
    akla C, C++ ve sembolik makine dilleri geliyorsa da bazı sistem programları Java, C# gibi dillerle de yazılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri bilgisayar donanımının kaynaklarını yöneten, bilgisayar donanımı ile kullanıcı arasında arayüz 
    oluşturan sistem programlarıdır. Bilgisayar bilimlerinin akademik öncülerinin çoğu işletim sistemlerini bir kaynak 
    yöneticisi (resource manager) olarak tanımlamıştır.

            +----------------------+
            | Uygulama Programları |
            +----------------------+
        +-----------------------------+
        |       İşletim Sistemi       |
        +-----------------------------+
    +-----------------------------------+
    |        Bilgisayar Donanımı        |
    +-----------------------------------+

    İşletim sistemlerinin yönettiği kaynakların en önemlileri şunlardır:

    - CPU: İşletim sistemi hangi programın ne zaman, ne kadar süre için CPU'ya atanacağına karar verip bu işlemleri 
    gerçekleştirmektedir.
    
    - Ana Bellek (Main Memory (RAM)): İşletim sistemi programların ana belleğin neresine yükleneceğine karar verir 
    ve ana bellek kullanımını düzenler.
    
    - İkincil Bellekler: İşletim sistemi bir dosya sistemi (file system) oluşturarak dosyaların parçalarını ikincil 
    belleklerde etkin bir biçimde tutar ve kullanıcılara bir dosya kavramıyla sunar.
    
    - Çevre Birimleri (klavye, fare, yazıcı vs.): İşletim sistemi fare, klavye, yazıcı gibi çevre birimlerini yöneterek 
    onları kullanıma hazır hale getirir. Yardımcı işlemcileri (denetleyicileri) programlayarak onların işlev görmesini 
    sağlamaktadır.
    
    - Ağ İşlemleri: İşletim sistemi ağa ilişkin donanım birimlerini yöneterek dışarıdan gelen bilgileri onları talep 
    eden programlara iletir.

    İşletim sistemleri kaynak yönetimine göre alt sistemlere ayrılarak da incelenebilmektedir. Örneğin işletim 
    sisteminin "çizelgeleyici (scheduler)" alt sistemi demekle CPU yönetimini sağlayan alt sistemi kastedilmektedir. 
    Ana bellek yönetimi (memory management) yine soyutlanarak incelenen önemli alt sistemlerden biridir. İşletim 
    sistemlerinin ikincil bellek yönetimine "dosya sistemi (file system)" da denilmektedir. Tabii bütün bu sistemler
    birbirinden kopuk olarak değil birbirleriyle ilişkili bir biçimde işlev görmektedir. Bu durumu insanın "solunum 
    sistemi", "dolaşım sistemi", "sinir sistemi", "boşaltım sistemi" gibi alt sistemlerine benzetebiliriz. Bu alt 
    sistemlerin birinde bile çalışma bozukluğu oluşsa insan yaşamını yitirebilmektedir. 

    İşletim sistemleri yapı olarak iki kısımdan oluşmaktadır: Çekirdek (kernel) ve kabuk (shell). Çekirdek işletim 
    sisteminin donanımı kontrol eden ve kaynakları yöneten motor kısmıdır. Aslında işletim sistemi denildiğinde akla 
    çekirdek gelmektedir. Kabuk ise işletim sisteminin kullanıcı ile arayüz oluşturan önyüzüdür. Örneğin UNIX/Linux 
    sistemlerinde bash gibi komut satırı, GNOME, KDE gibi pencere yöneticileri, Windows'taki masaüstü (Explorer), 
    macOS'teki masaüstü (Aqua) bu işletim sistemlerinin kabuk kısımlarını oluşturmaktadır.

    +-----------------------------------+
    |           Kabuk (Shell)           |
    |   +---------------------------+   |
    |   |                           |   |
    |   |    Çekirdek (Kernel)      |   |
    |   |                           |   |
    |   +---------------------------+   |
    +-----------------------------------+

    Pekiyi işletim sistemi bu kadar temel donanım yönetimini sağlıyorsa işletimi olmadan programlama yapılabilir mi?
    İşletim sistemi olmadan programlama faaliyetine halk arasında "bare metal programlama" denilmektedir. Bare metal
    programlama gömülü sistemlerde, mikrodenetleyicilerin kullanıldığı uygulamalarda kullanılmaktadır. Bare metal 
    programlama genellikle özel bir amaca hizmet edecek biçimde yapılmaktadır. Amaçlar fazlalaştığı zaman ve sistem 
    karmaşıklaştığı zaman artık işletim sistemlerine gereksinim duyulmaktadır. 

    Bazı kontrol yazılımları işletim sistemlerinin bazı etkinliklerini de sağlamaktadır. Bir kontrol yazılımının 
    işletim sistemi olarak isimlendirilmesi için yukarıda açıkladığımız kaynak yönetimlerinin önemli bir bölümününü
    sağlıyor olması gerekir. Bu kaynak yönetimlerinin çoğunu sağlamayan kontrol yazılımlarına  genel olarak "firmware" 
    de denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri çeşitli biçimlerde sınıflandırılabilmektedir:

    - Proses Yönetimine Göre: Aynı anda tek bir programı çalıştıran işletim sistemlerine "tek prosesli (single processing)", 
    aynı anda birden fazla programı çalıştırabilen işletim sistemlerine ise "çok prosesli (multiprocessing) işletim sistemleri
    denilmektedir. Örneğin DOS işletim sistemi tek prosesli bir sistemdi. Biz bu işletim sisteminde bir programı çalıştırırdık
    ancak çalıştırdığımız program sonlanınca başka bir programı çalıştırabilirdik. Halbuki Windows, UNIX/Linux, MacOS gibi
    işletim sistemleri çok prosesli işletim sistemleridir.

    - Kullanıcı Sayısına Göre: Birden fazla farklı kullanıcının çalışabildiği sistemlere "çok kullanıcılı (multiuser)", 
    tek bir kullanıcının çalışabildiği sistemlere "tek kullanıcılı (single user)" sistemler denilmektedir. Genellikle 
    çok prosesli işletim sistemleri aynı zamanda çok kullanıcılı sistemlerdir. Birden fazla kullanıcının söz konusu 
    olduğu sistemlerde kullanıcıların yetkilerinin ayarlanması, kullanıcıların birbirlerinin alanlarına erişmesinin 
    engellenmesi, sistem kaynaklarını belli oranlarda bölüşmesi gerekebilmektedir. Örneğin DOS tek kullanıcılı bir 
    sistemdi. Halbuki Windows, UNIX/Linux ve macOS sistemleri çok kullanıcılı sistemlerdir.

    - Çekirdek Yapısına Göre: İşletim sistemleri çekirdek yapısına göre "tek parçalı çekirdekli (monolithic kernel)" 
    ve "mikro çekirdekli (microkernel)" olmak üzere ikiye ayrılmaktadır. Tek parçalı çekirdekli işletim sisteminin büyük 
    kısmı çekirdek modunda çalışır. Mikro çekirdekli sistemlerde ise çekirdek modunda çalışan kısım minimize edilmeye 
    çalışılmıştır. Aslında tek parçalı ve mikro çekirdekli tesarımları bir spektrum olarak düşünebiliriz. (Örneğin bu 
    spektrumda bazı çekirdekler tek parçalı tarafa yakın bazıları ise mikro tarafa yakın olabilmektedir.)

    - Dışsal Olaylarla Yanıt Verebilme Özelliğine Göre: İşletim sistemleri dışsal olaylara yanıt verme bakımından gerçek
    zamanlı olan (real-time) ve gerçek zamanlı olmayan (non-real-time) sistemler olmak üzere ikiye ayrılabilir. Dışsal 
    olaylara hızlı bir biçimde yanıt verebilecek çekirdek yapısına sahip olan işletim sistemlerine "gerçek zamanlı (real-time) 
    işletim sistemleri denilmektedir. Gerçek zamanlı işletim sistemleri de kendi aralarında "katı (hard real-time)" ve 
    "gevşek (soft real-time)" işletim sistemleri olmak üzere ikiye ayrılabilmektedir. Katı gerçek zamanlı sistemler dışsal 
    olaylara yanıt verme bakımından çok güvenilir olma iddiasındadır. Gevşek gerçek zamanlı sistemler ise bu konuda daha 
    toleranslıdır.

    - Dağıtıklık Durumuna Göre: İşletim sistemleri dağıtıklık durumuna göre "dağıtık olan (distributed)" ve "dağıtık olmayan
    (non-distributed)" sistemler biçiminde ikiye ayrılabilmektedir. Dağıtık işletim sistemlerinde sistem birden fazla
    bilgisayardan oluşan tek bir sistem gibi davranmaktadır. Örneğin 10 tane makineyi tek bir sistem olarak düşünebilirsiniz.
    Bu durumda bu bilgisayarların kaynakları (örneğin diskleri ve CPU'ları) bu 10 makine tarafından paylaşılmaktadır.
    Windows, UNIX/Linux ve macOS dağıtık işletim sistemleri değildir. Ancak bu sistemlerde dağıtık uygulamalar yapılabilmektedir.

    - Donanım Özelliğine Göre: Neredeyse her yaygın masaüstü işletim sisteminin bir mobil versiyonu da oluşturulmuştur. 
    IOS (Iphone Operating System) ve ipadOS Apple firmasının (yani macOS sistemlerinin) mobil işletim sistemleridir. Android 
    bir çeşit mobil Linux sistemi olarak değerlendirilebilir. Android projesinde Linux çekirdeği alınmış, biraz özelleştirilmiş, 
    bazı parçaları atılmış, buna bir mobil arayüz giydirilmiş ve sistem akıllı telefonlara ve tabletlere uygun hale getirilmiştir. 
    Nokia eskiden Symbian sistemlerinde büyük bir pazar payına sahipti. Ancak bu firma akıllı telefon geçişini iyi yönetemedi. 
    MeeGo ve Maemo gibi işletim sistemlerini denedi. Sonra ekonomik sıkıntılar sonucunca büyük ölçüde Microsoft tarafından 
    satın alındı. Windows'un mobil versiyonuna genel olarak Windows CE denilmektedir. Windows CE'nin akıllı telefonlar ve 
    tabletler için özelleştirilmiş biçimine ise Windows Mobile ve Windows Phone denilmektedir. Ancak Microsoft 2010 yılında 
    Windows Mobile işletim sistemini 2017'de de Windows Phone işletim sistemini sonlandırmıştır ve bu alandaki rekabetten 
    tamamen çekilmiştir. Windows CE ise Windows IoT Core ismiyle farklı bir tasarımla evrimleşerek devam ettirilmektedir.

    - Kaynak Kod Lisansına Göre: Kaynak kod lisansına göre işletim sistemlerini kabaca "açık kaynak kodlu (open source)" 
    ve "mülkiyete bağlı (proprieatary)" olmak üzere ikiye ayırabiliriz. Açık kaynak kodlu işletim sistemleri değişik açık 
    kaynak kod lisanslarına sahip olabilmektedir. Bunların kaynak kodları indirilip üzerinde değişiklikler yapılabilmektedir. 
    Örneğin Windows işletim sistemi mülkiyete sahiptir. Oysa Linux, BSD sistemleri, Solaris, Android gibi sistemler açık 
    kaynak kodludur. macOS sistemlerinin ise çekirdeği açık diğer kısımları (örneğin kabuk kısmı ve diğer katmanları) 
    kapalıdır.

    - Kaynak Kodun Özgünlüğüne Göre: Bazı işletim sistemleri bazı işletim sistemlerinin kodları alınıp değiştirilerek
    oluşturulmuştur (örneğin Android ve macOS'ta olduğu gibi). Bazı işletim sistemlerinin kodları ise sıfırdan yazılmıştır.
    Kodları sıfırdan yazılan yani orijinal kod temeline dayanan işletim sistemlerinden bazıları şunlardır:

    AT&T UNIX
    DOS
    Windows
    Linux
    BSD'ler (belli bir yıldan sonra)
    Solaris
    XENIX
    VMS

    Burada orijinal mimari ile orijinal kod tabanını birbirine karıştırmamak gerekiyor. Linux UNIX işletim sisteminin mimarisini
    temel almıştır. Ancak tüm kodları sıfırdan yazılmıştır. Yani orijinal AT&T UNIX sistemindeki kaynak kodların bir bölümü 
    kopyalanarak kullanılmamıştır. 

    - GUI Çalışma Desteğine Göre: Bazı işletim sistemleri GUI çalışma modelini doğrudan desteklerken bazıları desteklememektedir. 
    Örneğin Windows sistemleri çekirdekle entegre edilmiş bir GUI çalışma modeli sunmaktadır. UNIX/Linux sistemleri de 
    X Window (ya da X11) ve Wayland katmanlarıyla benzer bir model sunmaktadır. Fakat örneğin DOS işletim sisteminin böyle 
    bir doğal GUI desteği yoktu.

    - Ağ Üzerinde Hizmet Alıp Verme Rollerine Göre: İşletim sistemlerini ağ altında hizmet alıp verme rollerine göre 
    "istemci (client) ve sunucu (server) biçiminde de iki gruba ayırabiliriz. Bazı işletim sistemlerinin istemci versiyonları 
    birbirlerinden ayrılmıştır. Bazılarında ise bu ayrım yapılmamıştır. Örneğin Windows 7, 8, 10, 11 sistemleri bu bakımdan 
    istemci (client) sistemleridir. Halbuki Windows Server 2016, 2019 sunucu sistemleri olarak piyasaya sürülmüştür. 
    Eskiden Mac OS X'in istemci ve sunucu versiyonları farklıydı. Fakat Mac OS X 10.7 (Lion) ile birlikte istemci ve 
    sunucu versiyonları birleştirildi. Linux dağıtımlarının çoğu da hem istemci hem de sunucu olarak kullanılabilmektedir. 
    Ancak bazı dağıtımların ise istemci ve sunucu versiyonları farklıdır. Pekiyi işletim sistemlerinin istemci ve sunucu 
    versiyonları arasındaki farklılıklar nelerdir? Kabaca iki tür farklılığın olduğunu söyleyebiliriz. Birincisi 
    çekirdekle ilgili farklılıklardır. Genellikle sunucu sistemlerinde çizelgeleyici alt sistemde istemci sistemlerine 
    göre farklılıklar bulunmaktadır. İkincisi ise barındırdıkları yardımcı yazılmlardır. işletim sistemlerinin sunucu 
    versiyonları hazır bazı sunucu programlarını da içermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de biraz bilgisayar donanımlarının tarihsel gelişimi üzerinde duralım. Elektronik düzeyde bugün kullandığımız 
    bilgisayarlara benzer ilk aygıtlar 1940’lı yıllarda geliştirilmeye başlanmıştır. Ondan önce hesaplama işlemlerini yapmak 
    için pek çok mekanik aygıt üzerinde çalışılmıştır. Bunların bazıları kısmen başarılı olmuş ve belli bir süre kullanılmıştır. 
    Mekanik bilgisayarlardaki en önemli girişim Charles Babbage tarafından yapılan “Analytical Engine” ve “Difference Engine” 
    aygıtlarıdır. “Analytical Engine” tam olarak bitirilememiştir. Fakat bunlar pek çok çalışmaya ilham kaynağı olmuştur. Hatta 
    bir dönem Babbage’in asistanlığını yapan Ada Lovelace bu “Analytical Engine” üzerindeki çalışmalarından dolayı dünyanın 
    ilk programcısı kabul edilmektedir. Şöyle ki: Rivayete göre Babbage Ada’dan “Analytical Engine” için Bernoulli sayılarının 
    bulunmasını sağlayan bir yönerge yazmasını istemiştir. Ada’nın yazdığı bu yönergeler dünyanın ilk programı kabul edilmektedir. 
    (Gerçi bu yönergelerin bizzat Babbage’in kendisi tarafından yazılmış olduğu neredeyse ispatlanmış olsa bile böyle atıf 
    vardır.) Daha sonra 1800’lü yılların ortalarından itibaren elektronikte hızlı bir ilerleme yaşanmıştır. Bool cebri ortaya 
    atılmış, çeşitli devre elemanları kullanılmaya başlanmış ve mantık devreleri üzerinde çalışmalar başlatılmıştır. 1900’lü 
    yılların başlarında artık yavaş yavaş elektromekanik bilgisayar fikri belirmeye başlamıştır. 1930’lu yıllarda Alan Turing 
    konuya matematiksel açıdan yaklaşmış ve bugünkü bilgisayar benzeri bir makinenin hangi matematik problemleri çözebileceği 
    üzerine kafa yormuştur. Turing bir şerit üzerinde ilerleyen bir kafadan oluşan ve ismine “Turing Makinesi” denilen soyut 
    makine tanımlamıştır ve bu makinenin neler yapabileceği üzerinde kafa yormuştur. ACM Turing’in anısına bilgisayarın Nobel 
    ödülü gibi kabul edilen Turing ödülleri vermektedir.

    Dünyanın ilk elektronik bilgisayarının hangisi olduğu konusunda bir fikir birliği yoktur. Bazıları Konrad Zuse’nin 1941’de
    yaptığı Z3 bilgisayarını ilk bilgisayar olarak kabul ederken bazıları 1944'te yapılan Harward Mark 1 bilgisayarını bazıları 
    da 1945'te yapılan ENIAC’ı ilk bilgisayar olarak kabul etmektedir.

    Modern bilgisayar tarihi üç döneme ayrılarak incelenebilir:

    1) Transistör öncesi dönem (1940-1950’lerin ortalarına kadar)
    2) Transistör dönemi (1950’lerin ortalarından 1970’lerin ortalarına kadar)
    3) Entegre devre dönemi (1970’lerin ortalarından günümüze kadar ki dönem)

    İlk bilgisayarlar vakum tüplerle yapılmıştı. Vakum tüpler hem büyük yer kaplıyordu hem de çok ısınıyordu dolayısıyla da
    çok güç harcıyordu. Ayrıca güvenilir elemanlar değildi. Bu nedenle bu devirdeki bilgisayarlar bir salon büyüklüğündeydi.

    Transistör i1k 947 yılında John Bardeen, William Schockley ve Walter Brattain tarafından Bell Lab'ta icat edildi. Fakat
    1950'li yılların ortalarına doğru kullanıma girdi. İlk transistörlü radyo ve ilk transistörlü bilgisayar (TRADIC) 1954 
    yılında yapıldı. Transistörler 1950'li yıllarda yavaş yavaş bilgisayar devrelerine de girmeye başladı. Bu sayede bilgisayar 
    devreleri küçüldü ve kuvvetlendi. O zamanların en önemli firmaları IBM, Honeywell, DEC gibi firmalardı.

    Entegre devreye benzer ilk çalışma aslında ilk olarak 1949 yılında Alman mühendis Werner Jacobi tarafından yapıldı.
    Ancak entegre devre fikri 1952 yılında İngiliz Geoffrey Dummer tarafından ortaya atıldı. Fakat gerçek anlamda ilk
    gerçekleştirimi 1958 yılında Texas Instruments şirketi çalışanı Jack Kilby tarafından yapıldı. Kilby'den habersiz olarak
    yaklaşık altı ay sonra benzer entegre devre gerçekleştirimi Fairchild Semiconductor firmasında Robert Noyce tarafından
    da yapıldı. Kilby ile Noyce patent konusunda mahkemelik olmuşlarsa da sonra anlaşma sağlanmış ve her iki kişi adına
    patentleme yapılmıştır. Robert Noyce aslında transistörü bulan ekipteki William Shockley'nin yanında çalışıyordu. Bu
    ekipte Gordon Moore da vardı. Shockley'nin yönetiminden memnun olmayan bu ekip Fairchild Semiconductor şirketine
    geçmiştir. Noyce şirketin genel müdürü, Moore da ArGe müdürü olmuştur. Daha sonra 1968 yılında Robert Noyce ve Gordon 
    Moore Fairchild Semiconductor firmasından ayrılarak Intel'i kurdu. İkili Intel'i kurduktan sonra şirkete Fairchild
    Semiconductor'dan Andrew S. Grove da yanlarına aldı. Dünyanın entegre devre olarak üretilen ilk mikroişlemcisi Intel’in
    8080’i kabul edilmektedir. Intel daha önce 4004, 8008 gibi entegre devreler yaptıysa da bunlar tam bir mikroişlemci
    olarak kabul edilmemektedir. Entegre devreler kullanılarak mikroişlemciler yapılmaya başlanınca artık bilgisayar dünyası
    yeni bir döneme girmiş oldu.

    Intel 8080’i tasarladığında bundan bir kişisel bilgisayar yapılabileceği onların aklına gelmemiştir. Kişisel bilgisayar 
    fikri Ed Roberts isimli bir girişimci tarafından ortaya atıldı. Ed Roberts 8080’i kullanarak Altair isimli ilk kişisel 
    bilgisayarı yaptı ve “Popular Electronics” isimli dergiye kapak oldu. Altair makine dilinde kodlanıyordu. Roberts buna 
    Basic derleyicisi yazacak kişi aradı ve Popular Electronics dergisine ilan verdi. İlana o zaman Harward’ta öğrenci olan 
    Bill Gates ve Paul Allen başvurdular. Böylece Altair daha sonra Basic ile piyasaya sürüldü. Gates ve Allen okuldan 
    ayrıldılar ve 1975 yılında Microsoft firmasını kurdular. (O zamanlar bu yeni kişisel bilgisayarlara mikrobilgisayarlar 
    denilmekteydi). Amerika’da bu süreç içerisinde bilgisayar kulüpleri kuruldu ve pek çok kişi kendi kişisel bilgisayarlarını 
    yapmaya çalıştı. Steve Jobs ve Steve Wozniak Apple’ı 1976 yılında böyle bir süreçte kurmuştur.

    IBM kişisel bilgisayar konusunu hafife aldı. Fakat yine de bir ekip kurarak bugün kullandığımız PC’lerin donanımını
    tasarlamıştır. Ancak IBM küçük iş olduğu gerekçesiyle bunlar için işletim sistemini kendisi yazmadı, taşeron bir firmaya
    yazdırmak istedi. Bu süreç içerisinde Microsoft IBM ile anlaşarak DOS işletim sistemini geliştirdi. İlk PC’lerin donanımı
    IBM tarafından, yazılımı Microsoft tarafından yapılmıştır. Microsoft IBM’le anlaştı. IBM uzağı göremediğinden bu süreçte 
    önemli ticari hatalar yaptı. Microsoft ile yaptığı anlaşmaya göre başkalarına DOS’un satışını tamamen Microsoft yapacaktı. 
    IBM ikinci bir hata olarak PC için donanım patentlerini almayı ihmal etti. Bunun sonucunda pek çok firma IBM uyumlu daha 
    ucuz PC’ler yaptılar. Fakat bunların hepsi işletim sistemini Microsoft’tan satın alıyordu. Böylece Microsoft 80’li yıllarda 
    çok büyüdü.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de işletim istemlerinin tarihsel gelişimi üzerinde duracağız. 1940’lı yıllarda ilk elektronik bilgisayarlar yapıldığında 
    henüz bir işletim sistemi kavramı yoktu. Bu bilgisayarlara program yazacak olanlar işletim sistemi faaliyetlerini de 
    kendileri yapmak zorunda kalıyordu. (Yani şimdi mikrodenetleyicilere bare metal kod yazanlarda olduğu gibi.) Transistör 
    bulunduktan sonra 1950’li yıllarda artık elektronik bilgisayarlar yavaş yavaş transistörlerle yapılmaya başlandı. 
    Transistörlerin ortaya çıkması hem bilgisayarların kapasitelerini ve güvenilirliklerini artırmış, 
    hem de güç harcamalarını düşürmüştür.

    1950'li yıllarda IBM gibi pek çok bilgisayar üreticisi firma yalnızca donanım satıyordu. İşletim sistemi gibi programları
    yazmak kullanıcıların yapması gereken bir işti. Böylece donanımı satın alan her kurum işletim sistemine benzeyen
    programları da kendisi yazıyordu. Bu anlamda standart bir işletim sistemi yoktu. Bugünkü anlamda ilk işletim sisteminin
    General Motors'un 1956 yılında IBM'in 701 sistemi için yazdığı NAA IO (Noth Amrican Aviation Input Output System) olduğu 
    söylenebilir.

    1960'lara gelindiğinde IBM System/360 isminde yeni bir bilgisayar donanımı geliştirme işine girişti ve artık donanımla
    işletim sistemini birlikte satma fikrini benimsedi. Bu donanım 1964 yılında duyuruldu ve 1965 yılında gerçekleştirildi. 
    İlk System/360 Model 30 bilgisayarları o zamanın "Solid Logic Technoloy (SLD)" teknolojisiyle üretilmişti. Hem öncekilerden
    daha güçlüydü hem de daha az yer kaplıyordu. Saniyede 34500 işlem yapabiliyordu ve 8K ile 64K ana belleğe sahipti. 
    1967 yılında System/360'ın Model 60'ı piyasaya sürüldü. Bu model saniyede 16.6 milyon komut çalıştırabiliyordu ve ana 
    belleği de tipik olarak 512K, 768K ve 1 MB idi. IBM Sistem 360 donanımları için 1964 yılında ilk kez OS/360 işletim 
    sistemini geliştirdi. IBM daha sonra 1967 yılında OS/360 Model 67 için OS/360'ın TSS 360 isminde zaman paylaşımlı (time 
    sharing system) bir versiyonunu daha geliştirmiştir. IBM'in System/360 makineleri ve işletim sistemleri önemli ticari 
    başarı kazandı. System/360'ı System/370 izledi. System/360 ve System/370 için başka kurumlar da işletim sistemleri 
    geliştirmiştir. Michigan Terminal System (MTS) ve MUSIC/SP bunlar arasında önemli olanlardandır.

    1960'lı yıllarda başka firmalar da işletim sistemleri geliştirmiştir. Örneğin Control Data Corporation firmasının 
    SCOPE işletim sistemi batch işlemler yapabiliyordu. Aynı firma MACE isminde bu işletim sisteminin zaman paylaşımlı 
    bir versiyonunu da yazmıştır. Firma bu çalışmalarını 1970'li yıllarda Kronos işletim sistemiyle devam ettirmiştir. 
    Burroughs firması 1961 yılında MCP işletim sistemi ile B5000 bilgisayarlarını, GE firması da 1962 yılında GECOS işletim 
    sistemiyle GE-600 serisi bilgisayarlarını piyasaya sürdü. UNIVAC dünyanın ilk ticari bilgisayarlarını üreten firmadır. 
    Bu firma da 1962 yılında UNIVAC 1107 için EXEC I işletim sistemini yazdı. Bu işletim sistemini sırasıyla Exec 2 ve 
    Exec 8 izledi.

    DEC (Digital Equipment Corporation) eskilerin en önemli bilgisayar üretici firmalarından biriydi. (DEC 1998 yılında
    Compaq firması tarafından Compaq' firması da 2002 yılında HP firması tarafından satın alındı.) Firmanın en önemli
    ürünleri PDP (Programmed Data Processor) isimli bilgisayarlarıdır. Firma PDP-1'den (1959) başlayarak PDP-16'ya (1971-
    1972) kadar PDP makinelerinin 16 versiyonunu piyasaya sürmüştür. DEC'in PDP-8'inin mini bilgisayar devrimini başlattığı
    söylenebilir. Bu model 50000'in üzerinde satışa ulaşmıştır. UNIX işletim sistemi 1969 yılında ilk kez DEC'in PDP-7 modeli
    üzerinde yazılmıştır. 1965 yılında piyasaya sürülen DEC PDP-7 18 bitlik bir makineydi. Makine DECsys denilen işletim
    sistemi benzeri bir yönetici programla beraber satılıyordu. DEC'in 1966 yılında çıkardığı PDP-10 26 bitlik bir makineydi
    DEC bu modelle birlikte işletim sistemi olarak TOPS-10 isimli bir sisteme geçti.

    1960'lı yılların sonuna kadar işletim sistemleri ağırlıklı olarak sembolik makine diliyle yazılıyordu. 1960’lı yılların
    sonlarında AT&T Bell Lab. tarafından UNIX işletim sistemi geliştirildiğinde önemli bir devrim yaşandı. UNIX işletim 
    sistemi 1973 yılında C ile yeniden yazılmıştır. Böylece artık işletim sistemlerinin yüksek seviyeli dillerle de yazılabildiği
    görülmüştür. PDP-11'i 16 bitlik PDP-12 izledi. PDP-12 Intel'in x86 ve Motorola'nın 6800 işlemcileri için ilham kaynağı
    olmuştur.

    1970’li yılların ikinci yarısında entegre devrelerin de geliştirilmesiyle "ev bilgisayarları (home computer)" ortaya 
    çıkmaya başladı. Bunlarda genellikle BASIC yorumlayıcıları ile iç içe geçmiş CP/M tya da GEOS işletim sistemleri kullanılıyordu.
    1970'li yıllarda pek çok firma farklı ev bilgisayarları üretmiştir. BBC Micro, Commodore 64, Apple II, Atari, Amstrad, 
    ZX Spectrum dönemin en ünlü ev bilgisayarlarındandı. Bu makinelerde kullanılan işlemciler Intel'in 8080'i, Zilog'un 
    Z80'i, Motorola'nın 6800'ü gibi 8 bitlik işlemcilerdi.

    DEC firması 1977 yılında VAX isimli bilgisayarı ve 32 bitlik işlemci birimini piyasaya sürdü. VAX ailesi makineler o 
    yıllarda önemli bi ticari başarı kazanmıştır. DEC VAX makineleri için VAX/VMS isimli bir işletim sistemi yazmıştı. DEC 
    bu işletim sisteminin ismini 1992 yılında OpenVMS olarak değiştirdi. DEC 1992 yılında 64 bitlik RISC tasarımı olan Alpha 
    işlemcilerini piyasaya sürdü ve OpenVMS Alpha işlemcilerine port edildi. OpenVMS hala kullanılmaya devam etmektedir. 
    Itanium ve X86-64 portları da vardır.

    Apple firması 1976 yılında kuruldu. Apple'ın ilk bilgisayarı Apple I idi. Bunu 1977'de Apple II, 1980'de de Apple III 
    izledi. Bu ilk Apple bilgisayarlarında AppleDOS isimli işletim sistemleri kullanılıyordu. Daha sonra Apple 1983'te 
    Lisa modelini piyasaya sürdü. 1983'ün sonlarında da ilk Macintosh bilgisayarını çıkarttı. Lisa ile birlikte Apple 
    grafik tabanlı işletim sistemlerine geçiş yaptı. Lisa ve sonraki Apple bilgisayarlarının hepsi grafik bir arayüze 
    sahiptir. Macintosh markası daha sonra Mac olarak telaffuz edilmeye başlandı. Lisa bilgisayarlarında kullanılan i
    şletim sistemi LisaOS ismindeydi. Apple daha sonra Machntosh bilgisayarlarının değişik versiyonlarını piyasaya sürdü. 
    Bunlardaki işletim sistemini "System Software 1 (1984), System Software 2 (1985), System Software 3 (1986), System 
    Software 4 (1987), System Software 5 (1987), System Software 6 (1988), ve System Software 7 (1991)" olarak isimlendirdi. 
    Apple System Software 7.5'ten sonra işletim sisteminin ismini "System Software" yerine Mac OS olarak değiştirdi ve 
    System Software 7.6 versiyonu Mac OS 7.6 ismiyle çıktı. Daha sonra Apple 1997 yılında Mac OS 8'i, 1999 yılında da 
    Mac OS 9'u çıkarmıştır.

    1980'li yıllarda Mac bilgisayarlarının fiyatı çok yüksekti ve satışları da iyi gitmiyordu. Çünkü Steve Jobs bilgisayarların
    program yazmak için değil kullanmak için alınması gerektiğini düşünüyordu. Nihayet Apple'daki çalkantılar sonucunda
    Steve Jobs 1985 yılında Apple'dan ayrılmak zorunda kaldı (kovuldu da denebilir) ve NeXT firmasını kurdu. NeXT firması
    NeXT isimli bilgisayarları geliştirdi. Bu bilgisayarlarda NeXTSTEP isimli işletim sistemi kullanılıyordu. Daha sonra 
    bu sistem açık hale getirildi ve OPENSTEP ismini aldı. Dünyanın ilk Web tarayıcısı Tim Barners Lee tarafından Cern’de 
    NeXT bilgisayarları üzerinde gerçekleştirilmiştir.

    Steve Jobs 1997 yılında Apple’a geri döndü. Apple da NeXT firmasını 200 milyon dolara satın aldı. Sonra piyasaya iMac 
    ve Power Mac serileri çıktı. Daha sonra Steve Jobs Mac’lerin çekirdeklerini tamamen değiştirme kararı aldı. Mac’ler 
    Mac OS'un 10 versiyonu ile birlikte yeni bir çekirdeğe geçtiler. Mac OS işletim sistemlerinin 10'lu versiyonları Roma 
    rakamıyla Mac OS X biçiminde isimlendirilmiştir. Apple Mac OS X ismini 2012 yılında Mountain Lion (10.8) sürümü ile 
    OS X olarak, 2016 yılında da Sierra (10.12) sürümüyle birlikte de macOS olarak değiştirmiştir.

    DOS işletim sistemi text ekranda çalışıyordu. Microsoft da geleceğin grafik tabanlı işletim sistemlerinde olduğunu 
    gördü ve yavaş yavaş DOS'u bırakarak grafik tabanlı bir sisteme geçmeyi planladı. Bunun için Windows isimli grafik 
    arayüzün birinci versiyonunu 1985'te çıkardı. Bunu 1987'de Windows 2, 1990'da Windows 3.0 ve 1992'de de Windows 3.1 
    izledi. Bu 16 bit Windows sistemleri işletim sistemi değildi. DOS üzerinden çalıştırılan birer grafik arayüz gibiydi. 
    Microsoft daha sonra Windows'u Windows NT 3.1 ile bağımsız bir işletim sistemi haline getirdi. Microsoft bundan sonra 
    sırasıyla 1994 yılında Windows NT 3.5'i, 1995 yılında Windows NT 3.51'i ve Windows 95'i, 1998 yılında Windows 98'i, 
    2000 yılında Windows 2000 ve Windows ME'yi, 2001 yılında Windows XP'yi, 2006 yılında Windows Vista'yı, 2012 yılında 
    Windows 8'i, 2015 yılında Windows 10'u ve nihayet 2021 yılında da Windows 11'i çıkarmıştır.

    Linux işletim sistemi 1992 yılında bir dağıtım biçiminde piyasaya çıkmıştır. Linux işletim sisteminin hikayesi daha 
    geniş olarak izleyen paragraflarda ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX türevi işletim sistemlerinin tarihsel gelişimi üzerinde durmak istiyoruz. UNIX İşletim sistemi AT&T Bell 
    Laboratuvarlarında 1969-1971 yılları arasında geliştirildi. Proje ekibinin lideri Ken Thompson'du. Çalışma ekibinde 
    Dennis Ritchie, Brian Kernighan gibi önemli isimler de vardı. Ekip daha önce General Electrics'in GE-645 main frame 
    bilgisayarı için Multics işletim sistemi üzerinde çalışıyordu. (Multics işletim sisteminin geliştirilmesine 1964 yılında 
    başlandı. Projede General Electric, MIT ve Bell Lab birlikte çalışıyordu. Sonra proje Honeywell şirketi tarafından 
    devralınmıştır.)

    AT&T 1969 yılında bu projeden çekilerek kendi işletim sistemini geliştirmek istemiştir. Geliştirme çalışmasına DEC'in
    PDP-7 makinelerinde başlanmıştır. UNIX ismi 1970 yılında Brian Kernighan tarafından Multics'ten kelime oyunu yapılarak
    uydurulmuştur. Proje ekibi AT&T'yi DEC PDP-11 almaya ikna etti ve böylece geliştirme çalışmaları PDP-11 ile devam etti.
    UNIX'in resmi olarak ilk sürümü Ekim 1971'de ikinci sürümü Aralık 1972'de, Üçüncü ve dördüncü sürümleri de 1973 yılında 
    yayınlanmıştır. UNIX işletim sistemi büyük ölçüde PDP'nin sembolik makine dili ve Ken Thompson'ın B isimli programlama 
    diliyle geliştirilmiştir. B programlama dili fonksiyonları alıp DEC'in makine diline dönüştürüyordu. Bu bakımdan B bir 
    yorumlayıcı değil derleyiciydi. İşte 1972 yılında Dennis Ritchie, Ken Thompson'ın B programlama dilinden hareketle C 
    Programlama dilini geliştirmiştir. UNIX işletim sisteminin dördüncü sürümü 1973 yılında yeniden C Programlama Dili ile 
    yazılmıştır. 1974 yılında UNIX'in beşinci sürümü oluşturuldu. Bu sürümlerin hepsi araştırma amaçlıydı ve "educational 
    license" ismiyle lisanslanmıştı. UNIX işletim sistemi bir araştırma projesi olarak organize edilmişti. Bu nedenle AT&T 
    kaynak kodlarını araştırma kuruluşlarına ücretsiz dağıtılmıştır. 1975 yılında UNIX'in altıncı sürümü şirketlere yönelik 
    hazırlandı. UNIX'in altıncı versiyonunun kaynak kodları 20,000 dolara (şimdikinin 120,000 doları) şirketlere sunuldu. 
    1977 yılında Bell Lab, UNIX'i Interdata 7/32 isimli 32 bit mimariye port etti. Bunu 1978'de VAX portu izledi.

    1974 yılında California Üniversitesi (Berkeley) işletim sisteminin kopyasını Bell Lab'tan aldı. 1978 yılında "Berkeley
    Software Distribution (1BSD)" ismiyle AT&T dışındaki ilk UNIX dağıtımını gerçekleştirdi. Bu dağıtım hayatını hala FreeBSD, 
    OpenBSD ve NetBSD olarak devam ettirmektedir. 1979'da BSD'nin ikinci versiyonu (2BSD) ve 1979'un sonlarına doğru da üçüncü 
    versiyonu (3BSD) piyasaya sürüldü. Bunu 1980 yılında versiyon 4 (4BSD) izlemiştir. 1991 yılında BSD UNIX'ten AT&T kodları 
    tamamen arındırılmış ve kod bakımından özgün hale getirilmiştir. BSD'nin son versiyonu 1995'te 4.4BSD Lite Release 2 
    olarak çıkmıştır.

    1980'li yıllarda pek çok kurum ve ticari firma UNIX kodlarını lisans ücreti ödeyerek AT&T'den satın alıp kendilerine 
    yönelik UNIX sistemleri oluşturmuştur. Bunların önemli olanları şunlardır:

    AIX: IBM tarafından geliştirilmiş olan UNIX türevi sistemlerdir. İlk kez 1986 yılında piyasaya sürülmüştür. IBM AIX'i
    System/370, RS/6000 PS2 bilgisayarlarında kullanıyordu. Bu sistemler AT&T UNIX System 5 kodları temel alınarak geliştirilmiştir. 
    AIX hala kullanılmaktadır. Son sürümü 2021 yılında 7.3 olarak piyasaya sürülmüştür. AIX PowerPC, x86 işlemcileri için de 
    port edilmiştir.

    IRIX: SGI firması tarafından AT&T ve BSD kodları değiştirilerek 1988'de oluşturulmuştur. 2006'da bırakılmıştır.

    HP-UX: HP 9000 bilgisayarları için 1982'de oluşturulmuştur. Motorola 68000 ve Itanium işlemcileri için yazılmıştır. 
    Hala devam ettirilmektedir.

    ULTRIX: DEC firmasının PDP-7, PDP-11 ve VAX donanımları için geliştirdiği UNIX sistemiydi. İlk versiyonu 1984 yılında
    çıktı. 1995 yılında piyasadan çekildi.

    XENIX: Microsoft tarafından 1980 yılında geliştirilmeye başlanmıştır. İlk versiyonu 1980'in sonlarına doğru çıkmıştır.
    Daha sonra SCO firması Microsoft'la bu konuda iş birliği yapmış 1987 yılında da Microsoft sistemi tamamen SCO'ya
    devretmiştir. Bu sistemi daha sonra SCO firması, SCO-UNIX olarak devam ettirmiştir.

    SCO-UNIX: SCO firması XENIX'i Microsoft'tan alınca bunu SCO-UNIX olarak devam ettirdi. SCO-UNIX'in ilk versiyonu 1989
    yılında çıktı. SCO sonra bunu OpenServer ismiyle devam ettirmiştir.

    FreeBSD, NETBSD ve OpenBSD: 4.3BSD sistemleri temel alınarak geliştirilmiştir. FreeBSD ve NetBSD 1993 yılında, OpenBSD 
    ise 1996 yılında piyasaya çıkmıştır. Sürdürülmeye devam etmektedir. Önemli bir UNIX varyantı durumundadır. Bu üç 
    sistem de birbirlerine çok benzemektedir. FreeBSD genel amaçlı client ve server işletim sistemi olma niyetindedir. 
    NetBSD daha taşınabilirdir ve geniş bir port'a sahiptir. Daha çok bilimsel çalışmalarda tercih edilmektedir. OpenBSD 
    güvenliğin önemli olduğu alanlarda tercih edilmektedir.

    SunOS (Solaris): Sun firmasının BSD kodlarıyla oluşturduğu UNIX türevi işletim sistemiydi. İlk versiyonu 1982 yılında 
    çıktı. SunOS işletim sistemi 5.2 versiyonundan sonra (1992) Solaris ismiyle pazarlanmaya başlamıştır. Solaris daha
    sonra OpenSolaris biçminde açık kaynak kodlu olarak bir süre varlığını devam ettirdi. Oracle firmasının Sun firmasını
    2010'da satın almasındna sonra bu proje de durduruldu. Bu proje Illumos ismiyle başka ekip tarafından devam ettirilmektedir. 

    Linux: Linux Torvalds'ın öncülüğünde geliştirilmiş en yaygın UNIX türevi işletim sistemidir. İlk versiyonu 1991 
    yılında çıkmıştır. Hala devam ettirilmektedir. Linux'un tarihsel gelişimi izleyen bölümde ayrıntılı bir biçimde 
    açıklanmaktadır.

    Mac OS X, OS X, macOS: Carnegie Mellon üniversitesinin Mach isimli çekirdeği ile BSD UNIX sisteminin bir araya getirilmesiyle 
    oluşturulmuştur. İlk versiyonu 2001 yılında piyasaya sürülmüştür. İzleyen bölümlerde Mac OS işletim sistemlerinin 
    tarihsel gelişimi ayrıntılı olarak ele alınmaktadır.

    İzleyen paragrafta özel olarak Linux sistemlerinin tarihsel gelişimi üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin tarihsel gelişimini ele aldığımız önceki bölümde de belirttiğimiz gibi Apple firmasının Mac 
    bilgisayarları Mac OS'un 10 versiyonu ile birlikte yeni bir çekirdeğe geçtiler. Mac OS işletim sistemlerinin 10'lu
    versiyonları Roma rakamıyla Mac OS X biçiminde isimlendirildi. Apple Mac OS X ismini 2012 yılında Mountain Lion (10.8)
    sürümü ile OS X olarak, 2016 yılında da Sierra (10.12) sürümüyle birlikte de macOS olarak değiştirdi. Biz Mac OS X, 
    OS X ve macOS sistemlerine bu bölümde "Mac OS X türevi sistemler" de diyeceğiz.

    Mac OS X türevi işletim sistemleri UNIX türevi sistemlerdir. Bu işletim sistemlerinin çekirdeğine Darwin denilmektedir.
    Darwin açık kaynak kodlu bir işletim sistemdir. Ancak Mac OS X türevi sistemler tam anlamıyla açık sistemler değildir. 
    Bu sistemlerin çekirdeği açık olsa da geri kalan kısımları mülkiyete sahip (proprietary) biçimdedir.

    Darwin'in hikayesi 1989 yılında NeXT'in NeXTSTEP işletim sistemiyle başladı. NeXTSTEP daha sonra OpenStep ismiyie API 
    düzeyinde standart hale getirildi. 1996'nın sonunda 1997'nin başında Steve Jobs Apple'a dönerken Apple da NeXT firmasını 
    satın aldı ve sonraki işletim sistemini OpenStep üzerine kuracağını açıkladı. Bundan sonra Apple 1997’de OpenStep üzerine 
    kurulu olan Rapsody'yi çıkardı. 1998'de de yeni işletim sisteminin Mac OS X olacağını açıkladı. Daha sonra 2000 yılında 
    Apple Rapsody'den Darwin projesini türetti. Darwin her ne kadar Mac sistemlerinin çekirdeği olarak tasarlanmışsa da ayrı 
    bir işletim sistemi olarak da yüklenebilmektedir. Ancak Darwin grafik arayüzü olmadığı için Mac programlarını çalıştıramamaktadır. 
    Daha sonra Darwin'i bağımsız bir işletimn sistemi haline getirmek amacıyla Darwin'den de çeşitli projeler türetilmiştir. 
    Bunlardan biri Apple tarafından 2002'de başlatılan OpenDarwin'dir. Bu proje 2006'da sonlandırılmıştır. 2007'de PureDarwin 
    projesi başlatılmıştır.

    Darwin'in çekirdeği XNU üzerine oturtulmuştur. XNU NeXT firması tarafından NEXTSTEP işletim sisteminde kullanılmak üzere 
    geliştirilmiş bir çekirdektir. XNU, Carnegie Mellon ("Karnegi" diye okunuyor) üniversitesi'nin Mach 3 mikrokernel çekirdeği 
    ile 4.3BSD karışımı hibrit bir sistemdir.

    Mac OS X türevi sistemlerin versiyonları şunlardır:

    - Mac OS X 10.0 (Cheetah, 2001)
    - Mac OS X 10.1 (Puma, 2001)
    - Mac OS X 10.2 (Jaguar, 2002)
    - Mac OS X 10.3 (Panther, 2003)
    - Mac OS X 10.4 (Tiger, 2005)
    - Mac OS X 10.5 (Leopard, 2007)
    - Mac OS X 10.6 (Snow Leopard, 2009)
    - Mac OS X 10.7 (Lion, 2011)
    - OS X 10.8 (Mountain Lion, 2012)
    - OS X 10.9 (Maverics, 2013)
    - OS X 10.10 (Yosemite, 2014)
    - OS X 10.11 (El Capitan, 2015)
    - macOS 10.12 (Sierra, 2017)
    - macOS 10.13 (High Sierra, 2017)
    - macOS 10.14 (Mojave, 2018)
    - macOS 10.15 (Catalina, 2019)
    - macOS 11 (Big Sur, 2020)
    - macOS 12 (Monterey, 2021)
    - macOS 13 (Ventura, 2022)
    - macOS 14	(Sonoma, 2023)
    - macOS 15	(Sequoia, 2024)

    MacOS büyük ölçüde POSIX uyumlu bir sistemdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX/Linux dünyasında önemli bir yeri olan "GNU Projesi", "özgür yazılım" ve "açık kaynak kod akımları" üzerinde
    durmak istiyoruz.

    1970'lerdeki mikro bilgisayarlar devrimine kadar yazılımda bir telif anlayışı yoktu. Yani yazılımın dağıtılması konusunda
    sözleşmeler ve hukuki yaptırımlara gerek duyulmamıştı. Yazılım zaten donanımla birlikte satılıyordu ya da kuruma özel
    yapılıyordu. 1969 yılında IBM yazılımı donanımla birlikte verdiği için rekabet kurallarına uymadığı gerekçesiyle mahkemeye 
    verilmiştir ve cezaya çarptırılmıştır. 1970'li yıllarda yazılım maliyetleri artmış, yazılım sektörü genişlemiş ve lisanslama 
    politikaları da uygulamaya sokulmuştur. Pek çok yazılım bu yıllarda özel lisanslarla piyasaya sürülmeye başlanmıştır. 
    1980'li yıllarda bu lisanslama faaliyetleri hız kazanmıştır.

    1980'li yıllarda tüm UNIX türevi sistemler çeşitli biçimlerde sınırlandırıcı lisanslara sahipti. Yani 1980'li yıllarda 
    sınırlaması olmayan UNIX türevi sistemler kalmamıştı. Bu nedenle bedava ve sınırlamasız UNIX türevi bir işletim sistemine
    gereksinim duyulmaya başlandı. İşte durumdan vazife çıkaran ünlü Emacs editörünün yazarı Richard Stallman 1983 yılının 
    sonlarına doğru GNU projesini başlattı ve özgür yazılım (free software) fikrini oraya attı. GNU projesinin amacı açık
    kaynak kodlu UNIX benzeri bir işletim sistemini ve geliştirme araçlarını yazmaktı. Proje fiilen 1984 yılında başlamıştır.

    Stallman 1985 yılında özgür yazılım kavramını yaygınlaştırmak amacıyla Free Software Foundation (www.fsf.org) isimli
    kurumu kurdu ve atık GNU projesi bu kurum tarafından yürütülmeye başlandı. FSF özgür yazılım modeli için GPL (GNU Public 
    License) denilen lisansı ortaya çıkardı. Özgür yazılım akımında oluşturulan bir yazılım istenildiği gibi çalıştırılabilir,
    kopyalanabilir, incelenebilir, dağıtılabilir, değiştirilebilir ve iyileştirilebilir. Daha açık bir biçimde özgür yazılım 
    tipik olarak aşağıdaki dört özgürlükle tanımlanmıştır:

    Özgürlük 0: Programı her türlü amaç için çalıştırma özgürlüğü
    Özgürlük 1: Programın kaynak kodunu inceleme ve değiştirebilme özgürlüğü
    Özgürlük 2: Programın kopyalarını çıkartabilme ve yeniden dağıtabilme özgürlüğü
    Özgürlük 3: Programı iyileştirebilme ve iyileştirilmiş programı yayınlama özgürlüğü

    GNU projesi bağlamında pek çok temel araç (gcc derleyici, ld bağlayıcı vs.) geliştirilmiştir. Fakat hedeflenen bir çekirdek
    bir türlü oluşturulamamıştır.

    Aslında özgür yazılım (free software) ile açık kaynak kod (open source) akımları arasında bazı farklar olmakla birlikte 
    her iki akımın da hedefleri benzerdir. Özgür yazılım bir sosyal harekete benzetilirken açık kaynak kod akımı bir geliştirme
    metodolojisine benzetilmektedir. Biz kursumuzda tüm bu akımları "açık kaynak kod (open source)" olarak nitelendireceğiz. 
    Özgür yazılım akımının temel lisansı GPL'dir (GNU Public Licence). Bunun yumuşatılmış LGPL (Lesser GPL) biçiminde bir 
    versiyonu da oluşturulmuştur. Ayrıca Apache, MIT, BSD gibi açık kaynak kodlu başka lisanslar da vardır. Şüphesiz bu 
    lisansların aralarında birtakım farklılıklar bulunmakla birlikte pek çok yönleri de ortaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Açık kaynak kodlu yazılımlar bir araya getirilip paketlenerek istenildiği gibi dağıtılabilmektedir. Dağıtım (distribution) 
    bu anlamda kullanılan genel bir terimdir ve her türlü açık kaynak kodlu yazılım için dağıtım söz konusu olabilir. 
    Ancak biz burada Linux dağıtımları üzerinde duracağız.

    Linux temel olarak bir çekirdek geliştirme projesidir. Linux kaynak kodlarına baktığınızda tüm kodların çekirdekle ilgili 
    olduğunu görürsünüz. Çekirdeğin dışındaki tüm yazılımlar (örneğin init prosesinden başlayarak, kabuk yazılımları, paket 
    yöneticileri, pencere yöneticileri vs.) hep başka proje grupları tarafından gerçekleştirilmiş açık kaynak kodlu yazılımlardır. 
    İşte tüm bu açık kaynak kodlu yazılımların Linux çekirdeği temelinde bir araya getirilmesi ve doğrudan kullanıcının install 
    edip çalıştırabileceği biçimde paketlenmesine Linux dağıtımları denilmektedir. Linux dağıtımları pencere yöneticileri (KDE, 
    GNOME gibi), paket yöneticileri (APT, RPM, YUM, DPKG, PACMAN, ZYPPER gibi) ve diğer yararlı uygulama programları bakımından 
    farklılıklar gösterebilmektedir.

    Toplamda iki yüzün üzerinde Linux dağıtımının olduğu söylenebilir. Ancak bunlar arasında az sayıda dağıtım çok popüler
    olmuştur. Bazı dağıtımlar bazı dağıtımlardan fork edilerek oluşturulmuştur. Aşağıda en çok kullanılan dağıtımlara 
    ilişkin dağıtım ağacını veriyoruz:

    Linux
    ├── Debian
    │   ├── Ubuntu
    │   │   ├── Linux Mint
    │   │   ├── Pop!_OS
    │   │   ├── elementary OS
    │   │   └── Zorin OS
    │   ├── Devuan       # Systemd olmayan Debian
    │   └── Kali Linux   # Güvenlik test amaçlı
    ├── Red Hat Linux (eski)
    │   ├── Fedora       # Topluluk temelli, RHEL'in test yatağı
    │   │   └── RHEL (Red Hat Enterprise Linux)
    │   │       ├── CentOS (→ 2021 sonrası CentOS Stream)
    │   │       ├── AlmaLinux
    │   │       └── Rocky Linux
    ├── Slackware
    │   └── Slax         # Hafif sürüm
    ├── Arch Linux
    │   ├── Manjaro
    │   └── EndeavourOS
    ├── Gentoo
    │   └── Calculate Linux
    ├── SUSE Linux
    │   ├── openSUSE Leap
    │   └── openSUSE Tumbleweed
    ├── Android          # Mobil, Linux çekirdeğine dayalı
    ├── Alpine Linux     # Minimal, güvenli, konteyner dostu
    └── Chrome OS
        └── Chromium OS  # Açık kaynak tabanı
   
    Burada en çok kullanılan Linux dağıtımlarından bahsedeceğiz.

    Debian Dağıtımı: En önemli ve en eski Linux dağıtımlarından biridir. Knoppix, Mint, Ubuntu dağırımları Debian türevi 
    dağıtımlardır.

    Fedora: Red Hat firması tarafından çıkarılmış olan dağıtımdır. İlk kez 2003 yılında oluşturulmuştur. RPM paket yöneticisini 
    kullanır. CentoOS ve Scientific Linux en önemli Fedora türevi dağıtımlardır. 2000 yılında ilk sürümü yapılan Red Hat 
    Enterprise Linux (RHEL) en önemli Fedora türevidir. Ondan da CentOS, Scientific Linux gibi dağıtımlar türetilmiştir. 
    CentOS server makinelerde en yaygın kullanılan Linux versiyonudur.

    OpenSUSE: Alman SUSE firmasının desteklediği dağıtımdır. SUSE Linux Enterprise isminde ticari bir versiyonu da vardır.
    ZYpp, YaST ve RPM paket yöneticilerini kullanmaktadır.

    Slackware: En eski Linux dağıtımıdır. 1993 yılında oluşturulmuştur. Sürdürümü yavaş olmakla birlikte hala devam 
    etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    1980'li yıllarda AT&T ya da BSD kodlarından türetilmiş olan ve çoğunluğu şirketlere ait olan pek çok UNIX türevi sistem 
    oluşturuldu. Bu sistemler birbirlerine çok benzemekle birlikte aralarında bazı farklılıklara da sahipti. İşte IEEE durumdan 
    vazife çıkartarak bu UNIX türevi sistemleri standardize etmek için kolları sıvadı ve bunun sonucu olarak da POSIX 
    standartlarını oluşturdu.

    POSIX sözcüğü Richard Stallman tarafından önerilmiştir. "Portable Operating System Interface for UNIX" sözcüklerinden
    kısaltılarak uydurulmuştur ve "poziks" biçiminde okunmaktadır. POSIX standartları üzerinde çalışmalar 1985 yılında
    başlamıştır ve ilk standartlar 1988 yılında "IEEE Std 1003.1-1988" kod numarasıyla oluşturulmuştur. POSIX her ne kadar
    UNIX türevi sistemler için düşünülmüşse de UNIX türevi mimariye sahip olamayan sistemler için de kullanılabilecek bir
    standarttır. (Örneğin Windows sistemleri Interix denilen alt sistemle POSIX uyumlu olarak da kullanılabilmekteydi.
    Interix alt sistemi daha sonra Windows 8 ile birlikte Windows'tan kaldırılmıştır.)

    POSIX standartları 4 bölümden oluşmaktadır:

    1) Base Definitions: Bu bölümde temel tanımlamalar bulunmaktadır.
    2) Shell & Utilities: Bu bölümde kabuk komutları ve standart utility programlar ele alınmaktadır.
    3) System Interfaces: Bu bölümde C programcıları için hazır bulunan POSIX fonksiyonları açıklanmaktadır.
    4) Rationale: Çeşitli kuralların ve özelliklerin gerekçeleri bu bölümde açıklanmaktadır.

    POSIX standartlarının zaman içerisinde çeşitli versiyonları çıkartılmıştır. Bu versiyonlarda hem yeni POSIX fonksiyonları
    kütüphaneye eklenmiş hem de standartlardaki bazı bozukluklar ve uyumsuzluklar düzeltilmiştir. Standardın önemli versiyonları 
    şu senelerde yayınlanmıştır: 1992, 1993, 1995, 1997, 2001, 2004, 2008, 2017. Standartlardaki en önemli değişim 1993 
    yılında "POSIX 1.b" diye de isimlendirilen "Realtime-extensions" ile 1995 yılında "POSIX 1.c" diye isimlendirilen 
    "Thread-extensions" isimli eklemelerdir. Bu eklemelerle POSIX'e gerçek zamanlı işlemler için çeşitli özelliklerle thread 
    kullanımı eklenmiştir.

    Single UNIX Specification UNIX türevi sistemler için oluşturulmuş diğer önemli standarttır. Bir sistemin UNIX olarak
    değerlendirilebilmesi için bu standartlara uygun olması gerekmektedir. Standartlar "Austin Group" isimli toplulukla
    "Open Group" isimli dernek tarafından geliştirilmiştir. Sürdürümü Open Group tarafından yapılmaktadır. Open Group
    hali hazırda UNIX sistemlerinin isim haklarını elinde bulundurmaktadır. Single UNIX Specification isimli standardın
    zamanla pek çok versiyonu oluşturulmuştur.

    POSIX standartları ile Single UNIX Specification standartları arasında eskiden daha fazla farklılıklar vardı. Ancak bugün 
    itibari ile bu iki standart birbirlerine yaklaştırılmış ve son versiyonlarla aynı hale getirilmiştir. Single UNIX 
    Specification dokümanlarına Internet'ten Open Group'un web sitesinden erişilebilir:
    
    https://pubs.opengroup.org/onlinepubs/9699919799/
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yazılımda genel olarak kod tekrarı istenmez. Bu nedenle yazılım sistemleri katmanlı bir yapıya sahip olur. Örneğin B
    kütüphanesi A kütüphanesinin fonksiyonlarını kullanarak yazılmış olabilir. C kütüphanesi de B'yi kullanarak yazılmış
    olabilir. D de C'yi kullanmış olabilir:

                +-------------+
                |     D       |
                +-------------+
            +---------------------+
            |         C           |
            +---------------------+
        +-----------------------------+
        |             B               |
        +-----------------------------+
    +-----------------------------------+
    |                 A                 |
    +-----------------------------------+

    Kod tekrarının iki önemli dezavantajı vardır: Gereksiz kod büyümesi oluşur ve test ve bakım işlemlerinı zorlaştırır.

    Prosedürel programlama modelinde kod tekrarının engellenmesi için başvurulan tipik yöntem kodu alt programlara ayırıp 
    onları çağırmaktır. Örneğin C'de proje içerisinde bir kod parçasının çeşitli yerlerde yinelendiğini düşünelim. Bu kod 
    parçasını bir fonksiyon olarak bildirip tekrarlanan yerlerde o fonksiyonu çağırabiliriz. Aslında nesne yönelimli programlama 
    tekniğinde türetme işlemine de kod tekrarını engellemek için başvurulmaktadır. Bu teknikte iki sınıfın birtakım ortak 
    elemanları varsa bu ortak elemanlar bir taban sınıfta toplanır, bu iki sınıf da o taban sınıftan türetilerek gerçekleştirilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir yazılım sisteminde (bu bir işletim sistemi olabilir, framework olabilir, ya da başka bir yazılımlar olabilir) uygulama
    programcılarının doğrudan çağırabileceği, o sistem ile uygulama programcısı arasında köprü oluşturan fonksiyon ya da
    sınıf kümesine API denilmektedir. API aslında lastik bir terimdir. Hangi fonksiyonlara API denilebileceği tartışılabilir. 
    Fakat genel olarak API uygulama programcılarının ilgili sistem üzerinde birtakım faydalı işlemler yapabilmek için kullandıkları
    fonksiyon ya da sınıflardır. Örneğin Java API'leri denildiğinde Java sınıflarını, Windows API'leri denildiğinde Windows
    İşletim Sisteminde temel işlemleri yapmak için kullanılan fonksiyonları anlarız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kütüphane ve framework kavramlarının sınırları tam belli değildir. Değişik kaynaklar bu sınırları değişik biçimde
    çizebilmektedir. Fakat bir sistemin framework olarak tanımlanabilmesi için şu iki özelliğin bulunması gerektiği yönünde
    bir eğilim vardır:

    1) Karmaşıklığın kullanıcıya daha basit gösterilmesi ve yük oluşturan bazı sıkıcı işlemlerin kullanıcının üzerinden
    alınması.

    2) Kod akışının ele geçirilmesi ve duruma göre programcıya belli zamanlarda verilmesi (inversion of control).

    Halbuki kütüphanelerde arka planda birtakım işlemleri bizim için yapmak ve bir akışı ele geçirmek gibi bir amaç yoktur.
    Kütüphanelerde programın akışı bizdedir. Biz istersek kütüphane fonksiyonlarını çağırırız. Onlar da faydalı işlemleri
    yaparlar. Şüphesiz pek çok framework aynı zamanda birtakım kütüphanelere de (API'lere de) sahiptir. Bazı ara durumlarda 
    o şeyin framework olarak mı yoksa kütüphane olarak mı adlandırılacağı konusunda tereddütler olabilir. (Örneğin Qt için 
    ona kütüphane diyenler de framework diyenler de vardır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde aritmetik, mantıksal, bitsel işlemler ve karşılaştırma işlemleri mikroişlemci (microprocessor)
    denilen birim tarafından yapılmaktadır. Mikroişlemciler entegre devre biçiminde üretilmişlerdir. Mikroişlemcilere
    kavramsal olarak CPU (Central Processing Unit) de denilmektedir. Yani CPU mikroişlemcilerin kavramsal ismidir. Aslında
    bir bilgisayar sisteminde komut çalıştıran pek çok işlemci bulunabilmektedir. CPU bu işlemcileri de programlayan ana
    (merkezi) işlemcidir. (Bilgisayar sisteminde yerel bazı işlemlerden sorumlu yardımcı işlemciler de vardır. Örneğin "kesme
    denetleyicisi (interrupt controller)", "disk denetleyicisi (disk controller)", "DMA denetleyicisi (DMA controller)" gibi.)

    Kendi içerisinde CPU’su, RAM’i, ROM’u ve bazı çevre üniteleri de bulunan entegre devrelere "mirodenetleyici (microcontroller)" 
    denilmektedir. Mikrodenetleyicilerin işlem kapasiteleri ve içerdikleri bellek miktarları düşük olma eğilimindedir. Ancak 
    bunlar çok kolay programlanıp uygulamaya sokulabilmektedir. Mikro denetleyicilere "tek çiplik bilgisayar (single chip
     computer)" da denilmektedir. Mikrodenetleyiciler özellikle gömülü sistemlerde tercih edilirler. Bunların düşük güç 
     harcaması ve ucuz olmaları en büyük avantajlarındandır.

    Bazı firmalar ayrı birimler olarak tasarlanmış mikroişlemcileri, RAM'leri, ROM’ları ve diğer bazı üniteleri tek bir entegre
    devrenin içerisine sıkıştırmaktadır. Bunlara genel olarak "SOC (System On Chip)" denilmektedir. SOC mikrodenetleyicilere 
    benzese de aslında onlardan farklıdır. SOC’lar içerisindeki işlemcilerin ve belleklerin kapasiteleri yüksektir. Bunlar özel 
    amaçlı üretilirler ve bunların devrelerde kullanılmaları mikrodenetleyiciler kadar kolay değildir. Bunların en önemli 
    avantajları "az yer kaplamasıdır". Örneğin Raspberry Pi kitlerinde Broadcom isimli firmanın 2835, 2836, 2837 numaralı 
    SOC entegreleri kullanılmıştır. Bunların içerisinde Cortex A serisi ARM işlemcileri, RAM ve ROM bellekler bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Asıl amacı bilgisayar olmayan fakat bilgisayar devresi içeren sistemlere genel olarak gömülü sistemler denilmektedir.
    Örneğin elektronik tartılar, biyomedikal aygıtlar, GPS cihazları, turnike geçiş sistemleri, müzik kutuları vs. birer 
    gömülü sistemdir. Gömülü sistemlerde en çok kullanılan programlama dili C'dir. Ancak son yıllarda Raspberry Pi gibi, 
    Banana Pi gibi, Orange Pi gibi güçlü ARM işlemcilerine sahip kartlar çok ucuzlamıştır ve artık gömülü sistemlerde de 
    doğrudan kullanılır hale gelmiştir. Bu kartlar tamamen bir bilgisayarın işlevselliğine sahiptir. Bunlara genellikle Linux 
    işletim sistemi ya da Android işletim sistemi yüklenir. Böylece gömülü yazılımların güçlü donanımlarda ve bir işletim 
    sistemi altında çalışması sağlanabilmektedir. Örneğin Raspberry Pi’a biz Mono’yu yükleyerek C#’ta program yazıp onu 
    çalıştırabiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir programlama dilinde yazılmış olan programı eşdeğer olarak başka bir dile dönüştüren programlara çevirici programlar 
    (translators) denilmektedir. Çevirici programlarda dönüştürülmek istenen programın diline kaynak dil (source language), 
    dönüşüm sonucunda elde edilen programın diline de hedef dil (target/destination language) denir. Örneğin:

    C# Programı -----> Çevirici Program -----> VB.NET Programı

    Burada kaynak dil C#, hedef dil VB.NET'tir.

    Eğer bir çevirici programda hedef dil aşağı seviyeli bir dil ise (saf makine dili, arakod ve sembolik makine dilleri alçak
    seviyeli dillerdir) böyle çevirici programlara derleyici (compiler) denilmektedir. Her derleyici bir çevirici programdır 
    fakat her çevirici program bir derleyici değildir. Bir çevirici programa derleyici diyebilmek için hedef dile bakmak 
    gerekir. Örneğin arakodu gerçek makine koduna dönüştüren CLR bir derleme işlemi yapmaktadır. Sembolik makine dilini saf
    makina diline dönüştüren program da bir derleyicidir.

    Bazı programlar kaynak programı alarak hedef kod üretmeden onu o anda çalıştırırlar. Bunlara yorumlayıcı (interpreter)
    denilmektedir. Yorumlayıcılar birer çevirici program değildir. Yorumlayıcı yazmak derleyici yazmaktan daha kolaydır.
    Fakat programın çalışması genel olarak daha yavaş olur. Yorumlayıcılarda kaynak kodun çalıştırılması için onun başka
    kişilere verilmesi gerekir. Bu da kaynak kod güvenliğini bozar.

    Bazı diller yalnızca derleyicilere sahiptir (C, C++, C#, Java, Rust gibi). Bazıları yalnızca yorumlayıcılara sahiptir 
    (PHP, Perl gibi). Bazılarının hem derleyicileri hem de yorumlayıcıları vardır (Basic, Swift, Python gibi). Genel olarak 
    belli bir alana yönelik (domain specific) dillerde çalışma yorumlayıcılar yoluyla yapılmaktadır. Genel amaçlar diller 
    daha çok derleyiciler ile derlenerek çalıştırılırlar.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Alçak seviyeli dillerden yüksek seviyeli dillere dönüştürme yapan (yani derleyicilerin yaptığının tam tersini yapan)
    yazılımlara “decompiler” denilmektedir. Örneğin C#’ta yazılıp derlenmiş olan .exe dosyadan yeniden C# programı oluşturan 
    bir yazılım “decompiler”dır. Saf makine dilini decompile etmek neredeyse mümkün değildir. Ancak .NET’in arakodu olan 
    “CIL (Common Intermediate Language)” ve Java’nın ara kodu olan “Java Byte Code” kolay bir biçimde decompile edilebilmektedir. 
    C#’ta derlenmiş ve çalıştırılabilir hale getirilmiş dosyayı yeniden C#’a dönüştüren pek çok decompiler vardır (örneğin 
    Salamander, Dis#, Reflector, ILSpy gibi). İşte bu tür durumlar için C# ve Java programcıları kendileri bazı önlemler almak 
    zorundadırlar. Ancak C, C++ gibi doğal kod üreten derleyicilerin ürettiği kodlar geri dönüştürülememektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Derleyiciler komut satırından çalıştırılan programlardır. Bir programlama faaliyetinde program editör denilen bir program 
    kullanılarak yazılır. Diske save edilir. Sonra komut satırından derleme yapılır. Bu yorucu bir faaliyettir. İşte yazılım 
    geliştirmeyi kolaylaştıran çeşitli araçları içerisinde barındıran (integrated) özel yazılımlara IDE denilmektedir. IDE'lerin 
    editörleri vardır, menüleri vardır ve çeşitli araçları vardır. IDE'lerde derleme yapılırken derlemeyi IDE'lerin kendisi 
    yapmaz. IDE derleyiciyi çalıştırır. IDE yardımcı bir araçtır, mutlak gerekli bir araç değildir.

    Yazılım geliştirme sürecinde IDE'ler özellikle bazı dillerde yoğun olarak kullanılmaktadır. Microsoft'un ünlü IDE'sine "Visual 
    Studio" denilmektedir. Apple firmasının da "XCode" isimli bir IDE'si vardır. Bazı IDE'ler açık kaynak kodlu biçimde yazılmıştır. 
    Dolayısıya bu IDE'ler aynı zamanda bedavadır. Bazı IDE'ler paralı olsa da bunların parasız versiyonları da oluşturulmuştur. 
    Yine IDE'lerin bazıları "cross platform" özelliğe sahiptir. Yani hem Windows sistemlerinde hem macOS sistemlerinde hem de 
    Linux sistemlerinde aynı arayüz ile kullanılabilmektedir. Belli bir süredir IDE'ler artık bir plugin mimarisi ile tasarlanmaktadır. 
    Böylece IDE'lerin işlevleri üçüncü parti plugin'lerle değiştirilebilmektedir. Bazı IDE'ler yalnızca belli bir programlama 
    dili için oluşturulmuştur. Bazı IDE'ler ise pek çok programlama dilini desteklemektedir.

    Bazı araçlar tam bir IDE gibi olmasa da IDE'ye benzer özelliklere sahiptir. Bunlar adeta editör ile IDE arasında bir konumda 
    bulunmaktadır. İngilizce bunlara "lightweight IDE (hafif siklet IDE)" de denilmektedir. Günümüzde bu editör ile IDE arasında 
    kalan araçlardan en yaygın kullanılanı Microsoft'un geliştirdiği VSCode isimli programdır.

    UNIX/Linux sistemlerinde C ve C++ IDE'si olarak QtCreator, VSCode, KDevelop, Eclipse (CDT) kullanılabilir. Ancak kursumuzdaki 
    uygulamalarda bir IDE kullanmayacağız. Kodları bir VSCode gibi bir editörde yazıp programlarımız komut satırından derleyeceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kullandığımız CPU'lar ikilik sistemdeki makine komutlarını çalıştırmaktadır. Bir kodun CPU tarafından çalıştırılabilmesi
    için o kodun o CPU'nun makine diline dönüştürülmüş olması gerekir. Zaten derleyiciler de bunu yapmaktadır. Eğer bir
    derleyici o anda çalışılmakta olan makinenin CPU'sunun işletebileceği makine kodlarını üretiyor CPU da bunları çalıştırıyorsa 
    buna doğal kodlu (native code) çalışma denilmektedir. Örneğin C ve C++ programlama dillerinde doğal kodlu çalışma uygulanmaktadır. 
    Biz bu dillerde bir programı yazıp derlediğimizde artık o derlenmiş program ilgili CPU tarafından çalıştırılabilecek doğal 
    kodları içermektedir.

    Bazı sistemlerde derleyiciler doğrudan doğal kod üretmek yerine hiçbir CPU'nun makine dili olmayan (dolayısıyla hiçbir
    CPU tarafından işletilemeyen) yapay bir kod üretmektedir. Bu yapay kodlara genel olarak "ara kodlar (intermediate codes)" 
    denilmektedir. Bu arakodlar doğrudan CPU tarafından çalıştırılamazlar. Arakodlu çalışma Java ve .NET dünyasında ve daha 
    başka ortamlarda kullanılmaktadır. Java dünyasında Java derleyicilerinin ürettikleri ara kodu "Java Bytecode", .NET (CLI) 
    dünyasında ise "CIL (Common Intermediate Language)" denilmektedir. Pekiyi bu arakodlar ne işe yaramaktadır? İşte bu arakodlar 
    çalıştırılmak istendiğinde ilgili ortamın alt sistemleri devreye girerek önce bu arakodları o anda çalışılan CPU'nun doğal 
    makine diline dönüştürüp sonra çalıştırmaktadır. Bu sürece (yani arakodun doğal makine koduna dönüştürülmesi sürecine)" 
    tam zamanında derleme (just in time compilation)" ya da kısaca "JIT derlemesi" denilmektedir. Java ortamında bu JIT derlemesi 
    yapıp programı çalıştıran alt sisteme "Java Sanal Makinesi (Java Virtual Machine)", .NET ortamında ise CLR (Common Language 
    Runtime)" denilmektedir.

    Şüphesiz doğal kodlu çalışma arakodla çalışmnadan daha hızlıdır. Pek çok benchmark testleri aradaki hız farkının %20 civarında 
    olduğunu göstermektedir. Pekiyi arakodlu çalışmanın avantajları nelerdir? İşte bu çalışma biçimi derlenmiş kodun platform 
    bağımsız olmasını sağlamaktadır. Buna "binary portability" de denilmektedir. Böylece arakodlar başka bir CPU'nun ya da 
    işletim sisteminin bulunduğu bir bilgisayara götürüldüğünde eğer orada ilgili ortam (framework) kuruluysa doğrudan 
    çalıştırılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Windows’ta Linux ortamının oluşturulması için iki yöntem kullanılabilmektedir.

    1) Cygwin Ortamı İle Oluşturma: Cygwin isimli ortam yapay biçimde bize Linux çalışma ortamını (genel olarak POSIX çalışma 
    ortamını) sunmaktadır. Cygwin bir sanal makine değildir. Bize yapay biçimde UNIX/Linux ortamı sunan bir yazılımdır. 
    Biz bu ortamda UNIX/Linux kabuk komutlarını, gcc, g++ gibi derleyicilerle POSIX fonksiyonlarını kullanabiliriz. Burada 
    geliştirdiğimiz programlar ilgili UNIX/Linux ortamına götürülerek yeniden derlenmek suretiyle çalıştırılabiir. Ancak Cygwin 
    ortamının bir sanallaştırma yapmadığına arka planda Windows’un olanaklarıyla UNIX/Linux ortamını emüle ettiğine 
    dikkat ediniz.

    2) Sanallaştırma Yoluyla: Bugün VMWare, VirtualBox, Xen gibi sanallaştırma ve hypervisor yazılımlarla orijinal işletim
    sisteminin kodları tamamen sanallaştırma yoluyla çalıştırılabilmektedir. Artık Cygwin kullanımı Windows sistemlerinde bu 
    nedenle çok azalmıştır. Sanallaştırmada "host" ve "guest" sistemler arasında "copy-paste" işlemleri de yapılabilmektedir.
    Sanallaştırma yazılımları "host" olarak Windows, Linux ve macOS sistemlerinde bulunmaktadır. Ayrıca Windows'ta Microsoft 
    tarafından geliştirilmiş olan "Windows Subsystem for Linux (WSL)" denilen Linux için bir sanallaştırma ortamı da bulunmaktadır.
    WSL'nin 2'nci versiyonu arka planda Microsoft'un "Hyper-V" denilen hypervisor programını kullanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Burada bir noktaya dikkatinizi çekmek istiyoruz: macOS sistemleri aslında belli derecede POSIX uyumu olan UNIX türevi bir 
    sistemdir. Dolayısıyla kursumuzda UNIX/Linux sistemi denildiğinde macOS sistemi de anlaşılmalıdır. Kursumuzdaki UNIX/Linux 
    sistemi için verilen örneklerin hepsi olmasa da büyük bölümü macOS sistemlerinde de benzer biçimde derlenerek çalıştırılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir C programını derlemek için önce programın bir metin editöründe yazılıp bir dosya biçiminde diskte saklanması gerekir. 
    Bundan sonra dosya ismi derleyicilere komut satırı argümanı biçiminde verilerek derleme gerçekleştirilmektedir. UNIX/Linux 
    sistemlerinde ağırlıklı olarak gcc ve clang derleyicileri kullanılmaktadır. Bu iki derleyicinin komut satırı seçenekleri 
    birbirleriyle uyumludur. Program bir metin editörde yazılıp saklandıktan sonra derleme işlemi komut satırından şöyle 
    yapılmaktadır:

    gcc -o <çalıştırılabilen dosya ismi> <kaynak dosya ismi>
    clang -o <çalıştırılabilen dosya ismi> <kaynak dosya ismi>

    Örneğin:
    $ gcc -o sample sample.c

    ya da örneğin:

    $ clang -o sample sample.c

    Eğer "-o seçeneği" kullanılmamışsa çalıştırılabilen dosyanın ismi "a.out" olacaktır.

    gcc ve clang derleyicileri default durumda derleme sonrasında bağlayıcıyı (linker) çalıştırmaktadır. Bağlama işlemi bittikten 
    sonra gcc ve clang oluşturulmuş olan amaç dosyayı (object file) da kendisi siler. UNIX/Linux sistemlerinde bağlama (linking) 
    işlemi GNU projesi kapsamında geliştirilmiş olan "ld" isimli bağlayıcı programıyla yapılmaktadır. Aslında biz derleme ve 
    bağlama işlemini ayrı ayrı iki aşamada da yapabiliriz. gcc ve clang derleyicilerinde -c seçeneği "yalnızca derle (only compile), 
    fakat bağlama" anlamına gelmektedir. Biz bir C programını yalnızca derleyip ondan amaç dosya elde edebiliriz. Örneğin:

    $ gcc -c sample.c

    Amaç dosyayı bağlamak için ld bağlayıcısı kullanılabilir. Ancak bu durumda bazı başlangıç dosyalarının (start-up object
    files) da bağlama işlemine dahil edilmesi gerekir. Biz bağlama işlemini de gcc (ya da clang ile) ile yapabiliriz. gcc 
    aslında bu durumda arka planda ld bağlayıcı programını çalıştırmaktadır. Örneğin:

    $ gcc -c sample.c
    $ gcc -o sample sample.o

    Bu biçimde gcc başlangıç dosyalarını da ld bağlayıcısına vererek bağlama işlemini ona yaptırmaktadır. UNIX/Linux 
    sistemlerinde bulunulan dizindeki bir programı komut satırından çalıştırabilmek için yalnızca dosyanın ismi yazılmaz. 
    Onun dizini de belirtilmelidir. Tipik çalıştırma şöyle yapılır:

    $ ./sample

    "." karakterinin "bulunulan dizini temsil ettiğini anımsayınız.

    GCC derleyicisi pek çok sisteme port edilmiştir. GCC'nin Windows portuna MinGW denilmektedir. gcc ve clang derleyicileri 
    varsayılan durumda durumda eğer sistem 32 bit ise 32 bit derleme, 64 bit ise 64 bit derleme yapmaktadır. Örneğin makinemizdeki 
    Linux sistemi 64 bit ise biz aşağıdaki gibi bir derlemeden 64 bit ELF formatına sahip bir çalıştırılabilir dosya elde ederiz:

    $ gcc -o sample sample.c

    64 bit Linux sistemlerinde 32 bit derleme yapmak için -m32 seçeneği kullanılmalıdır. Örneğin:

    $ gcc -m32 -o sample sample.c

    Pek çok 64 bit Linux sisteminde 32 bitlik derleme paketleri hazır olarak bulunmamaktadır. Bu nedenle 32 bit derleme için
    ek pakletlerin yüklenmesi gerekebilmektedir. Ubuntu türevi sistemlerde bu paketlerin yüklenmesi aşağıdaki komutla
    yapılabilir:

    $ sudo apt-get install g++-multilib libc6-dev-i386
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin çekirdeklerinde binlerce fonksiyon bulunmaktadır. Bunların küçük bir kısmı dışarıdan da (kullanıcı
    modundan) önemli bazı işleri yapmak için çağrılabilmektedir. Bunlara işletim sisteminin "sistem fonksiyonları (system call) 
    denilmektedir. Her işletim sisteminin sistem fonksiyonlarının isimleri, parametrik yapıları farklı olabilmektedir. Biz C 
    Programcısı olarak bu sistem fonksiyonlarını doğrudan çağırabiliriz. Ancak bu durumda her işletim sisteminin sistem fonksiyonları 
    farklı olduğu için taşınabilirlik sorunları ortaya çıkabilecektir.

    Programlarda sık karşılaşılan bazı işlemler aslında aşağı seviyede tamamen işletim sisteminin kontrolü altındadır. O
    faaliyetleri gerçekleştirmek isteyen herkes aslında eninde sonunda işletim sisteminin ilgili sistem fonksiyonunu çağırmak
    zorundadır. Örneğin bir dosyayı silmek için bir sistem fonksiyonu vardır. Kullandığımız dil ne olursa olsun, eninde
    sonunda dosya bu fonksiyonla silinir. Çünkü bunun başka yolu yoktur. Biz hangi dili, kütüphaneyi ya da ortamı (framework) 
    kullanıyor olursak olalım. Bu işi yapmak için bize sunulan fonksiyonlar eninde sonunda işletim sisteminin
    dosyayı silen sistem fonksiyonunu çağırarak bu işi yaparlar.

    POSIX standartları temelde hem kabuk komutlarını hem de C'den çağrılacak ortak fonksiyonları belirlemektedir. POSIX
    fonksiyonları UNIX türevi sistemlerdeki ortak fonksiyonlardır. POSIX fonksiyonları Linux gibi, BSD gibi, Solaris gibi hatta
    MAC OS X gibi sistemlerde aynı biçimde kullanılabilmektedir. Bazı POSIX fonksiyonları doğrudan o sistemdeki bir sistem
    fonksiyonu çağırır. Bazı POSIX fonksiyonları ise hiçbir sistem fonksiyonunu çağırmaz. Bazıları da birden fazla sistem
    fonksiyonunu çağırabilmektedir. Örneğin dosya açmak için open isimli bir POSIX fonksiyonu kullanılmaktadır. Bu
    fonksiyon Linux sistemlerinde sys_open isimli sistem fonksiyonunu çağırmaktadır.

    Standart C fonksiyonları ise tüm C derleyicilerinde bulunan fonksiyonlardır. İşletim sistemi ne olursa olsun C derleyicileri
    bu standart C fonksiyonlarını bizim için hazır durumda bulundurmaktadır. Bu üç grup fonksiyon içerisinde şüphesiz en
    geniş taşınabilirliğe sahip olan standart C fonksiyonlarıdır. Örneğin Linux sistemlerde bir standart C fonksiyonu olan 
    fopen fonksiyonunu çağırmış olalım. Bu sistemlerde fopen fonksiyonu birtakım işlemlerden sonra open POSIX fonksiyonunu 
    çağırmaktadır. open POSIX fonksiyonu da sys_open isimli sistem fonksiyonunu çağırır. Dosyanın açılması aslında sys_open 
    isimli istem fonksiyonu tarafından yapılmaktadır.

    fopen -----> sys_open

    POSIX fonksiyonları UNIX/Linux sistemlerinde standart C fonksiyonlarının bulunduğu kütüphane içerisine yerleştirilmiştir.
    Bu kütüphameye "libc" denilmektedir. Bu "libc" kütüphanesi GNU tarafından "glibc" ismiyle gerçekleştirilmiştir. Bu kütüphane
    gcc ile bağlama işlemi yapılırken otomatik biçimde bağlama sürecine katılmaktadır. Yani UNIX/Linux sistemlerinde POSIX
    fonksiyonlarını çağırmak için ek bir işlem yapmaya gerek yoktur. POSIX fonksiyonlarının prototipleri çeşitli başlık
    dosyaları içerisinde bulundurulmuştur. Pek çok POSIX fonksiyonunun prototipi <unistd.h> dosyası içerisinde bulunmaktadır. 
    Ancak bu dosyanın dışında POSIX fonksiyonlarının prototiplerini barındıran pek çok başlık dosyası da vardır.

    Pekiyi bazen işletim sisteminin sistem fonksiyonlarını doğrudan çağırmamız gerekebilir mi? Taşınabilirlik sağlamak için
    ortak özelliklere hitap etmek gerekmektedir. Yani örneğin Linux'ta olan fakat BSD'de olmayan bir özellik POSIX
    fonksiyonunun konusu olamaz. Çünkü POSIX fonksiyonları tüm UNIX türevi sistemler için düşünülmüştür. İşte biz bazen
    belirli bir sisteme özgü işlemler yapmak isteyebiliriz. Bunun için doğrudan o sistemin sistem fonksiyonlarını çağırmak
    zorunda kalabiliriz. Şimdi şöyle bir soru soralım: Linux için fopen mı, open mı, yoksa sys_open mı daha geniş olanaklara
    sahiptir? İşte Linux'un sys_open fonksiyonu Linux'a özgü yazılmıştır. open ise UNIX türevi tüm sistemleri hedef alacak
    biçimde tasarlanmıştır. Halbuki fopen fonksiyonu tüm sistemlerde olabilecek ortak özelliklere göre tanımlanmıştır.

    Windows sistemlerinde genellikle sisteme yönelik birtakım işlemler için hazır biçimde bulunan fonksiyonlar vardır. Bunlara 
    "Windows API Fonksiyonları" denilmektedir. Windows’un API fonksiyonları düzey olarak POSIX fonksiyonlarına benzetilebilir. 
    Nasıl POSIX fonksiyonları tüm UNIX türevi sistemlerdeki ortak fonksiyonları betimliyorsa Windows'un API fonksiyonları da 
    tüm Windows sistemlerinde kullanabileceğimiz ortak fonksiyonları betimlemektedir. (Bazı Windows API fonksiyonlarının belli 
    bir Windows versiyonundan sonraki versiyonlarda kullanılabildiğini de belirtelim.) Windows'un API fonksiyonlarından bazıları 
    Windows’un belli bir sistem fonksiyonunu doğrudan çağırabilmekte, bazıları birden fazla sistem fonksiyonunu çağırabilmekte, 
    bazıları ise hiçbir sistem fonksiyonunu çağırmayabilmektedir. Windows’un API fonksiyonlarının pek çoğunun prototipi 
    <Windows.h> isimli başlık dosyasındadır. Bu API fonksiyonlarının bulunduğu dinamik kütüphaneler (Kernel32.dll, User32.dll, 
    Gdi32.dll gibi) Microsoft’un derleyicileri ve bağlayıcıları tarafından doğrudan işleme sokulurlar. Dolayısıyla Windows’un 
    API fonksiyonlarını çağırmak için Microsoft derleyicilerinde <windows.h> dosyasını include etmek dışında yapılacak başka 
    bir şey yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                1. Ders 22/10/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi UNIX/Linux sistemlerinde ilk programımız olan "Hello UNIX/Linux System Programming" programını yazıp derleyelim.
    Programımız şöyle olsun:

    #include <stdio.h>

    int main(void)
    {
        printf("Hello UNIX/Linux System Programming...\n");

        return 0;
    }

    Programın "sample.c" dosyası olarak save edildiğini varsayalım. Derleme işlemi gcc derleyicisi ile şöyle yapılabilir:

    $ gcc -o sample sample.c

    Çalıştırmayı şöyle yapabilirsiniz:

    $ ./sample
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    printf("Hello UNIX/Linux System Programming...\n");

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                4. Ders 05/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında komut satırı argümanlarının oluşturulması için geniş bir kesim tarafından kullanılan geleneksel bir 
    biçim vardır. Bu biçime "GNU biçimi" de denilmektedir. Biz de kursumuzda UNIX/Linux dünyasında yazacağımız programlarda 
    bu geleneği kullanacağız. GNU stilinde komut satırı argümanları üçe ayrılmaktadır:

    1) Argümansız seçenekler
    2) Argümanlı seçenekler
    3) Seçeneksiz argümanlar

    Argümansız seçenekler "-" karakterine yapışık tek bir harften oluşmaktadır. Harflerde büyük harf - küçük harf duyarlılığı 
    (case sensitivity) dikkate alınmaktadır. Örneğin:

    $ ls -l -i /usr/include

    Burada -l ve -i argümansız seçeneklerdir. /usr/include argümanının bu seçeneklerle hiçbir ilgisi yoktur. Argümansız seçenekler 
    tek bir karakterden oluşturulduğu için birleştirilebilmektedir. Örneğin:

    $ ls -li

    Buradaki -li aslında -l -i ile tamamen aynı anlamdadır. Genel olarak GNU stilinde seçenekler arasındaki sıranın bir önemi yoktur. 
    Yani örneğin:

    $ ls -l -i

    ile

    $ ls -i -l

    arasında bir farklılık yoktur.

    Argümanlı seçeneklerde bir seçeneğin yanında o seçenekle ilişkili bir argüman da bulunur. Örneğin:

    $ gcc -o sample sample.c

    Burada -o seçeneği seçeneği tek başına kullanılmaz. Hedef dosyanın ismi seçeneğin argümanını oluşturmaktadır. O halde buradaki 
    -o seçeneği tipik olarak argümanlı seçeneğe bir örnektir. Argüman seçeneklerin birleştirilmesi tavsiye edilmez. Ancak birleştirme 
    yapılabilmektedir. Örneğin:

    $ gcc -co sample.o sample.c

    Bu yazım biçimini pek çok program kabul etse de biz tavsiye etmiyoruz. Buradaki argümanların aşağıdaki gibi belirtilmesi daha 
    uygundur:

    $ gcc -c -o sample.o sample.c

    Programlar, argümanlı seçeneklerde seçeneğin argümanı hiç boşluk karakterleriyle ayrılmasa bile bunu kabul edebilmektedir. 
    Örneğin:

    $ gcc -osample sample.c

    Burada -o argümanlı seçenek olduğu için onu başka bir seçenek izleyemeyeceğinden dolayı "sample" -o seçeneğinin argümanı olarak 
    ele alınmaktadır.

    Seçeneklerle ilgisi olmayan argümanlara "seçeneksiz argüman" denilmektedir. Örneğin:

    $ gcc -o sample sample.c

    Burada "sample.c" argümanı herhangi bir seçenekle ilgili değildir. Örneğin:

    $ cp x.txt y.txt

    Buradaki "x.txt" ve "y.txt" argümanları da seçeneklerle ilgili değildir. Seçeneksiz argümanların sonda bulunması gerekmez. 
    Örneğin:

    $ gcc sample.c -o sample
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Eskiden yalnızca tek karakterden oluşan kısa seçenekler kullanılıyordu. Ancak daha sonraları bu kısa seçeneklerin yetersiz 
    kaldığı ve okunabilirliği bozduğu gerekçesiyle uzun seçenekler de kullanılmaya başlanmıştır. POSIX standartları uzun seçenekleri 
    desteklememektedir. Ancak UNIX/Linux dünyasında yaygın biçimde kullanılmaktadır. Uzun seçenekler "--" öneki ile başlatılmaktadır. 
    Örneğin:

    prog --count -a -b --length 100

    Uzun seçenekler de argümanlı ve argümansız olabilmektedir. Yukarıdaki örnekte "--count" argümansız uzun seçenek, "-a" ve "-b" 
    argümansız seçenekler ve "--length 100" ise argümanlı uzun seçenektir.

    Uzun seçeneklerde "isteğe bağlı argüman (optional argument)" denilen özel bir argüman da kullanılmaktadır. İsmi üzerinde "isteğe 
    bağlı argüman" uzun seçeneklerin yanında verilip verilmemesi isteğe bağlı olan argümanlardır. Uzun seçeneklerin isteğe bağlı 
    argümanları "=" sentaksı ile yapışık bir biçimde belirtilmektedir. Örneğin:

    prog --size=512

    Burada --size uzun seçeneğinin argümanı isteğe bağlıdır. Yani bu uzun seçenek argümansız da aşağıdaki gibi kullanılabilirdi:

    prog --size

    Günümüzde genel olarak programlar kısa seçenekleri de uzun seçenekleri de bir arada kullanmaktadır. Programcılar bazı 
    kısa seçeneklerin alternatif uzun seçeneklerini oluşturabilmektedir. Yukarıda da belirttiğimiz gibi POSIX standartları 
    uzun seçenekleri desteklememektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında kullanılan komut satırı argümanlarını parse etmek için getopt ve getopt_long isimli iki fonksiyon 
    bulundurulmuştur. getopt fonksiyonu bir POSIX fonksiyonudur. Ancak bu fonksiyon uzun seçenekleri parse etmemektedir. 
    getopt_long ise uzun seçenekleri de parse eden getopt fonksiyonunun daha gelişmiş bir biçimidir. Ancak getopt_long bir 
    POSIX fonksiyonu değildir. Ancak libc kütüphanesinde bulunmaktadır. Bu fonksiyonlar Windows sistemlerinde hazır bir biçimde 
    herhangi bir kütüphanede bulunmamaktadır. Zaten yukarıda da belirttiğimiz gibi Windows sistemlerindeki komut satırı argüman 
    stili UNIX/Linux sistemlerindekinden farklıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    getopt fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int getopt(int argc, char * const argv[], const char *optstring);

    getopt fonksiyonunun ilk iki parametresi main fonksiyonunun argc ve argv parametreleri gibidir. Yani programcı main 
    fonksiyonunun bu parametrelerini getopt fonksiyonuna geçirir. Fonksiyonun üçüncü parametresinde kısa seçenekler belirtilmektedir. 
    Bu parametre bir yazı biçiminde girilir. Bu yazıdaki her bir karakter bir kısa seçeneği belirtir. Bir karakterin yanında ':' 
    karakteri varsa bu ':' karakterinin solundaki seçeneğin argümanlı bir seçenek olduğunu belirtmektedir. Örneğin "ab:c" burada 
    -a, -b ve -c seçenekleri belirtilmiştir. Ancak -b seçeneğinin bir argümanı da vardır.

    getopt fonksiyonu bir kez çağrılmaz. Bir döngü içerisinde çağrılmalıdır. Çünkü fonksiyon her çağrıldığında bir kısa seçeneği 
    bulmaktadır. Fonksiyon bütün kısa seçenekleri bulduktan sonra artık bulacak bir seçenek kalmadığında -1 değerine geri dönmektedir. 
    O halde fonksiyonun çağrılma kalıbı şöyle olmalıdır:

    int result;
    ...

    while ((result = getopt(argc, argv, "ab:c")) != -1) {
        ...
    }

    getopt, her kısa seçeneği bulduğunda o kısa seçeneğe ilişkin karakterle (yani o karakterin sayısal karşılığı ile) geri dönmektedir. 
    O halde bizim getopt fonksiyonunun geri dönüş değerini switch içerisinde ele almamız gerekir:

    while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                ...
                break;
            case 'b':
                ...
                break;
            case 'c':
                ...
                break;
        }
    }

    getopt fonksiyonu, olmayan (yani üçüncü parametresinde belirtilmeyen) bir kısa seçenekle karşılaştığında ya da argümanı 
    olması gerektiği halde girilmemiş bir kısa seçenekle karşılaştığında '?' özel değerine geri dönmektedir. Programcının 
    switch deyimine bu case bölümünü ekleyerek bu durumu da değerlendirmesi uygun olur. Örneğin:

    while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                ...
                break;
            case 'b':
                ...
                break;
            case 'c':
                ...
                break;
            case '?':
                ...
                break;
        }
    }

    getopt fonksiyonunun kullandığı dört global değişken vardır. Bu global değişkenler kütüphanenin içerisinde tanımlanmıştır. 
    Bunları biz extern bildirimi ile kullanabiliriz. Ancak bunların extern bildirimleri zaten <unistd.h> dosyası içerisinde 
    yapılmış durumdadır:

    extern int opterr;
    extern int optopt;
    extern int optind;
    extern char *optarg;

    Default durumda, getopt fonksiyonu geçersiz bir seçenekle (yani üçüncü parametresinde belirtilmeyen bir seçenekle) karşılaştığında 
    stderr dosyasına (ekranda çıkacaktır) kendisi hata mesajını yazdırmaktadır. Programcılar genellikle bunu istemezler. getopt 
    fonksiyonunun geçersiz seçenekler için hata mesajını yazdırması opterr değişkenine 0 değeri atanarak sağlanabilir. Yani opterr 
    değişkeni sıfır dışı bir değerdeyse (default durum) fonksiyon mesajı stderr dosyasına kendisi de yazar, sıfır değerindeyse 
    fonksiyon hata mesajını stderr dosyasına yazmaz.

    getopt fonksiyonu geçersiz bir seçenekle ya da argümanı girilmemiş argümanlı bir seçenekle karşılaştığında '?' geri dönmekle 
    birlikte aynı zamanda optopt global değişkenine geçersiz seçeneğin karakter karşılığını yerleştirmektedir. Böylece programcı 
    daha yeterli bir mesaj verebilmektedir. 
    Örneğin:

    opterr = 0;
    while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                printf("-a given...\n");
                break;
            case 'b':
                printf("-b given...\n");
                break;
            case 'c':
                printf("-c given...\n");
                break;
            case '?':
            if (optopt == 'b')
                fprintf(stderr, "-b option given without argument!...\n");
            else
                fprintf(stderr, "invalid option: -%c\n", optopt);
            break;
        }
    }

    Argümanlı bir kısa seçenek bulunduğunda getopt fonksiyonu, optarg global değişkenini o kısa seçeneğin argümanını gösterecek 
    biçimde set eder. Ancak optarg, yeni bir argümanlı kısa seçenek bulunduğunda bu kez onun argümanını gösterecek biçimde set 
    edilmektedir. Yani programcı argümanlı kısa seçeneği bulduğu anda optarg değişkenine başvurmalı gerekirse onu başka bir 
    göstericide saklamalıdır.

    Pekiyi seçeneksiz argümanları nasıl edebiliriz? Seçeneksiz argümanlar argv dizisinin herhangi bir yerine bulunuyor olabilir. 
    İşte getopt fonksiyonu her zaman seçeneksiz argümanları girildiği sırada argv dizisinin sonuna taşır ve onların başladığı 
    indeksi de optind global değişkeninin göstermesini sağlar. O halde programcı getopt ile işini bitirdikten sonra (yani while 
    döngüsünden çıktıktan sonra) optind indeksinden argc indeksine kadar ilerleyerek tüm seçeneksiz argümanları elde edebilmektedir. 
    Örneğin:

    $ ./sample -a ali -b veli selami -c

    Burada "ali" ve "selami" seçeneksiz argümanlardır. getopt bu argv dizisini şu halde getirmektedir:

    $ ./sample -a -b veli -c ali selami

    Şimdi burada optind indeksi artık "ali" argümanının başladığı indeksi belirtecektir. Onun ötesindeki tüm argümanlar seçeneksiz 
    argümanlardır. Bu argümanları while döngüsünün dışında şöyle yazdırabiliriz:

    for (int i = optind; i < argc; ++i)
        puts(argv[i]);

    Programcının girilmiş olan seçenekleri saklayıp programın ilerleyen aşamalarında bunları kullanması gerekebilmektedir. Bunun 
    için şöyle bir kalıp önerilebilir: 

    - Her seçenek için bir flag değişkeni tutulur. Bu flag değişkenlerine başlangıçta 0 atanır.
    - Her argümanlı seçenek için bir gösterici tutulur. 
    - Her seçenekle karşılaşıldığında flag değişkenine 1 atanarak o seçeneğin kullanıldığı kaydedilir. 
    - Argümanlı seçeneklerle karşılaşıldığında onların argümanları göstericilerde saklanır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    getopt fonksiyonun kullanımına ilişkin tipik bir kalıp aşağıda verilmiştir. Aşağıdaki örnekte -a, -b, -d argümansız seçenekler,
    -c ve -e ise argümanlı seçeneklerdir. Bu kalıbı kendi programlarınızda da kullanabilirsiniz. Bu örnekte ayrıştırma işleminde 
    bir hata oluştuğunda programın devam etmemesini isteriz. Ancak tüm hataların rapor edilmesi de gerekmektedir. Bunun için bir 
    flag değişkeninden faydalanılabilir. O flag değişkeni hata durumunda set edilir. Çıkışta kontrol edilip duruma göre 
    program sonlandırılır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, b_flag, c_flag, d_flag, e_flag, err_flag;
    char *c_arg, *e_arg;

    a_flag = b_flag = c_flag = d_flag = e_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt(argc, argv, "abc:de:")) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_flag = 1;
                break;
            case 'c':
                c_flag = 1;
                c_arg = optarg;
                break;
            case 'd':
                d_flag = 1;
                break;
            case 'e':
                e_flag = 1;
                e_arg = optarg;
                break;
            case '?':
                if (optopt == 'c' || optopt == 'e')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given\n");
    if (c_flag)
        printf("-c option given with argument \"%s\"\n", c_arg);
    if (d_flag)
        printf("-d option given\n");
    if (e_flag)
        printf("-e option given with argument \"%s\"\n", e_arg);

    if (optind != argc)
        printf("Arguments without option:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    getopt fonksiyonun kullanımına bir örnek. Bu örnekte disp isimli program şu komut satırı argümanlarını almaktadır:

    -x (display hex)
    -o (display octal)
    -t (display text)
    -n (number of character per line)

    Burada -x, -o ve -t seçeneklerinden yalnızca bir tanesi kullanılabilmektedir. Eğer hiçbir seçenek kullanılmazsa default 
    durum "-t" biçimindedir. -n seçeneği yalnızca hex ve octal görüntülemede kullanılabilmektedir. Bu seçenek de belirtilmezse 
    sanki "-n 16" gibi bir belirleme yapıldığı varsayılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdbool.h>
#include <unistd.h>

#define DEFAULT_LINE_CHAR        16

bool disp_text(FILE *f);
bool disp_hex(FILE *f, int n_arg);
bool disp_octal(FILE *f, int n_arg);
int check_number(const char *str);

int main(int argc, char *argv[])
{
    int result;
    int t_flag, o_flag, x_flag, n_flag, err_flag;
    int n_arg;
    FILE *f;

    t_flag = o_flag = x_flag = n_flag = err_flag = 0;
    n_arg = DEFAULT_LINE_CHAR;
    opterr = 0;

    while ((result = getopt(argc, argv, "toxn:")) != -1) {
        switch (result) {
            case 't':
                t_flag = 1;
                break;
            case 'o':
                o_flag = 1;
                break;
            case 'x':
                x_flag = 1;
                break;
            case 'n':
                n_flag = 1;
                if ((n_arg = check_number(optarg)) < 0) {
                    fprintf(stderr, "-n argument is invalid!...\n");
                    err_flag = 1;
                }
                break;
            case '?':
                if (optopt == 'n')
                    fprintf(stderr, "-%c option given without argument!...\n", optopt);
                else
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                err_flag = 1;

            break;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (t_flag + o_flag + x_flag > 1) {
        fprintf(stderr, "only one of -[tox] option may be specified!...\n");
        exit(EXIT_FAILURE);
    }

    if (t_flag + o_flag + x_flag == 0)
        t_flag = 1;

    if (t_flag && n_flag) {
        fprintf(stderr, "-n option cannot be used with -t option!...\n");
        exit(EXIT_FAILURE);
    }

    if (argc - optind == 0) {
        fprintf(stderr, "file must be specified!...\n");
        exit(EXIT_FAILURE);
    }
    if (argc - optind > 1) {
        fprintf(stderr, "too many files specified!...\n");
        exit(EXIT_FAILURE);
    }

    if ((f = fopen(argv[optind], t_flag ? "r" : "rb")) == NULL) {
        fprintf(stderr, "cannot open file: %s\n", argv[optind]);
        exit(EXIT_FAILURE);
    }
    if (t_flag)
        result = disp_text(f);
    else if (x_flag)
        result = disp_hex(f, n_arg);
    else if (o_flag)
        result = disp_octal(f, n_arg);

    if (!result) {
        fprintf(stderr, "cannot read file: %s\n", argv[optind]);
        exit(EXIT_FAILURE);
    }

    fclose(f);

    return 0;
}

bool disp_text(FILE *f)
{
    int ch;

    while ((ch = fgetc(f)) != EOF)
        putchar(ch);

    return feof(f);
}

bool disp_hex(FILE *f, int n_arg)
{
    size_t i;
    int ch;

    for (i = 0;(ch = fgetc(f)) != EOF; ++i) {
        if (i % n_arg == 0) {
            if (i != 0)
                putchar('\n');
            printf("%08zX ", i);
        }
        printf("%02X ", ch);

    }
    putchar('\n');

    return feof(f);
}

bool disp_octal(FILE *f, int n_arg)
{
    size_t i;
    int ch;

    for (i = 0;(ch = fgetc(f)) != EOF; ++i) {
        if (i % n_arg == 0)
            printf("%08zo ", i);

        printf("%03o ", ch);
        if (i % n_arg == n_arg - 1)
            putchar('\n');
    }
    putchar('\n');

    return feof(f);
}

int check_number(const char *str)
{
    const char *temp;
    int result;

    while (isspace(*str))
        ++str;

    temp = str;

    while (isdigit(*str))
        ++str;

    if (*str != '\0')
        return -1;

    result = atoi(temp);
    if (!result)
        return -1;

    return result;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mycalc isimli bir program yazılmıştır. Program iki komut satırı argümanı ile aldığı değerler üzerinde 
    dört işlem yapmaktadır. Aşağıdaki seçeneklere sahiptir:

    -a: Toplama işlemi
    -m: Çarpma işlemi
    -d: Bölme işlemi
    -s: Çıkartma işlemi
    -D msg: Çıktının başında "msg: " kısmını ekler
---------------------------------------------------------------------------------------------------------------------------*/

/* mycalc.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, m_flag, M_flag, d_flag, s_flag, err_flag;
    char *M_arg;
    double arg1, arg2, calc_result;

    a_flag = m_flag = M_flag = d_flag = s_flag = err_flag = 0;

    opterr = 0;

    while ((result = getopt(argc, argv, "amM:ds")) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'm':
                m_flag = 1;
                break;
            case 'M':
                M_flag = 1;
                M_arg = optarg;
                break;
            case 'd':
                d_flag = 1;
                break;
            case 's':
                s_flag = 1;
                break;
            case '?':
                if (optopt == 'M')
                    fprintf(stderr, "-M option must have an argument!\n");
                else
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag + m_flag + d_flag + s_flag > 1) {
        fprintf(stderr, "only one option must be specified!\n");
        exit(EXIT_FAILURE);
    }
    if (a_flag + m_flag + d_flag + s_flag == 0) {
        fprintf(stderr, "at least one of -amds options must be specified\n");
        exit(EXIT_FAILURE);
    }

    if (argc - optind != 2) {
        fprintf(stderr, "two number must be specified!\n");
        exit(EXIT_FAILURE);
    }

    arg1 = atof(argv[optind]);
    arg2 = atof(argv[optind + 1]);

    if (a_flag)
        calc_result = arg1 + arg2;
    else if (m_flag)
        calc_result = arg1 * arg2;
    else if (d_flag)
            calc_result = arg1 / arg2;
    else
        calc_result = arg1 - arg2;

    if (M_flag)
        printf("%s: %f\n", M_arg, calc_result);
    else
        printf("%f\n", calc_result);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi komut satırında uzun seçenek kullanımı POSIX standartlarında yoktur. Ancak Linux gibi 
    pek çok sistemdeki çeşitli yardımcı programlar uzun seçenekleri desteklemektedir. Programlarda bazı kısa seçeneklerin 
    eşdeğer uzun seçenekleri bulunmaktadır. Bazı uzun seçeneklerin ise kısa seçenek eşdeğeri bulunmamaktadır. Bazı kısa 
    seçeneklerin de uzun seçenek eşdeğerleri yoktur.

    Uzun seçenekleri parse etmek için getopt_long isimli fonksiyon kullanılmaktadır. Uzun seçenekler POSIX standartlarında 
    olmadığına göre getopt_long fonksiyonu da bir POSIX fonksiyonu değildir. Ancak GNU'nun glibc kütüphanesinde bir eklenti 
    biçiminde bulunmaktadır. getopt_long fonksiyonu işlevsel olarak getopt fonksiyonunu kapsamaktadır. Ancak fonksiyonun kullanımı 
    biraz daha zordur. Fonksiyonun prototipi şöyledir:

    #include <getopt.h>

    int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);

    Fonksiyonun birinci ve ikinci parametrelerine, main fonksiyonundan alınan argc ve argv parametreleri geçirilir. Fonksiyonun 
    üçüncü parametresi yine kısa seçeneklerin belirtildiği yazının adresini almaktadır. Yani fonksiyonun ilk üç parametresi 
    tamamen getopt fonksiyonu ile aynıdır. Fonksiyonun dördüncü parametresi uzun seçeneklerin belirtildiği struct option türünden 
    bir yapı dizisinin adresini almaktadır. Her uzun seçenek struct option türünden bir nesneyle ifade edilmektedir. struct option 
    yapısı şöyle bildirilmiştir:

    struct option {
        const char *name;
        int         has_arg;
        int        *flag;
        int         val;
    };

    Fonksiyon bu yapı dizisinin bittiğini nasıl anlayacaktır? İşte yapı dizisinin son elemanına ilişkin yapı nesnesinin tüm 
    elemanları 0'larla doldurulmalıdır. (0 sabitinin göstericiler söz konusu olduğunda NULL adres anlamına geldiğini de anımsayınız.)

    struct option yapısının name elemanı uzun seçeneğin ismini belirtmektedir. Yapının has_arg elemanı üç değerden birini alabilir:

    no_argument (0)
    required_argument (1)
    optional_argument (2)

    Bu eleman uzun seçeneğin argüman alıp almadığını belirtmektedir. Yapının flag ve val elemanları birbirleriyle ilişkilidir. 
    Yapının val elemanı uzun seçenek bulunduğunda bunun hangi sayısal değerle ifade edileceğini belirtir. İşte bu flag elemanına 
    int bir nesnenin adresi geçilirse bu durumda uzun seçenek bulunduğunda bu val değeri bu int nesneye yerleştirilir. getopt_long 
    ise bu durumda 0 değeri ile geri döner. Ancak bu flag göstericisine NULL adres de geçilebilir. Bu durumda getopt_long uzun seçenek 
    bulunduğunda val elemanındaki değeri geri dönüş değeri olarak verir. Örneğin:

    struct option options[] = {
        {"count", required_argument, NULL, 'c'},
        {0, 0, 0, 0}
    };

    Burada uzun seçenek "--count" biçimindedir. Bir argümanla kullanılmak zorundadır. Bu uzun seçenek bulunduğunda flag parametresi 
    NULL adres geçildiği için getopt_long fonksiyonu 'c' değeri ile geri dönecektir. Örneğin:

    int count_flag;
    ...

    struct option options[] = {
        {"count", required_argument, &count_flag, 1},
        {0, 0, 0, 0}
    };

    Burada artık uzun seçenek bulunduğunda getopt_long fonksiyonu 0 ile geri dönecek ancak 1 değeri count_flag nesnesine 
    yerleştirilecektir.

    getopt_long fonksiyonunun son parametresi uzun seçenek bulunduğunda o uzun seçeneğin option dizisindeki kaçıncı indeksli 
    uzun seçenek olduğunu anlamak için kullanılmaktadır. Burada belirtilen adresteki nesneye uzun seçeneğin option dizisi
    içerisindeki indeks numarası yerleştirilmektedir. Ancak bu bilgiye genellikle gereksinim duyulmamaktadır. Bu parametre 
    NULL geçilebilir. Bu durumda böyle bir yerleştirme yapılmaz.

    Bu durumda getopt_long fonksiyonunun geri dönüş değeri beş biçimden biri olabilir:

    1) Fonksiyon bir kısa seçenek bulmuştur. Kısa seçeneğin karakter koduyla geri döner. 
    2) Fonksiyon bir uzun seçenek bulmuştur ve option yapısının flag elemanında NULL adres vardır. Bu durumda fonksiyon option 
    yapısının val elemanındaki değerle geri döner. 
    3) Fonksiyon bir uzun seçenek bulmuştur ve option yapısının flag elemanında NULL adres yoktur. Bu durumda fonksiyon val 
    değerini bu adrese yerleştirir ve 0 değeri ile geri döner. 
    4) Fonksiyon geçersiz (yani olmayan) bir kısa ya da uzun seçenekle karşılaşmıştır ya da argümanlı bir kısa seçenek ya da 
    uzun seçeneğin argümanı girilmemiştir. Bu durumda fonksiyon '?' karakterinin değeriyle geri döner. 
    5) Parse edecek argüman kalmamıştır fonksiyon -1 ile geri döner.

    getopt fonksiyonundaki yardımcı global değişkenlerin aynısı burada da kullanılmaktadır:

    opterr: Hata mesajının fonksiyon tarafından stderr dosyasına basılıp basılmayacağını belirtir. 
    optarg: Argümanlı bir kısa ya da uzun seçenekte argümanı belirtmektedir. Eğer "isteğe bağlı argümanlı" bir uzun seçenek 
    bulunmuşsa ve bu uzun seçenek için argüman girilmemişse optarg nesnesine NULL adres yerleştirilmektedir. 
    optind: Bu değişken yine seçeneksiz argümanların başladığı indeksi belirtmektedir. 
    optopt: Bu değişken geçersiz bir uzun ya da kısa seçenek girildiğinde hatanın nedenini belirtmektedir.

    getopt_long geçersiz bir seçenekle karşılaştığında '?' geri dönmekle birlikte optopt değişkenini şu biçimlerde set etmektedir:

    1) Eğer fonksiyon argümanlı bir kısa seçenek bulduğu halde argüman girilmemişse o argümanlı kısa seçeneğin karakter karşılığını 
    optopt değişkenine yerleştirir. 
    2) Eğer fonksiyon argümanlı bir uzun seçenek bulduğu halde argüman girilmemişse o argümanlı uzun seçeneğin option yapısındaki 
    val değerini optopt değişkenine yerleştirmektedir. 
    3) Eğer fonksiyon geçersiz bir kısa seçenekle karşılaşmışsa bu durumda optopt geçersiz kısa seçeneğin karakter karşılığına 
    geri döner. 
    4) Eğer fonksiyon geçersiz bir uzun seçenekle karşılaşmışsa bu durumda optopt değişkenine 0 değeri yerleştirilmektedir.

    Maalesef getopt_long olmayan bir uzun seçenek girildiğinde bunu bize vermemektedir. Ancak GNU'nun getopt_long gerçekleştirimine 
    bakıldığında bu geçersiz uzun seçeneğin argv dizisinin "optind - 1" indeksinde olduğu görülmektedir. Yani bu geçersiz uzun 
    seçeneğe argv[optind - 1] ifadesi ile erişilebilmektedir. Ancak bu durum glibc dokümanlarında belirtilmemiştir. Bu nedenle 
    bu özelliğin kullanılması uygun değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                5. Ders 06/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekteki komut satırı argümanları şunlardır:

    -a
    -b
    -c <arg> ya da --count <arg>
    --verbose
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int a_flag, b_flag, c_flag, verbose_flag;
    int err_flag;
    char *c_arg;
    int result;

    struct option options[] = {
        {"count", required_argument, NULL, 'c'},
        {"verbose", no_argument, &verbose_flag, 1},
        {0, 0, 0, 0}
    };

    a_flag = b_flag = c_flag = verbose_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt_long(argc, argv, "abc:", options, NULL)) != -1) {
        switch (result) {
        case 'a':
            a_flag = 1;
            break;
        case 'b':
            b_flag = 1;
            break;
        case 'c':
            c_flag = 1;
            c_arg = optarg;
            break;
        case '?':
            if (optopt == 'c')
                fprintf(stderr, "option -c or --count without argument!...\n");
            else if (optopt != 0)
                fprintf(stderr, "invalid option: -%c\n", optopt);
            else
                fprintf(stderr, "invalid long option!...\n");
            /* fprintf(stderr, "invalid long option: %s\n", argv[optind - 1]); */
            err_flag = 1;
            break;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given\n");
    if (c_flag)
        printf("-c or --count option given with argument \"%s\"\n", c_arg);
    if (verbose_flag)
        printf("--verbose given\n");

    if (optind != argc) {
        printf("Arguments without options");
        for (int i = optind; i < argc; ++i)
            printf("%s\n", argv[i]);
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    getopt_long fonksiyonun kullanımına diğer bir örnekte aşağıda verilmiştir. Aşağıda programın komut satırı argümanları 
    şunlardır:

    -a
    -b <arg>
    -c
    -h ya da --help
    --count <arg>
    --line[=<arg>]
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, b_flag, c_flag, h_flag, count_flag, line_flag;
    char *b_arg, *count_arg, *line_arg;
    int err_flag;
    int i;

    struct option options[] = {
        {"help", no_argument, &h_flag, 1},
        {"count", required_argument, NULL, 2},
        {"line", optional_argument, NULL, 3},
        {0, 0, 0, 0 },
    };

    a_flag = b_flag = c_flag = h_flag = count_flag = line_flag = 0;
    err_flag = 0;

    opterr = 0;
    while ((result = getopt_long(argc, argv, "ab:ch", options, NULL)) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_flag = 1;
                b_arg = optarg;
                break;
            case 'c':
                c_flag = 1;
                break;
            case 'h':
                h_flag = 1;
                break;
            case 2:            /* --count */
                count_flag = 1;
                count_arg = optarg;
                break;
            case 3:            /* --line */
                line_flag = 1;
                line_arg = optarg;
                break;
            case '?':
                if (optopt == 'b')
                    fprintf(stderr, "-b option must have an argument!...\n");
                else if (optopt == 2)
                    fprintf(stderr, "argument must be specified with --count option\n");
                else if (optopt != 0)
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                else
                    fprintf(stderr, "invalid long option!...\n");

                err_flag = 1;

                break;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given...\n");

    if (b_flag)
        printf("-b option given with argument \"%s\"...\n", b_arg);

    if (c_flag)
        printf("-c option given...\n");

    if (h_flag)
        printf("-h or --help option given...\n");

    if (count_flag)
        printf("--count option specified with \"%s\"...\n", count_arg);

    if (line_flag) {
        if (line_arg != NULL)
            printf("--line option given with optional argument \"%s\"\n", line_arg);
        else
            printf("--line option given without optional argument...\n");
    }

    if (optind != argc) {
        printf("Arguments without options:\n");
        for (i = optind; i < argc; ++i)
            printf("%s\n", argv[i]);
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    getopt_long fonksiyonun kullanılmasına başka bir örnek. Bu örnekteki seçenekler şöyledir:

    -a: argümansız kısa seçenek
    -b: argümanlı kısa seçenek
    --all: argümansız uzun seçenek
    --length: argümanlı uzun seçenek
    --number: isteğe bağlı argümanlı uzun seçenek
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int result;
    struct option options[] = {
        {"all", no_argument, NULL, 1},
        {"length", required_argument, NULL, 2},
        {"number", optional_argument, NULL, 3},
        {0, 0, 0, 0},
    };
    int a_flag, b_flag, all_flag, length_flag, number_flag, err_flag;
    char *b_arg, *length_arg, *number_arg;

    a_flag = b_flag = all_flag = length_flag = number_flag = err_flag = 0;
    opterr = 0;
    while ((result = getopt_long(argc, argv, "ab:", options, NULL)) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_flag = 1;
                b_arg = optarg;
                break;
            case 1:
                all_flag = 1;
                break;
            case 2:
                length_flag = 1;
                length_arg = optarg;
                break;
            case 3:
                number_flag = 1;
                number_arg = optarg;
                break;
            case '?':
                if (optopt == 'b')
                    fprintf(stderr, "-b option without argument!\n");
                else if (optopt == 2)
                    fprintf(stderr, "--length option without argument!\n");
                else if (optopt != 0)
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                else
                    fprintf(stderr, "invalid long option!\n");
                err_flag = 1;
        }
    }
    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given with argument \"%s\"\n", b_arg);
    if (all_flag)
        printf("--all option given\n");
    if (length_flag)
        printf("--length option given with argument \"%s\"\n", length_arg);
    if (number_flag)
        if (number_arg != NULL)
            printf("--number option given with argument \"%s\"\n", number_arg);
        else
            printf("--number option given without argument\n");

    if (optind != argc)
        printf("Arguments without options:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*

test girişi: ./sample --all --length 100 --number=300 -a ali veli selami
Çıktısı şöyledir:

-a option given
--all option given
--length option given with argument "100"
--number option given with argument "300"
Arguments without options:
ali
veli
selami

*/

/*---------------------------------------------------------------------------------------------------------------------------
    getopt_long fonksiyonunda struct option yapısındaki flag elemanına NULL adres yerine int bir nesnenin adresi geçirilirse
    bu durumda getopt_long bu uzun seçenek girildiğinde doğrudan yapının val elemanındaki değeri bu nesneye yerleştirir ve 0 
    ile geri döner. Böylece programcı isterse argümansız uzun seçenekleri switch içerisinde işlemeden doğrudan onun bayrağına
    set işlemi yapabilir. Ayrıca programlarda kısa seçeneklerin uzun seçenek eşdeğerleri de bulunabilmektedir. Bunu sağlamanın 
    en kolay yolu uzun seçeneğe ilişkin struct option yapısındaki val elemanına kısa seçeneğe ilişkin karakter kodunu girmektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, b_flag, all_flag, length_flag, number_flag, err_flag;
    char *b_arg, *length_arg, *number_arg;
    struct option options[] = {
        {"all", no_argument, &all_flag, 1},
        {"length", required_argument, NULL, 'l'},
        {"number", optional_argument, NULL, 3},
        {0, 0, 0, 0},
    };

    a_flag = b_flag = all_flag = length_flag = number_flag = err_flag = 0;
    opterr = 0;
    while ((result = getopt_long(argc, argv, "ab:l:", options, NULL)) != -1) {
        switch (result) {
            case 'b':
                b_flag = 1;
                b_arg = optarg;
                break;
            case 1:
                all_flag = 1;
                break;
            case 'l':
                length_flag = 1;
                length_arg = optarg;
                break;
            case 3:
                number_flag = 1;
                number_arg = optarg;
                break;
            case '?':
                if (optopt == 'b')
                    fprintf(stderr, "-b option without argument!\n");
                else if (optopt == 2)
                    fprintf(stderr, "--length option without argument!\n");
                else if (optopt != 0)
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                else
                    fprintf(stderr, "invalid long option!\n");
                err_flag = 1;
        }
    }
    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given with argument \"%s\"\n", b_arg);
    if (all_flag)
        printf("--all option given\n");
    if (length_flag)
        printf("--length option given with argument \"%s\"\n", length_arg);
    if (number_flag)
        if (number_arg != NULL)
            printf("--number option given with argument \"%s\"\n", number_arg);
        else
            printf("--number option given without argument\n");

    if (optind != argc)
        printf("Arguments without options:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                6. Ders 12/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir kullanıcı ile login olunduğunda login programı /etc/passwd dosyasında belirtilen programı çalıştırır. 
    Biz istersek bu programı değiştirip kendi istediğimiz bir programın çalıştırılmasını sağlayabiliriz. Kendi programımız 
    myshell isimli program olsun ve onu /bin dizinine kopyalamış olalım. /etc/passwd dosyasının içeriğini şöyle değiştirebiliriz:

    ali:x:1002:1001::/home/ali:/bin/myshell
---------------------------------------------------------------------------------------------------------------------------*/

/* myshell.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS        128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    for (;;) {
        printf("CSD>");
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing...\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    char cwd[4096];

    if (g_nparams > 1) {
        printf("pwd command must be used withoud argument!...\n");
        return;
    }

    getcwd(cwd, 4096);

    printf("%s\n", cwd);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                7. Ders 13/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir hata değerinin yazısını elde etmek için strerror fonksiyonu kullanılabilir. Fonksiyon bizden EXXX biçimindeki hata 
    kodunu parametre olarak alır, bize statik düzeyde tahsis edilmiş hata yazısının adresini verir. Biz de POSIX fonksiyonu 
    başarısız olduğunda errno değerini bu biçimde yazıya dönüştürüp rapor edebiliriz.

    Aşağıda buna bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1) {
        fprintf(stderr, "open failed: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }
    printf("success\n");

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    strerror fonksiyonu ile alınan error yazısı default durumda İngilizce'dir. POSIX standartlarına göre bu yazının içeriği locale'in
    LC_MESSAGES kategorisine göre ayarlanmaktadır. Dolayısıyla eğer mesajları Türkçe bastırmak istiyorsanız LC_MESSAGES kategorisine ilişkin 
    locale'i setlocale fonksiyonu ile değiştirmelisiniz. Tabii genel olarak tüm kategorilerin değiştirilmesi yoluna gidilmektedir. 
    Türkçe UNICODE UTF-8 locale'i "tr_TR.UTF-8" ile temsil edilmektedir. Dolayısıyla bu işlemi şöyle yapabilirsiniz:

    if (setlocale(LC_ALL, "tr_TR.UTF-8") == NULL) {
        fprintf(stderr, "cannot set locale!...\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <locale.h>

int main(void)
{
    if (setlocale(LC_ALL, "tr_TR.UTF-8") == NULL) {
        fprintf(stderr, "cannot set locale!...\n");
        exit(EXIT_FAILURE);
    }

    puts(strerror(EPERM));

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX fonksiyonlarında oluşan hatayı rapor etmek için perror isimli daha pratik kullanımı olan bir POSIX fonksiyonu (aynı zamanda 
    standart C fonksiyonudur) bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <stdio.h>

    void perror(const char *str);

    Fonksiyon argüman olarak girilen yazıyı stderr dosyasına yazdırır. Sonra hemen yanına ':' karakterini ve bir SPACE karakterini basar ve sonra da o andaki 
    errno değerinin yazısını yazdırır. İmleci aşağı satırın başına geçirir. Fonksiyon aşağıdaki gibi yazılabilir:

    void perror(const char *str)
    {
        fprintf(stderr, "%s: %s\n", str, strerror(errno));
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    printf("success\n");

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda, bir POSIX fonksiyonu başarısız olduğunda genellikle (ancak her zaman değil) programımızı sonlandıracağız. 
    Bu durumda daha az tuşa basmak için bir exit_sys isimli "sarma (wrapper)" fonksiyondan faydalanacağız. Bu fonksiyon önce perror
    fonksiyonu ile hatayı stderr dosyasına yazdıracak sonra da exit fonksiyonu ile program sonlandıracaktır:

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1)
        exit_sys("open");

    printf("success\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bazı programcılar yukarıdaki exit_sys fonksiyonunu printf fonksiyonuna benzetmektedir. (Örneğin Stevens "Advanced Programming in the
    UNIX Environment)" kitabında böyle bir sarma fonksiyon kullanmıştır. Böyle bir sarma fonksiyona örnek şu olabilir:

    void exit_sys(const char *format, ...)
    {
        va_list ap;

        va_start(ap, format);
        vfprintf(stderr, format, ap);
        fprintf(stderr, ": %s\n", strerror(errno));

        va_end(ap);

        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <errno.h>
#include <fcntl.h>

void exit_sys(const char *format, ...);

int main(void)
{
    int fd;
    char path[] = "xxx.txt";

    if ((fd = open(path, O_RDONLY)) == -1)
        exit_sys("open (%s)", path);

    printf("success\n");

    return 0;
}

void exit_sys(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vfprintf(stderr, format, ap);
    fprintf(stderr, ": %s\n", strerror(errno));
    va_end(ap);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    C standartlarında errno değeri çok kısıtlı bir biçimde kullanılmıştır. Yani C standartlarında pek az fonksiyon errno değişkenini 
    set etmektedir. Ancak standartlar çeşitli standart C fonksiyonlarının errno değişkenini derleyiciye bağlı olarak set edebileceğini 
    belirtmektedir. POSIX standartlarına göre her standart C fonksiyonu aynı zamanda bir POSIX fonksiyonu olarak ele alınmaktadır. 
    Standart C fonksiyonları aynı zamanda errno değişkenini de set etmektedir. Örneğin biz fopen fonksiyonu ile bir dosyayı açmak 
    istesek fopen başarısız olduğunda UNIX/Linux sistemleri errno değerini uygun biçimde set edebilmektedir. Böylece biz standart 
    C fonksiyonlarındaki hata mesajlarını da aşağıdaki gibi yazdırabilmekteyiz:

    if ((f = fopen("test.dat", "r")) == NULL)
        exit_sys("fopen");

    Ya da örneğin:

    if ((p = malloc(SIZE)) == NULL)
        exit_sys("malloc");

    Her ne kadar standart C fonksiyonları UNIX/Linux sistemlerinde errno değişkenini set ediyorsa da biz standart C uyumunu 
    korumak için kursumuzda standart C fonksiyonlarında set edilen errno değişkenini kullanmayacağız. Örneğin:

    if ((f = fopen("test.dat", "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında errno değişkeni Linux'ta çekirdek tarafından set edilen bir değişken değildir. errno değişkeni tamamen user mode'daki 
    POSIX kütüphanesi tarafından set edilmektedir. Tipik olarak Linux çekirdeğinde bir sistem fonksiyonu başarısız olduğunda 
    negatif errno değerine geri dönmektedir. Sistem fonksiyonunu çağıran POSIX fonksiyonu bu negatif errno değerini pozitife 
    dönüştürerek errno değişkenini set etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her dosyanın bir kullanıcı id'si (user id) ve grup id'si (group id) bulunmaktadır. Bu sistemlerde 
    tüm dosyalar "open" isimli bir POSIX fonksiyonu tarafından yaratılmaktadır. Bir dosyanın kullanıcı id'si onu yaratan 
    prosesin etkin kullanıcı id'si olarak set edilmektedir. Dosyanın grup id'si ise iki seçenekten biri olarak set edilebilmektedir. 
    Bazı sistemler dosyanın grup id'sini onu yaratan prosesin etkin grup id'si olarak set etmektedir. Bu biçim klasik AT&T 
    UNIX sistemlerinin uyguladığı biçimdir. Linux böyle davranmaktadır. İkinci seçenek BSD sistemlerinde olduğu gibi dosyanın 
    grup id'sinin onun içinde bulunduğu dizinin grup id'si olarak set edilmesidir. POSIX standartları her iki durumu da geçerli 
    kabul etmektedir. Linux sistemlerinde "mount parametreleriyle" BSD tarzı davranış istenirse oluşturulabilmektedir. Aynı 
    zamanda Linux sistemlerinde "dosyanın içinde bulunduğu dizinde set group id" bayrağı set edilerek de aynı etki oluşturulabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                8. Ders 20/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosya üzerinde işlem yapmak isteyen proses erişme biçimini de (okumak için mi, yazmak için mi, hem okuyup hem yazmak 
    için mi, yoksa dosyadaki kodu çalıştırmak için mi) belirtmektedir. Bu durumda işletim sistemi sırasıyla şu kontrolleri 
    yapmaktadır (bu işlemler else-if biçiminde sıralanmıştır):

    1) Eğer işlem yapmak isteyen prosesin etkin kullanıcı id'si (etkin grup id'sinin burada önemi yoktur) 0 ise işlem yapmak 
    isteyen proses yetkili kullanıcının bir prosesidir. Bu tür proseslere "root prosesler" ya da "super user prosesler" ya da 
    "öncelikli (privileged) prosesler" denilmektedir. Bu durumda işletim sistemi yapılmak istenen işlem ne olursa olsun bu 
    işleme onay verir.

    2) Eğer işlem yapmak isteyen prosesin etkin kullanıcı id'si (effective user id) dosyanın kullanıcı id'si ile aynıysa bu 
    durumda "dosyanın sahibinin dosya üzerinde işlem yaptığı gibi mantıksal bir çıkarım" yapılmaktadır. Yapılmak istenen işlem 
    ile dosyanın sahiplik (owner) erişim bilgileri karşılaştırılır. Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay 
    verilir. Değilse işlem başarısızlıkla sonuçlanır.

    3) Eğer işlem yapmak isteyen prosesin etkin grup id'si (effective group id) ya da "ek grup (supplementary groups)" id'lerinden 
    biri dosyanın grup id'si ile aynıysa bu durumda "dosya ile aynı grupta bulunan bir kullanıcının dosya üzerinde işlem yaptığı 
    gibi mantıksal bir çıkarım" yapılmaktadır. Yapılmak istenen işlem ile dosyanın grupluk (group) erişim bilgileri karşılaştırılır.
     Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay verilir. Değilse işlem başarısızlıkla sonuçlanır.

    4) İşlem yapmak isteyen proses herhangi bir proses ise bu durumda yapılmak istenen işlem ile dosyanın "diğer (other)" 
    erişim bilgileri karşılaştırılır. Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay verilir. Değilse işlem başarısızlıkla 
    sonuçlanır.

    Örneğin aşağıdaki gibi bir dosya söz konusu olsun:

    -rw-r--r-- 1 kaan study    20 Kas 13 13:54 test.txt

    Dosyaya erişim yapmak isteyen proses, "okuma ve yazma amaçlı" erişim yapmak istesin. Eğer prosesin etkin kullanıcı id'si 0 
    ise bu işlem onaylanacaktır. Eğer prosesin etkin kullanıcı id'si "kaan" ise bu işlem yine onaylanacaktır. Ancak prosesin etkin 
    grup id'si ya da ek grup id'lerinden biri study ise işlem onaylanmayacaktır. Çünkü erişim hakları gruptaki üyelere yalnızca 
    okuma izni vermektedir. Benzer biçimde prosesin etkin kullanıcı id'si ya da etkin grup id'si (ve ek grup id'leri) burada 
    belirtilenlerin dışında ise yine prosese bu işlem için onay verilmeyecektir.

    Yukarıdaki maddeler else-if biçiminde düşünülmelidir. Örneğin dosya aşağıdaki gibi olsun:

    -r--rw-r-- 1 kaan study    20 Kas 13 13:54 test.txt

    Burada dosyanın sahibi (yani etkin kullanıcı id'si dosyanın kullanıcı id'si ile aynı olan proses) dosya üzerinde yazma 
    yapamayacaktır. Ancak aynı grupta olan prosesler bunu yapabilecektir. Tabii bu biçimdeki erişim hakları mantıksal olarak tuhaf 
    ve anlamsızdır. Yani dosyanın sahibine verilmeyen bir hakkın gruba ya da diğerlerine verilmesi normal bir durum değildir.

    Çalıştırılabilir bir dosya 'x' hakkı ile temsil edilmiştir. Bu durumda biz bir program dosyasının başkaları tarafından 
    çalıştırılması engelleyebiliriz. Örneğin:

    -rwxr--r-- 1 kaan study 16816 Kas 13 13:49 sample

    Burada dosyanın sahibi (ve tabii root kullanıcısı) bu dosyayı çalıştırabilir. Ancak diğer kullanıcılar bu dosyayı çalıştıramazlar. 
    Örneğin:

    -rw-r--r-- 1 kaan study 16816 Kas 13 13:49 sample

    Burada artık root kullanıcısı da dosyayı çalıştıramaz. root kullanıcısının dosyayı çalıştırabilmesi için sahiplik, grupluk 
    ya da diğer erişim bilgilerinin en az birinde 'x' hakkının belirtilmiş olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında erişim mekanizması üzerinde açıklamalar yapılırken "root önceliği" ya da "prosesin etkin kullanıcı 
    id'sinin 0 olması" gibi bir anlatım uygulanmamıştır. Onun yerine POSIX standartlarında "appropriate privileges" terimi 
    kullanılmıştır. Çünkü bir POSIX sistemi "ya hep ya hiç" biçiminde tasarlanmak zorunda değildir. Gerçekten de örneğin Linux 
    sistemlerinde "capability" denilen bir özellik bulunmaktadır. Bu "capability" sayesinde bir prosesin etkin kullanıcı id'si 
    0 olmamasına karşın o proses belirlenen bazı şeyleri yapabilir duruma getirilebilmektedir. İşte POSIX standartlarındaki 
    "appropriate privileges" terimi bunu anlatmaktadır. Yani buradaki "appropriate privileges" terimi "prosesin etkin kullanıcı 
    id'si 0 ya da 0 olmasa da prosesin bu işlemi yapabilme yeteneğinin" olduğunu belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin çalışma dizini getcwd isimli POSIX fonksiyonuyla elde edilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    char *getcwd(char *buf, size_t size);

    Fonksiyonun birinci parametresi yol ifadesinin yerleştirileceği dizinin adresini, ikinci parametresi ise bu dizinin null 
    karakter dahil olmak üzere uzunluğunu almaktadır. Fonksiyon başarı durumunda birinci parametresiyle belirtilen adresin 
    aynısına, başarısızlık durumunda NULL adrese geri dönmektedir. Fonksiyonun ikinci parametresinde belirtilen uzunluk eğer 
    yol ifadesini ve null karakteri içerecek büyüklükte değilse fonksiyon başarısız olmaktadır.

    UNIX/Linux sistemlerinde bir yol ifadesinin maksimum karakter sayısı (null karakter dahil olmak üzere) <limits.h> içerisindeki 
    PATH_MAX sembolik sabitiyle belirtilmiştir. Ancak bu konuda bazı ayrıntılar vardır. Bazı sistemlerde bu PATH_MAX sembolik 
    sabiti tanımlı değildir. Dolayısıyla bazı sistemlerde maksimum yol ifadesi uzunluğu pathconf denilen özel bir fonksiyon 
    ile elde edilebilmektedir. Linux sistemlerinde <limits.h> dosyası içerisinde PATH_MAX 4096 olarak define edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    char buf[PATH_MAX];

    if (getcwd(buf, PATH_MAX) == NULL)
        exit_sys("getcwd");

    puts(buf);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin çalışma dizinini chdir isimli POSIX fonksiyonuyla değiştirebiliriz. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int chdir(const char *path);

    Fonksiyon yeni çalışma dizinin yol ifadesini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    char buf[PATH_MAX];

    if (getcwd(buf, PATH_MAX) == NULL)
        exit_sys("getcwd");

    puts(buf);

    if (chdir("/usr/bin") == -1)
        exit_sys("chdir");

    if (getcwd(buf, PATH_MAX) == NULL)
        exit_sys("getcwd");

    puts(buf);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önce yazmış olduğumuz kabuk programına cd komutunu aşağıdaki gibi ekleyebiliriz. Bu örnekteki getenv fonksiyonunu 
    henüz görmedik.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS        128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);
void cd_proc(void);

void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {"cd", cd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing...\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    printf("%s\n", g_cwd);
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                9. Ders 20/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dizinler de işletim sistemi tarafından birer dosyaymış gibi ele alınmaktadır. Gerçekten de dizinleri sanki "içerisinde 
    dosya bilgilerini tutan dosyalar" gibi düşünebiliriz. Dolayısıyla UNIX/Linux sistemlerinde bir dosyayı silmek için, 
    bir dosya yaratmak için, bir dosyanın ismini değiştirmek için prosesin o dizine "w" hakkının olması gerekir. Yukarıda 
    belirttiğimiz üç işlem de aslında dizine yazma yapma anlamına gelmektedir. Yani bizim bir dosyayı silebilmek için dosyaya 
    "w" hakkına sahip olmamız gerekmez, dosyanın içinde bulunduğu dizine "w" hakkına sahip olmamız gerekir. Bir dizin için 
    "r" hakkı demek o dizinin içeriğinin okunabilmesi hakkı demektir. Yani bizim bir dizinin içeriğini elde edebilmemiz 
    (ya da ls gibi bir komutla görüntüleyebilmemiz) için o dizine "r" hakkına sahip olmamız gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dizinlerde "x" hakları farklı bir anlama gelmektedir. İşletim sistemi, bir yol ifadesi verildiğinde yol ifadesinde hedeflenen 
    dizin girişi için bilgileri elde etmek isteyecektir. Örneğin:

    "/home/kaan/Study/C/sample.c" 

    Burada hedeflenen dosya "sample.c" dosyasıdır. Ancak işletim sistemi bu dosyanın yerini bulabilmek için yol ifadesindeki 
    bileşenlerin üzerinden geçer. Bu işleme "pathname resolution" denilmektedir. İşte "pathname resolution" işleminde dizin 
    geçişleriyle hedefe ulaşılabilmesi için prosesin yol ifadesine ilişkin dizin bileşenlerinin "x" hakkına sahip olması gerekir. 
    Yani dizinlerdeki "x" hakkı "içinden geçilebilirlik" gibi bir anlama gelmektedir. Biz bir dizinimizdeki "x" hakkını kaldırırsak, 
    işletim sistemi "pathname resolution" işleminde başarısız olur. Dolayısıyla "pathname resolution" işleminin başarılı olabilmesi 
    için yol ifadesindeki dizin bileşenlerinin hepsine (son bileşen de dahil olmak üzere) prosesin "x" hakkına sahip olması gerekir. 
    Yukarıdaki örnekte "pathname resolution işleminin" bitirilebilmesi için prosesin "home" dizini "kaan" dizini "Study" dizini ve 
    "C" dizini için "x" hakkına sahip olması gerekir. "x" hakkı bir dizin ağacında bir noktaya duvar örmek için kullanılabilmektedir. 
    mkdir gibi kabuk komutları dizin yaratırken zaten "x" hakkını default durumda vermektedir. Proses id'si 0 olan "root prosesler" 
    her zaman pathname resolution sırasında dizinler içerisinden geçebilirler. "x" hakkı göreli yol ifadelerinde de aynı biçimde
    uygulanmaktadır. Örneğin biz kendi dizinimizde bulunan "test.txt" dosyasını open ile "test.txt" yol ifadesini vererek açmak 
    isteyelim. Eğer içinde bulunduğumuz dizine "x" hakkına sahip değilsek yine "pathname resolution" işlemi başarısız olacaktır.
    Başka bir deyişle "test.txt" yol ifadesi sanki "./test.txt" gibi ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir işletim sisteminin dosyalarla uğraşan kısmına "dosya sistemi (file system)" denilmektedir. Dosya sisteminin iki yönü 
    vardır: Disk ve Bellek. İşletim sistemi dosya organizasyonu için diskte belli bir biçim kullanmaktadır. Ancak bir dosya 
    açıldığında işletim sistemi çekirdek alanı içerisinde bazı veri yapıları oluşturur bu da dosya sisteminin bellek tarafı 
    ile ilgilidir.

    Pek çok POSIX uyumlu işletim sistemi dosya işlemleri için 5 sistem bulundurmaktadır:

    - Dosya açmak için gereken sistem fonksiyonu (Linux'ta sys_open)
    - Dosya kapatmak için gereken sistem fonksiyonu (Linux'ta sys_close)
    - Dosyadan okuma yapmak için gereken sistem fonksiyonu (Linux'ta sys_read)
    - Dosyaya yazma yapmak için gereken sistem fonksiyonu (Linux'ta sys_write)
    - Dosya göstericisini konumlandırmak için gereken sistem fonksiyonu (Linux'ta sys_lseek)

    Bu 5 sistem fonksiyonunu çağıran 5 POSIX fonksiyonu bulunmaktadır: open, close, read, write ve lseek

    Biz bir UNIX/Linux sisteminde hangi düzeyde çalışıyor olursak olalım eninde sonunda dosya işlemleri bu 5 POSIX fonksiyonu 
    ile yapılmaktadır. Programlama dili ne olursa olsun durum böyledir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosya açıldığında işletim sistemi açılacak dosyanın bilgilerini pathname resolution işlemi sonucunda diskte bulur. 
    Dosyanın bilgilerini kernel alanı içerisinde bir alana çeker. Bu alana "dosya nesnesi (file object)" denilmektedir. Buradaki 
    "nesne (object)" terimi tahsis edilmiş yapı alanları için kullanılmaktadır. Dosya nesnesi Linux'un kaynak kodlarında "struct 
    file" ile temsil edilmiştir. İşletim sistemi, bir proses bir dosyayı açtığında açılan dosyayı o proses ile ilişkilendirir. 
    Yani dosya nesnelerine proses kontrol blokları yoluyla erişilmektedir. Güncel Linux çekirdeklerinde bu durum biraz karmaşıktır:

    task_struct (files) ---> files_struct (fdt) ---> fdtable (fd) ---> file * türünden bir dizi ---> file

    Linux'ta proses kontrol bloktan dosya nesnesine erişim birkaç yapıdan geçilerek yapılmaktadır. Ancak biz bu durumu 
    şöyle basitleştirerek ifade edebiliriz: "proses kontrol blokta bir eleman bir diziyi göstermektedir. Bu diziye "dosya betimleyici 
    tablosu (file descriptor table)" denilmektedir. Dosya betimleyici tablosunun her elemanı bir dosya nesnesini göstermektedir. 
    Yani biz yukarıdaki yapıyı aşağıdaki gibi sadeleştirerek kavramsallaştırıyoruz:

    proses kontrol block ---> betimleyici tablosu --> dosya nesneleri 

    Dosya betimleyici tablosu (file descriptor table) açık dosyalara ilişkin dosya nesnelerinin adreslerini tutan bir gösterici 
    dizisidir. Dosya betimleyici tablosuna proses kontrol bloktan hareketle erişilmektedir. Her prosesin ayrı bir dosya 
    betimleyici tablosu vardır. İşletim sistemi her açılan dosya için bir dosya nesnesi tahsis etmektedir. Aynı dosya ikinci 
    kez açıldığında o dosya için yine yeni bir dosya nesnesi oluşturulur. Dosya göstericisinin konumu da dosya nesnesinin 
    içerisinde saklanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dosyayı açmak için open isimli POSIX fonksiyonu kullanılmaktadır. (Örneğin fopen standart C fonksiyonu 
    da UNIX/Linux sistemlerinde aslında open fonksiyonunu çağırmaktadır.) Fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int open(const char *path, int flags, ...);

    open fonksiyonu isteğe bağlı (optional) olarak bir üçüncü argüman alabilmektedir. Eğer fonksiyon 3 argümanla çağrılacaksa 
    üçüncü argüman mode_t türünden olmalıdır. Her ne kadar prototipteki "..." "istenildiği kadar argüman girilebilir" anlamına 
    geliyorsa da open ya iki argümanla ya da üç argümanla çağrılmalıdır. open fonksiyonunu daha fazla argümanla çağırmak "tanımsız 
    davranışa (undefined behavior)" yol açmaktadır.

    Fonksiyonun birinci parametresi açılacak dosyanın yol ifadesini belirtir. İkinci parametre açış bayraklarını (modlarını) 
    belirtmektedir. Bu parametre O_XXX biçiminde isimlendirilmiş sembolik sabitlerin "bit OR" işlemine sokulmasıyla oluşturulur. 
    Açış sırasında aşağıdaki sembolik sabitlerden yalnızca biri belirtilmek zorundadır.

    O_RDONLY
    O_WRONLY
    O_RDWR
    O_SEARCH (at'li fonksiyonlar için bulundurulmuştur, ileride ele alınacaktır)
    O_EXEC (fexecve fonksiyonu için bulundurulmuştur, ileride ele alınacaktır)

    Buradaki O_RDONLY "yalnızca okuma yapma amacıyla", O_WRONLY "yalnızca yazma yapma amacıyla" ve O_RDWR "hem okuma hem de yazma yapma amacıyla"
    dosyanın açılmak istendiği anlamına gelmektedir. İşletim sistemi, prosesin etkin kullanıcı id'sine ve etkin grup id'sine ve dosyanın kullanıcı ve grup 
    id'lerine bakarak prosesin dosyaya "r", "w" hakkının olup olmadığını kontrol eder. Eğer proses bu hakka sahip değilse open fonksiyonu başarısız olur. 
    Buradaki O_SEARCH bayrağı bazı POSIX fonksiyonlarının "at"li versiyonları için, O_EXEC bayrağı ise "fexecve" fonksiyonu için bulundurulmuştur. Bu bayraklar
    ileride ele alınacaktır.

    open fonksiyonu yalnızca olan dosyayı açmak için değil aynı zamanda yeni bir dosya yaratmak için de kullanılmaktadır. O_CREAT bayrağı 
    dosya varsa etkili olmaz. Ancak dosya yoksa dosyanın yaratılmasını sağlar. Yani O_CREAT bayrağı "dosya varsa olanı aç, yoksa yarat ve aç"
    anlamına gelmektedir. Bir dosya yaratılırken dosyanın erişim haklarını, dosyayı yaratan kişi open fonksiyonun üçüncü parametresinde vermek zorundadır. 
    Yani dosyanın erişim haklarını dosyayı yaratan kişi belirlemektedir. Biz O_CREAT bayrağını açış moduna eklemişsek bu durumda "dosya yaratılabilir" 
    fikri ile erişim haklarını open fonksiyonun üçüncü parametresinde belirtmemiz gerekir. Erişim hakları tüm bitleri sıfır tek biti 1 olan sembolik sabitlerin 
    "bit OR" işlemine sokulmasıyla oluşturulmaktadır. Bu sembolik sabitlerin hepsi S_I öneki başlar. Bunu R, W ya da X harfi izler. Bunu da USR, GRP ya da OTH 
    harfleri izlemektedir. Böylece 9 tane erişim hakkı şöyle isimlendirilmiştir:

    S_IRUSR
    S_IWUSR
    S_IXUSR
    S_IRGRP
    S_IWGRP
    S_IXGRP
    S_IROTH
    S_IWOTH
    S_IXOTH

    Örneğin S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH erişim hakları "rw-r--r--" anlamına gelmektedir.

    Ayrıca <sys/stat.h> içerisinde aşağıdaki sembolik sabitler de bildirilmiştir:

    S_IRWXU
    S_IRWXG
    S_IRWXO

    Bu sembolik sabitler şöyle oluşturulmuştur:

    #define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
    #define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
    #define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)

    Bu durumda örneğin S_IRWXU|S_IRWXG|S_IRWXO işlemi "rwxrwxrwx" anlamına gelmektedir.

    Yukarıdaki S_IXXX biçimindeki sembolik sabitlerin değerlerinin eskiden sistemden sisteme değişebileceği dikkate alınmıştır. Bu nedenle 
    POSIX standartları başlarda bu sembolik sabitlerin sayısal değerlerini işletim sistemlerini oluşturanların belirlemesini istemiştir. 
    Ancak daha sonraları (2008 ve sonrasında, SUS 4) bu sembolik sabitlerin değerleri POSIX standartlarında açıkça belirtilmiştir. Dolayısıyla 
    programcılar artık bu sembolik sabitleri kullanmak yerine bunların sayısal karşılıklarını da kullanabilir duruma gelmiştir. Ancak eski 
    sistemler dikkate alındığında bunların sayısal karşılıkları yerine yukarıdaki sembolik sabitlerin kullanılması tavsiye edilmektedir. Bu 
    sembolik sabitler aynı zamanda okunabilirliği de artırmaktadır. POSIX standartları belli bir sürümden sonra bu sembolik sabitlerin sayısal 
    değerlerini aşağıdaki gibi belirlemiştir:

    S_IRWXU             0700
    S_IRUSR             0400
    S_IWUSR             0200
    S_IXUSR             0100
    S_IRWXG             070
    S_IRGRP             040
    S_IWGRP             020
    S_IXGRP             010
    S_IRWXO             07
    S_IROTH             04
    S_IWOTH             02
    S_IXOTH             01
    S_ISUID             04000
    S_ISGID             02000
    S_ISVTX             01000

    Yani belli bir süreden sonra artık rwxrwxrwx biçiminde owner, group ve other bilgilerine ilişkin S_IXXX biçimindeki sembolik sabitler 
    gerçekten yukarıdaki sıraya göre bitleri temsil eder hale gelmiştir. Örneğin S_IWGRP sembolik sabiti 000010000 bitlerinden oluşmaktadır. 
    Bu durumda belli bir süreden sonra örneğin S_IRUSR|S_IWURS|S_IRGRP|S_IROTH bir erişim hakkını biz 0644 octal değeri ile edebiliriz. 
    Bu sembolik sabitlerin binary karşılıklarını da vermek istiyoruz.

    S_IRUSR        100 000 000
    S_IWUSR        010 000 000
    S_IXUSR        001 000 000

    S_IRGRP        000 100 000
    S_IWGRP        000 010 000
    S_IXGRP        001 001 000

    S_IROTH        000 000 100
    S_IWOTH        000 010 010
    S_IXOTH        001 001 001

    open fonksiyonunda O_CREAT bayrağı belirtilmemişse erişim haklarının girilmesinin hiçbir anlamı yoktur. Kaldı ki 
    O_CREAT bayrağı girildiğinde dosya varsa erişim hakları yine dikkate alınmayacaktır.

    POSIX sistemlerinde yukarıdaki S_IXXX biçimindeki sembolik sabitler mode_t türüyle temsil edilmiştir. mode_t türü 
    <sys/types.h> ve bazı başlık dosyalarında sistemi oluşturanların belirlediği bir tamsayı türü olarak typedef edilmiştir.

    O_TRUNC açış bayrağı "eğer dosya varsa onu sıfırlayarak aç" anlamına gelmektedir. Ancak O_TRUNC ancak yazma modunda açılan
    dosyalarda kullanılabilmektedir. Yani O_TRUNC bayrağını kullanabilmek için O_WRONLY ya da O_RDWR bayraklarından birinin de 
    belirtilmiş olması gerekmektedir. Örneğin O_WRONLY|O_CREAT|O_TRUNC açış modu "dosya yoksa yarat ancak varsa sıfırlayarak aç" 
    anlamına gelmektedir. O_TRUNC bayrağı için dosyanın yaratılıyor olması gerekmez. O_WRONLY|O_TRUNC geçerli bir açış modudur. 
    Bu durumda dosya yoksa open başarısız olur. Ancak dosya varsa sıfırlanarak açılır.

    O_APPEND bayrağı yazma işlemlerinin dosyanın sonuna yapılacağı anlamına gelmektedir. Yani bu bayrak kullanılırsa tüm yazma 
    işlemlerinde işletim sistemi dosya göstericisini dosyanın sonuna çekip sonra yazmayı yapmaktadır. Bu açış modu da O_WRONLY
    ya da O_RDWR için anlamlıdır. Örneğin O_RDWR|O_APPEND burada dosyaya her yazılan sona eklenecektir. Ancak dosyanın herhangi bir yerinden 
    okuma yapılabilecektir.

    O halde standart C'nin fopen fonksiyonundaki açış modlarının POSIX karşılıkları şöyle oluşturulabilir:

    Standart C fopen                    POSIX

    "w"                                 O_WRONLY|O_CREAT|O_TRUNC
    "w+"                                O_RDWR|O_CREAT|O_TRUNC
    "r"                                 O_RDONLY
    "r+"                                O_RDWR
    "a"                                 O_WRONLY|O_CREAT|O_APPEND
    "a+"                                O_RDWR|O_CREAT|O_APPEND

    O_EXCL bayrağı "exclusive" açım kullanılmaktadır. Bu bayrak O_CREAT ile birlikte kullanılmalıdır. O_CREAT|O_EXCL biçiminde 
    açış modu "dosya yoksa yarat, varsa yaratma başarısız ol" anlamına gelmektedir. O_EXCL bayrağının O_CREAT olmadan kullanılması 
    "tanımsız davranışa" yol açmaktadır.

    O_DIRECTORY bayrağının tek işlevi açılmak istenen dosya bir dizin dosyası değilse açımın başarısız olmasını sağlamak içindir.

    open fonksiyonunun diğer açış modları ileride başka konular içerisinde ele alınacaktır.

    Erişim hakları open fonksiyonu tarafından (yani open fonksiyonunun çağırdığı sistem fonksiyonu tarafından) kontrol edilmektedir. 
    Örneğin biz dosyayı O_RDWR modunda açmak isteyelim bu durumda prosesimizin dosyaya "r" ve "w" haklarına sahip olması gerekir. Eğer 
    prosesimiz dosya için bu haklara sahip değilse open başarısız olur ve errno EACCESS değeri ile set edilir. Burada önemli olan nokta
    kontrolün en başta open tarafından yapılmasıdır. Yani O_RDWR modunda açma istendiğinde eğer proses bu haklara sahip değilse
    açma başarılı olup read ya da write fonksiyonlarındaki hatadan dolayı başarısız olma söz konusu değildir. Direkt açmanın kendisi 
    başarısız olmaktadır.

    open fonksiyonu başarı durumunda int türden "dosya betimleyicisi (file descriptor)" denilen bir değerle geri dönmektedir. 
    Dosya betimleyicisi bir handle olarak diğer fonksiyonlar tarafından istenmektedir. open başarısız olursa -1 ile geri döner ve errno 
    uygun biçimde set edilir. open fonksiyonunun başarısız olması için pek çok neden söz konusudur. Bundan dolayı açma işleminin başarısı 
    kesinlikle test edilmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                10. Ders 26/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------

    open fonksiyonu işletim sisteminin dosya açan sistem fonksiyonunu (Linux'ta sys_open) çağırmaktadır. Bu sistem fonksiyonu
    açılacak dosyaya ilişkin bilgileri diskten bulur ve o bilgileri "dosya nesnesi (file object)" denilen bir yapının içerisine 
    yerleştirir. Dosya nesnesi Linux'un kaynak kodlarında "struct file" türü ile temsil edilmiştir. İşletim sistemi dosya nesnesinin 
    içini doldurduktan sonra dosya betimleyici tablosunda boş bir slot bulur ve o slota dosya nesnesinin adresini yazar. Anımsanacağı gibi 
    dosya betimleyici tablosu dosya nesnelerinin adreslerini tutan bir gösterici dizisi biçiminde organize edilmiştir. Dosya betimleyici tablosunun 
    yeri prosesin kontrol bloğundan hareketle elde edilmektedir. İşte open fonksiyonunun bize geri döndürdüğü dosya betimleyicisi aslında
    dosya betimleyici tablosunda (yani gösterici dizisinde) bir indeks belirtmektedir.

    Bir program çalıştığında genellikle dosya betimleyici tablosunun ilk üç betimleyicisi dolu diğerleri boştur. Dosya betimleyici tablosunun 
    0'ıncı slotu (yani 0 numaralı betimleyici) terminal aygıt sürücüsü için oluşturulmuş dosya nesnesini göstermektedir. Buna stdin 
    dosya betimleyicisi denilmektedir. 1 ve 2 numaralı betimleyiciler yine terminal aygıt sürücüsü oluşturulmuş dosya betimleyicisini göstermektedir. 
    (1 ve 2 numaralı betimleyiciler aynı nesneyi göstermektedir) Bu betimleyicilere de sırasıyla stdout ve stderr denilmektedir. 
    Böylece ilk boş betimleyici genellikle 3 numaralı betimleyici olmaktadır. open fonksiyonun dosya betimleyici tablosunda ilk boş betimleyiciyi vermesi
    POSIX standartlarında garanti edilmiştir.

    Her prosesin proses kontrol bloğu ve dolayısıyla dosya betimleyici tablosu birbirinden farklıdır. O halde dosya betimleyicileri 
    kendi prosesinin dosya betimleyici tablosunda bir indeks belirtmektedir. Yani dosya betimleyicileri prosese özgü bir anlama sahiptir.

    Bu durumda tipik olarak işletim sisteminin dosya açan sistem fonksiyonu sırasıyla şu işlemleri yapmaktadır:

    1) Dosya betimleyici tablosunda ilk boş betimleyiciyi bulmaya çalışır. Boş betimleyiciyi bulamazsa başarısız olur ve errno 
    değerini EMFILE ise set eder.

    2) Dosya nesnesini tahsis eder ve bunun içini diskten elden ettiği bilgilerle doldurur. Bunun adresini de dosya betimleyici tablosunda 
    ilk boş betimleyiciye ilişkin slota yazar.

    3) Dosya betimleyici tablosunda indeks belirten betimleyici ile geri döner.

    C'nin fopen fonksiyonunda dosya açımı sırasında "text mode", "binary mode" gibi bir kavram vardır. Halbuki işletim sisteminde 
    böyle bir kavram yoktur. İşletim sistemine göre dosya byte'lardan oluşmaktadır. Text mode, binary mode C ve diğer diller tarafından 
    uydurulmuş olan yapay bir kavramdır.

    Bir proses her open işlemi yaptığında kesinlikle yeni bir dosya nesnesi oluşturulur. Bu durumda bir proses aynı dosyayı aynı biçimde
    ikinci kez açmış olsa bile dosya aynı dosya nesnesi kullanılmaz. Her iki open iki farklı dosya nesnesinin ve dosya betimleyicisinin
    oluşmasına yol açmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    printf("file opened: %d\n", fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Açılan her dosyanın kapatılması gerekir. Bir dosyanın kapatılması sırasında işletim sistemi dosyanın açılması sırasında yapılan 
    işlemleri geri almaktadır. Tipik olarak UNIX/Linux sistemlerinde dosya kapatıldığında şunlar yapılmaktadır:

    1) Dosya nesnesi eğer onu gösteren tek bir betimleyici varsa yok edilir. 
    2) Dosya betimleyici tablosundaki betimleyiciye ilişkin slot boşaltılır.

    İleride de görüleceği gibi dosya betimleyici tablosunda birden fazla betimleyici aynı dosya nesnesini gösteriyor durumda olabilir. 
    Bu durumda işletim sistemi dosya nesnesi içerisinde bir sayaç tutup bu sayacı artırıp eksiltmektedir. Sayaç 0'a geldiğinde nesneyi silmektedir. 
    (Linux'un kaynak kodlarında bu sayaç struct file yapısının f_count elemanında tutulmaktadır.)

    Bir dosya artık kullanılmayacaksa onu kapatmak iyi bir tekniktir. Çünkü bu sayede:

    1) Dosya betimleyici tablosunda gereksiz bir slot tahsis edilmiş durumda olmaz. 
    2) Dosya nesnesi gereksiz bir biçimde kernel alanı içerisinde yer kaplamaz.

    Tabii işletim sistemi, proses dosyayı kapatmasa bile proses sonlandırılırken dosya prosesin dosya betimleyici tablosunu inceler
    ve açık dosyaları bu biçimde kapatır. Yani biz bir dosyayı kapatmasak bile proses bittiğinde dosyalar zaten kapatılmaktadır.

    Dosyanın kapatılması için close isimli POSIX fonksiyonu bulundurulmuştur. Bu POSIX fonksiyonu doğrudan işletim sisteminin 
    dosyayı kapatan sistem fonksiyonunu çağırmaktadır. close fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int close(int fd);

    Fonksiyon parametre olarak dosya betimleyicisini alır. close fonksiyonu başarı durumunda 0, başarısızlık durumunda -1 değerine geri 
    dönmektedir. Fonksiyonun geri dönüş değeri genellikle kontrol edilmez. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    printf("file opened: %d\n", fd);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    İlk UNIX sistemlerinden beri creat isimli bir fonksiyon da open fonksiyonun bir sarma fonksiyonu biçiminde bulundurulmaktadır. 
    creat fonksiyonu POSIX standartlarında var olan bir fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int creat(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini belirtmektedir. İkinci parametre erişim bilgisini belirtir. Görüldüğü gibi 
    fonksiyonda açış modu belirten flags parametresi yoktur. Çünkü bu parametre O_WRONLY|O_CREAT|O_TRUNC biçiminde alınmaktadır. creat fonksiyonu
    aşağıdaki gibi yazılmıştır:

    int creat(const char *path, mode_t mode)
    {
        return open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyadaki her bir byte'a bir offset numarası karşı getirilmiştir. Buna ilgili byte'ın offset'i denilmektedir. Dosya göstericisi
    okuma ve yazma işlemlerinin hangi offset'ten itibaren yapılacağını gösteren bir offset belirtmektedir. Okuma ya da yazma miktarı 
    kadar dosya göstericisi otomatik olarak ilerletilmektedir. Dosya ilk açıldığında dosya göstericisi 0 durumundadır. Dosya göstericisinin 
    dosyanın son byte'ından sonraki byte'ı göstermesi durumuna EOF durumu denir. EOF durumunda okuma yapılamaz. Ancak yazma yapılabilir. 
    Bu durumda yazılanlar dosyaya eklenmiş olur. Dosyada araya bir şey eklemek (insert) diye bir kavram yoktur. Dosya boyutunu değiştirmek 
    için dosya göstericisi EOF'a çekilip yazma yapılmalıdır.

    Dosya göstericisin konumu dosya nesnesi içerisinde saklanmaktadır. (Linux'un kaynak kodlarında "struct file" yapısının f_pos 
    elemanı dosya göstericisinin konumunu tutmaktadır.) Biz aynı dosyayı ikinci kez açmış olsak bile yeni bir dosya nesnesi 
    dolayısıyla yeni bir dosya göstericisi elde etmiş oluruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyadan okuma yapmak için read POSIX fonksiyonu kullanılmaktadır. Pek çok sistemde bu POSIX fonksiyonu doğrudan işletim sisteminin
    okuma yapan sistem fonksiyonunu (Linux'ta sys_read) çağırmaktadır. read fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    ssize_t read(int fd, void *buf, size_t nbyte);

    Fonksiyonun birinci parametresi okuma işleminin yapılacağı dosya betimleyicisini belirtmektedir. İşletim sistemi, bu betimleyiciden 
    hareketle dosya nesnesine erişmektedir. İkinci parametre bellekteki transfer adresini belirtmektedir. Üçüncü parametre okunacak 
    byte sayısını belirtir.

    Fonksiyon başarı durumunda okuyabildiği byte ile geri döner. read fonksiyonu ile eğer dosya göstericisinin gösterdiği yerden itibaren dosya sonuna kadar 
    mevcut olan byte miktarından daha fazla byte okunmak istenirse, read fonksiyonu okuyabildiği kadar byte'ı okur ve okuyabildiği byte sayısına 
    geri döner. Dosya göstericisi EOF durumunda ise read hiç okuma yapamayacağı için 0 ile geri dönmektedir. Ancak argümanların
    yanlış girilmesinde ya da IO hatalarında read başarısız olur ve -1 değerine geri döner. ssize_t <unistd.h> ve <sys/types.h> 
    içerisinde işaretli bir tamsayı türü biçiminde typedef edilmek durumunda olan POSIX'e özgü bir typedef ismidir.

    read fonksiyonu ile dosyadan 0 byte okunmak istendiğinde read fonksiyonu temel bazı kontrolleri yapar. (Örneğin; dosyanın okuma modunda 
    açılmış olup olmadığı kontrol edilir.) Eğer bu kontrollerde bir sorun çıkarsa -1 değerine geri döner. Eğer bu kontrollerde bir sorun çıkmazsa 
    0 değerine geri döner ve herhangi bir okuma işlemi yapmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");

    buf[result] = '\0';

    printf(":%s:\n", buf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi bir dosyayı (örneğimizde içerisinde yazı olan bir dosyayı) dosya sonuna kadar read fonksiyonu ile bir döngü içerisinde 
    okuyalım. Bu tür durumlarda klasik yöntem aşağıdaki gibi bir döngü oluşturmaktır:

    while ((result = read(fd, buf, BUFSIZE)) > 0) {
        buf[result] = '\0';
        printf("%s", buf);
    }

    if (result == -1)
        exit_sys("read");

    Bu döngüden IO hatası oluşunca ya da dosya göstericisi dosyanın sonuna geldiğinde çıkılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFSIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFSIZE + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fd, buf, BUFSIZE)) > 0) {
        buf[result] = '\0';
        printf("%s", buf);
    }

    if (result == -1)
        exit_sys("read");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                11. Ders 27/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyaya yazma yapmak için write isimli POSIX fonksiyonu kullanılmaktadır. Bu fonksiyon da pek çok sistemde doğrudan işletim sisteminin
    dosyaya yazma yapan sistem fonksiyonunu (Linux'ta sys_write) çağırmaktadır. Prototipi şöyledir:

    #include <unistd.h>

    ssize_t write(int fd, const void *buf, size_t nbyte);

    Fonksiyonun birinci parametresi yazma yapılacak dosyaya ilişkin dosya betimleyicisini belirtir. İkinci parametre yazılacak 
    bilgilerin bulunduğu bellek adresidir. Üçüncü parametre yazılacak byte sayısını belirtir. write fonksiyonu başarılı olarak yazılan 
    byte sayısı ile geri dönmektedir. Normal olarak bu değer üçüncü parametrede belirtilen yazılmak istenen byte sayısıdır. Ancak çok seyrek 
    bazı durumlarda (örneğin diskin dolu olması gibi) write talep edilenden daha az byte'ı yazabilir. Bu durumda yazabildiği byte sayısı ile geri döner. 
    write başarısız olursa -1 değerine geri dönmektedir.

    write fonksiyonu ile dosyaya 0 byte yazılmak istendiğinde gerçek bir yazma yapılmaz. write fonksiyonu bu durumda yazma konusunda 
    gerekli kontrolleri yapar (örneğin dosyanın yazma modunda açılıp açılmadığı gibi). Eğer bu kontrollerde başarısızlık oluşursa 
    write fonksiyonu -1 ile geri döner. Eğer bu kontrollerde başarısızlık oluşmazsa write fonksiyonu 0 ile geri döner. Ancak yukarıda da 
    belirttiğimiz gibi bu durumda gerçek bir yazma yapılmamaktadır. POSIX standartları normal dosyaların dışında (yani "regular" olmayan dosyaların dışında)
    0 byte yazma işlemini "unspecified" olarak belirtmiştir. Dolayısıyla ileride göreceğimiz boru gibi dosyalara 0 byte yazıldığında ne olacağı
    o sisteme bağlı bir durumdur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[] = "this is a test";
    ssize_t result;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (write(fd, buf, strlen(buf)) == -1)
        exit_sys("write");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dosya kopyalama bir döngü içerisinde kaynak dosyadan hedef dosyaya blok blok okuma yazma işlemi ile
    yapılmaktadır. Ancak bazı UNIX türevi işletim sistemleri dosya kopyalama işlemi için sistem fonksiyonları da bulundurabilmektedir. 
    Örneğin Linux sistemlerinde copy_file_range isimli sistem fonksiyonu doğrudan disk üzerinde blok kopyalaması yoluyla dosya 
    kopyalamasını hiç user mode işlem yapmadan gerçekleştirebilmektedir. Ancak bu işlemin taşınabilir yolu yukarıda belirttiğimiz gibi 
    kaynaktan hedefe aktarım yapmaktır. Pekiyi bu kopyalama işleminde hangi büyüklükte bir tampon kullanılmalıdır? Tipik olarak dosya sistemindeki 
    blok uzunluğu bunun için tercih edilir. stat, fstat, lstat gibi fonksiyonlar bunu bize verirler. Blok uzunlukları 512'nin 
    katları biçimindedir.

    Aşağıdaki örnekte blok kopyalaması yoluyla dosya kopyalaması yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE];
    int fds, fdd;
    ssize_t result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fds = open(argv[1], O_RDONLY)) == -1)
        exit_sys(argv[1]);

    if ((fdd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys(argv[2]);

    while ((result = read(fds, buf, BUFFER_SIZE)) > 0)
        if (write(fdd, buf, result) != result) {
            fprintf(stderr, "cannot write file!...\n");
            exit(EXIT_FAILURE);
        }

    if (result == -1)
        exit_sys("read");

    close(fds);
    close(fdd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    write çok çok seyrek de olsa başarılı olduğu halde talep edilen miktar kadar hedef dosyaya yazamayabilir. Örneğin diskin dolu 
    olması durumunda ya da bir sinyal oluşması durumunda write talep edilen miktar kadar yazma yapamayabilir. Bu tür durumları diğer
    durumlardan ayırmak için ayrı bir kontrol yapmak gerekebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE];
    int fds, fdd;
    ssize_t size, result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fds = open(argv[1], O_RDONLY)) == -1)
        exit_sys(argv[1]);

    if ((fdd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys(argv[2]);

    while ((result = read(fds, buf, BUFFER_SIZE)) > 0) {
        if ((size = write(fdd, buf, result)) == -1)
            exit_sys("write");
        if (size != result) {
            fprintf(stderr, "cannot write file!...\n");
            exit(EXIT_FAILURE);
        }
    }

    if (result == -1)
        exit_sys("read");

    close(fds);
    close(fdd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    read ve write POSIX fonksiyonları yukarıda da belirttiğimiz gibi dosya göstericisinin gösterdiği yerden itibaren okuma ve 
    yazma işlemlerini yapmaktadır. Bu fonksiyonlar dosya göstericisinin konumunu okunan ya da yazılan miktar kadar ilerletmektedir. 
    İşte read ve write fonksiyonlarının pread ve pwrite biçiminde bir versiyonu da bulunmaktadır. pread ve pwrite fonksiyonları, 
    işlemlerini dosya göstericisinin gösterdiği yerden itibaren değil, parametreleriyle belirtilen offset'ten yapmaktadır. Bu 
    fonksiyonlar dosya göstericisinin konumunu değiştirmezler. Uygulamada pread ve pwrite fonksiyonları seyrek kullanılmaktadır. 
    Örneğin dosyanın farklı yerlerinden sürekli okuma/yazma yapıldığı durumlarda bu fonksiyonlar kullanım kolaylığı sağlayabilmektedir. 
    Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
    ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);

    pread ve pwrite fonksiyonlarının read ve write fonksiyonlarından tek farkı offset parametresidir. Bu fonksiyonlar dosya 
    göstericisinin gösterdiği yerden değil, son parametreleriyle belirtilen yerden okuma ve yazma işlemini yaparlar. Fonksiyonların
    dosya göstericisinin konumunu değiştirmediğine dikkat ediniz.

    Dosyalara okuma yazma işlemi genellikle ardışıl bir biçimde yapıldığı için bu fonksiyonlar seyrek kullanılmaktadır. Ancak
    örneğin veritabanı işlemlerinde yukarıda da belirttiğimiz gibi dosyanın farklı offset'lerinden sıkça okuma ve yazmanın
    yapıldığı durumlarda bu fonksiyonlar tercih edilebilmektedir.

    pread ve pwrite fonksiyonları da doğrudan ilgili sistem fonksiyonlarını çağırmaktadır. (Linux sistemlerinde sys_pread ve 
    sys_pwrite). Tabii bu işlemler önce dosya göstericisini saklayıp, sonra konumlandırıp, sonra read/write işlemlerini yapıp, 
    sonra da yeniden dosya göstericisini eski konumuna yerleştirmekle yapılabilir. Ancak pread ve pwrite işlemlerini yapan 
    sistem fonksiyonları bu biçimde değil, daha doğrudan aynı işlemi yapmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosya göstericisi dosya açıldığında 0'ıncı offset'tedir. Ancak okuma ve yazma yapıldığında okunan ya da yazılan miktar kadar otomatik ilerletilmektedir. 
    Dosya göstericisini belli bir konuma almak için lseek isimli POSIX fonksiyonu kullanılmaktadır. Bu fonksiyon da pek çok işletim 
    sisteminde doğrudan dosyayı konumlandıran sistem fonksiyonunu (Linux'ta sys_lseek) çağırmaktadır. lseek fonksiyonun genel kullanımı
    fseek standart C fonksiyonuna çok benzemektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    off_t lseek(int fd, off_t offset, int whence);

    Fonksiyonun birinci parametresi dosya göstericisi konumlandırılacak dosyaya ilişkin dosya betimleyicisini belirtir. Dosya göstericisi 
    dosya nesnesinin (Linux'ta struct file) içerisinde tutulmaktadır. İkinci parametre konumlandırma offset'ini belirtir. off_t 
    <unistd.h> ve <sys/types.h> içerisinde işaretli bir tamsayı türü biçiminde typedef edilmiş olan bir tür ismidir. Üçüncü parametre konumlandırma 
    orijinini belirtmektedir. Bu üçüncü parametre 0, 1 ya da 2 olarak girilebilir. Tabii sayısal değer girmek yerine yine SEEK_SET (0), SEEK_CUR (1)
    ve SEEK_END (2) sembolik sabitlerini girebiliriz. Bu sembolik sabitler <unistd.h> ve <stdio.h> içerisinde de bildirilmiştir. 
    Fonksiyon başarı durumunda konumlandırılan offset'e, başarısızlık durumunda -1 değerine geri dönmektedir.

    SEEK_SET konumlandırmanın dosyanın başından itibaren yapılacağını, SEEK_CUR konumlandırmanın o anda dosya göstericisinin gösterdiği 
    yerden itibaren yapılacağını ve SEEK_END de konumlandırmanın EOF durumundan itibaren yapılacağını belirtmektedir. En normal durum 
    SEEK_SET orijininde ikinci parametrenin >= 0, SEEK_END orijininde <= 0 biçiminde girilmesidir. SEEK_CUR orijininde ikinci 
    parametre pozitif ya da negatif girilebilir. Örneğin dosya göstericisini EOF durumuna şöyle konumlandırabiliriz:

    lseek(fd, 0, SEEK_END);

    Dosya sistemine de bağlı olarak UNIX/Linux sistemleri dosya göstericisini EOF'un ötesine konumlandırmaya izin verebilmektedir. 
    Bu özel bir durumdur. Bu tür durumlarda dosyaya yazma yapıldığında "dosya delikleri (file holes)" oluşmaktadır. Dosya delikleri konusu ileride 
    ele alınacaktır.

    Aslında dosya açarken O_APPEND modu atomik bir biçimde her write işleminden önce dosya göstericisini EOF durumuna çekmektedir. Bu nedenle 
    her yazılan dosyanın sonuna eklenmektedir.

    Aşağıdaki örnekte "test.txt" O_WRONLY modunda açılmış ve dosya göstericisi EOF durumuna çekilerek dosyaya ekleme yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[] = "\nthis is a test";

    if ((fd = open("test.txt", O_WRONLY)) == -1)
        exit_sys("open");

    lseek(fd, 0, SEEK_END);

    if (write(fd, buf, strlen(buf)) == -1)
        exit_sys("write");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir C/C++ programcısı olarak UNIX/Linux sistemlerinde dosya işlemleri yapmak için üç seçenek söz konusu olabilir:

    1) C'nin ya da C++'ın standart dosya fonksiyonlarını kullanmak
    2) POSIX dosya fonksiyonlarını kullanmak
    3) Sistem fonksiyonlarını kullanmak

    Burada en taşınabilir olan standart C/C++ fonksiyonlarıdır. Dolayısıyla ilk tercih bunlar olmalıdır. Ancak C ve C++'ın standart dosya fonksiyonları 
    spesifik bir sistemin gereksinimini karşılayacak biçimde yazılmamıştır. Bu nedenle bazen doğrudan POSIX fonksiyonlarının kullanılması 
    gerekebilmektedir. Genellikle dosya işlemleri yapan sistem fonksiyonlarının kullanılması hiç gerekmez. Çünkü Linux'ta olduğu gibi 
    pek çok UNIX türevi sistemde yukarıda gördüğümüz POSIX fonksiyonları zaten doğrudan sistem fonksiyonlarını çağırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre dosyaya yapılan read ve write işlemleri sistem genelinde atomiktir. Yani örneğin iki program 
    aynı anda aynı dosyanın aynı yerine yazma yapsa bile iç içe geçme oluşmaz. Önce birisi yazar daha sonra diğeri yazar. 
    Tabii hangi prosesin önce yazacağını bilemeyiz. Ancak burada önemli olan nokta iç içe geçmenin olmamasıdır. Benzer biçimde
    bir read ile bir dosyanın bir yerinden n byte okumak istediğimizde başka bir proses aynı dosyanın aynı yerine yazma yaptığında
    biz ya o prosesin yazdıklarını okuruz ya da onun yazmadan önceki dosya değerlerini okuruz. Yarısı eski yarısı yeni bir bilgi okumayız. 
    Ancak işletim sistemi farklı read ve write çağrılarını bu anlamda senkronize etmemektedir. Yani örneğin biz bir dosyanın belli bir yerine
    iki farklı write fonksiyonu ile ardışık şeyler yazdığımızı düşünelim. Birinci write işleminden sonra başka bir proses artık orayı 
    değiştirebilir. Dolayısıyla bu anlamda bir iç içe girme durumu oluşabilir. Veritabanı programlarında bu tür durumlarla sık karşılaşılmaktadır. 
    Örneğin veritabanı programı bir kaydı "data" dosyasına yazıp ona ilişkin indeksleri "index" dosyasına yazıyor olabilir. Bu durumda 
    iki write işlemi söz konusudur. Data dosyasına bilgiler yazıldıktan sonra henüz indeks dosyasına bilgi yazılmadan başka bir proses bu iki işlemi hızlı
    davranarak yaparsa data ve indeks bütünlüğü bozulur. İşletim sisteminin burada bir sorumluluğu yoktur. Bu tarz işlemlerde senkronizasyon 
    programcılar tarafından sağlanmak zorundadır. Bu tür senkronizasyonlar senkronizasyon nesneleriyle (semaphore gibi, mutex gibi) dosya bütününde 
    yapılabilir. Ancak tüm dosyaya erişimin engellenmesi iyi bir teknik değildir. İşte bu tür durumlar için işletim sistemleri çekirdeğe 
    entegre edilmiş olan "dosya kilitleme (file locking)" mekanizması bulundurmaktadır. Dosya kilitleme tüm dosyayı değil dosyanın belli offset'lerine erişimi 
    engelleme amacındadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz open fonksiyonu ile bir dosya yaratırken yaratacağımız dosyaya verdiğimiz erişim hakları dosyaya tam olarak yansıtılmayabilir. 
    Yani örneğin biz gruba "w" hakkı vermek istesek bile bunu sağlayamayabiliriz. Çünkü belirtilen erişim değerlerini maskeleyen (yani ortadan kaldıran)
    bir mekanizma vardır. Buna prosin umask değeri denilmektedir. Prosesin umask değeri mode_t türü ile ifade edilir; sahiplik, grupluk ve diğerlik
    bilgilerini içerir. Bu bilgiler aslında maskeleneck değerleri belirtmektedir. Örneğin prosesin umask değerinin S_IWGRP|S_IWOTH olduğunu varsayalım.
    Bu umask değeri "biz open fonksiyonu ile bir dosyayı yaratırken grup için ve diğerleri için "w" hakkı versek bile bu hak dosyaya 
    yansıtılmayacak" anlamına gelmektedir. Eğer prosesin umask değeri 0 ise bu durumda maskelenecek bir şey yoktur dolayısıyla verilen 
    hakların hepsi dosyaya yansıtılır. Prosesin umask değerinin umask olduğunu varsayalım. Dosyaya vermek istediğimiz erişim haklarının da 
    mode olduğunu varsayalım. (Yani mode S_IXXX gibi tek biti 1 olan değerlerin bit düzeyinde OR'lanması ile oluşturulmuş değer olsun.)
    Bu durumda dosyaya yansıtılacak erişim hakları mode & ~umask olacaktır. Yani prosesin umask değerindeki bitler maskelenecek erişim 
    haklarını belirtmektedir.

    Prosesin başlangıçtaki umask değeri üst prosesten aktarılmaktadır. Örneğin biz kabuktan program çalıştırırken çalıştırdığımız programın umask 
    değeri kabuğun (örneğin bash prosesinin) umask değeri olarak bizim prosesimize geçirilecektir. Kabuğun umask değeri "umask" isimli
    komutla elde edilebilir. Bu değer genellikle "0022" ya da "0002" gibi bir değerde olacaktır. Buradaki basamaklar octal sayı (sekizlik sistemde sayı)
    belirtmektedir. Bir octal digit 3 bitle açılmaktadır. Dolayısıyla bu bitler maskelenecek erişim haklarının durumunu belirtir: 

    ? owner group other

    En yüksek anlamlı octal digit şimdiye kadar görmediğimiz başka haklarla ilgilidir. Bu haklara "set user id", "set group id" ve "sticky"
    hakları denilmektedir. Ancak diğer 3 octal digit sırasıyla owner, group ve other maskeleme bitlerini belirtmektedir.

    Kabuk üzerinde umask komutuyla aynı zamanda kabuğun umask değeri de değiştirilebilir. Bu durumda yine değiştirme değerleri octal digitler 
    biçiminde verilmelidir. Örneğin:

    $ umask 022

    Burada en yüksek anlamlı octal verilmediğine göre 0 kabul edilir. O halde burada belirtilern umask değeri grup için ve diğerleri için
    "w" hakkını maskeleyecektir. (Zaten pek çok kabulta umask değerin default durumu böyledir.) Bazen programcı umask değerini tamamen sıfırlamak da isteyebilir. 
    Bu işlem şöyle yapılabilir:

    $ umask 0

    Burada yüksek anlamlı üç octal digit de 0 kabul edilmektedir. Bu durumda artık çalıştırdığımız programda open fonksiyonun tüm erişim hakları 
    dosyalara yansıtılacaktır.

    Bir proses başlangıçta umask değerini üst prosesten almaktadır. Ancak proses istediği zaman umask isimli POSIX fonksiyonu ile kendi umask 
    değerini değiştirebilmektedir. umask fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    mode_t umask(mode_t cmask);

    Fonksiyon belirtilen değerle prosesin umask değerini set eder ve prosesin eski umask değerine geri döner. Fonksiyon başarısız olamaz.

    umask fonksiyonu ile kendi prosesimizin umask değerini almak için onu değiştirmemiz gerekir. Bu durumda bu işlem aşağıdaki bir kodla 
    yapılabilir:

    mode_t mode;

    mode = umask(0);
    umask(mode);

    Tabii programcı umask fonksiyonuna octal digitler girebilir. Ancak sistemlerde bu ocatl digitler tam olarak S_IXXX sembolik sabitlerinin 
    değerlerine karşı gelmeyebilir. Ancak daha önceden de bahsedildiği gibi POSIX standartlarında belli bir zamandan sonra bu S_IXXX sembolik sabitlerinin 
    değerleri açıkça belirtilmiştir. Örneğin:

    umask(00022);               /* Eskiden bu biçimde belirleme taşınabilir değildi, eski sistemlerde dikkat edilmesi gerekir */
    umask(S_IWGRP|S_IWOTH);     /* Bu biçimde belirleme daha okunabilirdir. */

    Aşağıdaki örnekte prosesin umask değeri önce sıfırlanmış, sonra bir dosya yaratılmıştır. open fonksiyonunda verilen erişim hakları 
    artık dosyaya tamamen yansıtılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    umask(0);

    if ((fd = open("x.dat", O_WRONLY|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO)) == -1)
        exit_sys("open");

    printf("success...\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                12. Ders 03/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki daha önce yapmış olduğumuz shell programına umask komutunu ekliyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <limits.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS        128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);

void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);
void cd_proc(void);
void umask_proc(void);

int check_umask_arg(const char *str);

void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {"cd", cd_proc},
    {"umask", umask_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing...\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    printf("%s\n", g_cwd);
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void umask_proc(void)
{
    mode_t mode;
    int argval;

    if (g_nparams > 2) {
        printf("too many arguments in umask command!...\n");
        return;
    }

    if (g_nparams == 1) {
        mode = umask(0);
        umask(mode);

        printf("%04o\n", (int)mode);

        return;
    }

    if (!check_umask_arg(g_params[1])) {
        printf("%s octal number out of range!...\n", g_params[1]);
        return;
    }

    sscanf(g_params[1], "%o", &argval);
    umask(argval);
}

int check_umask_arg(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde open, close, read, wri,te ve lseek fonksiyonlarının yanı sıra pek çok yardımcı dosya fonksiyonları da vardır. 
    Bu yardımcı dosya fonksiyonları dosyalar üzerinde bazı önemli işlemleri yapmaktadır. Bu bölümde bu fonksiyonların önemli olanlarını
    tanıtacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyaya ilişkin bilgileri elde etmek için stat, lstat ve fstat isimli üç fonksiyon kullanılmaktadır. Bu fonksiyonlar
    aslında aynı şeyi yaparlar. Fakat parametrik yapı bakımından ve semantik bakımdan bunların arasında küçük farklılıklar vardır. 
    Fonksiyonların prototipleri şöyledir:

    #include <sys/stat.h>

    int stat(const char *path, struct stat *buf);
    int fstat(int fd, struct stat *buf);
    int lstat(const char *path, struct stat *buf);

    stat fonksiyonları bir dosyanın bilgilerini elde etmek amacıyla kullanılmaktadır. Örneğin dosyanın erişim hakları, kullanıcı ve grup id'leri,
    dosyanın uzunluğu, dosyanın tarih zaman bilgileri bu stat fonksiyonlarıyla elde edilmektedir. ls komutu -l seçeneği ile kullanıldığında
    aslında dosya bilgilerini bu stat fonksiyonuyla elde edip ekrana yazdırmaktadır.

    stat fonksiyonlarından en çok kullanılanı stat fonksiyonudur:

    int stat(const char *path, struct stat *buf);

    Fonksiyonun birinci parametresi bilgisi elde edilecek dosyanın yol ifadesini belirtmektedir. İkinci parametresi dosya 
    bilgilerinin yerleştirileceği struct stat isimli bir yapı nesnesinin adresini almaktadır. stat isimli yapı <sys/stat.h> 
    içerisinde bildirilmiştir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri döner.

    struct stat yapısının elemanları şöyledir:

    struct stat {
        dev_t     st_dev;         /* ID of device containing file */
        ino_t     st_ino;         /* Inode number */
        mode_t    st_mode;        /* File type and mode */
        nlink_t   st_nlink;       /* Number of hard links */
        uid_t     st_uid;         /* User ID of owner */
        gid_t     st_gid;         /* Group ID of owner */
        dev_t     st_rdev;        /* Device ID (if special file) */
        off_t     st_size;        /* Total size, in bytes */
        blksize_t st_blksize;     /* Block size for filesystem I/O */
        blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

        /* Since Linux 2.6, the kernel supports nanosecond
            precision for the following timestamp fields.
            For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
    };

    Yapının st_dev elemanı dosyanın içinde bulunduğu aygıtın aygıt numarasını belirtir. Genellikle programcılar bu bilgiye gereksinim duymazlar. dev_t 
    türü herhangi bir tamsayı türü biçiminde typedef edilebilecek bir tür ismidir.

    stat fonksiyonları dosya bilgilerini aslında diskten elde etmektedir. UNIX/Linux sistemlerinde kullanılan dosya sistemlerinin disk organizasyonunda 
    i-node tablosu denilen bir tablo vardır. i-node tablosu i-node elemanlarından oluşmaktadır. Her i-node elemanı bir dosyaya ilişkin bilgileri tutar. 
    İşte bir dosyanın bilgilerinin hangi i-node elemanında olduğu stat yapısının st_ino elemanına yerleştirilmektedir. Dosyanın i-node elemanı i-node 
    tablosunda bir indeks belirtmektedir. Dosyaların i-node numaraları ls komutunda -i seçeneği ile gösterilmektedir. ino_t türü işaretsiz olmak koşuluyla 
    herhangi bir tamsayı türü biçiminde typedef edilebilmektedir.

    Yapının st_mode elemanı dosyanın erişim bilgilerini ve türünü içermektedir. Yine bu elemanın içerisindeki değerler bitler biçiminde oluşturulmuştur. 
    1 olan bitler ilgili özelliğin olduğunu belirtmektedir. Belli bir erişim hakkının (örneğin S_IWGRP gibi) olup olmadığını anlamak için programcı ilgili 
    bitin set edilip edilmediğine st_mode & S_IXX işlemi ile bakmalıdır. Dosyanın türü de yine aynı elemanın içerisine bitsel olarak kodlanmıştır. Ancak hangi bitlerin
    hangi türleri belirttiği POSIX standartlarında belirtilmemiştir. Bu durum sistemden sisteme değişebilmektedir. (Anımsanacağı gibi eskiden aynı durum S_IXXX
    sembolik sabitleri için de geçerliydi. Ancak daha sonra bu sembolik sabitlerin sayısal değerleri yani bit pozisyonları POSIX standartlarında belirlendi.)
    Dosyanın türünü anlamak için iki yöntem bulunmaktadır. Birincisi <sys/stat.h> içerisindeki S_ISXXX biçimindeki makroları kullanmaktır. Bu makrolar
    eğer dosya ilgili türdense sıfır dışı bir değer ilgili türden değilse sıfır değerini verir. Makrolar şunlardır:

    S_ISBLK(m)      Blok aygıt sürücü dosyası mı? (ls -l'de 'b' dosya türü)
    S_ISCHR(m)      Karakter aygıt sürücü dosyası mı? (ls -l'de 'c' dosya türü)
    S_ISDIR(m)      Dizin dosyası mı? (ls -l'de 'd' dosya türü)
    S_ISFIFO(m)     Boru dosyası mı? (ls -l'de 'p' dosya türü)
    S_ISREG(m)      Sıradan bir disk dosyası mı? (ls -l'de '-' dosya türü)
    S_ISLNK(m)      Sembolik bağlantı dosyası mı? (ls -l'de 'l' dosya türü)
    S_ISSOCK(m)     Soket dosyası mı? (ls -l'de 's' dosya türü)

    Dosya türünün tespiti için ikinci yöntem st_mode içerisindeki dosya tür bitlerinin S_IFMT sembolik sabiti ile bit AND işlemi ile 
    elde edilip aşağıdaki sembolik sabitlerle karşılaştırılmasıdır.

    S_IFBLK         Blok aygıt dosyası
    S_IFCHR         Karakter aygıt dosyası
    S_IFIFO         Boru dosyası
    S_IFREG         Sıradan disk dosyası
    S_IFDIR         Dizin dosyası
    S_IFLNK         Sembolik bağlantı dosyası
    S_IFSOCK        Soket dosyası

    st_mode değeri S_IFMT değeri ile bir AND işlemine sokulduktan sonra bu sembolik sabitlerle karşılaştırılmalıdır. Bu sembolik sabitlerin 
    tek biti 1 değildir. Yani karşılaştırma (mode & S_IFMT) == S_IFXXX biçiminde yapılmalıdır.

    Yapının st_nlink elemanı dosyanın "hard link" sayısını belirtmektedir. Hard link kavramı ileride ele alınacaktır. nlink_t türü
    bir tamsayı türü olmak koşuluyla herhangi bir tür olarak typedef edilebilmektedir.

    Yapının st_uid elemanı dosyanın kullanıcı id'sini belirtmektedir. Tabii ls -l komutu bu id'yi sayı olarak değil /etc/passwd dosyasına başvurarak
    isim biçiminde yazdırmaktadır. uid_t türü herhangi bir tamsayı türü olarak typedef edilebilmektedir.

    Yapının st_gid elemanı dosyanın grup id'sini belirtmektedir. Tabii ls -l komutu bu id'yi sayı olarak değil /etc/group dosyasına başvurarak
    isim biçiminde yazdırmaktadır. ugid_t türü herhangi bir tamsayı türü olarak typedef edilebilmektedir.

    Yapının st_rdev elemanı eğer dosya bir aygıt dosyası ise temsil ettiği aygıtın numarasını bize vermektedir. Bu eleman da dev_t türündedir.

    Yapının st_size elemanı dosyanın uzunluğunu bize vermektedir. off_t türü daha önceden de belirttiğimiz gibi işaretli bir tamsayı 
    türü biçiminde typedef edilmek zorundadır.

    Yapının st_blksize elemanı dosyanın içinde bulunduğu dosya sisteminin kullandığı blok uzunluğunu belirtmektedir. Dosyaların parçaları 
    diskte "block" denilen ardışıl byte topluluklarında tutulmaktadır. İşte bir bloğun kaç byte olduğu bilgisi bu elemanla belirtilmektedir. 
    Aynı zamanda programcılar dosya kopyalama gibi işlemlerde bu büyüklüğü tampon büyüklüğü (buffer size) olarak da kullanmaktadır.
    blksize_t işaretli bir tamsayı türü olarak typedef edilmek zorundadır.

    Yapının st_blocks elemanı dosyanın diskte kapladığı blok sayısını belirtmektedir. (Ancak buradaki sayı 512 byte'lık blokların sayısıdır. 
    Yani dosya sistemindeki dosyanın parçaları olan bloklara ilişkin sayı değildir.) blkcnt_t işaretli bir tamsayı türü olarak typedef 
    edilmek zorundadır.

    UNIX/Linux sistemlerinde kullanılan i-node tabanlı dosya sistemleri bir dosya için üç zaman bilgisi tutmaktadır:

    1) Dosyanın son değiştirilme zamanı
    2) Dosyanın son okunma zamanı
    3) Dosyanın i-node bilgilerinin son değiştirilme zamanı

    POSIX standartları hangi POSIX fonksiyonlarının hangi zamanları dosya için güncellediğini belirtmektedir. Örneğin read fonksiyonu
    dosyanın son okuma zamanını, write fonksiyonu son yazma ve i-node bilgilerinin değiştirilme zamanını güncellemektedir.

    stat yapısının bu zamanı tutan elemanları eski POSIX standartlarında time_t türündendi ve isimleri st_atime, st_mtime ve st_ctime
    biçimindeydi. Bu elemanlar epoch olan 01/01/1970'ten geçen saniye sayısını tutuyordu (C Programlama Dili'nde epoch'un 01/01/1970 olması 
    zorunlu değildir. Ancak POSIX standartlarında bu zorunludur.) Ancak daha sonra POSIX standartlarında bu zaman bilgisini nanosaniye çözünürlüğe
    çektiler. Dolayısıyla zamansal bilgiler time_t türü ile değil timespec bir yapıyla belirtilmeye başlandı. Yapı elemanlarının isimleri de 
    st_atime, st_mtim ve st_ctim olarak değiştirildi. timespec yapısı geçmişe doğru uyumu koruyabilmek için aşağıdaki gibi bildirilmiştir:

    struct timespec {
        time_t  tv_sec;
        long    tv_nsec;
    };

    Yapının tv_sec elemanı yine 01/01/1970'ten geçen saniye sayısını tv_nsec elemanı ise o saniyeden sonraki nanosaniye sayısını tutmaktadır. 
    Sistemlerin çoğu POSIX standartlarında bu konuda değişiklik yapılmış olsa da eski doğru uyumu şöyle korumuştur:

    struct stat {
        ...
        struct timespec st_atim;    /* Time of last access */
        struct timespec st_mtim;    /* Time of last modification */
        struct timespec st_ctim;    /* Time of last status change */

    #define st_atime st_atim.tv_sec        /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
    };

    Bu durumda programcı sisteminin yeni POSIX standartlarını destekleyip desteklemediğine bakmalı ve duruma göre yapının eski ya da yeni 
    elemanlarını kullanmalıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                13. Ders 04/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda dosya bilgilerini stat fonksiyonu ile alıp yazdıran bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

void exit_sys(const char *msg);
void disp_mode(mode_t mode);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (stat(argv[i], &finfo) == -1)
            exit_sys("stat");

        printf("i-node no: %llu\n", (unsigned long long)finfo.st_ino);
        printf("file mode: ");
        disp_mode(finfo.st_mode);
        printf("number of hard links: %llu\n", (unsigned long long)finfo.st_nlink);
        printf("user id: %llu\n", (unsigned long long)finfo.st_uid);
        printf("group id: %llu\n", (unsigned long long)finfo.st_gid);
        printf("file size: %lld\n", (long long)finfo.st_size);
        printf("file block size: %lld\n", (long long)finfo.st_blksize);
        printf("number of blocks: %lld\n", (long long)finfo.st_blocks);

        pt = localtime(&finfo.st_mtim.tv_sec);
        printf("last modification: %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);
        pt = localtime(&finfo.st_atim.tv_sec);
        printf("last access (read): %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);
        pt = localtime(&finfo.st_ctim.tv_sec);
        printf("last i-node changed: %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);

        if (argc > 2)
            printf("-----------------\n");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void disp_mode(mode_t mode)
{
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};

    for (int i = 0; i < 7; ++i)
        if ((mode & S_IFMT) == ftypes[i]) {
            putchar("bcp-dls"[i]);
            break;
        }
    /*

    alternatifi

    if (S_ISBLK(mode))
        putchar('b');
    else if (S_ISCHR(mode))
        putchar('c');
    else if (S_ISDIR(mode))
        putchar('d');
    else if (S_ISFIFO(mode))
        putchar('p');
    else if (S_ISREG(mode))
        putchar('-')
    else if (S_ISLNK(mode))
        putchar('l');
    else if (S_ISSOCK(mode))
        putchar('s');
    else
        putchar('?');

    */

    for (int i = 0; i < 9; ++i)
        putchar(mode & modes[i] ? "rwx"[i % 3] : '-');
    putchar('\n');
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte get_ls isimli fonksiyon bizden stat yapısını ve dosyanın ismini alarak char türden static bir dizinin içerisine
    dosya bilgilerini ls -l formatında kodlamaktadır. Ancak biz henüz kullanıcı id'sini ve grup id'sini /etc/passwd ve /etc/group
    dosyalarına başvurarak isimlere dönüştürmedik. Bu nedenle bu örnekte dosyaların kullanıcı ve grup id'leri yazı olarak değil
    sayı olarak kodlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (stat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
    fstat fonksiyonu stat fonksiyonunun yol ifadesi değil dosya betimleyicisi alan biçimidir. Prototipi şöyledir:

    int fstat(int fd, struct stat *buf);

    Genel olarak işletim sisteminin dosya betimleyicisinden hareketle i-node bilgilerine erişmesi yol ifadesinden hareketle 
    erişmesinden daha hızlı olmaktadır. Çünkü open fonksiyonunda zaten open dosyanın i-node bilgilerine erişip onu dosya nesnesinin
    içerisine almaktadır. Tabii önce dosyayı açıp sonra fstat uygulamak anlamsız bir yöntemdir. Ancak zaten biz bir dosyayı 
    başka amaçla açmışsak onun bilgilerini fstat ile daha hızlı elde edebiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    int fd;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    /* burada dosyayla ilgili birtakım işlemler yapılıyor */

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    printf("%s\n", get_ls(&finfo, "sample.c"));

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı işaret eden özel dosyalara "sembolik bağlantı dosyaları (symbolic link files)" denilmektedir. Sembolik bağlantı dosyaları 
    aynı zamanda "soft link" dosyalar biçiminde de isimlendirilmektedir. Sembolik bağlantı dosyaları bir dosyayı işaret eden dosyalardır. 
    Bunlar gerçek anlamda birer dosya değildir. Adeta bir "pointer" dosyadır. İşletim sistemleri sembolik bağlantı dosyaları için diskte 
    yalnızca bir i-node elemanı tutmaktadır. Sembolik bağlantı dosyaları komut satırında ln -s komutuyla yaratılabilirler. Örneğin:

    $ ln -s x.dat y.dat

    Burada "x.dat" dosyasının "y.dat" isimli bir sembolik bağlantı dosyası oluşturulmuştur. ls -l komutunda sembolik bağlantı dosyaları ok işaretiyle 
    gösterilmektedir. Örneğin:

    $ ls -l x.dat y.dat

    -rwxr-xr-x 1 kaan study 0 Kas 27 13:07 x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:11 y.dat -> x.dat

    Sembolik bağlantı dosyaları "l" dosya türü ile gösterilmektedir. Bir sembolik bağlantı dosyası başka bir sembolik bağlantı dosyasını gösterebilir. 
    Örneğin:

    $ ls -l x.dat y.dat z.dat
    -rwxr-xr-x 1 kaan study 0 Kas 27 13:07 x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:11 y.dat -> x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:48 z.dat -> y.dat

    Sembolik bağlantı dosyaları yaratıldığında erişim hakları otomatik olarak "lrwxrwxrwx" biçiminde oluşturulmaktadır. Sembolik bağlantı dosyalarının 
    kendi erişim haklarının bir önemi yoktur. Bu dosyaların kendi erişim hakları sistem tarafından herhangi bir biçimde kullanılmamaktadır.

    open gibi POSIX fonksiyonlarının pek çoğu sembolik bağlantı dosyalarında bağlantıyı izlemektedir. Yani örneğin biz open fonksiyonu 
    ile bir sembolik bağlantı dosyasını açmaya çalışsak open fonksiyonu o dosyayı değil o dosyanın gösterdiği dosyayı açmaya çalışır. 
    Yukarıdaki örnekte biz "z.dat" dosyasını açmak istesek aslında "x.dat" dosyası açılacaktır. Bu durum ileride ele alacağımız POSIX fonksiyonlarının
    hemen hepsinde böyledir. Ancak lstat fonksiyonu istisnalardan biridir.

    Bir dosya fonksiyonuna yol ifadesi olarak sembolik bağlantı dosyası verildiğinde fonksiyon (lstat dışındaki fonksiyonlar) sembolik bağlantıyı 
    izlemektedir. Ancak bu izleme sırasında bir döngü oluşabilir. Örneğin a sembolik bağlantı dosyası b sembolik bağlantı dosyasını, 
    b sembolik bağlantı dosyası da c sembolik bağlantı dosyasını gösteriyor olabilir. c sembolik bağlantı dosyası da yeniden a sembolik bağlantı 
    dosyasını gösteriyor olabilir. Böyle bir işlemde sonsuz döngü söz konusu olmaktadır. İşte dosya fonksiyonları bu durumu da dikkate alır ve böylesi bir
    döngüsellik varsa başarısızlıkla geri döner. Bu başarısızlık durumunda errno değeri ELOOP biçiminde set edilmektedir. Aslında POSIX sistemlerinde işletim
    sistemi tarafından belirlenmiş maksimum link izleme sayısı vardır. Bu sayı aşıldığında ilgili fonksiyon başarısız olup errno değişkeni ELOOP değeri 
    ile set edilmektedir. (POSIX standartlarında maksimum link izleme değeri <sys/limits.h> içerisinde SYMLOOP_MAX sembolik sabitiyle belirtilmektedir. 
    Ancak bu sembolik sabit define edilmiş olmak zorunda değildir. Ayrıca POSIX sistemlerinde olabilecek en düşük sembolik link izleme sayısı da _POSIX_SYMLOOP_MAX (8)
    değeri ile belirlenmiştir.) Yani aslında sembolik bağlantıların döngüye genellikle girmesi maksimum sayacın aşılması ile anlaşılmaktadır.

    Bir sembolik bağlantı dosyasının gösterdiği dosya silinirse burada tuhaf bir durum oluşur. İşte bu tür durumlarda bu sembolik bağlantı dosyası 
    kullanıldığında (örneğin open fonksiyonuyla açılmaya çalışıldığında) sanki dosya yokmuş gibi bir hata oluşur (ENOENT). Çünkü bağlantının işaret ettiği 
    bir dosya bulunmamaktadır. Windows sistemlerinde sembolik bağlantı dosyalarının bir benzerleri "kısayol (shortcut)" dosyalar biçiminde karşımıza çıkmaktadır.

    lstat fonksiyonu ile stat fonksiyonu arasındaki tek fark eğer stat bilgisi elde edilecek dosya bir sembolik bağlantı dosyası ise 
    stat fonksiyonun bu bağlantının gösterdiği dosyanın bilgisini alması ancak lstat fonksiyonun sembolik bağlantı dosyasının kendi bilgisini almasıdır. 
    Diğer dosyalar için bu fonksiyon arasında bir farklılık yoktur. Örneğin:

    $ ls -l sample.c x
    -rw-rw-r-- 1 parallels parallels 1748 Dec  4 13:46 sample.c
    lrwxrwxrwx 1 parallels parallels    8 Dec  4 13:47 x -> sample.c

    Burada "x" bir sembolik bağlantı dosyasıdır ve bu dosya "sample.c" dosyasını göstermektedir. İşte biz "x" dosyasının stat bilgilerini 
    stat fonksiyonu ile almaya çalışırsak stat bize aslında "sample.c" dosyasının bilgilerini verir. Ancak biz "x" dosyasının stat bilgilerini
    lstat fonksiyonu ile alırsak lstat bize "x" dosyasının kendi bilgisini verir.

    Aşağıdaki örnekte sembolik bağlantı dosyasının lstat ve stat fonksiyonlarıyla stat bilgileri alınmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (lstat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın stat bilgilerini görüntülemek için stat isimli kabuk komutu da bulundurulmuştur. Tabii bu komut aslında 
    stat ve lstat POSIX fonksiyonlarını çağırarak elde ettikleri bilgileri yazdırmaktadır. Örneğin:

    $ stat sample.c
    File: sample.c
    Size: 329           Blocks: 8          IO Block: 4096   normal dosya
    Device: 805h/2053d    Inode: 1207667     Links: 2
    Access: (0644/-rw-r--r--)  Uid: ( 1000/    kaan)   Gid: ( 1001/   study)
    Access: 2022-12-10 10:59:52.700330245 +0300
    Modify: 2022-12-10 10:59:46.620211508 +0300
    Change: 2022-12-10 11:41:11.151049064 +0300
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                14. Ders 10/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı silmek için remove ve unlink isimli fonksiyonlar kullanılmaktadır. remove bir standart C fonksiyonudur. unlink ise 
    bir POSIX fonksiyonudur. Bu iki fonksiyon tamamen aynı şeyi yapmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <stdio.h>

    int remove(const char *path);

    #include <unistd.h>

    int unlink(const char *path);

    Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    remove ve unlink fonksiyonlarıyla bir dosyayı silebilmek için prosesin dosyanın kendisine "w" hakkının olması gerekmez. 
    Ancak dosyanın içinde bulunduğu dizine "w" hakkının olması gerekir. Bizim eğer dosyanın içinde bulunduğu dizine "w" 
    hakkımız varsa dosyanın sahibi olmasak bile dosyayı silebiliriz. Tabii proses id'si 0 olan prosesler herhangi bir kontrol 
    uygulamadan bu silme işlemini yapabilirler.

    Bir dosya unlink ya da remove fonksiyonlarıyla silindiğinde dizin girişi silinir. Ancak dosyanın kendisi dosyanın hard link sayacı 
    0'a düşmüşse silinmektedir. Yani unlink ve remove fonksiyonları dosyayı dizin girişinden silerler. Sonra dosyanın hard link sayacını 1
    eksiltirler. Eğer hard link sayacı 0'a düşmüşse dosyayı fiziksel olarak silerler. HArd link sayacının ne anlama geldiği ileride 
    ele alınacaktır.

    Aşağıdaki örnekte komut satırından verilen yol ifadelerine ilişkin dosyalar silinmeye çalışılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    if (argc == 1) {
        fprintf(stderr, "file name(s) must be specified!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i)
        if (unlink(argv[i]) == -1)
            perror("unlink");

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi aslında "dizinler" birer dosya gibi organize edilmiştir. Dizin dosyalarının içerisinde 
    "dizin girişleri (directory entries)" bulunmaktadır. Bir dizin girişinin formatı dosya sisteminden dosya sistemine değişebilmektedir. 
    Ancak özet olarak bir dizin dosyasının içeriği şöyledir:

    Dizi Dosyası
    -------------
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    ...
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    dosya_ismi  i-node no

    Dosyaların asıl bilgileri (yani stat fonksiyonuyla elde ettiğimiz bilgiler) Diskte "I-Node Block" denilen bir bölgede saklanmaktadır. 
    I-Node Block i-node elemanlarından oluşur. Her i-node elemanına ilk eleman 0 olmak üzere artan sırada bir numara karşı düşürülmüştür.
    İşletim sistemi bir dosya ile ilgili işlem yaparken kesinlikle o dosyanın i-node elemanına erişmek ve oradaki bilgileri kullanmak
    zorundadır.

    Bir dosya unlink ya da remove fonksiyonlarıyla silindiğinde kesinlikle dizin girişi silinmektedir. Ancak dosyanın silinip 
    silinmeyeceği hard-link sayacına bağlıdır.

    Farklı dizin girişleri farklı isimlerle aynı i-node numaralarını işaret ediyorsa buna "hard link" denilmektedir. Örneğin:

    Dizin Dosyası
    --------------
    a.txt   12345678
    b.txt   12345678
    ...

    Burada bizim open fonksiyonuyla "a.txt" ya da "b.txt" dosyalarını açmamız arasında hiçbir farklılık yoktur. Çünkü dosyanın bütün bilgileri 
    i-node elemanının içerisindedir. İşte biz bu dosyalardan örneğin "a.txt" dosyasını silersek aslında yalnızca dizin girişini silmiş oluruz. 
    Çünkü işletim sistemi "a.txt" dosyasının işaret ettiği i-node elemanının başka bir giriş tarafından kullanıldığını gördüğü için i-node elemanını 
    ve dosyanın diskteki varlığını silmez. İşte bu durum "hard link sayacı" ile kontrol edilmektedir. Yukarıdaki örnekte dosyanın hard link sayacı 2'dir. 
    Biz bu dizin girişlerinden birini sildiğimizde hard link sayacı 1'e düşer. Diğerini de sildiğimizde hard link sayacı 0'a düşer ve dosya gerçekten silinir.

    Bir dosyanın hard link'ini oluşturmak için ln kabuk komutu kullanılmaktadır. Örneğin:

    $ ln sample.c mample.c

    $ ls -li sample.c mample.c
    1207667 -rw-r--r-- 2 kaan study 329 Ara 10 10:59 mample.c
    1207667 -rw-r--r-- 2 kaan study 329 Ara 10 10:59 sample.c

    Dosyanın hard link sayacının 2 olduğuna dikkat ediniz.

    Bir dizin yaratıldığında onun içerisinde "." ve ".." biçiminde iki dizin girişi otomatik olarak yaratılmaktadır. (UNIX/Linux 
    sistemlerinde başı "." ile başlayan dizin girişleri ls komutunda default olarak görüntülenmemektedir. Bunların görüntülenmesi için
    -a (all) seçeneğinin de kullanılması gerekir.) "." dizin girişi kendi dizin dosyasının i-node elemanını ".." dizin girişi ise 
    üst dizinin i-node elemanını göstermektedir. Bu nedenle bir dizin yaratıldığında dizin dosyasına ilişkin hard-link sayacı
    2 olur. O dizinin içerisinde yaratılan her dizin ".." girişini içereceğinden dolayı o dizinin hard link sayacını artıracaktır.

    Belli bir i-node elemanını gösteren dizin girişlerinin elde edilmesine yönelik bu sistemlerde pratik bir yol yoktur. Yapılacak 
    şey diskteki tüm dosyaları gözden geçirip i-node numaralarından onların aynı i-node elemanını gösterip göstermediğini anlamaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi dosya bilgileri disk üzerinde i-node bloktaki i-node elemanının içerisinde tutulmaktadır. 
    stat fonksiyonları erişim bilgilerini buradan almaktadır (ls komutu da stat fonksiyonları kullanılarak yazılmıştır). 
    Dosyanın erişim hakları yine anımsayacağınız gibi open fonksiyonunda dosya yaratılırken belirlenmektedir. İşte bir dosyanın erişim haklarını
    dosyanın içine dokunmadan chmod isimli POSIX fonksiyonu ile değiştirebiliriz. Fonksiyonun prototipi şöyledir:

    #include <sys/stat.h>

    int chmod(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini, ikinci parametresi erişim haklarını belirtmektedir. Fonksiyon başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri dönmektedir. Erişim hakları 2008 stnadralarına kadar S_IXXX sembolik sabitleriyle 
    oluşturulmak zorundaydı. Ancak 2008 ve sonrasında artık bu S_IXXX sembolik sabitlerinin değerleri belirlendiği için programcı doğrudan 
    octal bir sayı biçiminde bu erişim haklarını verebilir. Fakat tavsiye edilen yine S_IXXX sembolik sabitlerinin kullanılmasıdır.

    Bir dosyanın erişim haklarını chmod fonksiyonuyla değiştirebilmek için prosesin etkin kullanıcı id'sinin dosyanın kullanıcı id'si ile 
    aynı olması ya da prosesin etkin kullanıcı id'sinin 0 olması gerekmektedir. Dosyanın dördüncü 3 btilik S_ISUID, S_ISGID ve S_ISVTX 
    erişim hakları da bu fonksiyonla set edilmeye çalışılabilir. Ancak bazı sistemler S_ISUID ve S_ISGID erişim haklarını değiştirmeye izin vermeyebilmektedir.

    chmod POSIX fonksiyonu prosesin umask değerini dikkate almamaktadır. Yani fonksiyonda belirttiğimiz erişim haklarının hepsi 
    dosyaya yansıtılmaktadır.

    Aşağıdaki girilen octal digitlerle dosyaların erişim haklarını değiştiren bir örnek verilmiştir. Bu örnekte doğrudan chmod fonksiyonunda
    bitmask değerler sayısal olarak kullanılmıştır. Bu durumun eski sistemlerde sorunlu olabileceğini bir kez daha vurguluyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int check_mode(const char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int mode;

    if (argc < 3) {
        fprintf(stderr, "too few parameters!...\n");
        exit(EXIT_FAILURE);
    }

    if (!check_mode(argv[1])) {
        fprintf(stderr, "invalid mode: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    sscanf(argv[1], "%o", &mode);
    for (int i = 2; i < argc; ++i)
        if (chmod(argv[i], mode) == -1)
            fprintf(stderr, "cannot change mode: %s\n", argv[1]);

    return 0;
}

int check_mode(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte eski POSIX standartları da dikkate alınarak mode bilgisi S_IXXX sembolik sabitlerinin bit düzeyinde 
    OR'lanması ile oluşturulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int check_mode(const char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int modeval;
    mode_t modes[] = {S_ISUID, S_ISGID, S_ISVTX, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    mode_t mode;

    if (argc < 3) {
        fprintf(stderr, "too few parameters!...\n");
        exit(EXIT_FAILURE);
    }

    if (!check_mode(argv[1])) {
        fprintf(stderr, "invalid mode: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    sscanf(argv[1], "%o", &modeval);

    mode = 0;
    for (int i = 11; i >= 0; --i)
        if (modeval >> i & 1)
            mode |= modes[11 - i];

    for (int i = 2; i < argc; ++i)
        if (chmod(argv[i], mode) == -1)
            fprintf(stderr, "cannot change mode: %s\n", argv[1]);

    return 0;
}

int check_mode(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    chmod POSIX fonksiyonunun yanı sıra bir de dosya betimleyicisi ile çalışan fchmod fonksiyonu vardır. Eğer dosyayı zaten açmışsak chmod yerine
    fchmod fonksiyonu daha hızlı bir çalışma sunmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/stat.h>

    int fchmod(int fd, mode_t mode);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyanın erişim haklarını değiştirmek için chmod isimli bir kabuk komutu da bulunmaktadır. Bu kabuk komutu tabii chmod POSIX
    fonksiyonu kullanılarak yazılmıştır. Bu kabuk komutunun kullanımının birkaç biçimi vardır. Tipik olarak komutta erişim hakları 
    octal digitlerle belirtilmektedir. Örneğin:

    $ chmod 664 a.txt b.txt

    Burada 664'ün bit karşılığı şöyledir: 110 110 100. Bu erişim hakları olarak şu anlama gelmektedir: rw-rw-r--. Komutun ikinci kullanımı 
    + ve -'li kullanımıdır. Örneğin:

    $ chmod +w a.txt

    Burada "a.txt" dosyasının "owner", "group" ve "other" "w" hakkı eklemektedir. Komutta "-" ilgili hakkın çıkartılacağını belirtmektedir. 
    Bunların önüne u, g, o ya da a harfleri getirilebilir. Örneğin:

    $ chmod o+w a.txt

    Burada yalnızca "other" için "w" hakkı eklenmiştir. a hepsine anlamına gelir. Örneğin:

    $ chmod a-w a.txt

    Burada owner, group ve other için "w" hakları silinmiştir. Tabii birden fazlası kombine edilebilir. Örneğin:

    $ chmod 0 a.txt
    $ chmod ug+rw a.txt

    Komutta octal sayı belirtilirse umask etkili olmaz. Ancak octal sayı yerine ugua ve rwx belirtilirse bu durumda 
    kabuğun umask değeri etkili olmaktadır.

    Komutun başka ayrıntıları da vardır. Bunun için ilgili dokümanlara başvurabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın kullanıcı id'si ve grup id'si dosya yaratılırken belirleniyordu. Ancak programcı isterse dosyanın kullanıcı 
    id'sini ve grup id'sini chown ya da fchown isimli POSIX fonksiyonları ile değiştirebilir. Fonksiyonların prototipleri 
    şöyledir:

    #include <unistd.h>

    int chown(const char *path, uid_t owner, gid_t group);
    int fchown(int fd, uid_t owner, gid_t group);

    chown fonksiyonun birinci parametresi dosyanın yol ifadesini ikinci parametresi değiştirilecek kullanıcı id'sini ve üçüncü 
    parametresi de değiştirilecek grup id'sini belirtmektedir. fchown fonksiyonu chown fonksiyonunun dosya betimleyicisi ile 
    çalışan biçimidir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Bir dosyanın kullanıcı ve grup id'lerinin değiştirilmesi kötüye kullanıma açık bir durum oluşturabilmektedir. (Yani örneğin 
    "kaan" kullanıcısı kendi dosyasını sanki "ali" kullanıcısının dosyasıymış gibi gösterirse burada bir kötü niyet de söz konusu 
    olabilir.) Bu nedenle bu fonksiyonun kullanımı üzerinde bazı kısıtlar vardır. Şöyle ki:

    1) Eğer prosesin etkin kullanıcı id'si dosyanın kullanıcı id'si ile aynı ise bu durumda chown fonksiyonu dosyanın grup id'sini 
    kendi grup id'si olarak ya da ek gruplarının (supplementary groups) birinin id'si olarak eğiştirebilmektedir. Ancak dosyanın 
    kullanıcı id'sinin değiştirilmesi işletim sisteminin iznine bağlıdır. Modern sistemler bu izni vermemektedir. Ancak bazı eski 
    sistemler bu izni vermektedir. Bu izin "change own restricted" ismiyle ifade edilmektedir. İlgili sistemin bu izni verip 
    vermediği <unisth.h> dosyası içerisindeki _POSIX_CHOWN_RESTRICTED sembolik sabitiyle derleme aşamasında sorgulanabilir.

    2) Proses id'si 0 olan root prosesler (ya da uygun önceliğe sahip prosesler) her zaman dosyanın kullanıcı ve grup id'sini 
    istedikleri gibi değiştirebilirler. (Yani biz bir dosyanın kullanıcı ve grup id'sini istediğimiz gibi değiştirmek istiyorsak 
    programımızı "sudo" ile çalıştırmalıyız.)

    Fonksiyonlar ile yalnızca kullanıcı id'si ya da grup id'si değiştirilebilir. Bu durumda değiştirilmeyecek değer için -1 girilmelidir. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Change on restricted durumu aşağıdaki gibi #ifdef komutuyla sorgulanabilir:

    #include <stdio.h>
    #include <unistd.h>

    int main(int argc, char *argv[])
    {
    #ifdef _POSIX_CHOWN_RESTRICTED
        printf("chown restricted\n");
    #else
        printf("chown not restricted\n");
    #endif

        return 0;
    }

    Aşağıda chown fonksiyonun örnek bir kullanımını görüyorsunuz:
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (chown("test.txt", 1000, -1) == -1)
        exit_sys("chown");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                15. Ders 11/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyanın kullanıcı ve grup id'lerini değiştirebilmek için chown isimli bir kabuk komutu da bulundurulmuştur. Komut aşağıdaki biçimlerde 
    kullanılmaktadır:

    $ sudo chwon kaan:study test.txt
    $ sudo chown kaan test.txt
    $ sudo chown :study test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    truncate isimli POSIX fonksiyonu bir dosyanın boyutunu değiştirmek için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int truncate(const char *path, off_t length);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini almaktadır. İkinci parametresi dosyanın yeni uzunluğunu belirtir. 
    Bu fonksiyon genellikle dosyanın sonundaki kısmı atarak onun boyutunu küçültmek amacıyla kullanılmaktadır. Burada belirtilen 
    uzunluk dosyanın gerçek uzunluğundan küçükse dosyanın sonundaki ilgili kısım yok edilir ve dosya burada belirtilen uzunluğa 
    getirilir. (Fonksiyonun ismi tipik olarak dosyaların küçültüleceği fikriyle "trunctate" olarak verilmiştir.) Biz truncate 
    fonksiyonu ile dosyayı büyütmek de isteyebiliriz. Bu durumda dosya büyütülür ve büyütülen kısım 0'larla doldurulur. Bugünkü 
    sistemlerde dosya sistemi "dosya deliklerini (file holes)" destekliyorsa; büyütme, delik (hole) oluşturularak yapılmaktadır. 
    Fonksiyon, başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. 
    Tabii truncate yapabilmek için prosesin dosyaya yazma hakkının olması olması gerekmektedir.

    truncate fonksiyonunun yol ifadesini alarak değil, dosya betimleyicisini alarak aynı işlemi yapan ftruncate isminde bir benzeri 
    de vardır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int ftruncate(int fd, off_t length);

    Fonksiyonun birinci parametresi dosya betimleyicisini almaktadır. İkinci parametresi dosyanın yeni uzunluğunu belirtir.. Fonksiyon 
    başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. Tabii 
    ftruncate yapabilmek için dosyanın yazma modunda açılmış olması gerekmektedir.

    Fonksiyonun işlev bakımından truncate fonksiyonundan hiçbir farkı yoktur.

    Aşağıdaki örnekte daha önce var olan "test.dat" dosyası 1000 byte uzunluğa çekilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.dat", O_RDWR)) == -1)
        exit_sys("open");

    if (ftruncate(fd, 1000) == -1)
        exit_sys("open");

    printf("success...\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    truncate işlemini yapan bir kabuk komutu da bulunmaktadır. Komut -s seçeneği ile dosyanın yeni uzunluğunu almaktadır. 
    Örneğin:

    $ truncate -s 100 test.txt

    Dosya uzunluklarında uzunluğun sonuna birim belirten karakterler de eklenebilmektedir. Örneğin:

    $ truncate -s 100K test.txt

    Burada dosya 100K uzunluğuna çekilmektedir. Komutun diğer ayrıntıları için man sayfalarına başvurabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dizin (directory) yaratmak için mkdir isimli POSIX fonksiyonu kullanılmaktadır. Dizin yaratma işlemi open fonksiyonuyla 
    yapılamamaktadır. mkdir fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mkdir(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi yaratılacak dizinin yol ifadesini, ikinci parametresi ise erişim haklarını belirtmektedir. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Dizin yaratırken erişim haklarında 'x' hakkını bulundurmayı unutmayınız. Anımsanacağı gibi dizinlerde 'x' hakkı "içinden 
    geçilebilirlik" anlamına geliyordu. mkdir fonksiyonu tıpkı open fonksiyonu gibi prosesin umask değerinden etkilenmektedir. 
    O halde istediğiniz erişim haklarının hepsinin dizine yansıtılmasını istiyorsanız işin başında umask(0) çağrısıyla prosesinizin 
    umask değerini sıfırlayabilirsiniz.

    Bir dizin yaratıldığında içerisinde "." ve ".." isminde iki dizin girişi bulunmaktadır. Daha önceden de belirtildiği gibi "." dizin 
    girişi bulunulan dizinin i-node elemanını, ".." dizin girişi ise üst dizinin i-node elemanını işaret eder. Bu nedenle bir dizin 
    yaratıldığında kendi dizininin ve üst dizinin hard link sayaçları bir artırılmaktadır.

    Aşağıda komut satırından verilen isimle bir dizin yaratan örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (mkdir(argv[1], S_IRWXU|S_IRWXG|S_IRWXO) == -1)
        exit_sys("mkdir");

    printf("success...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Komut satırında dizin yaratmak için "mkdir" isminde bir kabuk komutu da bulunmaktadır. Tabii bu komut mkdir POSIX fonksiyonu 
    kullanılarak yazılmıştır. Komut default durumda umask değerinden etkilenir. Ancak -m ya da --mode seçeneği ile biz erişim 
    haklarını octal basamaklar biçiminde belirtebilmekteyiz. Örneğin:

    $ mkdir xxx
    $ mkdir -m 777 yyy

    Dizinler için de hard link çıkartılabilmektedir. Ancak bu durum dizin ağacını dolaşan kodların sonsuz döngüye girmesine 
    yol açabilmektedir. Bu nedenle dizinler için hard link çıkartmak yerine soft link (sembolik bağlantı) çıkartmak tercih 
    edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dizini silmek için unlink ya da remove fonksiyonları kullanılamaz. Dizin silmek için rmdir isimli özel bir POSIX fonksiyonu 
    bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int rmdir(const char *path);

    Fonksiyon parametre olarak silinecek dizinin yol ifadesini alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine
    geri döner.

    rmdir fonksiyonu ile içinde dosya olan dizinler silinememektedir. Bu durum güvenlik amacıyla düşünülmüştür. İçi boş dizin demek
    içinde yalnızca "." ve ".." girişlerinin bulunduğu dizin demektir. Zaten UNIX/Linux, macOS ve Windows sistemlerinde bu iki özel 
    dizin girişi silinememektedir. rmdir fonksiyonuna bir dizini işaret eden sembolik bağlantı dosyası verilirse fonksiyon bağlantıyı 
    izlemez. Başarısız olur ve errno değeri ENOTDIR biçiminde set edilir.

    rmdir fonksiyonun başarılı olabilmesi için prosesin dizine yazma hakkına sahip olması gerekmez ancak dizinin içinde bulunduğu 
    dizine yazma hakkına sahip olması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Komut satırından dizin silmek için "rmdir" isimli bir kabuk komutu da bulunmaktadır. Tabii bu komut aslıda "rmdir" POSIX 
    fonksiyonu kullanılarak yazılmıştır. rmdir komutuyla dizin silmek için yine dizinin boş olması gerekir. İçi dolu dizinleri 
    tek hamlede silmek için "rm" komutu "-r" seçeneği ile kullanılabilir. Örneğin:

    $ rm -r xxx
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi genel olarak pek çok UNIX/Linux sisteminde kullanıcılar hakkında bilgiler /etc/passwd ve /etc/group 
    dosyalarında tutuluyordu. Bu dosyalardaki satırlar ':' ile ayrılmış olan alanlardan oluşmaktaydı. Bu dosyalar ve bunların formatları 
    POSIX standartlarında belirtilmemiştir. Onun yerine POSIX standartlarında bu dosyalardan okuma yapan özel fonksiyonlar bulundurulmuştur. 
    (Yani aslında bir POSIX sisteminde /etc/passwd ve /etc/group dosyaları bu isimlerde ve Linux'tak içerikte bulunmak zorunda değildir. 
    Ancak bu bilgileri alan aşağıda açıklayacağımız POSIX fonksiyonları bulunmak zorundadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    /etc/passwd dosyası üzerinde parse işlemi yapan fonksiyonların prototipleri <pwd.h> dosyası içerisinde bulundurulmuştur. 
    getpwnam POSIX fonksiyonu bir kullanıcının ismini alarak o kullanıcı hakkında /etc/passwd dosyasında belirtilen bilgileri 
    vermektedir. Fonksiyonun prototipi şöyledir:

    #include <pwd.h>

    struct passwd *getpwnam(const char *name);

    Fonksiyon parametre olarak kullanıcı ismini almaktadır. Başarı durumunda o kullanıcıya ilişkin bilgileri barındıran statik 
    düzeyde tahsis edilmiş olan struct passwd isimli bir yapı nesnesinin adresiyle geri dönmektedir. struct passwd yapısı şöyle 
    bildirilmiştir:

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };

    Aslında bu yapının elemanları /etc/passwd dosyasındaki satır bilgilerinden oluşmaktadır. Aşağıda /etc/passwd dosyasından 
    birkaç satır verilmiştir:

    ...
    kaan:x:1000:1001:Kaan Aslan,,,:/home/kaan:/bin/bash
    student:$6$EW3bJuIgtpIfgbdm$Sy4Z4XNdxgBrNlzc7cEnEJn2gp36XCvaIUqaH9p8ZZrtfF3qQZ7KTK7qpM4T54/p5Lck24ZknXC1EuXm2hnBm1:1001:1001:Student,,,:/home/student:/bin/ulak-shell
    ali:x:1001:1001::/home/ali:/bin/myshell
    veli:x:1002:1002::/home/veli:/bin/bash
    ...

    Yapının pw_nam elemanı kullanıcı ismini, pw_passwd elemanı parola bilgisini, pw_uid ve pw_gid elemanları login olunduğunda 
    çalıştırılacak programa ilişkin prosesin gerçek ve etkin kullanıcı ve group id değerlerini pw_gecos yorum bilgisini (kullanıcıya 
    ilişkin ek birtakım bilgileri, pw_dir login olunduğunda çalıştırılacak programa ilişkin prosesin çalışma dizinini ve pw_shell 
    elemanı da login olunduğunda çalıştırılacak programı belirtmektedir.)

    getpwnam fonksiyonu iki nedenden dolayı başarısız olabilir. Birincisi belirtilen isme ilişkin bir kullanıcının /etc/passwd 
    dosyası içerisinde bulunamamasıdır. İkincisi ise daha patolojik durumlardır. Yani bir IO hatası, /etc/passwd dosyasının 
    silinmiş olması gibi. Programcının Eğer fonksiyon isme ilişkin bir kayıt bulamadıysa errno değerini değiştirmemektedir. 
    Ancak diğer hatalı durumlarda errno değerini uygun biçimde set etmektedir. Dolayısıyla programcı bu tür durumlarda fonksiyonu
     çağırmadan önce errno değerini 0'a çeker. Sonra fonksiyon başarısız olduğunda errno değerine bakar. Eğer bu değer hala 0 
     ise fonksiyonun ilgili kullanıcı ismini bulamadığından dolayı başarısız olduğu anlaşılır.

    Aşağıdaki örnekte komut satırından ismi alınan kullanıcının /etc/passwd dosyasındaki bilgileri ekrana (stdout dosyasına) 
    yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct passwd *pass;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    errno = 0;
    if ((pass = getpwnam(argv[1])) == NULL) {
        if (errno == 0) {
            fprintf(stderr, "user name cannot found!...\n");
            exit(EXIT_FAILURE);
        }
        exit_sys("getpwnam");
    }

    printf("User Name: %s\n", pass->pw_name);
    printf("Password: %s\n", pass->pw_passwd);
    printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
    printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
    printf("Gecos: %s\n", pass->pw_gecos);
    printf("Current Working Directory: %s\n", pass->pw_dir);
    printf("Login Program: %s\n", pass->pw_shell);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    getpwuid fonksiyonu da getpwnam fonksiyonu gibidir. Yalnızca kullanıcı ismi ile değil kullanıcı id'si ile kullanıcı bilgilerini 
    elde etmektedir. Fonksiyonun prototipi şöyledir:

    #include <pwd.h>

    struct passwd *getpwuid(uid_t uid);

    Fonksiyon yine başarı durumunda statik düzeyde tahsis edilmiş olan struct passwd türünden yapı nesnesinin adresiyle, başarısızlık 
    durumunda NULL adresle geri dönmektedir. Başarısızlığın nedeni kullanıcı id'sine ilişkin kullanıcının bulunamaması nedeni ile ise 
    bu durumda fonksiyon errno değerini değiştirmemektedir.

    Aşağıdaki örnekte komut satırından verilen kullanıcı id'sine ilişkin kullanıcı bilgileri ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct passwd *pass;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    errno = 0;
    if ((pass = getpwuid(atoi(argv[1]))) == NULL) {
        if (errno == 0) {
            fprintf(stderr, "user name cannot found!...\n");
            exit(EXIT_FAILURE);
        }
        exit_sys("getpwnam");
    }

    printf("User Name: %s\n", pass->pw_name);
    printf("Password: %s\n", pass->pw_passwd);
    printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
    printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
    printf("Gecos: %s\n", pass->pw_gecos);
    printf("Current Working Directory: %s\n", pass->pw_dir);
    printf("Login Program: %s\n", pass->pw_shell);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bazen programcı /etc/passwd dosyasındaki tüm kayıtları elde etmek isteyebilir. Bunun için getpwent, endpwent ve setpwend POSIX
    fonksiyonları bulundurulmuştur. Fonksiyonların prototipleri şöyledir:

    #include <pwd.h>

    struct passwd *getpwent(void);
    void setpwent(void);
    void endpwent(void);

    getpwent fonksiyonu her çağrıldığında sıraki bir kullanıcının bilgisini verir. Fonksiyon /etc/passwd dosyasının sonuna gelindiğinde 
    (yani artık bilgisi verilecek kullanıcı kalmadığında) NULL adrese geri döner. Tabii getpwent IO hatası nedeniyle de başarısız olabilir. 
    Bu durumda errno değerini değiştirmez. Programcı bu sayede başarısızlığın nedenini anlayabilir. İşlem bitince endpwent fonksiyonu 
    son kez çağrılmalıdır. (Bu fonksiyon arka planda muhtemelen /etc/passwd dosyasını kapatmaktadır.) Eğer dolaşım yeniden yapılacaksa
    setpwent fonksiyonu çağrılır. İlk dolaşımda setpwent fonksiyonun çağrılması gerekmemektedir.

    Aşağıdaki programda tüm kullanıcı bilgileri bir döngü içerisinde elde edilip ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(void)
{
    struct passwd *pass;

    while ((errno = 0, pass = getpwent()) != NULL) {
        printf("User Name: %s\n", pass->pw_name);
        printf("Password: %s\n", pass->pw_passwd);
        printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
        printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
        printf("Gecos: %s\n", pass->pw_gecos);
        printf("Current Working Directory: %s\n", pass->pw_dir);
        printf("Login Program: %s\n", pass->pw_shell);
        printf("-----------------------------------------------------------\n");
    }

    if (errno != 0)
        exit_sys("getpwent");

    endpwent();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi pek çok UNIX türevi sistemde grup bilgileri /etc/group isimli bir dosyada tutulmaktadır. (POSIX standartları 
    grup bilgilerinin böyle bir dosyada tutulacağına yönelik bir bilgi içermemektedir.) İşte grup bilgilerinin bu dosyadan alınması 
    için de benzer bir mekanizma oluşturulmuştur. Aşağıda grup /etc/group dosyasından birkaç satır görüyorsunuz:

    ...
    nm-openvpn:x:133:
    kaan:x:1000:
    sambashare:x:134:kaan
    study:x:1001
    test:x:1002
    ...

    Grup bilgilerini elde etmek için kullanılan POSIX fonksiyonları da şöyledir:

    #include <grp.h>

    struct group *getgrnam(const char *name);
    struct group *getgrgid(gid_t gid);
    struct group *getgrent(void);
    void setgrent(void);
    void endgrent(void);

    Bu fonksiyonlardaki struct group yapısı <grp.h> dosyası içerisinde şöyle bildirilmiştir:

    struct group {
        char   *gr_name;        /* group name */
        char   *gr_passwd;        /* group password */
        gid_t   gr_gid;            /* group ID */
        char  **gr_mem;            /* NULL-terminated array of pointers to names of group members */
    };

    Yapının gr_name elemanı grubun ismini belirtmektedir. gr_passwd elemanı grubun parola bilgisini belirtir. Gruplarda da parola 
    kavramı vardır. Ancak seyrek kullanılmaktadır. gr_gid elemanı grubun numarasını belirtir. Anımsanacağı gibi bir kullanıcı 
    birden fazla gruba üye olabilmektedir. Kullanıcının asıl grubu /etc/passwd dosyasında belirtilen grup id'ye ilişkin gruptur. 
    Örneğin /etc/group dosyasında aşağıdaki gibi bir satır bulunuyor olsun:

    study:x:1001:ali,veli,selami

    Burada grup bilgilerinin sonundaki ali, vel, selami bu study grubuna ek grup olarak dahil edilen kullanıcıları belirtmektedir. 
    Örneğin kaan kullanıcısının asıl grubu project olabilir. Ancak kaan kullanıcısı aynı zamanda "ek grup (supplementary group)" olarak 
    study grubuna da dahil olabilir. Yani sistemin bir kullanıcının ek gruplarını elde edebilmesi için /etc/group dosyasını baştan sona gözden geçirip
    kullanıcının hangi satırların ':' ayrılmış son bölümünde geçtiğini belirlemesi gerekmektedir. İşte group yapısının gr_mem 
    elemanı bir göstericiyi gösteren göstericidir ve bu gruba ait olan kullanıcıları belirtmektedir. Tabii bu gr_mem ile belirtilmiş olan 
    gösterici dizisinin son elemanı NULL adres içermektedir.

    getgrnam fonksiyonu grubun isminden hareketle grup bilgilerini, getgrgid fonksiyonu ise grup id'sinden hareketle grup bilgilerini vermektedir. 
    Tıpkı kullanıcı bilgilerinde olduğu gibi grup bilgilerinin de tek tek elde edilmesi benzer biçimde get_grent, endgrent ve setgrent 
    fonksiyonlarıyla yapılmaktadır.

    Aşağıdaki örnekte tüm gruplara ilişkin grup bilgileri ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    struct group *grp;

    while ((errno = 0, grp = getgrent()) != NULL) {
        printf("Group name: %s\n", grp->gr_name);
        printf("Password: %s\n", grp->gr_passwd);
        printf("Group id: %llu\n", (unsigned long long)grp->gr_gid);
        printf("Supplemenray userf of this group: ");
        for (int i = 0; grp->gr_mem[i] != NULL; ++i) {
            if (i != 0)
                printf(", ");
            printf("%s", grp->gr_mem[i]);
        }
        printf("\n-----------------------------------------------------\n");
    }

    if (errno != 0)
        exit_sys("getgrent");

    endgrent();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                16. Ders 17/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önce ls -l komutu formatında dosya bilgilerini yazdıran bir örnek yapmıştık. Ancak o örnekte kullanıcı ve grup isimleri 
    isim olarak değil kullanıcı ve grup id'leri olarak ekrana (stdout dosyasına) yazdırılmıştı. Şimdi artık getpwuid ve getgrgid
    fonksiyonları ile bu sayısal id değerlerinden kullanıcı ve grup isimlerini elde edebiliriz.

    Aşağıda ls -l komutunun düzeltilmiş hali verilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (lstat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi dizinler (directories) de aslında tamamen dosyalar gibi organize ediliyordu. Dizinlerin içerisinde aşağıdaki 
    gibi dizin girişleri bulunuyordu:

    isim    i-node_no
    isim    i-node_no
    isim    i-node_no
    ...

    Dizin dosyalarının gerçek formatları biraz daha detay içerebilmektedir. Kursumuzun sonlarında doğru Ext-2 dosya sisteminin disk organizasyonu
    üzerinde duracağız.

    Bir dizini erişim hakları yeterliyse open fonksiyonuyla açabiliriz. Ancak POSIX standartlarında dizin dosyalarından okuma, 
    yazma ve konumlandırma işlemlerinin yapılıp yapılamayacağı işletim sistemini yazanların isteğine bırakılmıştır. Linux, BSD, 
    macOS gibi sistemler dizin dosyalarından read ve write fonksiyonları ile okuma ve yazma yapmaya izin vermemektedir. Ancak bu 
    sistemler lseek fonksiyonuyla dizin dosyalarının dosya göstericilerinin konumlandırılmasına izin vermektedir. Pekiyi mademki 
    işletim sistemleri dizin dosyalarından okuma yazma yapmaya izin vermeyebiliyorlar, bu durumda open fonksiyonuyla dizin dosyalarını 
    hangi modda açabiliriz? İşte bunun POSIX standartlarında O_SEARCH isimli bir mod bulunmaktadır. Bu mod aslında ileride ele 
    alacağımız at'li POSIX fonksiyonları için düşünülmüştür. Eğer O_SEARCH modunda bir dizin açılırsa bu dizinden okuma yazma 
    yapılamaz ancak bu at'li fonksiyonlar kullanılabilir. Ancak O_SEARCH modu Linux tarafından desteklenmemektedir. Bu durumda 
    mecburen Linux'ta bir dizini açacaksak işletim sistemi read fonksiyonu ile okuma yapılmasına izin vermiyor olsa da biz açış 
    modu olarak O_RDONLY kullanırız.

    Pekiyi bir dizini O_SEARCH modunda açmak ile O_RDONLY modunda açmak arasında ne fark vardır? O_SEARCH modu POSIX standartlarına 
    bir dizin üzerinde "read", "write" yapmamak ancak başka işlemlerde kullanılmak amacıyla kullanılmak için eklenmiştir. Dolayısıyla 
    bir işletim sistemi örneğin dizin dosyalarından read fonksiyonu ile okuma yapmaya izin veriyorsa bu durumda biz o dizini O_SEARCH 
    modunda açarsak okuma yapamayız. Ancak O_RDONLY modunda açarsak okuma yapabiliriz. Linux ve macOS O_SEARCH modunu desteklememektedir. 
    Ancak BSD türevi sistemler bu modu desteklemektedir.

    Aşağıdaki Linux sistemlerinde bir dizin'inin open fonksiyonuyla açılmasına örnek verdik. Linux açış modu olarak O_SREACH modunu 
    desteklemediği için O_RDONLY modunu kullandık. İşletim sistemleri genel olarak dizinlerin write modda açılmasına izin vermemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open(".", O_RDONLY)) == -1)
        exit_sys("open");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki işletim sistemlerinin çoğu bir dizin üzerinde read ve write fonksiyonları ile işlem yapmaya izin vermiyorsa 
    bu durumda bir dizini open fonksiyonu ile açmanın ne anlamı vardır? İşte anımsanacağı gibi yol ifadesi alan POSIX dosya 
    fonksiyonlarının başı f ile başlayan dosya betimleyicisi alan biçimleri de vardı. Örneğin stat ve lstat fonksiyonları yol 
    ifadesi alırken fstat fonksiyonu dosya betimleyicisi alıyordu. Benzer biçimde chmod için fchmod, chown için fchown fonksiyonları 
    bulunmaktaydı. İşte bu fonksiyonların bir de at'li versiyonları vardır. Örneğin fstatat, fchmodat, fchownat gibi. Ayrıca 
    başı f ile başlamayan çeşitli dosya fonksiyonlarının da at'li versiyonları bulunmaktadır. Örneğin open fonksiyonun da bir 
    at'li versiyonu vardır. Aslında bu at'li fonksiyonlar seyrek kullanılan fonksiyonlardır. Ancak biz kursumuzda bunlar 
    hakkında açıklama yapmayı da uygun görüyoruz. Pekiyi bu at'li fonksiyonlar ne yapmaktadır? Aşağıda openat fonksiyonunun 
    prototipini görüyorsunuz:

    #include <fcntl.h>

    int openat(int fd, const char *path, int oflag, ...);

    Fonksiyonun prototipini open fonksiyonu ile karşılaştırınız:

    int open(const char *path, int oflag, ...);

    Fonksiyonların at'li versiyonları yol ifadesinin yanı sıra bir dosya betimleyicisi de almaktadır. Bu dosya betimleyicisinin 
    bir dizine ilişkin olması gerekir. Eğer bu dosya betimleyicisi bir dizine ilişkin değilse fonksiyon başarısız olur. at'li 
    versiyonlara bir dizine ilişkin dosya betimleyicisinin yanı sıra bir yol ifadesi de verilmekteir. Buradaki yol ifadesi 
    eğer mutlak (absolute) ise bu at'li versiyonların at'siz versiyonlardan (flag parametreleri dışında) hiçbir farkı kalmaz. 
    Dolayısıyla bu durumda kulanım geçerli olsa da bu at'li versiyonları kullanmanın anlamı kalmamaktadır. (Bazı at'li versiyonlar 
    flag parametresine de sahiptir. Bu parametrenin işlevinden faydalanmak için de at'li fonksiyonlar kullanılabilmektedir.) 
    Yani bu duruma fonksiyon bu dizin betimleyicisinden faydalanmamaktadır. Ancak yol ifadesi göreli (relative) ise bu durumda 
    dosya prosesin çalışma dizininden itibaren değil dizin betimleyicisinin belirttiği dizinden itibaren orijin belirtmektedir. 
    Yani biz at'li versiyonlarla göreli yol ifadelerinin orijinlerini prosesin çalışma dizinin dışında başka bir dizine kaydırabilmekteyiz. 
    Tabii fonksiyonların at'li versiyonları kullanılacaksa bu durumda dizin dosyalarının O_SEARCH modunda açılması daha uygundur. 
    Çünkü bu at'li versiyonlar için dizin dosyalarının okuma modunda açılması gerekmemektedir. Zaten POSIX'te O_SEARCH modu 
    bu at'li fonksiyonlar için bulundurulmuştur. Linux ve macOS sistemleri O_SEARCH modunu desteklemediğine göre bu sistemlerde 
    at'li fonksiyonları kullanırken dizin'leri O_RDONLY modda açmamız gerekir. POSIX standartlarına göre at'li fonksiyonlarda 
    eğer dizin O_SEARCH modunda açılmışsa göreli aramda belirtilen dizinin "x" hakkına sahiplik kontrolü yapılmaz. (Dizin 
    O_SEARCH modunda açılırken zaten "x hakkı kontrolü yapılmaktadır.) Eğer dizin O_SEARCH yerine diğer modlarla (örneğin 
    O_RDONLY) açılmışsa bu durumda belirtilen dizinde "x" hakkı kontrolü yapılmaktadır. Ayrıca fonksiyonların at'li versiyonlarında 
    dizine ilişkin dosya betimleyicisine özel olarak AT_FDCWD değeri geçirilirse bu durumda sanki prosesin çalışma dizinine 
    ilişkin dizin betimleyicisi geçirilmiş gibi bir etki oluşmaktadır. Tabii bu durumda fonksiyonun at'li versiyonu ile at'siz 
    versiyonu arasında bir fark kalmamaktadır. Ancak fonksiyonların at'li versiyonlarının ekstra parametreleri de olabilmektedir 
    (genellikle bu ekstra parametre flag parametresi biçimindedir). İşte programcı bu ekstra parametrelerden faydalanabilmek 
    için dosya betimleyici parametresini AT_FDCWD biçiminde geçebilmektedir. Ayrıca fonksiyonların at'li versiyonlarında biz 
    yol ifadesi olarak mutlak ifadesi geçtiğimizde fonksiyonun dizin betimleyici parametresi zaten hiç kontrol edilmemektedir 
    (yani bu parametre geçersiz bir betimleyici belirtse bile eğer yol ifadesi mutlak ise fonksiyon için bir sorun oluşturmamaktadır.)

    Diğer at'li bazı fonksiyonların prototipleri de şöyledir:

    int fchmodat(int fd, const char *path, mode_t mode, int flag);
    int fchownat(int fd, const char *path, uid_t owner, gid_t group, int flag);
    int fstatat(int fd, const char *restrict path, struct stat *restrict buf, int flag);

    Aşağıda openat fonksiyonunun kullanımına bir örnek verilmiştir. Burada çalışma dizininde "test.txt" dosyası bulunduğu 
    halde fonksiyon başarısız olacaktır. Çünkü yol ifadesi fd ile belirtilen dizinden göreli biçimde çzöülecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fddir, fd;

    if ((fddir = open("/usr/include", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd = openat(fddir, "test.txt", O_RDONLY)) == -1)
        exit_sys("openat");

    printf("Ok\n");

    close(fd);
    close(fddir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dizin dosyası içerisindeki "dizin girişlerini (directory entry)" elde etmek için bir grup POSIX fonksiyonu bulundurulmuştur. 
    (Dizin dosyalarının open ya da openat ile fonksiyonu ile açılabildiğine ancak pek çok sistemde read fonksiyonu ile okunamadığına 
    dikkat ediniz. Ayrıca dizin dosyalarının iç formatı dosya sisteminden dosya sistemine değişebilmektedir. Bu nedenle POSIX 
    standartlarında bu işi yapan ayrı fonksiyonlar bulundurulmuştur.)

    Linux sistemlerinde dizin girişlerinin okunması için getdents isimli bir sistem fonksiyonu bulundurulmuştur. Dolayısıyla 
    aşağıda açıklayacağımız POSIX fonksiyonları arka planda Linux sistemlerinde getdents sistem fonksiyonunu çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dizin girişlerini elde etmek için önce dizin'in opendir fonksiyonuyla açılması gerekmektedir. Bunun için dizine okuma hakkının 
    bulunuyor olması gerekmektedir. opendir fonksiyonunun prototipi şöyledir:

    #include <dirent.h>

    DIR *opendir(const char *dirname);

    Fonksiyon parametre olarak açılacak dizin'in yol ifadesini almaktadır. Fonksiyonun geri dönüş değeri DIR isimli bir yapı 
    türünden (DIR bir typedef ismidir) bir adrestir. Bu DIR adresi bir handle gibi kullanılmaktadır. Fonksiyon başarısızlık 
    durumunda NULL adrese geri döner ve errno uygun biçimde değer alır. opendir fonksiyonun fdopendir isimli bir versiyonu da 
    vardır. Bu versiyon eğer zaten dizin O_SEARCH ya da O_RDONLY modda açılmışsa o dizine ilişkin betimleyici yoluyla DIR 
    adresini vermektedir:

    #include <dirent.h>

    DIR *fdopendir(int fd);

    Dizin opendir ya da fdopendir fonksiyonuyla açılıp, DIR handle'ı elde edildikten sonra, artık dizin girişleri readdir POSIX 
    fonksiyonuyla tek tek bir döngü içerisinde okunabilir. readdir fonksiyonu her çağrıldığında bir sonraki dizin girişi elde edilir. 
    Fonksiyonun prototipi şöyledir:

    #include <dirent.h>

    struct dirent *readdir(DIR *dirp);

    Fonksiyon parametre olarak DIR yapısının adresini alır sıradaki dizin girişini elde eder. Bu dizin girişinin bilgilerini statik 
    ömürlü struct dirent isimli bir yapı nesnesinin içerisine yerleştirir. Bize de onun adresini verir. Eğer readdir dizin listesinin
    sonuna gelirse NULL adrese geri dönmektedir. Ancak fonksiyon IO hatalarından dolayı da başarısız olabilir. Bu durumda başarısızlığın 
    dizin sonuna gelmekten dolayı mı yoksa IO hatalarından dolayı mı olduğunu anlamak gerekebilir. İşte readdir fonksiyonu eğer dizin sonuna 
    gelindiğinden dolayı NULL adrese geri dönmüş ise bu durumda errno değişkeninin değerini değiştirmemektedir. O halde programcı fonksiyonu çağırmadan 
    önce errno değişkenine 0 atamalı sonra fonksiyonu çağırmalıdır. Eğer fonksiyon NULL adrese geri dönmüşse errno değişkenine bakmalı eğer errno
    hala 0 ise fonksiyonun dizin sonuna gelindiğinden dolayı başarısız olduğu sonucunu çıkarmalıdır. O halde fonksiyon tipik olarak şöyle kullanılmalıdır:

    struct dirent *de;
    ...
    while (errno = 0, (de = readdir(dir)) != NULL) {
        /* ... */
    }
    if (errno != 0)
        exit_sys("readdir");

    dirent yapısı POSIX standartlarına göre en az iki elemana sahip olmak zorundadır. Bu elemanlar d_ino ve d_name elemanlarıdır. 
    d_ino elemanı ino_t türündendir. d_name elemanı ise char türden bir dizidir. Ancak işletim sistemleri genellikle bu dirent yapısında
    daha fazla eleman bulundurmaktadır. Örneğin Linux'taki dirent yapısı şöyledir:

    struct dirent {
        ino_t          d_ino;       /* Inode number */
        off_t          d_off;       /* Not an offset; see below */
        unsigned short d_reclen;    /* Length of this record */
        unsigned char  d_type;      /* Type of file; not supported
                                        by all filesystem types */
        char           d_name[256]; /* Null-terminated filename */
    };

    Görüldüğü gibi Linux'ta yapının içerisinde d_off, d_reclen ve d_type elemanları da bulunmaktadır. d_off ve d_reclen elemanları 
    önemli değildir. Ancak d_type elemanı dosyanın ne dosyası olduğunu belirtmektedir. Bu eleman sayesinde programcı dosyanın türünü 
    anlamak için stat fonksiyonlarını çağırmak zorunda kalmaz. Gerçekten de i-node tabanlı dosya sistemleri dizin girişlerinde dosyanın 
    türünü de zaten tutmaktadır. Ancak POSIX standartlarında bu elemanlar zorunlu olarak belirtilmediğinden taşınabilir programlarda 
    yalnızca yapının d_ino ve d_name elemanları kullanılmalıdır.

    dirent yapısının d_ino elemanı bize dosyanın i-node numarasını verir. d_name elemanı ise dizin girişinin ismini vermektedir. 
    Linux sistemlerinde d_type bit düzeyinde kodlanmamıştır. Aşağıdaki değerlerden birine eşit olmak zorundadır:

    DT_BLK      block device
    DT_CHR      character device
    DT_DIR      directory
    DT_FIFO     named pipe (FIFO)
    DT_LNK      symbolic link
    DT_REG      regular file.
    DT_SOCK     UNIX domain socket.
    DT_UNKNOWN  Bilinmeyen bir tür

    readdir ile dizin girişleri dosya sistemindeki kayıtlara göre verilmektedir. Halbuki ls komutu default durumda önce dizin girişlerini 
    isme göre sıraya dizmekte sonra onları göstermektedir. (Linux'ta -f'den sonra -l'yi kullanınız, ters sırada çalışmıyor.) Doğal sıranın 
    ne anlam ifade ettiği dosya sistemlerinin anlatıldığı bölümde ele alımacaktır.

    Dizin girişleri elde edildikten sonra dizin closedir POSIX fonksiyonuyla kapatılmaldır:

    #include <dirent.h>

    int closedir(DIR *dirp);

    Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir.

    closedir fonksiyonu kendi içerisinde kullandığı betimleyicileri close etmektedir. Örneğin biz DIR nesnesini (directory stream)
    fdopendir ile dizin betimleyicisini vererek yaratmış olalım. closedir bu betimleyiciyi kendisi close etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL)
        printf("%s\n", de->d_name);

    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir dizindeki dosyaların hepsini ls -l stili ile yazdırıyoruz. Bu örnekte bazı noktalara dikkat ediniz:

    - Biz argv[1] ile görüntülenecek dizini alıyoruz. Ancak bu dizindeki dosyaların stat bilgileri elde edilirken yok ifadesinin 
    dosya isminin başına eklenmesi gerekmektedir:

    while (errno = 0, (de = readdir(dir)) != NULL) {
        sprintf(path, "%s/%s", argv[1], de->d_name);
        if (lstat(path, &finfo) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }

    Aslında bu tür durumlarda fonksiyonların at'li versiyonlarını kullanmak daha uygun olabilmektedir.

    - Biz burada bir hizalama yapmadık. Halbuki orijinal ls -l komutu yazısal sütunları karakter sayısına göre hizalayıp sola 
    dayalı olarak, sayısal sütunları ise hizalayıp sağa dayalı olarak yazdırmaktadır. Tabii bunun için sütunun en geniş elemanının 
    bulunması da gerekmektedir. Bu işlem "çalışma sorusu" olarak sorulacaktır.

    - Biz bu örnekte dizin girişlerini doğal sıraya göre görüntüledik. Halbuki ls -l komutu önce onları isme göre sıraya dizip 
    sonra görüntülemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <sys/stat.h>
#include <dirent.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    DIR *dir;
    struct dirent *de;
    char path[4096];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        sprintf(path, "%s/%s", argv[1], de->d_name);
        if (lstat(path, &finfo) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz üzere aslında opendir, readdir, closedir gibi POSIX fonksiyonları arka planda işletim sisteminin sistem fonksiyonlarını
    çağırmaktadır. Örneğin Linux'ta aslında işletim sistemi düzeyinde işlemler önce sys_open sistem fonksiyonu ile dizin'in açılması 
    sonra sys_getdents sistem fonksiyonu ile dizin girişlerinin okunması ve nihayet sys_close fonksiyonu ile dizin'in kapatılması yoluyla 
    yapılmaktadır. Ancak POSIX standartlarında bu işlemler taşınabilir biçimde opendir, readdir ve closedir fonksiyonlarına devredilmiştir. 
    Şüphesiz bu fonksiyonlar aslında dizini açıp onun betimleyicisini DIR yapısının içerisinde saklamaktadır. İşte elimizde DIR yapısı 
    varsa biz de açık dizin'in betimleyicisini elde etmek istiyorsak bunun için dirfd isimli POSIX fonksiyonundan faydalanabiliriz:

    #include <dirent.h>

    int dirfd(DIR *dirp);

    Fonksiyon parametre olarak DIR yapısının adresini alır, geri dönüş değeri olarak dizine ilişkin betimleyiciyi verir. Fonksiyon başarısızlık durumunda
    -1 değerine geri dönmektedir.

    Yukarıdaki örneği fstatat fonksiyonunu kullanarak basitleştirebiliriz. fstatat fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int fstatat(int fd, const char *restrict path, struct stat *restrict buf, int flag);

    Fonksiyonun fd parametresinin yanı sıra aynı zamanda bir flag parametresinin olduğuna dikkat ediniz. Bu parametre stat semantiğinin mi yoksa 
    lstat semantiğinin mi uygulanacağını belirtmektedir. Eğer bu parametreye 0 geçilirse bu durumda stat semantiği uygulanır. Eğer bu parametreye 
    AT_SYMLINK_NOFOLLOW değeri geçilirse bu durumda lstat semantiği uygulanmaktadır. AT_SYMLINK_NOFOLLOW sembolik sabiti <sys/stat.h> içerisinde değil
    <fcntl.h> içerisinde bildirilmiştir. İşte biz yukarıdaki örnekte önce dizin'in betimleyicisini dirfd fonksiyonu ile alıp bunu fstatat 
    fonksiyonunda kullanırsak yol ifadesini düzenlememize gerek kalmaz. Aşağıdaki örnekte bu çözüm verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dirent.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE        4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    DIR *dir;
    struct dirent *de;
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    if ((fd = dirfd(dir)) == -1)
        exit_sys("dirfd");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        if (fstatat(fd, de->d_name, &finfo, AT_SYMLINK_NOFOLLOW) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                17. Ders 18/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    rewinddir isimli POSIX fonksiyonu dolaşımı yeniden başlatmak amacıyla kullanılır. Yani bu işlem adeta dosya göstericisinin 
    dizin dosyasının başına çekilmesi işlemi gibidir.

    Aşağıdaki örnekte dizin girişleri rewindir fonksiyonu ile iki kez elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL)
        printf("%s\n", de->d_name);

    if (errno != 0)
        exit_sys("readdir");

    printf("---------------------------------------\n");

    rewinddir(dir);

    while (errno = 0, (de = readdir(dir)) != NULL)
        printf("%s\n", de->d_name);

    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Dizin girişlerini dolaşırken belli bir noktada dizin dosyasının dosya göstericisinin konumunu telldir POSIX fonksiyonu 
    ile alabiliriz ve o offset'e seekdir POSIX fonksiyonu ile yeniden konumlandırma yapabiliriz. Fonksiyonların prototipleri şöyledir:

    #include <dirent.h>

    long telldir(DIR *dirp);
    void seekdir(DIR *dirp, long loc);

    Tabii biz belli bir konumu okuduktan sonra kaydedersek bu durumda okumadan dolayı dizin dosyasının dosya göstericisi ilerletilmiş 
    olacaktır. Aşağıdaki örnekte dizin içerisinde "sample.c" dosyası bulunup onun konumu telldir fonksiyonu ile saklanmıştır. Sonra seekdir
    fonksiyonu ile konuma konumlandırma yapılmıştır. Tabii burada kaydedilen konum "sample.c" dosyasından sonraki dosyanın konumdur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;
    long loc;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%s\n", de->d_name);
        if (!strcmp(de->d_name, "sample.c"))
            loc = telldir(dir);
    }

    if (errno != 0)
        exit_sys("readdir");

    printf("----------------------------------------------\n");

    seekdir(dir, loc);

    while (errno = 0, (de = readdir(dir)) != NULL)
        printf("%s\n", de->d_name);

    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Dizin ağacının dolaşılması özyinelemeli bir algoritmayla yapılmalıdır. Bu işlem çeşitli biçimlerde gerçekleştirilebilir. 
    En basit gerçekleştirimi dolaşılacak ağacın kök yol ifadesini alan özyinelemeli bir fonksiyon yazmaktır. Bu fonksiyon 
    dizin girişlerini tek tek elde eder. Eğer söz konusu dizin girişi bir dizine ilişkinse o dizinin yol ifadesiyle kendini çağırır.
    Bu algoritmada dikkat edilmesi gereken birkaç nokta vardır:

    1) Dizin girişleri dolaşılırken "." ve ".." dizinleri continue ile geçilmelidir. Aksi takdirde sonsuz döngü oluşabilir.

    2) stat fonksiyonu yerine lstat fonksiyonu kullanılmalıdır. Çünkü dizin ağacı dolaşılırken sembolik bağlantı bir dizine ilişkinse
    sembolik bağlantının hedefine gidilmesi özyinelemeyi bozup sonsuz döngülere yol açabilir.

    3) readdir fonksiyonu dizin girişini okuduğunda bize yalnız girişin ismini vermektedir. Dolayısıyla lstat fonksiyonu uygulanırken 
    prosesin çalışma dizinin uygun olması gerekir. Bunu sağlayabilmek için her dizine geçişte chdir fonksiyonu ile prosesin çalışma dizinini 
    değiştirebiliriz. Ya da alternatif olarak mutlak bir yol ifadesi sürekli güncellenebilir. Aslında burada seçeneklerden biri de fonksiyonların 
    at'li biçimlerini kullanmak olabilir.

    4) Her özyineleme bittiğinde opendir ile açılan dizin closedir ile kapatılmalıdır.

    5) Genellikle böylesi fonksiyonlar bir fatal error ile programı sonlandırmamalıdır. chdir fonksiyonu ile prosesin çalışma dizini 
    değiştirilemeyebilir. Ya da örneğin opendir ile biz bir dizini açamayabiliriz. Bu tür durumlarda hata stderr dosyasına rapor edilip işlemin 
    devam ettirilmesi uygun olabilir.

    6) Özyinelemeli dolaşım bittikten sonra prosesin çalışma dizini orijinal halde bırakılmalıdır.

    Aşağıda tipik bir özyinelemeli "depth-first" dolaşım örneği verilmiştir. Ancak burada prosesin çalışma dizini özyineleme bittikten sonra
    orijinal dizin ile yeniden set edilmemiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

    return 0;
}

void walkdir(const char *path)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }

    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%s\n", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }

        if (S_ISDIR(finfo.st_mode)) {
            walkdir(de->d_name);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Özyineleme çağırmada hangi kademede bulunulduğunu belirten bir bilginin de özyinelemeli fonksiyona parametre yoluyla aktarılması
    faydaları olabilmektedir. Örneğin bu sayede biz ağacı kademeli bir biçimde görüntüleyebiliriz.

    Aşağıdaki örnekte walkdir fonksiyonuna bir kademe bilgisi de eklenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1], 0);

    return 0;
}

void walkdir(const char *path, int level)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }

    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }

        if (S_ISDIR(finfo.st_mode)) {
            walkdir(de->d_name, level + 1);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki walkdir fonksiyonu bir sarma fonksiyonla daha iyi hale getirilebilir. Bu sayede level parametresi kullanıcıdan gizlenebilir 
    ve prosesin çalışma dizini alınıp geri set edilebilir.

    Aşağıdaki örnekte walkdir fonksiyonu asıl özyineleme işlemini yapan walkdir_recur fonksiyonunu çağırmaktadır. Fonksiyonda kademeli yazım 
    için printf fonksiyonu şöyle çağrılmıştır:

    printf("%*s%s\n", level * 4, "", de->d_name);

    Burada * format karakteri level * 4 ile eşleştirilmiştir. İlk %s format karakteriyle de "" biçiminde boş string eşleşecektir. 
    O halde biz yalnızca satırın başında level * 4 kadar boşluk oluşturmuş oluyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void walkdir_recur(const char *path, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

    return 0;
}

void walkdir(const char *path)
{
    char cwd[PATH_MAX];

    if (getcwd(cwd, PATH_MAX) == NULL) {
        perror("getcwd");
        return;
    }

    walkdir_recur(path, 0);

    if (chdir(cwd) == -1) {
        perror("chdir");
        return;
    }
}

void walkdir_recur(const char *path, int level)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }

    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }

        if (S_ISDIR(finfo.st_mode)) {
            walkdir_recur(de->d_name, level + 1);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

*--------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını dolaşırken her defasında prosesin çalışma dizinini değiştirmek yerine fonksiyonların at'li biçimlerinden de 
    faydalanabiliriz. Aşağıdaki örnekte özyinelemeli fonksiyona üst dizinin betimleyicisi (fdp) ve dosyanın ismi geçirilmiştir. 
    at'li fonksiyonların eğer yol ifadesi mutlak ise at'siz fonksiyonlar gibi davrandığını anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void walkdir_recur(int fddir, const char *fname, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

    return 0;
}

void walkdir(const char *path)
{
    int fddir;

    if ((fddir = open(path, O_RDONLY)) == -1)
        exit_sys(path);

    walkdir_recur(fddir, path, 0);

    close(fddir);
}

void walkdir_recur(int fdp, const char *fname, int level)
{
    DIR *dir;
    int fdc;
    struct dirent *de;
    struct stat finfo;

    if ((fdc = openat(fdp, fname, O_RDONLY)) == -1) {
        fprintf(stderr, "cannot open file: %s\n", fname);
        return;
    }
    if ((dir = fdopendir(fdc)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", fname);
        close(fdp);
        return;
    }

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (fstatat(fdc, de->d_name, &finfo, AT_SYMLINK_NOFOLLOW) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }

        if (S_ISDIR(finfo.st_mode))
            walkdir_recur(fdc, de->d_name, level + 1);
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", fname);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını dolaşırken genelleştirme sağlamak için fonksiyon göstericilerinden faydalanabiliriz. Yani fonksiyonumuz dizin ağacını 
    dolaşırken dosya isimlerini ekrana yazdırmak yerine parametresiyle aldığı bir callback fonksiyonu çağırabilir.

    Aşağıda dizin girişi bulundukça çağrılan bir callback mekanizması örneği verilmiştir. Buradaki fonksiyonun prototipi şöyledir:

    int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int));

    Fonksiyonun birinci parametresi dolaşılacak dizinin yol ifadesini belirtir. İkinci parametre callback fonksiyonun adresini almaktadır. 
    callback fonksiyonun birinci parametresi bulunan dizin girişinin ismini (tüm yol ifadesi değil), ikinci parametresi bu dosyanın 
    stat bilgilerini belirtmektedir. Üçüncü parametre ise özyineleme için kademe bilgisini belirtir. Callback fonksiyon 0 ile geri dönerse 
    özyineleme devam ettirilir. Ancak sıfır dışı bir değerle geri dönerse özyineleme sonlandırılır ve walkdir fonksiyonu da bu değerler 
    geri döner. Bu durumda walkdir fonksiyonun geri dönüş değeri üç biçimde olabilir:

    -1: POSIX fonksiyonlarından birinin hatayla geri dönmesi
    > 0: Erken sonlanmayı belirtir.
    0: Normal sonlanmayı belirtir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int));
int walkdir_recur(const char *path, int level, int (*proc)(const char *, const struct stat *, int));

int disp(const char *fname, const struct stat *finfo, int level)
{
    printf("%*s%s\n", level * 4, "", fname);

    if (!strcmp(fname, "d.dat"))
        return 1;

    return 0;
}

int main(int argc, char *argv[])
{
    int result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((result = walkdir(argv[1], disp)) == -1) {
        fprintf(stderr, "function terminates problematically!\n");
        exit(EXIT_FAILURE);
    }
    if (result != 0)
        printf("function terminates prematurely with %d code\n", result);
    else
        printf("function terminates normally!...\n");

    return 0;
}

int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int))
{
    char cwd[PATH_MAX];
    int result;

    if (getcwd(cwd, PATH_MAX) == NULL) {
        perror("getcwd");
        return - 1;
    }

    result = walkdir_recur(path, 0, proc);

    if (chdir(cwd) == -1) {
        perror("chdir");
        return -1;
    }

    return result;
}

int walkdir_recur(const char *path, int level, int (*proc)(const char *, const struct stat *, int))
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;
    int result = 0;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return -1;
    }

    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        result = -1;
        goto EXIT;
    }

    while (errno = 0, (de = readdir(dir)) != NULL) {
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
        if ((result = proc(de->d_name, &finfo, level)) != 0) {
            result = -1;
            goto EXIT;
        }

        if (S_ISDIR(finfo.st_mode)) {
            result = walkdir_recur(de->d_name, level + 1, proc);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                result = -1;
                goto EXIT;
            }
            if (result != 0)
                goto EXIT;
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);

    return result;
}

/*---------------------------------------------------------------------------------------------------------------------------
    scandir bir dizindeki belli koşulları sağlayan girişleri veren biraz karmaşık parametreye sahip bir POSIX fonksiyonudur. 
    Fonksiyonun parametrik yapısı şöyledir:

    #include <dirent.h>

    int alphasort(const struct dirent **d1, const struct dirent **d2);
    int scandir(const char *dir, struct dirent ***namelist, int (*sel)(const struct dirent *),
                int (*compar)(const struct dirent **, const struct dirent **));

    scandir fonksiyonunun birinci parametresi dizin'in yol ifadesini almaktadır. İkinci parametreye struct dirent türünden 
    göstericiyi gösteren bir göstericinin adresi geçirilmelidir. Üçüncü parametre filtre işleminde kullanılacak fonksiyonu belirtmektedir. 
    Her dizin girişi bulundukça bu fonksiyon çağrılır. Eğer bu fonksiyon sıfır dışı bir değerle geri dönerse dizin girişi biriktirilir. 
    Bu parametre NULL adres geçilebilir. Bu durumda dizindeki tüm girişler elde edilir. Son parametre filtrelenen girişlere ilişkin 
    gösterici dizisini sort etmek için kullanılacak karşılaştırma fonksiyonunu belirtmektedir. Bu karşılaştırma fonksiyonunun prototipi şöyle olmalıdır:

    int cmp(const struct **direnet1, const struct **dirent2);

    Fonksiyon tıpkı qsort fonksiyonunda olduğu gibi birinci parametresiyle belirtilmiş olan dizin girişi ikinci parametresiyle belirtilmiş 
    olan dizin girişinden büyükse pozitif herhangi bir değere, küçükse negatif herhangi bir değere ve eşitse sıfır değerine geri dönmelidir. 
    Alfabetik sıralamayı sağlamak amacıyla zaten hazır bir alphasort isimli fonksiyon bulundurulmuştur.

    scandir fonksiyonu başarı durumunda gösterici dizisine yerleştirilen eleman sayısı ile başarısızlık durumunda -1 ile geri döner ve errno uygun biçimde değer 
    alır.

    scandir fonksiyonu tüm tahsisatları malloc fonksiyonunu kullanarak yapmaktadır. Dolayısıyla programcının tahsis edilen bu alanları kendisinin
    free hale getirmesi gerekmektedir.

    scandir kendi içerisinde her biriktirilecek dizin girişi için malloc fonksiyonu ile bir struct dirent yapısı tahsis eder, bunların adreslerini 
    de yine tahsis ettiği bir gösterici dizisine yerleştirir. Bu gösterici dizisinin adresini de bizim adresini geçtiğimiz 
    göstericiyi gösteren göstericinin içerisine yerleştirmektedir.

    Aşağıdaki örnekte komut argümanı olarak girilen bir dizinde başı 'a' ya da 'A' harfi ile başlayan girişler elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

void exit_sys(const char *msg);

int myfilter(const struct dirent *de)
{
    return de->d_name[0] == 'a' || de->d_name[0] == 'A';
}

int main(int argc, char *argv[])
{
    int result;
    struct dirent **dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((result = scandir(argv[1], &dents, myfilter, alphasort)) == -1)
        exit_sys("scandir");

    for (int i = 0; i < result; ++i)
        printf("%s\n", dents[i]->d_name);

    for (int i = 0; i < result; ++i)
        free(dents[i]);
    free(dents);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    scandir fonksiyonun tasarımında bize göre kusurlar vardır. Fonksiyonun dirent yapılarını biriktirmesi karşılaştırma fonksiyonu yazacak
    kişiler için yük oluşturmaktadır. Buradaki daha doğru tasarım yeni bir yapı bildirip yapının içerisinde hem dirent bilgilerinin hem de 
    stat bilgilerinin bulunması olabilir.

    Aşağıda bir karşılaştırma fonksiyonu yazımı örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

void exit_sys(const char *msg);

int myfilter(const struct dirent *de)
{
    return de->d_name[0] == 'a' || de->d_name[0] == 'A';
}

int cmp_size(const struct dirent **de1, const struct dirent **de2)
{
    struct stat finfo1, finfo2;

    if (stat((**de1).d_name, &finfo1) == -1)
        exit_sys("stat");

    if (stat((**de2).d_name, &finfo2) == -1)
        exit_sys("stat");

    if (finfo1.st_size > finfo2.st_size)
        return 1;

    if (finfo1.st_size < finfo2.st_size)
        return -1;

    return 0;
}

int main(int argc, char *argv[])
{
    int result;
    struct dirent **dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (chdir(argv[1]) == -1)
        exit_sys("chdir");

    if ((result = scandir(argv[1], &dents, myfilter, cmp_size)) == -1)
        exit_sys("scandir");

    for (int i = 0; i < result; ++i)
        printf("%s\n", dents[i]->d_name);

    for (int i = 0; i < result; ++i)
        free(dents[i]);
    free(dents);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                18. Ders 24/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını özyinelemeli biçimde dolaşan ftw (file traverse walk) ve nftw (new file traverse walk) isimli POSIX fonksiyonları 
    bulunmaktadır. Aslında eskiden yalnızca ftw fonksiyonu vardı. Ancak bu fonksiyona bazı eklemeler yapılıp nftw fonksiyonu oluşturuldu
    ve ftw fonksiyonu "deprecated" yapıldı. Yani bugün hem ftw hem de nftw fonksiyonları bulunuyor olsa da nftw fonksiyonun kullanılması 
    önerilmektedir. Zaten nftw fonksiyonu işlevsel olarak ftw fonksiyonu kapsamaktadır. nftw fonksiyonunun prototipi şöyledir:

    #include <ftw.h>

    int nftw(const char *path, int (*fn)(const char *, const struct stat *, int, struct FTW *), int fd_limit, int flags);

    Linux altında bu fonksiyonu libc kütüphanesi ile kullanırken "feature test macro" oluşturulmalıdır. Burada başlık dosyalarının 
    yukarısında aşağıdaki gibi bir sembolik sabit bulundurmak gerekir:

    #define _XOPEN_SOURCE 500

    Feature test macro kavramından daha sonra bahsedilecektir. Budaraki sayının 500'e eşit ya da daha büyük olması gerekmektedir.

    Fonksiyonun birinci parametresi özyinelemeli dolaşılacak dizin'in yol ifadesini almaktadır. İkinci parametre her dizin girişi bulundukça 
    çağrılacak "callback" fonksiyonun adresini almaktadır. Buradaki fonksiyonun aşağıdaki parametrik yapıya sahip olması gerekir:

    int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);

    nftw fonksiyonun üçüncü parametresi kullanılacak maksimum dosya betimleyici sayısını belirtmektedir. Fonksiyon her derine indikçe 
    o dizini opendir fonksiyonu ile açtığı için (bizde öyle yapmıştık) dosya betimleyici tablosunda bir betimleyici harcamaktadır. Linux'ta
    default durumda prosesin dosya betimleyici tablosunda 1024 tane betimleyici için yer vardır. Dolayısıyla derine inildikçe bu tabloda 
    betimleyici yer kaplayacağından derin ağaçlarda betimleyici sıkıntısı çekilebilir. İşte fonksiyonun dördüncü parametresi (fd_limit)
    fonksiyonun en fazla kaç betimleyiciyi açık olarak tutacığını belirtmektedir. Programcı bu parametreye ortalama bir değer girebilir. 
    Fonksiyon kendi içerisinde burada belirtilen derinlik aşıldığında özyineleme yaparken üst dizin'in betimleyicisini kapatıp geri dönüşte 
    yeniden açmaktadır. Ayrıca fonksiyonun dokümantasyonunda fonksiyonun her kademe için en fazla bir tane betimleyici kullanacağı belirtilmiştir. 
    Fonksiyonun son parametresi özyinelemeli dolaşım sırasında bazı belirlemeler için kullanılmaktadır. Bu parametre çeşitli sembolik sabitlerin 
    bit düzeyinde OR'lanması ile oluşturulmaktadır. Bu sembolik sabitler şunlardır:

    FTW_CHDIR: Eğer bu bayrak belirtilirse fonksiyon her dizine geçtiğinde prosesin çalışma dizinini de o dizin olarak değiştirmektedir.

    FTW_DEPTH: Normalde dolaşım "pre-order" biçimde yapılmaktadır. Bu bayrak girilirse "post-order" dolaşım yapılır. Bayrağın ismi yanlış verilmiştir. 
    "pre-order" dolaşım demek bir dizin ile karşılaşıldığında önce dizin girişinin ele alınması sonra özyineleme yapılması demektir. "post-order" dolaşım ise
    önce özyineleme yapılıp sonra dizin girişinin ele alınması demektir. Default durum "pre-order" dolaşım biçimindedir.

    FTW_MOUNT: Bu bayrak belirtilirse özyineleme yapılırken bir "mount point" ile karşılaşılırsa o dosya sistemine girilmez. Default durumda 
    özyineleme sırasında bir "mount point" ile karşılaşılırsa özyineleme o dosya sisteminin içine girilerek devam ettirilmektedir.

    FTW_PHYS: Default durumda nftw fonksiyonu bir sembolik link dosyası ile karşılaştığında linki izler ve link'in hedefine
    yönelik hareket eder. Daha önce bir böyle bir durumun sonsuz döngüye yol açabileceğinden bahsetmiştik. Bu nedenle biz özyinelemede stat fonksiyonu yerine
    lstat fonksiyonunu kullanmıştık. İşte bu bayrak belirtilirse artık nftw fonksiyonu sembolik link dosyası ile karşılaştığında link'i izlemez, 
    sembolik link dosyasının kendisi hakkında bilgi verir.

    Programcı bu dördüncü parametreye hiçbir bayrak geçmek istemezse 0 girebilir.

    nftw fonksiyonun geri dönüş değeri fonksiyon başarısızsa -1, başarılıysa 0'dır. Ancak aslında fonksiyon başarılı durumda callback fonksiyonun 
    geri dönüş değeri ile geri döner. Şöyle ki: Biz callback fonksiyonu 0 ile geri döndürürsek özyinelemeye devam etmek istediğimizi belirtmiş 
    oluruz. Bu durumda bir IO hatası da olmazsa nftw fonksiyonu 0 ile geri döner. Eğer biz bu fonksiyondan sıfır dışı bir değerle geri dönersek.
    nftw fonksiyonu özyinelemeyi bırakıp hemen geri çıkar ve bizim callback fonksiyondan döndürdüğümüz sıfır dışı değerle geri döner.

    Şimdi de callback fonksiyonun parametrelerine gelelim:

    int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);

    Fonksiyonun birinci parametresine bulunun dizin girişinin yol ifadesi yerleştirilir. Bu yol ifadesinin baş kısmı tamamen 
    bizim nftw fonksiyonuna verdiğimiz dizin ifadesinden oluşmaktadır. (Yani biz nftw fonksiyonuna mutlak bir yol iafdesi verirsek buraya
    mutlak bir yol ifadesi geçirilir, biz nftw fonksiyonuna göreli bir yol ifadesi verirsek burada göreli bir yol ifadesi geçirilir.) 
    Fonksiyonun ikinci parametresi bulunan dizin girişine ilişkin struct stat yapısının adresini belirtmektedir. Fonksiyonun üçüncü parametresi ise
    bulunan dizin girişinin türünü belirtmektedir. Bu tür şunlardan birine tam eşit olmak zorundadır:

    FTW_D: Bulunan giriş bir dizin girişidir.

    FTW_DNR: Bulunan giriş bir dizin girişidir. Ancak bu dizin'in içi okunamamaktadır. Dolayısıyla bu dizin özyinelemede dolaşılamayacaktır.

    FTW_DP: Post-order dolaşımda bir dizinle karşılaşıldığında bayrak FTW_D yerine FTW_DP olarak set edilmektedir.

    FTW_F: Bulunan dizin girişi sıradan bir dosyadır (regular file).

    FTW_NS: Bulunan dizin girişi için stat ya da lstat fonksiyonu başarısız olmuştur. Dolayısıyla fonksiyona geçirilen stat yapısı da
    anlamlı değildir.

    FTW_SL: Bulunan giriş bir sembolik bağlantı dosyasına ilişkindir. Sembolik bağlantı dosyasının hedefi mevcuttur.

    FTW_SLN: Bulunan giriş bir sembolik bağlantı dosyasına ilişkindir. Sembolik bağlantı dosyasının hedefi mevcut değildir ("danging link" durumu).

    callback fonksiyonun son parametresi FTW isimli bir yapı türündendir Bu yapı şöyle bildirilmiştir:

    struct FTW {
        int base;
        int level;
    };

    Yapının level elemanı ağaçtaki derinlik düzeyini belirtmektedir. Bu değer 0'dan başlayarak derine indikçe artırılmaktadır.
    base elemanı ise dizin girişinin birinci parametrede belirtilen yol ifadesinin kaçıncı indeksinden başladığını belirtmektedir. Örneğin
    biz "/home/kaan/Study" dizinini dolaşmak istemiş olalım. Fonksiyon da dizin girişi olarak "sample.c" bulmuş olsun. Fonksiyon bize bu girişi 
    "/home/kaan/Study/sample.c" biçiminde verecektir. İşte buradaki base 17 olarak verilecektir.

    Aşağıda nftw fonksiyonunun kullanımına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _XOPEN_SOURCE 500

#include <stdio.h>
#include <stdlib.h>
#include <ftw.h>

int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((result = nftw(argv[1], callback, 100, FTW_PHYS)) == -1)
        exit_sys("nftw");

    printf("result = %d\n", result);

    return 0;
}

int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw)
{
    switch (flag) {
        case FTW_DNR:
            printf("%*s%s (cannot read directory)\n", ftw->level * 4, "", path + ftw->base);
            break;
        case FTW_NS:
            printf("%*s%s (cannot get statinfo)\n", ftw->level * 4, "", path + ftw->base);
            break;
        default:
            printf("%*s%s\n", ftw->level * 4, "", path + ftw->base);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın hard link'ini programlama yoluyla oluşturabilmek için link isimli POSIX fonksiyonu kullanılmaktadır. Linux sistemlerinde 
    link fonksiyonu doğrudan işletim sisteminin sys_link isimli sistem fonksiyonunu çağırmaktadır. link fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int link(const char *oldpath, const char *newpath);

    Fonksiyonun birinci parametresi hard link'i çıkartılacak dosyanın yol ifadesini, ikinci parametresi yeni dizin girişinin ismini belirtmektedir. 
    Tabii prosesin ilgili dizine yazma hakkının olması gerekir. POSIX standartlarına göre bir sembolik bağlantı dosyasının hard link'i çıkartılırken 
    bu sembolik bağlantının kendisinin mi yoksa onun hedefinin mi link'inin çıkartılacağı işletim sistemini yazanların isteğine bırakılmıştır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno uygun biçimde değer alır.

    Bir dizin'in hard link'inin çıkartılması özyinelemeli fonksiyonları sonsuz döngüye sokabilmektedir. Bu nedenle dizinler üzerinde 
    hard link çıkartma şüpheli bir durumdur. POSIX standartları bir dizin'in hard link'ini çıkartılabilmesi için prosesin 
    bunu yapabilecek önceliğe sahip olması gerektiğini (yani etkin kullanıcı id'sinin 0 olması gerektiğini) ve işletim sisteminin de 
    dizinlerin hard link'lerinin çıkartılabilmesine izin vermesi gerektiğini belirtmektedir. Eskiden Linux sistemleri root prosesler için
    dizinlerin hard link'lerinin çıkartılmasına izin veriyordu. Ancak sonraları bunu da kaldırdı. Yani Linux istemlerinde dizinlerin 
    hard link'leri artık çıkartılamamaktadır.

    Daha önceden de belirtildiği gibi bir dosyanın hard link'i komut satırından ln komutuyla oluşturulabilmektedir. Tabii aslında bu program
    link fonksiyonu çağrılarak yazılmıştır. Örneğin:

    $ ln a b

    Aşağıdaki örnekte komut satırından verilen bir dosyanın hard link'i çıkartılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (link(argv[1], argv[2]) == -1)
        exit_sys("link");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    link fonksiyonunun linkat ismiyle "at"li bir versiyonu da vardır. linkat fonksiyonunun prototipi şöyledir:

    #include <fcntl.h>

    int linkat(int fd1, const char *path1, int fd2, const char *path2, int flag);

    Fonksiyonun birinci parametresi ikinci parametresiyle belirtilen yok ifadesi göreli ise aramanın yapılacağı dizinin betimleyicisini alır. 
    Üçüncü parametresi ise dördüncü parametrede belirtilen yol ifadesi göreli ise aramanın yapılacağı dizin'in betimleyicisini almaktadır. 
    Son parametre sembolik bağlantının izlenip izlenmeyeceğini belirtir. Eğer bu parametre AT_SYMLINK_FOLLOW biçiminde girilirse semboli 
    bağlantı izlenir. Eğer bu parametre 0 girilirse sembolik bağlantı izlenmez. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın sembolik bağlantı dosyası symlink isimli POSIX fonksiyonuyla oluşturulmaktadır. Bu fonksiyon Linux sistemlerinde 
    doğrudan sys_symlink isimli sistem fonksiyonunu çağırmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int symlink(const char *path1, const char *path2);

    Fonksiyonun birinci parametresi sembolik bağlantısı çıkartılacak dosyanın yol ifadesini, ikinci parametresi ise sembolik bağlantı dosyasının 
    yol ifadesini alır. Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri döner. Prototipten de gördüğünüz 
    gibi sembolik bağlantı dosyasının kendisine ilişkin erişim hakları bizden istenmemektedir. Çünkü sembolik bağlantı dosyasının kendi erişim haklarının 
    bir önemi yoktur. Bu fonksiyon bu erişim hakları için "rwxrwxrwx" haklarını vermektedir. Sembolik bağlantı dosyasını izleyen fonksiyonlar
    hedef dosyanın erişim haklarını dikkate alırlar. Sembolik bağlantı dosyasının kendi erişim haklarının bir önemi yoktur.

    symlink fonksiyonu ile "dangling" link oluşturulabilmektedir. Yani başka bir deyişle fonksiyonun birinci parametresinde belirtilen 
    dosyanın bulunuyor olması gerekmez.

    Bir POSIX fonksiyonun sembolik bağlantı dosyasını izleyip izlemediğine dikkat ediniz. Şüphe duyarsanız dokümanlardan bunu doğrulayınız. 
    Örneğin open fonksiyonu sembolik bağlantıyı izlemektedir. Ancak remove ve unlik fonksiyonları sembolik bağlantı dosyalarını izlememektedir. 
    (Yani remove ve unlink ile sembolik bağlantı dosyası silinmeye çalışılırsa bu fonksiyonlar sembolik bağlantı dosyasının kendisini silmektedir.) 
    Genel olarak POSIX fonksiyonlarının büyük bölümü sembolik bağlantı dosyasını izlemektedir.

    Bir POSIX fonksiyonu "pathname resolution" işlemini yaparken belli sayıdan fazla sembolik link üzerinden geçilmişse
    döngüsel bir durumun oluştuğunu düşünerek ELOOP özel değeri ile geri dönmektedir. Örneğin:

    a -> b
    b -> a

    Bu durumda biz "a" dosyasını open fonksiyonuyla açmak istersek fonksiyon başarısız olur ve errno ELOOP değerini alır.

    Dizin'lerin hard link'lerinin çıkartılması sorunlu bir durum oluşturduğundan yukarı söz etmiştik. Halbuki aynı durum sembolik 
    bağlantılar için geçerli değildir. Yani sıradan bir proses bir dizin'in sembolik bağlantısını oluşturabilmektedir.

    Daha önceden de belirtildiği gibi bir dosyanın sembolik bağlantısı ln -s kabuk komutuyla oluşturulabilmektedir. Örneğin:

    $ ln -s a b

    Burada b sembolik bağlantı dosyası a dosyasını göstermektedir.

    Aşağıda komut satırından hareketle bir sembolik bağlantı oluşturma örneği verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (symlink(argv[1], argv[2]) == -1)
        exit_sys("symlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    symlink fonksiyonun symlinkat isminde bir de "at"li versiyonu vardır:

    #include <fcntl.h>

    int symlinkat(const char *path1, int fd, const char *path2);

    Fonksiyonun ikinci parametresi üçüncü parametresindeki yol ifadesi göreli ise aramanın yapılacağı dizinin betimleyicisini almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz lstat fonksiyonuyla bir dosyanın bilgilerini elde ettiğimizde o dosyanın bir sembolik bağlantı dosyası olup olmadığını anlayabiliyorduk. 
    Ancak o sembolik bağlantı dosyasının hangi dosyaya referans ettiğini lstat fonksiyonu bize vermemektedir. İşte readlink 
    isimli POSIX fonksiyonu bu işi yapmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    ssize_t readlink(const char *path, char *buf, size_t bufsize);

    Fonksiyonun birinci parametresi sembolik bağlantı dosyasının yol ifadesini belirtir. İkinci ve üçüncü parametreler 
    sembolik bağlantı dosyasının referans ettiği dosyanın yol ifadesinin yerleştirileceği yerin adresini ve uzunluğu almaktadır. 
    Bu alan küçük ise fonksiyon başarısız olmaz ancak yol ifadesinin son kısmı budanır. Fonksiyon verdiğimiz adrese yerleştirdiği 
    karakter sayısına geri dönmektedir. Fonksiyon (diğer fonksiyonların aksine) null karakteri dizinin sonuna yerleştirmez. 
    Bu durumda programcı referans edilen yol ifadesine erişirken dikkat etmelidir.

    Fonksiyon başarı durumunda yerleştirilen karakter sayısına, başarısızlık durumunda -1 değerine geri dönmektedir.

    Aşağıda readlink fonksiyonun kullanımına bir örnek verilmiştir. readlink fonksiyonunun null karakteri diziye yerleştirmediğine dikkat ediniz.
    Sonunda null karakter olmayan result uzunlukta bir yazının printf ile bastırılması şöyle yapılabilir:

    printf("%.*s\n, result, buf);

    printf "%.10s" gibi bir format karakterlerinde yazıyı null karakter görene kadar değil n karakter yazdırmaktadır. (Örneğimizde 10).
    Tabii biz burada istersek null karakteri dizinin sonuna yerleştirip onu normak olarak yazdırabiliriz. Ancak bu durumda da dizi uzunluğunun yeterli 
    olduğuna dikkat etmemiz gerekir.

    Aşağıdaki örnekte biz yol ifadesinin yerleştirileceği diziyi 4096 + 1 eleman uzunluğunda açtık. Linux sistemlerinde x86 ve x64 mimarilerinde 
    (sayfa uzunluğunun 4K olduğu mimarilerde) yol ifadeleri en fazla 4096 karakter olabilmektedir. Ancak diğer mimarilerde ve POSIX genelinde
    böyle bir zorunluluk yoktur. O sistemdeki maksimum yol ifadesi uzunluğu <limits.h> dosyası içerisindeki PATH_MAX sembolik sabitiyle 
    belirtilmektedir. Ancak maalesef bu sembolik sabitin define edilmiş olması da zorunlu değildir. Bu konunun biraz ayrıntıları olduğu için 
    konu bir başlık altında ileride ele alınacaktır.

    Aşağıdaki örnekte yol ifadesi tam olarak 4096 karakter de olabilir. Ya da daha uzun olup budanmış da olabilir. Bu tür durumlarda tavsiye edilen
    diziyi büyütüp fonksiyonu başarılı olan kadar tekrar tekrar çağırmaktır. Ancak bir yol ifadesinin 4096 karakterden büyük olması çok çok uç bir noktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[4096 + 1];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((result = readlink(argv[1], buf, 4096)) == -1)
        exit_sys("readlink");

    printf("result = %lld\n", (long long)result);

    if (result < 4096) {
        buf[result] = '\0';        /* alternatifi -> printf("%.*s\n", (int)result, buf); */
        puts(buf);
    }
    else
        fprintf(stderr, "path maybe truncated!...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                19. Ders 24/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    access isimli POSIX fonksiyonu bir dosyaya okuma, yazma, çalıştırma gibi erişimlerin mümkün olup olmadığı bilgisini bize vermektedir. 
    Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int access(const char *path, int amode)

    Fonksiyonun birinci parametresi erişim testinin yapılacağı dosyanın yol ifadesini belirtmektedir. İkinci parametresi test edilecek 
    erişimi belirtir. Bu parametre aşağıdaki sembolik sabitlerin bir düzeyinde OR'lanmasıyla oluşturulabilir:

    R_OK: Okuma yapılabilir mi?
    W_OK: Yazma yapılabilir mi?
    X_OK: Çalıştırılabilir mi?
    F_OK: Dosya var mı?

    access fonksiyonuyla ilgili iki önemli nokta vardır. Birincisi access fonksiyonu test işleminde prosesin etkin kullanıcı id'sini ve
    grup id'sini değil, gerçek kullanıcı id'sini ve grup id'sini işleme sokar. Her ne kadar prosesin gerçek kullanıcı ve grup id'leri çoğu kez 
    etkin kullanıcı id'leri ve grup id'leri ile aynı olsa da bazen farklılaşabilmektedir. İkinci durum ise, access ile bir test yapıldıktan sonra 
    bu teste dayalı olarak dosya üzerinde işlem yapılmak istendiğinde bu işlemin başarılı olması garanti değildir. Çünkü o arada
    sistemdeki başka bir proses dosyanın erişim hakları üzerinde değişiklik yapmış olabilir.

    access fonksiyonu test olumluysa 0 değerine olumsuzsa -1 değerine geri dönmektedir. Tabii access fonksiyonun başarısızlığının başka nedenleri de 
    olabilir. Ancak programcı genellikle öyle ya da böyle istediği işlemi yapıp yapamayacağı ile ilgilenmektedir. Ancak yine de fonksiyon başarısız 
    olduğunda errno değeri incelenebilir ve başarısızlığın EACCESS nedeniyle olduğu doğrulanabilir. Biz aşağıdaki örnekte bu yola gitmiyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (access(argv[1], F_OK) == 0)
        printf("file exists...\n");
    else {
        printf("file doesn't exist!...\n");
        exit(EXIT_SUCCESS);
    }
    if (access(argv[1], R_OK) == 0)
        printf("read access ok...\n");
    else
        printf("can't read...\n");

    if (access(argv[1], W_OK) == 0)
        printf("write access ok...\n");
    else
        printf("can't write...\n");

    if (access(argv[1], X_OK) == 0)
        printf("execute access ok\n...");
    else
        printf("can't execute...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    access fonksiyonunun GNU libc kütüphanesinde prosesin etkin kullanıcı is'sini ve etkin grup id'sini kullanarak test eden 
    euidaccess ve eaccess (ikisi aynı şeyi yapmaktadır) versiyonları da bulunmaktadır. Ancak bu iki fonksiyon POSIX standartlarında 
    yoktur. Dolayısıyla taşınabilir programlar için bu konuya dikkat edilmesi gerekir.

    #define _GNU_SOURCE            /* See feature_test_macros(7) */
    #include <unistd.h>

    int euidaccess(const char *pathname, int mode);
    int eaccess(const char *pathname, int mode);

    Bu fonksiyonların semantiği etkin kullanıcı id'sini ve grup id'sini kullanmalarının dışında bir farklılık içermemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    access fonksiyonunun faccassat isminde "at"li bir versiyonu da vardır. Bu versiyonda aynı zamanda istenirse gerçek kullanıcı ve 
    grup id'leri yerine etkin kullanıcı ve grup id'leri de işleme sokulabilmektedir. Fonksiyonun parametrik yapısı şöyledir:

    #include <fcntl.h>

    int faccessat(int fd, const char *path, int amode, int flag);

    Fonksiyonun birinci parametresi ikinci parametresiyle belirtilen yol ifadesinin göreli olması durumunda aramanın yapılacağı 
    dizini belirtmektedir. Son parametre 0 geçilebilir ya da AT_EACCESS geçilebilir. Bu AT_EACCESS değeri test işleminin etkin kullanıcı ve grup 
    id'lerine bakılarak yapılacağı anlamına gelmektedir. (Tabii ikinci parametre ile belirtilen yol ifadesi mutlak olduğunda birinci parametrede 
    belirtilen dizine ilişkin betimleyici yine dikkate alınmaz. Ancak üçüncü parametreyle belirtilen bayrak dikkate alınır)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (faccessat(AT_FDCWD, argv[1], F_OK, AT_EACCESS) == 0)
        printf("file exists...\n");
    else {
        printf("file doesn't exist!...\n");
        exit(EXIT_SUCCESS);
    }
    if (faccessat(AT_FDCWD, argv[1], R_OK, AT_EACCESS) == 0)
        printf("read access ok...\n");
    else
        printf("can't read...\n");

    if (faccessat(AT_FDCWD, argv[1], W_OK, AT_EACCESS) == 0)
        printf("write access ok...\n");
    else
        printf("can't write...\n");

    if (faccessat(AT_FDCWD, argv[1], X_OK, AT_EACCESS) == 0)
        printf("execute access ok\n...");
    else
        printf("can't execute...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi "dosya betimleyici tablosu (file descriptor table)" proses kontrol blok yoluyla erişilebilen dosya nesnelerinin 
    adreslerinin tutulduğu bir gösterici dizisi biçimindeydi. İşletim sisteminin çekirdeği ne zaman bir dosya açılsa o dosya için
    bir dosya nesnesi (Linux'ta "file" yapısı) yaratıp dosya betimleyici tablosunda bir slotun o nesneyi göstermesini sağlıyordu. 
    Zaten "dosya betimleyicisi (file descriptor)" de dosya betimleyici tablosunda bir indeks belirtiyordu. Linux çekirdeklerinde 
    buradaki veri yapıları zamanla biraz değiştirilmiştir. Güncel çekirdekte proses kontrol bloktan dosya nesnesine erişim birkaç 
    yapıdan geçilerek yapılmaktadır:

    task_struct (files) ---> files_struct (fdt) ---> fdtable (fd) ---> file * türünden bir dizi ---> file

    Genellikle bir proses çalışmaya başladığında ilk üç betimleyici doludur. Bu betimleyicilere sırasıyla "stdin", "stdout" ve "stderr"
    betimleyicileri denilmektedir. Bu ilk üç betimleyici için <unistd.h> dosyasında üç sembolik de bulundurulmuştur:

    #define STDIN_FILENO        0
    #define STDOUT_FILENO       1
    #define STDERR_FILENO       2

    Aygıt "sürücüler (device drivers)" dosya gibi açılarak kullanılmaktadır. (Yani bir aygıt sürücü de kullanılmadan önce "open" 
    fonksiyonuyla açılır, sonra "read" fonksiyonuyla ondan okuma yapılıp "write" fonksiyonu ile ona yazma yapabilir.) Dolayısıyla 
    bir dosya nesnesi bir disk dosyasına ilişkin olabileceği gibi bir aygıt sürücüs dosyasına da ilişkin olabilir. Örneğin biz 
    bir betimleyiciden read fonksiyonu ile okuma yapmak istediğimizde sistem eğer bu betimleyicinin gösterdiği dosya nesnesi bir 
    disk dosyasına ilişkinse bizim dosyadan okuma yapmamızı sağlar. Ancak bir aygıt sürücüye ilişkinse bu durumda sistem o aygıt 
    sürücünün "read" fonksiyonunu çağırır. Yani aygıt sürücülerin içerisinde "read" yapıldığında "write" yapıldığında çağrılacak 
    fonksiyonlar vardır. İşte örneğin biz 0 numaralı betimleyiciden okuma yapmak istediğimizde aslında "terminal aygıt sürücüsünün" 
    "read" fonksiyonu çağrılmaktadır. 0 numaralı betimleyici O_RDONLY modunda açılmıştır. Terminal aygıt sürücüsünün "read" fonksiyonu 
    da bize klavyeden okunanları verir. Program çalışmaya başladığında 1 ve 2 numaralı betimleyicilerin her ikisi de aynı dosya 
    nesnesini göstermektedir. Bu dosya da O_WRONLY modunda açılmıştır. Bu dosya nesneleri de yine "terminal aygıt sürücüsüne" 
    ilişkindir. Dolayısıyla biz write işlemi yaptığımızda aslında terminal aygıt sürücüsünün "write" fonksiyonunu çağırmış oluruz. 
    O da bilgileri imlecin bulunduğu noktadan itibaren ekrana yazar. Burada stdout ve stderr betimleyicilerinin aynı dosya nesnesini 
    gösterdiğine dikkat ediniz. Dolayısıyla bu betimleyiciler kullanıldığında yazdırılmak istenen şeyler ekrana çıkacaktır. 
    (O halde stdout ile stderr arasında ne farklılık vardır? İzleyen bölümlerde bu durum açıklanacaktır)

    open fonksiyonunun ilk boş betimleyici verdiği garanti edilmiştir. Yani örneğin programımız başladığında 0, 1 ve 2 numaralı 
    betimleyiciler dolu olduğuna göre open fonksiyonu bize 3 numaralı betimleyiciyi verecektir. Tabii dosyaları kapattığımızda 
    o betimleyicilere ilişkin slot'lar serbest bırakılır. Bu durumda open ilk boş betimleyiciyi bize verir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosya betimleyici tablosunda iki dosya betimleyicisi aynı dosya nesnesini gösteriyorsa bu duruma "dosya betimleyicilerinin 
    çiftlenmiş (duplicate) olması" denilmektedir. Bu durumda bizim bu betimleyicilerden hangisini kullandığımız bir önemi kalmamaktadır. 
    Pekiyi böyle bir durumda bir betimleyiciyi close fonksiyonuyla kapattığımızda ne olacaktır? İşte dosya nesnelerinin içerisinde 
    bir sayaç bulunmaktadır. close fonksiyonu bu sayacın değerini bir eksiltir. Dosya nesnesinin silinmesi sayaç 0'a düştüğünde
    yapılmaktadır. O halde close her durumda betimleyici slotunu boşaltır. Ancak dosya nesnesinin referans sayıcını bir eksilttikten 
    sonra eğer referans sayacı 0'a düşmüşse dosya nesnesini siler. Aşağıda Linux'un güncel çekirdeğindeki dosya nesnesi verilmiştir. 
    Buradaki f_count elemanı bu sayacı belirtmektedir:

    struct file {
        union {
            struct llist_node    f_llist;
            struct rcu_head     f_rcuhead;
            unsigned int         f_iocb_flags;
        };
        struct path        f_path;
        struct inode        *f_inode;    /* cached value */
        const struct file_operations    *f_op;

        /*
        * Protects f_ep, f_flags.
        * Must not be taken from IRQ context.
        */
        spinlock_t        f_lock;
        atomic_long_t        f_count;
        unsigned int         f_flags;
        fmode_t            f_mode;
        struct mutex        f_pos_lock;
        loff_t            f_pos;
        struct fown_struct    f_owner;
        const struct cred    *f_cred;
        struct file_ra_state    f_ra;

        u64            f_version;
    #ifdef CONFIG_SECURITY
        void            *f_security;
    #endif
        /* needed for tty driver, and maybe others */
        void            *private_data;

    #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct hlist_head    *f_ep;
    #endif /* #ifdef CONFIG_EPOLL */
        struct address_space    *f_mapping;
        errseq_t        f_wb_err;
        errseq_t        f_sb_err; /* for syncfs */
    };

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir betimleyicinin gösterdiği dosya nesnesini gösteren yeni bir betimleyici oluşturulabilir. Bunun için dup ve dup2 
    isimli POSIX fonksiyonları kullanılmaktadır. dup fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int dup(int fildes);

    Fonksiyon parametre olarak açık bir dosyanın betimleyicisini alır, o betimleyicinin gösterdiği dosya nesnesini gösteren 
    yeni bir betimleyici oluşturup o betimleyiciye geri döner. Fonksiyon başarısızlık durumunda -1'e geri dönmektedir. dup 
    fonksiyonunun en düşük boş betimleyici slotunu tahsis etmesi garanti edilmiştir.

    Açık dosyanın tüm bilgileri dosya nesnesinin içerisinde olduğuna göre iki betimleyici aynı dosya nesnesini gösteriyorsa 
    örneğin aynı dosya göstericisine sahip gibi davranırlar. Aşağıdaki programda dup fonksiyonuna bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int fd2;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd2 = dup(fd)) == -1)
        exit_sys("dup");

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    if ((result = read(fd2, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    close(fd2);
    close(fd);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    dup2 isimli POSIX fonksiyonu dup fonksiyonunun biraz daha ayrıntılı biçimidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int dup2(int fildes, int fildes2);

    Bu fonksiyon yine birinci parametresiyle belirtilen betimleyici çiftlemek için kullanılmaktadır. Ancak bu fonksiyon
    ilk boş betimleyici ile değil ikinci parametresiyle belirtilen betimleyici ile geri dönmek ister. Yani biz istersek 
    bu fonksiyon sayesinde istediğimiz bir betimleyicinin birinci parametresiyle belirtilen betimleyici ile aynı dosya nesnesini 
    göstermesini sağlayabiliriz. Eğer ikinci parametresiyle belirtilen betimleyici zaten açık bir dosyaya ilişkinse bu durumda 
    dosya önce kapatılır, sonra o betimleyicinin birinci parametresiyle belirtilen betimleyicinin gösterdiği dosya nesnesini 
    göstermesi sağlanır. Fonksiyon başarı durumunda ikinci parametresiyle belirtilen betimleyicinin aynısına, başarısızlık durumunda 
    -1 değerine geri dönmektedir. Tabii fonksiyon birinci ve ikinci parametresinin aynı betimleyiciye ilişkin olduğunu da kontrol 
    etmektedir. Bu durumda bir şey yapmadan başarılı olur. Fonksiyonun iki argümanı aynı betimleyiciyi belirtiyorsa dup2 hiçbir 
    şey yapmaz, argümanlarla belirtilen betimleyiciye geri döner.

    Aşağıda dup2 fonksiyonunun kullanımına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int fd2;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd2 = dup2(fd, 25)) == -1)
        exit_sys("dup");

    printf("fd = %d, fd2 = %d\n", fd, fd2);

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    if ((result = read(fd2, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    close(fd2);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                20. Ders 07/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Dosyalar konusundaki önemli bir alt konu da "IO Yönlendirmesi (IO Redirection)" denilen konudur. IO yönlendirmesi teknik 
    olarak bir dosya betimleyicisinin gösterdiği dosya nesnesinin değiştirilmesi işlemidir. Bu sayede bir kişi belli bir dosya 
    üzerinde işlem yaptığını sanırken aslında başka bir dosya üzerinde işlem yapar hale gelmektedir. IO yönlendirmesi en çok 
    "stdin", "stdout" ve "stderr", dosyaları üzerinde uygulanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir proses yaratıldığında genellikle işin başında 0, 1 ve 2 numaralı betimleyiciler zaten dolu durumdadır. 
    UNIX/Linux dünyasında 0 numaralı betimleyiciye "stdin" betimleyicisi, "1 numaralı betimleyiciye "stdout" betimleyicisi ve 
    2 numaralı betimleyiciye ise "stderr" betimleyicisi denilmektedir. Bir dosya betimleyicisinin gösterdiği dosya nesnesi 
    bir disk dosyasına ilişkin olabileceği gibi bir "aygıt sürücü (device driver)" dosyasına ilişkin de olabilmektedir. 
    Gerçekten de 0, 1 ve 2 numaralı betimleyicilerin gösterdiği dosya nesneleri "terminal aygıt sürücüsüne" ilişkindir.

    Bir aygıt sürücü kernel mode'da çalışan bir kod topluluğudur. Bir dosya betimleyicisi bir aygıt sürücüsüne ilişkinse bu betimleyici 
    ile read fonksiyonu çağrıldığında aygıt sürücüsünü yazanların "read" olarak tanımladıkları fonksiyon çağrılmaktadır. Benzer 
    biçimde bir aygıt sürücüsüne ilişkinse bu betimleyici ile write fonksiyonu çağrıldığında aygıt sürücüsünü yazanların "write" 
    diye tanımladıkları fonksiyon çağrılmaktadır.

    0 numaralı stdin betimleyicisi "read-only" modda açılmış durumdadır. Benzer biçimde 1 ve 2 numaralı betimleyiciler de 
    "write-only" modda açılmış durumdadır. 0 numaralı betimleyiciden okuma yapılmak istendiğinde aygıt sürücüsünün okuma fonksiyonu 
    çalıştırılır ve bu fonksiyon da aslında klavyeden okunanları bize verir. 1 ve 2 numaralı betimleyiciler dup yapılmış durumdadır. 
    Yani bu betimleyiciler aynı dosya nesnesini göstermektedir. Bu betimleyicilerle yazma işlemi yapılırsa aygıt sürücülerin yazma 
    fonksiyonları devreye girer ve bu fonksiyonlar da yazdırılacak şeyleri ekrana çıkartırlar.

    Görüldüğü gibi aygıt sürücüler sanki bir dosyaymış gibi ele alınmaktadır. Bunun önemli faydaları vardır. Yani programcı bu 
    sayede "sanki klavye ve ekran birer dosyaymış gibi" dosya fonksiyonlarını kullanarak onlarla işlem yapabilmektedir.

    Aşağıdaki örnekte 0 numaralı stdin betimleyicisinden read fonksiyonuyla okuma yapılmış ve okunanlar 1 numaralı stdout 
    betimleyicisine yazılmıştır. Biz read fonksiyonuyla stdin dosyasından okuma yapmak istediğimizde read fonksiyonu ENTER tuşuna 
    basılına kadarki klavyeden girilenleri bize vermektedir.

    <unistd.h> dosyasında okunabilirliği artırmak için şu sembolik sabitler bildirilmiştir:

    #define STDIN_FILENO        0
    #define STDOUT_FILENO       1
    #define STDERR_FILENO       2

    Bir program çalışmaya başladığında 0, 1 ve 2 numaralı betimleyiciler zaten hazır durumdadır. Bu betimleyicileri programcı 
    oluşturmamıştır. O halde bu betişmleyicilerin kapatılmasını da programcı yapmamalıdır. Buradaki mekanizma ileride ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    char buf[4096];
    ssize_t result;

    if ((result = read(0, buf, 4096)) == -1)
        exit_sys("read");

    if (write(1, buf, result) == -1)
        exit_sys("write");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    C'nin <stdio.h> dosyası içerisinde prototipleri bulunan stdin ve stdout dosyaları üzerinde işlem yapan "scanf", "puts", 
    "printf" gibi fonksiyonları eninde sonunda read ve write fonksiyonlarını 0 ve 1 numaralı betimleyicilerle çağırarak işlemlerini 
    yapmaktadır. Zaten bu sistemlerde ekrana bir şey yazdırmak için klavyeden bir şey okumak için başka bir yol yoktur. Örneğin 
    biz printf fonksiyonu ile ekrana bir şeyler yazdırmak istediğimiz zaman aslında printf önce yazdırılacak yazıyı bir dizide 
    oluşturur sonra write fonksiyonunu 1 numaralı betimleyici ile çağırır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte biz close(1) ile 1 numaralı betimleyicinin gösterdiği terminal aygıt sürücüsüne ilişkin dosyayı kapattık. 
    Sonra da open fonksiyonu ile yeni bir dosyayı açtık. open fonksiyonu en düşük boş betimleyiciyi vereceğine göre artık 
    1 numaralı betimleyici terminal aygıt sürücüsüne ilişkin dosya nesnesini değil bizim açtığımız dosya nesnesini gösteriyor
    durumda olacaktır. Daha bu örnekte biz printf fonksiyonu ile ekrana bir şeyler yazdık. printf eninde sonunda write(1, ...)
    çağrısıyla ekrana bir şeyler yazdırmak isteyeceğine göre artık printf ekrana değil bizim açtığımız dosyaya yazma yapacaktır. 
    IO yönlendirmesinin temel mekanizması bu biçimdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    close(1);

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    IO yönlendirmesinin yukarıdaki gibi yapılmasının iki önemli problemi vardır:

    1) Bu yönlendirme aynı biçimde yüksek numaralı betimleyiciler için yapılmak istenirse o betimleyicilerden önce boş boş 
    betimleyicilerin bulunuyor olma olasılığı yükselir. Dolayısıyla open istediğimiz betimleyiciyi değil başka bir betimleyiciyi 
    tahsis edebilir.

    2) Çok thread'li programlarda close işleminden sonra henüz open yapılmadan önce başka bir thread dosya açarsa bu betimleyiciyi 
    o thread kapabilir. Çünkü close ile open işlemleri atomik değildir.

    IO yönlendirmesi daha sağlıklı bir biçimde dup2 fonksiyonuyla yapılabilir. Anımsanacağı gibi dup2(fd1, fd2) işleminde 
    fd2 betimleyicisi fd1 betimleyicisi ile aynı dosya nesnesini gösterir hale getirilmektedir. fd2 zaten açık bir dosyaya 
    ilişkinse önce o betimleyici üzerinde atomik bir biçimde close işlemi uygulanmaktadır. dup2 fonksiyonun en düşük betimleyiciyi 
    değil, ikinci parametresiyle belirtilen betimleyiciyi yönlendirdiğine dikkat ediniz. O halde örneğin 1 numaralı betimleyici 
    şöyle yönlendirilebilir:

    int fd;
    ...

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    Burada dup2 ile birlikte hem 1 numaralı betimleyicinin hem de fd numaralı betimleyicinin yeni açılan dosyaya ilişkin dosya 
    nesnesini gösterdiğine dikkat ediniz. fd betimleyicisini kapatmak doğru tekniktir. 1 numaralı betimleyici zaten ileride de 
    ele alınacağı gibi proses bittiğinde kapatılmaktadır.

    Burada gerçekleşmesi beklenmeyen bir küçük nokta üzerinde de durmak istiyoruz. Bizim open fonksiyonuyla yönlendirilecek dosyayı
    açtığımız durumda ya stdout dosyası zaten kapatılmışsa ne olacaktır? İşte bu durumda close işlemi bizim için sorun oluşturur. 
    Şöyle ki bu durumda open fonksiyonu en düşük betimleyici olan 1 numaralı betimleyiciyi tahsis edecektir. dup2(fd, 1) çağrısında 
    her iki betimleyici de aynı olduğu için dup2 bir şey yapmayacaktır. Ancak bundan sonda fd betimleyicisinin kapatılması aslında 
    1 numaralı betimleyicinin kapatılması anlamına gelecektir. Yani sakıncalı bir durum oluşaçaktır. Bu sakıncalı durum aşağıdaki 
    gibi bir kontrolle elimine edilebilir:

    int fd;
    ...

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");
    if (fd != 1) {
        if (dup2(fd, 1) == -1)
            exit_sys("dup2");
        close(fd);
    }

    Tabii programcının genellikle böyle bir kontrol yapmasına gerek yoktur. Çünkü içinde bulunduğu durumda 1 numaralı betimleyicinin 
    stdout dosyasını göstermesi normal bir durumdur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (fd != 1) {                /* kontrol özel bir durum yoksa gerekmemektedir */
        if (dup2(fd, 1) == -1)
            exit_sys("dup2");

        close(fd);
    }

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte biz 1 numaralı betimleyicinin bizim dosyamıza ilişkin dosya nesnesini göstermesini sağladık. Pekiyi 
    bundan geri dönebilir miyiz? Yani 1 numaralı betimleyicinin yeniden terminale ilişkin aygıt sürücüsünü göstermesini sağlayabilir 
    miyiz? Anımsanacağı gibi 1 ve 2 numaralı betimleyicilerin her ikisi de terminal aygıt sürücüsüne ilişkin dosya nesnesini 
    belirtiyordu. İşte biz bu sayede geri dönüşü aşağıdaki gibi yapabiliriz:

    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    ...

    if (dup2(2, 1) == -1)
        exit_sys("dup2");

    Aşağıdaki örnekte bu işlem uygulanmıştır. Ancak burada bir fflush çağırması da yapılmıştır. Bunun nedeni izleyen konularda
    anlaşılabilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    fflush(stdout);

    if (dup2(2, 1) == -1)
        exit_sys("dup2");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi yukarıdaki örnekte 2 numaralı betimleyici bir biçimde yönlendirilmişse ya da close edilmişse geri dönüş nasıl 
    sağlanabilir? Burada artık işleme başlamadan önce dup işlemi ile 1 numaralı betimleyicinin gösterdiği dosya nesnesini 
    gösteren başka bir yedek betimleyicinin oluşturulması gerekir. Aşağıda bu duruma örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd, fd_stdout;

    close(2);

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if ((fd_stdout = dup(1)) == -1)
        exit_sys("dup2");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    fflush(stdout);

    if (dup2(fd_stdout, 1) == -1)
        exit_sys("dup2");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de 0 numaralı betimleyiciyi yönlendirelim. Eğer biz 0 numaralı betimleyiciyi bir dosyaya yönlendirirsek bu durumda 
    klavyeden (stdin dosyasından) okuma yaptığını sanan standart C fonksiyonları aslında bu dosyadan okuma yapacaktır. Yani 
    adeta sanki bu dosyanın içindekiler klavyeden girilmiş gibi bir etki oluşturacaktır. Aşağıdaki örnekte "test.txt" dosyasının 
    içeriği şöyledir:

    10 20
    30 40
    50
    60
    70
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int val;

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    if (fd != 0) {        /* özel bir durum yoksa bu kontrole gerek yok */
        if (dup2(fd, 0) == -1)
            exit_sys("dup2");
        close(fd);
    }

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    IO yönlendirmesi kabuk üzerinden de yapılabilmektedir. Kabukta ">" sembolü 1 numaralı betimleyicinin yönlendirileceği 
    anlamına gelmektedir. Örneğin:

    $ ./sample > test.txt

    Bu durumda kabuk önce ">" sembolünün sağındaki dosyayı O_WRONLY|O_TRUNC modunda açar. Sonra ./sample programını çalıştırarak 
    bu prosesin 1 numaralı betimleyicisini dup2 fonksiyonu ile bu dosyaya yönlendirir. Böylece ./sample, sample programının 
    ekrana yazdığını zannettiği şeyler bu dosyaya yazılmış olacaktır.

    ls gibi, cat gibi kabuk komutlarının da aslında birer program olduğuna bunların da 1 numaralı betimleyiciyi kullanarak yazdırma 
    yaptığına dikkat ediniz. Örneğin biz kabuk üzerinde şu komutu uygulayabiliriz:

    $ ls -l > test.txt

    Eğer kabukta ">" yerine ">>" sembolü kullanılırsa bu durumda ">>" sembolünün sağındaki dosya O_CREAT|O_WRONLY|O_APPEND modunda 
    açılmaktadır. Yani dosya varsa bu durumda olan dosyanın sonuna ekleme yapılacaktır. Örneğin:

    $ ls -l >> test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kabuk üzerinde "<" sembolü de 0 numaralı betimleyiciyi yönlendirmektedir. Örneğin:

    $ ./sample < test.txt

    Burada kabuk "test.txt" dosyasını O_RDONLY modda açar. Sonra ./sample programını çalıştırır. Prosesin 0 numaralı betimleyicisini
    "test.txt" dosyasına dup2 fonksiyonuyla yönlendirir. Böylece program sanki klavyeden okuduğunu sanırken aslında dosyadan
    okuma yapacaktır. Aşağıdaki örnekte programın "sample.c" olduğunu kabul edelim. "test.txt" dosyasının içeriği de şöyle olsun:

    10 20
    30 40
    50
    60
    70

    Programı kabuktan aşağıdaki gibi çalıştırıp sonucu inceleyiniz:

    $ ./sample < test.txt
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    int val;

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında kabukta genel olarak yönlendirme için "n>" ve "n<" sembolleri de kullanılabilmektedir. Buradaki n betimleyicinin 
    numarasını belirtir. Bu sayede biz herhangi bir betimleyiciyi okuma ve yazma amaçlı bir dosyaya yönlendirebiliriz. Örneğin:

    $ ./sample 2> test.txt

    Burada "test.txt" dosyası açılıp ./sample programının "stderr" olarak isimlendirilen 2 numaralı betimleyicisi bu dosyaya 
    yönlendirilecektir.

    Kabuk programları ">", "<", "n>" "n<" gibi yönlendirmeleri nasıl yapmaktadır? Bu konu ileride ele alınacaktır. Kabuk önce 
    bir kez fork işlemi yapar. Sonra yönlendirme işlemini gerçekleştirir. Sonra da exec işlemi yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii hem stdout dosyasını hem de stdin dosyasını kabuk üzerinden birlikte de yönlendirebiliriz. Örneğin:

    $ ./sample > out.txt < in.txt

    Burada 1 numaralı betimleyici "out.txt" dosyasına, 0 numaralı betimleyici "in.txt" dosyasına yönlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüler yine open fonksiyonuyla açılmaktadır. open fonksiyonunda aygıt sürücüyü temsil eden bir dizin girişi 
    belirtilie. Örneğin:

    fd = open("/dev/null", O_WRONLY);

    Ancak bu dizin girişi gerçek bir dosya değildir. Bu giriş için yalnızca bir i-node elemanı bulundurulmaktadır. İşletim 
    sistemi böyle bir dosya açılmaya çalışıldığında aslında "bir aygıt sürücü ile işlem yapılmak istendiğini" anlamaktadır. 
    Yani aygıt sürücü bir dosya gibi açılıyor olsa da aslında onun bir dosyayla ilgisi yoktur. Aygıt dosyaları (örneğimizdeki 
    "dev/null" dosyası) dummy bir dosyadır. Aslında kernel içerisindeki aygıt sürücüyü temsil etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi stderr dosyası ne anlama gelmektedir? Anımsanacağı gibi stderr 2 numaralı betimleyici ile temsil edilmektedir. 1 
    ve 2 numaralı betimleyiciler dup yapılmış durumdadır. Yani her iki betimleyici ile de write yapıldığında yazılanlar ekrana 
    çıkacaktır. O halde stderr dosyasının ne anlamı vardır? 

    C'de stdin, stdout ve stderr isimli değişkenler betimleyici belirtmezler. Bu değişkenler FILE * türündendir. Tabii stdin 
    UNIX/Linux sistemlerinde 0 numaralı betimleyici ile stdout 1 numaralı betimleyici ile stderr de 2 numaralı betimleyici ile 
    ilişkilidir. Biz C'de stderr dosyasına fprintf fonksiyonu ile aşağıdaki gibi bir şeyler yazabiliriz:

    fprintf(stderr, "stderr\n");

    Tabii aslında bilindiği gibi printf ile fprintf arasında, scanf ile fscanf arasındaki tek farklılık printf ve scanf 
    fonksiyonlarının default olarak stdout ve stdin dosya bilgi göstericilerini kullanmasıdır. Yani örneğin printf(...) çağrısı 
    tamamen fprintf(stdout, ...) çağrısı eşdeğerdir. Benzer biçimde scanf(...) çağrısı ile de fscanf(stdin, ...) eşdeğerdir.

    Programcı hata mesajlarını her zaman "stderr" dosyasına yazdırmalıdır. Bu iyi bir tekniktir. Örneğin:

    if ((f = fopen("test.txt", "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    Böylece ileride gerekirse programın normal çıktılarıyla hata mesajları IO yönlendirmesiyle birbirinden ayrılabilir. 
    Tabii biz IO yönlendirmesi yapmadıktan sonra programın normal mesajlarıyla hata mesajlarının her ikisi de ekrana çıkacaktır. 
    Aşağıdaki gibi bir program olsun:

    /* sample.c */

    #include <stdio.h>

    int main(void)
    {
        fprintf(stderr, "stderr\n");
        fprintf(stdout, "stdout\n");

        return 0;
    }

    Biz bu programı çeşitli biçimlerde çalıştıralım:

    $ ./sample
    stderr
    stdout
    $ ./sample > test.txt
    stderr
    $ ./sample 2> test.txt
    stdout

    Görüldüğü gibi biz programın hata mesajları ile normal mesajları artık ayırabilmekteyiz. Eğer her mesayı printf ile stdout
    dosyasına yazdırsaydık bunun imkanı olmayacaktı.

    Örneğin biz find programı ile "sample.c" dosyasını dizin ağacında aramak isteyelim:

    $ find / -name "sample.c"

    Burada erişilemeyen dizinler için find programı bir sürü hata mesajını stderr dosyasına yazdırcaktır. Dolayısıyla kafamız
    karışacaktır. Şimdi programı şöyle çalıştıralım:

    $ find / -name "sample.c" 2> test.txt

    Artık hata mesajları ekranda görünmeyecektir. Bu tür durumlar için /dev/null isimli bir aygıt sürücü bulundurulmuştur. Bu 
    aygıt sürücü açılırsa ve ona yazma yapılırsa yazılanlar atılmaktadır. O halde programın yazdığı hata mesajları gereksiz yer 
    kaplamasın diye biz yönlendirmeyi /dev/null aygıt sürücüsüne yapabiliriz. Örneğin:

    $ find / -name "sample.c" 2> /dev/null

    /dev/null aygıt sürücüsünden okuma yapılmaya çalışılırsa sanki dosya sonuna gelinmiş (yani EOF durumuna gelinmiş) gibi bir 
    durum oluşur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                21. Ders 08/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    "/dev/zero" aygıt sürücüsü "/dev/null" aygıt sürücüsüne çok benzemektedir. "/dev/zero" aygıt sürücüsüne yazılanlar da 
    atılır. Ancak bu aygıt sürücüden okuma yapıldığında hep sıfır okunmaktadır. Aşağıdaki örnekte bu aygıt sürücü açılıp 
    okuma yapılmıştır. Burada standart C fonksiyonlarını kullanmanın bizim için bir dezavantajı yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    int ch;

    if ((f = fopen("/dev/zero", "rb")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((ch = fgetc(f)) == EOF) {
            fprintf(stderr, "cannot read from file!...\n");
            exit(EXIT_FAILURE);
        }
        printf("%d ", ch);
        fflush(stdout);
    }
    printf("\n");

    fclose(f);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    "/dev/random" ve "/dev/urandom" aygıt sürücüleri her okunduğunda rastgele byte'lar elde edilmektedir. Bu iki aygıt sürücü 
    arasında bazı küçük farklılıklar vardır. Ancak burada onun üzerinde durmayacağız. Ayrıca bu aygıt sürücülerden okumayı 
    pratik hale getirmek için Linux'a 3.17 çekirdeği ile birlikte "sys_getrandom" isimli bir sistem fonksiyonu da eklenmiştir. 
    Aşağıdaki örnekte bu aygıt sürücüden rastgele byte'lar okunup hex sistemde ekrana yazdırılmıştır. Program beklemelere yol 
    açarsa şaşırmayınız. Çünkü konunun bazı ayrıntıları vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    int ch;

    if ((f = fopen("/dev/random", "rb")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 256; ++i) {
        if ((ch = fgetc(f)) == EOF) {
            fprintf(stderr, "cannot read from file!...\n");
            exit(EXIT_FAILURE);
        }
        printf("%02X%c", ch, i % 16 == 15 ? '\n' : ' ');
        fflush(stdout);
    }
    printf("\n");

    fclose(f);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Komut satırındaki diğer önemli bir işlem de "boru (pipe)" işlemidir. Boru işlemi "|" ile temsil edilmektedir. Kabuk üzerinden
    aşağıdaki gibi bir komut uygulamış olalım:

    a | b

    Burada kabuk bu yazıyı "|" karakterinden parse eder. "|" karakterinin solundaki ve sağındakileri birer program olarak ele alır. 
    Her iki programı da çalışırır. Yani burada "a" programı da "b" programı da çalıştırılacaktır. "a" programının "stdout" dosyasına
    yazdıklarını "b" programı "stdin" dosyasından okuyacaktır. Başka bir deyişle "a" programının 1 numaralı betimleyiciyle yaptığı write 
    işlemlerini "b" programı 0 numaralı betimleyici ile read fonksiyonunu kullanarak okuyabilecektir. Kabuk boru işlemlerini
    "prosesler arası haberleşme yöntemlerinden biri olan boru haberleşmesi ile" gerçekleştirmektedir. Zaten ilerleyen bölümlerde 
    bu konu ele alınacaktır.

    Tabii boru işlemi yapılırken programların komut satırı argümanları da verilebilir. Örneğin:

    a b c | d e f

    Burada aslında çalıştırılacak programlar "a" ve "d" programlarıdır. Diğerleri bunların komut satırı argümanlarıdır.

    Aşağıdaki örnekte "a" programı ekrana (stdout dosyasına) 0'dan 10'a kadar sayıları yazdırmaktadır. "b" programı ise
    döngü içerisinde klavyeden (stdin dosyasından) değer okuyup ekrana yazdırmaktadır. Bu iki programı aşağıdaki gibi çalıştıralım:

    $ ./a | ./b

    Burada artık a'nın ekrana yazdıklarını sanki b klavyeden okuyormuş gibi bir etki oluşacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>

int main(void)
{
    for (int i = 0; i < 10; ++i)
        printf("%d\n", i);

    return 0;
}

/* b.c */

#include <stdio.h>

int main(void)
{
    int val;

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerindeki dosya yol ifadesi alan POSIX kabuk komutları eğer doys yol ifadesi verilmezse genellikle "stdin" 
    dosyasından okuma yapacak biçimde yazılmışlardır. Örneğin "cat" komutu bir dosyanın içeriğini stdout dosyasına yazdırır:

    $ cat test.txt

    Ancak bu "cat" komutu argümansız kullanılırsa okumayı "stdin" dosyasından yapar. Örneğin "wc" isimli kabuk komutu normal olarak
    bir dosyayı argüman olarak alır ve o dosyadaki satır sayısını, sözcük sayısını ve byte sayısını stdout dosyasına yazdırır. 
    Ancak bu program komut satırı argümanı verilmeden kullanılırsa klavyeden (stdin dosyasından) okuma yapacaktır. Bu biçimdeki 
    tasarımın nedeni bu komutların "boru" eşliğinde kullanımını sağlamaktır. Örneğin:

    $ ps -e | wc

    Burada "ps -e" komutu satır satır sistemdeki prosesleri "stdout" dosyasına yazmaktadır. "wc" komutuna argüman verilmediğinde 
    göre bu komut "stdin" dosyasından okuma yapacaktır. O halde bu durumda aslında "ps -e" komutunun ekrana yazdıklarını "wc" 
    komutu işleme sokacaktır.

    Örneğin bir çıktıyı sayfa sayfa görüntülemek için "more" isimli bir komut bulunmaktadır. "more" programı normalde bir dosyayı 
    argüman olarak alır. Ancak eğer dosya verilmezse bu durumda "more" stdin dosyasından okunanları sayfa sayfa görüntüler. 
    Biz de bu sayede aşağıdaki gibi faydalı işlemler yapabiliriz:

    $ ps -e | more

    Burada "ps -e" komutunun ekrana yazdırdıkları sayfa sayfa görüntülenecektir.

    Pekiyi "|" karakterinin sağındaki program tdin dosyasından okuma yapmıyorsa ne olur? Örneğin:

    $ ps -e | wc sample.c

    Burada "wc" komutu artık stdin dosyasından okuma yapmayacaktır. Bu durumda yine "ps -e" komutunun çıktısı boruya yönlendirilir. 
    Ancak "sample.c" stdin dosyasından okuma yapmadığı için "ps e" komutunun ekrana yazdıklarını işleme sokmayacaktır.

    Boru işlemleri yinelemeli olarak yapılabilir. Örneğin:

    a | b | c

    Burada "a" programının stdout dosyasına yazdıklarını "b" programı stdin dosyasından okuyacaktır. "b" programının da stdout 
    dosyasına yazdıklarını "c" programı stdin dosyasından okuyacaktır.

    Eğer boru mekanizması olmasaydı yukarıdaki işlemler yine yapılabilirdi. Ancak bu durumda geçici dosyaların oluşturulması gerekirdi. 
    Örneğin:

    $ ps -e > temp.txt
    $ wc temp.txt
    $ rm temp.txt
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Çok prosesli (multiprocessing) işletim sistemlerinin çalıştığı donanımlarda kullanılan mikroişlemcilerin "koruma mekanizması 
    (protection mechanism)" denilen bir özelliği vardır. Çok prosesleri sistemlerde bütün programlar o anda RAM'de bir biçimde 
    bulunmaktadır. Tabii işletim sisteminin kendisi de RAM'de bulunur. Bir programın göstericiler yoluyla kendi bellek alanının 
    dışına çıkarak başka bir prosesin bellek alanına erişmesi mutlaka engellenmesi gereken bir durumdur. Çünkü eğer bu durum 
    engellenmezse bir program başka bir programın bellek alanını bozabilir. Bu bozulma da o programın hatalı çalışmasına ya da 
    çökmesine yol açabilir. Program başka bir programın bellek alanını bozmasa bile oradaki programlar üzerinde casusluk faaliyetleri 
    yürütebilir. Buna ek olarak bazı makine komutları tamamen sistemin çökmesine yol açabilmektedir. Bir programın bu makine 
    komutlarını kullanmasının tüm sistemi çökertebileceği için önüne geçilmesi gerekir. İşte işlemcilerin koruma mekanizması bu 
    tür ihlallerin birinci elden işlemci tarafından tespit edilip engellenmesini sağlamaktadır.

    İşlemcilerin koruma mekanizmasının iki yönü vardır:

    1) Bellek Koruması
    2) Komut Koruması

    Bellek koruması bir prosesin kendi bellek alanının dışına erişimlerinin tespit edilmesine yönelik mekanizmadır. Komut koruması 
    ise sistemi çökertme potansiyeline sahip makine komutlarının kullanımının engellenmesine yönelik mekanizmadır.

    Tabii her türlü mikroişlemci böyle bir mekanizmaya sahip değildir. Ancak güçlü işlemcilerde bu mekanizma bulunmaktadır. 
    Örneğin Intel'in 80386 ve sonrası işlemcileri ARM'nin Cortex A serisi işlemcileri, Alpha işlemcileri, PowerPC işlemcileri, 
    Itanium işlemcileri bu mekanizmalarsa sahiptir. Mikrodenetleyiciler genel olarak küçük işlemciler oldukları için bu mekanizmaya 
    sahip değillerdir. Windows gibi Linux gibi macOS gibi işletim sistemleri bu mekanizmaya sahip olmayan işlemcilerin bulundurduğu 
    sistemlerde kullanılamazlar.

    Bir prosesin bellek korumasını ve komut korumasını ihlal etmesi birinci elde mikroişlemci tarafından tespit edilmektedir. 
    Mikroişlemci ihlali tespit eder ve işletim sistemine bildirir. İşletim sistemi de hemen her zaman programı sonlandırır.

    Öte yandan kernel içerisindeki kodların ve aygıt sürücülerin kodlarının bu koruma engeline takılmaması gerekmektedir. Kernel 
    belleğin her yerine erişebilmelidir. Çünkü programları bile belleğe yükleyen kernel'dır. Aynı zamanda kernel sistemi çökertme 
    potansiyelinde olan pek çok makine komutunu uygun bir biçimde kullanmaktadır. Benzer biçimde aygıt sürücüler de mecburen 
    bu tür makine komutlarını kullanmak zorundadırlar. İşte kernel kodlarının ve aygıt sürücü kodlarının bir biçimde bu koruma 
    mekanizmasından muaf olması gerekmektedir.

    İşlemcileri tasarlayanlar genellikle prosesler için iki çalışma modu tanımlamışlardır: "Kernel Mode" ve "User Mode".
    Eğer bir kod "kernel mode'da" çalışıyorsa işlemci koruma mekanizmasını o kod için işletmez. Böylece o kod her şeyi yapabilir. 
    Ancak eğer bir kod "user mode'da" çalışıyorsa işlemci o kod için koruma mekanizmasını işletmektedir. Normal programların hepsi 
    user mode'da çalışmaktadır. Ancak kernel kodları ve aygıt sürücüler (kernel modülleri) kernel mode'da çalışırlar.

    Bir programın "sudo" ile çalıştırılmasının (yani programın proses id'sinin 0 olmasının) bu konuyla hiçbir ilgisi yoktur. 
    Proses id'nin 0 olması yalnızca dosya erişimleri için avantaj sağlayabilmektedir. Yoksa biz bir programı "sudo" ile çalıştırsak 
    bile o program yine "user mode'da" çalıştırılmaktadır.

    Pekiyi biz kendi programımızı kernel mode'da çalıştıramaz mıyız? Bu sorunun yanıtı genel olarak "hayır" biçimindedir. Bunun tek 
    yolu "aygıt sürücü" ya da "kernel modül" denilen biçimde kod yazmaktır. Zaten aygıt sürücülerin en önemli özelliği onların 
    kernel mode'da çalışmasıdır. Tabii aygıt sürücüler ancak sistem yöneticisi tarafından bir parola eşiliğinde (yani sudo ile) 
    yüklenebilmektedir.

    Sistem fonksiyonları kernel'ın içerisindeki fonksiyonlardır. Dolayısıyla bu fonksiyonlar özel makine komutlarını kullanırlar ve 
    bellekte her yere erişebilirler. Aksi takdirde bu fonksiyonların yazılabilmesi mümkün değildir. Pekiyi bizim programlarımız
    user mode'da çalıştığına göre biz bir sistem fonksiyonunu çağırdığımızda ne olacaktır? İşte user mod bir proses bir sistem 
    fonksiyonunu çağırdığında prosesin modu otomatik olarak kernel mode'a geçirilmektedir. Böylece sistem fonksiyonu yine kernel 
    mode'da çalışmış olmaktadır. Sistem fonksiyonunun çalışması bittiğinde proses yine otomatik olarak user mode'a dönmektedir. 
    Örneğin Intel işlemcilerinde bu geçişi sağlayan mekanizmaya "kapı (gate)" denilmektedir. Tabii kapı yerleştirmek kernel mode'da 
    yapılabilecek ir işlemdir. Dolayısıyla user mod proses yalnızca zaten belirlenmiş olan kodları çalıştırmak üzere kernel mode'a 
    geçebilmektedir.

    Sistem fonksiyonlarını çağırmanın zamansal bir maliyeti vardır. Çünkü prosesin user mode'dan kernel mode'a geçmesi ve birtakım 
    gerekli kontrollerin kernel mode'da yapılması zaman kaybına yol açmaktadır. Örneğin:

    read(fd, (char *)0x123456, 10)

    Linux'ta read POSIX fonksiyonu doğrudan sys_read sistem fonksiyonunu çağıracaktır. Eğer bu sistem fonksiyonu ikinci parametreyle
    verilen adresi hiç kontrol etmezse koruma mekanizmasından da muaf olduğu için tuzağa düşecektir. İşte bu tür sistem fonksiyonları 
    kesinlikle adreslerin o prosesin alanı içerisinde olup olmadığını test ederler. Bunun gibi pek çok yapılması gereken irili ufaklı 
    kontroller vardır.

    O halde aslında bir proses yaşamının önemli bir kısmını user mode'da geçirirken bir kısmını da kernel mode'da geçirebilmektedir. 
    Örneğin "time" isimli kabuk komutuyla biz prosesin ne kadar zamanı kernel mode'da ne kadar zamanı user mode'da geçirdiğini görebiliriz:

    $ time ./sample

    real    0m0,189s
    user    0m0,185s
    sys    0m0,005s

    Burada "sys" kernel modu, "user" user modu ve "real" da toplam zamanı vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C'nin prototipleri <stdio.h> içerisinde olan ve başı "f" ile başlayan dosya fonksiyonları aslında birer "sarma fonksiyon 
    (wapper function)" gibidir. Biz bu fonksiyonları kullandığımızda arka planda bu fonksiyonlar UNIX/Linux ve macOS sistemlerinde 
    POSIX fonksiyonlarını, Windows sistemlerinde ise Windows API fonksiyonlarını kullanmaktadır. Tabi bu fonksiyonlar da ilgili 
    sistemdeki sistem fonksiyonlarını çağırmaktadır. Örneğin biz Linux sistemlerinde fopen fonksiyonunu kullanmış olalım:

    fopen (user mode) ---> open (user mode) ---> sys_open (kernel mode)

    fopen fonksiyonu bize FILE * türünden bir dosya bilgi göstericisi vermektedir. Aslında FILE typedef edilmiş bir yapıdır:

    typedef struct {
        ...
        ...
        ...
    } FILE;

    Pekiyi bu yapının içerisinde hangi bilgiler vardır? Bir kere fopen dosyayı gerçekte UNIX/Linux sistemlerinde open POSIX 
    fonksiyonunu kullanarak açtığına göre bir biçimde onun içerisinde open fonksiyonundan elde edilen dosya betimleyicisi bulunacaktır:

    typedef struct {
        ...
        int fd;
        ...
    } FILE;

    Standart dosya fonksiyonlarının en önemli özellikleri bir "cache sistemi" oluşturmalarıdır. Burada "cache" terimi daha 
    uygun olmasına karşın daha çok "tampon (buffer)" terimi kullanılmaktadır. Bu nedenle C'nin dosya fonksiyonlarına 
    "tamponlu (buffered) IO fonksiyonları" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda iki program verilmiştir. Bu iki program da bir dosyanın bütün karakterlerini ekrana yazdırmaktadır. "a.c" programı
    bu işlemi her defasında read fonksiyonu çağırarak yaparken "b.c" programı bir defasında 512 byte okuma yaparak okunanları 
    bir tampona yerleştirip oradan alıp yazdırmaktadır. Dolayısıyla "b.c" programının daha hızlı çalışması beklenir. Çünkü bu 
    program sistem fonksiyonlarını daha az çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char ch;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fd, &ch, 1)) > 0)
        putchar(ch);

    if (result == -1)
        exit_sys("read");

    putchar('\n');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* b.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

#define BUFSIZE        512

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFSIZE];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fd, buf, BUFSIZE)) > 0) {
        for (int i = 0; i < result; ++i)
            putchar(buf[i]);
    }

    if (result == -1)
        exit_sys("read");

    putchar('\n');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    İşte standart C fonksiyonları da yukarıdaki örnekte olduğu gibi sistem fonksiyonlarını daha az çağırmak için bir tampon
    kullanmaktadır. Biz örneğin fgetc fonksiyonu ile bir byte bile okumak istesek fgetc bir tamponluk bilgiyi okur ve bize 
    onun içerisinde bir byte'ı verir. Biz daha sonra yeniden fgetc fonksiyonunu çağırdığımızda fgetc zaten tamponda daha önce 
    okunmuş olan bilgi yığını olduğu için read fonksiyonu ile okuma yapmaz bize doğrudan tampondan verir. Tabii tampondaki 
    her byte okunduktan sonra (yani tamponun sonuna gelindiğinde) fgetc yeniden read fonksiyonunu çağıracak ve tamponu yeniden 
    dolduracaktır.

    fopen fonksiyonun geri döndürdüğü FILE türünden yapının içerisinde aslında bu tamponu yönetmek için gerekli olan bilgiler de 
    bulunmaktadır.

    Standart C fonksiyonlarının kullandıkları default tampon büyüklüğü <stdio.h> içerisinde BUFSIZ sembolik sabitiyle ifade 
    edilmiştir. (Tabii bu BUFSIZ değerini değiştirmenin bir anlamı yoktur. Kod çoktan derlenmiştir. Bu sembolik sabit sadece 
    dış dünyaya default durum hakkında bilgi vermek için bulundurulmuştur.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    printf("%d\n", BUFSIZ);        /* 8192 */

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Standart C fonksiyonlarının oluşturdukları bu tampon read/write bir tampondur. Yani yalnızca okuma sırasında da değil yazma 
    sırasında da kullanılmaktadır. Örneğin biz fputc fonksiyonu le bir byte'ı dosyaya yazmak istesek bu bir byte aslında bu 
    tampona yazılır. Bu tampon dolduğunda (bu konusunun ayrıntısı ele alınacaktır) ya da fflush fonksiyonu çağrıldığında ya da 
    en kötü olasılıkla fclose işlemi sırasında write fonksiyonu çağrılarak diske yazdırılır. Biz tampondaki bilginin aktarılmasını 
    garanti etmek için fflush fonksiyonu kullanabiliriz. Tampondaki bilginin write gibi bir fonksiyonla diske yazılması işlemine 
    dosya terminolojisinde "flush işlemi" denilmektedir. fflush fonksiyonunun kullanılabilmes için dosyanın "yazma modunda açılmış 
    olması (yani "w", "r+" gibi modlarda)" gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                22. Ders 14/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'nin dosya açmakta kullanılan fopen fonksiyonu bize FILE türünden bir yapı nesnesinin adresini vermektedir. 
    Bu FILE nesnesine "stream" de denilmektedir. Biz Derneğimizde buna genel olarak "dosya bilgi göstericisi" diyoruz. 
    İşte bu FILE yapısının içerisinde söz konusu bu tamponu yönetmek için de bilgiler bulunmaktadır. Örneğin FILE yapısının 
    içerisinde tipik olarak şu bilgiler bulunur:

    - İşletim sistemi düzeyinde okuma/yazma işlemleri için gereken dosya betimleyicisi
    - Tamponun başlangıç adresini tutan bir gösterici
    - Tampondaki aktif noktayı tutan bir gösterici
    - Tamponun uzunluğunu tutan bir eleman ya da tamponun sonunu tutan bir gösterici
    - Diğer bilgiler

    Pekiyi fopen tarafından bu FILE yapısı nasıl tahsis edilmektedir? Standart C kütüphanelerini yazanlar birkaç teknik 
    kullanabilmektedir. Birincisi doğrudan tahsisatın malloc fonksiyonu ile yapılmasıdır. Tabii bu durumda free işlemi fclose 
    fonksiyonu tarafından yapılacaktır. İkincisi bu FILE yapısı zaten işin başında static düzeyde tahsis edilmiş bir FILE 
    dizisinin içerisinde alınabilir. Örneğin:

    static FILE g_files[FILE_MAX];
    ...

    C standartlarında FILE yapısının içeriği hakkında bir bilgi verilmemiştir. Bu durumda bu FILE yapısının içeriği kütüphaneyi 
    yazanlar tarafından istenildiği gibi alınabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    fileno isimli POSIX fonksiyonu FILE yapısının içerisindeki dosya betimleyicisini bize vermektedir. Yani biz bir dosyayı fopen 
    fonksiyonuyla açıp o dosyanın dosya betimleyicisini elde edebiliriz. fileno fonksiyonunun prototipi şöyledir:

    #include <stdio.h>

    int fileno(FILE *stream);

    Fonksiyonun geri dönüş değeri dosya betimleyicisidir. Pekiyi bu fonksiyon başarısız olabilir mi ya da başarısızlığı tespit 
    edebilir mi? POSIX standartlarına göre fonksiyon başarısız olabilir. Bu durumda -1 değerine geri döner. Ancak fonksiyonun 
    başarısızlığı tespit etmesi yeterli bir biçimde yapılamayabilir. Fonksiyon FILE yapısının içerisindeki elemana başlangıçta 
    geçersiz bir değer atayıp bu değere bakmaktadır.

    Tabii fileno fonksiyonuyla FILE yapısı içerisindeki dosya betimleyicisini alıp onunla işlem yapınca onun gösterdiği dosya 
    göstericisi değiştirilmiş olur. Pek çok gerçekleştirim bu durumda soruna yol açmamaktadır. Ancak bu konuda dikkat etmek 
    gerekir. fileno fonksiyonu kısıtlı biçimde bazı zorunlu durumlarda kullanılmalıdır.

    Aşağıdaki örnekte dosya önce fopen fonksiyonuyla açılıp fileno fonksiyonuyla dosya betimleyicisi elde edilmiş ve sonra 
    o betimleyici ile okuma yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    FILE *f;
    int fd;
    char buf[10 + 1];
    ssize_t result;

    if ((f = fopen("test.txt", "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = fileno(f)) == -1)
        exit_sys("fileno");

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");

    buf[result] = '\0';
    puts(buf);

    fclose(f);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    fileno POSIX fonksiyonunun mantıksal olarak tersini yapan fdopen isimli bir POSIX fonksiyonu da vardır. (fdopen bir standart 
    C fonksiyonu değildir). fdopen fonksiyonu open POSIX fonksiyonuyla açıp betimleyicisini elde ettiğimiz dosyaya ilişkin dosya 
    bilgi göstericisini (FILE *) bize verir. Yani fdopen sanki o dosyayı fopen ile açmışız gibi bir durum oluşturmaktadır. 
    fdopen fonksiyonunun prototipi şöyledir:

    #include <stdio.h>

    FILE *fdopen(int fd, const char *mode);

    Fonksiyonun birinci parametresi open fonksiyonu ile elde edilen dosya betimleyicidir. İkinci parametre dosyanın fopen 
    fonksiyonundaki açış modudur. Tabii buradaki açış modunun open fonksiyonuyla dosya açılırken ki mod ile uyuşması gerekir. Fonksiyon 
    başarı durumunda dosya bilgi göstericisine, başarısızlık durumunda NULL adrese geri döner. errno değeri uygun biçimde set 
    edilir.

    Aşağıdaki örnekte önce open POSIX fonksiyonu ile dosya açılmış sonra dosya betimleyicisi kullanılarak fdopen fonksiyonu ile 
    dosya bilgi göstericisi elde edilmiştir. İşlemlere standart C fonksiyonlarıyla devam edilmiştir. fclose işlemi zaten bu 
    betimleyiciyi kapatacağı için ayrıca close fonksiyonu çağrılmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    FILE *f;
    int ch;

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    if ((f = fdopen(fd, "r+")) == NULL)
        exit_sys("fdopen");

    while ((ch = fgetc(f)) != EOF)
        putchar(ch);

    if (ferror(f)) {
        fprintf(stderr, "cannot read file!...\n");
        exit(EXIT_FAILURE);
    }

    fclose(f);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Standart C'nin <stdio.h> fonksiyonları tamponlamayı üç moda (ya da stratejiye) göre farklı biçimlerde yapmaktadır. 
    Üç tamponlama modu şöyledir:

    Tam Tamponlamalı Modu (Full Buffering): Burada okuma sırasında tampon tamamen doldurulur. Tamponun sonuna gelindiğinde tampon 
    yeniden doldurulur. Yazma sırasında da tampona yazılır. Tamponun sonuna gelindiğinde tampona yazılmış olanlar flush edilir. 
    (Tabii her zaman fflush ve fclose zaten flush işlemini yapmaktadır.)

    Satır Tamponlamalı Mod (Line Buffering): Bu modda tampon tamamen doldurulmaz. Yalnızca tek satırlık bilgi ('\n' karakteri 
    dahil olmak üzere) tampona çekilmektedir. Okuma sırasında bu tampondan byte'lar verilir. Yazma sırasına yine tampona yazılır. 
    flush işlemi '\n' karakteri tampona yazılınca (ya da fflush ve fclose fonksiyonları çağrılınca) yapılmaktadır. Satır tamponlamalı 
    mod tipik olarak text dosyalar için kullanılmaktadır. Binary dosyalar için bu mod kullanılabilse de anlamsızdır.

    Sıfır Tamponlamalı Mod (No Buffering): Burada tampon hiç kullanılmaz. Doğrudan ilgili aşağı seviyeli fonksiyonlarla (yani read 
    ve write POSIX fonksiyonlarıyla) aktarım yapılır.

    Satır tamponlaması kişilere biraz tuhaf gelebilmektedir. Çünkü satır tamponlaması yapabilmek için standart C kütüphanesinin 
    okuma sırasında '\n' karakterini görmesi gerekir ki bazı durumlarda bunun etkin bir biçimde yapılabilme olanağı yoktur. Ancak 
    bazı durumlarda zaten aygıt sürücüler bize satırsal bilgi vermektedir. Standart kütüphaneleri disk dosyaları için satır 
    tamponlaması yaparken aslında çoğu kez '\n' karakterine kadar değil tüm tampon kadar okuma yapmaktadır. Ancak '\n' karakteri 
    tampona yazıldığında flush işlemi yapmaktadırlar. C standartları bu üç tamponlama biçimini belirtmiş olsa da detaylar konusunda 
    bir açıklama yapmamıştır. Dolayısıyla kütüphaneyi gerçekleştirenler satır tamponlaması ile okuma yapılırken '\n' karakterine 
    kadar değil tüm tamponu da doldurabilmektedir. C standartlarında tamponlama stratejisi için "niyet" belirtilmiştir. Ancak yukarıda 
    da belirttiğimiz gibi detay belirtilmemiştir.

    Tamponlama modu ile ilgili iki önemli soru gündeme gelmektedir?

    1) Dosyanın default tamponlama modu nedir?
    2) Dosyanın tamponlama modu nasıl değiştirilmektedir?

    fopen fonksiyonu ile dosya açıldığında dosyanın default tamponlama modu hakkında C standartlarında bir şey söylenmemiştir. 
    Bu durum "bunun herhangi bir biçimde olabileceği" anlamına gelmektedir.Fakat mevcut standart C kütüphaneleri genel olarak 
    default durumda "tam tamponlamalı (full buffered)" modu esas almaktadır. Ancak standartlarda "stdin", "stdout" ve "strderr" 
    dosyaları için bazı şeyler söylenmiştir. Bir dosyanın tamponlama modu dosya fopen fonksiyonuyla açıldıktan sonra ancak henüz 
    hiçbir işlem yapmadan "setbuf" ve "setvbuf" standart C fonksiyonlarıyla değiştirilebilmektedir. Dosya üzerinde herhangi bir 
    işlem yaptıktan sonra bu fonksiyonların çağrılması "tanımsız davranışa (undefined behavior)" yol açmaktadır. "setvbuf" 
    fonksiyonu işlevsel olarak "setbuf" fonksiyonunu zaten kapsamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    setbuf fonksiyonu temel olarak kullanılan tamponun yerini değiştirmek için tasarlanmıştır. Fonksiyonun prototipi 
    şöyledir:

    #include <stdio.h>

    void setbuf(FILE *stream, char *buf);

    Fonksiyonun birinci parametresi dosya bilgi göstericisini, ikinci parametresi yeni tamponun yerini belirtmektedir. Bu tamponun 
    BUFSIZ uzunluğunda olması gerekir. Eğer ikinci parametre NULL adres olarak girilirse bu durumda dosya "sıfır tamponlamalı moda" 
    sokulmaktadır. Fonksiyon başarıyı kontrol edememektedir.

    Aşağıdaki örnekte setbuf fonksiyonu ile dosya için kullanılacak tamponun yeri değiştirilmiştir. fgetc işlemi sonrasında bu 
    tamponun doldurulduğuna dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    char mybuf[BUFSIZ];
    int ch;

    if ((f = fopen("test.txt", "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    setbuf(f, mybuf);

    ch = fgetc(f);
    putchar(ch);

    for (int i = 0; i < 512; ++i)
        putchar(mybuf[i]);
    putchar('\n');

    fclose(f);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    setvbuf fonksiyonu ile hem tamponun yeri, hem büyüklüğü hem de tamponlama modu değiştirilebilmektedir. Fonksiyonun prototipi 
    şöyledir:

    #include <stdio.h>

    int setvbuf(FILE *stream, char *buf, int mode, size_t size);

    Fonksiyonun birinci parametresi dosya bilgi göstericisini (stream) belirtir. Üçüncü parametre değiştirilecek tamponlama modunu 
    belirtmektedir. Bu parametre şu değerlerden birini alabilmektedir:

    _IONBF (unbuffered)
    _IOLBF (line buffered)
    _IOFBF (fully buffered)

    İkinci parametre tamponu değiştirmek için kullanılmaktadır. Bu parametre NULL adres geçilirse tamponun yeri değiştirilmez. Son 
    parametre ise tamponun yeni uzunluğunu belirtmektedir. Programcı ikinci parametreye NULL adres geçip son parametre yoluyla tamponun 
    büyüklüğünü de değiştirebilir. Bu durumda tamponu setvbuf kendisi tahsis edecektir. Eğer tamponlama modu ikinci parametreye 
    _IONBF geçilerek sıfır tamponlamalı mod olarak ayarlanırsa artık ikinci ve dördüncü parametrenin bir önemi kalmamaktadır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda sıfır dışı bir değere geri dönmektedir. POSIX sistemlerinde errno 
    değeri yine uygun biçimde set edilmektedir.

    glibc kütüphanesinde stebuffer ve setlinebuf isimli iki fonksiyon da bulunmaktadır. Ancak bu fonksiyonların taşınabilirliği yoktur.

    Aşağıdaki örnekte bir dosya fopen fonksiyonuyla açılmış ve "satır tamponlamalı moda" geçirilmiştir. Yukarıda da belirtildiği gibi 
    C standartları tamponlama modları için mutlak uyulması gereken kuralları açıkça belirtmemiştir. Örneğin glibc kütüphanesi normal 
    dosyalarda satır tamponlaması sırasında satır sonuna kadar değil tamponun tamamını doldurmaktadır. Ancak '\n' karakteri dosyaya 
    yazıldığında flush işlemi yapmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    char mybuf[512];
    int ch;

    if ((f = fopen("test.txt", "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    if (setvbuf(f, mybuf, _IOLBF, 512) != 0) {
        fprintf(stderr, "cannot set buffer!...\n");
        exit(EXIT_FAILURE);
    }

    ch = fgetc(f);
    putchar(ch);

    for (int i = 0; i < 512; ++i)
        putchar(mybuf[i]);
    putchar('\n');

    fclose(f);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Çeşitli standart C kütüphanelerinin özellikle stdio fonksiyonlarının gerçekleştirimini üşenmeden inceleyebilirsiniz. 
    Alternatifler şunlar olabilir:

    - uclibc (Mikro C kütüphanesi): https://elixir.bootlin.com/uclibc-ng/latest/source
    - musl libc kütüphanesi: http://www.musl-libc.org/
    - diet libc kütüphanesi: http://www.fefe.de/dietlibc/
    - Plauger'in "The C Standard Library" kitabında gerçekleştimini yaptığı kütüphane: https://github.com/topics/c-standard-library 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C'nin <stdio.h> dosyası içerisinde FILE * türünden yani "stream" belirten üç değişken ismi bulunmaktadır: stdin, stdout 
    ve stderr. Bu değişkenler fopen fonksiyonun geri döndürdüğü FILE nesnesi türünden adres belirtmektedir. Dolayısıyla C'nin 
    standart dosya fonksiyonlarında bunları kullanabiliriz. Örneğin aslında:

    printf(...);

    çağrısı ile aşağıdaki fprintf çağrısının bir farkı yoktur:

    fprintf(stdout, ...);

    stdin, stdout ve stderr dosya bilgi göstericileri (streams) programcı tarafından açılmamıştır ve programcı tarafından 
    kapatılmamalıdır. Programcı bunları doğrudan kullanabilir. Şüphesiz UNIX/Linux sistemlerinde stdin dosya bilgi göstericisinin 
    gösterdiği FILE nesnesinin içerisinde 0 numaralı betimleyici, stdout FILE nesnesinin içerisinde 1 numaralı betimleyici ve 
    stderr FILE nesnesinin içerisinde 2 numaralı betimleyici vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C standartları herhangi bir dosyanın default tamponlaması hakkında bir şey söylememiş olsa da "stdin", "stdout" ve "stderr" 
    dosyalarının default tamponlaması hakkında şunları söylemiştir:

    - stdin ve stdout dosyaları default durumda "eğer interaktif olmayan bir aygıta yönlendirilmişse işin başında tam tamponlamalı" 
    moddadırlar. Ancak bu dosyalar "interaktif olan bir aygıta yönlendirilmişse işin başında tam tamponalamlı olamazlar, satır 
    tamponlamalı ya da sıfır tamponlamalı" olabilirler. Klavye ve ekran yani terminal "interaktif aygıt" kabul edilmektedir. 
    Ancak disk dosyaları interaktif aygıt kabul edilmemektedir.

    - stderr dosyası ister interaktif olamayan aygıta yönlendirilmiş olsun isterse interaktif aygıta yönlendirilmiş olsun 
    işin başında tam tamponlamalı olamaz. Ancak satır tamponlamalı ya da sıfır tamponlamalı olabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                23. Ders 15/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Örneğin Windows sistemlerindeki C derleyicilerinde default durumda dosyay yönlendirme yapılmamışsa stdout sıfır tamponlamalı 
    stdin satır tamponlamalıdır. Ancak UNIX/Linux sistemlerinde stdout ve stdin dosyaları satır tamponlamalıdır. Aşağıdaki örnekte 
    bu durum anlaşılabilir.

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");        /* Windows sistemlerinde yazı gözükecek, UNIX/Linux'ta gözükmeyecek */

        for (;;)
            ;

        return 0;
    }

    Tabii program sonlanırken stdin, stdout ve stderr dosyaları zaten derleyiciler tarafından kapatılacağı için her durumda 
    bu flush işlemi yapılacaktır. Örneğin aşapıdaki programda programın çalışması bitince her sistemde yazı görünecektir:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");

        return 0;
    }

    stdout dosyası default terminale yönlendirilmişken satır tamponlamalı ya da sıfır tamponlamalı modda olabiliyorsa bir yazının 
    ekrana çıkmasını nasıl garanti edebiliriz? Mademki stdout terminale yönlendirildiğinde en kötü olasılıkla satır tamponlamalı 
    olabilir. O zaman yazının sonuna '\n' karakteri koyarız. Örneğin:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara\n");        /* Hem Windows'ta hem de Linux sistemlerinde yazı görülecek */

        for (;;)
            ;

        return 0;
    }

    Ancak burada imleç aynı zamanda aşağı satıra geçirilmektedir. Pekiyi imleç aşağı satıra geçirilmeden yazının ekrana çıkması nasıl 
    garanti edilebilir? Bunun iki yolu vardır. Birincisi stdout dosyasını fflush(stdout) çağrısıyla flush etmektir:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");
        fflush(stdout);

        for (;;)
            ;

        return 0;
    }

    İkincisi stdout dosyasını her ihtimale karşı açıkça sıfır tamponlamalı moda çekmektir:

  #include <stdio.h>

    int main(void)
    {
        setvbuf(stdout, NULL, _IONBF, 0);        /* setbuf(stdout, NULL */
        printf("ankara");

        for (;;)
            ;

        return 0;
    }

    C derleyicilerinin hemen hepsinde stdin dosyasından okuma yapıldığında okuma yapan fonksiyonlar öne stdout dosyasını flush 
    etmektedir. Standartlarda bu durum garanti edilmemiştir. Ancak derleyicilerin hemen hepsi böyle yapmaktadır. Örneğin:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");

        getchar();        /* Hem Windows hem de UNIX/Linux sistemlerindeki derleyicilerde stdout flush edilecek */

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    stdin dosyası hem Windows hem de UNIX/Linux sistemlerinde dosyaya yönlendirilmemişse satır tamponlamalı moddadır. Dolayısıyla 
    biz klavyeden bir karakter bile okumak istesek UNIX/Linux sistemlerinde read fonksiyonu 0 numaralı betimleyici ile çağrılarak 
    bir satırlık bilgi okunup tampona yerleştirilmektedir. Artık tamponda bilgi olduğu sürece okuma fonksiyonları tampondakileri 
    okuyacaktır. Örneğin üst üste ik getchar çağrısı ile iki karakteri stdin dosyasından okumak isteyelim:

    ch1 = getchar();
    ch2 = getchar();

    Birinci getchar fonksiyonu bizden bir satır alarak onu stdin dosyasının tampona yerleştirir. Tabii tamponun sonunda '\n' 
    karakteri de bulunacaktır. İkinci getchar tampon boş olmadığı sürece artık klavyeden giriş istemeyip tampondan girişi 
    karşılayacaktır. Yukarıdaki örnekte biz ilk getchar fonksiyonunda klavyeden "a" karakterine basıp ENTER tuşuna basalım. 
    Bu durumda tamponda şu karakter olacaktır:

    a\n

    İlk getchar bu 'a' karakterini ikinci getchar ise '\n' karakterini alacaktır. Biz getchar fonksiyonunu üçüncü kez çağırdığımızda 
    artık yeni bir satır istenecektir. Yani stdin dosyasından okuma yapan fonksiyonlar tampon boşsa read fonksiyonunu çağırarak 
    bizden bir satırlık bilgi istemektedir. Aşağıdaki programla test işlemini yapabilirsiniz:

    #include <stdio.h>

    int main(void)
    {
        int ch;

        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        return 0;
    }

    Tabii scanf, getchar, gets gibi fonksiyonların hepsi ortak tampondan çalışmaktadır. Yani bu fonksiyonların hepsi stdin dosyasından 
    okuma yapar. stdin dosyasının da bir tane tamponu vardır.

    Pekiyi biz gerçekten ikinci getchar fonksiyonu ile yeni bir klavye girişi yapmak istiyorsak bunu nasıl sağlayabiliriz? stdin 
    dosyasının flush edilmesi geçersiz bir işlemdir. Zira C'de "read-only" dosyalar flush edilemezler. Bunun için özel bir fonksiyon 
    da bulundurulmamıştır. O zaman tek yapılacak şey '\n' karakterini görene kadar stdin dosyasından karakter karakter okuma yapmaktır. 
    Bu işlem şöyle bir döngü ile yapılabilir:

    while(getchar() != '\n')
        ;

    Tabii sonraki anlatımlarda görüleceği üzere EOF durumunun da kontrol edilmesi daha uygun olur. Bu nedenle aşağıdaki gibi bir 
    fonksiyon bu iş için kullanılabilir:

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }

    Maalesef bu işlemin daha pratik bir yolu yoktur. Örneğin:

    #include <stdio.h>

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }

    int main(void)
    {
        int ch;

        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        clear_stdin();

        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    stdin dosyası default durumda pek çok sistemde terminal aygıt sürücüsüne (yani klavyeye) yönlendirilmiş durumdadır. 
    Biz stdin dosyasında okuma yaptığımızda EOF ile karşılaşabiliriz. Çünkü stdin bir dosyaya yönlendirildiğinde dosyanın sonuna
    gelinmiş de olabilir. Pekiyi stdin default durumda klavyeden okuma yaparken dosya sonu kavramı ne olacaktır? İşte terminal 
    aygıt sürücüsü bazı özel tuş kombinasyonlarında yalancı bir EOF etkisi oluşturmaktadır. Windows sistemlerinde Ctrl+z tuşu 
    UNIX/Linux sistemlerinde Ctrl+d tuşu bu amaçla kullanılmaktadır. Örneğin:

    ch = getchar();

    Burada Windows sistemlerinde Ctrl+z tuşuna UNIX/Linux sistemlerinde Ctrl+d tuşuna basıldığında "dosya sonuna gelme etkisi" 
    yaratılacak ve getchar fonksiyonu EOF değerine (-1) geri dönecektir. Tabii bu tuş kombinasyonlarına basıldığında gerçekte 
    dosya sonuna gelme gibi bir durum oluşmamaktadır. Bu yalancı bir etkidir. Yani daha sonra stdin dosyasından yine okuma 
    yapılabilir. Bu nedenle stdin tamponunu boşaltırken kullanıcının EOF etkisi yaratmak isteyebileceğine de dikkat edilmelidir:

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C'de stdin dosyasından okuma yapan standart fonksiyonlar şunlardır:

    getchar
    scanf
    gets (C11'de kaldırılıdı)
    gets_s (C11 ile birlikte eklendi ancak "isteğe bağlı (optional), VS ve glibc kütüphanelerinde yok")

    Bunların hepsi aynı tampondan çalışmaktadır. Şimdi bu fonksiyonlar üzerinde duralım.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    getchar fonksiyonu stdin dosyasından bir karakter okur. Tabii önce tampona bakar. Tamponda en az bir karakter varsa onu verir. 
    Tampon tamamen boşsa klavyeden bir satır okuyarak tamponu doldurur. Ondan sonra karakteri verir. Aslında gets ve scanf gibi 
    fonksiyonların hepsi getchar kullanılarak yazılmıştır. Yani temel fonksiyon getchar fonksiyonlarıdır. 
    getchar fonksiyonu dosya sonuna gelindiğinde ya da IO hatası olduğunda EOF (-1) değerine geri dönmektedir. getchar fonksiyonunun 
    prototipi şöyledir:

    #include <stdio.h>

    int getchar(void);

    Eğer fonksiyonun geri dönüş değeri char olsaydı bu durumda 0xFF gibi bir okumayla EOF değeri birbirinden ayırt edilemezdi.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    gets fonksiyonu C99'da "deprecated" yapılmış ve C11'de C'den kaldırılmıştır. Ancak hala derleyiciler bunu muhafaza etmektedir. 
    gets fonksiyonu stdin dosyasından karakter karakter okuma yapar ve okuduğu karakterleri verilen bir diziye yerleştirir. gets 
    fonksiyonu '\n' karakterini de okur ancak onun yerine diziye '\0' karakterini yerleştirir. Yani gets fonksiyonu aslında stdin 
    tamponunu da tamamen boşaltmaktadır. Tabii gets fonksiyonu çağrıldığında stdin tamponunda zaten karakterler varsa gets 
    klavyeden bir giriş beklemeden onları okuyup geri dönecektir.

    gets fonksiyonunun prototipi şöyledir:

    char *gets(char *s);

    gets fonksiyonu parametresiyle girilen adresin aynısıyla geri döner. Ancak henüz hiçbir karakter okunmadan EOF ile karşılaşılırsa
    gets NULL adresle geri dönmektedir.

    gets fonksiyonu aşağıdaki gibi yazılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

char *mygets(char *s)
{
    int ch;
    size_t i;

    for (i = 0; (ch = getchar()) != '\n' && ch != EOF; ++i)
        s[i] = ch;

    if (i == 0 && ch == EOF)
        return NULL;

    s[i] = '\0';

    return s;

}

int main(void)
{
    char buf[64];

    mygets(buf);
    puts(buf);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    gets fonksiyonun problemi parametre olarak verdiğimiz dizinin her zaman taşırılabilme olasılığıdır. Fonksiyonun dizi uzunluğunu 
    da parametre olarak alması gerekirdi. İşte C11 ile birlikte isteğe bağlı biçimde standartlara eklenmiş olan gets_s bununu 
    yapmaktadır. gets_s fonksiyonunun prototipi şöyledir:

    char *gets_s(char *s, rsize_t n);

    Buradaki rsize_t türü de yine "isteğe bağlı typedef edilmesi gereken" bir türdür. Aşağıdak gets_s fonksiyonun muhtemel bir 
    gerçekleştirimi verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

char *mygets_s(char *s, size_t n)
{
    int ch;
    size_t i;

    for (i = 0; i < n - 1; ++i) {
        if ((ch = getchar()) == '\n' || ch == EOF)
            break;
        s[i] = ch;
    }

    s[i] = '\0';

    if (i == 0 && ch == EOF)
        return NULL;

    return s;
}

int main(void)
{
    char buf[3];

    mygets_s(buf, 3);
    printf("%s\n", buf);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bazı programcılar gets_s fonksiyonu derleyicilerde bulunmadığı için onun işlevselliğini fgets fonksiyonu ile karşılamaya çalışmaktadır. 
    fgets fonksiyonunun prototipi şöyledir:

    char *fgets(char *s, size_t n, FILE *f);

    Ancak fgets fonksiyonu ile eğer belirtilen uzunluktan daha kısa bir satır girilmişse '\n' karakterini de diziye yerleştirmektedir. 
    Bu durumda programcının bu '\n' karakterini kendisinin aşağıdaki gibi silmesi gerekmektedir:

    char buf[64];
    char *str;

    fgets(buf, 64, stdin);
    if ((str = strchr(buf, '\n')) != NULL)
        *str = '\0';
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    scanf fonksiyonu işlevsel olarak printf fonksiyonun tersi gibidir. Prototipi şöyledir:

    int scanf(const char *format, ...);

    Fonksiyon stdin dosyasından karakterleri tek tek okur. Format karakterlerine uygunsuzluk tespit ettiği noktada uygunsuz olan 
    o karakteri tampona geri yazar ve işlemini sonlandırır. scanf fonksiyonu başarılı bir biçimde yerleştirilen değerin sayısına geri 
    dönmektedir. Tabii bu değer 0 da olabilir. scanf henüz hiçbir karakter okuyamadan EOF ile karşılaşırsa EOF değerine geri döner. 
    scanf her zaman baştaki boşluk karakterlerini (leading space) ve girişler arasındaki boşluk karakterlerini atmaktadır. 
    Ancak sonraki boşluk karakterlerini ('\n' de dahil olmak üzere) atmamaktadır.

    Aşağıda scanf kullanımına ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

void clear_stdin(void)
{
    int ch;

    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

int disp_menu(void)
{
    int option;
    int result;

    do {
        printf("1) Add record \n");
        printf("2) Delete record \n");
        printf("3) List record \n");
        printf("4) Quit\n");

        printf("\nChoose an item:");
        if ((result = scanf("%d", &option)) != 1 || option < 0 || option > 4) {
            printf("Invalid option!...\n");
            clear_stdin();
        }
    } while (result != 1);

    return option;
}

int main(void)
{
    int option;

    for (;;) {
        option = disp_menu();

        switch (option) {
            case 1:
                printf("add record...\n");
                break;
            case 2:
                printf("delete record...\n");
                break;
            case 3:
                printf("list record...\n");
                break;
            case 4:
                goto EXIT;
        }
    }

EXIT:
    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyadan okunan karakter beğenilmezse sanki hiç okunmamış gibi bir etki oluşturmak için (yani o karakteri tampona geri 
    bırakmak için) ungetc isimli bir standart C fonksiyonu bulundurulmuştur:

    #include <stdio.h>

    int ungetc(int c, FILE *stream);

    Fonksiyon başarı durumunda tampona bırakılan karakterin aynısına, başarısızlık durumunda EOF değerine geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı byte byte okurken fgetc fonksiyonundan faydalanırız. Standart C fonksiyonları tamponlu çalıştığına göre gereksiz 
    bir biçimde sistem fonksiyonları tekrar tekrar çağrılmayacaktır. Ancak öte yandan fonksiyon çağırmanın da bir maliyeti vardır. 
    İşte C standartlarında fgetc yerine getc isimli alternatif bir fonksiyon da bulundurulmuştur. getc fonksiyonu makro olarak 
    yazılabilmektedir. Yani iki fonksiyon arasındaki tek fark getc fonksiyonunun bir makro biçiminde yazılabilmesidir. getc 
    fonksiyonunun prototipi de şöyledir:

    #include <stdio.h>

    int getc(FILE *stream);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her prosesin o anda "sistem genelinde tek olan (unique)" bir "proses id" değeri vardır. 
    Proses id değeri prosesin kontrol bloğuna erişmek için bir anahtar olarak kullanılmaktadır. Yani biz işletim sistemine 
    bu proses id değerini verdiğimizde işletim sistemi çok hızlı bir biçimde bu id değerinden hareketle prosesin kontrol bloğuna 
    erişebilmektedir.

    Proseslerin id değerleri pid_t türüyle temsil edilmiştir. pid_t türü işaretli bir tamsayı türü olmak koşuluyla <sys/types.h> ve
    <unistd.h> dosyalarında typedef edilmiş durumdadır.

    Sistem boot edildiğinde boot kodu 0 numaralı id'ye sahip proses biçimine dönüştürülmektedir. (Buna "swapper" ya da "pager" 
    da denilebilmektedir.) Daha sonra da bu 0 numaralı id bir daha sistemde kullanılmamaktadır. Sistemde ikinci yaratılan proses 
    1 numaralı id'ye sahip olan "init" isimli prosestir. 0 numaralı pros yok edildiği için sistemdeki bütün proseslerin atası 
    bu "init" posesidir.

    İşletim sisteminin çekirdeği tipik olarak yeni yaratılan bir proses için proses id değerini bir sayaç ile vermektedir. Her proses yaratıldığında
    bu sayaç değeri bir artırılır. Sayaç sona geldiğinde yeniden başa geçilir ve bitmiş proseslerin id'leri kullanılır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan programa ilişkin proses id değeri getpid isimli POSIX fonksiyonu ile elde edilebilmektedir:

    #include <unistd.h>

    pid_t getpid(void);

    Fonksiyon başarısız olamaz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

int main(void)
{
    pid_t pid;

    pid = getpid();

    printf("%jd\n", (intmax_t)pid);     /* printf("%lld\n", (long long)pid); */

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                24. Ders 21/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesler, prosesler tarafından sistem fonksiyonlarıyla yaratılmaktadır. Bir prosesi yaratan prosese o prosesin "üst prosesi (parent process)",
    yaratılan prosese de üst prosesin "alt prosesi (child process)" denilmektedir. Her prosesin bir üst prosesi vardır. Bir prosesin 
    üst prosesi getppid fonksiyonu ile elde edilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    pid_t getppid(void);

    Fonksiyon başarısız olamamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

int main(void)
{
    pid_t pid, ppid;

    pid = getpid();
    printf("pid = %jd\n", (intmax_t)pid);

    ppid = getppid();
    printf("ppid = %jd\n", (intmax_t)ppid);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir prosesin üst prosesi sonlanırsa bu tür proseslere "öksüz (orphan) prosesler" denilmektedir. Sistem böyle bir durumda
    1 numaralı id'ye sahip olan "init" prosesini öksüz duruma düşmüş prosesin üst prosesi olarak atamaktadır. Dolayısıyla her 
    zaman prosesin bir üst prosesi bulunmaktadır.

    Sistemlerde prosesler konusunda bazı limitler söz konusu olabilmektedir. Çünkü her proses bir kaynak kullanmaktadır. Bu kaynakların da 
    o makine için bir limiti vardır. Örneğin Linux sistemlerinde, sistem genelinde aynı anda var olabilecek toplam proseslerin sayısı 
    /proc/sys/kernel/threads-max dosyasında belirtilmektedir. Burada belirtilen değer "toplam proseslerin ve thread'lerin" sayısıdır. 
    (Linux sistemlerinde aslında thread'ler de prosesler gibi kaynak kullanmaktadır.) Yine Linux sistemlerinde belli bir kullanıcının yaratabileceği 
    maksimum proses ve thread sayısı da söz konusudur. Bu değer getrlimit fonksiyonuyla ya da ulimit kabuk komutuyla elde edilebilir. 
    Tabii root prosesi (proses id'si 0 olan prosesler ve bu yeterliliğe (capability) sahip olan prosesler) bu sınırlamaya tabi değildir. 
    Linux sistemlerinde "proses id'lerin yeniden başa geçmeden alabileceği maksimum değer de "/proc/sys/kernel/max_pid" dosyasında
    belirtilmektedir. Aşağıdaki bir Ubuntu makinede bu limitler gösterilmiştir. Ancak bu limitler makineden makineye değişebilmektedir.

    $ cat /proc/sys/kernel/threads-max
    15071

    $ cat /proc/sys/kernel/pid_max
    4194304

    $ ulimit -u
    7535

    Bu değerler aslında o anda ya da kalıcı olarak değiştirilebilmektedir. Bu değerlerin boot edilene kadar değiştirilmesi bu 
    dosyalara yeni değerlerin yazılmasıyla yapılabilir. Ya da sysctl kabuk komutu ile yapılabilir. Kalıcı değişiklik için sistem 
    boot edilirken başvurulan bazı konfigürasyon dosyalarından faydalanılmaktadır. Örneğin /etc/sysctl.conf dosyasına yeni 
    limitler girilirse sistem her açıldığında bu limitlerle açılacaktır. Aslında bu limitler "kernel parametreleri" yoluyla 
    da değiştirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde bir proses yaratmanın yegane yolu "fork" isimli POSIX fonksiyonunu kullanmaktır. fork fonksiyonu, 
    doğrudan işletim sisteminin bu işi yapan sistem fonksiyonunu çağırmaktadır. Linux sistemlerinde sys_fork isimli fonksiyon ve 
    bunun daha genel biçimi olan sys_clone sistem fonksiyonları bu işi yapmaktadır. fork fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    pid_t fork(void);

    fork, Türkçe "çatal" anlamına gelmektedir. "Akışın çatallanması" gibi bir benzetmeyle bu isim verilmiştir. fork, bir prosesin 
    tamamen özdeş bir kopyasını oluşturur. (Bunu klonlama makinesine giren orada klonu çıkartılan bir insan olarak düşünebilirsiniz.)
    Yani fork fonksiyonu şunları yapmaktadır:

    1) Yeni bir proses kontrol blok yaratır. fork işlemini yapan prosesin proses kontrol bloğunun içeriğini, yeni yaratılan 
    prosesin kontrol bloğuna kopyalar. Böylece üst proses ile yeni yaratılan alt proses tamamen aynı özelliklere sahip olmaktadır.

    2) fork, bu fonksiyonu çağıran prosesin bellek alanının da kopyasını yeni yaratılan proses için oluşturmaktadır. Böylece 
    her iki proses de aynı kodu ve data ve heap alanlarına sahip olacaktır. Ancak bunlar birbirlerinden ayrıdır.

    Yukarıdaki işlemler fork fonksiyonunun içinde yapılmaktadır. fork fonksiyonundan hem bu fonksiyonu çağıran proses hem de 
    yeni yaratılan proses çıkmaktadır. Ancak bunların bellek alanları ayrı olduğu için artık birinin yapacağı değişikliği diğeri 
    görmeyecektir. fork fonksiyonu, bir klonlama yapmaktadır. Yeni bir prosesi, kendi prosesiyle aynı özelliklere ve aynı bellek alanı 
    ile yaratmaktadır. fork sırasında prosesin kontrol bloğu yeni yaratılan prosese kopyalandığı için üst proses ile alt proses 
    aynı kullanıcı ve grup id'sine sahip olur. (Bir kişi klonlama makinesine girip klonu çıkartıldığında makineden iki kişi çıkacaktır. 
    Bu iki kişinin de anıları aynı olacaktır. Ancak artık bunların yaşamları farklıdır. Birisinin başına gelen şeyler makineden
    çıktıktan sonra ona özgü olacaktır.)

    fork işlemini yapan proses üst proses (parent process) durumundadır. Yeni yaratılan proses ise alt proses (child process) durumundadır. 
    Tabii alt proses yeni bir proses id'ye sahip olacaktır. Alt prosesin üst prosesi, fork fonksiyonu uygulayan proses olacaktır. 
    fork fonksiyonu başarısız olabilir. fork başarısızlık durumunda -1 değerine geri dönmektedir.

    Pekiyi yeni proses hangi noktada yaratılmaktadır? Tabii fork fonksiyonu içerisinde. Yeni yaratılan prosesin (alt prosesin) akışı da 
    fork fonksiyonu içerisinde başlatılacaktır. Bu durumda her iki proses de fork fonksiyonunun içerisinden çıkacaktır. İşte üst proses (yani fork 
    işlemini yapan proses) "alt prosesin id" değeri ile, alt proses ise "0 değeri ile" fork fonksiyonundan çıkacaktır. Böylece programcı 
    fork çıkışında üst proses ile alt prosese farklı işlemler yaptırabilmektedir. Alt prosesin fork içerisinden 0 ile çıkması alt prosesin 
    proses id'sinin 0 olduğu anlamına gelmemektedir. Alt prosesin proses id'si alt proses içerisinden getpid fonksiyonuyla elde 
    edilebilmektedir.

    fork işleminin tipik kalıbı şöyledir:

    pid_t pid;
    ...

    if ((pid = fork()) == -1)
        exit_sys("fork");
    if (pid != 0) {        /* parent process */
        ...
    }
    else {                /* child process */
        ...
    }

    Aşağıdaki örnekte fork fonksiyonu ile bir proses yaratılmış ve çeşitli proses id'ler üst ve alt proseslerde yazdırılmıştır. 
    Bu örnekte üst proseste fork fonksiyonunun alt prosesin proses id değeri ile geri döndüğüne dikkat ediniz. Denemenin yapıldığı 
    makinede şöyle bir sonuç elde edilmiştir:

    Parent pid: 549376
    Parent's parent pid: 536568
    fork return value: 549377
    common code...
    Child pid: 549377
    Child's parent pid: 549376
    Common code...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        printf("Parent pid: %lld\n", (long long)getpid());
        printf("Parent's parent pid: %lld\n", (long long)getppid());
        printf("fork return value: %lld\n", (long long)pid);
    }
    else {                /* child process */
        printf("Child pid: %lld\n", (long long)getpid());
        printf("Child's parent pid: %lld\n", (long long)getppid());
    }

    printf("Common code...\n");

    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    fork işleminde en fazla kafa karıştıran noktalardan biri fork fonksiyonundan iki akışın çıkması durumudur. Burada genellikle 
    yeni öğrenenlerin gözden kaçırdığı birkaç nokta vardır:

    1) fork sırasında fork işlemini yapan prosesin (yani üst prosesin) tüm bellek alanının yani onun kod, data, stack ve heap 
    alanlarının özdeş bir kopyası oluşturulmaktadır. Yani fork işlemini yapan prosesin kod, data stack ve heap alanlarının hepsi 
    alt proseste de bulunmaktadır. Örneğin:

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        ...
    }
    else {
        ...
    }

    Bu kod, bu haliyle hem üst proseste hem de alt proseste bulunacaktır. Yani fork işleminden sonra bu kodlardan aslında iki 
    tane vardır. Bizim buradaki temel amacımız fork çıkışında kodu aynı olan iki farklı prosese farklı şeyleri yaptırmaktır. İşte 
    bunu sağlamanın yolu fork fonksiyonunun geri dönüş değerinden faydalanmaktadır.

    2) Yeni öğrenen kişilere iki prosesin de fork fonksiyonundan çıkması tuhaf gelebilmektedir. Aslında burada bir tuhaflık yoktur. 
    Şöyle ki: Prosesin yaratılması ve bellek alanlarının kopyalanması zaten fork içerisinde yapılmaktadır. fork fonksiyonunu 
    çağıran proses (üst proses) fork'tan çıkacaktır. Kopyası çıkartılan alt proses de çalışmaya fork içerisinden başlamaktadır. 
    Bu durumda alt proses de fork fonksiyonundan çıkacaktır.

    Tabii fork fonksiyonundan çıkınca artık üst proses ile alt prosesin yaşamları farklı olabilmektedir. Örneğin üst proses 
    bir global değişkenin değerini değiştirse alt proses bunu değişmiş olarak görmez. Çünkü o global değişkenin üst proseste 
    ve alt proseste farklı kopyaları vardır. Üst proses kendi global değişkenini değiştirmektedir. Yani fork işleminden çıkıldığında 
    üst ve alt prosesin her şeyi aynı olsa da artık bunlar kendi yollarına gideceklerdir. (Bu durumu klon makinesinden çıkan 
    iki kişinin durumuna benzetebiliriz. Klon makinesinden çıkar çıkmaz bu iki kişinin her şeyi aynıdır. Ancak bundan sonra bu 
    kişiler bağımsız kişiler oldukları için başlarına farklı olaylar gelecektir. Birisinin maruz kaldığı bir duruma diğeri 
    maruz kalmayacaktır.)

    Aşağıdaki örnekte fork işlemi sonrasında üst proses g_x global değişkenine yeni bir değer atamıştır. Sonra alt proseste bu 
    global değişkenin değeri yazdırılmıştır. Tabii alt proses üst prosesin yaptığı bu değişikliği görmeyecektir. Çünkü aslında 
    iki prosesin de bellek alanları tamamen fork içerisinde kopyalama yöntemiyle ayrıştırılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int g_x = 10;

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        g_x = 100;
    }
    else {                /* child process */
        sleep(1);
        printf("%d\n", g_x);    /* 10 */
    }

    printf("Common code...\n");

    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    fork işleminde yeni proses yaratıldığında hangi proses akışının fork fonksiyonundan önce çıkacağının bir garantisi yoktur. 
    Bu işletim sisteminin çizelgeleme algoritmalarına bağlı olarak değişebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte "Common Code" yazısı 8 defa ekranda görünecektir. Çünkü ilk fork işleminden sonra ikinci fork işlemini 
    iki proses yapacaktır. Böylece ikinci fork işleminden sonra aynı kodu sahip 4 proses oluşacaktır. Sonra bu 4 proses de 
    üçüncü fork işlemini yapacaktır. O halde üçüncü fork işleminden toplam 8 proses çıkacaktır. Buradaki sleep fonksiyonuna 
    takılmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    fork();
    fork();
    fork();

    printf("Common code...\n");
    sleep(1);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde yine aşağıdaki kodda ekrana 8 tane 3 sayısı basılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    int a = 0;
    fork();
    ++a;
    fork();
    ++a;
    fork();
    ++a;

    printf("%d\n", a);
    sleep(1);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    fork işlemi sırasında üst prosesin (fork işlemini yapan prosesin) proses kontrol bloğunun yeni yaratılan alt prosesin 
    proses kontrol bloğuna kopyalandığını belirttik. Bu nedenle alt prosesin "kullanıcı id'si, grup id'si, çalışma dizini" ve 
    daha pek çok özellikleri üst prosesle aynı olacaktır. Pekiyi alt proseste dosya betimleyici tablosunun durumu ne olacaktır? 
    Örneğin biz bir dosya açmış olsak sonra fork yapmış olsak alt proseste bu dosyanın durumu ne olacaktır?

    fork işlemi sırasında işletim sistemi üst prosesin dosya betimleyici tablosu içerisindeki dosya nesnelerinin adreslerini de 
    alt prosesin dosya betimleyici tablosuna kopyalamaktadır. Ancak dosya nesnelerinin kopyalarını çıkartmamaktadır. Böylece fork 
    işleminin sonunda üst prosesin dosya betimleyici tablosunun slotları ile alt prosesin dosya betimleyici tablosunun slotları 
    (yani dosya betimleyicileri) aynı dosya nesnesini gösteriyor durumda olur. Bu tür kopyalamalara "sığ kopyalama (shallow copy)" 
    da denilmektedir. Mademki açık dosyaya ilişkin tüm bilgiler dosya nesnesinde tutulmaktadır, o halde fork işleminden sonra 
    proseslerden biri bir dosyanın dosya göstericisini değiştirirse diğer proses bunu değişmiş olarak görecektir. Tabii fork 
    işlemi sırasında dosya nesnelerinin referans sayaçları da bir artırılmaktadır. Benzer biçimde aslında işin başında açık olan 
    0, 1 ve numaralı betimleyiciler login işlemi öncesinde yaratılmış durumdadır. Her fork işleminde bu betimleyicilere ilişkin 
    dosya nesnelerinin kopyaları çıkartılmamaktadır. Prosesler aslında genellikle aynı 0, 1 ve 2 numaralı dosya nesnelerini 
    göstermektedir.

    Aşağıdaki örnekte önce bir dosya açılmış sonra üst proses dosya göstericisini 50'nci offset'e konumlandırmıştır. Üst prosesle 
    alt proses aynı dosya nesnelerini gördüğü için bu durumdan alt proses etkilenecektir. Alt proseste yapılan okuma 50'nci 
    offset'ten itibaren yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    pid_t pid;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        lseek(fd, 50, SEEK_SET);
    }
    else {
        sleep(1);
        if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    C'nin standart dosya fonksiyonlarının tamponlama mekanizmasıyla çalıştığını görmüştük. Bu durumda fopen fonksiyonu ile 
    açtığımız bir dosyaya bir şeyler yazıp henüz tampon flush edilmeden fork yaparsak tüm bellek alanının kopyası çıkartılacağı 
    için bu tamponun da flush edilmemiş bir kopyası oluşacaktır. Bu durum tasarımda sorunlara yol açabilir. Programcının bu 
    durumu dikkate alıp fork işleminden önce fflush yapması gerekebilir.

    Aşağıdaki örnekte printf fonksiyonu Linux sistemlerinde default durumda "satır tamponlamalı" olan stdout dosyasının tamponuna 
    bilgileri yazmıştır. Ancak "\n" karakteri tampona yazılmadığı için flush işlemi de yapılmamıştır. fork işlemi ile birlikte 
    bu tamponun da kopyası çıkarılacağından dolayı ekranda iki tane "Ok" yazısı görünecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    printf("Ok");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    printf("\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                25. Ders 22/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde prosesi sonlandırmak için _exit isimli POSIX fonksiyonu kullanılmaktadır. Bu fonksiyon C'nin 
    standart exit fonksiyonuna benzemektedir.

    #include <unistd.h>

    void _exit(int status);

    Fonksiyon, parametre olarak prosesin "exit kodunu" almaktadır. Tabii bir proses sonlanmadan önce prosesin sistem genelinde 
    tahsis etmiş olduğu kaynaklar boşaltılmaktadır. Yani örneğin biz open fonksiyonu ile birtakım dosyalar açmışsak _exit işlemi
    sırasında bütün bu dosyalar kapatılacaktır. Linux sistemlerinde _exit fonksiyonu doğrudan işletim sisteminin sys_exit_group isimli
    sistem fonksiyonunu çağırmaktadır. Tabii asıl prosesin sonlandırılması bu sistem fonksiyonu tarafından yapılmaktadır. 
    Yine geleneksel olarak başarılı sonlanmalar için 0 değeri, başarısız sonlanmalar için sıfır dışı değerler kullanılmaktadır.

    C'nin standart exit fonksiyonun da prototipi şöyledir:

    #include <stdlib.h>

    void exit(int status);

    C'nin exit fonksiyonu prosesin sonlandırılması için UNIX/Linux sistemlerinde aslında _exit POSIX fonksiyonunu çağırmaktadır:

    exit ----> _exit ----> sys_exit_group (Linux)

    exit standart C fonksiyonu, standart C kütüphanesinde yapılan bazı işlemleri de geri almaktadır. Örneğin exit fonksiyonu önce 
    atexit fonksiyonu ile kaydetterilmiş olan fonksiyonları ters sırada çağırır, sonra tmpfile fonksiyonu ile yaratılmış geçici dosyaları 
    siler ve dosya bilgi göstericilerine (streams) ilişkin tamponları flush eder sonra da bunları kapatır.

    C'de programcı, program içerisinde exit fonksiyonunu hiç çağırmamışsa akış main fonksiyonunu bitirdiğinde main fonksiyonunun geri 
    dönüş değeri ile exit fonksiyonu çağrılmaktadır. Yani C'de main fonksiyonu derleyici tarafından adeta exit(main()) gibi çağrılmaktadır. 
    Yani C'de sonlandırmalar aslında her zaman exit (ya da abort) fonksiyonu ile yapılmaktadır. abort fonksiyonu ise "abnormal" 
    sonlandırmalar için kullanılmaktadır. UNIX/Linux sistemlerinde abort standart C fonksiyonu SIGABRT sinyali oluşturarak programı 
    sonlandırmaktadır.

    C'de program, standart exit fonksiyonu ile sonlandırılmalıdır. Çünkü exit fonksiyonu yukarıda ele aldığımız bazı gerekli son 
    işlemleri de yapmaktadır. Ancak yine de bazen programın doğrudan _exit POSIX fonksiyonu ile sonlandırılması gerekebilmektedir.

    Aşağıdaki örnekte program exit fonksiyonu ile değil _exit fonksiyonu ile sonlandırılmıştır. Bu nedenle atexit ile kaydedilen 
    foo fonksiyonu program sonlanırken çağrılmayacaktır. Aynı zamanda dosya tamponları da flush edilmeyeceğinden dolayı printf 
    fonksiyonu ile ekrana yazılmak istenen ancak satır tamponlaması nedeniyle henüz yazılamayan "ok" yazısı da ekranda görülmeyecektir. 
    Burada _exit çağrısını kaldırırsanız. Akış main fonksiyonunu bitirince exit standart C fonksiyonu çağrılacağı için bir sorun kalmayacaktır.

    Linux'ta aslında _exit fonksiyonu işletim sisteminin sys_exit sistem fonksiyonunu değil sys_exit_group sistem fonksiyonunu 
    çağırmaktadır. Linux'ta sys_exit sistem fonksiyonu yalnızca fonksiyonu çağıran thread'i sys_exit_group fonksiyonu ise tüm thread'leri 
    dolayısıyla da prosesi sonlandırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void foo(void)
{
    fprintf(stderr, "foo\n");
}

int main(void)
{
    atexit(foo);

    printf("ok");

    _exit(0);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    _exit fonksiyonunun parametresi olan exit kodunun hangi değerde olduğu işletim sistemini ilgilendirmemektedir. Yani işletim 
    sistemi bu değeri aslında kullanmamaktadır. İşletim sistemi exit kodunu alır ve saklar. Bunu prosesi yaratan üst proses isterse
    ona verir. Ancak onun hangi değerde olduğu ile ilgilenmez. exit kodunun değeri üst prosesle alt prosesin arasındaki bir 
    anlaşma ile anlam kazanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Üst proses fork fonksiyonu ile alt prosesi yarattıktan sonra onun sonlanmasını bekleyebilir ve alt proses sonlandığında 
    onun exit kodunu alabilir. Bunun için wait ve waitpid isimli POSIX fonksiyonları kullanılmaktadır. waitpid fonksiyonu wait 
    fonksiyonunu işlevsel olarak kapsamaktadır. (Zaten önce wait fonksiyonu vardı, onun yetersizlikleri görülünce waitpid 
    fonksiyonu tasarlandı).

    wait fonksiyonunun prototipi şöyledir:

    #include <sys/wait.h>

    pid_t wait(int *wstatus);

    wait fonksiyonu herhangi bir alt proses sonlanana kadar "blokede" fonksiyonu çağıran thread'i bekletir. Burada blokede 
    bekleme terimi CPU zamanı harcamadan uykuda kalmayı belirtmektedir. Tabii wait fonksiyonu çağrıldığında alt proseslerden 
    biri sonlanmış da olabilir. Bu durumda wait fonksiyonu blokeye (yani beklemeye) yol açmaz. wait fonksiyonu başarı durumunda 
    exit kodunu aldığı prosesin id değeri ile geri dönmektedir. Böylece programcı çok sayıda alt prosesin söz konusu olduğu 
    durumda hangi alt prosesin exit kodunu aldığını buradan hareketle anlayabilmektedir. Fonksiyon parametresiyle aldığı 
    int nesnesinin içerisine sonlanan prosesin exit kodunu ve sonlanma nedenine ilişkin bazı bilgileri yerleştirmektedir.

    Normal biçimde sonlanmamış (yani bir sinyal ile sonlanmış) proseslerde exit kodu oluşmamaktadır. O halde programcının 
    prosesin exit kodunu alabilmesi için onun normal bir biçimde sonlanmış olduğunu belirlemesi gerekir. İşte <sys/wait.h> 
    içerisindeki WIFEXITED makrosu ile bu belirleme yapılabilmektedir. Bu makroya wait fonksiyonuna geçirilmiş olan int nesne 
    verilir. Makro bu nesnenin bazı bitlerinden alt prosesin normal sonlanıp sonlanmadığını anlar ve eğer alt proses normal 
    bir biçimde sonlanmışsa sıfır dışı herhangi bir değere, normal bir biçimde sonlanmamışsa sıfır değerine geri döner. Benzer 
    biçimde biz prosesin anormal bir biçimde bir sinyal dolayısıyla sonlanıp sonlanmadığını da WIFSIGNALED makrosuyla tespit 
    edebiliriz. Proses SIGSTOP sinyali ile geçici süre durdurulmuş da olabilir. Bu durum da WIFSTOPPED makrosu ile tespit 
    edilebilmektedir. Prosesin exit kodu ise WEXITSTATUS makrosuyla elde edilmektedir. Yine bu makroya wait fonksiyonuna geçirilen 
    int nesne argüman olarak verilmektedir. Programcı wait fonksiyonuna argüman olarak NULL adres de geçebilir. Bu durumda 
    fonksiyon exit koduyla ilgili bir yerleştirme yapmaz. Ancak yine ilk alt prosesin bitmesini bekler.

    Eğer wait fonksiyonu çağrıldığında zaten üst prosesin yarattığı herhangi bir alt proses yoksa ya da fonksiyona geçersiz 
    bir adres geçilmişse fonksiyon başarısız olabilmektedir.

    wait fonksiyonunun tasarımında şu problemler vardır:

    - wait fonksiyonu ile biz belli bir alt prosesi bekleyememekteyiz. wait çağrıldığında henüz hiçbir alt proses sonlanmamışsa 
    wait fonksiyonu ilk sonlanan alt prosesin exit kodunu alır.

    - wait fonksiyonu çağrıldığında eğer zaten birden fazla alt proses sonlanmış durumdaysa POSIX standartları hangi alt prosesin 
    exit kodunun elde edileceği konusunda bir garanti vermemektedir. Yani bu durumda wait fonksiyonunun ilk sonlanan alt prosesin
    exit kodunu alması garanti edilmemiştir.

    Aşağıdaki örnekte üst proses fork fonksiyonu ile alt prosesi yaratmıştır ve wait fonksiyonu ile onu beklemiştir. 
    Alt proses normal bir biçimde sonlanmışsa onun exit kodunu alıp ekrana yazdırmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

void child_proc(void)
{
    for (int i = 0; i < 10; ++i) {
        printf("child running: %d\n", i);
        sleep(1);
    }

    exit(100);
}

int main(void)
{
    pid_t pid;
    int status;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0)
        child_proc();

    printf("parent waiting for child to exit...\n");

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("child exited with exit code %d\n", WEXITSTATUS(status));

    printf("Ok, parent continues running...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ise üst proses wait fonksiyonu çağırmadan alt proses sonlanmıştır. Tabii bu durumda üst proses hiç beklemeden 
    alt prosesin exit kodunu alıp yoluna devam edecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

void child_proc(void)
{
    printf("child terminates...\n");

    exit(100);
}

int main(void)
{
    pid_t pid;
    int status;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0)
        child_proc();

    for (int i = 0; i < 10; ++i) {
        printf("parent running: %d\n", i);
        sleep(1);
    }

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("child exited with exit code %d\n", WEXITSTATUS(status));

    printf("Ok, parent continues running...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii üst proses ne kadar fork yapmışsa o kadar sayıda wait yapmalıdır. Çünkü her wait fonksiyonu bir alt prosesin 
    sonlanma bilgilerini alacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define NCHILDS        5

void exit_sys(const char *msg);

void child_proc(int val)
{
    srand(val);

    sleep(rand() % 5 + 1);

    exit(val);
}

int main(void)
{
    pid_t pids[NCHILDS];
    int status;

    printf("parent is waiting for childs to exit...\n");

    for (int i = 0; i < NCHILDS; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0)
            child_proc(100 + i);
    }

    for (int i = 0; i < NCHILDS; ++i) {
        if (wait(&status) == -1)
            exit_sys("wait");

        if (WIFEXITED(status))
            printf("child exited with exit code %d\n", WEXITSTATUS(status));
    }

    printf("Ok, parent continues running...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    waitpid fonksiyonu wait fonksiyonunun daha gelişmiş bir biçimidir. Fonksiyonun prototipi şöyledir:

    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int *status, int options);

    Fonksiyonun birinci parametresi beklenecek alt prosesin proses id değerini belirtir. Bu sayede programcı belli bir alt prosesi 
    bekleyebilmektedir. Bu birinci parametre aslında birkaç biçimde geçilebilmektedir. Eğer bu parametre negatif bir proses id 
    değeri olarak geçilirse bu durumda fonksiyon proses grup id'si bu değerin pozitifi olan herhangi bir alt prosesi beklemektedir. 
    Eğer bu parametre -1 olarak geçilirse bu durumda fonksiyon tamamen wait fonksiyonundaki gibi davranmaktadır. Yani herhangi bir 
    alt prosesi beklemektedir.Eğer bu parametre 0 olarak geçilirse fonksiyon proses grup id'si waitpid fonksiyonunu çağıran prosesin 
    id'si ile aynı olan herhangi bir alt prosesi beklemektedir. Tabii normal olarak bu parametreye programcı pozitif olan bir proses 
    id geçer. Bu durumda fonksiyon o alt prosesi bekleyecektir. (Tabii bu parametreye geçilen proses id, o prosesin bir alt prosesi 
    değilse fonksiyon yine başarısız olmaktadır.) Fonksiyonun ikinci parametresi exit bilgisinin yerleştirileceği int türden nesnenin 
    adresini alır. Üçüncü parametre bazı özel değerlerin bit düzeyinde OR'lanmasıyla oluşturulabilmektedir:

    WNOHANG: Bu durumda waitpid eğer alt proses henüz sonlanmamışsa bekleme yapmaz, başarısızlıkla sonuçlanır. 
    WUNTRACED, WCONTINUED: Prosesin durdurulması ve devam ettirilmesi ile ilgili bilginin elde edilmesinde kullanılmaktadır.

    Tabii bu üçüncü parametre genellikle 0 geçilmektedir. 0 geçilmesi bu bayraklardan hiçbirinin kullanılmadığı anlamına gelmektedir. 
    O halde aslında wait(&status) çağrısı ile waitpid(-1, &status, 0) eşdeğerdir.

    waitpid fonksiyonunda da ikinci parametre NULL adres geçilebilir. Bu durumda proses beklenir ama exit bilgileri elde edilmez.

    waitpid fonksiyonu da başarı durumunda beklenen proses id değeri ile başarısızlık durumunda -1 değeriyle geri dönmektedir.

    Aşağıdaki örnekte 5 tane alt proses yaratılmış ancak bunlar herhangi bir sırada değil yaratım sırasına göre waitpid fonksiyonu 
    ile beklenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define NCHILDS        5

void exit_sys(const char *msg);

void child_proc(int val)
{
    srand(val);

    sleep(rand() % 5 + 1);

    exit(val);
}

int main(void)
{
    pid_t pids[NCHILDS];
    int status;

    printf("parent is waiting for childs to exit...\n");

    for (int i = 0; i < NCHILDS; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0)
            child_proc(100 + i);
    }

    for (int i = 0; i < NCHILDS; ++i) {
        if (waitpid(pids[i], &status, 0) == -1)
            exit_sys("wait");

        if (WIFEXITED(status))
            printf("child exited with exit code %d\n", WEXITSTATUS(status));
    }

    printf("Ok, parent continues running...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Programcının fork fonksiyonu ile her yarattığı alt prosesi wait fonksiyonları ile beklemesi iyi bir tekniktir. Aksi halde
    sonraki paragrafta ele alacağımız gibi "hortlak (zombie)" proses problemi oluşabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz kabuk üzerinden program çalıştırdığımızda fork işlemini kabuk uygulamaktadır. Dolayısıyla çalıştırılan programın exit 
    kodunu da üst proses olan kabuk almaktadır. İşte biz $? ile kabuk üzerinde son çalıştırılan programın exit kodunu 
    elde edebiliriz. Örneğin:

    $ ./sample
    $ echo $?
    100
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde prosesler konusunda çokça karşılaşılan "zombie (hortlak)" proses biçiminde bir kavram vardır. 
    Zombie sözcük anlamı olarak "tam ölememiş canlılar" için kullanılmaktadır. Bir alt proses sonlandığında işletim sistemi onun 
    kaynaklarını boşaltmaktadır. Örneğin prosesin bellek alanı tamamen sisteme iade edilmektedir. Prosesin açmış olduğu dosyalar
    kapatılmaktadır. Ancak işletim sistemi, alt prosesin exit kodunu üst prosese iletebilmek için proses kontrol bloğunu proses 
    bittiğinde hemen serbest bırakmamaktadır. Prosesin exit kodu proses kontrol bloğunda saklanmaktadır. İşletim sistemi bu exit 
    kodunu üst proses herhangi bir zaman isteyebilir diye proses kontrol bloğunu (Linux'taki task_struct yapısı) sisteme iade etmez. 
    Böylece bir alt proses bittiğinde eğer üst proses wait fonksiyonlarıyla alt prosesin exit kodunu henüz almamışsa "kendisi bitmiş 
    ama proses kontrol bloğu boşaltılamamış" bir durum oluşmaktadır. İşte bu duruma UNIX/Linux dünyasında "zombie process" denilmektedir. 
    Zombie proseslerde prosesin id değeri de "üst proses wait ya da waitpid fonksiyonunu kullanabilir" diye sisteme iade edilmemektedir.

    Alt ve üst proseslerin sonlanması şu biçimlerde olabilmektedir:

    1) Üst proses alt prosesten önce sonlanmış olabilir. Bu durumda alt proses "öksüz (orphan)" duruma düşer. Sistem de 1 numaralı 
    id'ye sahip olan "init" prosesini öksüz prosesin üst prosesi olarak atar. Daha sonra alt proses sonlandığında init prosesi 
    alt prosesin exit kodunu alarak onun zombie duruma düşmesini engeller.

    2) Alt proses üst prosesten daha önce sonlanmıştır. İşte bu durumda eğer üst proses wait fonksiyonlarını henüz uygulamamışsa
    alt proses zombie durumda kalır. Tabii üst proses wait fonksiyonlarını uyguladığı anda alt proses zombie olmaktan kurtulur.

    3) Alt proses üst prosesten önce sonlanmıştır. Ancak üst proses de wait fonksiyonlarını uygulamadan sonlanmıştır. Bu durumda
     yine işletim sistemi artık exit kodunu alacak bir üst proses kalmadığı için alt prosesi zombie olmaktan çıkartır. Yani 
     onun proses kontrol bloğunu ve id değerini boşaltır.

    O halde zombie proses yalnızca şu süreçte ortaya çıkmaktadır: "Alt proses sonlanmıştır ancak üst proses wait fonksiyonlarını 
    uygulamadan çalışmasına devam etmektedir."
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                26. Ders 28/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi bir "zombie" proses durumu oluşturalım. Yapacağımız şey alt prosesi sonlandırıp üst prosesin wait fonksiyonlarını 
    uygulamadan yoluna devam etmesini sağlamaktır. Zombie prosesler "ps -l" komutunda "defunct" olarak gösterilmektedir. 
    Bunların "proses durumları da (process state)" "Z" harfi ile belirtilmektedir. Örneğin:

    $ ps -la
    F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    0 S  1000   10612    1868  0  80   0 -   622 hrtime pts/1    00:00:00 sample
    1 Z  1000   10613   10612  0  80   0 -     0 -      pts/1    00:00:00 sample <defunct>
    4 R  1000   10621    1618  0  80   0 -  3540 -      pts/0    00:00:00 ps
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {            /* üst proses */
        for (int i = 0; i < 60; ++i) {
            printf("parent process continues running: %d\n", i);
            sleep(1);
        }
    }
    else {                    /* alt proses */
        printf("child terminates...\n");

        exit(EXIT_SUCCESS);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Zombie proses oluşmasının şu sorunları vardır:

    - Üst prosesin ömrü fazla değilse genellikle üst prosesin zombie proses oluşturması ciddi bir soruna yol açmaz. Ancak üst 
    proses uzun süre çalışıyorsa (günlerce, aylarca) zombie prosesler önemli bir sistem kaynağının harcanmasına yol açabilmektedir.

    - Zombie proseslere ilişkin proses id değerleri o proses zombie'likten kurtulana kadar sistem tarafından kullanılamamaktadır. 
    Sürekli zombie proses üreten bir program proses id'lerin tükenmesine bile yol açabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi zombie proses oluşmasının engellenmesinin tek yolu wait fonksiyonlarını uygulamak mıdır? Çünkü wait fonksiyonları
    uygulandığında üst proses alt proses bitene kadar blokede bekleyecektir. Halbuki bazı uygulamalarda üst prosesin yoluna 
    devam etmesi ve bloke olmaması istenir. İşte zombie oluşmasının otomatik engellenmesi için iki yöntem kullanılmaktadır:

    1) Alt proses bittiğinde SIGCHLD sinyalinde üst proses wait fonksiyonlarını uygularsa üst proses blokede kalmadan zombie 
    durumunu engelleyebilir.

    2) Biz alt prosesin exit kodunu almak istemediğimizi işletim sistemine söylersek işletim sistemi alt proses bittiğinde 
    onu zombie duruma sokmadan onun kaynaklarını boşaltabilmektedir.

    Bu iki zombie engelleme yöntemi de "sinyal (signal)" denilen konu ile ilgilidir. Bu konu ileride ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinin büyük çoğunluğunda prosese özgü ismine "çevre değişkenleri (environment variables)" denilen 
    bir veri yapısı bulundurulmaktadır. Çevre değişkenleri anahtar-değer çiftlerini tutan anahtar verildiğinde onun değerini 
    bize veren "sözlük (dictionary)" tarzı bir veri yapısı organizasyonudur. Tabii sözlük tarzı veri yapıları pek çok nesne 
    yönelimli programlama dilinin standart kütüphanesinde "map", "set", "dictionary", "hashtable" gibi isimlerle bulunmaktadır. 
    Ancak çevre değişkenleri, bir sözlük veri yapısının basit bir biçimde işletim sistemi tarafından aşağı seviyeli bir 
    gerçekleştirimidir.

    Çevre değişkenleri konusunda anahtar-değer çiftlerinin anahtarlarına "çevre değişkeni (environment variable)" denilmektedir. 
    O anahtara karşı gelen değere de "o çevre değişkeninin değeri" denir. Çevre değişkenlerinin anahtarları da değerleri de birer 
    yazı biçimindedir. Örneğin anahtar "ankara" yazısı olabilir, onun değeri de "06" yazısı olabilir. Anahtar "eskisehir" yazısı 
    olabilir onun değeri de "26" yazısı olabilir.

    Çevre değişkenleri ve değerleri pek çok işletim sisteminde prosesin bellek alanı içerisinde tutulmaktadır. Örneğin Windows 
    sistemleri, UNIX/Linux sistemleri tipik olarak çevre değişkenlerini proses bellek alanı içerisinde özel bir alanda tutmaktadır. 
    Bu konu çerçevesinde programcının şu işlemleri yapabilmesi gerekmektedir:

    - Bir çevre değişkeni (yani anahtar) verildiğinde onun değerini elde etmek.
    - Prosesin çevre değişken listesine yeni bir anahtar-değer çifti eklemek
    - Prosesin tüm çevre değişken listesini elde etmek.

    UNIX/Linux sistemlerinde prosesin çevre değişkenlerinin (yani anahtarların) büyük harf-küçük harf duyarlılığı vardır.
    Ancak Windows sistemlerinde çevre değişkenlerinin büyük harf-küçük harf duyarlılığı yoktur. Genel olarak çevre değişkenleri 
    (yani anahtarlar) boşluk karakterleri içermemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir çevre değişkeni (yani anahtar) verildiğinde onun değerini elde etmek için getenv isimli standart C fonksiyonu kullanılabilir. 
    Fonksiyonun prototipi şöyledir:

    #include <stdlib.h>

    char *getenv(const char *name);

    Fonksiyon parametre olarak çevre değişkeninin ismini (yani anahtarı) alır geri dönüş değeri olarak onun değerinin bulunduğu 
    bellek adresini verir. Fonksiyonun geri döndürdüğü adres prosesin adres alanı içerisindeki statik düzeyde tahsis edilmiş 
    bir alanın adresidir. Fonksiyon eğer ilgili çevre değişkeni yoksa NULL adrese geri dönmektedir. Fonksiyonun geri dönüş 
    değeri const olmayan bir gösterici olsa da programcı geri döndürülen bu adresteki yazıyı değiştirmeye çalışmamalıdır. 
    C standartlarında bu değiştirme durumu işletim sisteminin isteğine bırakılmış olsa da UNIX/Linux sistemlerinde bu durum 
    tanımsız davranışa yol açmaktadır. getenv fonksiyonu başarısızlık durumunda errno değişkenini herhangi bir değerle set 
    etmemektedir.

    Aşağıdaki örnekte komut satırından alınan çevre değişkeninin değeri stdout dosyasına yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    char *value;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((value = getenv(argv[1])) == NULL) {
        fprintf(stderr, "environment variable not found: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    puts(value);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişkenleri, fork işlemi sırasında üst prosesten alt prosese aktarılmaktadır. Zaten çevre değişkenleri 
    prosesin bellek alanında saklandığından fork işlemi de prosesin bellek alanının bir kopyasını oluşturduğundan bu işlemin 
    doğal sonucu olarak üst prosesin çevre değişkenleri alt prosese aktarılmaktadır. Örneğin biz kabuk üzerinden bir program 
    çalıştırdığımızda kabuğun çevre değişkenleri bizim programımıza aktarılacaktır.

    Kabuğun çevre değişken listesi env kabuk komutuyla her satırda "anahtar=değer" biçiminde görüntülenebilmektedir.

    Pekiyi kabuk programındaki çevre değişkenleri nasıl oluşturulmuştur? İşte prosesler birbirlerini yaratırken kabuk prosesine 
    gelene kadar bazı prosesler çevre değişkenlerine eklemeler yapmaktadır. Örneğin kabuk programını çalıştıran login programı 
    "HOME", "USER", "SHELL" gibi çevre değişkenlerini prosesin çevre değişken listesine eklemektedir. Benzer biçimde kabuk da 
    pek çok çevre değişkenini çevre değişken listesine eklemiş durumdadır. Yani biz programımızı kabuk üzerinden çalıştırırken 
    kümülatif olarak çeşitli prosesler çevre değişken listesine çeşitli çevre değişkenlerini eklemiş olmaktadır. Örneğin biz 
    kabuk üzerinde "cd" komutunu kullandığımızda kabuk PWD isimli çevre değişkeninin değerini o anda geçilen dizin biçiminde 
    değiştirmektedir. chdir POSIX fonksiyonu bunu yapmaz. Kabuktaki "cd" komutu bunu yapmaktadır.

    Kabuk üzerinde bir çevre değişkenini başına $ olacak biçimde yazarsak kabuk sanki o yazı yerine onun değerine ilişkin 
    yazıyı oraya yazmışız gibi davranmaktadır. Örneğin biz kabuk üzerinde $PATH yazarsak kabuk bu $PATH yazısını kaldırıp 
    onun yerine onun değerini oraya yerleştirecektir. (Aynı işlem Windows sistemlerinde %NAME% ile yapılmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                27. Ders 29/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişken listesine yeni bir anahtar-değer çifti eklemek için setenv ve putenv isimli POSIX fonksiyonları 
    kullanılmaktadır. Bu fonksiyonlar standart C fonksiyonları değildir. C'de prosesin çevre değişken listesine ekleme yapan 
    standart bir fonksiyon yoktur.

    setenv fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    int setenv(const char *name, const char *value, int overwrite);

    Fonksiyonun birinci parametresi çevre değişkeninin ismini ikinci parametresi onun değerini alır. Üçüncü parametre eğer o 
    çevre değişkeni zaten varsa onun değerinin değiştirilip değiştirilmeyeceğini belirtir. Bu parametre sıfır dışı bir değer 
    olarak geçilirse çevre değişkeninin değeri değiştirilir. Sıfır geçilirse değiştirilmez ve fonksiyon yine başarıyla geri 
    döner. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Başarısızlık durumunda 
    errno değeri uygun biçimde set edilmektedir.

    Aşağıdaki örnekte komut satırı argümanı ile verilen çevre değişkenleri setenv fonksiyonu ile prosesin çevre değişken 
    listesine eklenmiş ve sonra getenv fonksiyonu ile onların değerleri elde edilmiştir. Girişin aşağıdaki gibi yapılması gerekir:

    $ ./sample ali=100 veli=200 selami=300

    Program '=' karakterini strchr fonksiyonu ile aramış eğer onu bulursa '=' karakteri yerine '\0' karakterini yerleştirmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char *str;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i)    {
        if ((str = strchr(argv[i], '=')) == NULL) {
            fprintf(stderr, "invalid argument: %s\n", argv[i]);
            continue;
        }
        *str = '\0';
        if (setenv(argv[i], str + 1, 1) == -1)
            perror("setenv");
    }

    for (int i = 1; i < argc; ++i) {
        if ((str = getenv(argv[i])) == NULL) {
            fprintf(stderr, "environment variable not found: %s\n", argv[i]);
            continue;
        }
        printf("%s ---> %s\n", argv[i], str);
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    putenv fonksiyonu da yine prosesin çevre değişken listesine ekleme yapmak için kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <stdlib.h>

    int putenv(char *str);

    Fonksiyon parametre olarak "anahtar=değer" biçiminde bir yazı almaktadır. Fonksiyon ilgili çevre değişkeni zaten varsa 
    her zaman onun değerini güncellemektedir. Eğer yazıda '=' karakteri kullanılmazsa boş değeri boş olan (yani elde edildiğinde 
    yalnızca null karakter veren bir çevre değişkeni oluşturulmaktadır. Fonksiyon yine başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir.) putenv fonksiyonunda verilen adres doğrudan 
    prosesin çevre değişken listesi olarak kullanılmaktadır. Verilen adresteki bilginin program çalıştığı sürece kalıcı olmasına 
    dikkat ediniz.

    Aşağıdaki örnekte yine program aşağıdakine benzer çalıştırılmalıdır:

    $ ./sample ali=100 veli=200
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char *str;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i)
        if (putenv(argv[i]) == -1)
            perror("putenv");

    /* ... */

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte putenv fonksiyonu ile prosesin çevre değişken listesine bir ekleme yapılmıştır. Sonra buradaki anahtar 
    değer çifti program içerisinde değiştirilmiştir. Prosesin çevre değişken listesinin nasıl organize edildiği izleyen 
    paragrafta ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void exit_sys(const char *msg);

int main(void)
{
    char *value;
    char env[1024] = "city=istanbul";

    if (putenv(env) == -1)
        exit_sys("setenv");

    if ((value = getenv("city")) == NULL) {
        fprintf(stderr, "cannot find environment variable \"city\"!...\n");
        exit(EXIT_FAILURE);
    }

    puts(value);

    strcpy(env, "village=urla");

    if ((value = getenv("village")) == NULL)
        fprintf(stderr, "cannot find environment variable \"village\"!...\n");

    puts(value);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde genel olarak çevre değişkenleri bir gösterici dizisi yoluyla tutulmaktadır. Her çevre değişkeni 
    aslında "anahtar=değer\0" biçiminde bir yazı olarak oluşturulmakta ve bu yazıların başlangıç adresleri de bir gösterici 
    dizisinde saklanmaktadır. Bu gösterici dizisinin sonunda da NULL adres bulunmaktadır. Bu gösterici dizisinin başlangıç 
    adresi environ isimli bir global göstericiyi gösteren göstericiyle tutulmaktadır. Yani prosesin çevre değişken listesi 
    aşağıdaki gibi bir veri yapısıyla oluşturulmuştur:

    environ ---->   adres   ---> ali=100\0
                    adres   ---> veli=200\0
                    adres   ---> selami=300\0
                    ...
                    NULL

    Aslında putenv fonksiyonu bizim "anahtar=değer" biçiminde verdiğimiz yazının adresini eğer anahtar yoksa doğrudan
    bu gösterici dizisine eklemektedir. Örneğin:

    char s[] = "ayse=500";

    putenv(s);

    environ ---->   adres   ---> ali=100\0
                    adres   ---> veli=200\0
                    adres   ---> selami=300\0
                    ...
                    s dizisinin adresi   ----> ayse=500\0
                    NULL

    Maalesef bu environ global değişkeninin extern bildirimi herhangi bir başlık dosyasında bulundurulmamıştır. Prosesin çevre 
    değişken listesine erişmek isteyen programcıların bu extern bildirimini kendilerinin yapması gerekmektedir. Örneğin:

    extern char **environ;

    O halde prosesin bütün çevre değişkenlerinin listesini almak oldukça kolaydır. Aşağıdaki örnekte prosesin tüm çevre 
    değişkenlerinin listesi elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

extern char **environ;

int main(void)
{
    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    getenv fonksiyonu aşağıdaki gibi basit bir biçimde gerçekleştirilebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern char **environ;

char *mygetenv(const char *name)
{
    char *str;

    for (int i = 0; environ[i] != NULL; ++i) {
        if ((str = strchr(environ[i], '=')) != NULL)
            if (!strncmp(name, environ[i], str - environ[i]))
                return str + 1;
    }

    return NULL;
}

int main(void)
{
    char *val;

    if ((val = mygetenv("xxx")) == NULL) {
        fprintf(stderr, "environment variable not found!...\n");
        exit(EXIT_FAILURE);
    }
    puts(val);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişkenlerine ilişkin gösterici dizisi ve onların gösterdikleri yerler prosesin bellek alanı içerisindedir. 
    fork işlemi sırasında üst prosesin tüm bellek alanının bir kopyası oluşturulduğuna göre alt prosesin çevre değişken listesi 
    üst prosesinkinin aynısı olacaktır. Ancak fork işleminden sonra üst proses ya da alt proses çevre değişken listesinde bir 
    değişiklik yaparsa artık yalnızca o değişiklik o prosese özgü olacaktır. Çünkü fork işlemi sırasında kopyalama yapıldıktan 
    sonra artık üst prosesle alt prosesin bellek alanları birbirinden tamamen ayrılmış olur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir çevre değişkeni unsetenv isimli POSIX fonksiyonuyla prosesin çevre değişken listesinden silinebilmektedir. Fonksiyonun 
    prototipi şöyledir:

    #include <stdlib.h>

    int unsetenv(const char *name);

    Fonksiyon çevre değişkenin ismini almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri önder ve 
    errno uygun biçimde set edilir. Eğer ilgili çevre değişkeni zaten yoksa fonksiyon bir şey yapmaz ancak başarılı bir biçimde 
    geri dönmektedir.

    Aşağıdaki örnekte komut satırından alınan bir çevre değişkeninin önce değeri yazdırılmış sonra o çevre değişkeni silinmiş, 
    sonra da o çevre değişkeninin yeniden değeri elde edilmek istenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char *value;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((value = getenv(argv[1])) == NULL) {
        fprintf(stderr, "environment variable not found: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    puts(value);

    if (unsetenv(argv[1]) == -1)
        exit_sys("ensetenv");

    if ((value = getenv(argv[1])) == NULL) {
        fprintf(stderr, "environment variable not found: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    puts(value);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz programımızı çalıştırdığımızda belli bir çevre değişkeninin zaten var olmasını nasıl sağlayabiliriz? Çevre 
    değişkenleri fork işlemi sırasında alt prosese aktarıldığına göre biz eğer kabuk programın (bash) çevre değişken listesine 
    bir ekleme yaparsak kabuk bizim programınızı çalıştırırken fork yapacak ve onun çevre değişkenleri bizim programımıza geçecektir. 
    Pekiyi kabuk programının çevre değişken listesine nasıl ekleme yapabiliriz? İşte bu işlem şöyle yapılabilmektedir:

    $ CITY=Eskisehir
    $ export CITY

    Komut satırında "anahtar=değer" biçiminde bir yazı yazıp ENTER tuşuna basarsak biz kabuk dili için bir kabuk değişkeni yaratmış 
    oluruz. Bu kabuk değişkeninin aynı zamanda kabuğun çevre değişkeni yapılması için export komutu kullanılmaktadır. Tabii bu iki 
    komut tek hamlede de verilebilmektedir:

    $ export CITY=Eskisehir

    Çevre değişkenini kabuktan silmek için de unset komutu kullanılmaktadır. Örneğin:

    $ unset CITY

    Bir çevre değişkeninin (aslında genel olarak kabul değişkeninin) değerini elde etmek için UNIX/Linux sistemlerinde çevre 
    değişkeninin başına $ karakteri getirilir. Örneğin:

    $ echo $CITY

    Burada biz CITY çevre değişkeninin değerini ekrana yazdırmış olduk. $ karakterinden sonra çevre değişkeni küme parantezlerine 
    de alınabilir. Örneğin:

    $ echo ${CITY}

    Buradaki küme parantezine bazı durumlarda gereksinim duyulabilmektedir. Örneğin kabuk üzerinde CITY çevre değişkenini yukarıdaki 
    gibi yaratmış olalım. Şimdi de bu çevre değişkeninden hareketle bu çevre değişkeninin değerine yapışık olarak "CENTER" sözcüğünü 
    de eklemek isteyelim:

    $ export OTHER=$CITYCENTER

    Bu durumda kabuk sanki bizim CITYCENTER isimli bir çevre değişkeninin değerini yazdırmak istediğimizi sanacaktır. Bu durumda 
    mecburen küme parantezleri kullanılmalıdır. Örneğin:

    $ export OTHER=${CITY}CENTER

    Aslında pek çok kabuk programında hiç kabuk programının çevre değişkenlerini set etmeden, doğrudan çalıştırılacak program 
    için çevre değişkenleri belirlenebilmektedir. Bunun için önce "değişken=değer" çiftleri yazılarak program dosyası belirtilir. 
    Örneğin:

    $ XX=10 YY=20 ./sample

    Burada XX ve YY kabuğun çevre değişken listesine eklenmemektedir. Doğrudan ./sample prosesinin çevre değişkeni yapılmaktadır. 
    Kabuk bu durumda fork işleminden sonra alt proseste bu çevre değişkenlerini ekleyip exec yapmaktadır.

    Kabuk üzerinde yukarıdaki gibi çevre değişkeni oluşturduğumuzda bunun kalıcılığı olmaz. Yani bu çevre değişkeni o kabuk programının 
    çevre değişkeni olur. Biz başka terminal açsak o başka bir proses olacağı için bu çevre değişkeni orada bulunmayacaktır. Pekiyi 
    kabuk üzerindeki çevre değişkenlerinin kalıcılığını nasıl sağlayabiliriz? İşte bunu sağlamak için kabukların "startup" dosyaları 
    kullanılmaktadır. Kabukların startup dosyaları kabuğun nasıl çalıştırıldığına bağlı olarak değişmektedir. Kabuk programları üç 
    biçimde çalıştırılabilmektedir:

    1) Interactive login shell
    2) Interactive Non-login shell
    3) Non-interactive shell

    "Interactive shell" demek "komut satırına düşen kullanıcının komut verip çalıştırdığı shell" demektir. "login shell" demek bize 
    "user name" ve "password" soran shell demektir. "Non-interactive shell" demek ise tek bir komutu çalıştırıp işlemini sonlandıran 
    shell demektir. Değişik kabuk programlarının startup dosyaları farklıdır. Biz burada bash üzerinde duracağız. bash kabuğunun "
    user manual" dokümanındaki ilgili bölüm aşağıdaki bağlantıdan incelenebilir:

    https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html

    Eğer bash "interactive login shell" biçiminde çalıştırılmışsa önce "/etc/profile" dosyasını çalıştırır, sonra sırasıyla aşağıdaki 
    dosyalardan hangisini ilk bulursa yalnız onun içerisindeki komutları çalıştırmaktadır:

    $ ~/.bash_profile
    $ ~/.bash_login
    $ ~/.profile

    Eğer bash "interactive non-login shell" olarak çalıştırılırsa (örneğin masaüstünden) bu durumda bash "~/.bashrc" dosyasındaki 
    komutları çalıştırmaktadır. Yani biz "~/.bashrc" dosyasına export ile çevre değişkeni eklersek masaüstünden terminali açtığımızda 
    o çevre değişkeni kabuk üzerinde ekli olarak görünecektir. Tabii programcı hem "interactive login shell" hem de "interactive 
    non-login" shell için aynı komutların çalıştırılmasını isteyebilir. Bunu sağlamanın pratik bir yolu komutları ~/.bashrc dosyasına 
    yazıp ~/.bash_profile içerisinden bu dosyanın çalıştırılmasını sağlamaktır. Bu işlem şöyle yapılabilir:

    if [ -f ~/.bashrc ]; then . ~/.bashrc; fi

    Eğer bash interactive olmayan bir biçimde (-c seçeneği ile) çalıştırılırsa bu durumda BASH_ENV isimli bir çevre değişkenini 
    araştırır. Eğer bulursa onun değerinin belirttiği script dosyasını çalıştırır.

    Ayrıca UNIX/Linux'ta kullanılan kabuk programlarında bir program çalıştırılırken onun soluna "çevre_değişkeni=değer" yazılırsa 
    belirtilen çevre değişkeni çalıştırılan programa aktarılmaktadır. Örneğin:

    $COUNTRY=Turkey CITY=Ankara ./sample

    Burada COUNTRY ve CITY çevre değişkenleri sample programına aktarılacaktır. Böyle bir çalıştırmada burada belirtilen değişkenlerin
    kabuk değişkeni olarak ya da kabuğun çevre değişkeni olarak set edilmediğine dikkat çekmek istiyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi çevre değişkenlerine neden gereksinim duyulmaktadır? Çevre değişkenleri birtakım aşağı seviyeli işlemlerin parametrik 
    hale getirilmesi için kullanılmaktadır. Yani aşağı seviyeli bazı işlemlerin basit bir biçimde dışarıdan değiştirilmesine 
    olanak sağlamaktadır. Bazı çevre değişkenleri bazı POSIX fonksiyonları tarafından kullanılmaktadır. Örneğin exec fonksiyonlarının 
    p'li biçimleri prosesin PATH çevre değişkenine başvurmaktadır. Ya da örneğin dinamik bir kütüphane yüklenirken dinamik yükleyici 
    yükleyicisi prosesin LD_LIBRARY_PATH çevre değişkenine başvurmaktadır. Bazen çevre değişkenleri uygulama programcıları tarafından 
    da kullanılmaktadır. Örneğin biz programımız içerisinde bir dosyanın yerini belirlemek isteyelim. Ancak kullanıcı bu dosyayı 
    farklı bir yere yerleştirebiliyor olsun. Bunu bir çevre değişkeni ile ayarlanabilir hale getirebiliriz:

    char *data_path = "datafile.dat";
    char *value;
    FILE *s;

    if ((value = getenv("DATA_LOCATION")) != NULL)
        data_path = value;

    if (f = fopen(data_path, "r")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }
    ...

    Örneğin gcc derleyicisi <...> biçiminde include edilmiş dosyaların yerlerini aynı zamanda C_INCLUDE_PATH isimli bir çevre 
    değişkeninde de aramaktadır. Yani derleyici standart include dosyalarının bulunduğu yerin dışında bu çevre değişkeni ile 
    belirtilen dizinlere de bakmaktadır. Tabii birden fazla dizin belirtilebilir bu durumda ':' ile onları ayırmak gerekir.
     Örneğin:

    $ export C_INCLUDE_PATH=/home/kaan:/home/kaan/Study
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir program dosyasını çalıştırmak için ismine "exec fonksiyonları" denilen bir grup POSIX fonksiyonu kullanılmaktadır. 
    Bu fonksiyonların yaptıkları işlemler birbirine benzerdir. Ancak fonksiyonların parametrik yapıları arasında bazı farklılıklar 
    vardır. exec fonksiyonlarını şunlardır:

    execl
    execle
    execlp
    execv
    execve (Linux'ta sistem fonksiyonu olarak yazılmıştır)
    execvp
    fexecve (Linux'ta execveat sistem fonksiyonu)

    Ayrıca POSIX standartlarında tanımlı olmasa da da GNU C kütüphanesinde execvpe isimli bir exec fonksiyonu da bulunmaktadır. 
    Yine Linux sistemlerine özgü bir biçimde execveat isimli bir fonksiyon da vardır.

    Aslında UNIX/Linux sistemleri bu exec fonksiyonlarının hepsini sistem fonksiyonu biçiminde bulundurmamaktadır. Örneğin
    Linux sistemlerinde execve fonksiyonu bir sistem fonksiyonu biçiminde yazılmıştır. Taşınabilir exec fonksiyonları bu 
    sistem fonksiyonunu çağıran kütüphane fonksiyonları biçiminde gerçekleştirilmiştir. Benzer biçimde Linux'a özgü biçimde 
    "execveat" fonksiyonu da bir sistem fonksiyonu biçimine gerçekleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonları prosesin yaşamına başka bir kodla devam etmesini sağlamaktadır. exec fonksiyonlarına biz "çalıştırılabilen 
    bir program dosyasını" parametre olarak veririz. exec fonksiyonları o anda çalışmakta olan programın kodlarını bellekten 
    atıp onun yerine bizim verdiğimiz program dosyasının kodlarını belleğe yükler ve o kodu çalıştırır. exec işlemi ile prosesin 
    kontrol bloğunda ciddi bir değişiklik yapılmaz. Yani prosesin id'si, kullanıcı ve grup id'leri, prosesin çalışma dizini vs. 
    değişmez. exec işlemleriyle prosesin yalnızca kodu değiştirilmektedir. Örneğin "sample" programının içerisinde biz exec 
    fonksiyonlarıyla "mample" programını çalıştırmak istediğimizde "sample" programının bellekteki kodu kaldırılır onun yerine 
    "mample" programının kodu belleğe yüklenir ve "mample" programının kodu çalıştırılır. Ancak prosesin kontrol bloğundaki 
    bilgiler değişmez. Yani exec fonksiyonları uygulandığında proses yaşamına başka bir kodla devam etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                28. Ders 04/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının isimlerinin sonlarında bulunan "l" harfi (execl, execlp) komut satırı argümanlarının tek tek bir liste 
    biçiminde verileceğini belirtmektedir. Fonksiyonların isimlerinin sonundaki "v" harfi ise komut satırı argümanlarının bir 
    dizi (vector) biçiminde verileceğini belirtir. Fonksiyonların isimlerinin sonlarındaki "p" harfi (path) aramanın PATH çevre 
    değişkenine bakılarak yapılacağını, "e" harfi (environment) ise prosesin çevre değişkenlerinin exec sırasında değiştirileceği 
    anlamına gelmektedir. Yukarıda da belirtildiği gibi Linux sistemlerinde execl, execv, execlp, execvp, execle fonksiyonları 
    aslında execve sistem fonksiyonu fonksiyonu çağrılarak gerçekleştirilmiştir. fexecve ise Linux sistemlerinde execveat sistem 
    fonksiyonu çağrılarak gerçekleştirilmiştir. Biz burada bu fonksiyonların üzerinde tek tek duracağız.

    Tüm exec fonksiyonları başarı durumunda geri dönmezler. Çünkü zaten başarı durumunda bu fonksiyonlar başka bir programı 
    yüklemiş ve çalıştırmış durumda olurlar. Bu fonksiyonlar başarısızlık durumunda yine -1 değerine geri dönerler ve errno 
    değeri uygun biçimde set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    execl fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int execl(const char *path, const char *arg0, ... /*, (char *)0 */);

    Fonksiyonun birinci parametresi çalıştırılacak olan programın yol ifadesini almaktadır. Bu yol ifadesi mutlak ya da göreli
    olabilir. Fonksiyonun diğer parametreleri sırasıyla çalıştırılacak programa geçirilecek komut satırı argümanlarının listesini 
    belirtir. Birinci komut satırı argümanının (argv[0]) her zaman program ismi olacak biçimde oluşturulması genel bir beklenti 
    ve C standartlarında öngörülen bir durumdur. Programcı exec uygularken bunu sağlamak zorunda değildir. Ancak bunun sağlanmaması 
    kötü bir tekniktir. Fonksiyon değişken sayıda (... parametresine dikkat ediniz) argüman aldığı için argüman listesinin sonunda 
    NULL adresin bulunması gerekmektedir. Ancak C'de "default argüman dönüştürmesi (default argument conversion)" denilen kurala 
    göre eğer argümanın karşılığında bir parametre türü belirtilmemişse "int türünden küçük türler int türüne, float ise double 
    türüne dönüştürülerek" fonksiyona yollanmaktadır. Burada programcının NULL adres sabitini yalnızca NULL sembolik sabiti biçiminde 
    belirtmemesi gerekir. Çünkü NULL sembolik sabiti düz sıfır olarak da define edilmiş olabilir. Benzer biçimde programcı burada 
    NULL adres sabiti için düz sıfır da geçmemelidir. Uygun olan durum düz sıfır değerinin ya da NULL sembolik sabitinin bir adres 
    türüne (tipik olarak char * türüne) dönüştürülerek aktarılmasıdır. Yukarıda da belirtildiği exec fonksiyonları başarı durumunda 
    zaten geri dönmezler. Başarısızlık durumunda -1 değerine geri dönerler ve errno değişkeni uygun biçimde set edilir. Örneğin:

    if (execl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1)
        exit_sys("execl");

    /* unreachable code */

    Burada execl ile prosesin çalışma dizininde bulunan "mample" programı çalıştırılmak istenmiştir. Diğer argümanlar mample 
    programının main fonksiyonunun argv parametresine geçirilecek komut satırı argümanlarını belirtmektedir.

    exec fonksiyonları çeşitli nedenlerle başarısız olabilir. Örneğin çalıştırılacak program dosyası bulunamayabilir, bulunduğu 
    halde proses dosya için "x" hakkına sahip olmayabilir, çalıştırılabilen dosyanın formatı bozulmuş olabilir. Bu durumlarda
    errno değeri uygun biçimde set edilir.

    Aşağıdaki örneği inceleyiniz. Aşağıdaki sample programı çalıştırıldığında ekranda şu yazıların çıkması gerekir:

    sample running...
    mample running...
    mample
    ali
    veli
    selami
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    printf("sample running...\n");

    if (execl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1)
        exit_sys("execl");

    /* unreachable code */

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("mample running...\n");

    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mademki exec fonksiyonları başarılı olduğunda zaten geri dönmemektedir. O halde exec işlemi aşağıdaki gibi de yapılabilir:

    exec(...);
    exit_sys("exec);

    Burada exec zaten başarılı olduğunda akış aşağıya geçmeyecektir. Başarısız olduğunda akış aşağıya geçecektir. Bu durumda kontrol 
    yapmaya aslında gerek yoktur. Fakat biz kursumuzda genel olarak exec işlemini aşağıdaki gibi yapacağız:

    if (exec(...) == -1)
        exit_sys("exec");
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    fork işlemi ile yeni bir proses yaratılıp yeni prosesin üst proses ile aynı kodu çalıştırması sağlanıyordu. exec işleminde 
    ise prosesin kodu atılıp başka bir programın kodu çalıştırılıyordu. Pekiyi biz hem kendi programımız devam etsin hem de 
    başka bir programı da çalıştıralım istiyorsak bunu nasıl yapabiliriz? İşte bu durumda yalnızca fork ya da yalnızca exec 
    işe yaramamaktadır. fork ve exec fonksiyonlarının birlikte kullanılması gerekmektedir. Şöyle ki: Programcı önce fork yapar, 
    sonra alt proseste exec işlemini uygular. Yani başka bir programın kodunu alt proses çalıştırmış olur. Bu işlem tipik olarak 
    şöyle yapılabilir:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0)
        if (exec(...) == -1)
            exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */

    Burada exec başarılı olursa zaten artık alt prosesin bellek alanı boşaltılıp yeni program yüklenecektir. exec başarısız olursa 
    zaten alt proses sonlandırılmıştır. Tabii yukarıdaki kalıp && operatörüyle de şöyle oluşturulabilir:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && exec(...) == -1)
        exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */

    Tabii üst prosesin yine alt prosesi wait fonksiyonlarıyla beklemesi gerekmektedir. exec işlemi yapılmış olsa da bu bakımdan 
    değişen bir şey yoktur. Çalıştırılan programa ilişkin prosesin üst prosesi yine fork işlemi yapan prosestir. Örneğin:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && exec(...) == -1)
        exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    Bazen fork işleminden sonra üst proses alt proseste bazı ayarlamalar yaptıktan sonra exec uygulamak isteyebilir. Örneğin:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        /* alt proseste bazı işlemler */
        if (exec(...) == -1)
            exit_sys("exec");
        /* unreachable code */
    }

    /* Yalnızca üst prosesin akışı buraya gelir */

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    Aslında fork ve exec nadiren tek başına uygulanmaktadır. Genellikle fork ve exec bir arada yukarıdaki kalıp eşiliğinde 
    kullanılmaktadır.

    Aşağıdaki örnekte üst proses "/bin/ls" programını çalıştırıp yoluna devam etmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execl("/bin/ls", "/bin/ls", "-l", (char *)0) == -1)
        exit_sys("execl");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    fork/exec işlemlerinde kişilerin kafasını karıştıran bir durum oluşmaktadır. Kişiler haklı olarak şöyle düşünmektedir: 
    "fork işlemi ile üst prosesin bellek alanı alt proses için kopyalandığına göre ve alt proseste de exec yapıldığında alt 
    prosesin bellek alanı hemen boşaltılacağına göre burada üst prosesin bellek alanı gereksiz biçimde alt prosese kopyalanmış 
    olmuyor mu?" Gerçekten de ilk bakışta böyle bir durum söz gibi gözükmektedir. Ancak modern işlemcilerin "sayfalama (paging)" 
    mekanizmaları sayesinde aslında fork işlemi sırasında "copy on write" mekanizması işletilmektedir. Yani aslında bugün 
    kullandığımız işlemcilerde fork işlemi sırasında işletim sistemi üst prosesin bellek alanını zaten alt prosese bütünsel olarak 
    kopyalamamaktadır. Kopyalama işlemi aslında "gerektiğinde" yapılmaktadır. Bu mekanizmaya "copy on write" denilmektedir. Bu 
    konuda bilgiler ileride verilecektir. Ancak eski sistemlerde "copy on write" mekanizması ya yoktu ya da etkin olarak 
    gerçekleştirilemiyordu. Yani eski sistemlerde yukarıdaki sorudaki durum gerçekten etkinlik bakımından bir problem oluşturuyordu. 
    Bu nedenle bu eski sistemler zamanında fork fonksiyonunun bellek kopyalamasını yapmayan (ya da minimal düzeyde yapan) vfork 
    isminde bir benzeri de bulundurulmuştur. vfork fonksiyonu eskiden POSIX standartlarında bulunuyordu. 2008'den itibaren POSIX 
    standartlarından kaldırılmıştır. Fakat glibc kütüphanesi bu fonksiyonu bulundurmaya devam etmektedir. Zaten yukarıda da 
    belirttiğimiz gibi modern sistemlerde artık vfork fonksiyonuna gereksinim de kalmamıştır. vfork tamamen fork işlemi yapar. 
    Ancak üst prosesin bellek alanını alt prosese kopyalamaz. Çünkü vfork exec için düşünülmüştür. Yani vfork işleminden sonra 
    exec yapılmalıdır. Eğer vfork işleminden sonra exec yapılmayıp sanki fork yapılmış gibi program devam ettirilirse 
    "tanımsız davranış (undefined behavior)" oluşmaktadır. vfork fonksiyonunun prototipi fork ile aynı biçimdedir:

    #include <unistd.h>

    pid_t vfork(void);

    Eski POSIX standartlarına göre vfork işleminden sonra yalnızca _exit fonksiyonu ya da exec fonksiyonları çağrılabilir.
    Bunun dışında başka bir fonksiyon çağrılamaz. Yani vfork başarılı ise biz ya _exit ile prosesi sonlandırmalıyız ya da exec 
    uygulamalıyız. Tabii exec de başarısız olursa _exit ile (exit ile değil) alt prosesi sonlandırmalıyız. Başka bir fonksiyonun 
    kullanılamamasının nedeni o fonksiyonların kodlarının alt prosese kopyalanmamış olmasındandır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    execv fonksiyonu işlevsel olarak execl fonksiyonu ile aynıdır. Ancak bu fonksiyon çalıştırılacak program için komut satırı 
    argümanlarını bir gösterici dizisi biçiminde ister. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int execv(const char *path, char * const *argv);

    Fonksiyonun birinci parametresi çalıştırılacak program dosyasının yol ifadesini belirtir. İkinci parametresi ise komut satırı
    argümanlarının bulunduğu char türden gösterici dizisinin başlangıç adresini almaktadır. Yani bizim komut satırı argümanlarını 
    bir gösterici dizisine yerleştirip onun adresini vermemiz gerekir. Bu gösterici dizisinin son elemanı NULL adres olmalıdır. 
    Tabii bu durumda tür dönüştürmesi yapmaya gerek yoktur. Örneğin:

    char *argv[] = {"/bin/ls", "-l", NULL};
    ...

    execv("/bin/ls", argv);
    exit_sys("execv");

    execv fonksiyonun ikinci parametresindeki const niteleyicisinin yerine dikkat ediniz. Burada const niteleyicisi adresi geçirilen
    gösterici dizisinin const olduğunu belirtmektedir. O gösterici dizilerinin gösterdiği adresteki yazıların const olduğunu 
    belirtmemektedir.

    Aşağıdaki execv fonksiyonun kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    char *argv[] = {"/bin/ls", "-l", NULL};

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execv("/bin/ls", argv) == -1)
        exit_sys("execl");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    execv ne zaman tercih edilebilir? İşte bazen execl fonksiyonu yerine execv fonksiyonunun kullanılması daha uygun olabilmektedir. 
    Örneğin biz "sample" isimli bir program yazalım. Bu program da komut satırı argümanlarıyla aldığı programı çalıştırsın. 
    Yani "sample" programı şöyle çalıştırılsın:

    $ ./sample /bin/ls -l

    Eğer böyle bir programı execl ile yazamaya çalışırsak bunu pratik bir biçimde başaramayız. Çünkü çalıştıracağımız programın 
    kaç komut satırı argümanı ile çalıştırılacağını baştan bilmemekteyiz. Aşağıda böyle bir programa örnek verilmiştir. Programı 
    şöyle edebilirsiniz:

    $ ./sample /bin/ls -l
    $ ./sample /bin/cp sample.c x.c
    $ ./sample mample ali veli selami
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execv(argv[1], &argv[1]) == -1)
        exit_sys("execv");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının iki p'li versiyonu vardır: execlp ve execvp. Bu p'li versiyonların prototipleri p'siz versiyonlarla 
    aynıdır. Yalnızca ilk parametrenin semantik anlamı farklıdır. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
    int execvp(const char *file, char *const argv[]);

    exec fonksiyonlarının p'li versiyonları şöyle çalışmaktadır:

    - Eğer bu fonksiyonların birinci parametrelerinde belirtilen dosya isminde hiç "/" karakteri kullanılmamışsa bu fonksiyonlar
    önce PATH çevre değişkeninin değerini getenv fonksiyonuyla alıp buradaki yazıyı ':' karakterlerinden parçalara ayırırlar. 
    Bu ':' karakterlerinin arasındaki yazıların dizin belirttiğini varsayarlar. Sonra exec yapılacak dosyayı sırasıyla bu dizinlerde
    ararlar. Eğer bulurlarsa onu exec yaparlar, bulamazlarsa bu fonksiyonlar başarısız olur. Tabii bu fonksiyonlar PATH çevre 
    değişkeninde belirtilen dizinlerdeki aramayı baştan sona doğru yaparlar ve ilk bulduğu dizindeki programı exec işlemine sokarlar. 
    PATH çevre değişkeninin değerinin aşağıdakine benzer bir biçimde bulunması gerekmektedir:

    "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"

    - Eğer p'li exec fonksiyonlarının birinci parametresiyle belirtilen dosya isminde en az bir "/" karakteri varsa bu durumda 
    fonksiyonlar PATH çevre değişkenine başvurmazlar. Birinci parametresiyle belirtilen göreli ya da mutlak yol ifadesinden hareketle
    dosyanın yerini belirlemeye çalışırlar. Başka bir deyişle bu durumda fonksiyonların p'li versiyonlarının p'siz versiyonlarından 
    hiçbir farkı kalmamaktadır. Örneğin:

    execlp("ls", ...);          /* PATH çevre değişkenine başvurulur */
    execlp("./mample", ...);    /* PATH çevre değişkenine başvurulmaz */
    execlp("a/mample", ...);    /* PATH çevre değişkenine başvurulmaz */

    exec fonksiyonlarının p'li versiyonları eğer dosya isminde hiç "/" karakteri yoksa ve PATH dizinlerinde de dosyayı bulamazlarsa 
    prosesin çalışma dizinine bakmamaktadır. Yani bu durumda bu fonksiyonlar yalnızca PATH çevre değişkenindeki dizinlere bakmaktadır. 
    Tabii PATH çevre değişkeninde o andaki prosesin çalışma dizini "." ile de belirtilebilir. Örneğin:

    "/bin:/usr/bin:/:."

    Buradaki "." prosesin çalışma dizinini belirtmektedir. Biz PATH çevre değişkeninin sonuna dizinler ekleyebiliriz. Örneğin:

    PATH=$PATH:/home/kaan

    Tabii bunun kalıcı hale getirilmesi için kabuk programının startup dosyalarına yerleştirilmesi gerekir. Prosesin çalışma 
    dizininin PATH çevre değişkenine eklenmesi güvenlik zafiyeti nedeniyle iyi bir teknik kabul edilmemektedir. Örneğin:

    PATH=$PATH:.

    Pekiyi exec fonksiyonlarının p'li versiyonları PATH çevre değişkenini bulamazsa ne olur? POSIX standartları bu durumdaki 
    davranışın sistemden sisteme değişebileceğini (implementation dependent) belirtmektedir. Pek çok sistem (örneğin Linux ve 
    BSD) bu durumda sanki PATH çevre değişkeni "/bin:/usr/bin" biçimindeymiş gibi davranmaktadır.

    exec fonksiyonlarının p'li versiyonları (execlp ve execvp) aramayı PATH dizinlerinde sırasıyla yapmaktadır. Ancak bu fonksiyonlar 
    dosyayı bir dizinde bulduğunda ve onu sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında EINVAL ve ENOEXEC errno 
    değerini alırsa dosyanın bir kabuk dosyası (shell script) olduğundan çalıştırılamadığı sonucunu çıkartmaktadır ve bu durumda 
    dosyayı /bin/sh (default shell) programı ile çalıştırmaktadır. Ancak exec fonksiyonlarının diğer versiyonları EINVAL ve ENOEXEC 
    hatalarında bunu yapmamaktadır. Bunu yalnızca exec fonksiyonlarının p'li versiyonları yapmaktadır. Exec fonksiyonlarının 
    p'li versiyonları PATH dizinlerinin birinde dosyayı sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında EACCESS errno 
    değeri ile başarısız olurlarsa dosyayı sonraki PATH dizinlerinde aramaya devam ederler. Ancak bu arama sırasında bu fonksiyonlar 
    artık dosyayı diğer PATH dizinlerinde bulamazlarsa EACCESS errno değeri ile başarısız olurlar.

    Aşağıda execlp fonksiyonuna bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execlp("ls", "ls", "-l", (char *)0) == -1)
        exit_sys("execv");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda execvp kullanımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execvp(argv[1], &argv[1]) == -1)
        exit_sys("execv");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi kabuk üzerinden programları neden "./sample" biçiminde çalıştırdığımız artık anlaşılabilir. Kabuk programları önce 
    fork yapıp alt proseste exec fonksiyonlarının p'li versiyonlarıyla programları çalıştırmaktadır. Dolayısıyla biz programı 
    "sample" biçiminde çalıştırmak istediğimizde bu p'li versiyonlar bu programı PATH çevre değişkeninin belirttiği dizinlerinde 
    bulamayacaktır. Ancak biz programı "./sample" biçiminde çalıştırmak istediğimizde bu fonksiyonlar artık PATH çevre değişkenine 
    bakmayacaktır.

    Pekiyi kabuk programları neden exec fonksiyonlarının p'li versiyonlarını kullanmaktadır? Bunun birinci sebebi kolaylık sağlamak 
    içindir. Örneğin "ls" komutunu biz "/bin/ls" biçiminde kullanmak istemeyiz. Bunun ikinci sebebi güvenliktir. Eskiden durum 
    böyle değilken programın çalışma dizinine gerçek komutlarla aynı isimli komutlar yerleştirerek hileli işlemler yapmaya 
    yeltenenler olmuştur. İşte bu nedenle PATH dizinlerinin içerisinde prosesin çalışma dizini de yerleştirilmez. Eğer durum 
    böyle olmasaydı bazen hatalı yazılmış komutlarla istenmeden başka programlar da çalıştırılabilirdi. Örneğin dizinimizde 
    "co" diye bir program olsun biz "cp" yerine yanlışlıkla "co" yazarsak bu programımızı istemeden de çalıştırabiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                29. Ders 05/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz myshell kabuk programına fork/exec işlemini ekleyelim. Programın bu versiyonu önce "internal" 
    komutlara bakacak, eğer internal komutlarda verilen komutu bulmazsa onu fork/exec ile program dosyası gibi çalıştıracaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS        128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void cd_proc(void);
void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"cd", cd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;
    pid_t pid;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL) {
            if ((pid = fork()) == -1) {
                perror("fork");
                continue;
            }
            if (pid == 0 && execvp(g_params[0], &g_params[0]) == -1){
                fprintf(stderr, "command not found or cannot execute!\n");
                continue;
            }
            if (wait(NULL) == -1)
                exit_sys("wait");
        }
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
    g_params[g_nparams] = NULL;
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının başarısızlığının nedeni olabilecek çeşitli errno değerleri vardır. Bunların en önemlilerinden birkaçı 
    şunlardır:

    ENOENT (No such file or directory): Dosya bulunamamıştır.

    EACCESS (Permission denied): Dosya bulunmuştur ancak proses dosyaya "x" hakkına sahip değildir.

    ENOEXEC (Exec format error): Dosya bulunmuştur. Prosesin dosyaya "x" hakkı da vardır. Ancak dosyanın formatı çalıştırmaya 
    uygun değildir. Yani dosya çalıştırılabilir bir dosya değildir ya da dosyanın başında "shebang" yoktur.

    EINVAL (Invalid argument): Dosya bulunmuştur, proses dosyaya "x" hakkına sahiptir. Ancak dosya bu sistem tarafından desteklenen 
    "çalıştırılabilir (executable)" bir formata sahip değildir.

    Yukarıda da belirttiğimiz gibi exec fonksiyonlarının p'li versiyonları (execlp ve execvp) PATH dizinlerinde tek tek dosyayı 
    aramaktadır. Ancak bu fonksiyonlar dosyayı bir dizinde bulduğunda ve onu sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında 
    EINVAL ve ENOEXEC errno değerini alırsa dosyanın bir kabuk dosyası olduğundan çalıştırılamadığı sonucunu çıkartmaktadır 
    ve bu durumda dosyayı "/bin/sh (default shell)" programı ile çalıştırmaktadır. Ancak exec fonksiyonlarının diğer versiyonları 
    EINVAL ve ENOEXEC hatalarında bunu yapmamaktadır. Bunu yalnızca exec fonksiyonlarının p'li versiyonları yapmaktadır. exec 
    fonksiyonlarının p'li versiyonları PATH dizinlerinin birinde dosyayı sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında 
    EACCESS errno değeri ile başarısız olurlarsa dosyayı sonraki PATH dizinlerinde aramaya devam ederler. Ancak bu arama sırasında 
    bu fonksiyonlar artık dosyayı diğer PATH dizinlerinde bulamazlarsa EACCESS errno değeri ile başarısız olurlar.

    Bu davranışın anlamı izleyen bölümlerde başka paragraflarda açıklanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının iki tane e'li biçimleri vardır: execle ve execve. Buradaki "e" harfi "environment" yani çevre değişkenleri
    anlamında isme eklenmiştir.

    Anımsanacağı gibi çevre değişkenleri tipik olarak prosesin bellek alanında bulunduruluyordu ve fork işlemi sırasında üst 
    prosesin bellek alanının alt prosese kopyalanmasıyla alt prosese geçiriliyordu. Ancak exec işlemleri prosesin bellek alanını 
    ortadan kaldırıp yeni bir program kodunu yüklediğine göre prosesin çevre değişkenleri ne olacaktır? İşte exec işlemi sırasında 
    prosesin bellek alanı boşaltılıp yeni program için prosesin bellek alanı yeniden oluşturulurken çevre değişkenleri de sıfırdan 
    oluşturulabilmektedir. Bunu exec fonksiyonlarının e'li versiyonları yapmaktadır. exec fonksiyonlarının e'siz versiyonları o andaki 
    prosesin çevre değişkenlerinin aynısını exec yapılan programın bellek alanına taşımaktadır. Yani biz exec fonksiyonlarının e'siz 
    versiyonlarını kullandığımızda exec yapmadan önceki çevre değişkenleriyle exec yapıldıktan sonraki programın çevre değişkenleri 
    aynı olacaktır.

    execle ve execve fonksiyonlarının prototipleri şöyledir:

    #include <unistd.h>

    int execle(const char *path, const char *arg0, ... /*, (char *)0, char *const envp[]*/);
    int execve(const char *path, char *const argv[], char *const envp[]);

    execle fonksiyonun birinci parametresi yine çalıştırılacak dosyanın yol ifadesini almaktadır. Diğer parametreler programa 
    geçirilecek komut satırı argümanlarını belirtir. Bu argüman listesinin sonu yine NULL adresle bitirilmelidir. Bu NULL adresten 
    sonra son parametre char türden bir gösterici dizisi olmalıdır. Bu gösterici dizisi çevre değişkenlerini "anahtar=değer" 
    biçiminde tutan yazıların başlangıç adreslerinden oluşmalıdır (yani environ global değişkeninde olduğu gibi). Bu fonksiyonlardaki 
    çevre değişkenleri için oluşturulan gösterici dizilerinin sonunda NULL adres olmalıdır.

    execve fonksiyonu da benzerdir. Bu fonksiyon da önce çalıştırılacak programın yol ifadesini alır. Sonra komut satırı argümanlarını 
    bir gösterici dizisi olarak sonra da çevre değişkenlerini bir gösterici dizisi olarak almaktadır.

    Aşağıdaki execve fonksiyonunun kullanımına bir örnek verilmiştir. Burada komut satırı argümanlarıyla verilen program execve 
    fonksiyonu ile çalıştırmaktadır. execve için çevre değişken listesi bir gösterici dizisi biçiminde oluşturulmuştur. mample 
    programı içerisinde hem komut satırı argümanları hem de prosesin çevre değişkenleri yazdırılmıştır. Testi şöyle yapabilirsiniz:

    $ ./sample mample ali veli selami

    Şöyle bir çıktı elde edeceksiniz:

    sample running...
    ok, parent continues...
    mample running...

    command line arguments:

    mample
    ali
    veli
    selami

    Environment variables:

    city=eskisehir
    PATH=/bin:/usr/bin
    name=ali
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    pid_t pid;
    char *env[] = {"city=eskisehir", "PATH=/bin:/usr/bin", "name=ali", NULL};

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execve(argv[1], &argv[1], env) == -1)
        exit_sys("execve");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki execle fonksiyonunun kullanımına bir örnek verilmiştir. execle fonksiyonunda komut satırı argümanlarından sonra 
    çevre değişkenlerini belirten gösterici dizisi argüman olarak geçilmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    char *env[] = {"city=eskisehir", "PATH=/bin:/usr/bin", "name=ali", NULL};

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execle("mample", "mample", "ali", "veli", "selami", (char *)0, env) == -1)
        exit_sys("exece");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirtildiği gibi UNIX türevi sistemlerde yalnızca execve fonksiyonu sistem fonksiyonu olarak işletim sistemi
    içerisinde bulunmaktadır. Aslında execl, execlp, execv, execvp, execle fonksiyonları, execve fonksiyonunu çağıracak biçimde 
    birer kütüphane fonksiyonu biçiminde bulundurulmaktadır. Yani burada "taban (base)" fonksiyon execve fonksiyonudur.

    Aşağıda execv fonksiyonunun execve kullanılarak basit biçimde yazımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

extern char **environ;

int myexecv(const char *path, char * const *argv)
{
    return execve(path, argv, environ);
}

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && myexecv(argv[1], &argv[1]) == -1)
        exit_sys("myexecv");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte de execl fonksiyonunun execve kullanılarak nasıl yazıldığı hakkında bir fikir verilmiştir. 
    Burada komut satırı argümanlarının sayısı MAX_ARGS ile sınırlandırılmıştır.

    Değişken sayıda argüman alan fonksiyonların yazımını inceleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdarg.h>

#define MAX_ARG        4096

void exit_sys(const char *msg);

extern char **environ;

int myexecl(const char *path, const char *arg0, ...)
{
    va_list vl;
    char *args[MAX_ARG + 1];
    char *arg;
    int i;

    va_start(vl, arg0);

    args[0] = (char *)arg0;
    for (i = 1; (arg = va_arg(vl, char *)) != NULL && i < MAX_ARG; ++i)
        args[i] = arg;
    args[i] = NULL;

    va_end(vl);

    return execve(path, args, environ);
}

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && myexecl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1)
        exit_sys("myexecl");

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    fexecve isimli POSIX fonksiyonu execve fonksiyonu gibidir. Ancak bunun tek farkı dosyayı yol ifadesini alarak değil dosya 
    betimleyicisini alarak çalıştırmasıdır. Yani biz çalıştırmak istediğimiz dosyayı zaten open fonksiyonu ile açmışsak bu 
    durumda doğrudan fexecve fonksiyonunu kullanabiliriz. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int fexecve(int fd, char *const argv[], char *const envp[]);

    Fonksiyonun birinci parametresi çalıştırılacak dosyanın dosya betimleyicisini almaktadır. Diğer parametreler execve fonksiyonu 
    ile tamamen aynıdır. Bu fonksiyonun birinci parametresinde belirtilen betimleyiciye ilişkin dosya hangi modda açılmış olmalıdır?
    POSIX standartlarında olan ancak Linux tarafından desteklenmeyen O_EXEC bayrağı bunun için kullanılabilir. (O_EXEC bayrağında
    dosyanın "x" hakkına sahip olup olmadığına bakılmaktadır.) Ancak POSIX standartlarında da dosyanın O_RDONLY modunda
    açılabileceği belirtilmiştir. Yani dosya bu modlarda da açılmış olabilir. Linux sistemlerinde O_EXEC bayrağı olmasa da benzer 
    amaçlarla kullanılan standart olmayan O_PATH bayrağı bulunmaktadır. Linux sistemlerinde bu dosya O_PATH bayrağı ile de 
    açılmış olabilir. O halde Linux sistemleri de göz önüne alındığında buradaki dosyanın taşınabilirlik bakımından O_RDONLY modda
    açılması uygun olmaktadır. Programcı bu dosyayı fork işleminden sonra alt proseste exec işleminden önce açabilir. Bu durumda 
    dosyanın alt proseste kapatılması işlemi exec sırasında otomatik yapılmaktadır. Yani exec edilen kodda artık bu dosya açık 
    görülmeyecektir.

    Aşağıda fexecve fonksiyonun kullanımına bir örnek verilmiştir. Burada dosya alt proseste açılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

extern char **environ;

int main(int argc, char *argv[])
{
    pid_t pid;
    int fd;

    if (argc == 1) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("sample running...\n");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        if ((fd = open(argv[1], O_RDONLY)) == -1)
            exit_sys("open");
        if (fexecve(fd, &argv[1], environ) == -1)
            exit_sys("fexecve");
    }

    printf("ok, parent continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    exec işlemi yapıldığında o ana kadar açık olan dosyaların akıbeti ne olacaktır? Anımsanacağı gibi açık dosyaların dosya 
    nesnelerinin adresleri "dosya betimleyici tablosu" denilen bir tabloda tutuluyordu. Örneğin bir program 100 tane dosya açıp 
    sonra exec işlemi uygulasa yeni çalıştırılacak kod bu 100 dosyanın farkında olmayacaktır. Ancak dosya betimleyici tablosunda
    bu 100 betimleyici çoğu kez gereksiz bir biçimde bulunmaya devam edecektir. İşte UNIX/Linux sistemlerinde her açık dosya için
    "close on exec" isminde bir bayrak da tutulmaktadır. Eğer bu bayrak "set" edilmişse bu durumda exec işlemi sırasında bu dosya
    işletim sistemi tarafından otomatik olarak kapatılır. Eğer bu bayrak "reset" durumdaysa bu durumda exec işlemi sırasında dosya 
    kapatılmaz, exec yapılan program kodu dosyanın betimleyicisini bilirse onu kullanmaya devam edebilir. Bu bayrak default olarak 
    "reset" durumdadır. open fonksiyonuyla dosya açılırken açış modunda O_CLOEXEC bayrağı belirtilirse bu bayrak set edilmiş olur. 
    Örneğin:

    fd = open("test.txt", O_RDONLY|O_CLOEXEC);

    Programcı isterse herhangi bir zaman fcntl fonksiyonu ile de bu bayrağı set ya da reset edebilir. Biz bu fcntl fonksiyonunu 
    henüz görmedik. Ancak bu bayrağın set edilmesi işlem şöyle yapılabilmektedir:

    if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD)|FD_CLOEXEC)) == -1)
        exit_sys("fcntl");

    Benzer biçimde bu bayrak şöyle de reset edilebilir:

    if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) & ~FD_CLOEXEC)) == -1)
        exit_sys("fcntl");

    Close on exec bayrağı dosya nesnesinin içerisinde tutulmamaktadır. Aynı dosya nesnesini gösteren farklı betimleyiciler olabilir. 
    Bu betimleyicilerden birinin close on exec bayrağı set edilmişken diğerinin set edilmemiş olabilir. Yani close on exec bayrağı 
    dosya nesnesinin içerisinde değil proses kontrol blok içerisinde başka bir yerdedir.

    Aşağıdaki örnekte "sample" programı execl ile "mample" programını çalıştırmıştır. Ancak "mample" programı "sample" programının
    açmış olduğu dosyanın betimleyici numarasını bilmediği için "sample" programı komut satırı argümanıyla bu bilgiyi "mample"
    programına iletmiştir.

    Aşağıdaki programı daha sonra dosyanın close-on-exec bayrağı set set ederek yeniden deneyiniz:

    if ((fd = open("sample.c", O_RDONLY|O_CLOEXEC)) == -1)
        exit_sys("open");

    Tabii aynı işlem şöyle de yapılabilirdi:

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD)|FD_CLOEXEC) == -1)
        exit_sys("fcntl");

    close on exec bayrağı bazı işlemler sırasında işletim sistemi tarafından set ya da reset edilebilmektedir. Örneğin dup ve 
    dup2 fonksiyonları ile dosya betimleyicisinin kopyası çıkartılırken her zaman yeni betimleyicinin close on exec bayrağı 
    reset durumda olur.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    pid_t pid;
    int fd;
    char fd_str[64];

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    sprintf(fd_str, "%d", fd);
    if (pid == 0 && execl("mample", "mample", fd_str, (char *)0) == -1)
        exit_sys("execve");

    printf("parent process continues...\n");

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }
    fd = atoi(argv[1]);
    lseek(fd, 0, SEEK_SET);

    while ((result = read(fd, buf, BUFFER_SIZE)) > 0) {
        buf[result] = '\0';
        printf("%s", buf);
    }
    if (result == -1)
        exit_sys("read");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                30. Ders 18/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonları ile script dosyaları da (yani text dosyalar da) çalıştırılabilmektedir. Bu özellik tamamen çekirdekte
    bulunan sistem fonksiyonları (Linux'ta execve) tarafından sağlanmaktadır. exec fonksiyonları (aslında Linux'ta execve 
    sistem fonksiyonu) eğer çalıştırılmak istenen dosya "çalıştırılabilir bir dosya değilse (örneğin Linux'ta ELF formatı ya 
    da a.out formatı değilse)" bu dosyanın birinci satırını okuyarak onunla özel bir işlem yapmaktadır. Çalıştırılabilir 
    formata sahip olmayan bir dosyanın (tipik olarak bir text dosya) birinci satırı aşağıdaki gibi ise exec fonksiyonları burada 
    özel bir işlem uygulamaktadır:

    #! [optional SPACE'ler] <executable file mutlak yol ifadesi> [isteğe bağlı argüman(lar)]

    Burada #! karakterlerine genellikle "shebang" denilmektedir. Bu karakterler hemen satırın başında olmak zorundadır. 
    Shebang karakterlerinden sonra isteğe bağlı bir ya da birden fazla SPACE karakteri bulundurulabilmektedir. Bundan sonra 
    gerçekten çalıştırılacak olan "çalıştırılabilir bir dosyanın" mutlak yol ifadesi olmalıdır. Bunu isteğe bağlı argümanlar 
    izleyebilir. Örneğin:

    #! /bin/bash
    #!/bin/bash
    #!/usr/bin/python
    #!make -f

    exec işlemini yapan sistem fonksiyonları eğer exec yapılmak istenen dosya çalıştırılabilir bir dosya değilse (muhtemelen bir 
    text dosya) onun birinci satırını okuyarak orada belirtilen çalıştırılabilir dosyayı çalıştırmaktadır. Ancak exec fonksiyonlarının 
    bu işlemi yapabilmesi için exec yapılan dosyanın yine de (text dosyası olmasına karşın) "x" hakkına sahip olması gerekmektedir. 
    Aksi takdirde exec fonksiyonları başarısız olur ve yine errno değeri EACCESS biçiminde set edilir.

    Yukarıdaki biçimde biz bir script dosyasını çalıştırmaya çalıştığımızda aslında asıl çalıştırılan dosya shebang'te belirtilen 
    dosya olmaktadır. Pekiyi shebang'te belirtilen dosya çalıştırılırken ona komut satırı argümanları olarak ne geçirilecektir? 
    Shebang'te belirtilen programın çalıştırılması sırasında bu programa geçirilen komut satır argümanları şöyledir:

    argv[0] ---> shebang'te belirtilen program dosyasına ilişkin yol ifadesi
    argv[1] ---> Eğer shebang'te çalıştırılabilen programın yanında isteğe bağlı argüman varsa o argüman 
    argv[2] ---> exec fonksiyonunda belirtilen çalıştırılabilir olmayan dosyanın (yani script dosyasının) yol ifadesi 
    argv[3] ve sonrası ---> exec fonksiyonunda belirtilen komut satırı argümanları ancak ilk argüman dahil değil

    Eğer shebang'in yanındaki programın yanında isteğe bağlı argüman verilmemişse bu durumda shebang'te belirtilen programın
    komut satırı argümanları şöyle olacaktır:

    argv[0] ---> shebang'te belirtilen program dosyasına ilişkin yol ifadesi
    argv[1] ---> exec fonksiyonunda belirtilen çalıştırılabilir olmayan dosyanın (yani script dosyasının) yol ifadesi 
    argv[2] ve sonrası ---> exec fonksiyonunda belirtilen komut satırı argümanları ancak ilk argüman dahil değil

    Burada dikkat edilmesi gereken bir nokta şudur: exec fonksiyonunda belirtilen argv[0] için girilen argüman shebang'te 
    belirtilen programa aktarılmamaktadır.

    Şimdi çeşitli denemelerle argüman aktarımını anlamaya çalışalım. "test.txt" şöyle olsun:

    #! /home/kaan/Study/Unix-Linux-SysProg/mample ankara

    Burada görüldüğü gibi shebang'te belirtilen programın yanında bir isteğe bağlı argüman vardır. Şimdi "mample" programının 
    da şöyle yazılmış olduğunu kabul edelim:

    #include <stdio.h>

    int main(int argc, char *argv[])
    {
        printf("mample running...\n");

        for (int i = 0; i < argc; ++i)
            puts(argv[i]);

        return 0;
    }

    Şimdi aşağıdaki gibi exec yapılmış olsun:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);

    Ekranda şunları görmeliyiz:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara
    test.txt
    ali
    veli
    selami

    exec işlemi şöyle yapılmış olsun:

    execl("test.txt", "ali", "veli", "selami", (char *)0);

    Ekrana şunlar çıkacaktır:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara
    test.txt
    veli
    selam

    Şimdi de shebang satırı şöyle olsun:

    #!/home/kaan/Study/Unix-Linux-SysProg/mample

    Görüldüğü gibi burada arık shebang'te belirtilen programın yanında isteğe bağlı argüman yoktur. Şimdi exec işlemini şöyle
    yapmış olalım:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    test.txt
    ali
    veli
    selami

    Sistemlerde genellikle shebang satırları için maksimum bir uzunluk belirlenmiş olmaktadır. Örneğin eski Linux sistemlerinde 
    eğer shebang satırı uzunsa kernel bunun ilk 127 karakterini dikkate almaktadır. Ancak Linux'ta 5.1 kernel'ı ile birlikte
    bu uzunluk 255'e yükseltilmiştir.

    Shebang'te belirtilen çalıştırılabilir program genellikle "mutlak yol ifadesi" ile belirtilmektedir. Ancak Linux'ta buradaki 
    program "göreli yol ifadesi" ile de belirtilebilmektedir. Örneğin:

    #!mample

    Bu durumda burada belirtilen program exec işlemini yapan prosesin çalışma dizini temel alınarak aranmaktadır.

    Shebang'te belirtilen programın yanına birden fazla argüman yazabilir miyiz? Örneğin:

    #! /home/kaan/Study/Unix-Linux-SysProg/mample ankara izmir istanbul

    Maalesef bu durumda UNIX türevi sistemler arasında bazı farklılıklar söz konusu olmaktadır. Bu durum POSIX standartlarında
    açık biçimde belirtilmemiş ve işletim sistemini yazanların isteğine bırakılmıştır. Linux ve pek çok sistem bu durumda shebang'te 
    belirtilen programın sağındaki tüm argümanları tek bir argümanmış gibi aktarmaktadır. "test.txt" dosyasının yukarıdaki gibi 
    olduğunu varsayalım. Bu dosya aşağıdaki gibi exec yapılmış olsun:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);

    Linux sistemlerinde aşağıdaki gibi bir çıktı elde edilmiştir:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara istanbul izmir
    test.txt
    ali
    veli
    selami

    Bazı UNIX türevi sistemler bu durumda yalnızca boşlukla ayrılmış ilk argümanı (örneğimizde "ankara") programa aktarıp diğerlerini 
    ihmal edebilmektedir. Bu durumda programcının taşınabilirliği sağlamak için shebang dosyasının yanına tek bir argüman yerleştirmesi 
    uygun olmaktadır.

    Tabii biz bir script dosyasını doğrudan kabuk üzerinden de çalıştırabiliriz. Fark eden bir şey yoktur. Bu durumda zaten kabuk 
    exec işlemini uygulamaktadır. Örneğin "test.txt" dosyası şöyle olsun:

    #! /home/kaan/Study/Unix-Linux-SysProg/mample ankara

    Şimdi bunu kabuk üzerinden çalıştıralım:

    $ ./test.txt ali veli selami
    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara

    $ ./test.txt
    ali
    veli
    selami

    Görüldüğü gibi burada exec işlemini kabuk uygulamıştır. Kabuk exec uygularken dosya ismini yine exec'te ilk komut satırı 
    argümanı olarak kullanır. Ancak exec bunu shebang'te belirtilen programa aktarmamaktadır.

    Aşağıda shebang programına parametre aktarımının test edilmesi için bir örnek verilmiştir. Burada script (test.txt) programına
    chmod ile "x" hakkı vermeyi unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        if (execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0) == -1)
            exit_sys("execl");

        /* Unreachable code */
    }

    if (wait(NULL) == -1)
        exit_sys("wait");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("mample running...\n");

    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/* test.txt */

#! /home/kaan/Study/Unix-Linux-SysProg/mample ankara

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bütün bunların anlamı nedir? Yani shebang ile bir script dosyasının aslında başka bir programı çalıştırmasının ne faydası olabilir?
    Bu mekanizma sayesinde yorumlayıcı yoluyla çalıştırılan dosyaların doğrudan çalıştırılabilmesine olanak sağlanmaktadır. Örneğin
    aşağıdaki gibi "sample.sh" isimli bir bash script dosyası olsun:

    #!/bin/bash

    for i in {1..10}
    do
        echo $i
    done

    Bu program 1'den 10'a kadar sayıları ekrana yazdırmaktadır. Normal olarak bir bash programı aşağıdaki gibi çalıştırılabilir:

    $ /bin/bash sample.sh

    Burada "sample.sh" dosyasının "x" hakkına sahip olması gerekmez. Ancak biz dosyası doğrudan aşağıdaki gibi çalıştırmak isteyebiliriz:

    $ ./sample.sh

    Bu durumda dosyanın "x" hakkına sahip olması gerekir. Dosyayı böyle çalıştırmak istediğimizde kabuk program exec işlemi uygulayıp
    "sample.sh" programını çalıştırmak isteyecektir. Sistem fonksiyonu da "sample.sh" programının çalıştırılabilir bir dosya formatına
    sahip olmadığını anladığında shebang satırına bakıp orada belirtilen "/bin/bash" programını çalıştıracaktır. Ancak bu programa 
    script dosyasının kendisini argüman olarak geçirecektir. Yani program adeta şöyle çalıştırılmış olacaktır:

    $ /bin/bash sample.sh

    Pekiyi /bin/bash programı buradaki "sample.sh" programını çalıştırırken onun başında shebang satırı bir soruna yol açmayacak mı?
    İşte script dillerinin hemen hepsinde # özellikle bu shebang kullanımını desteklemek için yorum satırı biçiminde ele alınmaktadır. 
    Aynı durum python, perl, sed, awk gibi dillerde de böyledir. Şimdi bir Python programını shebang ile çalıştıralım. Programın ismi
    "sample.py" olsun:

    #!/usr/bin/python3

    for i in range(10):
        print(i)

    Bu dosyaya "x" vererek biz artık onu komut satırından çalıştırabiliriz:

    $ ./sample.py

    Aşağıdaki örnekte ekrana 1'den 10'a kadar sayıları yazan "sample.py" isimli bir python programı verilmiştir. Bu program 
    shebang içerdiğinden dolayı komut satırında "x" verilmişse doğrudan aşağıdaki gibi çalıştırılabilmektedir:

    $ ./sample.py
---------------------------------------------------------------------------------------------------------------------------*/

#!/usr/bin/python3

for i in range(10):
    print(i)

/*---------------------------------------------------------------------------------------------------------------------------
    Bazen shebang yanında isteğe bağlı argüman gerekebilmektedir. Örneğin make programına bir dosyayı verebilmek için -f seçeneğinin 
    kullanılması gerekir. O halde make için shebang oluşturulurken -f seçeneğinin shebang satırında isteğe bağlı argüman olarak 
    belirtilmesi gerekir. Örneğin:

    #! /bin/make -f

    sample: sample.o
        gcc -o sample sample.o
    sample.o: sample.c
        gcc -c sample.c

    clean:
        rm -f *.o
        rm -f sample

    Burada dosyanın "sample.mak" isminde olduğunu düşünelim. Bu dosyaya "x" hakkını verdikten sonra onu aşağıdaki gibi çalıştırmış 
    olalım:

    $ ./sample.mak

    Bu çalıştırma aslında aşağıdakiyle eşdeğer olacaktır:

    $ /bin/make -f sample.mak
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Shebang satırında bazı şeylere dikkat etmek gerekir. Örneğin shebang karakterlerinin hemen ilk satırın başından başlatılması 
    gerekir. Aksi takdirde exec fonksiyonları ENOEXEC ile başarısız olacaktır. Eğer shebang karakterlerinin yanındaki dosya 
    bulunamazsa bu durumda exec fonksiyonları ENOENT ile başarısız olur. Eğer dosyanın ilk satırında shebang yoksa yine bu 
    fonksiyonlar errno değerini ENOEXEC ile set ederek başarısız olmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının p'li versiyonları (yani execlp ve execvp) özel bir davranışa sahiptir. Bilindiği gibi bu fonksiyonlar 
    PATH çevre değişkeninde belirtilen dizinlerde exec yapılan dosyayı tek tek aramaktadır. Eğer bunlar çalıştırılabilir olmayan 
    dosyayı "x" hakkına sahip olarak bulup ancak dosyanın başında "shebang" görmezlerse sanki dosyanın başında aşağıdaki gibi 
    bir shebang olduğunu varsaymaktadır:

    #!/bin/sh

    Buradan şu sonuç çıkmaktadır: exec fonksiyonlarının p'li versiyonları ile bir shell script dosyasını biz başında shebang 
    satırı olmadan da çalıştırabiliriz. Ancak exec fonksiyonlarının p'siz versiyonlarında bunu yapamayız. Öte yandan Linux 
    sistemlerinde zaten execve dışındaki exec fonksiyonlarının sistem fonksiyonu olmadığını anımsayınız. O halde exec fonksiyonlarının 
    p'li versiyonları tamamen user mode'da script dosyasını execve yaptıktan sonra ENOEXEC errno değeri ile fonksiyonun başarısız 
    olduğunu gördüklerinde bu kez "/bin/sh" dosyasını execve ile exec yapmaktadır. Dosya isminin içerisinde "/" karakteri kullanılsa 
    bile exec fonksiyonlarının p'li versiyonlarının davranışı yine bu biçimdedir. exec fonksiyonlarının p'li versiyonlarının 
    bu davranışı POSIX'te eskiden isteğe bağlı bırakılmıştı. Ancak sonra standartlarda bu davranış zorunlu tutulmuştur. Ancak 
    POSIX standartları çalıştırılacak shell programının ne olacağı konusunda bir belirlemede bulunmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi shebang'te belirtilen dosyanın kendisi de bir script dosyası olabilir mi? Yani bu shebang işlemi özyinelemeli midir?
    Aslında POSIX standartları bu konuda bir şey söylememiştir. Bu durumda böyle bir işlemin özyinelemeli yapılacağının bir 
    garantisi yoktur. Linux çekirdeği bu tür durumlarda dört kademeye kadar özyineleme yapabilmektedir. Siz de deneme yoluyla 
    bu özyinelemeyi yapıp sonucuna bakabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                31. Ders 18/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    system isimli bir standart C fonksiyonu vardır. Bu fonksiyon ilgili sistemdeki kabuk programını (command interpreter)
    interaktif olmayan modda çalıştırarak bizim verdiğimiz bir kabuk komutunun kabuk tarafından çalıştırılmasını sağlar. 
    Böylece biz kabuk üzerinde yazabildiğimiz tüm komutları bir C programının içerisinde bu yolla çalıştırabiliriz. system
    fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    int system(const char *command);

    Fonksiyon parametre olarak kabuğa işletilecek komut yazısını almaktadır. Tabii system bir standart C fonksiyonu olduğuna göre
    yalnızca UNIX/Linux sistemlerinde değil diğer tüm sistemlerde de kullanılabilmektedir. Örneğin system fonksiyonu UNIX/Linux 
    sistemlerinde "/bin/sh" programını çalıştırırken, Windows sistemlerinde "cmd.exe" programını çalıştırmaktadır. Tabii bir 
    sistemde kabuk programı bulunuyor olmak zorunda değildir. Örneğin pek çok gömülü sistemde bir işletim sistemi olmadığı için 
    kabuk programı da yoktur. İşte programcı ilgili sistemde kabuk programının olup olmadığını fonksiyonun parametresine NULL 
    adres geçerek test edebilir. Bu durumda system fonksiyonu eğer ilgili sistemde kabuk programı varsa sıfır dışı bir değere 
    yoksa 0 değerine geri dönmektedir. Tabii programcı Windows, UNIX/Linux ve macOS gibi sistemlerde çalışıyorsa böyle bir kontrol 
    yapmaz.

    Pek çok sistemde kabuk programları "interaktif olmayan (noninteractive)" bir modda çalıştırılabilmektedir. Örneğin UNIX/Linux 
    kabuk programları "-c" seçeneği ile çalıştırılırsa yalnızca bir komutu çalıştırıp sonlanmaktadır. Örneğin:

    $ bash -c "ls -l; cat sample.c"

    Benzer biçimde Windows sistemlerinde de "cmd.exe" kabuk programı /C seçeneği ile benzer biçimde çalıştırılabilmektedir.

    O halde UNIX/Linux sistemlerinde system fonksiyonu kabuk programını "-c" seçeneği ile fork/exec yoluyla çalıştırmaktadır. 
    Eğer system fonksiyonu fork ya da wait işlemini yapamazsa -1 değeri ile geri dönmektedir. Eğer fork yapıp exec yapamazsa 
    sanki _exit(127) biçiminde oluşturulan ve waitpid fonksiyonu ile elde edilen değere (status) geri dönmektedir. Diğer
     durumlarda (yani fork ve exec başarılı bir biçimde yapılmışsa) system fonksiyonu çalıştırdığı kabuk pogramının waitpid 
     fonksiyonuyla elde edilen değerine (status) geri dönmektedir. Tabii kabuk programları da interaktif olmayan modda çalıştırılan 
    komutun waitpid fonksiyonu ile elde edilen (status) değere geri dönerler. Örneğin:

    $ system("ls -l");

    Burada system fork/exec ile "/bin/sh" programını -c seçeneği ile çalıştırmaktadır. Tabii kabuk programı da "ls" programını 
    fork/exec ile çalıştıracaktır. (Bazen kabuk programları interaktif modda eğer tek bir komut işletiliyorsa boşuna fork yapmayabilir).
    Burada kabuk programı aslında "ls" programının waitpid fonksiyonu ile elde edilen değeri ile (status) sonlanmaktadır. 
    Dolayısıyla biz aslında system fonksiyonun geri dönüş değeri olarak çalıştırdığımız "ls" programının waitpid fonksiyonu ile 
    elde edilen (status) değeri elde etmiş oluruz. UNIX/Linux sistemlerinde genel olarak kabuk komutları (yani programları) başarı 
    durumunda exit kod olarak 0 değerini oluşturmaktadır.

    Pekiyi system fonksiyonunun başarısını nasıl tespit edebiliriz? Biz fonksiyonun geri dönüş değerini -1 ve 127 ile test edebiliriz. 
    Örneğin:

    result = system("ls -l") ;

    if (result == -1 || (WIFEXITED(result) && WEXITSTATUS(result) != 0) {
        fprintf(stderr, "command failed!\n");
        exit(EXIT_FAILURE);
    }

    Biz kabuk programını system fonksiyonu ile çalıştırırken komutlar arasına ";" koyarak birden fazla komutun çalıştırılmasını 
    sağlayabiliriz. Genel olarak kabuk bu durumda son komutun exit kodunu bize vermektedir.

    Aslında programcılar genellikle system fonksiyonu için yalnızca -1 kontrolünü yapmaktadır. Yani çalıştırdıkları komutun 
    başarısını kontrol etmemektedir. Örneğin:

    if (system("any command") == -1)
        exit_sys("system");

    Aşağıda system fonksiyonun kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
    int result;

    if (system("ls -l > test.txt") == -1)
        exit_sys("system");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi system fonksiyonunu nasıl yazabiliriz? Aşağıda buna bir örnek verilmiştir. Ancak aşağıdaki örnekte bazı noktalar 
    henüz kursumuzda o konu anlatılmadığı için ihmal edilmiştir. Bu noktalar şunlardır:

    - waitpid fonksiyonu sinyalle kesilirse yeniden çalıştırılması gerekir.
    - Üst prosesin işlemler sırasında SIGCHLD sinyalini, SIGINT ve SIGQUIT sinyallerini bloke etmesi gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int mysystem(const char *command)
{
    pid_t pid;
    int status;

    if (command == NULL)
        return 1;

    if ((pid = fork()) == -1)
        return -1;

    if (pid == 0) {
        if (execl("/bin/sh", "/bin/sh", "-c", command, (char *)0) == -1)
            _exit(127);
        /* unreachable code */
    }
    if (waitpid(pid, &status, 0) == -1)
        return -1;

    return status;
}

int main(void)
{
    int result;

    result = mysystem("ls");

    if (result == -1 || WIFEXITED(result) && WEXITSTATUS(result) != 0) {
        fprintf(stderr,"command failed!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki system fonksiyonu bizim için zaten fork/exec işlemlerini yapmaktadır, bu durumda örneğin bir programı 
    çalıştırmak için biz fork/exec kullanmak yerine bu işlemi system fonksiyonu ile yapamaz mıyız? Bu sorunun yanıtı genel 
    olarak bu işlemlerin system fonksiyonu ile yapılabileceğidir. Ancak bu konudaki her türlü gereksinimimizi system fonksiyonu 
    karşılayamaz. Örneğin fork işleminden sonra alt proseste ayarlamalar yapıp exec yapmak isteyebiliriz. Ayrıca system fonksiyonu 
    kendi içerisinde kabuk programını çalıştırdığı için daha yavaş ve daha fazla kaynak kullanır durumdadır. Bizim tavsiyemiz 
    bir programı açıkça fork/exec ile çalıştırmak ancak karmaşık işlemleri (örneğin IO redirection, boru vs. gibi) system 
    fonksiyonuyla yapmaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte kabuk programı system fonksiyonu sayesinde sarmalanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
    char cmd[4096];
    char *str;

    for (;;) {
        printf("CSD>");
        fflush(stdout);

        if (fgets(cmd, 4096, stdin) != NULL)
            if ((str = strchr(cmd, '\n')) != NULL)
                *str = '\0';
            if (!strcmp(cmd, "exit"))
                break;
        if (system(cmd) == -1)
            perror("system");
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar dosyalar için 9 tane erişim bayrağı gördük: S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, 
    S_IWOTH, S_IXOTH. Bu bayraklar dosyanın "rwx rwx rwx" erişim haklarını belirtmektedir. Ancak aslında dosyaların erişim hakları 
    9 tane değil 12 tanedir. Henüz görmediğimiz üç erişim hakkına "set-user-id", "set-group-id" ve "sticky" hakları denilmektedir. 
    Şimdi dikkatimizi bu üç erişim hakkına çevireceğiz. Bu üç erişim hakkı open fonksiyonunda ya da chmod fonksiyonunda sırasıyla 
    S_ISUID, S_ISGID ve S_ISVTX sembolik sabitleriyle kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Komut satırında dosyanın set-user-id bayrağını set etmek için u+s seçeneği kullanılabilir. Örneğin:

    $ ls -l sample
    -rwxrwxrwx 1 kaan study 17176 Şub 19 11:46 sample
    $ chmod u+s sample
    $ ls -l sample
    -rwsrwxrwx 1 kaan study 17176 Şub 19 11:46 sample

    Görüldüğü gibi dosyanın set-user-id bayrağı set edildiğinde "x" harfinin yerinde "s" harfi gözükmektedir. Yani eğer dosyanın 
    hem "x" bayrağı hem de set-user-id bayrağı set edilmişse "x" hakkının bulunduğu yerde "s" harfi gözükmektedir. Ancak dosyanın 
    yalnızca set-user-id bayrağı set edilmişse "x" hakkının bulunduğu yerde "S" harfi gözükür. Örneğin:

    $ ls -l test.txt
    -rw-rw-rw- 1 kaan study 2087 Şub 19 10:49 test.txt
    $ chmod u+s test.txt
    $ ls -l test.txt
    -rwSrw-rw- 1 kaan study 2087 Şub 19 10:49 test.txt

    Dosyanın set-grup-id bayrağının set edilmesi de chmod komutunda g+s ile yapılmaktadır. İşlem sonrasında yine grup bilgisinde "x"
    hakkı yerinde "s" ya da "S" görünür. chmod komutunda +s kullanılırsa bu durumda dosyanın hem set-user-id hem de set-group-id 
    bayrakları set edilir. Dosyanın sticky bayrağını set etmek için chmod komutunda +t kullanılmaktadır. Bu işlem yapıldığında
    görüntü olarak grup hakkında "x" varsa x hakkının olduğu yerde "t", yoksa orada "T" görülmektedir.

    Benzer biçimde istersek yine chmod komutunda octal digit'lerle set-user-d, set-group-id ve sticky bitlerini set edebiliriz. 
    Örneğin:

    $ chmod 4755 sample

    Burada en soldaki octal digit 4 olduğu için dosyanın set-user-id bayrağı da set edilmiştir.

    chmod fonksiyonunda yukarıda belirttiğimiz bayrakları kullanarak set-user-id, set-group-id ve stick bayraklarını set edebiliriz. 
    Örneğin biz "sample" programını rwsrwxrwx haline şöyle getirebiliriz:

    if (chmod("sample", S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID) == -1)
        exit_sys("chmod");

    Pekiyi zaten var olan bir dosyaya bu özellikleri programlama yoluyla nasıl ekleyebiliriz? Bunun için önce dosyanın erişim 
    haklarının stat, lstat ya da fstat fonksiyonuyla elde edilmesi gerekmektedir. Ondan sonra bu erişim haklarına biz S_ISUID, 
    S_ISGID ve S_ISVTX bayraklarını OR işlemiyle ekleyebiliriz. Ancak stat fonksiyonun bize verdiği st_mode değeri dosyanın türünü de 
    içermektedir. Gerçi chmod fonksiyonu bu ekstra bitleri dikkate almamaktadır. Ancak yine de stat yapısının st_mode elemanındaki 
    değeri S_IFMT ile maskelemek daha uygundur. (Stevens "Advanced Programming in the UNIX Environment" kitabında böyle yapmamıştır.)
    O halde bu işlem şöyle yapılabilir:

    struct stat finfo;

    if (stat("sample", &finfo) == -1)
        exit_sys("stat");

    if (chmod("sample", (finfo.st_mode & ~S_IFMT) | S_ISUID) == -1)        /* ~S_IMT maskelemesi yapılmasa da genel olarak bir sorun oluşmaz */
        exit_sys("chmod");
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
    struct stat finfo;

    if (stat("sample", &finfo) == -1)
        exit_sys("stat");

    if (chmod("sample", (finfo.st_mode & ~S_IFMT) | S_ISUID) == -1)
        exit_sys("chmod");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosyanın set-user-id ve set-group-id bayraklarının set edilmiş olmasının ne anlamı vardır? Öncelikle bu bayrakların 
    yalnızca "çalıştırılabilir dosyalar için" anlamlı olduğunu belirtelim. Yani bu bayraklar tasarımda "çalıştırılabilir dosyalar" 
    için düşünülmüştür. Çalıştırılabilir dosyanın set-user-id bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin 
    kullanıcı id'si işletim sistemi tarafından dosyanın kullanıcı id'si olacak biçimde değiştirilmektedir. Benzer biçimde çalıştırılabilir 
    dosyanın set-group-id bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin grup id'si dosyanın grup id'si olarak 
    değiştirilmektedir. Başka bir deyişle örneğin biz set-user-id bayrağı set edilmiş bir programı çalıştırdığımızda artık 
    prosesimiz etkin kullanıcı id'si sanki o dosyanın sahibiymiş gibi olmaktadır.

    "/bin/passwd" programı ile biz kendi parolamızı değiştirebilmekteyiz. Ancak bu program sıradan kullanıcılara yazma hakkı verilmemiş 
    olan "/etc/passwd" ve "/etc/shadow" dosyalarında değişiklikler yapabilmektedir. İşte biz /bin/passwd programının set-user-id 
    bayrağı set edildiği için onu çalıştırdığımızda sanki program "root" önceliğinde çalışmaktadır. Böylece program bu dosyalarda 
    değişiklik yapabilmektedir. "/bin/passwd" programının erişim hakları şöyledir:

    -rwsr-xr-x 1 root root 68208 May 28  2020 /bin/passwd

    Aşağıdaki örnekte "sample" programı "mample" programını exec yaparak çalıştırmıştır. Biz bu örnekte mample programını
    derledikten sonra chwon komutuyla sudo ile birlikte kullanıcı id'sini ve group id'sini root olarak değiştirdik.
    Bu mample programı prosesin gerçek ve etkin kullanıcı ve grup id'lerini ekrana isim olarak yazdırmaktadır. Bu deneyi önce
    mample programının set-user-id bayrağı set edilmeden ve set edildikten sonra yineleyiniz. Aşağıda yapılanlar özetlenmiştir:

    $ gcc -o sample sample.c
    $ gcc -o mample mample.c
    $ ls -l mample
    -rwxr-xr-x 1 kaan study 17088 Şub 19 13:42 mample
    $ sudo chown root:root mample
    $ ls -l mample
    -rwxr-xr-x 1 root root 17088 Şub 19 13:42 mample
    $ ./sample
    Real user id: kaan
    Effective user id: kaan
    Real group id: study
    Effective group id: study
    $ sudo chmod u+s mample
    $ ls -l mample
    -rwsr-xr-x 1 root root 17088 Şub 19 13:42 mample
    $ ./sample
    Real user id: kaan
    Effective user id: root
    Real group id: study
    Effective group id: study
    $ sudo chmod g+s mample
    $ ls -l mample
    -rwsr-sr-x 1 root root 17088 Şub 19 13:42 mample
    $ ./sample
    Real user id: kaan
    Effective user id: root
    Real group id: study
    Effective group id: root

    Biz bir programı sudo ile root önceliğinde (etkin proses id'si 0 olacak biçimde) çalıştırıyor olalım. Dosyanın set-user-id
    bayrağı da set edilmiş olsun. Bu durumda program çalışırken prosesin etkin kullanıcı id'si root değil program dosyasının
    kullanıcı id'si olacaktır. Yani set-user-id bayrağı set edilmiş olan programların sudo ile root önceliğinde çalıştırılmasının
    bir anlamı kalmamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execl("mample", "mample", (char *)0) == -1)
        exit_sys("execl");

    if (wait(NULL) == -1)
        exit_sys("wait");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    struct passwd *pass;
    struct group *gr;

    if ((pass = getpwuid(getuid())) == NULL)
        exit_sys("getpwuid");
    printf("Real user id: %s\n", pass->pw_name);

    if ((pass = getpwuid(geteuid())) == NULL)
        exit_sys("getpwuid");
    printf("Effective user id: %s\n", pass->pw_name);

    if ((gr = getgrgid(getgid())) == NULL)
        exit_sys("getgrgid");
    printf("Real group id: %s\n", gr->gr_name);

    if ((gr = getgrgid(getegid())) == NULL)
        exit_sys("getgrgid");
    printf("Effective group id: %s\n", gr->gr_name);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                32. Ders 25/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Normal olarak set-user id ve set-group-d bayrakları çalıştırılabilen dosyalar için söz konusudur. Ancak dizinler için de 
    set-group-d bayrağının bir anlamı vardır. Pek çok UNIX türevi sistemde (Linux da buna dahil) bir dizin'in set-group-id bayrağı
    set edilirse Linux o dizin içerisinde open fonksiyonuyla (zaten başka yolu yoktur) ya da mkdir fonksiyonu ile bir dosya 
    ya da dizin yaratıldığında dosyanın grup id'sini prosesin etkin grup id'si olarak değil, o dizin'in grup id'si olarak set 
    etmektedir. BSD sistemlerinde zaten default olarak bir dosya ya da dizin yaratıldığında dosyanın ya da dizin'in grup id'si 
    o dosyanın dosya ya da dizin'in içinde bulunduğu dizin'in grup id'si olarak set edilir. O halde Linux'ta open fonksiyonu ile 
    bir dosya ya da dizin yaratılırken dosya ya da dizin'in grup id'si eğer o dosyanın içinde bulunduğu dizin'in set-group-id 
    bayrağı set edilmemişse prosesin etkin group id'si olarak eğer set edilmişse dizin'in grup id'si olarak set edilmektedir.

    Dizinlerin set-user-id bayraklarının set edilmesi benzer bir etkiye yol açmamaktadır. (Bu durum bazı eski UNIX sistemlerinde 
    denenmiştir ancak modern sistemlerde böyle bir semantik yoktur.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi script dosyaları (shebang içeren text dosyalar) için set-user-id ve set-group-id bayrakları set edilebilir mi?
    Bu işlem ilk zamanlar uygulanmıştır. Ancak güvenlik açığı nedeniyle sonra uygulamadan kaldırılmıştır. Bugünkü modern UNIX/Linux 
    sistemleri script dosyalarının set-user-id ve set-group-id bayrakları set edilmiş olsa bile onları dikkate almamaktadır. 
    Buradaki güvenlik açığı ilginç bir biçimde aşağıdaki gibi oluşmaktadır:

    - Script dosyasının ismi "x.txt" olsun. Eğer bu dosyanın set-user-id ve set-group-id bayrakları dikkate alınsaydı bu durumda
    exec fonksiyonları bu dosyayı açıp shebang satırında bulunan programı çalıştırırken prosesin etkin kullanıcı ve/veya grup 
    id'sini "x.txt" dosyasının kullanıcı ve/veya grup id'si olarak set ederdi. Bu durumda da eğer birisi örneğin "y.txt" sembolik 
    bağlantı dosyası oluşturup bu dosyanın "x.txt" dosyasını göstermesini sağlarsa ve bu "y.txt" ile exec yaparsa bu durumda 
    aslında exec fonksiyonu sembolik bağlantıyı izleyecek ve "x.txt" dosyasını çalıştıracaktır. Ancak exec fonksiyonları bu 
    "x.txt" dosyasının shebang satırındaki programı çalıştırırken yine komut satırı argümanı olarak "y.txt" dosyasını kullanacaktır. 
    İşte tam bu sırada birisi bu "y.txt" dosyasının sembolik bağlantısını değiştirirse maalesef prosesin etkin kullanıcı 
    id'si "x.txt"nin kullanıcı id'si olarak buradaki başka dosyayı çalıştırır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi dosyaların sticky bayraklarının ne işlevi vardır? Aslında sticky bayrağı tasarımda başka bir amaçla düşünülmüştür. 
    Eski sistemlerde çalıştırılabilen dosyaların çalıştırılması sonrasında programın bellekten atılmaması gibi bir ipucu 
    oluşturmaktadır. Ancak modern sistemlerde böyle bir etkinin bir anlamı kalmadığı için sticky bayrağı da ilk tasarlandığı 
    zamanki işlevinden tamamen kopmuştur. Bugün sticky bayrağı değişik sistemlerde değişik amaçlarla kullanılabilmektedir. 
    POSIX standartları eskiden sticky bayrağı üzerinde açıklama yapmıyordu. Ancak belli zamandan sonra sticky için şöyle 
    bir işlevsellik tanımlanmıştır: Bir dizin'in sticky bayrağı set edilirse dizine prosesin yazma hakkı olsa bile dizin 
    içerisindeki başkalarına ait (yani kullanıcı id'si başka) olan dosyalar silinememekte ve ismi değiştirilememektedir. 
    Bugünkü sistemlerde dizin dışında diğer dosyaların sticky bayraklarının set edilmiş olup olmamasının işlevsel bir anlamı 
    yoktur. Örneğin Linux sistemlerinde "/tmp" dizininin sticky bayrağı set edilmiştir ve bu dizine yazma hakkı verilmiştir. 
    Bu durumda biz bu dizinde dosya yaratabiliriz, kendi dosyamızı silebiliriz. Ancak başkalarının dosyalarını silemeyiz. 
    "/tmp" dizininin erişim hakları şöyledir:

    drwxrwxrwt 19 root root 65536 Şub 25 10:05 /tmp
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bir prosesin "gerçek kullanıcı id'si (real user id)" ile "etkin kullanıcı id'si (effective 
    user id)", "gerçek grup id'si (real group id)" ile de "etkin grup id'si (effective group id)" aynı olmaktadır. Ancak 
    set-user-id ve set-group-id bayrakları set edilmiş çalıştırılabilir programlar çalıştırıldığında bu id'ler farklı hale 
    gelebilmektedir. Örneğin prosesimizin gerçek kullanıcı id'si ve etkin kullanıcı id'si "kaan" olsun. Biz set-user-id bayrağı set edilmiş 
    "/bin/passwd" programını exec yaptığımızda prosesimizin gerçek kullanıcı id'si "kaan" olmaya devam eder ancak etkin kullanıcı 
    id'si "root" olur. Dosya işlemlerinde teste her zaman etkin id'ler sokulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Gerçek kullanıcı id'si ve gerçek grup id'si, etkin kullanıcı id'si ve etkin grup id'si dışında bir de "saklı kullanıcı id'si 
    (saved set user id)" ve "saklı grup id'si (saved set group id)" denilen iki id daha vardır. Bir proses exec uyguladığında 
    programın set-user-id ve set-group-id bayrakları set edilmiş olsun ya da olmasın her zaman kernel yeni etkin kullanıcı id'sini 
    ve yeni etkin grup id'sini saklı kullanıcı id'si ve saklı grup id'si olarak set etmektedir. Örneğin prosesimizin gerçek kullanıcı 
    id'si "kaan" ve etkin kullanıcı id'si "kaan", gerçek grup id'si "study" ve "etkin grup id'si "study" olsun. Şimdi biz set-user-id 
    bayrağı set edilmiş olan "/bin/passwd" programını exec ile çalıştıralım. Arık prosesimizin gerçek kullanıcı id'si "kaan", 
    etkin kullanıcı id'si "root" olacaktır. Gerçek group id'si "study" ve etkin grup id'si de "study" olarak kalacaktır. İşte 
    kernel aynı zamanda bu yeni etkin kullanıcı ("root" id'sini kastediyoruz) ve grup id'sini prosesin "saklı kullanıcı id'si
    (saved set user id)" ve "saklı grup id'si" olarak da set etmektedir. O halde prosesimizin id'leri artık şöyle olacaktır:

    gerçek kullanıcı id'si: kaan
    etkin kullanıcı id'si: root
    saklı kullanıcı id'si: root
    gerçek grup id'si: study
    etkin grup id'si: study
    saklı grup id'si: study

    Bu işlem set-user id ya da set-group-id bayrağı set edilmemiş programlar çalıştırılırken de yürütülmektedir. Örneğin prosesimizin
    gerçek kullanıcı id'si "kaan", etkin kullanıcı id'si "kaan", gerçek grup id'si "study" ve etkin grup id'si "study" olsun. 
    Biz de set-user-id bayrağı set edilmemiş olan bir programı exec yapmış olalım. Yeni id'ler şöyle olacaktır:

    gerçek kullanıcı id'si: kaan
    etkin kullanıcı id'si: kaan
    saklı kullanıcı id'si: kaan
    gerçek grup id'si: study
    etkin grup id'si: study
    saklı grup id'si: study

    Tabii saklı kullanıcı id'si ve saklı grup id'si yine porses kontrol bloğu içerisinde (Linux'taki task_struct yapısı) 
    saklanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan prosesin (yani kendi prosesimizin) gerçek kullanıcı id'si getuid isimli POSIX fonksiyonuyla, etkin 
    kullanıcı id'si de geteuid isimli POSIX fonksiyonuyla elde edilebilmektedir. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    uid_t getuid(void)
    uid_t geteuid(void)

    uid_t türü <unistd.h> ve <sys/types.h> dosyaları içerisinde bir tamsayı türü olacak biçimde typedef edilmiştir. Bu fonksiyonlar
    başarısız olamamaktadır.

    O anda çalışmakta olan prosesin gerçek grup id'si getgid POSIX fonksiyonu ile, etkin grup id'si ise getegid POSIX fonksiyonu ile 
    elde edilebilmektedir. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    gid_t getgid(void);
    gid_t getegid(void);

    Bu fonksiyonlar da başarısız olamamaktadır.

    POSIX standartlarında saklı id'leri alan fonksiyonlar yoktur. Ancak Linux sistemlerinde bu işlemi yapacak fonksiyon bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    uid_t ruid, euid;
    gid_t rgid, egid;
    struct passwd *pass;
    struct group *grp;

    ruid = getuid();
    if ((pass = getpwuid(ruid)) == NULL)
        exit_sys("getpwuid");

    printf("Real User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ruid);

    euid = geteuid();

    if ((pass = getpwuid(euid)) == NULL)
        exit_sys("getpwuid");

    printf("Effective User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)euid);

    rgid = getgid();
    if ((grp = getgrgid(rgid)) == NULL)
        exit_sys("getgrgid");

    printf("Real Group Id: %s (%ju)\n", grp->gr_name, (uintmax_t)rgid);

    egid = getegid();

    if ((grp = getgrgid(egid)) == NULL)
        exit_sys("getgrgid");

    printf("Effective Group Id: %s (%ju)\n", grp->gr_name, (uintmax_t)egid);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesin kullanıcı ve grup id'lerini set etmek için setuid, setgid, seteuid ve setegid POSIX fonksiyonları bulundurulmuştur. 
    Ancak bu fonksiyonların sematiği kişiler biraz karmaşık gelmektedir. Biz burada bu fonksiyonları tek tek açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    setuid fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int setuid(uid_t uid);

    Her ne kadar fonksiyonun ismi sanki yalnızca prosesin "gerçek kullanıcı id'sini" değişterecek gibi görünüyorsa da aslında
    fonksiyon şöyle davranmaktadır: 

    1) Prosesin önceliği uygunsa (appropriate privileges) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde 
    proses bu işi yapacak yeterliliğe (capability) sahipse (CAP_SETUID) fonksiyon prosesin hem gerçek kullanıcı id'sini, hem 
    etkin kullanıcı id'sini hem de saklı kullanıcı id'sini parametresi ile belirtilen kullanıcı id'si yapar.

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETUID yeterliliği yoksa) bu durumda setuid 
    fonksiyonu eğer parametresi ile belirtilen uid değeri prosesin gerçek ya da saklı kullanıcı id'si ile aynı ise prosesin 
    yalnızca etkin kullanıcı id'sini parametresi ile belirtilen id olarak değiştirir. Bu koşullar sağlanmıyorsa fonksiyon başarısız 
    olmaktadır. Pekiyi bunun anlamı nedir? Bu işlem set-user-id programların kısmen geri daha sonra dönüp yeniden önceliği geri 
    almasını sağlamak için düşünülmüştür. Saklı id'lerin kullanılmasının tek nedeni de budur. Şöyle ki:

    - Biz kaan prosesi olarak set-user-id bayrağı set edilmiş root programını çalıştırdığımızı düşünelim. Şimdi bizim id'lerimiz
    şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi biz sonraki paragrafta göreceğimiz seteuid fonksiyonu ile geri dönüp prosesin yeteneğini azaltarak onun etikin kullanıcı
    id'sinin kaan olmasını sağlayalım. Bu durumdaki id'ler şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    İşte şimdi bu noktada biz setuid fonksiyonu ile yeniden root önceliğine dönebiliriz. Çünkü bizim şu anda uygun önceliğimiz 
    olmasa da saklı kullanıcı id'miz hala root durumundadır. Yani programlar önceliği yükse birtakım işlemler yapıp sonra önceliği 
    düşürüp sonra da yüksek önceliğe geri dönmek için saklı id'ler uydurulmuştur.

    setuid fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno uygun biçimde set 
    edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    seteuid fonksiyonu setuid fonksiyonunun yalnızca etkin kullanıcı id'sini set eden biçimidir. Genellikle setuid yerine bu 
    fonksiyon tercih edilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int seteuid(uid_t uid);

    Fonksiyonun çalışması şöyledir:

    1) Prosesin önceliği uygunsa (appropriate privileges) yani prosesin etkin kullanıcı id'si 0 ise ya da proses Linux sistemlerinde 
    bu işi yapacak yeterliliğe (capability) sahipse (CAP_SETUID) fonksiyon prosesin yalnızca etkin kullanıcı id'sini parametresiyle 
    belirtilen id olarak değiştirir. Gerçek kullanıcı id'si ve saklı kullanıcı id'si değiştirilmez.

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETUID yeterliliği yoksa) bu durumda seteuid 
    fonksiyonu eğer parametresi ile belirtilen uid değeri prosesin gerçek ya da saklı kullanıcı id'si ile aynı ise prosesin 
    yalnızca etkin kullanıcı id'sini parametresi ile belirtilen id olarak değiştirir.

    Görüldüğü gibi eğer prosesin önceliği uygun değilse zaten setuid fonksiyonu ile seteuid fonksiyonu arasında bir fark 
    kalmamaktadır.

    Bu durumda geri dönüş senaryosu tam olarak şöyle gerçekleştirilir. Yine prosesimizin id'leri şöyle olsun:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan

    Şimdi biz set-user-id bayrağı set edilmiş bir programı exec yapalım. Id'lerimiz şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi çalıştırdığımız program kaan olarak bazı şeyleri yapmak istesin o zaman şu çağrıyı yapacaktır:

    seteuid(getuid());

    Şimdi prosesin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Burada saklı kullanıcı id'sinin değişmediğine dikkat ediniz. Şimdi proses kaan olarak bazı şeyleri yaptıktan sonra yeniden 
    root olmak istesin:

    seteuid(0);

    Tabii aynı işlem setuid(0) ile de yapılabilirdi. Şimdi prosesin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Eğer saklı kullanıcı id'si diye bir kavram uydurulmuş olmasaydı geri dönüş yapılamazdı.

    seteuid fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. errno uygun biçimde 
    set edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    setgid fonksiyonun temel semantiği setuid fonksiyonunda olduğu gibidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int setgid(gid_t gid);

    Fonksiyon şöyle çalışmaktadır:

    1) Prosesin önceliği uygunsa (appropriate privileges) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde 
    proses bu işi yapacak yeterliliğe (capability) sahipse (CAP_SETGID) fonksiyon prosesin hem gerçek grup id'sini, hem etkin 
    grup id'sini hem de saklı grup id'sini parametresi ile belirtilen grup id'si yapar.

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETGID yeterliliği yoksa) bu durumda setgid 
    fonksiyonu eğer parametresi ile belirtilen gid değeri prosesin gerçek ya da saklı grup id'si ile aynı ise prosesin yalnızca 
    etkin grup id'sini parametresi ile belirtilen grup id olarak değiştirir.

    Buradaki amaç tamamen set-group-id bayrağı set edilmiş programların grup id'lerini geri döndürüp yeniden eski değere 
    set edebilmesidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    setegid fonksiyonun temel semantiği de seteuid fonksiyonunda olduğu gibidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int setegid(gid_t gid);

    Fonksiyon şöyle çalışmaktadır:

    1) Prosesin önceliği uygunsa (appropriate privileges) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde 
    proses bu işi yapacak yeterliliğe (capability) sahipse (CAP_SETGID) fonksiyon prosesin yalnızca etkin grup id'sini 
    parametresiyle belirtilen grup id'i olarak değiştirmektedir.

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETGID yeterliliği yoksa) bu durumda setegid 
    fonksiyonu eğer parametresi ile belirtilen gid değeri prosesin gerçek ya da saklı grup id'si ile aynı ise prosesin yalnızca 
    etkin grup id'sini parametresi ile belirtilen grup id olarak değiştirir.

    Yani eğer prosesin önceliği uygun değilse bu durumda setgid ile setegid fonksiyonları arasında bir fark kalmamaktadır.

    setgid ve setegid fonksiyonları yine grup id bakımından geriye dönüşü sağlamak için düşünülmüştür. Şöyleki, prosesimizin 
    işin başında id'leri şöyle olsun:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: study
    Saklı grup id'si: study

    Şimdi biz set-group-id bayrağı set edilmiş bir programı çalıştıralım. Program dosyasının kullanıcı id'si "ali", grup 
    id'si ise "test" olsun. Biz exec yaptığımızda id'lerimiz şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: test
    Saklı grup id'si: test

    Şimdi biz grup olarak geçmişe dönüp bazı şeyleri yapmak isteyelim:

    setegid(getgid());

    Tabii burada setgid fonksiyonunu da kullanabilirdik. Şimdi prosesimizin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: study
    Saklı grup id'si: test

    Şimdi eski grup id'ye yeniden geri dönmek isteyelim:

    setegid(test_gid);

    Tabii burada yine setgid fonksiyonu da kullanılabilirdi. Görüldüğü gibi grup temelinde geri dönüp yeniden aynı etkin 
    grup id'ye sahip olabilmek için saklı grup id'den faydalanılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bizim prosesimizin kullanıcı id'leri şöyle olsun:

    Gerçek kullanıcı id'si: root
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi biz aşağıdaki gibi bir çağrı yaparsak artık geri dönüş olanağımız kalmaz:

    setuid(uid_kaan);

    Çünkü uygun önceliğe sahip olan program setuid fonksiyonunu uyguladığında yalnızca kullanıcı etkin id'si değil, gerçek 
    kullanıcı id'si ve saklı kullanıcı id'si de değişmektedir. Yani bu işlem sonucunda kullanıcı id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan

    Ancak biz şu çağrıyı yapmış olsaydık geri dönebilirdik:

    seteuid(uid_kaan);

    Şimdi kullanıcı id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: root
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Şimdi artık setuid ya da seteuid fonksiyonu ile geri dönüş mümkündür. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki fonksiyonlara ek olarak setreuid ve setregid isimli iki yardımcı fonksiyon da bulundurulmuştur. Aslında bu 
    fonksiyonlara mutlak anlamda gerek yoktur. Ancak bazı işlemleri kolaylaştırmaktadır. Bu fonksiyonlar ilk kez BSD UNIX 
    sistemlerinde kullanılmış daha sonra POSIX standartlarına dahil edilmiştir. Bu fonksiyonların ana amacı tek hamlede gerçek 
    kullanıcı ve etkin kullanıcı id'lerini, gerçek grup id ve etkin grup id'lerini değiştirebilmektedir. Genellikle gerçek 
    id'lerle etkin id'leri yer değiştirmek amacıyla bu fonksiyon kullanılmaktadır.

    setreuid fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int setreuid(uid_t ruid, uid_t euid);

    Fonksiyon parametre olarak değiştirilmek istenen gerçek kullanıcı id'sini ve grup id'sini almaktadır. Eğer bunlardan herhangi 
    biri değiştirilmek istenmiyorsa bu durumda o parametre için -1 girilir.

    Fonksiyon şöyle çalışmaktadır:

    1) Eğer proses uygun önceliğe sahipse (yani root ise ya da Lİnux sistemlerinde CAP_SETUID yeteneğine sahipse) her iki id'yi 
    de değiştirir.

    2) Eğer proses uygun önceliğe sahip değilse fonksiyon yalnızca etkin kullanıcı id'sini değiştirir. Ancak bunu yapılabilmesi 
    için prosesin gerçek kullanıcı id'sinin ya da saklı kullanıcı id'sinin argüman olarak geçilen id ile aynı olması gerekmektedir.

    3) POSIX standartlarında bu fonksiyon ile gerçek kullanıcı id'sinin etkin kullanıcı id'si ya da saklı kullanıcı id'si biçiminde 
    değiştirilip değiştirilemeyeceği "belirsiz (unspecified)" bırakılmıştır. Linux sistemlerinde setreuid fonksiyonu "prosesin gerçek 
    kullanıcı id'sini etkin kullanıcı id'si olarak" değiştirebilmektedir. Ancak saklı kullanıcı id'si olarak değiştirememektedir.

    Bu fonksiyon eğer set edilmek istenen etkin kullanıcı id'si (yani hedef etkin kullanıcı id'si) prosesin o andaki gerçek 
    kullanıcı id'sine eşit değilse bu durumda saklı kullanıcı id'sini de etkin kullanıcı id'si olarak set etmektedir. Aynı zamanda 
    fonksiyon yine eğer gerçek kullanıcı id'si set ediliyorsa saklı kullanıcı id'sini yine hedef etkin kullanıcı id'si olarak set 
    etmektedir. Fonksiyonun parametrelerinden biri bile uygunsuzsa fonksiyon başarısız olmaktadır. Fonksiyon başarı durumunda 0 
    değerine, başarısızlık durumunda -1 değerine geri döner ve errno değeri uygun biçimde set edilir. Örneğin:

    setreuid(getuid(), getuid());

    Burada çağrı sonucunda prosesin gerçek kullanıcı id'si değişmeyecektir. Ancak prosesin etkin kullanıcı id'si ve saklı kullanıcı 
    id'si gerçek kullanıcı id'si olarak set edilecektir. Artık geri dönüş mümkün değildir. Örneğin:

    setreuid(geteuid(), getuid());

    Burada prosesin kullanıcı id'si ile etkin kullanıcı id'si yer değiştirilmiştir. Örneğin prosesin çağrı öncesindeki kullanıcı 
    id'leri şöyle olsun:

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi şu çağrıyı yapalım:

    setreuid(geteuid(), getuid());

    Şimdi id'ler şöyle olacaktır:

    Gerçek kullanıcı id'si: root
    Etkin kullanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Buradan eski duruma şöyle dönebiliriz:

    setreuid(geteuid(), getuid());

    Gerçek kullanıcı id'si: kaan
    Etkin kullanıcı id'si: root
    Saklı kullanıcı id'si: root

    Tabii yukarıda da belirttiğimiz gibi bu fonksiyonda prosesin uygun önceliği yoksa kullanıcı id'sinin etkin kullanıcı 
    id'si olarak değiştirilip değiştirilemeyeceği POSIX sistemlerinde belirsiz bırakılmıştır. Ancak Linux ve BSD bunu 
    yapabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    setregid fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int setregid(gid_t rgid, gid_t egid);

    setregid fonksiyonu da setereuid fonksiyonu ile grup temelinde benzer semantiğe sahiptir: 

    1) Eğer proses uygun önceliğe sahipse (yani root ise ya da Lİnux sistemlerinde CAP_SETGID yeteneğine sahipse) fonksiyon 
    her iki id'yi de değiştirir.

    2) Eğer proses uygun önceliğe sahip değilse fonksiyon etkin grup id'sini değiştirir. Ancak bunu yapılabilmesi için
    prosesin gerçek grup id'sinin ya da saklı grup id'sinin argüman olarak geçilen id ile aynı olması gerekmektedir.

    3) Fonksiyon uygun önceliğe sahip değilse gerçek grup id'sini saklı grup id'si olarak değiştirebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi POSIX standartlarında saklı kullanıcı ve grup id'lerini almanın bir yolu yoktur. Ancak 
    Linux sistemleri bir sistem fonksiyonu yoluyla buna izin vermektedir. getresuid ve getresgid fonksiyonları bütün id'leri 
    tek hamlede elde etmeye izin vermektedir.

    #define _GNU_SOURCE         /* See feature_test_macros(7) */
    #include <unistd.h>

    int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
    int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

    Fonksiyonlar ilgili nesnelerin adreslerini alıp değerleri oraya yerleştirmektedir. Başarı durumunda 0, başarısızlık durumunda 
    -1 değerine geri dönmektedir.

    Aşağıdaki örnekt prosesin gerçek, etkin ve saklı kullanıcı id'leri getresuid fonksiyonuyla elde edilip ekrana yazdırılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

 #define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(void)
{
    uid_t ruid, euid, ssuid;
    struct passwd *pass;

    if (getresuid(&ruid, &euid, &ssuid) == -1)
        exit_sys("getresuid");

    if ((pass = getpwuid(ruid)) == NULL)
        exit_sys("getpwuid");

    printf("Real User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ruid);

    if ((pass = getpwuid(euid)) == NULL)
        exit_sys("getpwuid");

    printf("Effective User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)euid);

    if ((pass = getpwuid(ssuid)) == NULL)
        exit_sys("getpwuid");

    printf("Saved Set User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ssuid);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                33. Ders 26/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde getresuid ve getresgid fonksiyonlarının bir de set'li versiyonları vardır. Bu fonksiyonlar da birer 
    sistem fonksiyonu olarak gerçekleştirilmiştir. Bu fonksiyonlar POSIX standartlarında bulunmamaktadır:

    #define _GNU_SOURCE            /* See feature_test_macros(7) */
    #include <unistd.h>

    int setresuid(uid_t ruid, uid_t euid, uid_t suid);
    int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

    Fonksiyonlar sırasıyla gerçek, etkin ve saklı id'leri alarak proses için set işlemi yapmaktadır. Set işlemi için şu koşullar
    bulunmaktadır: Uygun önceliğe sahip olmayan prosesler gerçek, etkin ve saklı id'lerini ancak o andaki gerçek, etkin ve saklı 
    id'lerinden biri olarak değiştirebilirler. Uygun önceliğe sahip olan prosesler bunları herhangi bir biçimde değiştirebilirler. 
    Yine fonksiyon herhangi bir parametrede uygunsuz bir durumla karşılaşırsa tüm işlem başarısız olur ve -1 değeri ile geri 
    döner. Başarı durumunda fonksiyon 0 ile geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İlk zamanlar UNIX sistemlerinde prosesler tek bir grup ile ilişkilendirilmişti. Sonra bir prosesin birden fazla grup ile 
    ilişkili olması gerektiği anlaşıldı ve bu durum "ek gruplar (supplementary groups)" kavramı ile sisteme dahil edilerek 
    gerçekleştirildi. Ek gruplar konusu uzun süredir POSIX standartlarının içerisinde var olan ve neredeyse tüm UNIX türevi 
    sistemlerin desteklediği bir özelliktir.

    Bir kullanıcının gerçek bir grubu vardır. Dolayısıyla işin başında gerçek grup id'si ve etkin grup id'si bu gruptur. 
    Anımsanacağı gibi dosya erişimlerinde test işlemlerine etkin kullanıcı id'si ve etkin grup id'si girmektedir. Yine 
    anımsanacağı gibi bir dosyanın rwx biçimindeki hangi üçlü kısmının open fonksiyonunda ve diğer fonksiyonlarda dikkate alınacağı 
    şöyle belirleniyordu:

    if (prosesin etkin kullanıcı id'si == 0)
        <proses her şeyi yapabilir >
    else if (prosesin etkin kullanıcı id'si == dosyanın kullanıcı id'si)
        <dosyanın rwx owner hakları dikkate alınır>
    else if (prosesin etkin grup id'si ya da ek gruplarından birinin id'si == dosyanın grup id'si)
        <dosyanın rwx grup hakları dikkate alınır>
    else
        <dosyanın rwx other hakları dikkate alınır>

    Buradan görüldüğü gibi grup kontrolü yapılırken yalnızca prosesin etkin grup id'si değil aynı zamanda ek grup id'leri de 
    eşdeğer düzeyde etkili olmaktadır. Yani örneğin prosesimizin etkin grup id'si "study" olsun. Ancak ek grupları da "work" ve 
    "test" olsun. Erişmeye çalıştığımız dosyanın grup id'si "test" ise her ne kadar bizim etkin grup id'miz "test" değilse de
    ek gruplarımızdan biri "test" olduğu için biz bu dosya ile aynı gruptan proses kabul ediliriz.

    Pekiyi ek gruplara neden gereksinim duyulmuştur? Bunun gerekçesini şöyle bir örnekle açıklayabiliriz. "ali", "veli" ve "selami"
    ortak bir proje üzerinde çalışıyor olsunlar. Bunların proje dosyalarına ortak biçimde erişebilmek için aynı gruba dahil olmaları 
    gerekir. Ancak "ali" kullanıcısının "ayse" ve "fatma" ile başka bir proje üzerinde de çalıştığını varsayalım. Eğer bu ikinci 
    proje grubundaki üyeler de aynı grup id'ye sahip olurlarsa bu durumda bu ikinci proje grubuna dahil olmayanlar da ikinci proje
    grubunun dosyalarına erişebilecektir. Yani bir kullanıcı birden fazla proje üzerinde çalışacaksa birden fazla gruba üye 
    olabilmelidir.

    Bir prosesin gerçek kullanıcı ve gerçek grup id'leri login prosesi tarafından "/etc/passwd" dosyasına başvurularak belirlenmektedir.
    İşte login programı prosesin ek gruplarını da "/etc/group" dosyasına bakarak belirlemektedir. Anımsanacağı gibi "/etc/group" 
    dosyasındaki her satır bir gruba ilişkin bilgileri barındırıyordu. Satırın sonundaki son eleman ise o gruba ek grup olarak 
    dahil olan kullanıcıları belirtmektedir. Örneğin:

    ...
    sys:x:3:
    adm:x:4:syslog,kaan
    tty:x:5:syslog
    disk:x:6:
    ...

    Burada syslog kullanıcısı hem adm grubuna hem de tty grubuna ek grup olarak üye biçimdedir. kaan kullanıcısı da ek grup 
    olarak adm grubuna üyedir. Tabii login prosesinin bir kullanıcının ek gruplarını belirleyebilmesi için /etc/group dosyasındaki 
    tüm satırları gözden geçirmesi gerekmektedir.

    Bu durumda pseudo kod olarak login programı şöyle yazılmıştır:

    1) user name ve password iste (bunu terminal programı da yapıyor olabilir)
    2) /etc/passwd ve /etc/shadow dosyalarına başvurarak doğrulamayı yap
    3) Kullanıcının ek grup'larını tespit etmek için /etc/group dosyasını dolaş ve kullanıcının ek gruplarını elde et
    4) setuid fonksiyonuyla prosesin gerçek, etkin ve saklı kullanıcı id'sini /etc/passwd dosyasında belirtilen biçimde set et.
    5) setgid fonksiyonuyla prosesin gerçek, etkin ve saklı grup id'sini /etc/passwd dosyasında belirtilen biçimde set et.
    6) chdir fonksiyonuyla prosesin çalışma dizinini /etc/passwd dosyasında belirtildiği gibi set et
    7) exec ile /etc/passwd dosyasında belirtilen programı çalıştır.

    Genel olarak login programı fork/exec değil yalnızca exec yapmaktadır. Biz shell'den çıkınca normalde yeniden login programı
    çalıştırılmaktadır.

    Tabii prosesin ek grupları da diğer bilgilerde olduğu gibi prosesin kontrol bloğunda saklanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan prosesin ek grup id'leri getgroups isimli POSIX fonksiyonu ile elde edilebilmektedir. Fonksiyonun 
    prototipi şöyledir:

    #include <unistd.h>

    int getgroups(int gidsetsize, gid_t grouplist[]);

    Fonksiyonun ikinci parametresi ek grup id'lerinin yerleştirileceği gid_t türünden dizini başlangıç adresini belirtir. 
    Birinci parametre ise bu dizinin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda diziye yerleştirdiği eleman sayısına, 
    başarısızlık durumunda -1 değerine geri dönmektedir. Pekiyi biz bu fonksiyona geçireceğimiz dizinin uzunluğunu nasıl 
    belirleyebiliriz? Daha ileride göreceğimiz gibi <limits.h> içerisinde NGROUPS_MAX isimli bir sembolik sabit vardır. Bu 
    sembolik sabit ilgili sistemindeki proseslerin sahip olabileceği maksimum grup sayısını belirtmektedir. Ancak maalesef bu 
    sembolik sabit "Runtime Increasable Values" grubundadır. Yani bu değer sistem açıldıktan sonra artırılmış olabilir. Gerçek 
    değer ise sysconf fonksiyonuyla elde edilmektedir. Ancak sysconf fonksiyonun çağrılması zahmetlidir. Bu fonksiyonun özel 
    bir durum olarak birinci parametresi 0 geçilirse zaten fonksiyon bize o kullanıcının ek gruplarının sayısını vermektedir. 
    Biz de bu sayı kadar alanı malloc ile tahsis edebiliriz. Fonksiyondaki diğer önemli bir nokta fonksiyonun aynı zamanda prosesin 
    etkin grup id'sini de verdiğimiz diziye yerleştirip yerleştirmeyeceğinin sistemden sisteme değişebileceğidir. Linux sistemleri 
    her zaman prosesin etkin kullanıcı id'sini de bu diziye yerleştirmektedir. NGROUPS_MAX sembolik sabitine bu değer dahil değildir. 
    Yani buradan hareketle dizi uzunlu belirlenecekse bu değerden bir fazla değer kadar alan malloc ile tahsis edilmelidir. Ancak 
    birinci parametre 0 geçilirse zaten geri döndürülen değere bu değer dahildir. Özetle fonksiyonun çağrılmasında şu yöntemler 
    izlenebilir:

    1) Dizi NGROUPS_MAX + 1 uzunlukta açılıp fonksiyon başarısız olursa sysconf fonksiyonu ile gerçek değer elde edilebilir. 
    Ya da doğrudan sysconf fonksiyonu kullanılabilir.

    2) Dizi uzunluğu büyük bir değer olarak tespit edilebilir. Ancak fonksiyonun başarısı kontrol edilebilir.

    3) Fonksiyonun birinci parametresine 0 geçilerek fonksiyon çağrılabilir. Elde edilen değerden hareketle malloc fonksiyonu ile
    tam istenen uzunlukta alan tahsis edilebilir.

    Aşağıdaki örnekte prosesin ek grup id'leri alınıp ekrana (stdout dosyasına) yazdırılmıştır. Linux sistemlerinde bu listeye
    prosesin etkin grup id'sinin de dahil edildiğine dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    gid_t *sgids;
    int ngroups;
    struct group *grp;

    if ((ngroups = getgroups(0, NULL)) == -1)
        exit_sys("getgroups");

    if ((sgids = (gid_t *)malloc(ngroups * sizeof(gid_t))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    if (getgroups(ngroups, sgids) == -1)
        exit_sys("getgroups");

    for (int i = 0; i < ngroups; ++i) {
        if ((grp = getgrgid(sgids[i])) == NULL)
            exit(EXIT_FAILURE);
        if (i != 0)
            printf(", ");
        printf("%ju (%s)", (uintmax_t)sgids[i], grp->gr_name);
    }
    printf("\n");

    free(sgids);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında prosesin ek gruplarını set eden bir fonksiyon bulundurulmamıştır. Ancak işletim sistemlerinde bunu 
    yapan mecburen bir sistem fonksiyonu bulundurulmak zorundadır. Linux sistemlerinde ve diğer pek çok UNIX türevi sistemde
    setgroups isimli fonksiyon ilgili sistem fonksiyonunu çağırarak bu işi yapmaktadır. Fonksiyonun prototipi şöyledir:

    #include <grp.h>

    int setgroups(size_t size, const gid_t *list);

    Fonksiyonun Fonksiyonun ikinci parametresi set edilecek ek grupların listesini belirtmektedir. Bu listeye prosesin etkin 
    grup id'si dahil edilmemelidir. Birinci parametresi ise bu dizinin uzunluğunu belirtir. Fonksiyon başarı durumunda 0, 
    başarısızlık durumunda -1 değerine geri döner. Tabii fonksiyonu herkes çağıramaz. Fonksiyonun başarılı olması için prosesin 
    uygun önceliğe (appropriate privileges)" sahip olması gerekmektedir. (Yani prosesin etkin kullanıcı id'si 0 (root) olması 
    ya da Linux sistemlerinde CAP_SETGID yeterliliğine sahip olması gerekir.)

    Aşağıdaki program set-user-id bayrağı set edilmiş sahibi root olan bir program dosyasına dönüştürülmüştür. Program aşağıdaki
    gibi derlenmiştir:

    $ gcc -o sample sample.c

    Sonra program dosyasının sahibi root olarak değiştirilmiştir. Ondan sonra da program dosyasının set-user-id bayrağı set 
    edilmiştir:

    $ sudo chown root sample
    $ ls -l sample
    -rwxr-xr-x 1 root study 17400 Şub 26 12:18 sample
    $ sudo chmod u+s sample
    $ ls -l sample
    -rwsr-xr-x 1 root study 17400 Şub 26 12:18 sample

    Burada önce dosyanın modunun değiştirildiğine daha sonra set-user-id bayrağının set edildiğine dikkat ediniz. Çünkü chown 
    POSIX fonksiyonu dosyanın set-user-id ve set-group-id bayraklarını reset etmektedir. chown fonksiyonunun dokümantasyonunu
    dikkatlice bir kez daha okuyunuz.

    Aşağıdaki programda önce prosesin ek grupları elde edilmiş sonra ek gruplara bir grup dahil edilip setgroups fonksiyonuyla 
    prosesin ek grupları set edilmiştir. setgroups işleminde prosesin ekin kullanıcı id'si 0 olduğu için başarılı olmaktadır. 
    En sonunda program setuid fonksiyonu ile asıl kullanıcının gerçeki etkin ve saklı kullanıcı id'leriyle çalışmaya devam 
    ettirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    gid_t *sgids;
    int ngroups;
    struct group *grp;
    uid_t euid;

    euid = geteuid();

    if ((ngroups = getgroups(0, NULL)) == -1)
        exit_sys("getgroups");

    if ((sgids = (gid_t *)malloc((ngroups + 1) * sizeof(gid_t))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    if (getgroups(ngroups, sgids) == -1)
        exit_sys("getgroups");

    for (int i = 0; i < ngroups; ++i) {
        if ((grp = getgrgid(sgids[i])) == NULL)
            exit(EXIT_FAILURE);
        if (i != 0)
            printf(", ");
        printf("%ju (%s)", (uintmax_t)sgids[i], grp->gr_name);
    }
    printf("\n");

    sgids[ngroups] = 0;

    if (setgroups(ngroups + 1, sgids) == -1)
        exit_sys("setgroups");

    free(sgids);

    if (setuid(getuid()) == -1)        /* prosesin gerçek, etkin ve saklı kullanıcı id'leri gerçek kullanıcı id'si haline getiriliyor */
        exit_sys("setuid");

    printf("success...\n")    ;

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir kullanıcının (yani kullanıcı id'sinin) ilişkin olduğu tüm grupları görebilmek için kabuk üzerinde "id" komutu ya da 
    "groups" komutu uygulanabilir. Örneğin:

    $ id
    uid=1000(kaan) gid=1000(study) gruplar=1000(study),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),115(lpadmin),136(sambashare)
    $ groups
    study adm cdrom sudo dip plugdev lpadmin sambashare

    Var olan bir kullanıcıya bir ek grup atamak için "adduser" komutu kullanılabilir. Aslında bu "adduser" komutu yeni bir 
    kullanıcı yaratmak için kullanılmaktadır. Ancak bu komuta biz var olan bir kullanıcı ve grup verirsek bu komut kullanıcıyı
    ek grup olarak da ilgili gruba eklemektedir. Ancak bu komut o andaki kabuk prosesinde bir değişiklik yaratmaz. Yalnızca 
    "/etc/group" dosyasında güncelleme yapmaktadır. Örneğin:

    $ sudo adduser kaan work
    [sudo] kaan için parola:
    "kaan" kullanıcısı "work" grubuna ekleniyor ...
    kaan kullanıcısı work grubuna ekleniyor
    Tamamlandı.

    Aynı şey "usermod" kabuk komutuyla da yapılabilmektedir:

    $ sudo usermod -G work kaan

    Bir kullanıcının ek gruptan silinmesi de benzer komutlarla yapılabilmektedir. Örneğin:

    $ sudo deluser kaan work
    `kaan' kullanıcısı `work' grubundan siliniyor ...
    Tamamlandı.

    Burada "kaan" kullanıcısı "work" isimli gruptan çıkarılmıştır. Tabii bu komut da yalnızca "etc/group" dosyası üzerinde 
    güncelleme yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    fork işlemi sırasında üst prosesin tüm ek grupları alt prosese aktarılmaktadır. Yani örneğin biz kabuk üzerinden bir program 
    çalıştırdığımızda kabuk prosesinin ek grupları bizim prosesimize kabuğun uyguladığı fork neticesinde aktarılmış olacaktır. 
    Tabii kabuk prosesinin de ek grupları aslında login programı tarafından "/etc/group" dosyasına başvurularak set edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında bir POSIX fonksiyonu olmasa da Linux, BSD ve pek çok UNIX türevi sistemlerde initgroups isimli bir fonksiyon da
    bulunmaktadır. Bu fonksiyon /etc/group dosyasını dolaşarak belli bir kullanıcının bütün ek grup bilgilerini elde eder ve
    setgroups fonksiyonu ile bunları set eder. Yani tipik olarak login programı aslında bu initgroups fonksiyonunu çağırmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <grp.h>

    int initgroups(const char *user, gid_t group);

    Fonksiyon birinci parametresiyle kullanıcının ismini alır. /etc/group dosyasına başvurarak kullanıcının ek grup id'lerini 
    elde eder. Sonra da setgroups fonksiyonunu uygulayarak prosesin ek gruplarını set eder. Tabii fonksiyonun bu işlemi yapabilmesi 
    için yine uygun önceliğe sahip olması gerekmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine döner ve errno uygun biçimde set edilir. Fonksiyonun ikinci parametresi /etc/group dosyasından elde edilen ek 
    gruplara dahil edilecek ekstra bir grubu belirtmektedir. Tipik olarak login prosesi prosesin etkin grup id'sini bu listeye 
    eklemek için fonksiyonun ikinci parametresini prosesin etkin grup id'si ile çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bugünkü masaüstü işletim sistemleri "zaman paylaşımlı (time sharing)" bir çalışma ortamı oluşturmaktadır. Zaman paylaşımlı 
    çalışma fikri ilk kez 1957 yılında uygulanmış ve sonra aktif bir biçimde işletim sistemlerine sokulmuştur. Dolayısıyla bugün 
    kullandığımı UNIX/Linux, Windows ve macOS sistemleri zaman paylaşımlı çalışma uygulamaktadır.

    Proses terimi çalışmakta olan programın bütün bilgilerini içermektedir. Programın bağımsız çizelgelenen akışlarına "thread"
    denilmektedir. Thread'ler 90 yılların ortalarına doğru işletim sistemlerine sokulmuştur. Bir proses tek bir thread'le çalışmaya 
    başlatılır. Buna prosesin "ana thread'i (main thread)" denir. Diğer thread'ler sistem fonksiyonlarıyla ya da sistem fonksiyonlarını 
    çağıran kütüphane fonksiyonlarıyla programcı tarafından yaratılmaktadır.

    Zaman paylaşımlı çalışmada proseslerin thread'leri işletim sistemi tarafından CPU'ya atanır. O thread'in CPU'da belli bir süre 
    çalışmasına izin verilir. O süre dolduğunda thread'in çalışmasına ara verilip başka thread benzer biçimde CPU'ya atanmaktadır. 
    Tabii çalışmasına ara verilen thread'in bilgileri proses kontrol bloğuna kaydedilmekte ve çalışma sırası yeniden o thread'e 
    geldiğinde thread en son kesilen noktadan çalışmasına devam etmektedir.

    Bir thread'in zaman paylaşımlı bir biçimde çalıştırıldığı parçalı çalışma süresine "quanta süresi" ya da İngilizce "time 
    quantum" denilmektedir. Quanta süresinin ne kadar olacağı işletim sisteminin tasarımına bağlıdır. Bir thread'in çalışmasına 
    ara verilmesi ve sıradaki thread'in CPU'ya atanması sürecine ise İngilizce "task switch" ya da "context switch" denilmektedir. 
    Tabii bu işlem de belli bir zaman çerçevesinde yapılabilmektedir. Eğer quanta süresi uzun tutulursa interaktivite azalır. 
    Quanta süresi tutulursa zamanın önemli kısmı "context switch" için harcanır dolayısıyla "birim zamanda yapılan iş miktarı
    (throughput)" düşer. Quanta süresi çeşitli faktörlere bağlı olarak değişebilmektedir. UNIX/Linux sistemleri ortalama 60 ms. 
    civarında Windows sistemleri ortalama 20 ms. civarında bir quanta süresi uygulamaktadır.

    Zaman paylaşımlı bir sistemde kullanıcı sanki tüm proseslerin aynı anda çalıştığını sanmaktadır. Halbuki bu bir illüzyondur. 
    Aslında programlar sürekli ara verilip çalıştırılmaktadır. Bu işlem çok hızlı yapıldığı için sanki programlar aynı anda 
    çalışıyormuş gibi bir algı oluşmaktadır.

    Pekiyi bir thread CPU'ya atanmışken onun quanta süresini doldurması ve CPU'dan kopartılması nasıl sağlanmaktadır? İşte bu 
    işlem hemen her zaman donanım kesmeleri yoluyla yapılmaktadır. Sistem donanımında periyodik kesme oluşturan bir mekanizma 
    vardır. Buna "timer kesmesi" ya da UNIX/Linux dünyasında "jiffy" denilmektedir. Eski Linux sistemleri makineler yavaş olduğu 
    için timer kesme periyodunu 10 ms. olarak ayarlamaktaydı. Ancak makineler hızlanınca artık bu periyot uzun süredir 1 ms. 
    biçiminde ayarlanmaktadır. Yani her 1 milisaniyede bir aslında donanım kesmesi yoluyla kernel kodu devreye girmektedir. 
    Bu kesme kodu da 60 ms. gibi bir zaman dolduğunda thread'ler arası geçiş (context switch) yapmaktadır. Thread akışının bu 
    biçimde quanta süresi dolduğunda donanım kesmesi yoluyla zorla ara verilmesine işletim sistemleri dünyasında "preemptive" 
    işletim sistemleri denilmektedir. UNIX/Linux, Windows ve macOS sistemleri preemptive işletim sistemleridir. Artık pek çok 
    işlemci ailesi bu biçimdeki donanım kesmeleri oluşturan timer devrelerini CPU'nun içerisine de dahil etmiştir. Ancak x86 
    ve x64 sistemlerinde timer sistemi için genel olarak eskiye uyum bakımından Intel 8254 ve onun ileri versiyonları olan ve 
    ismine "PIT (Programmable Interval Timer)" denilen devreler aktif olarak kullanılmaktadır. Preemptive sistemlere bir 
    alternatif olarak "non-preemptive" ya da "cooperative multitask" da denilen sistemler bulunmaktadır. Bu sistemlerde bir 
    thread çalıştığında kendi rızası ile CPU'yu bırakır. Eğer CPU bırakmazsa diğer thread'ler çalışma fırsatı bulamazlar. 
    Bu patolojik duruma "diğer thread'lerin açlıktan ölmesi (starvation)" denilmektedir. Tabii bu sistemler artık çok kısıtı 
    kullanılmaktadır. PalmOS, eski Windows 3.X sistemleri böyleydi. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                34. Ders 04/03/2023 Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi sistemimizde birden fazla CPU (ya da çekirdek) varsa zaman paylaşımlı çalışma nasıl yürütülmektedir? Aslında değişen
    bir şey yoktur. Bu durum tıpkı yemek verilen bir kurumda yemeğin birden fazla koldan fazla verilmesi gibidir. İşletim 
    sisteminin zaman paylaşımlı çalışma için oluşturduğu kuyruğa işletim sistemleri dünyasında "çalıştırma kuyruğu (run queue)" 
    denilmektedir. Bu çalıştırma kuyruğu çok CPU söz konusu olduğunda her CPU için oluşturulmaktadır. Böylece her CPU yine zaman 
    paylaşımlı bir biçimde çalıştırma kuyruğundaki thread'leri çalıştırmaktadır. Yani yukarıda açıkladığımız temel prensip 
    değişmemektedir. Tabii burada işletim sisteminin bazı kararları da vermesi gerekir. Örneğin yeni bir thread (ya da proses) 
    yaratıldığında bunun hangi CPU'ya atanacağı gibi. Bazen işletim sistemi thread'i bir CPU'nun çalıştırma kuyruğuna atar. Ancak 
    diğer kuyruklar daha boş hale gelirse (çünkü o sırada çeşitli prosesler ve thread'ler sonlanmış olabilir) işletim sistemi 
    başka bir CPU'nun çalıştırma kuyruğundaki thread'i kuyruğu daha boş olan CPU'nun çalıştırma kuyruğuna atayabilir. (Biz bir 
    süper markette işin başında boş bir kasanın kuyruğuna girmiş olabiliriz. Sonra başka bir kasadaki kuyruk çok azalmış duruma 
    gelebilir. Biz de o kuyruğa geçmeyi tercih ederiz. İşletim sistemi de buna benzer davranmaktadır.) Linux işletim sistemi, 
    Windows sistemleri ve macOS sistemleri buna benzer bir çizelgeleme algoritması kullanmaktadır. Bir ara Linux O(1) çizelgelemesi 
    denilen bir yöntem denemiştir. Bu yöntemde işletim sistemi tek bir çalıştırma kuyruğu kullanıyordu. Hangi CPU'daki parçalı 
    çalışma süresi biterse bu kuyruktan seçme yapılıyordu.

    Çok CPU'lu zaman paylaşımlı çalışmada CPU sayısı arttırıldıkça total performans artacaktır. Çünkü CPU'lar için düzenlenen 
    çalıştırma kuyruklarında daha az thread bulunacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Zaman paylaşımlı çalışmada en önemli kavramlardan biri de "bloke olma (blocking)" denilen kavramdır. İşletim sistemi bir 
    thread'i CPU'ya atadığında o thread "dışsal bir olaya ilişkin bir işlem başlattığı zaman" uzun süre bekleme yapabileceğinden 
    dolayı işletim sistemi o thread'i çalıştırma kuyruğundan (run queue) çıkartır, "bekleme kuyruğu (wait queue)" denilen bir 
    kuyruğa ekler. Böylece zaten bekleyecek olan thread boşuna CPU zamanı harcamadan pasif bir biçimde bekletilmiş olur. Örneğin 
    bir thread klavyeden bir şey okumak istesin. İşletim sistemi thread'i bloke ederek çalıştırma kuyruğundan çıkartır ve onu 
    bekleme kuyruğuna alır. Artık o thread çalıştırma kuyruğunda olmadığından zaman paylaşımlı çalışmada işletim sistemi tarafından 
    ele alınmaz. Beklenen dışsal olay (örneğin klavye okuması) gerçekleştiğinde thread yeniden çalıştırma kuyruğuna yerleştirilir. 
    Böylece çalışma aynı prensiple devam ettirilir. İşletim sistemi bekleme kuyruklarındaki thread'lere ilişkin olayların 
    gerçekleştiğini birkaç biçimde anlayabilmektedir. Örneğin bir soket okuması yapıldığında eğer sokete henüz bilgi gelmemişse 
    işletim sistemi thread'i bloke eder. Sonra network kartına paket geldiğinde network kartı bir donanım kesmesi oluşturur. 
    İşletim sistemi devreye girer ve eğer gelen paket soketten okuma yapmak isteyen thread'e ilişkinse bu kesme kodunda (interrupt 
    handler) aynı zamanda o thread'i blokeden kurtarır. Ya da örneğin wait gibi bir işlemde işletim sistemi wait işlemini yapan 
    thread'i bloke ederek wait kuyruğuna yerleştirir. Alt proses bittiğinde _exit sistem fonksiyonunda bu wait kuyruklarına bu 
    sistem fonksiyonu bakar ve ilgili thread'in blokesini çözer. sleep gibi bir fonksiyonda ise işletim sistemi bekleme zamanını 
    kendisi hesaplamaktadır. İşletim sistemi bekleme zamanı dolunca thread'in blokesini çözer. Genel olarak işletim sistemleri 
    her olay için ayrı bir wait kuyruğu oluşturmaktadır. Örneğin aygıt sürücüler kendi wait kuyruklarını oluşturup bloke işlemlerini 
    kendileri yapmaktadır.

    Thread'in çalıştırma kuyruğundan çıkartılıp wait kuyruğuna alınması nasıl ve kimin tarafından yapılmaktadır? Böyle bir işlem
    user mode'da sıradan prosesler tarafından yapılamaz. Hemen her zaman kernel mode'da işletim sisteminin sistem fonksiyonları 
    tarafından ya da aygıt sürücüler tarafından yapılmaktadır. Yani thread'in bloke olması programın çalışması sırasında 
    çağrılan bir sistem fonksiyonu (ya da aygıt sürücü fonksiyonu) tarafından yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler "IO yoğun (IO bound)" ve "CPU yoğun (CPU bound)" olmak üzere ikiye ayrılmaktadır. IO yoğun thread'ler kendisine 
    verilen quanta süresini çok az kullanıp hemen bloke olan thread'lerdir. CPU yoğun thread'ler ise kendisine verilen quanta 
    süresini büyük ölçüde kullanan thread'lerdir. Örneğin bir döngü içerisinde sürekli hesap yapan bir thread CPU yoğun bir 
    thread'tir. Ancak aşağıdaki gibi bir thread IO yoğun thread'tir:

    for (;;) {
        scanf("%d", &val);
        if (val == 0)
            break;
        printf("%d\n", val);
    }

    Burada bu thread aslında çok az CPU zamanı harcamaktadır. Zamanının büyük kısmını uykuda geçirecektir. IO yoğun ve CPU yoğun 
    thread kavramı işletim sistemi için değil durumun insanlar tarafından anlaşılması için uydurulmuş kavramlardır. Yani işletim 
    sistemi bu biçimde thread'leri ayırmamaktadır. Bir sistemde yüzlerde IO yoğun thread olsa bile bu durum sistemi çok fazla 
    yormaz. Ancak çok sayıda CPU yoğun thread sistemi yavaşlatacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir programda iki nokta arasında geçen zaman sistemin o anki yüküne bağlı olarak değişebilmektedir. Örneğin sistemde çok 
    sayıda CPU yoğun thread varsa iki nokta arasındaki zaman eskisine göre uzayabilir.

    Aşağıdaki programı önce bir kez çalıştırınız sonra kabuk üzerinden komut satırının sonuna & koyarak çok sayıda çalıştırınız. 
    Programın döngüde harcadığı gerçek zaman uzayacaktır. Biz bu programda C'nin clock_gettime fonksiyonunu kullandık. Bu fonksiyon 
    nanosaniye temelinde çözünürlüğe sahiptir. clock isimli standart C fonksiyonu Linux sistemlerinde CPU zamanını verdiği için 
    bu deneyde kullanılamamaktadır. Ancak ileride zaman ölçme konusu ayrı başlık altında değerlendirilecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct timespec ts1, ts2;
    long long elapsed_time;

    if (clock_gettime(CLOCK_MONOTONIC, &ts1) == -1)
        exit_sys("clock_gettime");

    for (long i = 0; i < 1000000000; ++i)
        for (int k = 0; k < 30; ++k)
            ;
    if (clock_gettime(CLOCK_MONOTONIC, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed_time = (ts2.tv_sec * 1000000000LL + ts2.tv_nsec) - (ts1.tv_sec * 1000000000LL + ts1.tv_nsec);
    printf("Elapsed Nanosecond: %lld\n", elapsed_time);
        printf("Elapsed Second: %f\n", elapsed_time / 1000000000.);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında bir programın toplam çalışma zamanı "time" isimli kabuk komutuyla da ölçülebilmektedir. Komut basit bir biçimde 
    şöyle kullanılabilir:

    $ time ./sample

    time komutundan şöyle bir çıktı elde edilmektedir:

    real    1m38,360s
    user    0m18,597s
    sys    0m0,052s

    Görüldüğü gibi time komutu programın hep toplam çalışma zamanını hem de kernel ve user mode'da harcadığı zamanı rapor
    etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kabuk üzerinde satırın sonuna & yerleştirilirse bu durumda kabuk fork/exec yapar ancak wait ile bekleme yapmaz. Dolayısıyla 
    yeniden hemen kabuk promptuna düşülür. Bu komutta çalıştırılan programlara birer numara verilmektedir. "fg" komutuyla bu 
    numara verildiğinde ilgili program yeniden "foreground" hale getirilebilmektedir. Satırın sonuna & yerleştirilmesi yalnızca 
    wait yapılmamayı sağlamaz aynı zamanda bu işlemin henüz görmediğimiz sinyal konusuyla ilgili etkileri de vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Modern kapasiteli mikroişlemcilerde "sayfalama (paging)" denilen önemli bir mekanizma vardır. Örneğin Intel işlemcileri 
    bu sayfalama mekanizmasına 80386 modelleriyle birlikte sahip olmuştur. ARM Cortex A serisi ve Cortex M serisi işlemcilerin 
    de bu mekanizmaları vardır. Itanium, PowerPC gibi işlemcilerde de sayfalama mekanizması bulunmaktadır. Genellikle koruma 
    mekanizmasına sahip işlemciler sayfalama mekanizmasına da sahip olurlar. Ancak koruma mekanizmasına sahip olduğu halde 
    sayfalama mekanizmasına sahip olmayan işlemciler de vardır. Sayfalama mekanizması güçlü işlemcilerde bulunan bir mekanizmadır. 
    Genel olarak mikrodenetleyicilerde bu mekanizma yoktur. Örneğin ARM'ın Cortex M serisi mikrodenetleyicilerinde sayfalama 
    mekanizması bulunmamaktadır. Ayrıca işlemcilerdeki bu sayfalama mekanizması aktif ve pasif duruma getirilebilmektedir. 
    Yani işlemci sayfalama mekanizmasına sahip olduğu halde sistem programcısı bu mekanizmayı açmayabilir ve kullanmayabilir. 
    İşlemciler reset edildiğinde sayfalama mekanizması pasif durumdadır. İşletim sistemleri bazı ön hazırlıkları yaptıktan sonra
    bu mekanizmayı açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sayfalama mekanizmasında fiziksel RAM aynı zamanda "sayfa (page)" denilen ardışıl bloklara ayrılır. Sayfa uzunluğu sistemden
    sisteme hatta aynı işlemcide işlemcinin modundan moduna değişebilir. Ancak en tipik kullanılan sayfa uzunluğu 4096 (4K) 
    byte'tır. Gerçekten de bugün Linux, Windows ve macOS sistemleri 4K'lık sayfalar kullanmaktadır. Sayfalama mekanizması etkin 
    hale getirildiğinde işlemci RAM'deki her sayfaya bir sayfa numarası karşılık getirir. Örneğin ilk 4096 byte 0'ıncı sayfaya, 
    sonraki 4096 byte 1'inci sayfaya ilişkindir. Sayfalar bu biçimde ilk sayfa 0'dan başlatılarak ardışıl biçimde numaralandırılmaktadır. 
    Yani her byte aslında bir sayfa içerisinde bulunur.

    Bir program içerisinde kullanılan yani derleyicinin ürettiği adresler aslında gerçek fiziksel adresler değildir. Bu adreslere 
    "sanal adresler (virtual addresses)" denilmektedir. Derleyiciler kodları sanki geniş bir RAM'de program tek başına çalışacakmış 
    gibi üretmektedir. Örneğin 32 bit işlemcilerin kullanıldığı bir Linux sisteminde derleyici sanki program 4 GB'lik RAM'de tek başına 
    4 MB'den itibaren yüklenecekmiş gibi kod üretmektedir. Yani örneğin 32 bit Linux sistemlerinde (Windows ve macOS'te de böyle) 
    sanki derleyiciler program 4 GB bellekte 4 MB'den itibaren tek başlarına yüklenecekmiş gibi bir kod üretmektedir. Her program 
    derlendiğinde aynı biçimde kod üretilmektedir. Çünkü derleyicinin ürettiği bu adresler sanal adreslerdir. Pekiyi her program 
    aynı biçimde sanki RAM'in 4 MB'sinden başlanarak ardışıl bir biçimde yüklenecekmiş gibi bir kodu sahipse bu programlar nasıl 
    çalışmaktadır?

    İşte sayfalama mekanizmasına sahip olan CPU'lar aslında "sayfa tablosu (page table)" denilen bir taloya bakarak çalışırlar. 
    Sayfa tablosu sanal sayfa numaralarını fiziksel sayfa numaralarına eşleyen bir tablodur. Sayfa tablosunun görünümü aşağıdaki 
    gibidir:

    Sanal Sayfa No              Fiziksel Sayfa No
    ...                         ...
    4562                        17456
    4563                        18987
    4564                        12976
    ...                         ...

    Şimdi Intel işlemcisinin aşağıdaki gibi bir makine kodunu çalıştırdığını düşünelim:

    MOV EAX, [05C34782]

    Burada makine komutu bellekte 05C34782 numaralı adresten başlayan 4 byte erişmek istemektedir. İşlemci önce bu adres değerinin 
    kaçıncı sanal sayfaya karşılık geldiğini hesaplar. Bu hesap işlemci tarafından oldukça kolay bir biçimde yapılır. Sayı 12 kere 
    sağa ötelenirse başka bir deyişle sayının sağındaki 3 hex digit atılırsa bu sanal adresin kaçıncı sanal sayfaya karşılık geldiği 
    bulunabilir:

    05C34782 >> 12 = 05C34 (sanal sayfa no, decimal 23604)

    Artık işlemci sayfa tablosunda 0x5C34 yani desimal 23604 numaralı girişe bakar. Sayfa tablosunun ilgili kısmı şöyle olsun:

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (decimal/hex)
    ...                         ...
    23603 (5C33)                      47324 (B8DC)
    23604 (5C34)                      52689 (CDD1)
    23605 (5C35)                      29671 (73E7)
    ...                         ...

    Burada 23604 (5C34) numaralı sanal sayfa 52689 (CDD1) fiziksel sayfasına yönlendirilmiştir. Pekiyi işlemci hangi fiziksel adrese 
    erişecektir? İşte bizim sanal adresimiz 05C34782 idi. Bu adres iki kısma ayrıştırılabilir:

    05C24   Sanal sayfa no (hex)
    782     Sayfa offset'i (hex)

    Bu durumda işlemci aslında fiziksel RAM'de 52689 (CDD1)'uncu fiziksel sayfanın 1922 (782) byte'ına erişecektir. O zaman gerçek
    bellekteki erişim adresi 52689 (CDD1) * 4096 (1000) + 1922 (782) olacaktır.

    Burada özetle anlatılmak istenen şey şudur: İşlemci her bellek erişiminde erişilecek sanal adresi iki kısma ayırır: "Sanal Sayfa 
    No" ve "Sayfa Offset'i". Sonra sayfa tablosuna giderek sanal sayfa numarasına karşı gelen fiziksel sayfa numarasını elde eder. 
    O fiziksel sayfanın sayfa offet'i ile belirtilen byte'ına erişir. Örneğin şöyle bir fonksiyon çağırmış olalım:

    foo();

    Derleyicimiz de şöyle bir kod üretmiş olsun:

    CALL 06F14678  (hex)

    Burada 06F14678 foo fonksiyonunun sanal bellek adresidir. Derleyici bu adresi üretmiştir. Ancak program çalışırken işlemci bu adresi 
    ikiye ayırır (hex olarak konuşacağız):

    06F146      Sanal Sayfa No (hex)
    678         Sayfa Offset'i (hex)

    Sonra sayfa tablosuna gider ve 06F146 sayfasının hangi fiziksel sayfaya yönlendirildiğini tespit eder. Bu fiziksel sayfanın 
    hex olarak 7C45 olduğuna düşünelim. O zaman işlemcinin erişeceği fiziksel adres 7C45000 + 678 hex adresi olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Buraya kadar şunları anladık:

    - Derleyici 32 bit bir sistemde sanki program 4 GB'lik bir RAM'de tek başına 4 MB'ye yüklenerek çalıştırılacakmış gibi bir kod
    üretmektedir.

    - İşlemci kodu çalıştırırken her bellek erişiminde sayfa tablosuna bakıp aslında o sanal adresleri fiziksel adreslere dönüştürmektedir.

    Pekiyi sayfa tablosunu kim oluşturmaktadır? Sayfa tablosu işletim sistemi tarafından proses belleğe yüklenirken (exec fonksiyonları 
    tarafından) oluşturulmaktadır. İşletim sisteminin yükleyicisi (loader) programı 4K'lık parçalara ayırarak sanal sayfa numaraları 
    ardışıl ancak fiziksel sayfa numaraları ardışıl olmayacak biçimde fiziksel RAM'e yüklemektedir. Yani işletim sistemi fiziksel 
    RAM'deki boş sayfalara bakar. Programın 4K'lık kısımlarını bu fiziksel RAM'deki boş sayfalara yükler ve sayfa tablosunu buradan 
    hareketle oluşturur.

    Aslında sayfa tablosu bir tane değildir. İşletim sistemi her proses için ayrı bir sayfa tablosu oluşturmaktadır. CPU'lar sayfa 
    tablolarını belli bir yazmacın gösterdiği yerde ararlar (Örneğin Intel işlemcilerinde sayfa tablosu CR3 yazmacının gösterdiği 
    yerdedir.) İşletim sistemi thread'ler arası geçiş (context switch) yapıldığında çalışmasına ara verilen thread ile yeni 
    geçilen thread'in aynı prosesin thread'leri olup olmadığına bakar. Eğer yeni geçilen thread ile çalışmasına ara verilen thread aynı 
    prosese ilişkinse sayfa tablosu değiştirilmez. Çünkü aynı prosesin thread'leri aynı sanal bellek alanını kullanmaktadır. Ancak 
    yeni geçilen thread kesilen thread'le farklı proseslere ilişkinse işletim sistemi CPU'nun gördüğü sayfa tablosunu da değiştirmektedir. 
    Böylece aslında bir prosesin thread'i çalışırken CPU o prosesin sayfa tablosunu gösterir durumda olur.

    Her prosesin sayfa tablosu birbirinden farklı olduğu için iki farklı prosesteki sanal adresler aynı olsa bile bu adreslerin 
    fiziksel karşılıkları farklı olacaktır. Örneğin aynı programı iki kez çalıştıralım. Bu durumda bu iki proses için işletim 
    sistemi iki farklı sayfa tablosu kullanıp aynı sanal adresleri farklı fiziksel sayfalara yönlendirecektir. Böylece aslında 
    aynı sanal adreslere sahip olan programlar farklı fiziksel adreslere sahip olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Konu ile ilgili sorular ve kısa cevapları şöyledir:

    Soru: Bir programı debugger ile inceliyorum. Orada bir nesnenin adresini görüyorum. Bu adres nasıl bir adresitir?
    Yanıt: Bu adres sanal bir adrestir. İşlemci bu adrese erişmek istediğinde aslında sayfa tablosu yoluyla fiziksel olan başka 
    bir adrese erişecektir.

    Soru: İki farklı programda sanal 5FC120 adresi kullanılıyorsa bunlar fiziksel RAM'de aynı yeri mi gösteriyordur?
    Yanıt: Hayır, çünkü işletim sistemi her proses için farklı bir sayfa tablosu oluşturmaktadır. Bir thread çalışırken işlemci 
    o thread'e ilişkin prosesin sayfa tablosunu kullanıyor durumdadır. Dolayısıyla bu iki farklı proseste işletim sistemi sayfa 
    tablolarının ilgili sayfalarını aslında farklı fiziksel sayfalara yönlendirmiş durumdadır.

    Soru: 32 bit bir derleyicinin ürettiği kodun aslında sanki 4 GB belleğe tek başına 4 MB'den itibaren yüklenecekmiş gibi üretildiği 
    söylendi. Sanal bellek alanındaki bu 4 MB boşluğun anlamı nedir?

    Yanıt: Bunun çok özel bir anlamı yoktur. Bir kere NULL adres için en az bir sayfa gerekmektedir. Pek çok işletim sistemi
    güvenlik amacıyla ve bazı başka nedenlerden dolayı sanal bellek alanının belli bir bölümünü boş bırakmaktadır. Windows'ta da
    bu alan 4 MB'dir. Ancak programın minimal yüklenme adresi 64K'ya kadar düşürülebilmektedir.

    Soru: CPU sayfa tablosunun yerini nereden bilmektedir?
    Yanıt: CPU'lar sayfa tablosunu özel bir yazmacın gösterdiği yerde arayacak biçimde tasarlanmıştır. Dolayısıyla context switch 
    sırasında aslında işletim sistemi yazmacın değerini değiştirmektedir. Yani işletim sistemi aslında tüm proseslerin sayfa 
    tablolarını fiziksel RAM'da oluşturur. Context switch sırasında yalnızca sayfa tablosunun yerini belirten ilgili yazmacın 
    değerini değiştirir.

    Soru: Sayfalama mekanizması CPU'nun çalışmasını yavaşlatmaz mı?
    Yanıt: Teorik olarak sayfalama mekanizması CPU'nun çalışmasını yavaşlatabilir. Ancak bugünkü CPU'ların çalışma hızları zaten 
    bu sayfalama mekanizmasının aktif olduğu durumla belirlenmektedir. Dolayısıyla donanımsal olarak sayfalama mekanizması iyi 
    bir biçimde oluşturulduğu için buradaki hız kaybı önemsenecek ölçüde değildir. Ayrıca işlemciler sayfa tablosuna erişimi 
    azaltmak için zaten onun bazı bölümlerini kendi içlerindeki bir cache sisteminde tutabilmektedir. Ayrıca sayfa girişlerine 
    hızlı erişim için işlemciler TLB (Translation Lookaside Buffer) denilen bir cache mekanizması da oluşturmaktadır.

    Soru: Sayfalama mekanizmasına ne gerek vardır? 
    Yanı: Bu durum izleyen paragraflarda ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                35. Ders 05/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi her proses için ayrı bir sayfa tablosu oluşturduğuna göre ve bu sayfa tablosunda aynı sanal sayfa numaralarını 
    zaten farklı fiziksel sayfalara yönlendirdiğine göre aslında hiçbir proses diğerinin alanına erişemez. Yani proseslerin 
    birbirlerinin alanlarına erişmesi zaten sayfalama mekanizmasıyla engellenmiş olmaktadır. Bu duruma "sayfalama mekanizması 
    ile proseslerin fiziksel bellek alanlarının izole edilmesi" denilmektedir. Örneğin aşağıdaki gibi iki prosesin sayfa tablosu 
    söz konusu olsun:

    Proses-1

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (decimal/hex)
    ...                         ...
    23603 (5C33)                      47324 (B8DC)
    23604 (5C34)                      52689 (CDD1)
    23605 (5C35)                      29671 (73E7)
    ...                         ...

    Proses-2

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (decimal/hex)
    ...                         ...
    23603 (5C33)                      84523 (14A2b)
    23604 (5C34)                      62981 (F605)
    23605 (5C35)                      42398 (A59E)
    ...                         ...

    İki prosesin sayfa tablosunda Fiziksel Sayfa Numaraları birbirinden ayrıldığında zaten bu iki proses asla birbirlerinin 
    alanlarına erişemeyecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi 32 bit bir mimaride işletim sisteminin sayfa tablosu yukarıdaki şekillere göre ne kadar yer kaplar? 32 bit mimaride
    fiziksel RAM en fazla 4 GB olabilir. Proseslerin sanal bellek alanları da 4 GB'dir. O halde toplam sayfa sayısı 
    4GB/4K = 2^32/2^12 = 2^20 = 1 MB olur. Her sayfa tablosu girişi Intel mimarisinde 4 byte'tır. Dolayısıyla yukarıdaki 
    şekillere göre bir prosesin sayfa tablosu 4 MB yer kaplar. Bu alan sayfa tablosu için çok büyüktür. Bu nedenle işlemcileri 
    tasarlayanlar sayfa tablolarının kapladığı alanı küçültmek için sanal adresleri iki parçaya değil, üç ya da dört parçaya 
    ayırma yoluna gitmişlerdir. Gerçekten de örneğin Intel'in 32 bit mimarisinde bir sanal adres üç parçaya ayrılmaktadır. Bu 
    ayrıntı kursumuzun konusu dışındadır ve Derneğimizde "80x86 ve ARM Sembolik Makine Dilleri" kursunda ele alınmaktadır. 
    Biz bu kursumuzda çeşitli gösterimlerde sanal adresleri ikiye ayıracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda 32 bit sistemlere göre örnekler verdik. Pekiyi 64 bit sistemlerde durum nasıldır? 64 bit sistemlerde fiziksel 
    RAM'in teorik büyüklüğü 2^64 = 16 exabyte olmaktadır. Dolayısıyla prosesin sanal bellek alanı da bu kadar olacaktır. Burada 
    eğer sanal adres iki parçaya ayrılırsa sayfa tablolarının aşırı büyük yer kaplaması kaçınılmazdır. Bu nedenle 64 bit sistemlerde 
    genellikle işlemcileri tasarlayanlar sanal adresleri dört parçaya ayırmaktadır. Bu konu yine kursumuzun kapsamı dışındadır. 
    Ancak 64 bit sistemlerde değişen bir şey yoktur. Program yine çok geniş bir sanal belleğe sanki tek başına yüklenecekmiş 
    gibi derlenir. Yine işletim sistemi proses için sayfa tablosu oluşturarak sanal sayfa numaralarını gerçek fiziksel sayfa 
    numaralarına yönlendirir. Tabii pek çok işletim sistemi 16 exabyte sanal bellek alanı çok büyük olduğu için bunu kısıtlama 
    yoluna gitmektedir. Örneğin Linux yalnızca 256 TB alanı kullanmaktadır. Windows ise yalnızca 16 TB alan kullanır. Bu alanlar 
    bile bugün için çok büyüktür.

    Sayfa tablolarının gerçek organizasyonu için kurs dokümanlarında /doc/ebooks klasöründe Intel'in AMD'nin ve ARM işlemcilerinin 
    orijinal dokümanları bulundurulmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi sayfalama (paging) mekanizmasının ne faydası vardır? İşte sayfalama mekanizmasının iki önemli işlevi vardır:

    1) Sayfalama mekanizması programların fiziksel RAM'e ardışıl yüklenmesinin zorunluluğunu ortadan kaldırır. Böylece 
    "bölünme (fragmentation)" denilen olgunun olumsuz etkisini azaltır.

    2) Sayfalama mekanizması "sanal bellek (virtual memory)" denilen olgunun gerçekleştirimi için gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bölünme (fragmentation) bellek yönetimi konusunda önemli bir problemdir. Bir nesnenin belleğe yüklenmesi ardışıl bir biçimde 
    yapılırsa zamanla yükleme boşaltma işlemlerinin sonucunda bellekte çok sayıda küçük alan oluşmaktadır. Bu küçük alanlar ardışıl 
    olmadığı için genellikle bir işe yaramamaktadır. Küçük alanların toplamı oldukça büyük miktarlara varabilmekte ve toplam 
    belleğin önemli miktarını kaplayabilmektedir. Bu olguya "bölünme (fragmentation)" denilmektedir. Bölünmenin engellenmesi 
    için ardışıl yükleme zorunluluğunun ortadan kaldırılması gerekir. Bu durumda bellek bloklara ayrılır. Yüklenecek nesne bloklara 
    bölünerek ardışıl olmayacak biçimde boş bloklara atanır. Ancak nesnenin hangi parçasının hangi bloklarda olduğu da bir biçimde 
    kaydedilir. Bu teknik hem RAM yönetiminde hem de disk yönetiminde benzer biçimde kullanılmaktadır. Ancak bloklama yöntemiyle 
    bölünme ortadan kaldırılmaya çalışıldığında bu sefer başka bir problem ortaya çıkmaktadır. Nesnelerin son bloklarında 
    kullanılmayan alanlar kalabilmektedir. Bu da bir çeşit bölünmedir. Bu bölünme durumuna "içsel bölünme (internal fragmentation)" 
    denilmektedir. İçsel bölünmede yapılabilecek bir şey yoktur. Ancak içsel bölünmenin etkisi diğerine göre daha az olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sanal bellek (virtual memory) bir programın tamamının değil belli kısmının belleğe yüklenerek disk ile RAM arasında yer 
    değiştirmeli bir biçimde çalıştırılmasına yönelik bir mekanizmadır. Bu mekanizma sayesinde örneğin 100 MB'lık bir programın 
    başlangıçta yalnızca 64K'lık kısmı RAM'e yüklenebilir. Sonra program çalışmaya başlar. Çalışma sırasında programın bellekte 
    olmayan bir kısmına erişildiğinde işletim sistemi programın bellekte olmayan kısmını o anda diskten belleğe yükler ve çalışma 
    kesintisiz devam ettirilirir.

    Sanal bellek kullanımında yine fiziksel RAM sayfalara ayrılır. Her sayfaya bir numara verilir. İşletim sistemi RAM'in hangi 
    sayfasının hangi programın neresini tuttuğunu bir biçimde oluşturduğu veri yapılarıyla bilir duruma gelir. Bir programın RAM'de 
    olmayan bir sayfasının diskten RAM'e yüklenmesine "swap in" denilmektedir. Ancak zamanla RAM'deki tüm fiziksel sayfalar dolu 
    duruma gelebilir. Bu durumda işletim sistemi bir programın bir parçasını RAM'e çekebilmek için RAM'deki bir sayfayı da RAM'dan 
    atmak durumunda kalır. Bu işleme ise "swap out" denilmektedir. Tabii işletim sistemi hangi programın RAM'deki hangi sayfasının 
    boşaltılacağı konusunda iyi bir karar vermek durumundadır. İşletim sistemine göre "gelecekte kullanılma olasılığı en düşük olan 
    sayfanın" RAM'den atılması en iyi stratejidir.

    Bu durumda bir program çalışırken aslında sürekli bir biçimde disk ile RAM arasında yer değiştirmeler yapılmaktadır. Bu yer 
    değiştirmelere genel olarak işletim sistemi dünyasında "swap" işlemi denilmektedir. Şüphesiz swap işlemi yavaş bir işlemdir 
    ve toplam performans üzerinde en önemli zayıflatıcı etkilerden birini oluşturmaktadır. Swap işlemlerinin olumsuz etkisini 
    azaltmak için ilk akla gelen şey fiziksel RAM'i büyütmektir. Ancak fiziksel RAM'in büyütülmesi maliyet oluşturmaktadır. 
    Bugünkü SSD'ler hard disklere göre oldukça iyi performans göstermektedir. Dolayısıyla bilgisayarımızda hard disk yerine SSD 
    varsa swap işlemleri daha hızlı yürütülecektir. Şüphesiz en önemli unsur aslında sayfaların yer değiştirilmesi konusunda 
    uygulanan algoritmalardır. Bunlara "page replacement" algoritmaları denilmektedir. Tabii bugünkü işletim sistemleri 
    bilinen en iyi algoritmaları zaten kullanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemi programın RAM'de olmayan bir sayfasını yüklemek istediğinde RAM'den sayfa boşaltacağı zaman ya 
    boşaltılacak sayfa üzerinde daha önce yazma işlemleri (update) yapıldıysa ne olacaktır? İçeriği değiştirilmiş olan sayfanın 
    RAM'den atılırken mecburen diskte saklanması gerekir. İşte işletim sistemleri bu işlemler için diskte ismine "swap file" ya 
    da "page file" denilen dosyalar tutmaktadır. Değiştirilmiş olan sayfaları bu dosyalara yazmaktadır. Linux işletim sistemi 
    swap alanı olarak genellikle ayrı bir disk bölümünü kullanmaktadır. Ancak herhangi bir dosya da swap dosyası olarak 
    kullanılabilmektedir. Kullanılacak swap disk alanının ya da dosyalarının toplamı bazen önemli olabilir. Çünkü sistemin toplam 
    sanal bellek kapasitesi bu swap dosyalarıyla da ilgilidir. Linux sistemlerinde o andaki toplam swap alanları "/proc/swaps" 
    dosyasından elde edilebilir. Buradaki değer Kilo Byte cinsindendir. Ya da "swapon -s" komutuyla aynı bilgi elde edilebilir.

    Pekiyi sistemin kullandığı swap alanı dolarsa ne olur? İşte bu durumda sistemin sanal bellek limiti dolmuş kabul edilir. 
    Yapılacak şey sisteme yeni swap alanları eklemektir. Bunun Linux'ta nasıl yapılacağını ilgili kaynaklardan öğrenebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemi programı belleğe yüklerken baştan kaç sayfayı yüklemektedir? İşte buna "minimum working set" 
    denilmektedir. İşletim sistemleri genel olarak bir program için en az yüklenecebilecek sayfa sayısını belirlemiş durumdadır. 
    Böylece yüklenmiş her programın en azından "minimum working set" kadar sayfası RAM'de bulunmak zorundadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi sanal bellek mekanizması nasıl gerçekleştirilmektedir? İşte işlemciler sanal bellek mekanizmasını oluşturabilmek için özel 
    bir biçimde tasarlanmıştır. İşlemci ne zaman sanal adresi fiziksel adrese dönüştürmek için sayfa tablosuna başvursa, eğer sayfa tablosunda
    o sanal adrese bir fiziksel sayfa karşılık getirilmemişse ismine "page fault" denilen bir içsel kesme (interrupt) oluşturmaktadır. Örneğin:

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (decimal/hex)
    ...                         ...
    23603                       84523
    23604                       -
    23605                       42398
    23606                       -
    23607                       73245
    ...                         ...

    Burada Fiziksel Sayfa Numarasındaki "-" sembolleri o sanal sayfaya bir fiziksel sayfanın karşı getirilmediğini belirtmektedir. 
    Dolayısıyla örneğin işlemci 23604 numaralı, 23606 numaralı sanal sayfalar için dönüştürme yapmak istediğinde "page fault" oluşturacaktır. 
    İşte "page fault"" denilen kesme oluştuğunda işletim sisteminin kesme kodu devreye girer. Buna "page fault handler" denilmektedir. Bütün 
    swap mekanizması bu işletim sisteminin kesme kodu tarafından yapılmaktadır. İşletim sisteminin bu kesme kodu (page fault handler) önce
    hangi prosesin hangi sayfaya erişmek istediğini tespit eder. Sonra onun diskteki karşılığını bulur ve yer değiştirme işlemini yapar. 
    Tabii bu kesme kodu yer değiştirme işlemini yaptıktan sonra artık sayfa tablosunu da güncellemektedir. İşletim sisteminin kesme kodu bittiğinde
    kesmeye yol açan makine komutu yeniden çalıştırılarak akış devam ettirilmektedir. Bu komut yeniden çalıştırıldığında artık sayfa tablosu 
    düzeltildiği için page fault oluşmayacaktır. Bu durumda bir program çalıştırılmak istendiğinde işletim sistemi aslında programın az sayıda 
    sayfasını RAM'e yükleyip sayfa tablosunun o sayfalar dışındaki fiziksel sayfa numaralarını "-" haline getirir. Böylece yukarıda açıklanan mekanizma
    eşliğinde kesiksiz çalışma sağlanacaktır.

    Pekiyi ya erişilmek istenen sanal adres uydurma bir adresse ne olacaktır? İşte işletim sisteminin page fault kesme kodu (handler)
    öncelikle erişilmek istenen adresin o proses için legal bir adres olup olmadığına bakmaktadır. Eğer erişilmek istenen adres legal bir adres değilse
    artık hiç swap işlemi yapılmadan proses cezalandırılır ve sonlandırılır. Yani her türlü sanal adresin diskte bir karşılığı yoktur. 
    Biz bir göstericiye rastgele bir adres yerleştirip oraya erişmek istesek aslında proses bu page fault kesme kodu tarafından 
    sonlandırılmaktadır.

    O halde sanal bellek mekanizması tipik olarak işlemci ve işletim sistemi tarafından olarak şöyle gerçekleştirilmektedir:

    1) Proses bir sanal adrese erişmeye çalışır
    2) İşlemci sanal adresi parçalarına ayırır ve sayfa tablosuna başvurularak
    3) Sayfa tablosunda ilgili sayfaya bir fiziksel sayfa karşı getirilmişse sorun oluşmaz çalışma normal olarak devam eder. 
    Ancak sanal sayfaya bir fiziksel adres karşı getirilmemişse (şekildee onu "-" ile gösterdik) bu durumda işlemci "page fault" denilen
    içsel kesmeyi oluşturur.
    4) Page fault kesmesi için kesme kodunu işletim sistemini yazanlar bulundurmuştur. Bu kod önce erişilmek istenen adresin geçerli 
    bir adres olup olmadığına bakar. Eğer erişilmek istenen adres geçerli bir adres değilse proses sonlandırılır. Eğer geçerli bir adresse
    page fault kesme kodu "swap mekanizması" ile programın o kısmını RAM'e yükler, sayfa tablosunu günceller ve kesme kodundan çıkar. 
    Artık işlemci fault oluşturan makine komutuyla çalışmasına devam eder. Ancak sayfa tablosu düzeltildiği için bu kez fault oluşturmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sisteminin "bellek yönetimi (memory management)" kısmını yazanlar hangi bilgileri tutmak zorundadır? 
    İşte işletim sistemleri tipik olarak bu mekanizma için şu bilgileri kernel alanı içerisinde oluşturmak zorundadır:

    1) Tüm fiziksel RAM'deki tüm sayfaların "free" olup olmadığına ilişkin tablo
    2) Bir fiziksel sayfanın free değilse hangi proses tarafından kullanıldığına ilişkin bilgi
    3) Swap dosyalarının yerleri ve organizasyonu
    4) Hani proseslerin hangi sayfalarının o anda fiziksel RAM'de hangi fiziksel sayfalarda bulunduğu
    5) Diğer başka bilgiler

    Bellek yönetimi (memory management) bir işletim sisteminin en önemli ve en zor yazılan alt sistemlerden biridir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi sanal bellek toplamda bize ne sağlamaktadır? Şüphesiz sanal bellek mekanizmasının en önemli faydası RAM yeterli olmasa bile
    çok sayıda büyük programın aynı anda çalışır durumda tutulabilmesidir. Bizim elimizde 8 GB RAM olsa bile biz onlarca büyük programı 
    çalışır durumda tutabiliriz. Ancak yukarıda da belirtildiği gibi işletim sistemi bir swap alanı bulundurmaktadır. Eğer bu swap alanı 
    dolarsa başka bir limit nedeniyle "out of memory" durumu oluşabilmektedir. Bu nedenle eğer programlar çok fazla bellek kullanıyorsa
    bu swap alanlarının büyütülmesi de gerekebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sayfalama ve sanal bellek mekanizmasında işletim sistemi de o anda sanal bellek alanı içerisinde bulunmak zorundadır. Pekiyi 
    işletim sisteminin kodları sayfa tablosunda sanal belleğin neresindedir? İşte genellikle işletim sistemi tasarımcıları
    sanal bellek alanını "user space" ve "kernel space" olarak ikiye ayırmaktadır. "user space" genellikle sanal bellek alanının düşük 
    anlamlı kısmında, kernel space ise yüksek anlamlı kısmında bulundurulur. Örneğin 32 bit Linux sistemleri 4 GB'lik sanal bellek alanını 
    şöyle ayırmıştır:

    32 Bit Linux Proses Sanal Bellek Alanı

    3 GB        User Space
    1 GB        Kernel Space

    Bu durumda 32 bit Linux sistemlerinde bir programın kullanabileceği maksimum sanal bellek 3 GB'dir. (Windows ta 2 GB user space için, 
    2 GB kernel space için kullanılmıştır.) 64 bit Linux sistemlerinde ise prosesin sanal bellek alanı şöyle organize edilmiştir:

    64 Bit Linux Proses Sanal Bellek Alanı

    128 TB        User Space
    128 TB        Kernel Space

    Görüldüğü gibi aslında teorik sanal bellek 16 exabyte olduğu halde 64 bit Linux sistemleri yalnızca 256 TB sanal belleğe
    izin vermektedir.

    Proseslerin sayfa tablolarında kernel alanınının içeriği hep aynıdır. Yani context switch yapılsa bile kernel kodları hep aynı 
    sanal adreslerde bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz bir program içerisinde yüksek miktarda dinamik tahsisat yaptığımızda ne olur? Linux sistemlerinde malloc fonksiyonu
    brk ya da sbrk denilen sistem fonksiyonunu çağırabilmektedir. Ancak arka planda sanal bellek bakımından şunlar gerçekleşir:

    - İşletim sistemi malloc ile tahsis edilen alanı sayfa tablosunda oluşturur. Oluştururken de tahsis edilen alanın 
    toplam swap alanından küçük olduğunu garanti etmeye çalışır. Çünkü malloc ile tahsis edilen alan eninde sonunda swap dosyası 
    içerisinde bulundurulacaktır.

    - İşletim sistemi swap dosyasının boyutu yeterliyse tahsisatı kabul etmektedir. Ancak sistemden sisteme değişebilecek biçimde
    bu sırada swap dosyasında tahsisat yapılabilir ya da yapılmayabilir. Eğer swap dosyasında o anda tahsisat yapılırsa bu durumda 
    swap alanı ciddi biçimde azalacak ve belki de başka proses artık aynı tahsisatı yapamayacaktır. Ancak işletim sistemi swap 
    dosyasında tahsisatı henüz yapmayabilir. Bu işlemi dinamik alan kullanıldığında yapabilir. Genellikle Linux sistemleri bu 
    yola başvurmaktadır. Literatürde dinamik alan için swap dosyasında baştan yer ayrılmasına "alanın commit edilmesi" denilmektedir.

    Aşağıdaki 3 GB RAM olan 2 GB swap alanına sahip 64 bit Linux sisteminde 5 GB alan dinamik olarak tahsis edilmek istenmiştir. 
    Burada tahsisat başarılı gibi gözükse de tahsis edilen alan kullanılırken swap alanı yetersizliğinden dolayı sinyal oluşacak 
    ve proses sonlandırılacaktır.

    O halde 64 bit Linux sistemlerinde biz teorik olarak her biri 128 TB olan onlarca programı bir arada çalıştırabiliriz. Ancak 
    bunun için swap alanımızın da yeterli büyüklükte diskte oluşturulmuş olması gerekir. Swap alanının yetersizliği durumunda 
    bir sinyal ile proses sonlandırılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *pc;

    pc = (char *)malloc(5000000000);
    if (pc == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    for (long i = 0; i < 5000000000; ++i)
        pc[i] = 0;

    printf("ok\n");

    getchar();

    free(pc);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                36. Ders 11/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi işletim sistemi sayfa tabloları yoluyla proseslerin bellek alanlarını tam olarak birbirinden izole
    etmektedir. Dolayısıyla bir proses istese de başka bir prosesin bellek alanına erişememektedir. Ancak ismine "paylaşılan bellek alanları 
    (shared memory)" denilen bir teknik ile işletim sistemi farklı proseslerin aynı fiziksel sayfaya erişimini sağlayabilmektedir. 
    Şöyle ki: İşletim sistemi iki prosesin sayfa tablosunda farklı sanal sayfaları aynı fiziksel sayfaya eşlerse bu iki proses farklı sanal adreslerle
    aslında aynı fiziksel sayfayı görüyor durumda olur. Örneğin:

    Proses-1 Sayfa Tablosu

    Sanal Sayfa Numarası            Fiziksel Sayfa Numarası
    ...                             ...
    987                             1245
    988                             1356
    999                             1412
    ...                             ...

    Proses-2 Sayfa Tablosu

    Sanal Sayfa Numarası            Fiziksel Sayfa Numarası
    ...                             ...
    356                             7645
    357                             1356
    358                             489
    ...                             ...

    Görüldüğü gibi birinci prosesin 988'inci sanal sayfa numarası ikinci prosesin 357'nci sanal sayfa numarasıyla aynı fiziksel 
    adrese yönlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında sayfa tablolarında her bir sayfanın da ayrıca bir "özellik bilgisi (attribute)" vardır. Yani sayfa tablolarının formatı
    daha gerçekçi bir biçimde şöyledir:

    Sanal Sayfa No          Fiziksel Sayfa No       Sayfa özelliği
    ...                     ...                     ...

    Sayfa özelliği o fiziksel sayfanın "read only" mi, "read/write" mı "execute" özelliğine sahip mi olduğunu belirtmektedir. 
    Ayrıca bir fiziksel sayfa "user mode" ya da "kernel mode" sayfa olarak belirlenebilmektedir. İşletim sistemi prosesin tüm fiziksel 
    sayfalarını "user mode" olarak ancak kernel'ın tüm sayfalarını "kernel mode" olarak ayarlamaktadır. User mode bir proses yalnızca 
    user mode sayfalara erişebilmektedir. Kernel mode sayfalara erişememektedir. Eğer user mode bir proses kernel mode sayfaya erişmek 
    isterse işlemci bir "içsel kesme (fault)" oluşturmakta ve işletim sistemi devreye girerek prosesi sonlandırmaktadır. Ancak kernel mode 
    bir proses hem kernel mode sayfalara hem de user mode sayfalara erişebilmektedir. Bizim prosesimiz user mode'da çalışmaktadır. User mode 
    prosesler bir user mode sayfaya erişirken işlemci erişim biçimine bakar ve duruma göre yine içsel kesme oluşturur. User mode bir proses
    user mode ancak read-only bir sayfaya yazma yaparsa içsel kesme (page fault) oluşturulmaktadır. Bu durumda işletim sistemi prosesi cezalandırarak
    sonlandırma yoluna gitmektedir. Ayrıca pek çok işlemci ailesinde bir kodun bir fiziksel sayfada çalışabilmesi için o kodun "execute" 
    özelliğine sahip bir fiziksel sayfada bulunması gerekmektedir. Bu mekanizma altında örneğin bir proses "execute" olmayan bir fiziksel 
    sayfadaki bir fonksiyonu çağırmak isterse yine işlemci içsel kesme (page fault) oluşturmaktadır. Örneğin C derleyicileri string'leri
    ELF formatında özel bir bölüme (section) yerleştirirler ve işletim sisteminin yükleyicisi de (UNIX/Linux sistemlerindeki exec fonksiyonları)
    bu sayfaları sayfa tablosunda oluştururken bu sayfaların özelliklerini "read-only" yaparlar. Böylece biz bir string'i değiştirmek istediğimizde
    koruma mekanizması yüzünden prosesimiz sonlandırılır. Zaten C'de string'lerin güncellenmesi "tanımsız davranış (undefined behavior)" olarak 
    belirtilmektedir. Benzer biçimde derleyiciler genellikle global const nesneleri de yine "read-only" bölümlere (sections) yerleştirmektedir. 
    (Ancak yerel const nesneler stack'te olduğu için read-only yerleştirilememektedir.) 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aynı programın ikinci kez çalıştırıldığını düşünelim. Bu durumda her şeyi aynı olan iki program çalışıyor durumda olacaktır.
    Ancak bu iki proses birbirinden bağımsız olduğuna göre bu iki prosesin farklı sayfa tabloları vardır ve aslında bu iki prosesin
    bellek alanı tamamen izole edilmelidir. İşte işletim sistemleri bu tür durumlarda "copy on write" denilen bir mekanizma uygulamaktadır. 
    Bu mekanizmada işletim sistemi bir program ikinci kez çalıştırıldığında sayfa tablosunda önceki çalıştırma ile aynı fiziksel 
    sayfaları eşler. Ancak bu sayfaları "read-only" biçimde işaretler. Proseslerden biri bu sayfaya yazma yaptığında içsel kesme (page fault)
    oluşur, işletim sistemi devreye girer tam yazma yapıldığı sırada o sayfanın bir kopyasını oluşturup iki prosesin fiziksel sayfalarını birbirinden 
    ayırır. Böylece iki proses baştan aynı fiziksel sayfaları paylaşırken daha sonra bu fiziksel sayfalar birbirinden ayrıştırılmaktadır. 
    Bu mekanizma sayesinde aslında hiç yazma yapılmayan fiziksel sayfaların boşuna bir kopyası oluşturulmamış olur. Örneğin ikinci çalıştırılan
    programın makine kodlarının bulunduğu sayfalar aslında hiç güncellenmemektedir. Bu durumda iki kopyanın aynı fiziksel sayfayı görmesinde
    bir sakınca yoktur. İşletim sistemleri dinamik kütüphanelerde de benzer tekniği kullanmaktadır. Bir dinamik kütüphane iki farklı 
    proses tarafından kullanıldığında mümkün olduğunca bu proseslerin sayfa tabloları aynı fiziksel sayfaları gösterir. Ancak proseslerden biri
    dinamik kütüphanedeki bir sayfada değişiklik yaparsa o noktada bu sayfanın kopyasından oluşturulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri dünyasında bir prosesin başka bir prosese bilgi göndermesi ve başka bir prosesten bilgi almasına 
    "prosesler arası haberleşme (interprocess communication - IPC)" denilmektedir. Burada bilgi gönderip almadan kastedilen şey 
    bir grup byte'ın gönderilip alınmasıdır. Prosesler arası haberleşme önemli bir konudur. Çünkü sayfa tabloları yoluyla 
    birbirinden izole edilmiş proseslerin başka yöntemlerle birbirleriyle haberleşmesi gerekebilmektedir. Bir program başka 
    bir programa bir şeyler gönderebilir, o program da bunları işleyebilir. Prosesler arası haberleşmenin en bariz örneği 
    "client-server" sistemlerdir. Bu sistemlerde client program server programa bir istek gönderir. Server program da bu isteği 
    yerine getirip sonuçları client programa iletir. Client-server tarzda haberleşmenin sağlanabilmesi için prosesler arası 
    haberleşme denilen mekanizmanın kullanılması gerekir. Benzer biçimde "dağıtık sistemlerde (distributed systems)" de esas 
    olarak prosesler arası haberleşme mekanizmaları kullanılmaktadır.

    Prosesler arası haberleşme mekanizmaları iki bölümde ele alınıp incelenmektedir:

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Aynı makinenin prosesleri arasında haberleşme işletim sisteminin sağladığı özel yöntemlerle gerçekleştirilmektedir. Farklı 
    makinelerin prosesleri arasında haberleşme için ortak uyulması gereken bazı kuralların belirlenmiş olması gerekir. Bu ortak 
    kurallara "protokol (protocol)" denilmektedir. Farklı makinelerin prosesleri arasında haberleşme için çeşitli protokol 
    aileleri oluşturulmuştur. Ancak bunlardan en yaygın kullanılanı "IP (Internet Protocol)" isimli protokol ailesidir. Biz 
    kursumuzda önce aynı makinenin prosesleri arasındaki haberleşme yöntemlerini inceleyeceğiz daha sonra farklı makinelerin 
    prosesleri arasında haberleşme yöntemleri üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aynı makinenin prosesleri arasında haberleşme için çeşitli işletim sistemlerinde birbirine benzer yöntemler geliştirilmiştir. 
    Örneğin "boru (pipe)" haberleşmesi yöntemi UNIX/Linux sistemleriyle Windows sistemleri arasında benzer biçimde yürütülür. 
    Paylaşılan bellek alanları (shared memory)" denilen haberleşme yöntemine yine benzer biçimde uygulanmaktadır. Ancak bazı 
    işletim sistemlerinde o sisteme özgü özel yöntemler de olabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Prosesler arası haberleşme mekanizmasının iki yönü vardır. Birincisi iki prosesin haberleşeceği bir ortamın oluşturulmasıdır.
    İkincisi ise bu ortamın senkronize bir biçimde kullanılmasıdır. Yani prosesler arası haberleşme bir senkronizasyon sağlanarak 
    gerçekleştirilmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    En yaygın kullanılan prosesler arası haberleşme yöntemi "boru (pipe)" haberleşmesi denilen yöntemdir. Boru haberleşmesi 
    hem bir ortam sunarken hem de senkronizasyonu kendi içerisinde sağlamaktadır. Bu nedenle boru haberleşmesi kolay kullanılabilen 
    bir IPC yöntemidir. Boru haberleşmeleri "isimsiz boru haberleşmeleri" ve "isimli boru haberleşmeleri" olmak üzere ikiye 
    ayrılmaktadır. İsimsiz boru haberleşmelerine İngilizce "unnamed pipe" ya da "anonymous pipe", isimli boru haberleşmelerine 
    ise "named pipe" ya da "fifo" denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Boru aslında FIFO tarzında çalışan bir kuyruk sistemidir. Bir proses boruya yazma yapar, diğeri de borundan yazılanları 
    okur. UNIX/Linux sistemlerinde borular birer dosya gibi ele alınmaktadır. Dolayısıyla boruya yazma işlemi "write" fonksiyonu 
    ile borudan okuma işlemi ise "read" fonksiyonu ile yapılmaktadır. Yazan taraf boruya bir grup byte'ı yazdığında okuyan taraf 
    bunları aynı sırada okur.

    Boruların belli bir uzunlukları vardır. Eskiden BSD ve Linux sistemlerinde boru uzunlukları 4096 byte (bir sayfa) büyüklüğündeydi.
    Linux daha sonra default boru uzunluğunu 65536'ya (16 sayfaya) yükseltmiştir.

    UNIX/Linux sistemlerinde borular tek yönlüdür. Bu nedenle proseslerden biri boruya yazma yaparken diğeri borudan okuma yapar. 
    (Halbuki örneğin Windows sistemlerinde borular çift yönlüdür.) Borunun tek yönlü olması demek iki prosesin de yazdıklarının 
    aynı boruya yazılması demektir. P1 prosesi boruya yazma yapıp yine P1 prosesi borudan okuma yaparsa kendi yazdığını okur. 
    Bunun da bir anlamı olmaz. Halbuki çift yönlü borularda borudan hem okuma hem yazma yapılabilmektedir. Borudan okuma 
    yapıldığında karşı tarafın yazdığı okunur. Ancak UNIX/Linux sistemlerindeki yukarıda da belirttiğimiz gibi borular tek 
    yönlüdür. Dolayısıyla haberleşmede bir taraf yazma yaparken diğer taraf okuma yapmalıdır. Eğer borularla karşılıklı okuma 
    yazma yapılmak isteniyorsa iki boru kullanılmalıdır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Borulara write POSIX fonksiyonu ile yazma yapılırken yazılmak istenen byte kadar boruda yer yoksa write işlemi blokeye 
    yol açar ve boruda yazılmak istenen miktar kadar boş alan oluşana kadar ilgili thread blokede bekletilir. Örneğin biz boruya
    50 byte yazmak isteyelim. Eğer boruda en az 50 byte'lık boş yer varsa biz bloke olmadan bu işlemi yaparız ve write fonksiyonu 
    50 değeri ile geri döner. Ancak boruda örneğin 40 byte boş yer varsa bu durumda write fonksiyonu 50 byte'lık yer açılana 
    kadar blokede bekler. 50 byte'lık yer açıldığında bu 50 byte'ı boruya yazar ve 50 değeri ile geri döner. Böylece bir proses 
    sürekli boruya yazma yapar ancak karşı taraf borudan okuma yapmazsa boru dolar en sonunda write fonksiyonu blokede bekler. 
    Karşı taraf borudan okuma yaptığında boruda yer açılmaktadır.

    Borulara yazma işlemi atomik düzeyde yapılmaktadır. Atomik yazma demekle sanki yazma işleminin tek hamlede araya hiçbir akış 
    girmeden yazılması kastedilmektedir. Farklı prosesler aynı boruya aynı anda yazma yapsalar bile bu yazılanlar iç içe geçmez. 
    Ancak borularda PIPE_BUF denilen bir sembolik sabit değeri vardır. Eğer iki prosesten en az biri bu PIPE_BUF değerinden 
    daha yüksek miktarda byte'ı boruya yazmak isterse bu durumda iç içe geçme oluşabilir. Yani birden fazla prosesin aynı boruya 
    aynı zamanda yazma yapması durumunda iç içe geçmenin olmaması için yazılanların PIPE_BUF sembolik sabitinden daha küçük 
    ya da ona eşit olması gerekir. PIPE_BUF pek çok sistemde (Linux'ta da böyle) 4096 değerindedir. Burada önemli bir nokta şudur: 
    Biz PIPE_BUF değerinden daha fazla byte'ı boruya yazmak istediğimizde yine tüm bilgi boruya yazılana kadar bloke oluşmaktadır. 
    Ancak bu durumda iç içe geçmeme garanti edilememektedir. Ayrıca proses borunun uzunluğundan fazla bilgiyi boruya yazmaya 
    çalışabilir. Bu durumda yine tüm bilgi boruya yazılana kadar bloke oluşmaktadır.

    Normal olarak borulara yazma yaparken write fonksiyonu tüm byte'lar yazılana kadar bloke oluşturduğuna göre write fonksiyonun 
    yazılmak istenen byte sayısı ile geri dönmesi beklenir. Gerçekten de hemen her zaman böyle olmaktadır. Ancak write fonksiyonu 
    ile boruya yazma yapılırken bir sinyal oluşursa bu durumda POSIX standartları kısmi yazma yapılabileceğini söylüyorsa da 
    Linux sistemlerinde bu durumda boruya hiçbir şey yazmadan write fonksiyonu başarısız olur ve -1 değeri ile geri döner. errno 
    değişkeni de EINTR değeriyle set edilir. Linux sistemlerinde yine write fonksiyonu boruda yeterince yer yoksa ve blokede 
    bekliyorsa sinyal oluştuğunda boruya bir şey yazmadan -1 ile geri dönmektedir. (Yani blokeli boru yazımlarında POSIX 
    standartlarına göre kısmi yazım söz konusu olabilirse de Linux sistemlerinde "kısmi yazım (partial write)" işlemi 
    yapılmamaktadır.)

    Boruya 0 byte yazılmak istenirse bu durum POSIX standartlarında "unspecified" bırakılmıştır. Ancak pek çok UNIX türevi 
    sistem (Linux'ta da böyle) 0 byte yazma durumunda boruya bir şey yazmamakta basit bazı kontroller yapıp write fonksiyonunu 
    sonlanmaktadır. Eğer bu kontrollerde bir sorun yoksa write fonksiyonu 0 ile geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    read fonksiyonu ile borudan okuma yapılırken read fonksiyonu eğer boru tamamen boşsa en az 1 byte boruda olana kadar blokeye
    yol açar. Ancak boruda en az 1 byte bilgi varsa read okuyabildiği kadar byte'ı okur, blokeye yol açmadan hemen okuyabildiği 
    byte sayısı ile geri döner. Yani read tüm byte'lar okunana kadar değil, en az bir byte okunana kadar beklemeye yol açmaktadır. 
    Bu bakımdan write gibi davranmamaktadır. Örneğin biz borudan 50 byte okumak isteyelim. Ancak boruda 10 byte bulunuyor olsun. 
    read fonksiyonu 50 byte okunana kadar beklemez. O 10 byte'ı okur, bu 10 değeri ile geri döner. Ancak boruda hiç bilgi yoksa 
    read blokede en az 1 byte boruda olana kadar blokede bekleyecektir. Örneğin biz borudan 50 byte okumak isteyelim. Ancak 
    boruda hiç bilgi olmasın. read fonksiyonu blokede bekler. O sırada bir proses boruya 10 byte yazmış olsun. Şimdi read bu 
    10 byte'ı alarak işlemini sonlandırır ve 10 değeri ile geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi boru haberleşmesi nasıl sonlandırılmaktadır? Boruyu kesinlikle önce yazan tarafın kapatması gerekir. Bu durumda 
    okuyan taraf önce boruda kalanları okur. Artık boruda okunacak bir şey kalmamışsa ve yazan taraf da boruyu kapatmışsa 
    read fonksiyonu 0 değeri ile geri döner. Yukarıda da belirttiğimiz gibi normalde read fonksiyonu boruda hiç bilgi yoksa 
    blokede beklemektedir. Ancak eğer boruya yazma potansiyelinde hiçbir betimleyici kalmadıysa bu durumda read fonksiyonu 
    bloke olmadan 0 özel değeri ile geri döner. O halde sonlandırma şöyle yapılmalıdır: Önce yazan taraf boruyu kapatır. Sonra 
    okuyan taraf boruda kalanları okur ve read fonksiyonu 0 ile geri döndüğünde okuyan taraf da boruyu kapatır.

    Boru haberleşmesinde eğer boruyu yanlış bir biçimde önce okuyan taraf kapatırsa yazan taraf boruya yazma yaptığında SIGPIPE 
    isimli bir sinyal oluşmaktadır. Bu sinyal de prosesin sonlanmasına yol açacaktır. Yani okuma tarafı kapatılmış bir boruya 
    yazma yapmak normal bir durum değildir. Ancak yazma tarafı kapatılmış bir borudan okuma yapmaya çalışmak normal bir durumdur. 
    Yukarıda da belirttiğimiz gibi bu durumda read boruda bir şey kalmadıysa 0 ile geri dönecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İsimsiz boru haberleşmesi üst ve alt prosesler arasında yapılabilen bir haberleşmedir. İsimsiz boru haberleşmesi tipik 
    olarak şu aşamalardan geçilerek gerçekleştirilir:

    1) Üst proses henüz fork ile alt prosesi yaratmadan önce pipe isimli POSIX fonksiyonu ile isimsiz boruyu yaratmalıdır. 
    pipe fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int pipe(int pipefd[2]);

    pipe fonksiyonu int türden bir dizinin başlangıç adresini parametre olarak alır. Prototipteki dekleratör bir gösterici 
    dekleratörüdür. pipe fonksiyonu boruyu yaratır. Borudan okuma yapmak ve boruya yazma yapmak için iki dosya betimleyicisi oluşturur. 
    O betimleyicilerin numaralarını da bizim fonksiyona geçirdiğimiz iki elemanlı int diziye yerleştirir. Dizinin ilk elemanına 
    borudan okuma yapmak için kullanılacak betimleyiciyi, ikinci elemanına ise boruya yazma yapmak için kullanılacak betimleyiciyi 
    yerleştirmektedir. Tabii bu betimleyiciler dosya betimleyici tablosunda tahsis edilmiş durumdadır. Bu betimleyicilerin gösterdiği 
    dosya nesneleri boruya erişmek için gereken bilgileri tutmaktadır. Bize verilen dizinin ilk elemanına yerleştirilen betimleyici 
    read-only, dizinin ikinci elemanına yerleştirilen betimleyici ise write-only bir betimleyicidir. Yani biz ilk betimleyici 
    ile yalnızca read işlemi ikinci betimleyici ile yalnızca write işlemi yapabiliriz. pipe fonksiyonunun dosya betimleyici 
    tablosundaki en düşük numaralı boş betimleyicileri vereceği POSIX standartlarında garanti edilmiştir. Ancak pipe fonksiyonun 
    verdiği iki betimleyicinin hangisinin düşük numaralı betimleyici olacağının bir garantisi yoktur.

    2) Boru yaratıldıktan sonra üst prosesin fork işlemi ile alt prosesi yaratması gerekir. fork işlemiyle birlikte üst prosesteki
    tüm betimleyiciler alt proseste de aynı değerlerle aynı dosya nesnelerini gösterir biçimde oluşturulacaktır. Yani artık 
    üst ve alt prosesler aynı numaralı betimleyicilerle boruya erişebilir durumda olur.

    3) Artık üst ve alt prosesler arasında haberleşme için bir karar verilmelidir. Kim yazacak kim okuyacaktır? Bundan sonra 
    boruya yazma ve okuma potansiyelinde olan birer betimleyici bırakılmalıdır. Yani yazan taraf okuma betimleyicisini okuyan
    taraf yazma betimleyicisini kapatmalıdır.

    4) Artık okuma ve yazma işlemleri read ve write fonksiyonlarıyla gerçekleştirilebilir.

    5) Haberleşmeyi sonlandırmak için yazan taraf boruyu kapatır. Okuyan taraf önce boruda kalanları okur, sonra read fonksiyonu
    0 ile geri döner. Böylece okuyan taraf da boruyu kapatır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                37. Ders 12/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda üst proses boruya yazma yapmakta alt proses de borudan okuma yapmaktadır. Alt proses üst prosesin yazdığı 
    int sayıları okumaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    int pid;
    int fdpipe[2];
    int result;

    if (pipe(fdpipe) == -1)
        exit_sys("pipe");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        /* parent writes */

        close(fdpipe[0]);

        for (int i = 0; i < 1000000; ++i)
            if (write(fdpipe[1], &i, sizeof(int)) == -1)
                exit_sys("write");

        close(fdpipe[1]);

        if (wait(NULL) == -1)
            exit_sys("wait");
    }
    else {
        /* child reads */
        int val;

        close(fdpipe[1]);

        while ((result = read(fdpipe[0], &val, sizeof(int))) > 0) {
            printf("%d ", val);
            fflush(stdout);
        }
        if (result == -1)
            exit_sys("read");

        close(fdpipe[0]);

        printf("\n");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi isimsiz boru haberleşmesinde neden okuyan taraf yazma betimleyicisini, yazan taraf da okuma betimleyicisini kapatmaktadır?
    İşte read fonksiyonunun 0 ile geri dönmesi için boruya yazma potansiyelinde olan tek bir betimleyicinin bulunuyor olması gerekir. 
    Eğer okuyan taraf yazma betimleyicisini kapatmazsa yazan taraf yazma betimleyicisini kapatsa bile boruya hala yazma potansiyelinde 
    olan bir betimleyici kaldığı için read fonksiyonu 0 ile geri dönmeyecektir. Bu durumda haberleşmenin sonlandırılması sorunlu 
    hale gelecektir. Yazan tarafın okuma betimleyicisini kapatmasının diğeri gibi kritik bir önemi yoktur. Ancak prensip olarak 
    kullanılmayan betimleyicilerin kapatılması iyi bir tekniktir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Üst ve alt prosesler arasında haberleşme yapmak kişilere biraz tuhaf gelebilmektedir. Çünkü fork işleminden sonra zaten 
    her iki kod da programı yazan kişi tarafından yazılmış olmaktadır. Ancak üst ve alt prosesler arasında boru haberleşmelerinin
    gerektiği önemli durumlar vardır.

    Eskiden thread'ler yokken bir işi daha hızlı yapmak için prosesler kullanılıyordu. Üst proses fork işlemi yapıp alt prosesle 
    koordineli bir biçimde işleri paylaşıyordu. O günlerde bu koordinasyonun sağlanması için üst ve alt prosesler arasında 
    haberleşme de gerekiyordu. Thread'lerden sonra artık bu tür işlemler prosesler yerine thread'lerle yapılmaya başlanmıştır.

    Üst ve alt prosesler arasında exec sonrasına da haberleşmeler yapılabilmektedir. Tabii bu durumda exec yapılan alt prosesin 
    exec sonrasında boru betimleyicilerinin numaralarını biliyor olması gerekir. Ancak stdin, stdout ve stderr dosyalarının 
    betimleyicileri sabit olduğuna göre exec sonrasında haberleşme bu betimleyiciler yoluyla yapılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda kabuktakine benzer bir boru yönlendirmesi yapılmıştır. Program komut satırı argümanı olarak aşağıdaki 
    gibi bir yazı almaktadır:

    "prog1 arg1 arg2 ... | prog2 arg1 arg2 ..."

    Program buradaki "|" sembolünün yerini bulur. Sonra bunun iki tarafını strtok ile parse ederek iki ayrı gösterici dizisine
    yerleştirir. Sonra üst proses pipe fonksiyonuyla boruyu yaratır. Soldaki ve sağdaki programlar için fork işlemi yapar. 
    Soldaki programı henüz exec ile çalıştırmadan o alt prosesin stdout dosyasını boruya yönlendirir. Benzer biçimde sağdaki 
    programı henüz çalıştırmadan o prosesin de stdin dosyasını boruya yönlendirir. Sonra da exec işlemlerini uygular. 
    Kabuk aşağıdaki gibi bu boru işlemini yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_ARG        1024

void exit_sys(const char *msg);
void exit_sys_child(const char *msg);

int main(int argc, char *argv[])
{
    char *ppos, *str;
    char *cmdl[MAX_ARG + 1], *cmdr[MAX_ARG + 1];
    int pipefds[2];
    pid_t pidl, pidr;
    int n;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((ppos = strchr(argv[1], '|')) == NULL) {
        fprintf(stderr, "invalid argument: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    *ppos = '\0';

    n = 0;
    for (str = strtok(argv[1], " \t"); str != NULL; str = strtok(NULL, " \t"))
        cmdl[n++] = str;
    cmdl[n] = NULL;

    if (n == 0) {
        fprintf(stderr, "invalid argument!...\n");
        exit(EXIT_FAILURE);
    }

    n = 0;
    for (str = strtok(ppos + 1, " \t"); str != NULL; str = strtok(NULL, " \t"))
        cmdr[n++] = str;
    cmdr[n] = NULL;

    if (n == 0) {
        fprintf(stderr, "invalid argument!...\n");
        exit(EXIT_FAILURE);
    }

    if (pipe(pipefds) == -1)
        exit_sys("pipe");

    if ((pidl = fork()) == -1)
        exit_sys("fork");

    if (pidl == 0) {
        close(pipefds[0]);
        if (pipefds[1] != 1) {                /* bu kontrol normal durumda yapılmayabilir */
            if (dup2(pipefds[1], 1) == -1)
                exit_sys_child("dup2");
            close(pipefds[1]);
        }

        if (execvp(cmdl[0], cmdl) == -1)
            exit_sys_child("execvp");

        /* unreachable code*/
    }

    if ((pidr = fork()) == -1)
        exit_sys("fork");

    if (pidr == 0) {
        close(pipefds[1]);
        if (pipefds[0] != 0) {                /* bu kontrol normal durumda yapılmayabilir */
            if (dup2(pipefds[0], 0) == -1)
                exit_sys_child("dup2");
            close(pipefds[0]);
        }

        if (execvp(cmdr[0], cmdr) == -1)
            exit_sys_child("execvp");

        /* unreachable code*/
    }

    close(pipefds[0]);
    close(pipefds[1]);

    if (waitpid(pidl, NULL, 0) == -1)
        exit_sys("waitpid");

    if (waitpid(pidr, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_child(const char *msg)
{
    perror(msg);

    _exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Borularla ilgili iki yardımcı ve ilginç POSIX fonksiyonu vardır: popen ve pclose. popen fonksiyonu bir boru yaratır sonra 
    kabuk programını interaktif olmayan bir biçimde (-c seçeneği ile) çalıştırır. Sonra kabuk programının stdin ya da stdout 
    dosyalarını bu yarattığı boruya yönlendirir. Borunun diğer ucunu da fdopen fonksiyonundan faydalanarak bir dosya bilgi 
    göstericisine (stream) dönüştürüp bize vermektedir. Fonksiyonun prototipi şöyledir:

    #include <stdio.h>

    FILE *popen(const char *command, const char *mode);

    Fonksiyonun birinci parametresi çalıştırılacak kabuk komutunu belirtir. İkinci parametre yalnızca "r" ya da "w" olabilir. 
    Eğer bu parametre "r" girilirse kabuk komutunun stdout dosyası boruya yönlendirilir. Borunun okuma ucu da bize verilir. 
    Yani biz, bize verilen dosyadan okuma yaptığımızda aslında kabuk komutunun stdout dosyasına yazdıklarını okumuş oluruz. 
    Eğer ikinci parametre "w" olarak girilirse bu durumda biz bu dosyaya yazma yaptığımızda aslında kabukta çalıştırdığımız 
    program bunu stdin dosyasından okuyacaktır. Fonksiyon başarısızlık durumunda NULL adrese geri dönmektedir.

    popen ile yaratılmış olan boru ve dosya bilgi göstericisi pclose fonksiyonu ile yok edilmektedir. pclose fonksiyonunun 
    prototipi de şöyledir:

    #include <stdio.h>

    int pclose(FILE *stream);

    Fonksiyon dosya bilgi göstericisini parametre olarak alır ve daha önce yapılan işlemleri sonlandırır. pclose fonksiyonu 
    aynı zamanda wait işlemini de uygulamaktadır. (Yani thread pclose çağrısında bloke olabilmektedir.) Fonksiyon başarı 
    durumunda çalıştırdığı kabuk programının wait fonksiyonu ile elde edilen durum bilgisine, başarısızlık durumunda -1 
    değerine geri dönmektedir. Kabuk programlarının interaktif olmayan modda çalıştırıldıklarına çalıştırdıkları programın 
    durum koduyla (yani wait fonksiyonlarından elde edilen değerleri kastediyoruz) sonlandığını anımsayınız. pclose kontrolü 
    şöyle yapılabilir:

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");

    Ancak eğer programcı çalıştırmış olduğu programın da başarısını dikkate almak isterse kontrolü şöyle yapabilir:

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");

    if (WIFEXITED(status))
        printf("Shell exit status: %d\n", WEXITSTATUS(status));
    else
        printf("shell abnormal terminated!...\n");

    Aşağıdaki programda "ls -l" komutu çalıştırılıp onun çıktısı elde edilmiştir. Programda pclose fonksiyonun geri dönüş 
    değerinin alınıp kontrol edilmesine genellikle gerek yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
    FILE *f;
    int ch;

    if ((f = popen("ls -l", "r")) == NULL)
        exit_sys("popen");

    while ((ch = fgetc(f)) != EOF)
        putchar(ch);

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");

    pclose(f);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte popen fonksiyonu "w" moduyla çağrılmıştır. Bu durumda bizim dosyaya yazdıklarımız aslında boruya 
    yazılacak ve "wc" programı da stdin yerine borudan okuma yapacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
    FILE *f;
    int ch;

    if ((f = popen("wc", "w")) == NULL)
        exit_sys("popen");

    for (int i = 0; i < 100; ++i)
        fprintf(f, "%d\n", i);

    pclose(f);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    popen fonksiyonu ile aldığımız dosya bilgi göstericisinin (stream) tamponlu çalıştığına dikkat ediniz. Dolayısıyla yazdığımız
    şeyler önce tampona aktarılıp oradan boruya aktarılacaktır. Uygulamaya göre gerekirse fflush ile tamponu tazeleyebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İsimsiz borular yalnızca üst ve alt prosesler arasındaki haberleşmelerde kullanılmaktadır. Halbuki isimli borular herhangi 
    iki proses arasında haberleşmede kullanılabilmektedir. İsimli borularla çalışma tipik olarak şu aşamalardan geçilerek yapılır:

    1) Önce ismine "boru dosyası" ya da "fifo dosyası" denilen özel bir dosyanın yaratılması gerekir. Boru dosyaları "ls -l" 
    komutunda "p" dosya türü ile gösterilmektedir. Boru dosyaları gerçek disk dosyaları değildir. Yalnızca bir dizin girişi 
    içerirler. Bunların diskte bir içerik olarak karşılıkları yoktur. Bu nedenle boru dosyaları hep 0 uzunlukta görüntülenmektedir. 
    Boru dosyaları open fonksiyonuyla yaratılmaz. Bunları yaratmak için mkfifo isimli POSIX fonksiyonu kullanılmaktadır. mkfifo 
    fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mkfifo(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi yaratılacak boru dosyasının yol ifadesini, ikinci parametresi ise erişim haklarını almaktadır.
    Bu erişim hakları yine prosesin umask değeri ile maskelenmektedir. Fonksiyon başarı durumunda 0 başarısızlık durumunda -1 
    değerine geri dönmektedir. Örneğin:

    if (mkfifo("testfifo", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) == -1)
        exit_sys("mkfifo");

    Boru dosyaları manuel olarak da mkfifo isimli kabuk komutuyla yaratılabilmektedir. Örneğin:

    $ mkfifo myfifo

    Erişim hakları -m seçeneği ile verilebilir. Örneğin:

    $ mkfifo -m 666 myfifo

    Tabii komut uygulanırken kabuğun umask değeri etkili olmamaktadır.

    2) İki proses de boru dosyasını open fonksiyonuyla açar. Açım sırasında tipik olarak O_RDONLY ve O_WRONLY modları kullanılmalıdır.
    Boru dosyaları O_RDWR modunda açılabilirse de bu durum genellikle uygun değildir. (Linux boru dosyalarının O_RDWR modunda 
    açılmasına izin vermektedir. Ancak POSIX standartları bu durumu "undefined" bırakmıştır.) Örneğin:

    if ((fd = open("myfifo", O_WRONLY)) == -1)
        exit_sys("open");

    Bir proses isimli boruyu O_WRONLY modunda açmışsa başka bir proses boruyu O_RDONLY (ya da O_RDWR modunda) açana kadar open 
    blokede beklemektedir. Benzer biçimde bir proses boruyu O_RDONLY modunda açmışsa diğer bir proses boruyu O_WRONLY (ya da 
    O_RDWR modunda) açana kadar open fonksiyonu blokede bekler. Tabii boru O_RDWR modunda açılmışsa bloke oluşmaz. Ancak bu modda 
    açım genel olarak uygun değildir ve POSIX standartları bunu "undefined" olarak ele almaktadır. open fonksiyonunun dosya 
    betimleyici tablosundaki en düşük betimleyiciyi verdiğini anımsayınız.

    3) Artık haberleşecek iki proses de boruyu açmıştır. Haberleşme write ve read fonksiyonlarıyla yukarıda belirtildiği gibi 
    yapılır. Yani buradaki haberleşmenin isimsiz boru haberleşmesinden bir farkı yoktur. write ve read fonksiyonları tamamen 
    isimsiz boru haberleşmesinde olduğu gibi davranmaktadır.

    4) Haberleşmenin sonunda yine yazan taraf boruyu kapatır, okuyan tarafın read fonksiyonu 0 ile geri döner. Böylece okuyan 
    taraf da boruyu kapatır. İsimli boruyu kullanan hiçbir betimleyici kalmadığında isimli borunun içi silinmektedir. Örneğin 
    isimli boruyu iki proses de açmış olsun. Birinin yazdığını diğerinin okuduğunu varsayalım. Yazan taraf boruyu kapattıktan 
    sonra okuyan taraf borudakilerin hepsini okumadan boruyu kapatırsa boru içinde kalan bilgiler silinmektedir.

    5) Eğer boru dosyası proseslerden biri tarafından mkfifo fonksiyonuyla yaratılmışsa unlink ya da remove fonksiyonuyla yine 
    ilgili proses tarafından silinebilir. Eğer boru komut satırından mkfifo komutuyla yaratılmışsa bu durumda yine komut satırından 
    rm komutu ile silme yapılabilir. Tabii boru dosyası başka bir haberleşme için de kullanılacaksa silinmeden bekletilebilir. 
    Örneğin:

    if (unlink("mypipe") == -1)
        exit_sys("mypipe")
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                38. Ders 18/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte "prog1" programı zaten komut satırında yaratılmış olan "mypipe" dosyasına yazma yapıp, "prog2" programı 
    da bu borudan okuma yapmaktadır. "prog1" programı klavyeden (stdin dosyasından) bir yazı alır. Bu yazıyı borudan "prog2" 
    programına borudan yollar. Ancak bu örnekte prog2 programı borudan ne kadar bilgi okuyacağını bilmemektedir. Dolayısıyla 
    4096 byte kadar bilgiyi okumak ister. Tabii read fonksiyonu borudan okuma yaparken 4096 byte okunana kadar blokeye yol 
    açmaz. Okuyabildiği kadar bilgiyi okur okuyabildiği byte sayısına geri döner. Yani böylede prog2 programındaki read 
    fonksiyonu karşı tarafın atomik bir biçimde boruya yazdığı kadar bilgiyi okumaktadır. Haberleşme "prog1" programının 
    klavyeden (stdin dosyasından) "quit" okumasıyla sonlanmaktadır. Bu durumda "prog1" döngüden çıkar boruyu kapatır."prog2"de 
    ise read fonksiyonu 0 ile geri döner. Böylece "proc2" de döngüden çıkar ve boruyu kapatır.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    char *str;

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) != NULL)
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
        *str = '\0;
        if (*buf == '\0')
            continue;
        if (write(fdpipe, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit"))
            break;
    }

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fdpipe, buf, BUFFER_SIZE)) > 0) {
        buf[result] = '\0';
        puts(buf);
    }
    if (result == -1)
        exit_sys("read");

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi boru dosyası haberleşecek proseslerden biri tarafından yaratılabilir. Bu durumda bu boru 
    dosyasının onu yaratan proses tarafından silinmesi uygun olur. Fakat boru dosyalarının dışarıdan yaratılması çoğu kez 
    tercih edilmektedir. Çünkü bu durumda iki programın çalıştırma sırasının bir önemi olmaktadır. Halbuki boru dosyası dışarıda 
    yaratılırsa programların çalıştırma sıralarının bir önemi olmaz. Anımsanacağı gibi UNIX/Linux sistemlerinde bir dosya 
    remove ya da unlink fonksiyonu ile silindiğinde açık betimleyiciler normal olarak çalışmaya devam eder. Son betimleyici 
    kapatıldığında dosya gerçek anlamda silinmektedir. Aynı durum boru dosyaları için de geçerlidir.

    Aşağıdaki örnekte "prog1" programı isimli boruyu mkfifo fonksiyonuyla yaratmış ve sonlanmadan önce unlink fonksiyonu ile
    boruyu silmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    char *str;

    if (mkfifo("mypipe", S_IRUSR|S_IWUSR|S_IRGRP|S_IRGRP) == -1)
        exit_sys("mypipe");

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) != NULL)
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
        *str = '\0';
        if (*buf == '\0')
            continue;
        if (write(fdpipe, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit"))
            break;
    }

    close(fdpipe);

    if (unlink("mypipe") == -1)
        exit_sys("unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fdpipe, buf, BUFFER_SIZE)) > 0) {
        buf[result] = '\0';
        puts(buf);
    }
    if (result == -1)
        exit_sys("read");

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Stream tabanlı haberleşmelerde önemli problemlerden biri de "değişken uzunlukta kayıtların" aktarımıdır. Yani örneğin boruya 
    yazan taraf sürekli farklı uzunluklarda kayıtları boruya yazsa, okuyan taraf bu yazılanları nasıl birbirinden ayrıştıracaktır?
    İşte bu tür durumda iki yöntem akla gelmektedir:

    1) Yazan taraf önce değişken uzunluktaki kaydın byte miktarını boruya yazar, sonra değişken uzunluktaki kaydı boruya yazar. 
    Okuyan taraf da önce uzunluğu okur sonra o uzunluk kadar yeniden okuma yapar. Bu yöntem etkin ve çoğu zaman tercih edilen 
    yöntemdir.

    2) Yazan taraf kayıtların sonuna özel bir byte yerleştirir. (Örneğin kayıtlar yazısalsa '\n' gibi bir karakter yerleştirilebilir.)
    Böylece okuyan taraf o özel byte'ı görene kadar okuma yapabilir. Buradaki problem bu özel byte'ın okuyan taraf tarafından nasıl 
    tespit edileceğidir. read fonksiyonu ile sürekli 1 byte okumak etkin bir yöntem değildir. O zaman bir blok bilginin okunup bir 
    tampona yerleştirilmesi ve o tampondan akıllıca kontrol yapılması yoluna gidilir. Buna benzer yazısal aktarımlarda bazen 
    programcılar kaydın sonuna '\n' karakterini yerleştirip boru betimleyicisinden fdopen fonksiyonu ile dosya bilgi gösterici 
    (stream) elde edip fgets gibi bir fonksiyonla okuma yapma yoluna gidebilmektedir. Ne de olsa fgets tamponlu biçimde çalıştığı 
    için bizim yapmamız gerekenleri kendisi yapmaktadır. Tabii aslında önce boruyu açıp sonra fdopen fonksiyonunu kullanmak 
    yerine doğrudan fopen fonksiyonuyla da boru açılabilir.

    Aşağıdaki örnekte "prog1" programı bir dizin'in yol ifadesini komut satırı argümanıyla almış o dizindeki dosyaları elde edip
    önce onların uzunluklarını sonra da isimlerini boruya yazmıştır. Okuyan taraf da (prog2 programı) önce uzunluğu sonra 
    içeriği okuyup kayıtları birbirinden ayırabilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fdpipe;
    DIR *dir;
    struct dirent *de;
    size_t len;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        len = strlen(de->d_name);
        if (write(fdpipe, &len, sizeof(size_t)) == -1)
            exit_sys("write");
        if (write(fdpipe, de->d_name, len) == -1)
            exit_sys("write");
    }

    if (errno != 0)
        exit_sys("readdir");

    close(fdpipe);
    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    size_t len;

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        if ((result = read(fdpipe, &len, sizeof(size_t))) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        if (read(fdpipe, buf, len) == -1)
            exit_sys("read");
        buf[len] = '\0';
        puts(buf);
    }

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yukarıda belirttiğimiz yöntemlerin ikincisi kullanılmıştır. Yani her kayıttan sonra özel bir sonlandırıcı 
    karakter boruya eklenmiştir. Biz burada sonlandırıcı karakter için '\0' değil '\n' karakterini tercih ettik. Çünkü C'de 
    '\0' görene kadar okuma yapan standart bir fonksiyon yoktur. Halbuki '\n' görene kadar okuma yapan bir fgets gibi bir standart
    fonksiyon vardır. Aşağıdaki program hakkında şu özet açıklamaları yapmak istiyoruz:

    - Boruya yazan taraf dosya ismini boruya yazdıktan sonra '\n' karakterini de sonlandırıcı oluşturmak amacıyla boruya yazmıştır.

    - Okuyan taraf tek tek karakterleri read fonksiyonuyla borudan okumak yerine standart fgets fonksiyonundan faydalanmıştır. 
    Tabii bunun için boruyu açtıktan sonra fdopen fonksiyonuyla ondan bir stream elde etmiştir. Şüphesiz bu tür durumlarda boru 
    doğrudan fopen fonksiyonuyla da açılabilir. fopen fonksiyonuyla açım alternatifi "prog3.c" dosyasında verilmiştir.

    - Yazan taraf boruyu kapattığında fgets fonksiyonu NULL adresle geri dönecektir. Anımsanacağı gibi fgets en az bir byte 
    okursa ikinci parametresi ile belirtilen adrese, hiç byte okuyamadan EOF ile karşılaşırsa NULL adrese geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fdpipe;
    DIR *dir;
    struct dirent *de;
    char delim = '\n';

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        if (write(fdpipe, de->d_name, strlen(de->d_name)) == -1)
            exit_sys("write");
        if (write(fdpipe, &delim, 1) == -1)
            exit_sys("write");
    }

    if (errno != 0)
        exit_sys("readdir");

    close(fdpipe);
    closedir(dir);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    FILE *fpipe;

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fpipe = fdopen(fdpipe, "r")) == NULL)
        exit_sys("fdopen");

    for (;;) {
        if (fgets(buf, BUFFER_SIZE, fpipe) == NULL)
            break;
        printf("%s", buf);
    }

    fclose(fpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog3.c */

#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    char buf[BUFFER_SIZE];
    FILE *fpipe;

    if ((fpipe = fopen("mypipe", "r")) == NULL)
        exit_sys("fdopen");

    for (;;) {
        if (fgets(buf, BUFFER_SIZE, fpipe) == NULL)
            break;
        printf("%s", buf);
    }

    fclose(fpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Client-Server haberleşme konusunda bir tasarım mimarisidir. Genellikle "client-server" denildiğinde konu TCP/IP soket 
    haberleşmesi ile ilişkilendirilmektedir. Ancak client-server haberleşme aslında genel bir konudur. Haberleşmedeki ortam 
    değişebilir. Haberleşecek birimler aynı makinenin prosesleri olabildiği gibi farklı makinelerin prosesleri de olabilmektedir. 
    İşte client-server haberleşme aynı makinenin prosesleri arasında borular kullanılarak da yapılabilmektedir. Client-Server 
    haberleşmede iki program söz konusudur: Client program ve server program. Burada asıl işi yapan program server programdır. 
    Client program bir istekte bulunur. Server program da bu isteği karşılar. Client program istekte bulunurken server programa
    "mesaj" adı altında bir bilgi gönderir. Server da client için bir isteği gerçekleştirdikten sonra yine mesaj adı altında 
    client'a bir bilgi göndermektedir.

    Client-Server tarzı haberleşme en çok TCP/IP protokolü ile yapılıyor olsa da borular yoluyla da yapılabilmektedir. 
    Pekiyi borular yoluyla çok client'lı (multi-client) bir client-server uygulama yapmak için kaç boruya ihtiyaç vardır?
    Client programların isteklerini farklı borularla server programa iletmesine gerek yoktur. Client programlar ortak tek bir 
    boru kullanarak isteklerini server programa iletebilirler. Bu durumda server program da belli uzunluktaki kayıtları okuyarak 
    istekleri elde eder. O isteklerin hangi client'tan geldiğini mesajın içerisinden öğrenebilir. Ancak server programın isteğin 
    yanıtını tek bir boruyla client programlara iletmesi mümkün değildir. Mecburen her client için farklı borunun kullanılması 
    gerekir. O halde şunlar söylenebilir:

    - Client programlar tek ve ortak bir boru ile server programa istekte bulunurlar. Bu borunun işin başında yaratılmış olması 
    uygundur.

    - Server program da her client için farklı bir boru ile client'a istek sonucunu gönderir. Server'ın client'a mesaj gönderdiği 
    o client'a özgü boruların client tarafından yaratılması ancak "CONNECT" mesajında server programa iletilmesi daha uygun bir çözümdür. 
    Bu boru yine "DISCONNECT" mesajı sonrasında client program tarafından yok edilir.

    - Server programın kendisine bağlanmış olan tüm client'ların bilgilerini tutması gerekir. Client'ları birbirinden ayıran 
    "sistem genelinde tek olan (unique)" bir değerin id olarak belirlenmesi uygundur. Bunun için akla ilk gelen proses id'lerin 
    client'ları birbirinden ayırmak için kullanılmasıdır. Bu durumda server program bir id'ye göre client bilgilerine hızlı 
    erişim sağlamalıdır. Bunun için en uygun veri yapısı şüphesiz "dengelenmiş ikili ağaçlar (balanced binary trees)" ya da 
    "hash tabloları (hash tables)". Ancak bilindiği gibi C'de bu veri yapıları C'nin standart kütüphanesinde bulunmamaktadır. 
    Halbuki nesne yönelimli dillerin neredeyse hemen hepsinde "sözlük (dictionary)" veri yapısı denilen bu veri yapıları o 
    dillerin standart kütüphanelerinde hazır biçimde bulunmaktadır. Örneğin C++'taki "map" ya da "unordered_map" isimli sınıflar 
    bu iş için idealdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                39. Ders 19/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki isimli borular kullanılarak bir client-server haberleşme örneği verilmiştir. Programla ilgili bazı açıklamaları
    veriyoruz:

    - Programda client'ların server'a mesaj göndermesi için kullandıkları borunun işin başında "serverpipe" ismiyle yaratılmış 
    olması gerekmektedir.

    - Client ile server arasındaki haberleşmeler yazısal biçimde şöyle yapılmaktadır:

    "KOMUT <parametrik bilgiler>"

    Client ve server bu yazıyı parse edip komut ve parametrelerini birbirinden ayırmaktadır.

    - Server'ın client'a göndereceği mesajlar için kullanılacak borular server tarafından yaratılmaktadır. Bu sırada client 
    "boru yaratılmış mı" diye beklemektedir.

    - Server her client'a bir id numarası vermektedir. Id numarası olarak proses id'ler değil client borulara ilişkin betimleyici 
    numaraları kullanılmıştır. Server bağlantıyı sağladığında client borusunu yaratır, onun betimleyici numarasını boruya gönderir. 
    Ancak client borusunun ismini client program belirlemektedir. Yani borunun ismi client program tarafından belirlenmekte ancak yaratımı
    server program tarafından yapılmaktadır.

    - Client'tan server'a gönderilen mesajlar şunlardır:

    CONNECT <boru ismi>
    DISCONNECT_REQUEST
    DISCONNECT
    CMD <kabuk komutu>

    Burada CMD client'ın server'a işlettireceği kabuk komutunu belirtmektedir. Yani server client'ın gönderdiği kabuk komutunu işletir. 
    Onun sonucunu client'a yollar.

    - Server programın client programa gönderdiği mesajlar da şunlardır:

    CMD_RESPONSE <komutun çıktı yazısı>
    DISCONNECT_ACCEPTED
    INVALID_COMMAND <hata yazısı>

    - Client'ın bağlantıyı sonlandırması şöyle bir el sıkışmayla sağlanmıştır:

    1) Önce client server'a DISCONNECT_REQUESTED mesajını gönderir.
    2) Sonra server bu mesajı alınca eğer disconnect'i kabul ederse DISCONNECT_ACCEPTED mesajını gönderir.
    3) Client son olarak server'a DISCONNECT mesajını göndererek el sıkışmayı sonlandırır.

    - Client program bir komut satırı oluşturup komutların kullanıcı tarafından uygulanmasını sağlamaktadır. Ancak bağlantının sonlandırılması
    bir dizi el sıkışma gerektirdiği için "quit" komutu sırasında yaptırılmıştır.

    - Server programda client'ların bilgileri için bir veri yapısı oluşturulmamıştır. Zaten client id server'daki dosya betimleyicisi 
    olduğu için böyle bir sözlük veri yapısına ihtiyaç duyulmamıştır. Tabii aslında client'ın pek çok bilgisini server saklamak isteyebilir. 
    Genel olarak böyle bir veri yapısının oluşturulması uygundur.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

/* Symbolic Constants */

#define SERVER_PIPE        "serverpipe"
#define MAX_CMD_LEN        1024
#define MAX_MSG_LEN        32768
#define MAX_PIPE_PATH    1024

/* Type Declaration */

typedef struct tagCLIENT_MSG {
    int msglen;
    int client_id;
    char msg[MAX_MSG_LEN];
} CLIENT_MSG;

typedef struct tagSERVER_MSG {
    int msglen;
    char msg[MAX_MSG_LEN];
} SERVER_MSG;

typedef struct tagMSG_CONTENTS {
    char *msg_cmd;
    char *msg_param;
} MSG_CONTENTS;

typedef struct tagMSG_PROC {
    const char *msg_cmd;
    int (*proc)(const char *msg_param);
} MSG_PROC;

/* Function Prototypes */

void sigpipe_handler(int sno);
int putmsg(const char *cmd);
int get_server_msg(int fdp, SERVER_MSG *smsg);
void parse_msg(char *msg, MSG_CONTENTS *msgc);
void check_quit(char *cmd);
int connect_to_server(void);
int cmd_response_proc(const char *msg_param);
int disconnect_accepted_proc(const char *msg_param);
int invalid_command_proc(const char *msg_param);
void clear_stdin(void);
void exit_sys(const char *msg);

/* Global Data Definitions */

MSG_PROC g_msg_proc[] = {
    {"CMD_RESPONSE", cmd_response_proc},
    {"DISCONNECT_ACCEPTED", disconnect_accepted_proc},
    {"INVALID_COMMAND", invalid_command_proc},
    {NULL, NULL}
};

int g_client_id;
int g_fdps, g_fdpc;

/* Function Definitions */

int main(void)
{
    char cmd[MAX_CMD_LEN];
    char *str;
    SERVER_MSG smsg;
    MSG_CONTENTS msgc;
    int i;

    if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
        exit_sys("signal");

    if ((g_fdps = open(SERVER_PIPE, O_WRONLY)) == -1)
        exit_sys("open");

    if (connect_to_server() == -1) {
        fprintf(stderr, "cannot connect to server! Try again...\n");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        printf("Client>");
        fflush(stdout);
        fgets(cmd, MAX_CMD_LEN, stdin);
        if ((str = strchr(cmd, '\n')) != NULL)
            *str = '\0';

        check_quit(cmd);

        if (putmsg(cmd) == -1)
            exit_sys("putmsg");

        if (get_server_msg(g_fdpc, &smsg) == -1)
            exit_sys("get_client_msg");

        parse_msg(smsg.msg, &msgc);

        for (i = 0; g_msg_proc[i].msg_cmd != NULL; ++i)
            if (!strcmp(msgc.msg_cmd, g_msg_proc[i].msg_cmd)) {
                if (g_msg_proc[i].proc(msgc.msg_param) == -1) {
                    fprintf(stderr, "command failed!\n");
                    exit(EXIT_FAILURE);
                }
                break;
            }
        if (g_msg_proc[i].msg_cmd == NULL) {        /* command not found */
            fprintf(stderr, "Fatal Error: Unknown server message!\n");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}

void sigpipe_handler(int sno)
{
    printf("server down, exiting...\n");

    exit(EXIT_FAILURE);
}

int putmsg(const char *cmd)
{
    CLIENT_MSG cmsg;
    int i, k;

    for (i = 0; isspace(cmd[i]); ++i)
        ;
    for (k = 0; !isspace(cmd[i]); ++i)
        cmsg.msg[k++] = cmd[i];
    cmsg.msg[k++] = ' ';
    for (; isspace(cmd[i]); ++i)
        ;
    for (; (cmsg.msg[k++] = cmd[i]) != '\0'; ++i)
        ;
    cmsg.msglen = (int)strlen(cmsg.msg);
    cmsg.client_id = g_client_id;

    if (write(g_fdps, &cmsg, 2 * sizeof(int) + cmsg.msglen) == -1)
        return -1;

    return 0;
}

int get_server_msg(int fdp, SERVER_MSG *smsg)
{
    if (read(fdp, &smsg->msglen, sizeof(int)) == -1)
        return -1;

    if (read(fdp, smsg->msg, smsg->msglen) == -1)
        return -1;

    smsg->msg[smsg->msglen] = '\0';

    return 0;
}

void parse_msg(char *msg, MSG_CONTENTS *msgc)
{
    int i;

    msgc->msg_cmd = msg;

    for (i = 0; msg[i] != ' ' && msg[i] != '\0'; ++i)
        ;
    msg[i++] = '\0';
    msgc->msg_param = &msg[i];
}

void check_quit(char *cmd)
{
    int i, pos;

    for (i = 0; isspace(cmd[i]); ++i)
        ;
    pos = i;
    for (; !isspace(cmd[i]) && cmd[i] != '\0'; ++i)
        ;
    if (!strncmp(&cmd[pos], "quit", pos - i))
        strcpy(cmd, "DISCONNECT_REQUEST");
}

int connect_to_server(void)
{
    char name[MAX_PIPE_PATH];
    char cmd[MAX_CMD_LEN];
    char *str;
    SERVER_MSG smsg;
    MSG_CONTENTS msgc;
    int response;

    printf("Pipe name:");
    fgets(name, MAX_PIPE_PATH, stdin);
    if ((str = strchr(name, '\n')) != NULL)
        *str = '\0';

    if (access(name, F_OK) == 0) {
        do {
            printf("Pipe already exists! Overwrite? (Y/N)");
            fflush(stdout);
            response = tolower(getchar());
            clear_stdin();
            if (response == 'y' && remove(name) == -1)
                return -1;
        } while (response != 'y' && response != 'n');
        if (response == 'n')
            return -1;
    }

    sprintf(cmd, "CONNECT %s", name);

    if (putmsg(cmd) == -1)
        return -1;

    while (access(name, F_OK) != 0)
        usleep(300);

    if ((g_fdpc = open(name, O_RDONLY)) == -1)
        return -1;

    if (get_server_msg(g_fdpc, &smsg) == -1)
        exit_sys("get_client_msg");

    parse_msg(smsg.msg, &msgc);

    if (strcmp(msgc.msg_cmd, "CONNECTED"))
        return -1;

    g_client_id = (int)strtol(msgc.msg_param, NULL, 10);

    printf("Connected server with '%d' id...\n", g_client_id);

    return 0;
}

int cmd_response_proc(const char *msg_param)
{
    printf("%s\n", msg_param);

    return 0;
}

int disconnect_accepted_proc(const char *msg_param)
{
    if (putmsg("DISCONNECT") == -1)
            exit_sys("putmsg");

    exit(EXIT_SUCCESS);

    return 0;
}

int invalid_command_proc(const char *msg_param)
{
    printf("invalid command: %s\n", msg_param);

    return 0;
}

void clear_stdin(void)
{
    int ch;

    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>

/* Symbolic Constants */

#define SERVER_PIPE            "serverpipe"
#define MAX_MSG_LEN            32768
#define MAX_PIPE_PATH        1024
#define MAX_CLIENT            1024

/* Type Declaration */

typedef struct tagCLIENT_MSG {
    int msglen;
    int client_id;
    char msg[MAX_MSG_LEN];
} CLIENT_MSG;

typedef struct tagSERVER_MSG {
    int msglen;
    char msg[MAX_MSG_LEN];
} SERVER_MSG;

typedef struct tagMSG_CONTENTS {
    char *msg_cmd;
    char *msg_param;
} MSG_CONTENTS;

typedef struct tagMSG_PROC {
    const char *msg_cmd;
    int (*proc)(int, const char *msg_param);
} MSG_PROC;

typedef struct tagCLIENT_INFO {
    int fdp;
    char path[MAX_PIPE_PATH];
} CLIENT_INFO;

/* Function Prototypes */

int get_client_msg(int fdp, CLIENT_MSG *cmsg);
int putmsg(int client_id, const char *cmd);
void parse_msg(char *msg, MSG_CONTENTS *msgc);
void print_msg(const CLIENT_MSG *cmsg);
int invalid_command(int client_id, const char *cmd);
int connect_proc(int client_id, const char *msg_param);
int disconnect_request_proc(int client_id, const char *msg_param);
int disconnect_proc(int client_id, const char *msg_param);
int cmd_proc(int client_id, const char *msg_param);
void exit_sys(const char *msg);

/* Global Data Definitions */

MSG_PROC g_msg_proc[] = {
    {"CONNECT", connect_proc},
    {"DISCONNECT_REQUEST", disconnect_request_proc},
    {"DISCONNECT", disconnect_proc},
    {"CMD", cmd_proc},
    {NULL, NULL}
};

CLIENT_INFO g_clients[MAX_CLIENT];

/* Function Definitions */

int main(void)
{
    int fdp;
    CLIENT_MSG cmsg;
    MSG_CONTENTS msgc;
    int i;

    printf("Server running...\n");

    if ((fdp = open(SERVER_PIPE, O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        if (get_client_msg(fdp, &cmsg) == -1)
            exit_sys("get_client_msg");
        print_msg(&cmsg);
        parse_msg(cmsg.msg, &msgc);
        for (i = 0; g_msg_proc[i].msg_cmd != NULL; ++i)
            if (!strcmp(msgc.msg_cmd, g_msg_proc[i].msg_cmd)) {
                if (g_msg_proc[i].proc(cmsg.client_id, msgc.msg_param)) {

                }
                break;
            }
        if (g_msg_proc[i].msg_cmd == NULL)
            if (invalid_command(cmsg.client_id, msgc.msg_cmd) == -1)
                continue;
    }

    close(fdp);

    return 0;
}

int get_client_msg(int fdp, CLIENT_MSG *cmsg)
{
    if (read(fdp, &cmsg->msglen, sizeof(int)) == -1)
        return -1;

    if (read(fdp, &cmsg->client_id, sizeof(int)) == -1)
        return -1;

    if (read(fdp, cmsg->msg, cmsg->msglen) == -1)
        return -1;

    cmsg->msg[cmsg->msglen] = '\0';

    return 0;
}

int putmsg(int client_id, const char *cmd)
{
    SERVER_MSG smsg;
    int fdp;

    strcpy(smsg.msg, cmd);
    smsg.msglen = strlen(smsg.msg);

    fdp = g_clients[client_id].fdp;

    return write(fdp, &smsg, sizeof(int) + smsg.msglen) == -1 ? -1 : 0;
}

void parse_msg(char *msg, MSG_CONTENTS *msgc)
{
    int i;

    msgc->msg_cmd = msg;

    for (i = 0; msg[i] != ' ' && msg[i] != '\0'; ++i)
        ;
    msg[i++] = '\0';
    msgc->msg_param = &msg[i];
}

void print_msg(const CLIENT_MSG *cmsg)
{
    printf("Message from \"%s\": %s\n", cmsg->client_id ? g_clients[cmsg->client_id].path : "", cmsg->msg);
}

int invalid_command(int client_id, const char *cmd)
{
    char buf[MAX_MSG_LEN];

    sprintf(buf, "INVALID_COMMAND %s", cmd);
    if (putmsg(client_id, buf) == -1)
        return -1;

    return 0;
}

int connect_proc(int client_id, const char *msg_param)
{
    int fdp;
    char buf[MAX_MSG_LEN];

    if (mkfifo(msg_param, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) == -1) {
        printf("CONNECT message failed! Params = \"%s\"\n", msg_param);
        return -1;
    }

    if ((fdp = open(msg_param, O_WRONLY)) == -1)
        exit_sys("open");

    g_clients[fdp].fdp = fdp;
    strcpy(g_clients[fdp].path, msg_param);

    sprintf(buf, "CONNECTED %d", fdp);
    if (putmsg(fdp, buf) == -1)
        exit_sys("putmsg");

    return 0;
}

int disconnect_request_proc(int client_id, const char *msg_param)
{
    if (putmsg(client_id, "DISCONNECT_ACCEPTED") == -1)
        return -1;

    return 0;
}

int disconnect_proc(int client_id, const char *msg_param)
{
    close(g_clients[client_id].fdp);

    if (remove(g_clients[client_id].path) == -1)
        return -1;

    return 0;
}

int cmd_proc(int client_id, const char *msg_param)
{
    FILE *f;
    char cmd[MAX_MSG_LEN] = "CMD_RESPONSE ";
    int i;
    int ch;

    if ((f = popen(msg_param, "r")) == NULL) {
        printf("cannot execute shell command!...\n");
        return -1;
    }

    for (i = 13; (ch = fgetc(f)) != EOF; ++i)
        cmd[i] = ch;
    cmd[i] = '\0';

    if (putmsg(client_id, cmd) == -1)
        return -1;

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Blokesiz boru işlemlerini ele almadan önce fcntl isimli POSIX fonksiyonunu (aynı zamanda bir sistem fonksiyonu olarak 
    bulundurulmaktadır) ele almak istiyoruz. fcntl zaten açılmış olan bir dosyanın çeşitli açım özelliklerini değiştirmek için 
    kullanılmaktadır. fcntl fonksiyonu sayesinde biz open fonksiyonu ile açım sırasında belirlediğimiz bazı açış bayraklarını 
    daha sonra değiştirebilmekteyiz. fcntl fonksiyonu aynı zamanda open fonksiyonu kullanılmadan yaratılmış olan betimleyicilerin 
    özelliklerini değiştirmekte de kullanılabilmektedir. Örneğin pipe fonksiyonu boruyu yarattıktan sonra bize iki betimleyici 
    vermektedir. Bu iki betimleyiciyi open fonksiyonuyla biz açmadığımız için onun bazı özelliklerini ancak fcntl fonksiyonu ile 
    set edebiliriz. fcntl fonksiyonu yalnızca betimleyici bayraklarının set edilmesi için değil onların elde edilmesi için 
    (get edilmesi için) de kullanılmaktadır. Biz daha önce close on exec bayrağını set etmek için fcntl fonksiyonunu zaten 
    kullanmıştık. Ancak orada fonksiyonun genel tanıtımını yapmamıştık.

    fcntl fonksiyonunun prototipi şöyledir:

    #include <fcntl.h>

    int fcntl(int fd, int cmd, ...);

    Fonksiyonun birinci parametresi bayrakları set ya da get edilecek betimleyicinin numarasını almaktadır. İkinci parametre 
    ne yapılacağını belirtir. Bu parametreye önceden belirlenmiş sembolik sabitlerle define edilmiş bazı değerler girilmektedir. 
    Fonksiyon get etme amacıyla kullanılıyorsa iki argümanla çağrılmaktadır. Ancak set etme amacıyla kullanılıyorsa üç argümanla 
    çağrılmaktadır. Fonksiyon başarı durumunda get amaçlı kullanıldıysa ilgili get edilen değere, set amaçlı kullanıldıysa -1 
    dışındaki herhangi bir değere ve başarısızlık durumunda -1 değerine geri dönmektedir. Tabii eğer fonksiyon get amaçlı 
    kullanılıyorsa ve betimleyici ile komut parametresi doğru bir biçimde verilmişse fonksiyonun başarısız olma olasılığı yoktur.

    Fonksiyonun ikinci parametresi F_GETFL ve F_SETFL biçiminde girilirse bu durumda fonksiyon "dosya durum bayraklarını (file 
    status flags)" ve "erişim modunu (access modes)" get ve set etmektedir. Dosya durum bayrakları (file status flags) şunlardır:

    O_APPEND
    O_DSYNC
    O_NONBLOCK
    O_RSYNC
    O_SYNC

    Biz bu bayraklardan yalnızca O_APPEND bayrağını open fonksiyonunu anlatırken açıklamıştık. Dosya erişim modları da şunlardan 
    oluşmaktadır:

    O_EXEC
    O_RDONLY
    O_RDWR
    O_SEARCH
    O_WRONLY

    Eğer programcı dosya durum bayraklarını F_GETFL ile elde etmek istemişse fonksiyonun geri dönüş değerini dosya durum 
    bayraklarıyla bit AND işlemine sokarak ilgili bayrağın set edilip edilmediğini anlayabilir. Örneğin:

    result = fcntl(fd, F_GETFL);
    if (result & O_APPEND) {
        /* O_APPEND bayrağı set edilmiş */
    }

    Eğer programcı dosya erişim modlarını elde etmek istiyorsa erişim modları ile bit AND işlemini kullanmamalıdır. Bunun 
    için önce fonksiyonun geri dönüş değeri O_ACCMODE değeri ile bit AND işlemine sokulup erişim modlarıyla == karşılaştıması 
    yapılmalıdır. Örneğin biz dosyanın O_RDWR modunda açılıp açılmadığını anlam isteyelim. Bu işlemi şöyle yapmamalıyız:

    result = fcntl(fd, F_GETFL);
    if (result & O_RDWR) {        /* dikkat! hatalı kullanım */
        ...
    }

    Bu işlemin şöyle yapılması gerekir:

    result = fcntl(fd, F_GETFL);
    if ((result & O_ACCMODE) == O_RDWR) {        /* doğru kullanım */
        /* O_RDWR bayrağı set edilmiş */
    }

    Şimdi F_SETFL komutuyla O_NONBLOCK bayrağını set etmek isteyelim. İşlemi şöyle yapabiliriz:

    result = fcntl(fd, F_GETFL);
    if (fcntl(fd, F_SETFL, result|O_NONBLOCK) == -1)
        exit_sys("fcntl");

    F_SETFL işleminde hem dosya durum bayraklarının hem de erişim modunun set edilmeye çalışıldığına dikkat ediniz. Diğer 
    bayraklara dokunmadan yalnızca O_NONBLOCK bayrağının set edilmesi için önce get işleminin yapılması gerekir. Şimdi de 
    O_NONBLOCK bayrağını clear edelim:

    result = fcntl(fd, F_GETFL);
    if (fcntl(fd, F_SETFL, result & ~O_NONBLOCK) == -1)
        exit_sys("fcntl");

    fcntl fonksiyonunda F_GETFD ve F_SETFD komut kodları "dosya betimleyici bayraklarını" get ve set etmekte kullanılmaktadır. 
    POSIX standartları dosya betimleyici bayrağı olarak yalnızca tek bir bayrak tanımlamıştır. Bu bayrak FD_CLOEXEC bayrağıdır. 
    Dolayısıyla biz bu komut kodu ile yalnızca dosyanın "close on exec" bayrağını get ve set edebiliriz. Biz de zaten daha önce 
    dosyanın close on exec bayrağını alıp set etmiştik. Dosyanın close on exec bayrağı şöyle alınabilir:

    result = fcntl(fd, F_GETFD);
    if (result & FD_CLOEXEC) {
        /* close on exec bayrağı set edilmiş durumda */
    }

    Dosyanın close on exec bayrağını şöyle set edebiliriz:

    result = fcntl(fd, F_GETFD);
    if (fcntl(fd, F_SETFD, result | FD_CLOEXEC) == -1)
        exit_sys("fcntl");

    Dosyanın close on exec bayrağını şöyle clear edebiliriz:

    result = fcntl(fd, F_GETFD);
    if (fcntl(fd, F_SETFD, result & ~FD_CLOEXEC) == -1)
        exit_sys("fcntl");

    Biz dosya betimleyicisini çiftlemek için daha önce dup ve dup2 fonksiyonlarını kullanmıştık. Aslında dosya betimleyicilerinin 
    çiftlenmesi fcntl fonksiyonuyla da yapılabilmektedir. Bunun fcntl fonksiyonunda komut kodu olarak F_DUPFD kullanılır. Bu komut 
    kodunda üçüncü parametre de girilmelidir. Fonksiyon üçüncü parametrede belirtilen betimleyici değerine eşit ya da ondan büyük 
    olan düşük boş betimleyiciyi bize verir. Bu bakımdan fcntl ile dosya betimleyicisinin çiftlenmesi dup ve dup2 fonksiyonlarından 
    farklıdır. Anımsanacağı gibi dup fonksiyonu bize ilk boş betimleyiciyi, dup2 fonksiyonu ise ikinci parametresiyle belirttiğimiz 
    betimleyiciyi vermektedir. Oysa fcntl fonksiyonu F_DUPFD komut koduyla bize belli bir değerden büyük en düşük betimleyici verir. 
    Örneğin:

    if ((fd2 = fcntl(fd, F_DUPFD, 50)) == -1)
        exit_sys("fcntl");

    Burada fd'nin çiftlenmiş betimleyicisi 50 ya da ilk büyük betimleyicidir. O halde fcntl ile dup fonksiyonun eşdeğeri şöyledir:

    if ((fd2 = fcntl(fd, F_DUPFD, 0)) == -1)    /* dup ile eşdeğer */
        exit_sys("fcntl");

    Ayrıca fcntl fonksiyonunun F_DUPFD_CLOEXEC biçiminde bir komut daha vardır. Bu komut kodu hem F_DUPFD hem de close on exec 
    bayrağının set edilmesini birlikte yapmaktadır. Yani özetle bu komut kodu hem dosya betimleyicisini çiftler hem de çiftlenmiş
    olan yeni betimleyicinin close on exec bayrağını set eder. Örneğin:

    if ((fd2 = fcntl(fd, F_DUPFD_CLOEXEC, 0)) == -1)
        exit_sys("fcntl");

    fd2 betimleyicisinin aynı zamanda close on exec bayrağı set edilmiştir.

    fcntl fonksiyonunun diğer komut kodları dosya kilitleme gibi özel bazı konulara ilişkindir. Bu bayraklar o konuların
    anlatıldığı bölümde ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    mypipe bir isimli boru dosyası olsun. Aşağıdaki gibi bir işlem yapsak ne olur?

    $ ls > mypipe

    Bu durumda kabuk programı IO yönlendirmesi yapmak için "mypipe" dosyasını "write" modda open fonksiyonu ile açmak isteyecektir. 
    Ancak "mypipe" isimli boru dosyası olduğu için açım sırasında bloke oluşacaktır. Pekiyi bu blokeden nasıl kurtulunabilir? 
    Tabii başka bir terminalden biz boruyu bu kez "read" modda açarak. Örneğin:

    $ cat < mypipe

    Burada yine kabuk programı "mypipe" dosyasını yönlendirme için "read" modda açacaktır. Bu durumda diğer kabuk prosesi 
    blokeden kurtulacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı (boru dosyaları da diğer aygıt sürücü dosyaları da dahil olmak üzere) açarken kullanılan bayraklardan biri de 
    O_NONBLOCK bayrağıdır. Bu bayrağın normal dosyalarda (regular file) bir etkisi yoktur. Ancak borularda, soketlerde ve özel 
    bazı aygıt sürücülerde bu bayrak önemli bir işlevselliğe sahiptir. Bu işlevselliğe "blokesiz IO işlemleri (Nonblocking IO)" 
    denilmektedir.

    Blokesiz IO işlemlerinin temel fikri şudur: Bazı aygıtlardan (boru ve soketlerde dahil olmak üzere) okuma yazma yapılırken 
    uzun süre beklemeye yol açabilecek bir bloke durumu oluşabilmektedir. Örneğin biz bir borudan okuma yapmak isteyelim. Ancak 
    boruda hiç byte olmasın. Bu durumda read fonksiyonu blokeye yol açacak ve boruya bilgi gelene kadar program akışı kesilecektir. 
    İşte blokesiz işlemlerde eğer ilgili işlem blokeye yol açabilecekse bloke oluşturulmamakta read ve write fonksiyonları başarısızlıkla
    geri dönmekte errno değeri EAGAIN denilen özel bir değerle set edilmektedir. Örneğin biz içerisinde hiç byte olmayan bir borudan 
    read fonksiyonu ile 10 byte okumak isteyelim. Eğer boru default durumda olduğu gibi "blokeli modda" ise read fonksiyonu en az 1 byte 
    boruya yazılana kadar blokede kalır. Ancak eğer blokesiz modda isek bu durumda read bloke olmaz -1 değeriyle geri döner ve errno 
    değeri EAGAIN ile set edilir. Böylece programcı arka planda "mademki boruda bir şey yok o zaman ben de başka bir şey yapayım" 
    diyebilmektedir. Aynı durum write sırasında da olmaktadır. Örneğin blokesiz modda biz bir boruya write işlemi yapmak isteyelim 
    ancak boru tam olarak dolu olsun. Bu durumda write fonksiyonu -1 ile geri döner ve errno değeri EAGAIN değeri set edilir. 
    Blokesiz modda işlemler blokeli moddaki işlemlere göre oldukça seyrek kullanılmaktadır.

    İsimli boru dosyaları open fonksiyonuyla O_NONBLOCK bayrağı kullanılarak açılırken artık open fonksiyonunda bloke oluşmaz. 
    Anımsanacağı gibi blokesiz modda open karşı taraf boruyu ters modda açana kadar bloke oluşturuyordu. open fonksiyonunda 
    O_NONBLOCK bayrağı kullanıldığında proses boruyu read modda açtığında henüz karşı taraf boruyu write modda açmamışsa read 
    fonksiyonu boruyu yazma potansiyelinde olan hiçbir betimleyici olmadığı için 0 ile geri döner.

    İsimli borularda proses boruyu "write" modda açarken normalde blokeli modda open fonksiyonu karşı taraf boruyu "read" modda 
    açana kadar bloke oluşuyordu. Halbuki isimli boruları O_NONBLOCK bayrağı ile "write" modda açmaya çalıştığımızda karşı 
    taraf boruyu henüz "read" modda açmamışsa open başarısız olmaktadır. Bu durumda open fonksiyonu errno değerini ENXIO ile 
    set etmektedir. Bu errno değerinin yazısı "No such device or address" biçimindedir.

    İsimli borularda iki taraf da boruyu O_NONBLOCK bayrağı ile açarsa yukarıda anlattığımız nedenden dolayı senkronizasyona 
    dikkat etmek gerekir. Bu tür durumlarda işlemleri kolaylaştırmak için isimli borular blokeli modda açılıp (O_NONBLOCK 
    kullanılmadan) sonrasında fcntl fonksiyonu ile blokesiz moda geçilebilir.

    Prosesler biri boruyu blokeli modda diğeri blokesiz modda açabilir. Bu da herhangi bir soruna yol açmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                40. Ders 25/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda isimsiz borularda blokesiz IO örneği verilmiştir. Bu örnekte borular blokesiz moda sokulmuş sonra read ve write 
    işlemleri başarısız olduğunda errno değerine bakılmıştır. Eğer başarısızlığın nedeni blokesiz IO yüzündense errno EAGAIN 
    özel değerine set edileceği için bu sırada prosesler arka planda başka işlemler yapmıştır. Örnekte kasten üst proseste
    biraz bekleme yapılmıştır. Dolayısıyla program çalıştırıldığında alt proses read işleminde blokesiz IO yüzünden başarısız 
    olup birtakım arka plan işlemleri yapacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);
void exit_sys_child(const char *msg);

int main(int argc, char *argv[])
{
    int pipefds[2];
    pid_t pid;
    ssize_t result;
    int val;
    int i;

    if (pipe(pipefds) == -1)
        exit_sys("pipe");

    if (fcntl(pipefds[1], F_SETFL, fcntl(pipefds[1], F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    if (fcntl(pipefds[0], F_SETFL, fcntl(pipefds[0], F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent writes */
        close(pipefds[0]);
        sleep(1);

        i = 0;
        while (i < 100000) {
            if (write(pipefds[1], &i, sizeof(int)) == -1)
                if (errno == EAGAIN) {
                    printf("parent background processing...\n");
                    usleep(500);
                    continue;
                }
                else
                    exit_sys("write");
            ++i;
        }

        close(pipefds[1]);
        if (wait(NULL) == -1)
            exit_sys("wait");

    }
    else {            /* child reads */
        close(pipefds[1]);
        while ((result = read(pipefds[0], &val, sizeof(int))) != 0) {
            if (result == -1)
                if (errno == EAGAIN) {
                    printf("child background processing...\n");
                    usleep(500);
                    continue;
                }
                else
                    exit_sys_child("read");
            printf("%d\n", val);
        }

        close(pipefds[0]);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_child(const char *msg)
{
    perror(msg);

    _exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda isimli boruların blokesiz modda kullanımına bir örnek verilmiştir. Burada "mypipe" isimli borusunun dışarıda 
    yaratılmış olması gerekir. İki proses de boruyu önce blokeli modda açmış sonra fcntl fonksiyonu ile blokesiz moda geçmiştir. 
    Yukarıda da belirttiğimiz gibi open fonksiyonu ile O_NONBLOCK bayrağı kullanılarak isimli boruların blokesiz modda açılması 
    sırasında senkronizasyona dikkat edilmesi gerekir. Halbuki önce iki prosesin open fonksiyonu ile boruları blokeli modda 
    açıp sonra fcntl fonksiyonu ile blokesiz moda geçirmesi bu senkronizasyon problemini bertaraf etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* proc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    int i;

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    if (fcntl(fdpipe, F_SETFL, fcntl(fdpipe, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    i = 0;
    while (i < 100000) {
        if (write(fdpipe, &i, sizeof(int)) == -1)
            if (errno == EAGAIN) {
                printf("parent background processing...\n");
                usleep(500);
                continue;
            }
            else
                exit_sys("write");
        ++i;
    }

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* proc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    int val;

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    if (fcntl(fdpipe, F_SETFL, fcntl(fdpipe, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    while ((result = read(fdpipe, &val, sizeof(int))) != 0) {
            if (result == -1)
                if (errno == EAGAIN) {
                    printf("child background processing...\n");
                    usleep(500);
                    continue;
                }
                else
                    exit_sys("read");
            printf("%d\n", val);
        }

    close(fdpipe);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında POSIX standartları çeşitli uyum kategorilerini içermektedir. Yani POSIX standardını destekleyen sistemler 
    onun bazı uyum kategorilerini destekleyip bazılarını desteklemiyor olabilirler. Örneğin XSI (X/Open ya da Open Group anlamına 
    gelmektedir) önemli bir uyum kategorisidir. Bu uyum kategorisi X/Open denilen ya da yeni ismi ile "Single Unix Specification" 
    denilen uyum kategorisini anlatır. Biz kursumuzda POSIX standartları demekle tüm bu uyum kategorilerini içerecek biçimde 
    bu terimi kullanıyoruz. Halbuki yukarıda da belirtildiği gibi bazı uyum kategorileri dışlanarak da POSIX standartları 
    desteklenebilmektedir. POSIX standartlarında, fonksiyonların yanında bu uyum kategorileri belirtilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında "IPC fonksiyonları" demekle geleneksel olarak "mesaj kuyrukları, paylaşılan bellek alanları ve semaphore'lar"
    anlaşılmaktadır. "IPC fonksiyonları" yerine "IPC nesneleri" terimi de kullanılabilmektedir. Borular tipik bir IPC mekanizması 
    olduğu halde bu dünyada IPC fonksiyonları denildiğinde borular anlaşılmamaktadır. (Semaphore'lar senkronizasyon konusu 
    ile ilgilidir. Ancak bir anlamda IPC konusuyla da ilgilidir. Biz semaphore'ları "thread'lerin anlatıldığı" bölümde ele alacağız.) 

    Yinelemek gerekirse UNIX dünyasında -onların terminolojisiyle- üç IPC mekanizması vardır:

    - Mesaj kuyrukları
    - Paylaşılan Bellek Alanları
    - Semaphore'lar

    Borular birer IPC mekanizması olduğu halde UNIX/Linux dünyasında IPC mekanizması denildiğinde genellikle borular ayrı biçimde 
    ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında IPC mekanizması (onların terimi ile) için iki farklı arayüz (fonksiyon grubu) kullanılmaktadır:

    1) Eskiden beri var olan geniş bir taşınabilirliğe sahip olan ismine "Sistem 5 IPC fonksiyonları" ya da "XSI IPC fonksiyonları"
    denilen klasik IPC fonksiyonları.

    2) 1990'lı yılların ortalarında "Real Time Extensions" eklemeleriyle UNIX/Linux dünyasına katılan ismine
    "POSIX IPC fonksiyonları" denilen yeni ve daha modern IPC fonksiyonları.

    Her ne kadar ikinci grup fonksiyonlara "POSIX IPC fonksiyonları" deniliyorsa da her iki fonksiyon grubu da POSIX standartlarında bulunmaktadır. 
    Klasik IPC fonksiyonlarının yanında XSI uyum kategorisi belirteçleri yerleştirilmiştir.

    Her iki arayüzdeki fonksiyonların parametrik yapıları ve isimleri o arayüze uygun biçimde belirlenmiştir. Bu nedenle örneğin Sistem 5 (XSI) 
    klasik IPC fonksiyonlarının isimlendirmeleri ve kullanımları birbirine benzerdir ve POSIX IPC fonksiyonlarının isimlendirmeleri ve kullanımları 
    birbirine benzerdir. Aşağıda her iki arayüzdeki yaratıcı fonksiyonların isimleri verilmiştir:

    Sistem 5 IPC Fonksiyonları                    POSIX IPC Fonksiyonları

    msgget    (mesaj kuyruğu                    mq_open        (mesaj kuyruğu)
    shmget    (paylaşılan bellek alanları)            shm_open    (paylaşılan bellek alanları)
    semget    (semaphore'lar)                    sem_open    (semaphore'lar)

    Pekiyi mademki klasik (Sistem 5) IPC nesneleri 70'lerden beri kullanılmaktadır ve oldukça taşınabilir durumdadır. O halde neden 90'lı yıllarda 
    yeni bir arayüz gereksinimi duyulmuştur? İşte bunun nedeni klasik IPC nesnelerinin genel tasarımında olan bazı problemlerdir. POSIX IPC 
    nesneleriyle bu problem giderilmeye çalışılmıştır. POSIX IPC nesneleri Linux çekirdeğine çok sonraları eklenmiştir. Hala bazı UNIX türevi sistemlerde
    bu fonksiyonlar tam desteklenmemektedir. Yani POSIX IPC nesneleri taşınabilirlik konusunda daha problemlidir. Gerçi seneler içerisinde 
    bu IPC nesneleri daha çok sistem tarafından desteklenmiştir ve bugünlerde bu taşınabilirlik problemi büyük ölçüde ortadan kalkmıştır.

    Bu IPC mekanizmalarının incelenmesi işlemi iki biçimde yapılabilir. Önce Klasik Sistem 5 IPC nesneleri görülüp sonra bunların POSIX IPC karşılıkları 
    incelenebilir ya da her IPC mekanizması ayrı ayrı klasik Sistem 5 ve POSIX karşılıkları incelenebilir. Biz bu kursumuzda ikinci yöntemi izleyeceğiz.

    Pekiyi biz programcı olarak hangi grup IPC fonksiyonlarını kullanmalıyız? İşte bu iki grubun birbirlerine göre amaca yönelik bazı avantajları ve dezavantajları
    söz konusu olmaktadır. Ancak artık programcıların özel bir durum yoksa modern POSIX IPC fonksiyonlarını tercih etmesi daha uygundur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Haberleşmeler biçimsel olarak "stream tabanlı" ve "mesaj (datagram) tabanlı" olmak üzere ikiye ayrılmaktadır. Stream tabanlı
    haberleşme denildiğinde yazan tarafın tek bir hamlede (örneğin write ile) yazdığını okuyan tarafın tek hamlede (tek bir read ile)
    okumasının zorunlu olmadığı kastedilmektedir. Örneğin bir proses tek hamlede haberleşme kanalına 100 byte göndermiş olabilir. 
    Stream tabanlı haberleşmede okuma yapan taraf bu 100 byte'ı tek hamlede değil birden fazla okuma yaparak elde edebilir. 
    Yani stream tabanlı haberleşmede okuyan taraf haberleşme kanalından istediği kadar byte okuyabilmektedir. Burada "stream" terimi
    "dere, pınar, su akışı" anlamlarından hareketle uydurulmuştur. Mesaj (datagram) haberleşmelerde ise gönderen taraf bir grup byte'ı
    mesaj adı altında tek hamlede gönderir. Okuyan taraf bunu tek hamlede okumak zorundadır. Örneğin yazan taraf mesaj adı altında 
    haberleşme kanalına 100 byte göndermiş olabilir. Bu 100 byte'lık paketi diğer taraf parça parça okuyamaz. Tek hamlede okumak zorundadır. 
    Yani okuyan taraf bu paketi ya okumaz ya da okursa hepsini okur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Borulardaki haberleşme "stream tabanlı" haberleşmeye tipik bir örnektir. Örneğin biz boruya 100 byte yazdığımızda okuyan taraf bu 
    100 byte'ı tek hamlede okumak zorunda değildir. Örneğin bunu 10'ar 10'ar byte okuyabilir. Oysa mesaj kuyrukları ismi üzerinde mesaj 
    tabanlı haberleşme sağlamaktadır. Yani mesaj kuyruklarında kuyruğa yazan taraf "mesaj" adı altında bir grup byte'ı 
    bir paket olarak yazar. Okuyan taraf da bunu bir paket olarak tek hamlede okur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 IPC mekanizmasında iki farklı prosesin aynı IPC nesnesi üzerinde anlaşabilmesi için "anahtar (key)" ve "id" 
    kavramları kullanılmaktadır. Bu arayüzlerde xxxget fonksiyonlarına programcı bir anahtar verir. Bu anahtar sayısal bir değerdir. 
    İki proses aynı anahtarı verirse aynı nesneyi kullanırlar. Bu xxxget fonksiyonları verilen anahtara ilişkin bir id geri döndürmektedir. 
    Bu id değeri aslında diğer fonksiyonlarda handle olarak kullanılmaktadır. Buradaki bir problem verilen anahtarın tesadüfen sistemdeki başka bir 
    prosesle çakışabilmesidir. Bunun için bazı kontrollerin yapılması gerekebilmektedir. xxxget fonksiyonlarının verdiği id değerleri 
    sistem genelinde "tek (unique)" bir değerdir. Yani aslında bu id değeri, diğer prosese prosesler arası haberleşme yöntemleriyle gönderilse 
    diğer proses hiç xxxget işlemi yapmadan doğrudan bu id değerini kullanabilir. Başka bir deyişle birden fazla proses xxxget fonksiyonlarında 
    aynı anahtarı verdiklerinde aslında aynı id'yi elde etmektedir.

    Klasik Sistem 5 IPC mekanizmasında xxxget fonksiyonlarında kullanılan anahtarlar aslında IPC nesnesinin türüne göre ayrı bir isim alanındadır. 
    Yani 12345 gibi bir anahtar paylaşılan bellek alanları için ayrı bir anahtar, mesaj kuyrukları için ayrı bir anahtar durumundadır.

    Klasik Sistem 5 IPC nesneleri yaratıldıktan sonra xxxctl fonksiyonu ile yok edilene kadar ya da sistem reboot edilene kadar yaşamaktadır. 
    Bu duruma bu terminolojide "kernel persistancy" denilmektedir. Halbuki örneğin borular öyle değildir. Bir isimli boru yaratılmış ve bir 
    proses onu açıp onun içerisine bir şeyler yazmış olsun. Prosesler boruyu kapatınca artık borunun içerisindekiler yok olur. 
    Halbuki klasik Sistem 5 IPC nesnelerinde bir proses IPC nesnesini silmedikten sonra reboot edilene kadar nesnenin içerisindeki bilgiler 
    kalmaya devam etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 (XSI) mesaj kuyruklarında dört fonksiyon vardır: msgget, msgsnd, msgrcv ve msgctl fonksiyonları. msgget fonksiyonu mesaj kuyruğunu 
    yaratır ya da yaratılmış olanı açar. msgget fonksiyonunu open fonksiyonuna benzetebiliriz. Mesaj kuyruğuna bir grup byte'ı mesaj olarak 
    yerleştirmek için msgsnd fonksiyonu, mesaj kuyruğundan mesaj almak için msgrcv fonksiyonu ve mesaj kuyruğu üzerinde silme de dahil olmak üzere
    bazı diğer işlemleri yapabilmek için msgctl fonksiyonu kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 mesaj kuyrukları msgget fonksiyonuyla yaratılabilir ya da zaten var olan mesaj kuyrukları msgget fonksiyonuyla
    kullanım için açılabilir. Fonksiyonun prototipi şöyledir:

    #include <sys/msg.h>

    int msgget(key_t key, int msgflg);

    Fonksiyonun birinci parametresi tamsayı biçiminde bir anahtar belirtmektedir. Fonksiyonun ikinci parametresinde şu bayraklar kullanılabilir:

    IPC_CREAT: Burada ilgili anahtara ilişkin bir mesaj kuyruğu varsa olan mesaj kuyruğu açılır ancak yoksa yeni bir mesaj kuyruğu 
    yaratılır. Buradaki semantik open fonksiyonundaki O_CREAT semantiğine benzemektedir.

    IPC_EXCL: Bu bayrak tek başına değil IPC_CREAT ile birlikte IPC_CREAT|IPC_EXCL biçiminde kullanılabilir. Semantik open fonksiyonundaki
    O_EXCL bayrağındaki gibidir. Yani daha önce başka kişiler tarafından aynı anahtara ilişkin bir mesaj kuyruğu zaten yaratılmışsa 
    msgget fonksiyonu bu durumda başarısız olur ve EEXIST ile set edilir.

    Eğer IPC_CREAT kullanılmazsa zaten var olan anahtara ilişkin mesaj kuyruğunun açılmak istendiği anlaşılmaktadır. Bu parametre 
    0 olarak da girilebilir.

    Eğer mesaj kuyruğunun yaratılma olasılığı varsa (yani IPC_CREAT bayrağı belirtilmişse) aynı zamanda oluşturulacak mesaj kuyruğu için 
    erişim haklarının da programcı tarafından belirtilmesi gerekir. Mesaj kuyrukları bir dosya olmasa da sanki dosya gibi erişim haklarına sahiptir. 
    Dolayısıyla erişim hakları için yine <sys/stat.h> içerisindeki S_IXXX sembolik sabitleri ya da bunların sayısal değerleri kullanılır. 
    Bu erişim haklarının IPC_CREAT ve IPC_EXCL ile bitsel OR işlemine sokulması gerekmektedir. Örneğin:

    msgid = msgget(0x12345, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Anımsanacağı gibi POSIX 2008 standardı ile bu S_IXXX sembolik sabitlerine sayısal değerler de karşılık getirilmişti. O halde POSIX 2008 
    ve sonrasında bu işlemi şöyle de yapabiliriz:

    msgid = msgget(0x12345, IPC_CREAT|0644);

    Tabii anahtara ilişkin mesaj kuyruğu zaten varsa buradaki erişim haklarının ve O_CREAT bayrağının hiçbir etkisi yoktur. Erişim hakları, 
    nesne gerçekten yaratılacaksa kullanılmaktadır.

    msgget fonksiyonunda (diğer xxxget fonksiyonlarında da böyle) birinci parametre olan anahtar IPC_PRIVATE olarak girilirse 
    bu durumda kullanılmayan bir anahtar oluşturulup mesaj kuyruğu yaratılır. msgget fonksiyonu da bu mesaj kuyruğunun id değerine
    geri döner. Örneğin:

    msgid = msgget(IPC_PRIVATE, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Burada olmayan bir anahtardan hareketle mesaj kuyruğu yaratıldığı için bir çakışma söz konusu olmayacaktır. Tabii bu durumda 
    bu id değerinin (anahtarı bilmiyoruz) diğer prosese aktarılması gerekmektedir. Bu aktarım da olsa olsa komut satırı argümanıyla 
    ya da başka bir prosesler arası haberleşme yöntemiyle olabilir. IPC_PRIVATE anahtarı makul gibi gözükse de genel olarak kullanışsızdır.

    Bir program mesaj kuyruğunu yaratıp sonlanabilir. Bu durumda yukarıda da belirttiğimiz gibi mesaj kuyruğu yaratılmış biçimde 
    kalmaya devam eder. Ta ki msgctl fonksiyonu ile silinene kadar ya da sistem reboot edilene kadar.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                41. Ders 26/03/2023 Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte program belli bir anahtar kullanarak klasik Sistem 5 mesaj kuyruğunu yaratmıştır. Aynı anahtarı kullanan 
    başka bir proses aynı mesaj kuyruğunu açabilir. Bu durumda aynı anahtarı kullanan proseslerin hepsi aynı id'yi elde eder. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

void exit_sys(const char *msg);

int main(void)
{
    int msgid;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    O anda yaratılmış olan klasik Sistem 5 IPC nesnelerini (mesaj kuyrukları, paylaşılan bellek alanları ve semaphore'lar) 
    komut satırından görüntülemek için "ipcs" isimli komut kullanılmaktadır. Örneğin:

    ----- İleti Kuyrukları -----
    anahtar    iltkiml    sahibi     izinler    kull-bayt    ileti-sayısı
    0x01234567 0          kaan       644        0            0

    ----- Paylaşımlı Bellek Bölütleri -----
    anahtar    shmid      sahibi     izinler    bayt       ekSayısı durum
    0x00000000 18         kaan       600        4194304    2          hedef
    0x00000000 21         kaan       600        524288     2          hedef
    0x00000000 22         kaan       600        67108864   2          hedef
    0x00000000 26         kaan       600        524288     2          hedef
    0x00000000 458815     kaan       600        4194304    2          hedef

    ----- Semafor Dizileri -----
    anahtar    semkiml    sahibi     izinler    semSayısı

    Bu komut anahtarları hex sistemde yazdırmaktadır. Bizim anahtarları hex olarak vermemize gerek yoktur. ipcs komutu 
    default olarak tüm IPC nesnelerini görüntülemektedir. Ancak -q komut satırı argümanıyla yalnızca mesaj kuyrukları,
    -m komutuyla yalnızca paylaşılan bellek alanları ve -s komutuyla da yalnızca semaphore nesneleri görüntülenebilir. 
    Örneğin:

    $ ipcs -q

    ----- İleti Kuyrukları -----
    anahtar    iltkiml    sahibi     izinler    kull-bayt    ileti-sayısı
    0x01234567 0          kaan       644        0            0

    Aslında Linux çekirdeği IPC nesneleri yaratıldığında onların bilgilerini proc dosya sisteminde "/proc/sysvipc" dizini 
    içerisinde msg, sem, shm dosyalarının içerisine yazmaktadır. ipcs komutu da zaten bu dosyaların içindekilerini görüntülemektedir.

    Not: proc dosya sistemi bellekte oluşturulan, kernel tarafından bir dosya sistemi gibi sürekli güncellenen ve çekirdeğin 
    yaptığı önemli işlemleri dış dünyaya bildirmek amacıyla kullanılan özel bir dosya sistemidir. Kursumuzda proc dosya sistemi 
    ileride ayrı bir bölümde ele alınacaktır. proc dosya sisteminde bazı dosyalar yazılabilir durumda da olabilmektedir. Bu 
    durumda bu dosyalara yazma yapıldığında çekirdeğin bazı ayarları da değiştirilmiş olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğuna bir mesaj göndermek için msgsnd POSIX fonksiyonu kullanılır. Fonksiyonun prototipi şöyledir:

    #include <sys/msg.h>

    int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

    Fonksiyonun birinci parametresi mesaj kuyruğunun msgget fonksiyonundan elde edilen id değeridir. (Tabii id değerleri sistem genelinde
    tektir (unique). Dolayısıyla proses mesaj kuyruğunun id değerini biliyorsa anahtardan hareketle id elde etmek zorunda değildir.)
    Fonksiyonun ikinci ve üçüncü parametreleri mesajı oluşturan byte yığınının adresini ve uzunluğunu almaktadır. Son parametre, gönderim 
    ile ilgili bazı ayrıntıları belirten flag değerleridir. Normal olarak mesaj kuyruğu doluysa (mesaj kuyruğunun bazı limitleri vardır)
    msgsnd bloke oluşturmaktadır. Eğer mesaj kuyruğu dolu olduğu halde bloke oluşmasın isteniyorsa (yani blokesiz işlem yapılmak isteniyorsa)
    bu durumda fonksiyonun son parametresine IPC_NOWAIT özel değeri geçirilir. Eğer bu değer geçilmeyecekse bu parametre 0 olarak girilebilir.
    (Sistem 5 mesaj kuyruklarında işlem yapmak O_NONBLOCK gibi bir bayrakla değil, IPC_NOWAIT bayrağı ile yapılmaktadır.)

    Fonksiyonun ikinci parametresine, mesajı oluşturan byte topluluğunun adresinin girileceğini belirtmiştik. Üçüncü parametre de 
    mesaj uzunluğunu belirtmekteydi. İşte mesaj aslında şöyle oluşturulmak zorundadır: Mesajın başında long bir alan olmalıdır. 
    Bu long alan mesajın türünü (önceliğini de diyebiliriz) belirtmektedir. Bu mesaj türü 0'dan büyük pozitif bir değer biçiminde girilmelidir. 
    Bu long alandan sonra mesajın byte'ları gelmelidir. Bu long alan ile mesaj byte'ları ardışıl olmalıdır. Bunu sağlamak için programcı tipik 
    olarak bir yapı oluşturur. Örneğin:

    struct MSG {
        long mtype;
        char msg[1024];
    };

    struct MSG msg;

    Burada yapının msg elemanı (yani long kısımdan sonra gelen kısmını temsil eden kısım) için 1024 byte yer ayrılmıştır. 
    Gönderilecek mesaj 1024 byte'tan daha kısa ise burada gereksiz boş alan kalır. 1024'ten daha yüksek bir mesajı bu yapıya yerleştiremeyiz. 
    Bu sorun için ilk akla gelen yöntem yapının mesaj uzunluğuna bağlı olarak dinamik bir biçimde tahsis edilmesidir. 
    Tabii long alandan sonraki adresi pratik bir biçimde elde edebilmemiz için yine long alandan sonra 1 byte uzunlukta 
    bir dizi bulundurabiliriz:

    struct MSG {
        long mtype;
        char msg[1];
    };

    Şimdi mesajın n byte uzunlukta olduğunu tespit etmiş olalım (kontroller koddan kaldırılmıştır):

    struct MSG *msg;

    msg = (struct MSG *)malloc(sizeof(long) + n)
    msg->mtype = 1;
    memcpy(msg->msg, mesage_content);
    ...
    free(msg);

    C99 ve sonrasında bir yapının son elemanı dizi ise o elemanda uzunluk belirtilmeyebilmektedir. Buna C standartlarında "flexible array member" denilmektedir. 
    Örneğin:

     struct MSG {
        long mtype;
        char msg[];
    };

    Tabii derleyici için bu msg elemanı yalnızca bir yer tutucudur. Bunun için bir yer tahsis etmez.

    Tabii bu işlem biraz zahmetlidir. Bu nedenle genellikle programcılar baştan maksimum mesaj uzunluğunu tespit edip buna uygun bir yapı bildirirler. 
    Örneğin kullanılacak maksimum mesaj uzunluğu 8192 olsun:

     struct MSG {
        long mtype;
        char msg[8192];
    };

    msgsnd fonksiyonundaki üçüncü parametre olan mesaj uzunluğuna mesajın başındaki long alan dahil değildir. Yalnızca mesajın kendi 
    uzunluğu dahildir. Yani msgsnd fonksiyonunu kullanırken biz mesaj uzunluğu olarak gerçek mesajın uzunluğunu veririz.

    Pekiyi mesajın türü ne anlamakta gelmektedir? Mesajın türü iki nedenden dolayı kullanılmaktadır:

    1) Mesajı alan taraf spesifik bir türe ilişkin mesajları alabilir. Örneğin alan taraf türü 10 olan mesajları alırsa 
    kuyruktaki diğer mesajları pas geçer ve ilk 10 türüne sahip olan mesajı alır. Bu da client-server tarzı uygulamalarda 
    tek bir mesaj kuyruğunun kullanılmasını mümkün hale getirmektedir.

    2) Mesajın türü istenirse "öncelik kuyruğu (priority queue)" gibi de kullanılmaktadır.

    Mesaj kuyruklarının tıpkı borularda olduğu gibi belli bir limiti vardır. Bu limite gelindiğinde msgsnd fonksiyonu 
    default olarak bloke olur ve mesaj kuyruğunda yer açılana kadar blokede kalır. Böylece tıpkı borularda olduğu gibi bir senkronizasyon 
    da sağlanmış olmaktadır. Ancak yukarıda da belirttiğimiz gibi msgsnd fonksiyonunun son parametresi IPC_NOWAIT girilirse 
    bu durumda mesaj kuyruğunun limiti dolmuşsa msgsnd fonksiyonu blokeye yol açmaz -1 değeri ile geri döner ve errno değişkeni de 
    EAGAIN değeriyle set edilir.

    msgsnd fonksiyonu başarısızlık durumunda -1 değeri ile geri döner. Mesaj kuyruğu doluysa ve bloke oluşmuşsa zaten henüz geri dönmez. 
    Başarı durumunda fonksiyon 0 ile geri dönmektedir.

    Aşağıdaki programda 1000000 tane int değer mesaj kuyruğuna bir mesaj biçiminde msgsnd fonksiyonuyla yazılmak istenmiştir. 
    Tabii mesaj kuyruğunun limitleri dolacağı için bu mesajların hepsi kuyruğa yazılamayacaktır. Dolayısıyla IPC_NOWAIT parametresi de 
    geçilmediğine göre bloke oluşacaktır. Bu programda mesaj türü (yapının mtype alanı) 1 olarak alınmıştır. Mesaj türü zaten 0 olamaz. 
    Eğer mesaj türüyle programcı ilgilenmeyecekse onu herhangi bir değerde tutabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    int val;
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (int i = 0; i < 1000000; ++i) {
        msg.mtype = 1;
        msg.val = i;

        if (msgsnd(msgid, &msg, sizeof(int), 0) == -1)
            exit_sys("msgsnd");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 mesaj kuyruklarından mesaj okumak için msgrcv fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/msg.h>

    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

    Fonksiyonun birinci parametresi mesaj kuyruğunun id'sini belirtmektedir. Fonksiyonun ikinci ve üçüncü parametreleri kuyruktan alınan 
    mesajın yerleştirileceği alanın adresini ve uzunluğunu almaktadır. Yine buraya geçirilecek adresin ilk byte'larında long 
    bir alan bulunmalıdır. Mesaj bu long alandan sonraki yere yerleştirilir. Dolayısıyla programcı genellikle yine ikinci parametreye
    geçirilecek adresi bir yapı olarak oluşturur. Örneğin:

    struct MSG {
        long mtype;
        char msg[8192];
    };

    struct MSG msg;

    Burada fonksiyonun ikinci parametresine bu yapı nesnesinin adresi geçirilir. Fonksiyon kuyruktaki mesajın türünü ve içeriğini 
    bu yapıya yerleştirecektir. Fonksiyonun üçüncü parametresinde belirtilen uzunluk long alandan sonraki gerçek mesajın uzunluğudur. 
    Örneğin:

    result = msgrcv(msgid, &msg, 8192, ...);

    Fonksiyonun dördüncü parametresi hangi türe ilişkin mesajların alınacağını belirtmektedir. Kuyrukta farklı tür numaralarına (mtype)
    sahip mesajlar bir arada bulunuyor olabilir. Dördüncü parametre bunların alınış biçimini belirtmektedir. Bu parametre 0 olarak girilirse 
    bu durumda msgrcv kuyruktaki tür değeri ne olursa olsun ilk mesajı alır. (0 değerinin geçerli bir tür değeri belirtmediğine dikkat ediniz.)
    Eğer bu parametreye biz 0'dan büyük bir değer girersek bu durumda o tür değerine sahip ilk mesaj kuyruktan alınır. Örneğin biz bu parametreye 
    100 girmiş olalım. Kuyrukta da 100 tür değerine sahip kuyruğun farklı yerlerinde 4 tane mesaj olsun. Biz bu durumda 100 tür değerine sahip
    kuyrukta en önceki mesajı alırız. Bu sayede biz kuyrukta belli bir tür değerine sahip mesajları elde edebilmekteyiz. Eğer bu parametre 
    negatif bir değer olarak girilirse bu durumda bu negatif değerin mutlak değerine eşit ya da ondan küçük olan en küçük mesaj tür değerine sahip 
    kuyruktaki ilk mesaj elde edilir. Örneğin kuyruktaki mesajların da mesaj tür değerleri şöyle olsun:

    20 5 30 2 8 40

    Şimdi biz msgrcv fonksiyonu bir döngü içerisinde dördüncü parametresi -10 olacak biçimde çağrımış olalım. -10 değerinin mutlak değeri 10'dur. 
    10'dan küçük ya da 10'a eşit olan en küçük tür değerine sahip olan mesaj 2 tür değerine sahip mesajdır. O halde kuyruktan önce bu mesaj alınacaktır. 
    Sonra 5 tür değerine sahip olan mesaj sonra da 8 tür değerine sahip olan mesaj alınacaktır. Sonra koşula uygun kuyrukta mesaj kalmayacağına göre msgrcv artık 
    bloke olacaktır. Fonksiyonun dördüncü parametresi negatif girildiğinde, artık kuyruk adeta bir öncelik kuyruğu gibi ele alınmaktadır. 
    Ancak burada mesaj türü değeri küçük olanlar daha öncelikli kabul edilmektedir.

    msgrcv fonksiyonunun son parametresi (msgflg) mesajın alımına ilişkin bazı özellikleri belirtir. POSIX standartlarına göre buradaki bayrak değerleri 
    iki bayraktan oluşabilir (bu iki bayrak birlikte bulunabilir):

    IPC_NOWAIT: Bu durumda blokesiz alım yapılmaktadır. Yani kuyrukta uygun mesaj yoksa msgrcv başarısız olur ve -1 değeri ile geri döner, 
    errno değeri EAGAIN olarak set edilir.

    MSG_NOERROR: Normal olarak alınan mesajın uzunluğu msgrcv fonksiyonunun üçüncü parametresinde belirtilen tampon uzunluğundan büyükse
    msgrcv başarısız olur ve errno değeri E2BIG değeri ile set edilir. Ancak son parametrede MSG_NOERROR bayrağı kullanılırsa bu durumda
    msgrcv başarılı olur ancak kuyruktaki mesaj kırpılarak verdiğimiz tampona yerleştirilir.

    Programcı son parametre için özel bir bayrak belirlemek istemiyorsa bu parametreyi 0 olarak geçebilir.

    msgrcv fonksiyonu başarı durumunda okunan mesajın byte uzunluğu ile başarısızlık durumunda -1 ile geri dönmektedir. Okunan mesajın 
    byte uzunluğuna long alan dahil değildir.

    Burada özellikle bir noktayı vurgulamak istiyoruz: Klasik Sistem 5 mesaj kuyruklarında karşı tarafın mesaj kuyruğunu kapatması diye bir 
    durum yoktur. Dolayısıyla borularda olduğu gibi 0 byte okunana kadar yinelenen bir döngü oluşturulamamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğundan sürekli mesaj okuyan programları yazarken dikkat ediniz. Çünkü bu programlar kuyrukta uygun mesaj olmadığı 
    zaman blokeye yol açarlar. Örneğin:

    for (;;) {
        if (msgrcv(msgid, &msg, sizeof(int), 0, 0) == -1)
            exit_sys("msgrcv");

        printf("Message type: %ld\n", msg.mtype);
        printf("Message content: %d\n", msg.val);
    }

    Burada msgrcv kuyruktaki mesajları alıp bitirdikten sonra artık kuyrukta mesaj yoksa bloke oluşacaktır. Pekiyi bu durumda 
    bu program nasıl döngüden çıkacaktır? Tabii en normal durum kuyruktan alınan mesajın incelenip özel bir mesaja göre döngüden çıkmak olabilir. 
    Eğer kuyruktaki tüm mesajların alınıp döngüden çıkılması isteniyorsa bu durumda blokesiz okuma yoluna gidilebilir. Örneğin:

    while (msgrcv(msgid, &msg, sizeof(int), 0, IPC_NOWAIT) != -1)
        printf("Message type: %ld\n", msg.mtype);
        printf("Message content: %d\n", msg.val);
    }
    if (errno != EAGAIN)
        exit_sys("msgrcv");

    Aşağıdaki örnekte prog1 programı mesaj kuyruğuna 0'dan 1000000'a kadar değerleri mesaj olarak yerleştirmektedir. Mesajın tür
    değeri programlar tarafından kullanılmadığı için 1 olarak geçilmiştir. prog2 programı bu değerleri kuyruktan almış 1000000 
    değerini gördüğünde o da kendini sonlandırmıştır.

    Mesaj kuyruklarında close tarzı bir işlem yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    int val;
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    msg.mtype = 1;
    for (int i = 0; i <= 1000000; ++i) {
        msg.val = i;

        if (msgsnd(msgid, &msg, sizeof(int), 0) == -1)
            exit_sys("msgsnd");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    int val;
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        if (msgrcv(msgid, &msg, sizeof(int), 0, 0) == -1)
            exit_sys("msgrcv");

        if (msg.val == 1000000)
            break;
        printf("Message type: %ld\n", msg.mtype);
        printf("Message content: %d\n", msg.val);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte prog1.c programı klavyeden (stdin dosyasından) alınan yazıları sonunda null karakter dahil olmak 
    üzere mesaj kuyruğuna yazmaktadır. Klavyeden "quit" girildiğinde bu mesaj da mesaj kuyruğuna yazılır ve prog1.c programı 
    sonlanır. prog2.c programı da kuyruktan mesajları alarak onları ekrana (stdout dosyasına) yazdırmaktadır. Programlarda yine 
    mesajın tür değeri kullanılmamaktadır, 1 biçiminde kodlanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;
    char *str;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    msg.mtype = 1;
    for (;;) {
        printf("Message text:");
        fflush(stdout);

        if (fgets(msg.buf, 8192, stdin) == NULL)
            continue;
        if ((str = strchr(msg.buf, '\n')) != NULL)
            *str = '\0';

        if (msgsnd(msgid, &msg, strlen(msg.buf) + 1, 0) == -1)
            exit_sys("msgsnd");
        if (!strcmp(msg.buf, "quit"))
            break;
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
            exit_sys("msgrcv");

        if (!strcmp(msg.buf, "quit"))
            break;

        printf("Message text: %s\n", msg.buf);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte prog1.c programı döngü içerisinde önce mesaj tür değerini sonra da mesaj yazısını alıp kuyruğa yollamıştır. 
    prog2.c ise msgrcv fonksiyonunda dördüncü parametrede -100 kullanarak en düşük mesaj tür değeri önce alınacak biçimde 
    mesajları kuyruktan almıştır. Bu örnekte önce prog1 programını çalıştırınız. quit mesajına düşük bir öncelik (yüksek değer) veriniz.
    Sonra prog2 programını çalıştırarak sonuçları gözden geçiriniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);
void clear_stdin(void);

int main(void)
{
    int msgid;
    struct MSG msg;
    char *str;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        printf("Message type:");
        scanf("%ld", &msg.mtype);

        clear_stdin();

        printf("Message text:");
        fflush(stdout);

        if (fgets(msg.buf, 8192, stdin) == NULL)
            continue;
        if ((str = strchr(msg.buf, '\n')) != NULL)
            *str = '\0';

        if (msgsnd(msgid, &msg, strlen(msg.buf) + 1, 0) == -1)
            exit_sys("msgsnd");
        if (!strcmp(msg.buf, "quit"))
            break;
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void clear_stdin(void)
{
    while (getchar() != '\n')
        ;
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY        0x1234567

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        if (msgrcv(msgid, &msg, 8192, -100, 0) == -1)
            exit_sys("msgrcv");

        if (!strcmp(msg.buf, "quit"))
            break;

        printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mesajların type değerinin kullanıldığı tipik örnekler client-server tarzı haberleşme örnekleridir. Şimdi mesaj kuyrukları 
    kullanılarak client-server tarzı bir haberleşme yapmak isteyelim. Bu haberleşmede client'ların server'dan istekte bulunması 
    için tek bir mesaj kuyruğu yeterlidir. Benzer biçimde server'ın da client'lara yanıtı geri döndürmesi için toplamda tek bir 
    mesaj kuyruğu yeterlidir. (Anımsanacağı isimli borularda, server yanıtları iletirken mecburen her client için ayrı bir isimli 
    boru kullanıyordu.) Haberleşmenin sistematiği şöyle olabilir:

    - Client programlar kendi proses id'lerini mesaj tür bilgisi olarak kullanıp mesajı önceden belirlenmiş mesaj kuyruğuna gönderir. 
    Bu mesaj kuyruğuna "server mesaj kuyruğu" diyelim.

    - Server program server mesaj kuyruğundan sıraki mesajı okur. (msgrcv fonksiyonunun dördüncü parametresi 0 olarak girilirse 
    kuyruktan sıradaki mesajlar okunmaktadır.) Bunun hangi client'tan geldiğini anlar. İşlemi yapar. İşlemin sonucunu "client mesaj kuyruğu"
    diye isimlendirdiğimiz mesaj kuyruğuna bir mesaj olarak yollar. Ancak yolladığı mesajın tür değeri client'ın proses id değeridir.

    - Mesajı gönderen client program, client mesaj kuyruğundan mesaj tür bilgisi kendi proses id'si olacak biçimde msgrecv fonksiyonu 
    ile yanıtı elde eder.

    Burada da görüldüğü gibi client programların hepsi ortak bir mesaj kuyruğundan server yanıtlarını alabilmektedir. Eğer mesaj kuyruğunun 
    böyle bir tür değeri olmasaydı ve mesaj kuyruğundan belli bir tür değerine ilişkin mesaj okunamasaydı bu durum mümkün olamazdı.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                42. Ders 01/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında klasik Sistem 5 mesaj kuyruklarıyla client-server haberleşme programı yazılırken tek bir kuyruk da kullanılabilir. 
    Örneğin bu durumda client'lar yine kendi proses id'lerini mesaj tür değeri yaparak kuyruğa server için mesaj bırakır. 
    Server da mesajı işledikten sonra bu kez yanıtı ilgili prosesin id'sini mesaj tür bilgisi yaparak kuyruğa yazar. Client da 
    kuyruktan kendi mesaj tür bilgisiyle okuma yapabilir. Ancak tek bir kuyruğun kullanılması aslında iyi bir yöntem değildir. 
    Bu durum haberleşmeyi çok kırılgan hale getirmektedir. Şöyle ki:

    - Bu durum "kilitlenme (deadlock)" denilen soruna kolaylıkla yol açabilmektedir. Mesaj kuyruklarının bir kapasitesi vardır. 
    Kuyruk dolduğunda blokeli yazmalarda kuyruğa mesaj yazacak taraf bloke olmaktadır. Bu senaryoda server bir client'ın isteğini 
    karşılamak için mesaj kuyruğuna yanıt mesajını yazacağı zaman diğer client'lar istek yaparak mesaj kuyruğunu doldurmuş olabilir. 
    Bu durumda ne client'lar kuyruğa mesaj yazabilir ne de server herhangi bir yanıtı kuyruğa yazabilir. İşte bu durum tipik 
    bir "kilitlenme (deadlock)" durumudur.

    - Bu modelde client ilk kez server'a kendi proses id'si ile mesaj gönderirken aynı kuyruğa mesajı yazacağı için birazdan 
    aynı proses id ile kuyruktan mesaj almaya çalışırken kendi yazdığı mesajı alabilir. Tabii bunu engellemenin çeşitli yolları da 
    vardır. Örneğin böylesi bir durumda server elde ettiği proses id'nin başına bir bilgi ekleyebilir. Client da okumasını buna göre yapabilir.

    - Bu model, kilitlenme durumu aşılsa bile yavaş olmaktadır. Çünkü kuyrukların bir kapasitesi vardır. Bu kapasite dolduğunda blokeler
    haberleşmeyi yavaşlatabilmektedir.

    İlk açıkladığımız, iki kuyruklu modelde her ne kadar "kilitlenmeye daha dirençliyse" kırılgan bir yapı oluşturabilmektedir. 
    Şöyle ki, belli bir client kuyruktan bilgi okumazsa (kasten bunu yapabilir ama client programı da biz yazıyorsak bunu kasten yapmayız)
    kuyruk dolabilir yine bir kilitlenme oluşabilir. Tabii client program neden kuyruktan mesaj okumayacaktır? Client program da bizim 
    tarafımızdan yazıldığına göre genellikle böyle bir şey olmaz. Ancak client programların başka yerlerinde yanlış bir teknik yüzünden bir bloke oluşsa
    onlar mesajlarını kuyruktan alamayabilirler. Bu durum diğer client'ları olumsuz etkileyebilir.

    O halde mesaj kuyruklarıyla client-server haberleşme daha sağlam yapılacaksa yine her client için ayrı bir mesaj kuyruğu kullanılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında mesaj kuyruklarına 0 byte'lık mesajlar da gönderilebilir. Bu durumda kuyruğa yine mesaj yazılır. Mesajın tür değeri yine
    0 byte'lık mesajı gönderen kişinin belirlediği tür değeri olarak mesajı okuyan kişi tarafından elde edilmektedir. Yani 0 byte'lık 
    mesajlar yine kuyruğa bir mesaj gibi yazılmaktadır. Bu tür mesajların uzunluğu çekirdek tarafından 1 byte mesajlarmış gibi ele alınmaktadır. 
    Böylece çekirdek sonsuz döngü içerisinde 0 byte mesaj gönderme durumunda mesaj kuyruğunun belli bir süre sonra dolmasına yol açmaktadır. 
    Pekiyi 0 byte'lık mesajlar neden gönderilebilir? İşte genellikle 0 byte uzunluğunda mesajlar "iletişimi sonlandırmak amacıyla" 
    gönderilmektedir. Tabii bazen gönderilecek mesaj gerçekten bir bilgi içermeyip yalnızca bir tür değeri de içeriyor olabilir.

    Aşağıdaki örnekte prog1 programı klavyeden (stdin dosyasından) aldığı yazıyı mesaj kuyruğuna yazmakta prog2 programı da bunu mesaj kuyruğundan 
    okumaktadır. İletişim sonlandırılacağı zaman prog1 kuyruğa 0 uzunlukta özel bir mesaj tür değeri olan QUIT_MSG mesajını bırakır. 
    prog2 programı da bu özel mesaj tür değerini aldığında işlemini sonlandırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY                0x1234567
#define NORMAL_MSG            1
#define QUIT_MSG            2

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;
    char *str;
    size_t len;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        printf("Message text:");
        fflush(stdout);

        if (fgets(msg.buf, 8192, stdin) == NULL)
            continue;
        if ((str = strchr(msg.buf, '\n')) != NULL)
            *str = '\0';

        if (!strcmp(msg.buf, "quit")) {
            msg.mtype = QUIT_MSG;
            len = 0;
        }
        else {
            msg.mtype = NORMAL_MSG;
            len = strlen(msg.buf) + 1;
        }

        if (msgsnd(msgid, &msg, len, 0) == -1)
            exit_sys("msgsnd");

        if (msg.mtype == QUIT_MSG)
            break;
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY                0x1234567
#define NORMAL_MSG            1
#define QUIT_MSG            2

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;

    if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
            exit_sys("msgrcv");

        if (msg.mtype == QUIT_MSG)
            break;

        printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Sistem 5 IPC nesnelerinin önemli sorunlarından biri bunların anahtar (key) değerlerinin bir çakışma yaratabilmesidir. 
    Yani bizim belirlediğimiz anahtara ilişkin bir mesaj kuyruğu başkaları tarafından yaratılmış olabilir. Bu tür durumlarda 
    anahtar yerine IPC_PRIVATE özel değerinin kullanılabileceğini belirtmiştik. Ancak bu durumda da elde edilen id değerinin 
    diğer prosese iletilmesi gerekmekteydi. İşte anahtar çakışmasını azaltmak için ftok isimli bir POSIX fonksiyonundan faydalanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <sys/ipc.h>

    key_t ftok(const char *path, int id);

    Fonksiyonun birinci parametresi olan bir dosyanın yol ifadesini belirtmelidir. İkinci parametre kombine edilecek değeri belirtir. 
    İkinci parametrenin yalnızca düşük anlamlı bir byte'ı kombine işleminde kullanılmaktadır. Bu parametrenin düşük anlamlı byte'ının 
    0 olmaması gerekir. Fonksiyon eğer biz ona aynı yol ifadesini ve aynı id değerini veriyorsak bize aynı geri dönüş değerini verir. Eğer biz ona
    farklı bir yol ifadesi ve/veya farklı bir id veriyorsak o bize başka bir geri dönüş değeri verir. Fonksiyonun amacı, Sistem 5 IPC nesneleri için
    bir yol ifadesinden hareketle bir anahtar değerin sistem genelinde tek olacak biçimde (unique) oluşturulmasıdır. Böylece her proses
    anahtar üretmekte bu ftok fonksiyonunu kullanırsa ve ftok fonksiyonuna kendisine ilişkin bir yol ifadesi ve id değeri verirse sistem genelinde 
    çakışma olmaz.

    Her ne kadar ftok fonksiyonu sistem genelinde bir anahtar çakışmasını engellemek için düşünülmüşse de maalesef böyle bir 
    garantinin verilmesi mümkün değildir. Dosyanın yol ifadesi ve id değerinden hareketle bir tamsayı değerin (key_t değerinin) 
    sistem genelinde tek olacak biçimde üretilmesi mümkün değildir. Standartlar bile bunu garanti altına almamaktadır. Yani iki program
    farklı yol ifadesi ve id değeri verdiğinde bile aynı anahtar değerini elde edebilir (her ne kadar bu olasılık çok düşükse de).
    Libc kütüphanesindeki ftok fonksiyonu dosyanın inode numarasını, dosyanın içinde bulunduğu aygıtın numarasını ve bizim verdiğimiz id
    değerini kombine ederek bir değer üretmektedir. Bu üretim de çakışmama olasılığını sıfırlayamamaktadır. ftok fonksiyonunu kullanırken 
    dosyayı silip aynı isimle yeniden yaratırsak dosyanın inode numarası değişebileceğinden dolayı aynı değeri elde edemeyebiliriz.

    ftok fonksiyonu başarı durumunda ürettiği anahtar değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Pekiyi ftok fonksiyonu farklı yol ifadeleri ve/veya id'ler için farklı anahtar değeri üretmeyi garanti etmiyorsa bu fonksiyonun
    kullanımının anlamı var mıdır? Aslında bu soruya "yoktur" yanıtını verebiliriz. Ancak ftok fonksiyonundan hedeflenen şeylerden biri de
    anahtarın sayısal olmasından kurtulunup yazısal hale getirilmesidir. Fakat ne olursa olsun ftok fonksiyonun verdiği değer programcının 
    uyduracağı değerden daha iyi olma eğilimindedir (tabii herkes ftok kullanırsa).

    Aşağıda ftok kullanımına bir örnek verilmiştir. İki program da aynı yol ifadesi ve aynı ftok id'si ile ftok uygulamış ve aynı değeri 
    elde etmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME            "/home/kaan"
#define KEY_ID                123
#define NORMAL_MSG            1
#define QUIT_MSG            2

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;
    char *str;
    size_t len;
    key_t key;

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        printf("Message text:");
        fflush(stdout);

        if (fgets(msg.buf, 8192, stdin) == NULL)
            continue;
        if ((str = strchr(msg.buf, '\n')) != NULL)
            *str = '\0';

        if (!strcmp(msg.buf, "quit")) {
            msg.mtype = QUIT_MSG;
            len = 0;
        }
        else {
            msg.mtype = NORMAL_MSG;
            len = strlen(msg.buf) + 1;
        }

        if (msgsnd(msgid, &msg, len, 0) == -1)
            exit_sys("msgsnd");

        if (msg.mtype == QUIT_MSG)
            break;
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME            "/home/kaan"
#define KEY_ID                123
#define NORMAL_MSG            1
#define QUIT_MSG            2

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;
    key_t key;

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    for (;;) {
        if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
            exit_sys("msgrcv");

        if (msg.mtype == QUIT_MSG)
            break;

        printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruklarının sistemlerde o sisteme özgü çeşitli kapasite limitleri söz konusu olabilmektedir. POSIX standartları 
    bu kapasite limitleri konusunda bir açıklama yapmamıştır. Ancak Linux sistemlerinde çekirdek mesaj kuyrukları için 
    üç kapasite limiti belirlemektedir:

    1) MSGMAX Limiti: Bu limit bir mesaj kuyruğuna yazılabilecek mesajın, mesaj tür değeri haricindeki kısmının maksimum byte 
    uzunluğudur. Herhangi bir proses, bu değerin yukarısındaki uzunluktaki bir mesajı kuyruğa yerleştirememektedir. Linux sistemlerinde 
    bu değer default olarak şimdilik 8192'dir. Bu değer proc dosya sisteminde /proc/sys/kernel/msgmax dosyasında belirtilmektedir. Bu değer 
    bu dosyanın içeriği değiştirilerek değiştirilebilmektedir. Ancak bunu yapabilmek için prosesin uygun önceliğe sahip olması 
    (proses id'sinin 0 olması) gerekir.

    2) MSGMNI (Maximum Number of Id): Bu limit tüm sistemde yaratılacak farklı mesaj kuyruklarının maksimum sayısını belirtmektedir. 
    Bu sayı "/proc/sys/kernel/msgmni" dosyasından elde edilebilir. Linux sistemlerinde bunun default değeri şimdilik 32000'dir.

    3) MSGMNB (Maximum Number of Bytes): Bu değer bir mesaj kuyruğundaki mesajın tür değeri dışındaki tüm mesajlarının toplam maximum 
    byte sayısıdır. msgsnd fonksiyonu bu değer aşıldığında blokeli işlemlerde bloke olur. Bu değer /proc/sys/kernel/msgmnb dosyasından 
    elde edilebilir. Linux sistemlerinde bu değer şimdilik default durumda 16384'tür. Yani msgsnd fonksiyonu bu değer aşıldığında bloke 
    olur. Ancak bu değer eldeki RAM miktarına bağlı olarak çekirdek tarafından ayarlanabilmektedir.

    Buradaki limit değerleri çekirdek parametreleriyle ya da çekirdek derlenirken konfigürasyon parametreleriyle değiştirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 mesaj kuyruklarına ilişkin bazı kontrol işlemleri msgctl isimli POSIX fonksiyonu ile yapılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/msg.h>

    int msgctl(int msqid, int cmd, struct msqid_ds *buf);

    Fonksiyonun birinci parametresi mesaj kuyruğunun id değeridir. İkinci parametre uygulanacak işlemi belirtir. Bu uygulanacak işlem 
    şunlardan biri olabilir:

    IPC_STAT
    IPC_SET
    IPC_RMID

    Fonksiyonun üçüncü parametresi msqid_ds isimli yapı nesnesinin adresini almaktadır. Bu yapı <sys/msg.h> içerisinde tanımlanmıştır. 
    POSIX bu yapının olması gereken elemanlarını belirtmiştir. Linux sistemlerinde yapı şöyle bildirilmiştir:

    struct msqid_ds {
        struct ipc_perm msg_perm;   /* Ownership and permissions */
        time_t          msg_stime;  /* Time of last msgsnd(2) */
        time_t          msg_rtime;  /* Time of last msgrcv(2) */
        time_t          msg_ctime;  /* Time of creation or last
                                        modification by msgctl() */
        unsigned long   msg_cbytes; /* # of bytes in queue */
        msgqnum_t       msg_qnum;   /* # number of messages in queue */
        msglen_t        msg_qbytes; /* Maximum # of bytes in queue */
        pid_t           msg_lspid;  /* PID of last msgsnd(2) */
        pid_t           msg_lrpid;  /* PID of last msgrcv(2) */
    };

    Yapının msg_perm elemanı ipc_perm isimli yapı türünden nesnedir. ipc_perm yapısı da şöyle bildirilmiştir:

    struct ipc_perm {
        uid_t uid;                      /* Effective UID of owner */
        gid_t gid;                      /* Effective GID of owner */
        uid_t cuid;                     /* Effective UID of creator */
        gid_t cgid;                     /* Effective GID of creator */
        unsigned short mode;            /* Permissions */
    };

    Buradaki cuid ve cgid elemanları mesaj kuyruğunu ilk yaratan prosesin etkin kullanıcı ve grup id'sini belirtmektedir. Normal olarak 
    uid ve gid elemanları cuid ve cgid elemanlarıyla aynı değerdedir. Ancak daha sonra msgctl fonksiyonu ile bu değerler değiştirilebilmektedir. 
    Yapının mode elemanı da mesaj kuyruğunun erişim haklarını belirtmektedir. msqid_ds yapısının msg_stime, msg_rtime ve msg_ctime
    elemanları mesaj kuyruğuna en son yapılan msgsnd, msgrcv ve msgctl işlemlerinin zamanlarını belirtmektedir. Yapının msg_cbytes 
    elemanı (POSIX standartlarında bu eleman belirtilmemiştir, ancak Linux sistemlerinde bulunmaktadır) mesaj kuyruğundaki tüm mesajların
    mesajın tür değeri haricindeki kısımlarının byte uzunluğunu belirtmektedir. Yapının msg_qnum elemanı ise mesaj kuyruğundaki o anda 
    bulunan mesaj sayısını belirtir. Yapının msg_qbytes elemanı mesaj kuyruğunun tutabileceği mesaj tür değeri haricindeki kısımların 
    toplam byte sayısını belirtmektedir. Bu değer, mesaj kuyruğu yaratılırken Linux sistemlerinde MSGMNB değeri olarak yapıya aktarılmaktadır. 
    Yapının msg_lspid ve msg_lrpid elemanları sırasıyla kuyruğa son msgsnd yapan prosesin id değerini ve kuyruktan son msgrcv yapan prosesin 
    id değerini belirtmektedir.

    Yapı bildirimindeki msgqnum_t ve msglen_t tür isimleri <sys/msg.h> içerisinde işaretsiz bir tamsayı türü olarak (ama en azından unsigned short
    uzunlukta) bildirilmelidir.

    Bizim mesaj kuyruğuna mesaj yazabilmemiz için mesaj kuyruğuna "write" hakkına, mesaj kuyruğundan mesaj okuyabilmemiz için 
    mesaj kuyruğundan "read" hakkına sahip olmamız gerekir. Buradaki erişim kontrolü tıpkı dosyalarda olduğu gibi yapılmaktadır. 
    Ancak "owner" kontrolü burada msqid_ds yapısının msg_perm yapı elemanının uid elemanı ile ve "group" kontrolü ise aynı yapının 
    gid elemanı ile belirlenmektedir. Normal olarak yukarıda da belirttiğimiz gibi mesaj kuyruğu yaratıldığında ipc_perm yapısının 
    uid ve gid elemanları cuid ve cgid elemanlarıyla aynı değerdedir. Ancak daha sonra izleyen paragraflarda ele alacağımız üzere IPC_SET işlemi 
    ile bunlar farklılaşabilirler. Tabii mesaj kuyruğunun yaratıcısına ilişkin cuid ve cgid değerleri değiştirilememektedir.

    Fonksiyon başarı durumunda 0 değeri ile başarısızlık durumunda -1 değeri ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    msgctl fonksiyonunun ikinci parametresi IPC_STAT geçilirse bu durumda mesaj kuyruğu bilgileri elde edilerek msqid_ds yapı nesnesinin 
    içine yerleştirilmektedir. Örneğin:

    struct msqid_ds msginfo;
    ...

    if (msgctl(msgid, IPC_STAT, &msgino) == -1)
        exit_sys("msgctl");

    Aşağıda bir mesaj kuyruğu yaratılıp (ya da açılıp) içerisine iki mesaj yerleştirilmiş sonra da msgctl fonksiyonu ile IPC_STAT 
    parametresi kullanılarak mesaj kuyruğu bilgileri elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME            "/home/kaan"
#define KEY_ID                321

struct MSG {
    long mtype;
    char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    struct MSG msg;
    key_t key;
    struct msqid_ds msginfo;

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    msg.mtype = 1;
    strcpy(msg.buf, "test");

    if (msgsnd(msgid, &msg, 4, 0) == -1)
        exit_sys("msgsnd");

    if (msgsnd(msgid, &msg, 4, 0) == -1)
        exit_sys("msgsnd");

    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);    /* 16384 ama değişebilir */
    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qnum);        /* 2 */

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    msgctl fonksiyonunun ikinci parametresi IPC_SET olarak girilirse bu durumda mesaj kuyruğuna ilişkin bazı değerler set edilebilmektedir. 
    Ancak bu durumda msqid_ds yapısının tüm elemanları değil yalnızca aşağıda belirtilen elemanları değiştirilmektedir:

    msg_perm.uid
    msg_perm.gid
    msg_perm.mode
    msg_qbytes

    IPC_SET işleminin yapılabilmesi için fonksiyonu çağıran prosesin etkin kullanıcı id'sinin mesaj kuyruğunda belirtilen 
    msg_perm.uid ya da msg_perm.cuid değerine eşit olması ya da prosesin uygun önceliğe sahip olması (root) gerekmektedir. IPC_SET işlemi yapılırken msqid_ds 
    yapısının diğer elemanları zaten dikkate alınmamaktadır. Yani diğer elemanlarda geçersiz değerlerin olması önemli değildir. Tabii programcı yalnızca belli bir 
    değeri değiştirecekse önce IPC_STAT yapıp ondan sonra IPC_SET uygulamalıdır. Çünkü IPC_SET yukarıdaki elemanların hepsini değiştirmektedir. 
    msqid_ds yapısının msg_qbytes elemanının değiştirilmesi yalnızca uygun önceliğe sahip (örneğin root) prosesler tarafından yapılabilmektedir.

    Aşağıdaki örnekte mesaj kuyruğuna ilişkin durum bilgisi IPC_STAT parametresiyle elde edilip IPC_SET parametresiyle kuyruğun msg_qbytes
    elemanı değiştirilmiştir. Ancak bunun yapılabilmesi için programın sudo ile çalıştırılması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME            "/home/kaan"
#define KEY_ID                321

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    key_t key;
    struct msqid_ds msginfo;

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);    /* muhtemelen 16384 */

    msginfo.msg_qbytes = 30000;

    if (msgctl(msgid, IPC_SET, &msginfo) == -1)
        exit_sys("msgctl");

    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);    /* 30000 */

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğunu silmek için msgctl fonksiyonu IPC_RMID parametresiyle çağrılmalıdır. Mesaj kuyruğunun bu biçimde silinebilmesi 
    için prosesin uygun önceliğe sahip olması (örneğin root olması) ya da prosesin etkin kullanıcı id'sinin msqid_ds yapısındaki 
    ipc_perm.uid ya da ipc_perm.cuid değerine eşit olması gerekmektedir. Yani özetle biz root değilsek başkasının mesaj kuyruğunu silemeyiz. 
    Tabii mesaj kuyrukları bu biçimde silinmezse zaten reboot işleminde otomatik olarak silinmektedir. Mesaj kuyrukları silindiğinde 
    artık o anda mesaj kuyruğunu kullanmakta olan prosesler hemen error ile geri dönmektedir. (Yani dosya sisteminde olduğu gibi, gerçek 
    silme tüm kullanan proseslerin kaynağı bırakmasıyla değil, o anda yapılmaktadır.) IPC_RMID parametresi kullanılırken artık üçüncü 
    parametreye gereksinim duyulmamaktadır. Bu parametre NULL olarak geçilebilir. Örneğin:

    if (msgctl(msgid, IPC_RMID, NULL) == -1)
        exit_sys("msgctl");

    Aşağıda daha önce oluşturulmuş olan mesaj kuyruğu msgctl fonksiyonu ve IPC_RMID parametresi ile silinmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME            "/home/kaan"
#define KEY_ID                123

void exit_sys(const char *msg);

int main(void)
{
    int msgid;
    key_t key;

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("msgget");

    if (msgctl(msgid, IPC_RMID, NULL) == -1)
        exit_sys("msgctl");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Linux'a özgü bir biçimde msgctl fonksiyonunda ikinci parametrede bazı özel değerler de kullanılabilmektedir. Bu özel değerler 
    şunlardır:

    IPC_INFO
    MSG_INFO
    MSG_STAT
    MSG_STAT_ANY

    Biz kursumuzda standart olmayan bu parametreler üzerinde durmayacağız. Ancak ilgili man sayfalarından ya da başka dokümanlardan 
    bu parametrelerin işlevleri konusunda bilgi edinebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 IPC mekanizması için iki önemli kabuk komutu vardır: ipcs ve ipcrm. Biz daha önce ipcs komutunu görmüştük. Bu 
    komutun /proc/sysvipc dizinindeki msg, sem ve shm dosyalarını okuyarak işlem yaptığını belirtmiştik. İşte ipcrm komutu ise
    belli bir ipc nesnesini silmek için kullanılmaktadır. ipcrm silme işlemini anahtara göre (büyük harfler) ya da id'lere göre (küçük harfler)
    yapabilmektedir. Örneğin mesaj kuyruklarının ipcrm ile silinmesi anahtar belirtilerek -Q seçeneği ile id belirtilerek -q 
    seçeneği ile yapılabilmektedir. Tabii bu komut aslında msgctl fonksiyonunu kullanarak yazılmıştır. Örneğin:

    $ ipcrm -Q 0x7b050002

    ya da örneğin:

    $ ipcrm -q 3
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                43. Ders 02/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi klasik Sistem 5 IPC nesnelerinin 1990'lı yıllarda alternatif yeni biçimleri oluşturulmuştur. 
    Bunlara halk arasında "POSIX IPC nesneleri" denilmektedir. Bu nesneler sonradan UNIX/Linux dünyasına katıldığı için belli bir süre 
    taşınabilirlik problemlerine sahipti. Ancak artık bu nesneler de yaygın tüm UNIX/Linux sistemlerinde bulunmaktadır.

    POSIX IPC mekanizmasının klasik Sistem 5 IPC mekanizmasından en önemli farklılıklarından biri IPC nesnesinin belirlenmesi için 
    bir anahtarın değil doğrudan bir dosya isminin kullanılmasıdır. Yani adeta isimli borularda olduğu gibi iki proses bir dosya
    isminde anlaşmaktadır. POSIX IPC nesneleri birer dosya ismiyle temsil edilmiş olsa da bu isimli dosyalar bir dizin girişi 
    biçiminde bulundurulmamaktadır. Daha doğrusu böyle bir zorunluluk yoktur. POSIX standartlarına göre POSIX IPC nesnelerine ilişkin 
    dosya isimleri "kök dizinde bir dosya" belirtmelidir. Örneğin "/my_message_queue" gibi. POSIX buradaki dosya isminin kök dizinde olmasını 
    zorunlu hale getirmemiştir. Ancak bunun işletim sistemine bağlı olduğunu belirtmiştir. Yani programcı eğer ilgili işletim sistemi 
    kabul ediyorsa buradaki dosya ismini başka bir dizindeki dosya ismi gibi verebilir. Ancak taşınabilir programların bu isimleri kök 
    dizinde uydurması gerekmektedir. Her ne kadar isimlerin bile çakışabileceği mümkünse de bu olasılık sayısal anahtarların çakışmasından 
    çok daha düşüktür.

    POSIX IPC mekanizmasının Sistem 5 IPC mekanizmasından diğer önemli farklılığı POSIX IPC mekanizmasının "dosya işlemlerine" benzetilmesidir. 
    Yani bu işlemler adeta dosya işlemleri gibi ele alınmaktadır. Örneğin klasik Sistem 5 mesaj kuyruğunu birisi msgctl fonksiyonu ile sildiğinde 
    o anda bu kuyruk üzerinde işlem yapan fonksiyonlar başarısızlıkla geri dönerler. Ancak POSIX mesaj kuyruklarında birisi dışarıdan 
    bu mesaj kuyruğunu silse bile, son proses bu mesaj kuyruğunu kapatmadan gerçek silme yapılmamaktadır. Bu durum adeta dosya silmedeki 
    "unlink/remove" fonksiyonlarına benzemektedir.

    Hem klasik Sistem 5 hem de POSIX IPC nesneleri silinene kadar ya da reboot işlemine kadar hayatta kalmaktadır (kernel persistent). 
    Bu bakımdan bu iki nesne grubu birbirine benzemektedir.

    Klasik Sistem 5 ve POSIX IPC mekanizmasını yöneten fonksiyonlarda da arayüz bakımından bazı farklılıklar vardır. POSIX IPC fonksiyonlarının 
    isimlendirme tarzları da farklıdır. Örneğin mesaj kuyruklarını yaratmak için klasik Sistem 5 kuyruklarında msgget fonksiyonu kullanılırken 
    POSIX mesaj kuyruklarında mq_open fonksiyonu kullanılmaktadır. Tabii isimlendirme ve genel kullanım POSIX IPC nesnelerinin arasında tutarlı 
    bir biçimde oluşturulmuştur.

    POSIX IPC nesneleri, POSIX'in "real time extension" ekleriyle standartlara dahil edilmiştir. Bu fonksiyonlar bu nedenle libc kütüphanesinin
    içerisinde değil librt kütüphanesinin içerisinde bulunmaktadır. Bu nedenle POSIX IPC nesnelerini kullanan programları derlerken -lrt seçeneğinin
    kullanılması gerekir. Örneğin:

    $ gcc -o sample sample.c -lrt
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX mesaj kuyrukları şöyle kullanılmaktadır:

    1) İki proses de (daha fazla proses de olabilir) mesaj kuyruğunu mq_open fonksiyonuyla ortak bir isim altında anlaşarak 
    açar. mq_open fonksiyonunun prototipi şöyledir:

    #include <mqueue.h>

    mqd_t mq_open(const char *name, int oflag, ...);

    Fonksiyon ya iki argümanla ya da dört argümanla çağrılmaktadır. Eğer mesaj kuyruğu zaten varsa fonksiyon iki argümanla 
    çağrılır. Ancak mesaj kuyruğunun yaratılması gibi bir durum söz konusu ise fonksiyon dört argümanla çağrılmalıdır. Eğer mesaj 
    kuyruğunun yaratılması söz konusu ise son iki parametreye sırasıyla IPC nesnesinin erişim hakları ve "özellikleri (attribute)" 
    girilmelidir. Yani mesaj kuyruğu yaratılacaksa adeta fonksiyonun parametrik yapısının aşağıdaki gibi olduğu varsayılmalıdır:

    mqd_t mq_open(const char *name, int oflag, mode_t mode, const struct mq_attr *attr);

    Fonksiyonun birinci parametresi IPC nesnesinin kök dizindeki dosya ismi gibi uydurulmuş olan ismini belirtir. İkinci parametre 
    açış bayraklarını belirtmektedir. Burada open fonksiyonundaki bayrakların bazıları kullanılmaktadır. Açış bayrakları 
    aşağıdakilerden yalnızca birini içermek zorundadır:

    O_RDONLY
    O_WRONLY
    O_RDWR

    Açış bayraklarına aşağıdaki değerlerin bir ya da birden fazlası da bit OR işlemiyle eklenebilir:

    O_CREAT
    O_EXCL
    O_NONBLOCK

    O_CREAT bayrağı yine "yoksa yarat, varsa olanı aç" anlamına gelmektedir. O_EXCL yine O_CREAT birlikte kullanılabilir. 
    Eğer nesne zaten varsa bu durumda fonksiyonun başarısız olmasını sağlar. O_NONBLOCK blokesiz okuma-yazma yapmak için 
    kullanılmaktadır.

    Eğer açış bayrağında O_CREAT belirtilmişse bu durumda programcının fonksiyona iki argüman daha girmesi gerekir. Tabii eğer 
    nesne varsa bu iki argüman zaten kullanılmayacaktır. Yani bu argüman IPC nesnesi yaratılacaksa (yoksa) kullanılmaktadır. 
    Mesaj kuyruğu yaratılırken erişim haklarını tıpkı dosyalarda olduğu gibi kuyruğu yaratan kişi S_IXXX sembolik sabitleriyle
    (ya da 2008 sonrasında doğrudan sayısal biçimde) vermelidir. Eğer mesaj kuyruğu yaratılacaksa son parametre mq_attr isimli 
    yapı türünden bir nesnenin adresi biçiminde girilmelidir. mq_attr yapısı şöyle bildirilmiştir:

    struct mq_attr {
        long mq_flags;       /* Flags: 0 or O_NONBLOCK */
        long mq_maxmsg;      /* Max. # of messages on queue */
        long mq_msgsize;     /* Max. message size (bytes) */
        long mq_curmsgs;     /* # of messages currently in queue */
    };

    Yapının mq_flags parametresi yalnızca O_NONBLOCK içerebilir. max_msg elemanı kuyruktaki tutulacak maksimum mesaj sayısını 
    belirtmektedir. Yapının mq_msgsize ise elemanı bir mesajın maksimum uzunluğunu belirtmektedir. mq_curmsgs elemanı da o anda 
    kuyruktaki mesaj sayısını belirtmektedir. Programcı mesaj kuyruğunu yaratırken yapının mq_maxmsg ve mq_msgsize elemanlarına 
    uygun değerler girip mesaj kuyruğunun istediği gibi yaratılmasını sağlayabilir. Yani mesaj kuyruğu yaratılırken programcı mq_attr 
    yapısının yalnızca mq_maxmsg ve mq_msgsize elemanlarını doldurur. Yapının diğer elemanları mq_open tarafından dikkate alınmamaktadır. 
    Ancak bu özellik parametresi NULL adres biçiminde de geçilebilir. Bu durumda mesaj kuyruğu default değerlerle yaratılır. Bu 
    default değerler değişik sistemlerde değişik biçimlerde olabilir. Linux sistemlerinde genel olarak default durumda maksimum mesaj 
    mq_maxmsg değeri 10, mq_msgsize değeri ise 8192 alınmaktadır. mq_open fonksiyonunda kuyruk özelliklerini girerken mq_maxmsg ve 
    mq_msgsize elemanlarına girilecek değerler için işletim sistemleri alt ve üst limit belirlemiş olabilirler. Eğer yapının bu 
    elemanları bu limitleri aşarsa mq_open fonksiyonu başarısız olur ve errno değişkeni EINVAL olarak set edilir. Örneğin Linux 
    sistemlerinde sıradan prosesler (yani root olmayan prosesler) mq_maxmsg değerini 10'un yukarısına çıkartamamaktadır. Ancak 
    uygun önceliğe sahip prosesler bu değeri 10'un yukarısında belirleyebilmektedir. Ancak POSIX standartları bu default limitler 
    hakkında bir şey söylememiştir. Linux sistemlerinde sonraki paragraflarda açıklanacağı gibi bu limitler proc dosya sisteminden 
    elde edilebilmektedir.

    mq_open fonksiyonu başarı durumunda yaratılan mesaj kuyruğunu temsil eden betimleyici değeriyle, başarısızlık durumunda -1 
    değeriyle geri dönmektedir. Fonksiyonun geri döndürdüğü "mesaj kuyruğu betimleyicisi (message queue descriptor)" diğer 
    fonksiyonlarda bir handle değeri gibi kullanılmaktadır. Linux çekirdeği aslında mesaj kuyruklarını tamamen birer dosya gibi 
    ele almaktadır. Yani mq_open fonksiyonu Linux sistemlerinde dosya betimleyici tablosunda bir betimleyici tahsis edip ona 
    geri dönmektedir. Ancak POSIX standartları fonksiyonun geri dönüş değerini mqd_t türüyle temsil etmiştir. Bu durum değişik 
    çekirdeklerde mesaj kuyruklarının dosya sisteminin dışında başka biçimlerde de gerçekleştirilebileceği anlamına gelmektedir. 
    POSIX standartlarına göre mqd_t herhangi bir tür olarak (yapı da dahil olmak üzere) <mqueue.h> dosyasında typedef edilebilir.

    Örneğin:

    mqd_t mqdes;
    struct mq_attr attr;

    attr.mq_maxmsg = 10;
    attr.mq_msgsize = 32;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, &attr)) == -1)
        exit_sys("mq_open");

    2) POSIX mesaj kuyruğuna mesaj yollamak için mq_send fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio);

    Fonksiyonun birinci parametresi mesaj kuyruğunun betimleyicisini belirtir. Fonksiyonun ikinci parametresi mesajın bulunduğu 
    dizinin adresini almaktadır. Ancak bu parametrenin void bir adres olmadığına dikkat ediniz. Eğer mesaj başka türlere ilişkinse 
    tür dönüştürmesinin yapılması gerekmektedir. Üçüncü parametre gönderilecek mesajın uzunluğunu, dördüncü parametre ise mesajın 
    öncelik derecesini belirtmektedir. Bu öncelik derecesi >= 0 bir değer olarak girilmelidir. POSIX mesaj kuyruklarında öncelik 
    derecesi yüksek olan mesajlar FIFO sırasına göre önce alınmaktadır. Bu mesaj kuyruklarının klasik Sistem 5 mesaj kuyruklarında 
    olduğu gibi belli bir öncelik derecesine sahip mesajları alabilme yeteneği yoktur. Buradaki öncelik derecesinin <limits.h> 
    içerisindeki MQ_PRIO_MAX değerinden küçük olması gerekmektedir. Bu değer ise işletim sistemlerini yazanlar tarafından 
    belirlenmektedir. Ancak bu değer _POSIX_MQ_PRIO_MAX (32) değerinden düşük olamaz. Yani başka bir deyişle buradaki desteklenen 
    değer 32'den küçük olamamaktadır. (Mevcut Linux sistemlerinde bu değer 32768 biçimindedir.)

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set 
    edilir.

    POSIX mesaj kuyruklarının da izleyen paragraflarda açıklanacağı üzere belli limitleri vardır. Eğer mesaj kuyruğu dolarsa 
    mq_send fonksiyonu blokeye yol açmaktadır. Ancak açış sırasında O_NONBLOCK bayrağı belirtilmişse mq_send kuyruk doluysa 
    blokeye yol açmaz, kuyruğa hiçbir şey yazmadan başarısızlıkla (-1 değeriyle) geri döner ve errno EAGAIN değeri ile set edilir.

    Örneğin:

    for (int i = 0; i < 100; ++i) {
        if (mq_send(mqdes, (const char *)&i, sizeof(int), 0) == -1)
            exit_sys("mq_send");
    }

    Burada 0'dan 100'e kadar 100 tane int değer mesaj kuyruğuna mesaj olarak yazılmıştır.

    Mesaj kuyruklarının kendi içerisinde bir senkronizasyon da içerdiğine dikkat ediniz. Kuyruğa yazan taraf kuyruk dolarsa 
    (Linux'taki default değerin 10 olduğunu anımsayınız) blokede beklemektedir. Ta ki diğer taraf kuyruktan mesajı alıp kuyrukta 
    yer açana kadar.

    3) POSIX mesaj kuyruklarından mesaj almak için mq_receive fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio);

    Fonksiyonun birinci parametresi mq_open fonksiyonundan elde edilen mesaj kuyruğu betimleyicisidir. İkinci parametre mesajın 
    yerleştirileceği adresi belirtmektedir. Yine bu parametrenin void bir gösterici olmadığına char türden bir gösterici olduğuna 
    dikkat ediniz. Yani char türünden farklı bir adres buraya geçilecekse tür dönüştürmesi uygulanmalıdır. Üçüncü parametre, 
    ikinci parametredeki mesajın yerleştirileceği alanın uzunluğunu belirtir. Ancak dikkat edilmesi gereken nokta buradaki uzunluk 
    değerinin mesaj kuyruğundaki mq_msgsize değerinden küçük olmaması gerektiğidir. Eğer bu parametreye girilen değer mesaj kuyruğuna 
    ilişkin mq_msgsize değerinden küçük ise fonksiyon hemen başarısız olmaktadır. Bu durumda errno değişkeni EMSGSIZE değeri ile set 
    edilmektedir. Pekiyi bu değeri mq_receive fonksiyonunu uygulayacak programcı nasıl bilecektir? Eğer kuyruğu kendisi yaratmışsa 
    ve yaratım sırasında mq_attr parametresiyle özellik belirtmişse programcı zaten bunu biliyor durumdadır. Ancak genellikle mq_receive
    fonksiyonunu kullanan programcılar bunu bilmezler. Çünkü genellikle kuyruk mq_receive yapan programcı tarafından yaratılmamıştır 
    ya da kuyruk default özelliklerle yaratılmıştır. Bu durumda mecburen programcı mq_getattr fonksiyonu ile bu bilgiyi elde etmek 
    zorunda kalır. Tabii bu işlem programın çalışma zamanında yapıldığına göre programcının mesajın yerleştirileceği alanı da malloc 
    fonksiyonu ile dinamik bir biçimde tahsis etmesi gerekmektedir. mq_receive fonksiyonun son parametresi kuyruktan alınan mesajın 
    öncelik derecesinin yerleştirileceği unsigned int türden nesnenin adresini almaktadır. Ancak bu parametre NULL adres biçiminde 
    geçilebilir. Bu durumda fonksiyon mesajın öncelik derecesini yerleştirmez.

    Fonksiyon başarı durumunda kuyruktaki mesajın uzunluğu ile, başarısızlık durumunda -1 ile geri dönmektedir ve errno değişkeni 
    uygun biçimde set edilmektedir.

    Örneğin:

    char buf[65536];
    ...
    if (mq_receive(mqdes, buf, 65536, NULL) == -1)
            exit_sys("mq_receive");

    Burada biz mesajın önceliğini almak istemedik. Bu nedenle son parametreye NULL adres geçtik. Tampon uzunluğunu öylesine büyük 
    bir değer olarak uydurduk. Aslında yukarıda da belirttiğimiz gibi mq_receive uyguladığımız noktada bizim tampon uzunluğunu 
    biliyor durumda olmamız gerekir.

    4) Pekiyi POSIX mesaj kuyruklarında mesaj haberleşmesi nasıl sonlandırılacaktır? Burada da karşı taraf betimleyiciyi kapattığında diğer taraf bunu 
    anlayamamaktadır. O halde haberleşmenin sonlanması için gönderen tarafın özel bir mesajı göndermesi ya da 0 uzunlukta bir mesajı
    göndermesi gerekir. Eğer 0 uzunluklu mesaj gönderilirse alan tarafta mq_receive fonksiyonu 0 ile geri dönecek ve alan taraf haberleşmenin 
    bittiğini anlayabilecektir.

    5) POSIX mesaj kuyruğu ile işlemler bitince programcı mesaj kuyruğunu mq_close fonksiyonu ile kapatmalıdır. Fonksiyonun 
    prototipi şöyledir:

    #include <mqueue.h>

    int mq_close(mqd_t mqdes);

    Fonksiyon parametre olarak mesaj kuyruğu betimleyicisini alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine geri döner. Programcı her şeyi doğru yaptığına inanıyorsa başarının kontrol edilmesine gerek yoktur.

    Tabii eğer programcı mq_close fonksiyonunu hiç kullanmazsa proses bittiğinde otomatik olarak betimleyici kapatılmaktadır.

    6) POSIX mesaj kuyrukları mq_unlink fonksiyonu ile silinmektedir. Tabii yukarıda da belirttiğimiz gibi mesaj kuyruğu 
    açıkça silinmezse reboot edilene kadar (kernel persistent) yaşamaya ve içerisindeki mesajları tutmaya devam etmektedir. 
    Bir POSIX mesaj kuyruğu mq_unlink fonksiyonu ile silindiğinde halen mesaj kuyruğunu kullanan programlar varsa onlar kullanmaya 
    devam ederler. Mesaj kuyruğu gerçek anlamda son mesaj kuyruğu betimleyicisi kapatıldığında yok edilmektedir. mq_unlink 
    fonksiyonunun prototipi şöyledir:

    #include <mqueue.h>

    int mq_unlink(const char *name);

    Fonksiyon mesaj kuyruğunun ismini alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner.

    Mesaj kuyruğunu, kuyruğu yaratan tarafın silmesi en normal durumdur. Ancak kuyruğu kimin yarattığı bilinmiyorsa taraflardan 
    biri kuyruğu silebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME        "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    struct mq_attr attr;

    attr.mq_maxmsg = 10;
    attr.mq_msgsize = 32;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, &attr)) == -1)
        exit_sys("mq_open");

    for (int i = 0; i < 100; ++i) {
        if (mq_send(mqdes, (const char *)&i, sizeof(int), 0) == -1)
            exit_sys("mq_send");
    }

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME        "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char buf[32];
    int val;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY)) == -1)
        exit_sys("mq_open");

    for (;;) {
        if (mq_receive(mqdes, buf, 32, NULL) == -1)
            exit_sys("mq_receive");
        val = *(const int *)buf;
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    mq_close(mqdes);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                44. Ders 08/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi mesajı alan taraf tutacağı tamponun büyüklüğünü nasıl anlayacaktır? Çünkü oluşturulması gereken tampon mesaj kuyruğu 
    yaratılırken kullanılan struct mq_attr yapısının içerisinde belirtilmektedir. Anımsanacağı gibi mesaj kuyruğu yaratılırken
    mq_open fonksiyonunda mq_attr parametresi NULL geçilirse mesaj kuyruğundaki mesaj uzunlukları için default değer alınmaktadır. 
    Her ne kadar Linux sistemlerinde şu anda bu default değer 8192 ise de başka sistemlerde ve Linux'ta ileride bunun böyle 
    olacağının bir garantisi yoktur. Yukarıdaki örnekte olduğu gibi mesaj kuyruğu yaratılırken bu değer programcı tarafından 
    belirleniyorsa zaten bu değer bilinmektedir. Ancak mq_open fonksiyonunda özellik parametresi NULL geçilebilir. Ya da 
    mesajı okuyacak taraf bunu bilmeyebilir. Bu durumda uygulanacak şey mq_getattr fonksiyonu ile mesaj kuyruğunun özelliklerinin 
    alınması ve tamponun dinamik bir biçimde orada belirtilen mq_msgsize değeri kadar oluşturulmasıdır.

    mq_getattr fonksiyonu mesaj kuyruğunun özellik bilgisini almak için kullanılır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    int mq_getattr(mqd_t mqdes, struct mq_attr *attr);

    Fonksiyonun birinci parametresi mq_open fonksiyonu ile elde edilen mesaj kuyruğu betimleyicisidir. İkinci parametre ise 
    mesaj kuyruğu özelliklerinin yerleştirileceği mq_attr yapısının adresini almaktadır. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri dönmektedir.

    Mesaj kuyruğu yaratıldıktan sonra mesaj kuyruğunun özellikleri mq_setattr fonksiyonu ile değiştirilebilir. Fonksiyonun prototipi 
    şöyledir:

    #include <mqueue.h>

    int mq_setattr(mqd_t mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);

    Fonksiyonun birinci parametresi, mesaj kuyruğu betimleyicisini belirtir. İkinci parametre yeni özelliklerin bulunduğu struct 
    mq_attr yapı nesnesinin adresini alır. Üçüncü parametre ise değiştirilmeden önceki mesaj kuyruğu özelliklerini elde etmek 
    için kullanılan yapı nesnesinin adresini belirtir. Bu parametre NULL adres olarak geçilebilir. Fonksiyon başarı durumunda 0 
    değerine, başarısızlık durumunda -1 değerine geri dönmektedir. mq_setattr fonksiyonu ile mq_attr yapısının yalnızca flags 
    parametresi dikkate alınmaktadır. Dolayısıyla değiştirilebilecek tek özellik aslında O_NONBLOCK bayrağıdır. Yapının diğer 
    elemanları, fonksiyon tarafından dikkate alınmamaktadır. (Mesaj kuyruğu yaratıldıktan sonra maksimum mesaj sayısının ya da 
    mesaj uzunluklarının değiştirilmesi zaten genel olarak uygun değildir.)

    Aşağıdaki örnekte "prog1" programı stdin dosyasından mesajı ve mesajın öncelik değerini alarak mesaj kuyruğuna yazmaktadır. 
    "prog2" programı da mesaj kuyruğundan bu bilgileri alarak stdout dosyasında bunları görüntülemektedir. Burada öncelikteki 
    yüksek değerin gerçek yüksek öncelik anlamına geldiğine dikkat ediniz. (Halbuki klasik Sistem 5 mesaj kuyruklarında yüksek 
    öncelik düşük değerler temsil edilmektedir.) Bu programları çalıştırırken öncelik testini yapabilmek için önce "prog1" 
    programını çalıştırıp kuyruğa çeşitli önceliklerde mesajlar gönderiniz. Sonra "prog2" programını çalıştırıp durumu gözleyiniz. 
    Örnekteki prog2 programı önce mq_getattr fonksiyonu ile mesaj kuyruğundaki maksimum mesaj uzunluğunu elde etmiş ve o 
    uzunlukta dinamik bir alan tahsis etmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME        "/my_message_queue"

void clear_stdin(void);
void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char buf[8192];
    char *str;
    int prio;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL)) == -1)
        exit_sys("mq_open");

    for (;;) {
        printf("Message text:");
        fflush(stdout);

        if (fgets(buf, 8192, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        printf("Priority:");
        fflush(stdout);
        scanf("%d", &prio);

        clear_stdin();

        if (mq_send(mqdes, buf, strlen(buf), prio) == -1)
            exit_sys("mq_send");

        if (!strcmp(buf, "quit"))
            break;
    }

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;
}

void clear_stdin(void)
{
    int ch;
    while ((ch = getchar() != '\n') && ch != EOF)
        ;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME        "/my_message_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char *buf;
    int val;
    struct mq_attr attr;
    int prio;
    ssize_t result;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY)) == -1)
        exit_sys("mq_open");

    if (mq_getattr(mqdes, &attr) == -1)
        exit_sys("mq_getattr");

    if ((buf = malloc(attr.mq_msgsize + 1)) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        if ((result = mq_receive(mqdes, buf, attr.mq_msgsize, &prio)) == -1)
            exit_sys("mq_receive");
        buf[result] = '\0';

        if (!strcmp(buf, "quit"))
            break;

        printf("Message: %s, Priority: %d\n", buf, prio);
    }
    printf("\n");

    free(buf);
    mq_close(mqdes);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bazı UNIX türevi sistemlerde POSIX mesaj kuyrukları özel bir dosya sistemi biçiminde mount edilebilmektedir. Örneğin 
    Linux sistemlerinde mesaj kuyruklarına ilişkin dosya sistemi "/dev/mqueue" dizini üzerinde mount edilmiştir. 
    Yani biz "/dev/mqueue" dizinine geçtiğimizde ls komutuyla o anda yaşamakta olan tüm POSIX mesaj kuyruklarını görüntüleyebiliriz. 
    İstersek rm komutuyla onları silebiliriz. Örneğin:

    $ /dev/mqueue$ ls -l
    toplam 0
    -rw-r--r-- 1 kaan kaan 80 Nis  8 11:25 my_message_queue

    Linux dağıtımları genellikle açılış sırasında bu dosya sistemini otomatik mount etmektedir. Ancak sistem yöneticisi isterse 
    /dev/mqueue dizinini unmount edebilir. Örneğin:

    $ sudo unmount /dev/mqueue

    Ya da sistem yöneticisi isterse bu dosya sistemini başka bir yere de mount komutuyla mount edebilir. Örneğin:

    $ sudo mount -t mqueue somename posix-mqueue

    Burada "somename" mount noktalarını görüntülerken kullanılacak bir isimdir. Mesaj kuyrukları bu biçimde mount edilirken 
    dizinin "sticky" biti set edilmektedir. Böylece bu dizinin birisi sahibi olsa da ancak oradaki dosyaları silebilmek için 
    kişinin dosyanın sahibi olması ya da uygun önceliğe sahip olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi mesaj kuyrukları için iki önemli limit vardı: Bir mesaj kuyruğuna yazılabilecek maksimum mesajların sayısı 
    (Linux'ta default 10 demiştik) ve mesaj kuyruğundaki bir mesajın maksimum uzunluğu (Linux'ta default 8192 demiştik). Pekiyi 
    bunların default değerleri nereden gelmektedir? POSIX standartları bu konuda bir şey söylememektedir. Ancak Linux sistemlerinde 
    bu değerler "/proc/sys/fs/mqueue" dizini içerisinde çeşitli dosyalar tarafından temsil edilmiştir. Buradaki dosyaların ve 
    içerisindeki değerlerin anlamları şöyledir:

    msg_default: Bu değer, mq_open ile mesaj kuyruğu yaratılırken fonksiyonun özellik parametresi NULL geçildiğinde yaratılacak 
    kuyruğa en fazla yerleştirilecek mesaj sayısını belirtmektedir. Bu dosyanın içini "cat" komutu ile yazdırırsak mevcut sistemlerde 
    10 değerini görürüz.

    msg_max: Bu dosya, mq_open ile özellik girilerek mesaj kuyruğu yaratıldığında mq_attr yapısının mq_maxmsg elemanına yerleştirilecek
    maksimum değeri belirtmektedir. Linux sistemlerinde de şimdilik bu dosyanın içerisinde 10 yazmaktadır. Yani biz mesaj kuyruğunu 
    yaratırken 10'dan daha fazla mesajı tutabilecek biçimde yaratamayız.

    msgsize_default: Bu dosya, mq_open ile mesaj kuyruğu yaratılırken özellik parametresine NULL geçildiğinde kuyruğa yazılabilecek 
    maksimum mesaj uzunluğunu belirtmektedir. Bu değerin zaten daha önce 8192 olduğunu belirtmiştik. O halde, bu dosyanın içeriğini 
    yazdırırsak 8192 değerini görürüz.

    msgsize_max: Bu dosyada da mesaj kuyruğunu yaratırken özellik bilgisinde mq_attr yapısının mq_msgsize elemanına yerleştirilebilecek 
    maksimum değer bulunmaktadır. Bu dosya yazdırılırsa 8192 değeri görülmektedir. Yani biz kuyruktaki mesajların uzunluğunu bu 
    eğerin yukarısına çekemeyiz.

    queues_max: Bu değer, sistem genelinde yaratılabilecek mesaj kuyruklarının toplam sayısını belirtmektedir.

    Uygun önceliğe sahip prosesler yukarıdaki limitlerden etkilenmezler. Ayrıca, buradaki değerler proc dosya sisteminden bu 
    dosyalara yazma yapılarak değiştirilebilmektedir. Örneğin:

    $ sudo sh -c "echo 20 > /proc/sys/fs/mqueue/msg_max"

    Buradaki değerlerin ayrı bir tavan limiti de vardır. Örneğin msg_max değerinin tavan limiti 3.5 ve sonrasındaki 
    çekirdeklerde 65536'dır. Yine örneğin msgsize_max değerinin de tavan limiti 3.5 ve sonrasındaki çekirdeklerde 16,777,216 
    biçimindedir. Uygun önceliğe sahip prosesler /proc/sys/fs/mqueue içerisindeki limitlere takılmasalar da bu tavan limitlerine 
    takılabilirler. Ayrıca belli bir kullanıcının maksimum kullanacağı mesaj kuyrukları için byte sayısı da bir limittir. Şu 
    andaki çekirdeklerde bu 819200 byte'tır. Yani belli bir kullanıcı toplam mesaj kuyruklarının sayısı * bir mesajdaki maksimum 
    byte sayısını bu değerin yukarısında set edemez. Bu konudaki detaylar için mq_overview(7) man sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    mq_send ve mq_receive fonksiyonlarının "zaman aşımlı (timeout)" versiyonları da vardır. Bu zaman aşımlı versiyonları kuyruk 
    doluyken ya da boşken blokeyi belirlenen zaman çerçevesinde oluşturur. Eğer bloke daha uzun sürerse zaman aşımından dolayı
    bu fonksiyonlar başarısızlıkla geri dönerler ve errno değeri ETIMEDOUT ile set edilir. Fonksiyonların prototipleri şöyledir:

    #include <time.h>
    #include <mqueue.h>

    int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, 
            unsigned int msg_prio, const struct timespec *abs_timeout);

    ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr, size_t msg_len, 
                unsigned int *msg_prio, const struct timespec *abs_timeout);

    Bu fonksiyonların mq_send ve mq_receive fonksiyonlarından tek farkı zaman aşımına ilişkin bir parametreye sahip olmasıdır. 
    Zaman aşımı <time.h> içerisinde bildirilmiş olan timespec yapısıyla ifade edilmektedir:

    struct timespec {
        time_t tv_sec;          /* seconds */
        long tv_nsec;           /* nanoseconds */
    };

    Bu yapının amacı 01/01/1970'ten geçen saniye sayısını nanosaniye mertebesinde detaylandırmaktır. Ancak fonksiyonlardaki 
    zaman aşımı değerleri "göreli" değil "mutlak"tır. Örneğin biz zaman aşımını 10 saniye tutacaksak buraya şimdiden 10 saniye sonraki
    timespec değerini girmeliyiz. Bunun için önce clock_gettime fonksiyonu ile şimdiki zamana ilişkin timespec değeri elde edilebilir. 
    Sonra o değere belli bir değer toplanıp zaman aşımı göreli biçimde oluşturulabilir. clock_gettime fonksiyonu aynı zamanda standart
    bir C fonksiyonudur. Bu fonksiyondaki saat türünün CLOCK_REALTIME alınması uygun olur. clock_gettime fonksiyonunun prototipi şöyledir:

    #include <time.h>

    int clock_gettime(clockid_t clock_id, struct timespec *tp);

    Fonksiyonun birinci parametresi saatin türünü, ikinci parametresi zaman bilgisinin yerleştirileceği yapı nesnesinin adresini 
    almaktadır. Örneğin:

     if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    if (mq_timedreceive(mqdes, buf, 8192, NULL, &ts) == -1)
        if (errno == ETIMEDOUT) {
            /* timeout oluştu başka şeyler yap */
        }

    Burada mq_timedreceive fonksiyonu ile 10 saniye kadar blokede beklenebilir. Ancak zaman aşımı dolduğunda bloke ortadan 
    kalkacaktır. Fonksiyon, başarısızlıkla geri dönecek ve errno ETIMEDOUT özel değeri ile set edilecektir. Böylece programcı 
    arka planda başka şeyler yapabilecektir. Bu zaman aşımlı işlemleri, blokesiz işlemlerle karıştırmayınız. Blokesiz işlemlerde 
    bloke hiç oluşmamaktadır. Halbuki zaman aşımlı işlemlerde bloke oluşur ancak en fazla belirlenen zaman aşımı kadar bloke sürer. 
    Zaman aşımlı işlemlerde, zaten zaman aşımı geçmişse ve kuyruk dolu ya da boşsa fonksiyon hemen başarısız olmaktadır. Fonksiyonlar 
    zaman aşımına kuyruk doluysa ya da boşsa bakmaktadır. Eğer kuyruk, blokesiz modda açılmışsa zaman aşımlı fonksiyonların zaman 
    aşımlı olmayanlardan davranış olarak bir farkı kalmaz.

    Aşağıdaki örnekte bir mesaj kuyruğu okuma amaçlı yaratılmış sonra mq_timedreceive fonksiyonu ile şimdiki zamandan 10 saniye 
    kadar blokeli beklenmiştir. Bu programı çalıştırdığınızda 10 saniye sonra "timeout" yazısının basıldığını göreceksiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
#include <time.h>
#include <mqueue.h>

#define MSGQUEUE_NAME        "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    struct mq_attr attr;
    struct timespec ts;
    char buf[8192];

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL)) == -1)
        exit_sys("mq_open");

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    if (mq_timedreceive(mqdes, buf, 8192, NULL, &ts) == -1)
        if (errno == ETIMEDOUT)
            printf("timedout\n");
        else
            exit_sys("mq_timedreceive");

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 mesaj kuyrukları ile POSIX mesaj kuyruklarını avantaj/dezavantaj bakımından şöyle karşılaştırabiliriz:

    - POSIX mesaj kuyrukları isimlendirme bakımından daha güzel bir arayüz sunmaktadır.

    - Klasik Sistem 5 mesaj kuyrukları daha taşınabilirdir. Ancak POSIX mesaj kuyrukları da artık taşınabilir hale gelmiştir.

    - POSIX mesaj kuyrukları dosyalar gibi kullanılmaktadır. Dolayısıyla "her şeyin dosya olduğu" tasarımı ile daha uyumludur.

    - Klasik Sistem 5 mesaj kuyruklarında belli bir önceliğe ilişkin mesajlar alınabilmektedir. POSIX mesaj kuyruklarında bu 
    yapılamamaktadır.

    - POSIX mesaj kuyrukları silindiğinde onu kullanan prosesler kullanmaya devam ederler. Ancak klasik Sistem 5 mesaj kuyruklarında
    mesaj kuyruğu silindiğinde onu kullanan prosesler artık mesaj kuyruğunu kullanamaz hale gelirler.

    - POSIX mesaj kuyrukları dosya sistemi gibi mount edilebilmektedir. Dolayısıyla silme işlemi dosya siler gibi yapılabilmektedir.

    - Her iki mesaj kuyruğu da silinene kadar ya da sistem reboot edilene kadar yaşamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Diğer önemli prosesler arası haberleşme yöntemlerinden biri de "paylaşılan bellek alanları (shared memory)" denilen yöntemdir. 
    Paylaşılan bellek alanlarında işletim sistemi iki prosesin sayfa tablosundaki farklı sanal sayfa numaralarını aynı fiziksel 
    sayfaya yönlendirir. Böylece iki proses, farklı sanal adreslerle aynı fiziksel sayfaya erişirler. Proseslerden biri oraya 
    bir şey yazdığında diğeri onu hemen görür. Dolayısıyla yöntem çok hızlıdır. Ancak bu yöntem kendi içerisinde bir senkronizasyon 
    içermemektedir. Dolayısıyla senkronizasyonun sağlanması için semaphore gibi bir senkronizasyon nesnesine de gereksinim duyulur. 
    Zaten bu nedenle IPC nesnelerine semaphore'lar eklenmiştir.

    Paylaşılan bellek alanları da UNIX/Linux dünyasında tıpkı mesaj kuyruklarında olduğu gibi iki arayüzle kullanılabilmektedir:
    Klasik Sistem 5 paylaşılan bellek alanları ve POSIX paylaşılan bellek alanları. Biz de burada önce klasik Sistem 5 paylaşılan 
    bellek alanlarını sonra da POSIX paylaşılan bellek alanlarını göreceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                45. Ders 09/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 paylaşılan bellek alanları aşağıdaki adımlardan geçilerek oluşturulmaktadır:

    1) Paylaşılan bellek alanı, shmget fonksiyonu ile anahtar verilip id elde edilecek biçimde yaratılır ya da olan açılır. 
    Yine id değerleri sistem genelinde tektir. Yani bu id değeri, diğer prosesler tarafından biliniyorsa yetki durumu da uygunsa
    shmget fonksiyonu çağrılmadan doğrudan kullanılabilir. shmget fonksiyonunun prototipi şöyledir:

    #include <sys/shm.h>

    int shmget(key_t key, size_t size, int shmflg);

    Fonksiyonun birinci parametresi yine paylaşılan bellek alanının anahtar değerini belirtir. Aynı anahtar için aynı id değerleri 
    elde edilmektedir. Fonksiyonun ikinci parametresi yaratılacak paylaşılan bellek alanının büyüklüğünü belirtmektedir. 
    Bu büyüklük normal olarak sayfa katlarına ilişkin bir değer olarak girilir. Ancak POSIX standartları bunu zorunlu hale getirmemiştir. 
    Örneğin biz bu büyüklüğü 5000 olarak girdiğimizde işletim sistemi 4096'lık iki sayfayı eşler. Dolayısıyla genellikle burada girilen değer
    sayfa katlarına bakılarak yukarıya doğru yuvarlanmaktadır. (Yani biz bu değeri örneğin Linux sistemlerinde 5000 girsek de sanki 
    sistem 2 * 4096 = 8192 girmişiz gibi durumu ele almaktadır.) Yukarıda da belirttiğimiz gibi buradaki büyüklüğün sayfa katlarına yukarıya 
    doğru yuvarlanması POSIX standartlarında belirtilmemiştir. Ancak Linux dokümanlarında (Linux man sayfalarında) belirtilmiştir. 
    Fonksiyonun son parametresi, IPC nesnesinin erişim haklarını ve yaratım seçeneklerini belirtmektedir. Tabii bu parametre eğer IPC nesnesi 
    yaratılıyorsa (yani IPC_CREAT bayrağı kullanılmışsa) etkili olmaktadır. Eğer IPC nesnesi zaten yaratılmışsa bu parametre 0 geçilebilir. 
    Bu parametrenin msgget get fonksiyonundaki ilgili parametreden bir farkı yoktur. Yine burada da erişim hakları S_IXXX sembolik sabitleriyle 
    oluşturulabilir (ya da 2008 ve sonrasında doğrudan sayısal değerlerle oluşturulabilir). Erişim haklarına IPC_CREAT eklenebilir. Bu durum, IPC nesnesi 
    yoksa onun yaratılacağı anlamına gelir. Yine IPC_CREAT|IPC_EXCL bayrakları birlikte kullanılırsa nesne zaten varsa fonksiyon başarısız
    olmaktadır. Yine tıpkı msgget fonksiyonunda olduğu gibi birinci parametreye IPC_PRIVATE değeri geçilebilir. Bu durumda nesne 
    çakışmayan bir anahtarla yaratılır ve IPC nesnesinin id değeri elde edilir. Bu id değeri, diğer proseslere gönderilirse onlar 
    bu IPC nesnesini doğrudan kullanabilirler. Fonksiyonun geri dönüş değeri, IPC nesnesinin id değerini vermektedir. Bu değer, sistem genelinde 
    paylaşılan bellek alanları içerisinde tektir. Başka proseslere gönderilirse onlar tarafından da kullanılabilir. Fonksiyon başarısız olursa
    -1 değerine geri döner ve errno uygun biçimde set edilir. Linux'ta, Linux'a özgü bir biçimde erişim haklarında birkaç standart olmayan bayrak da 
    kullanılabilmektedir. Bu bayrakları ilgili man sayfalarından inceleyebilirsiniz.

    Yine sistemdeki o anda yaratılmış olan paylaşılan bellek alanları "ipcs" komutuyla ya da "ipcs -m" komutuyla görüntülenebilir. 
    Örneğin:

    $ ipcs -m

    ----- Paylaşımlı Bellek Bölütleri -----
    anahtar    shmid      sahibi     izinler    bayt       ekSayısı durum
    0x00000000 98305      kaan       600        4194304    2          hedef
    0x00000000 98321      kaan       600        524288     2          hedef
    0x00000000 19         kaan       600        67108864   2          hedef
    0x00000000 65556      kaan       600        524288     2          hedef
    0x00000000 131099     kaan       606        10437756   2          hedef
    0x00000000 131100     kaan       606        10437756   2          hedef
    0x00012345 131101     kaan       644        4096       0
    0x00000000 65570      kaan       600        4194304    2          hedef
    0x00000000 51         kaan       600        4194304    2          hedef
    0x00000000 59         kaan       600        524288     2          hedef

    Aslında daha önceden de belirttiğimiz gibi "ipcs" komutu bu bilgileri "/proc/sysvipc" dizinindeki üç dosyadan elde etmektedir. 
    Klasik Sistem 5 paylaşılan bellek alanları için "/proc/sysvipc/shm" dosyası kullanılmaktadır. Örneğin:

    $ cat /proc/sysvipc/shm

    bu biçimde benzer bilgileri elde edebiliriz.

    Örneğin:

    int shmid;
    ...

    if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
        exit_sys("shmget");

    2) Zaten yaratılmış bir klasik Sistem 5 paylaşılan bellek alanı nesnesini, prosesin sanal bellek alanında oluşturmak gerekir. 
    Buna klasik Sistem 5 paylaşılan bellek alanları terminolojisinde "paylaşılan bellek alanının attach edilmesi" denilmektedir. 
    Bu işlem sırasında işletim sistemi ilgili prosesin sayfa tablosunda bu paylaşılan bellek alanına erişmede kullanılacak sanal adresi 
    oluşturmaktadır. Bu işlem shmat fonksiyonu ile yapılmaktadır. (İsimdeki "at" eki "attach" sözcüğünden kısaltmadır.) shmat 
    fonksiyonunun prototipi şöyledir:

    #include <sys/shm.h>

    void *shmat(int shmid, const void *shmaddr, int shmflg);

    Fonksiyonun birinci parametresi paylaşılan bellek alanının id'sini belirtmektedir. Fonksiyonun ikinci parametresi önerilen sanal 
    adresi belirtmektedir. Programcı, işletim sistemine "şu sanal adres yoluyla paylaşılan bellek alanına erişmek istiyorum" diyebilmektedir. 
    Ancak programcının önerdiği adres kullanılıyor olabilir ya da işletim sistemi tarafından kullanılamaz bir adres olabilir. 
    Bu durumda fonksiyon başarısız olur. Bu parametre NULL adres geçilebilir. Bu durumda, işletim sistemi paylaşılan bellek alanına erişmek 
    için kullanılacak sanal adresi kendisi tespit eder. Normal olarak bu adresin sayfa katlarında olması beklenmektedir. Ancak programcı 
    bu adresi sayfa katları olarak vermezse ve fonksiyonun üçüncü parametresinde SHM_RND bayrağını kullanırsa bu durumda programcının 
    verdiği adres sayfa katlarına aşağıya doğru yuvarlanmaktadır. Örneğin programcı ikinci parametreye 0x4A6C324 biçiminde bir adres 
    girmiş olsun. Eğer fonksiyonun son parametresi SHM_RND olarak girilirse bu adres 4096'nın katlarına aşağıya doğru yuvarlanmaktadır. 
    Yani bu durumda adres 0x4A6C000 biçimine dönüştürülecektir. Tabii programcının verdiği adres sayfa katlarında olsa bile işletim sistemi
    tarafından kabul edilmeyebilir. Çünkü sanal adres alanı içerisinde özel bölgeler, kullanılmayan alanlar bulunabilmektedir. 
    Eğer ikinci parametreye bir adres girilirse ve bu adres sayfa katlarında değilse, üçüncü parametrede de SHM_RND girilmezse fonksiyon 
    büyük olasılıkla başarısız olacaktır. POSIX standartlarında "sayfa katlarına aşağıya yuvarlama" biçiminde bir ibare bulunmamaktadır. 
    Sayfa katları yerine, standartlarda SHMLBA sembolik sabiti kullanılmıştır. Yani standartlar anlatımı "SHMLBA katlarına aşağıya yuvarlama"
    biçiminde oluşturmuştur. SHMLBA sembolik sabiti <sys/shm.h> içerisinde bildirilmiştir ve tipik olarak zaten sayfa uzunluğunu belirtir.

    Fonksiyonun son parametresi 0 geçilebilir ya da bazı bayraklar burada kullanılabilir. Yukarıda da belirttiğimiz gibi eğer 
    ikinci parametrede bir adres girilmişse üçüncü parametrede SHM_RND bayrağı bu adresin sayfa katlarına aşağıya doğru yuvarlanacağını belirtmektedir. 
    Üçüncü parametredeki SHM_RDONLY ilgili paylaşılan bellek alanına "read-only" erişim için kullanılmaktadır. Bu durumda, bu sayfaya 
    yazma yapıldığında "page fault" oluşacak ve işletim sistemi prosesi sonlandıracaktır. Bu bayrak belirtilmezse erişim "read-write" yapılır.

    Proses, aynı paylaşılan bellek alanı nesnesini birden fazla shmat fonksiyonu ile birden fazla kez "attach" yapabilir. Ancak genellikle
    böyle bir duruma gereksinim duyulmamaktadır.

    Fonksiyon başarı durumunda paylaşılan bellek alanına erişmekte kullanılan sanal adrese, başarısızlık durumunda (void *)-1 adresine
    geri dönmektedir. errno değişkeni uygun biçimde set edilmektedir. Fonksiyonun NULL adrese geri dönmemesinin nedeni bazı sistemlerde 
    0 adresinin geçerli bir biçimde kullanılabiliyor olmasındandır. Tabii fonksiyon bize sayfa katlarına ilişkin bir adres vermektedir. 
    (Yani 4096'lık sayfaların kullanıldığı sistemlerde verilen sanal adreslerin düşük anlamlı 3 hex digit'i 0 olacaktır.) Örneğin:

    int shmid;
    char *shmaddr;

    if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
        exit_sys("shmget");

    if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    3) Artık iki proses de muhtemelen farklı sanal adresler yoluyla aynı fiziksel sayfaya erişmektedir. Proseslerden biri o bölgeye
    bir şeyler yazarsa diğeri onu görür ve elde edebilir. Tabii burada bir senkronizasyonun sağlanması gerekmektedir. Daha önce 
    görmüş olduğumuz borular ve mesaj kuyruklarında zaten bu organizasyon bu nesneler tarafından sağlanmaktadır. Bir tarafın
    paylaşılan bellek alanına bir şeyleri yazdığı diğerinin okuduğu bu tür senkronizasyon problemlerine "üretici tüketici problemi" 
    (producer consumer problem)" denilmektedir. Bu problemin çözümü "thread'ler" konusunda ele alınacaktır.

    4) Proses paylaşılan bellek alanının kullanımını bitirdikten sonra o alanı prosesin sanal bellek alanından çıkartmalıdır. 
    Terminolojide paylaşılan bellek alanının prosesin bellek alanına iliştirilmesine "attach" denirken bunun tersine "detach" denilmektedir. 
    (Yani shmat fonksiyonunu "malloc" gibi bir fonksiyona benzetirsek bunun bir de "free" gibi serbest bırakan bir karşılığının olması gerekir.)
    İşte shmat ile yapılan işlemi geri almak için shmdt fonksiyonu kullanılmaktadır (buradaki "dt" eki "detach" sözcüğünden kısaltılmıştır).
    Fonksiyonun prototipi şöyledir:

    #include <sys/shm.h>

    int shmdt(const void *shmaddr);

    Fonksiyon parametre olarak shmat fonksiyonundan elde edilen sanal adresi alır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir. Her şey düzgün yapılmışsa fonksiyonun başarısının kontrol edilmesine de gerek yoktur. 
    Eğer programcı bu shmdt işlemini yapmazsa proses sonlanırken bu işlem zaten yapılmaktadır. Örneğin:

    int shmid;
    char *shmaddr;
    ...

    if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
        exit_sys("shmget");

    if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    ...

    if (shmdt(shmaddr) == -1)
        exit_sys("shmdt");

    5) Paylaşılan bellek alanlarının "detach" edilmesi ilgili nesnenin yok edileceği anlamına gelmemektedir. Programcı "detach" işlemi 
    sonrasında yeniden attach işlemi yapabilir. Paylaşılan bellek alanları nesnesi, diğer IPC nesnelerinde olduğu gibi açıkça silinene kadar 
    ya da reboot işlemine kadar yaşamaya devam etmektedir.

    6) Klasik Sistem 5 paylaşılan bellek alanları nesnesi için işletim sistemi shmid_ds isimli bir yapı oluşturmaktadır. Bu yapıda
    paylaşılan bellek alanına ilişkin bazı önemli bilgiler tutulmaktadır. Bu bilgileri elde etmek için, set etmek için ya da
    IPC nesnesini yok etmek için shmctl isimli fonksiyon kullanılmaktadır. Bu fonksiyonun işlevi, klasik Sistem 5 mesaj kuyruklarındaki
    msgctl fonksiyonuna benzetilebilir. shmctl fonksiyonunun parametrik yapısı şöyledir:

    #include <sys/shm.h>

    int shmctl(int shmid, int cmd, struct shmid_ds *buf);

    Fonksiyonun birinci parametresi paylaşılan bellek alanının id değerini, ikinci parametresi ise uygulanacak işlemi belirtmektedir. 
    Fonksiyonun üçüncü parametresinde belirtilen yapı şöyledir:

    struct ipc_perm {
        uid_t          uid;      /* Effective UID of owner */
        gid_t          gid;      /* Effective GID of owner */
        uid_t          cuid;     /* Effective UID of creator */
        gid_t          cgid;     /* Effective GID of creator */
        unsigned short mode;     /* Permissions + SHM_DEST and
                                    SHM_LOCKED flags */
    };

     struct shmid_ds {
        struct ipc_perm shm_perm;    /* Ownership and permissions */
        size_t          shm_segsz;   /* Size of segment (bytes) */
        time_t          shm_atime;   /* Last attach time */
        time_t          shm_dtime;   /* Last detach time */
        time_t          shm_ctime;   /* Creation time/time of last
                                        modification via shmctl() */
        pid_t           shm_cpid;    /* PID of creator */
        pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
        shmatt_t        shm_nattch;  /* No. of current attaches */
    };

    Daha önceden de ipc_perm yapısını görmüştük. Bu yapı içerisinde IPC nesnesinin o anki kullanıcı ve grup id'leri, nesneyi 
    yaratan prosesin kullanıcı ve grup id'leri ve nesnenin erişim hakları bulunuyordu. shmid_ds yapısının diğer elemanları sırasıyla 
    şu bilgileri barındırmaktadır: Paylaşılan bellek alanın büyüklüğü, son attach zamanı, son detach zamanı, son shmid_ds yapısındaki 
    değişiklik zamanı, IPC nesnesini yaratan prosesin id'si, son attach ya da detach yapan prosesin id'si ve nihayet nesnenin kaç kere attach 
    yapıldığı bilgisi.

    İkinci parametreye şunlardan biri girilebilir:

    IPC_STAT: Bu durumda paylaşılan bellek alanına ilişkin bilgiler fonksiyonun üçüncü parametresiyle belirtilen yapı nesnesine doldurulur.

    IPC_SET: Bu durumda shmid_ds yapısının aşağıdaki elemanları set edilmektedir:

    shm_perm.uid
    shm_perm.gid
    shm_perm.mode

    Tabii set işleminin yapılabilmesi için prosesin etkin kullanıcı id'sinin shm_perm.uid ya da sehm_perm.cuid değerine eşit olması 
    ya da prosesin uygun önceliğe sahip olması gerekmektedir.

    IPC_RMID: Bu parametre değeri IPC nesnesini silmek için kullanılmaktadır. Benzer biçimde bu işlemin yapılabilmesi için de 
    IPC_SET koşulunda belirtilen koşulların sağlanması gerekmektedir. Paylaşılan bellek alanları nesnesini bunu yaratan prosesin 
    silmesi uygun olur. Klasik Sistem 5 mesaj kuyruklarında, bir proses mesaj kuyruğunu silerse mesaj kuyruğu hemen siliniyordu. 
    Dolayısıyla onu kullanan bir proses ilgili işlemlerde başarısızlıkla karşılaşıyordu. Ancak paylaşılan bellek alanlarında durum 
    böyle değildir. Bir klasik Sistem 5 paylaşılan bellek alanı, shmctl fonksiyonu ile bir proses tarafından silinse bile gerçek 
    silinme onu kullanan tüm proseslerin bellek alanını "detach" yapmasıyla gerçekleşmektedir. IPC nesnesi, IPC_RMID parametresiyle 
    silinecekse artık fonksiyonun son parametresi kullanılmaz. NULL adres geçilebilir.

    Paylaşılan bellek alanları komut satırında "ipcrm" komutuyla da silinebilmektedir. Komutta -M seçeneği anahtar ile silmek için -m 
    seçeneği id ile silmek için kullanılmaktadır. Örneğin:

    $ ipcrm -m 131135

    Burada 131135 id'sine sahip paylaşılan bellek alanı silinmektedir. Tabii bize ait olmayan paylaşılan bellek alanlarını silmek için 
    sudo uygulamak gerekir.

    shmctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Aşağıdaki örnekte prog1 programı paylaşılan bellek alanına bir yazı yerleştirir. prog2 programı da bu yazıyı oradan alıp 
    ekrana (stdout dosyasına) yazdırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/shm.h>

#define SHM_KEY        0x12345

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    char *shmaddr;

    if ((shmid = shmget(SHM_KEY, 4096, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shmget");

    if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    printf("Shared memory virtual address: %p\n", shmaddr);

    strcpy(shmaddr, "this is a test");

    printf("press ENTER to continue...\n");

    getchar();

    if (shmdt(shmaddr) == -1)
        exit_sys("shmdt");

    if (shmctl(shmid, IPC_RMID, NULL) == -1)
        exit_sys("shmctl");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/shm.h>

#define SHM_KEY        0x12345

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    char *shmaddr;

    if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
        exit_sys("shmget");

    if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    printf("Shared memory virtual address: %p\n", shmaddr);

    printf("press ENTER to continue...\n");
    getchar();

    puts(shmaddr);

    if (shmdt(shmaddr) == -1)
        exit_sys("shmdt");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Her ne kadar POSIX standartlarında belirtilmiş olmasa da işletim sistemleri, paylaşılan bellek alanları için çeşitli sınır 
    değerler oluşturmaktadır. Linux sistemlerinde paylaşılan bellek alanlarına ilişkin sınırlar şöyledir:

    SHMALL: Sistemdeki tüm paylaşılan bellek alanlarının kaplayabileceği toplam alanı sayfa sayısı cinsinden belirtmektedir. 
    Bu değer Linux sistemlerinde /proc/sys/kernel/shmall dosyasından elde edilebilir ve değiştirilebilir. Buradaki default değer
    çok büyüktür yani adeta bir sınır olmadığını belirtmektedir.

    SHMMAX: Bu sınır belli bir prosesin shmget fonksiyonu ile oluşturabileceği maksimum paylaşılabilen bellek alanı büyüklüğüdür. 
    Yani shmget fonksiyonunda belirtilecek büyüklüğün üst sınırını belirtmektedir. Bu sınır da proc dosya sisteminde /proc/sys/kernel/shmmax
    dosyası ile elde edilebilir ve değiştirilebilir. Bu değer byte cinsindendir. Şu andaki Linux sistemlerindeki default değer çok 
    büyüktür. Adeta sınırsız gibi ele alınabilir.

    SHMMIN: Bu sınır shmget ile oluşturulabilecek minimum uzunluğu belirtmektedir. Şimdiki Linux sistemlerinde bu değer 1'dir. 
    Ancak tabii biz shmget ile 1 byte alan oluşturmak istesek bile shmget bize en az bir sayfa tahsis etmektedir. Bunun için 
    proc dosya sisteminde bir giriş bulunmamaktadır.

    SHMMNI: Bu sınır sistem genelinde yaratılabilecek maksimum paylaşılan bellek alanlarının sayısını belirtmektedir. Bu değer
    proc dosya sisteminde /proc/sys/kernel/shmmni dosyası ile elde edilebilir ve değiştirilebilir. Mevcut Linux sistemlerinde 
    bu dosyada default olarak 4096 değeri bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Paylaşılan bellek alanları da "POSIX paylaşılan bellek alanları" denilen alternatif bir arayüze sahiptir. POSIX paylaşılan bellek alanları 
    daha önce görmüş olduğumuz POSIX mesaj kuyruklarına benzer bir kullanım sunmaktadır. Yani burada farklı prosesler anahtarlarla 
    değil yine kök dizindeki dosya isimleriyle anlaşma sağlarlar. POSIX arayüzü, tıpkı mesaj kuyruklarında olduğu gibi daha modern 
    bir tasarıma sahiptir. Ayrıca POSIX arayüzü "bellek tabanlı dosyalar (memory mapped files)" denilen olguyla da birleştirilmiş durumdadır. 
    POSIX arayüzü yine sanki nesne bir dosyaymış gibi davranmaktadır. Ancak mesaj kuyruklarında da belirttiğimiz gibi bir taşınabilirlik 
    problemi burada da söz konusu olabilmektedir. Ancak pek çok UNIX türevi işletim sistemi artık bu arayüzü uzun süredir destekler duruma gelmiştir. 
    POSIX paylaşılan bellek alanları librt kütüphanesi içerisinde bulunduğundan link işleminde -lrt seçeneğinin kullanılması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                46. Ders 15/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX paylaşılan bellek alanları tipik olarak şu adımlardan geçilerek kullanılmaktadır:

    1) POSIX paylaşılan bellek alanı nesnesi iki proses tarafından shm_open fonksiyonuyla yaratılabilir ya da zaten var olan 
    nesne shm_open fonksiyonu ile açılabilir. shm_open fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    int shm_open(const char *name, int oflag, mode_t mode);

    Fonksiyonun birinci parametresi paylaşılan bellek alanı nesnesinin ismini belirtmektedir. Tıpkı POSIX mesaj kuyruklarında 
    olduğu gibi bu ismin kök dizinde bir dosya ismi gibi verilmesi gerekmektedir. (Bazı sistemlerin, buradaki dosya isminin 
    başka dizinlerde olmasına izin verebildiğini belirtmiştir.) Fonksiyonun ikinci parametresi paylaşılan bellek alanının açış 
    bayraklarını belirtmektedir. Bu bayraklar şunlardan birini içerebilir:

    O_RDONLY: Bu durumda paylaşılan bellek alanından yalnızca okuma yapılabilir.
    O_RDWR: Bu durumda paylaşılan bellek alanından hem okuma yapılabilir hem de oraya yazma yapılabilir.

    Aşağıdaki bayraklar da açış moduna eklenebilir:

    O_CREAT: Paylaşılan bellek alanı yoksa yaratılır, varsa olan açılır.
    O_EXCL: O_CREAT bayrağı ile birlikte kullanılabilir. Paylaşılan bellek alanı zaten varsa fonksiyon başarısız olur.
    O_TRUNC: Paylaşılan bellek alanı varsa sıfırlanarak açılır. Bu mod için O_RDWR bayrağının kullanılmış olması gerekmektedir.

    Fonksiyonun üçüncü parametresi paylaşılan bellek alanının erişim haklarını belirtmektedir. Tabii ancak ikinci parametrede
    O_CREAT bayrağı kullanılmışsa bu parametreye gereksinim duyulmaktadır. İkinci parametrede O_CREAT bayrağı kullanılmamışsa 
    üçüncü parametre hiç kullanılmamaktadır. Ancak shm_open fonksiyonunun bu üçüncü parametresi kullanılmayacak olsa bile girilmek 
    zorundadır. Örneğin bu tür durumlarda bu parametre için 0 değerini girebilirsiniz. (open fonksiyonunun üçüncü parametresinin 
    eğer gerek yoksa girilmeyebileceğini anımsayınız.)

    shm_open bize tıpkı bir disk dosyasında olduğu gibi bir dosya betimleyicisi vermektedir. (Halbuki mq_open fonksiyonunun bir 
    dosya betimleyicisi vermesinin zorunlu olmadığını anımsayınız.) Fonksiyon başarısız olursa yine -1 değerine geri döner ve errno 
    değişkeni uygun biçimde set edilir.

    Örneğin:

    int fdshm;

    if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    2) Paylaşılan bellek alanı yaratıldığında 0 uzunluktadır. Ona ftruncate fonksiyonu ile ona bir büyüklük vermek gerekir. 
    truncate ve ftruncate fonksiyonlarının bir dosyayı büyütmek ya da küçültmek amacıyla kullanıldığını anımsayınız. Örneğin:

    if (ftruncate(fdshm, SHM_SIZE) == -1)
        exit_sys("ftruncate");

    Tabii paylaşılan bellek alanı zaten yaratılmışsa ve biz onu açıyorsak ftruncate fonksiyonunu aynı uzunlukta çağırdığımızda 
    aslında fonksiyon herhangi bir şey yapmayacaktır. Yani aslında ftruncate fonksiyonu paylaşılan bellek alanı ilk kez yaratılırken 
    bir kez çağrılır. Ancak yukarıda da belirttiğimiz gibi aynı uzunlukta ftruncate işleminin bir etkisi yoktur.

    POSIX paylaşılan bellek alanı nesneleri Linux'ta dosya sisteminde "/dev/shm" dizini içerisinde görüntülenmektedir. Yani 
    programcı isterse bu dizin içerisindeki nesneleri komut satırında rm komutuyla silebilir.

    3) Artık paylaşılan bellek alanı nesnesinin belleğe "map" edilmesi gerekmektedir. (Klasik Sistem 5 paylaşılan bellek alanlarında 
    "map etmek" yerine "attach etmek" terimi kullanılmaktaydı. Bu arayüzde ise "attach" yerine "mapping" sözcüğü tercih edilmiştir.)
    Bunun için mmap isimli bir POSIX fonksiyonu kullanılmaktadır. mmap fonksiyonu pek çok UNIX türevi sistemde bir sistem fonksiyonu 
    olarak gerçekleştirilmiştir. mmap, paylaşılan bellek alanlarının dışında başka amaçlarla da kullanılabilen ayrıntılı bir 
    sistem fonksiyonudur. Bu nedenle, biz burada önce fonksiyonun paylaşılan bellek alanlarında kullanımına kısaca değineceğiz. 
    Sonra bu fonksiyonu ayrıca daha ayrıntılı biçimde ele alacağız. mmap fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off);

    Fonksiyonun birinci parametresi, "mapping için" önerilen (preferred) sanal adresi belirtmektedir. Programcı, belli bir sanal 
    adresin mapping için kullanılmasını isteyebilir. Ancak fonksiyon, flags parametresinde MAP_FIXED geçilmemişse bu adresi 
    tam (exact) olarak yani verildiği gibi kullanmayabilir. Fonksiyon bu önerilen adresin yakınındaki bir sayfayı tahsis edebilir. 
    Bu tahsisatın burada belirtilen adresin neresinde yapılacağı garanti edilmemiştir. Yani buradaki adres eğer fonksiyonun flags 
    parametresinde MAP_FIXED kullanılmamışsa bir öneri niteliğindedir. Eğer bu adres NULL olarak geçilirse bu durumda mapping işlemi 
    işletim sisteminin kendi belirlediği bir adresten itibaren yapılır. Tabii en normal durum bu parametrenin NULL adres olarak 
    geçilmesidir.

    Fonksiyonun ikinci parametresi, paylaşılan bellek alanının ne kadarının map edileceğini belirtir. Örneğin paylaşılan bellek 
    alanı nesnesi 1 MB olabilir. Ancak biz onun 100K'lık bir kısmını map etmek isteyebiliriz. Ya da tüm paylaşılan bellek alanını 
    da map etmek isteyebiliriz. Bu uzunluk sayfa katlarında olmak zorunda değildir. Ancak pek çok sistem, bu uzunluğu sayfa katlarına 
    doğru yukarı yuvarlamaktadır. Yani biz uzunluğu örneğin 100 byte verebiliriz. Ancak sistem 100 byte yerine sayfa uzunluğu olan 
    4096 byte'ı map edecektir.

    Fonksiyonun üçüncü parametresi, mapping işleminin koruma özelliklerini belirtmektedir. Başka bir deyişle bu parametre paylaşılan 
    bellek alanı için ayrılacak fiziksel sayfaların işlemci düzeyinde koruma özelliklerini belirtir. Bu özellikler şu sembolik 
    sabitlerden oluşturulabilir:

    PROT_READ
    PROT_WRITE
    PROT_EXEC
    PROT_NONE

    PROT_READ sayfanın "read only" olduğunu belirtir. Böyle sayfalara yazma yapılırsa, işlemci exception oluşturur ve program 
    SIGSEGV sinyali ile sonlandırılır. PROT_WRITE sayfaya yazma yapılabileceğini belirtmektedir. Örneğin PROT_READ|PROT_WRITE 
    hem okuma hem de yazma anlamına gelmektedir. PROT_EXEC ilgili sayfada bir kod varsa (örneğin oraya bir fonksiyon yerleştirilmişse) 
    o kodun çalıştırılabilirliği üzerinde etkili olmaktadır. Örneğin Intel ve ARM işlemcilerinde, fiziksel sayfa PROT_EXEC ile 
    özelliklendirilmemişse o sayfadaki bir kod çalıştırılamamaktadır. PROT_NONE o sayfaya herhangi bir erişimin mümkün olamayacağını 
    belirtmektedir. Yani PROT_NONE olan bir sayfa ne okunabilir ne de yazılabilir. Bu tür sayfa özellikleri "guard page" oluşturmak 
    için kullanılabilmektedir. Tabii bir sayfanın koruma özelliği daha sonra da değiştirilebilir. Aslında bütün işlemciler buradaki 
    koruma özelliklerinin hepsini desteklemeyebilirler. Örneğin Intel işlemcilerinde PROT_WRITE zaten okuma özelliğini de kapsamaktadır. 
    Bazı işlemciler sayfalarda PROT_EXEC özelliğini hiç bulundurmamaktadır. Ancak ne olursa olsun programcı sanki bu özelliklerin 
    hepsi çalıştıkları işlemcide varmış gibi bu parametreyi oluşturmalıdır. Böylece kodun başka bir işlemcinin bulunduğu sistemde 
    de düzgün çalışması sağlanacaktır. Tabii burada belirtilen koruma bayraklarının paylaşılan bellek alanı nesnesi oluşturulurken 
    (yan shm_open fonksiyonundaki) belirtilen dosya bayraklarından daha geniş bir koruma içermemesi gerekir. Örneğin shm_open 
    fonksiyonunda O_RDONLY bayrağı kullanılmışsa mapping işlemi PROT_READ|PROT_WRITE biçiminde yapılamaz. Ancak shm_open fonksiyonunda
    O_RDWR bayrağı belirtilmişse mmap fonksiyonundaki koruma bayrakları PROT_READ ya da PROT_WRITE ya da PROT_READ|PROT_WRITE seçilebilir.

    Fonksiyonun dördüncü parametresi olan flags aşağıdaki değerlerden yalnızca birini alabilir:

    MAP_PRIVATE
    MAP_SHARED

    MAP_PRIVATE ile oluşturulan mapping'e "private mapping", MAP_SHARED ile oluşturulan mapping'e ise "shared mapping" denilmektedir. 
    MAP_PRIVATE "copy on write" denilen semantik için kullanılmaktadır. "Copy on write" işlemi "yazma yapılana kadar sanal sayfaların
    aynı fiziksel sayfalara yönlendirilmesi ancak yazmayla birlikte o sayfaların bir kopyalarının çıkartılıp yazmanın o prosese 
    özel olarak yapılması ve yapılan yazmaların paylaşılan bellek alanına yansıtılmaması" anlamına gelmektedir. Başka bir deyişle
    MAP_PRIVATE bayrağı şunlara yol açmaktadır:

    - Okuma yapılınca paylaşılan bellek alanından okuma yapılmış olur. 
    - Yazma yapıldığında bu yazma paylaşılan bellek alanına yansıtılmaz. O anda yazılan sayfanın bir kopyası çıkartılarak yazma o 
    kopya üzerine yapılır. Dolayısıyla başka bir proses bu yazma işlemini göremez.

    Bir proses ilgili paylaşılan bellek alanı nesnesini MAP_PRIVATE ile map ettiğinde ve diğer proses o alana yazma yaptığında onun 
    yazdığını MAP_PRIVATE yapan prosesin görüp görmeyeceği POSIX standartlarında belirsiz (unspecified) bırakılmıştır. Linux 
    sistemlerinin man sayfasında da bu durum "unspecified" olarak belirtilmiş olsa da mevcut Linux çekirdeklerinde başka bir 
    proses private mapping yapılmış yere yazma yaptığında bu yazma private mapping'in yapıldığı proseste görülmektedir. Ancak 
    private mapping yapan proses sayfaya yazma yaptığında artık o sayfanın kopyasından çıkartılacağı için bu yazma işleminden 
    sonraki diğer prosesin yaptığı yazma işlemleri görülmemektedir.

    MAP_SHARED ise yazma işleminin paylaşılan bellek alanına yapılacağını yani "copy on write" yapılmayacağını belirtmektedir. 
    Dolayısıyla MAP_SHARED bir mapping'te paylaşılan alana yazılanlar diğer prosesler tarafından görülür. Normal olarak programcılar
    prosesler arası haberleşme için shared mapping kullanırlar. Private mapping (yani "copy on write") bazı özel durumlarda tercih 
    edilmektedir. Örneğin işletim sistemi (exec fonksiyonları) çalıştırılabilir dosyanın ".data" bölümünü private mapping yaparak
    belleğe mmap ile yüklemektedirler.

    Fonksiyonun flags parametresinde MAP_PRIVATE ve MAP_SHARED değerlerinin yalnızca biri kullanılabilir. Ancak bu değerlerden
    biri ile MAP_FIXED değeri bit düzeyinde OR işlemine sokulabilmektedir. MAP_FIXED bayrağı fonksiyonun birinci parametresindeki
    adres NULL geçilmemişse bu adresin kendisinin aynen (hiç değiştirilmeden) kullanılacağını belirtmektedir. Yani bu adresin 
    yakınındaki herhangi bir sayfa değil tam olarak bu adresten itibaren tahsisat yapılacak ve fonksiyon bu adresin aynısıyla 
    geri dönecektir. (Tabii bu durumda programcının verdiği adres uygun olmayabilir. Bu durumda fonksiyon da başarısız olur.)
    Eğer MAP_FIXED bayrağı belirtilmişse Linux sistemlerinde birinci parametredeki adresin sayfa katlarında olma zorunluluğu 
    vardır. Ancak POSIX standartlarının son versiyonları "may require" ifadesiyle bunun zorunlu olmayabileceğini belirtmektedir.

    Fonksiyonun son iki parametresi dosya betimleyicisi ve bir de offset içermektedir. Paylaşılan bellek alanının belli bir 
    offset'ten sonraki kısmı map edilebilmektedir. Örneğin paylaşılan bellek alanı nesnemiz 4 MB olsun. Biz bu nesnenin 1 
    MB'sinden itibaren 64K'lık kısmını map edebiliriz. Örneğin mmap fonksiyonunu şöyle çağırabiliriz:

    shmaddr = mmap(NULL, SHM_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fdshm, 0);

    Burada paylaşılan bellek alanı nesnesinin SHM_SIZE kadar alanı map edilmek istenmiştir. İlgili sayfalar PROT_READ|PROT_WRITE
    özelliğine sahip olacaktır. Yani bu sayfalara yazma yapılabilecektir. Bu sayfalara yazma yapıldığında paylaşılan bellek alanı 
    nesnesi bundan etkilenecek, yani aynı nesneyi kullanan diğer proseslerde de eğer shared mapping yapılmışsa bu değişiklikler 
    gözükecektir. Burada paylaşılan bellek alanı nesnesinin 0'ıncı offset'inden itibaren SHM_SIZE kadar alanın map edildiğine 
    dikkat ediniz.

    mmap fonksiyonun son parametresindeki offset değeri flags parametresinde MAP_FIXED belirtilmişse, birinci parametre ile son 
    parametrenin sayfa katlarına bölümünden elde edilen kalan aynı olmak zorundadır. (Yani örneğin POSIX standartlarında işletim 
    sistemi eğer 5000 adresini kabul ediyorsa 5000 % 4096 = 4'tür. Bu durumda son parametrenin de 4096'ya bölümünden elde edilen
    kalanın da 4 olması gerekir.) Ancak flags parametresinde MAP_FIXED belirtilmemişse POSIX standartları bu offset değerinin 
    sayfa katlarında olup olmayacağını işletim sistemini yazanların isteğine bırakmıştır. Linux çekirdeklerinde MAP_FIXED belirtilsin 
    ya da belirtilmesin bu offset değeri her zaman sayfa katlarında olmak zorundadır.

    mmap fonksiyonu başarı durumunda mapping yapılan sanal bellek adresine geri dönmektedir. Fonksiyon başarısızlık durumunda 
    MAP_FAILED özel değerine geri döner. Pek çok sistemde MAP_FAILED bellekteki son adres olarak aşağıdaki biçimde define edilmiştir:

    #define MAP_FAILED ((void *) -1)

    mmap fonksiyonunun başarı kontrolü şöyle yapılabilir:

    shmaddr = mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shmaddr == MAP_FAILED)
        exit_sys("mmap");

    Paylaşılan bellek alanı betimleyicisi mapping işleminden sonra close fonksiyonuyla kapatılabilir. Bu durum mapping'i 
    etkilememektedir.

    4) Programcı paylaşılan bellek alanı ile işini bitirdikten sonra artık map ettiği alanı boşaltabilir. Bu işlem munmap POSIX 
    fonksiyonu ile yapılmaktadır. (mmap fonksiyonunu malloc gibi düşünürsek munmap fonksiyonunu da free gibi düşünebiliriz.)
    munmap fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    int munmap(void *addr, size_t len);

    Fonksiyonun birinci parametresi, daha önce map edilen alanın başlangıç adresini, ikinci parametresi ise unmap edilecek alanın 
    uzunluğunu belirtmektedir. Fonksiyon birinci parametresinde belirtilen adresten itibaren ikinci parametresinde belirtilen miktardaki 
    byte'ı içeren sayfaları unmap etmektedir. (Örneğin buradaki adres bir sayfanın ortalarında ise ve uzunluk da başka bir sayfanın
    ortalarına kadar geliyorsa bu iki sayfa da tümden unmap edilmektedir.) POSIX standartları işletim sistemlerinin birinci parametrede 
    belirtilen adresin sayfa katlarında olmasını zorlayabileceğini (may require) belirtmektedir. Linux'ta birinci parametrede belirtilen 
    adres sayfa katlarında olmak zorundadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve 
    errno değişkeni uygun biçimde set edilir. munmap ile zaten map edilmemiş bir alan unmap edilmeye çalışılırsa fonksiyon bir şey yapmaz.
    Bu durumda fonksiyon başarısızlıkla geri dönmemektedir.

    Paylaşılan bellek alanına ilişkin dosya betimleyicisi close fonksiyonu ile kapatılabilir. Paylaşılan bellek alanı betimleyicisi 
    close ile kapatıldığında munmap işlemi yapılmamaktadır. Zaten paylaşılan bellek alanı nesnesi map edildikten sonra hemen close 
    ile kapatılabilir. Bunun mapping işlemine bir etkisi olmaz. Ancak proses sonlandığında tabii unmap işlemi otomatik olarak yapılmaktadır.

    Unmap işlemi mevcut mapping'in bir kısmına yapılabilmektedir. Bu durumda işletim sistemi mapping işlemini ardışıl olmayan 
    parçalara kendisi ayırmaktadır. Örneğin:

    xxxxmmmmmmmmmxxxx

    Burada "m" map edilmiş sayfaları "x" ise diğer sayfaları belirtiyor olsun. Biz de mapping'in içerisinde iki sayfayı unmap edelim:

    xxxxmmmmxxmmmxxxx

    Görüldüğü gibi artık sanki iki ayrı mapping varmış gibi bir durum oluşmaktadır.

    Proses bittiğinde map edilmiş bütün alanlar zaten işletim sistemi tarafından unmap edilmektedir.

    5) Paylaşılan bellek alanı nesnesine ilişkin betimleyici close fonksiyonu ile sanki bir dosyaymış gibi kapatılır. Yukarıda da 
    belirttiğimiz gibi bu kapatma işlemi aslında mapping işleminden hemen sonra da yapılabilir.

    6) Artık paylaşılan bellek alanı nesnesi shm_unlink fonksiyonu ile silinebilir. Anımsanacağı gibi bu silme yapılmazsa sistem 
    reboot edilene kadar nesne hayatta kalmaya devam edecektir (kernel persistent). shm_unlink fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    int shm_unlink(const char *name);

    Fonksiyon paylaşılan bellek alanı nesnesinin ismini alarak onu yok eder. Başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir. Örneğin:

    if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    Tıpkı POSIX mesaj kuyruklarında olduğu gibi bir proses paylaşılan bellek alanını shm_unlink fonksiyonu ile silse bile paylaşılan 
    bellek alanını kullanan diğer prosesler unmap işlemi yapana kadar nesne gerçek anlamda silinmemektedir.

    Aşağıdaki örnekte "prog1" programı paylaşılan bellek alanına bir yazı yazmakta "prog2" programı da bu yazıyı alarak 
    stdout dosyasına yazdırmaktadır. Tabii "prog1" programı sürekli paylaşılan bellek alanının başına eskisini ezecek biçimde yazıları 
    yazar. Programı test ederken "prog1"de paylaşılan bellek alanına bir şeyler yazdıktan sonra "prog2"de ENTER tuşuna basarak o 
    yazılanların alınmasını sağlamalısınız. Paylaşılan bellek alanları kendi içerisinde bir senkronizasyon içermemektedir. 
    Örneğimizde "prog1" en sonunda paylaşılan bellek alanına "quit" yazdığında her iki program da sonlanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

#define SHM_NAME        "/sample_posix_shared_memory"
#define SHM_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdshm;
    char *shmaddr;
    char buf[4096];
    char *str;

    if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, SHM_SIZE) == -1)
        exit_sys("ftruncate");

    shmaddr = (char *)mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shmaddr == MAP_FAILED)
        exit_sys("mmap");

    for (;;) {
        printf("Text:");

        /* okuma doğrudan paylaşılan bellek alanına da yapılabilir */

        if (fgets(buf, 4096, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        strcpy(shmaddr, buf);
        if (!strcmp(buf, "quit"))
            break;
    }

    if (munmap(shmaddr, SHM_SIZE) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define SHM_NAME        "/sample_posix_shared_memory"
#define SHM_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int fdshm;
    char *shmaddr;

    if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
        exit_sys("shm_open");

    shmaddr = (char *)mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shmaddr == MAP_FAILED)
        exit_sys("mmap");

    for (;;) {
        printf("Press ENTER to read...");
        getchar();
        puts(shmaddr);
        if (!strcmp(shmaddr, "quit"))
            break;
    }

    if (munmap(shmaddr, SHM_SIZE) == -1)
        exit_sys("munmap");

    close(fdshm);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Konu ile ilgili tipik sorular ve yanıtları şunlardır:

    SORU: POSIX paylaşılan bellek alanı nesnesi demekle ne kastedilmektedir? 

    YANIT: shm_open fonksiyonu sanki bir dosya yaratıyor gibi paylaşılan bellek alanı nesnesini yaratmaktadır. Aslında ortada 
    bir dosya yoktur. Ancak gerçek dosyalar da map edilebildiğinden (ileride ele alınacak) tasarım sanki "paylaşılan bellek 
    alanı nesnesi bir dosyaymış, o nesneye bir şeyler yazdığımızda o dosyaya bir şeyler yazıyormuşuz" gibi yapılmıştır. Tabii 
    shm_open sırasında işletim sistemi sanal bellek alanı için swap dosyalarında yer de ayırabilmektedir.

    SORU: POSIX paylaşılan bellek alanı shm_open fonksiyonu ile yaratıldığında gerçekte diskte bir dosya yaratılmakta mıdır?

    YANIT: Hayır yapılmamaktadır. Yalnızca bize sanki paylaşılan bellek alanı nesneleri bir dosya gibi gösterilmektedir. İşletim 
    sistemi arka planda paylaşılan bellek alanı nesneleri için swap dosyalarında yer ayırabilmektedir.

    SORU: POSIX paylaşılan bellek alanları arka planda nasıl işlem görmektedir?

    YANIT: Arka plan çalışma klasik Sistem 5 paylaşılan bellek alanlarında olduğu gibidir. Yani yine proseslerin sayfa tablolarında 
    değişik sanal sayfa numaraları aynı fiziksel sayfalarla eşleştirilmektedir.

    SORU: ftruncate fonksiyonuna neden gereksinim duyulmaktadır? 

    YANIT: Paylaşılan bellek alanı shm_open ile ilk kez yaratıldığında henüz alanın içi boştur. Ona bir uzunluk vermek gerekmektedir. 
    ftruncate fonksiyonu ona bir uzunluk vermek için kullanılmaktadır. Tabii ftruncate fonksiyonu nesne yaratıldığı zaman bir kez 
    çağrılmalıdır. Ancak aynı uzunlukla ftruncate işleminde nesne üzerinde bir değişiklik olmayacaktır.

    SORU: Private mapping yapılmasının ne anlamı olabilir? Çünkü private mapping'te nesneye yapılan yazma işlemleri nesneye 
    yansıtılmamaktadır.

    YANIT: Private mapping'te nesneye yazma yapıldığında "copy on write" mekanizması devreye girer ve yazma yapılan sayfa paylaştırılan 
    sayfadan ayrıştırılır. Copy on write mekanizması işletim sisteminin pek çok yerinde kullanılmaktadır. Yani private mapping 
    programcılardan ziyade çekirdek tarafından kullanılmaktadır.

    SORU: Private mapping yapıldığında başka bir proses paylaşılan bellek alanına yazma yaptığında (tabii o proses de paylaşılan 
    bellek alanını shared mapping ile açmış olsun) bu yazma işlemini private mapping yapan taraf görür mü? 

    YANIT: Bu durum POSIX standartlarında "unspecified" bırakılmıştır. Linux çekirdeğinde bu yazma "private mapping yapan tarafta 
    eğer sayfada "copy on write" yapılmadıysa" görülmektedir.

    SORU: mmap fonksiyonun birinci parametresi ve sonuncu parametresi sayfa katlarında olmak zorunda mıdır? 

    YANIT: Eğer fonksiyonun flags parametresinde MAP_FIXED belirtilmemişse birinci parametre sayfa katlarında olmak zorunda değildir. 
    Ancak MAP_FIXED belirtilmişse POSIX'in eski versiyonu sayfa katlarını zorunlu tutmaktaydı. Ancak güncel versiyonda bu zorunluluk 
    gevşetilmiştir ve işletim sisteminin isteğine bağlı hale getirilmiştir. Linux çekirdeği MAP_FIXED durumunda birinci parametredeki
    adresin sayfa katlarında olmasını zorunlu tutmaktadır. Fonksiyonun son parametresindeki offset değeri eğer MAP_FIXED belirtilmişse 
    POSIX standartlarına göre birinci parametrede belirtilen adresin sayfa katlarına bölümüne elde edilen kalanla aynı kalanı 
    vermek zorundadır. Ancak POSIX standartları MAP_FIXED belirtilsin ya da belirtilmesin offset değerinin işletim sistemi tarafından 
    sayfa katlarında olmasının zorunlu tutulabileceğini (may require) de belirtmiştir. Linux sistemlerinde MAP_FIXED belirtilse de 
    belirtilmese de offset değeri sayfa katlarında olmak zorundadır.

    SORU: Paylaşılan bellek alanları shmget ya da shm_open fonksiyonuyla oluşturulduktan sonra neden onların attach edilmesi ya da 
    map edilmesi gerekmektedir?

    YANIT: Klasik Sistem 5'teki shmget ve POSIX'teki shm_open fonksiyonları nesnenin kendisini oluşturur. Bu nesnenin proseste 
    kullanılabilmesi için prosesin adres alanı içerisine attach ya da map edilmesi gerekmektedir. Yani nesnenin var olması ayrı 
    bir durumdur onun proses tarafından kullanılır duruma getirilmesi ayrı bir durumdur. Kaldı ki aynı nesne aynı prosesin adres 
    alanı içerisinde birden fazla kez de attach ya da map edilebilir. Örneğin tipik olarak işletim sistemi shm_open fonksiyonu ile 
    bir paylaşılan bellek alanı oluşturulduğunda o alanı bir swap dosyası içerisinde diskte oluşturmaktadır. Sonra bu paylaşılan 
    bellek alanı, prosesin sanal bellek alanına map edildiğinde işletim sistemi prosesin sayfa tablosunda ilgili girişleri ayırır 
    ve paylaşılan bellek alanı kullanılmaya başlandığında onu RAM'e çeker. Başka bir proses de onu kullanmak isterse o prosesin 
    sayfa tablosunda o girişleri aynı fiziksel sayfaya yönlendirir.

    SORU: Paylaşılan bellek alanı shm_open ile açıldıktan sonra bu betimleyiciyi ne zaman kapatmalıyız? 

    YANIT: Aslında mapping işlemi yapıldıktan sonra bu betimleyiciyi hemen kapatabiliriz. Ancak bazen bu betimleyici ile 
    başka işlemlerin yapılması da gerekebilmektedir. Örneğin fstat fonksiyonu ile bu betimleyiciyi kullanarak paylaşılan bellek 
    alanının büyüklüğünü elde edebiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                47. Ders 16/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyalar (memory mapped files) 90'lı yıllarla birlikte işletim sistemlerine sokulmuştur. 90'ların ortalarında 
    bellek tabanlı dosyalar POSIX IPC nesneleriyle birlikte UNIX türevi sistemlere de resmi olarak sokulmuştur. macOS sistemleri 
    de bellek tabanlı dosyaları desteklemektedir. Microsoft ise ilk kez 32 bit Windows sistemlerinde (Windows NT (1993) ve 
    sonra da Windows 95 (1995)) bellek tabanlı dosyaları işletim sisteminin çekirdeğine dahil etmiştir.

    Bellek tabanlı dosyalar (memory mapped files) adeta diskte bulunan bir dosyanın prosesin sanal bellek alanına çekilmesi 
    anlamına gelmektedir. Biz bir disk dosyasını bellek tabanlı biçimde açıp kullandığımızda dosya sanki bellekteymiş gibi bir 
    durum oluşturulur. Biz bellekte göstericilerle dosyanın byte'larına erişiriz. Bellekte birtakım değişiklikler yapıldığında 
    bu değişiklikler dosyaya yansıtılmaktadır. Böylece dosya üzerinde işlemler yapılırken read ve write sistem fonksiyonları 
    yerine doğrudan göstericilerle bellek üzerinde işlem yapılmış olur.

    Örneğin read fonksiyonu ile dosyanın bir kısmını okumak isteyelim:

    result = read(fd, buf, size);

    Burada genellikle işletim sistemlerinde arka planda iki işlem yapılmaktadır: Önce dosyanın ilgili bölümü işletim sisteminin
    çekirdeği içerisindeki bir alana (bu alana buffer cache ya da page cache denilmektedir) çekilir. Sonra bu alandan bizim 
    belirttiğimiz alana aktarım yapılır. Halbuki bellek tabanlı dosyalarda genel olarak bu iki aktarım yerine dosya doğrudan 
    prosesin bellek alanına map edilmektedir. Yani bu anlamda bellek tabanlı dosyalar hız ve bellek kazancı sağlamaktadır. 
    Ayrıca her read ve write işleminin kontrol edilme zorunluluğu da bellek tabanlı dosyalarda ortadan kalkmaktadır. Bir dosya 
    üzerinde dosyanın farklı yerlerinden okuma ve yazma işlemlerinin sürekli yapıldığı durumlarda bellek tabanlı dosyalar 
    klasik read/write sistemine göre oldukça avantaj sağlamaktadır.

    Bu noktada kişilerin akıllarına şu soru gelmektedir? Biz bir dosyayı open ile açsak dosyanın tamamını read ile belleğe 
    okusak sonra işlemleri bellek üzerinde yapsak, sonra da write fonksiyonu ile tek hamlede yine onları diske yazsak bu 
    yöntemin bellek tabanlı dosyalardan bir farkı kalır mı? Bu soruda önerilen yöntem bellek tabanlı dosya çalışmasına 
    benzemekle birlikte bellek tabanlı dosyalar bu sorudaki çalışma biçiminden oldukça farklıdır. Birincisi, dosyanın 
    tamamının belleğe okunması yine iki tamponun devreye girmesine yol açmaktadır. İkincisi ise bellek tabanlı dosyaların 
    bir mapping oluşturması ve dolayısıyla prosesler arasında etkin bir kullanıma yol açmasıdır. Yani örneğin iki proses 
    aynı dosyayı bellek tabanlı olarak açtığında işletim sistemi her proses için ayrı bir alan oluşturmamakta dosyanın 
    parçalarını fiziksel bellekte bir yere yerleştirip o proseslerin aynı yerden çalışmasını sağlamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı bellek tabanlı (memory mapped) biçimde kullanmak için sırasıyla şu adımlardan geçilmektedir:

    1) Dosya open fonksiyonuyla açılır ve bir dosya betimleyicisi elde edilir. Örneğin:

    int fd;
    ...

    if ((fd = open("test.txt", O_RDWR)) == -1)
        exit_sys("open");

    İleride de belirtileceği gibi dosyalar bellek tabanlı olarak yaratılamamakta ve dosyalara bellek tabanlı biçimde eklemeler 
    yapılamamaktadır. Yani zaten var olan dosyalar bellek tabanlı biçimde kullanılabilirler.

    2) Açılmış olan dosya mmap fonksiyonu ile prosesin sanal bellek alanına map edilir. Yani işlemler adeta önceki konuda gördüğümüz
    POSIX paylaşılan bellek alanlarına benzer bir biçimde yürütülmektedir. (Burada shm_open yerine open fonksiyonunun kullanıldığını 
    varsayabilirsiniz.) Mapping işleminde genellikle shared mapping (MAP_SHARED) tercih edilir. Eğer private mapping (MAP_PRIVATE)
    yapılırsa mapping yapılan alana yazma yapıldığında yazma bu dosyaya yansıtılmaz, "copy on write" mekanizması devreye girer.
    mmap fonksiyonun son iki parametresi dosya betimleyicisi ve dosyada bir offset belirtmektedir. İşte dosya betimleyicisi olarak 
    açmış olduğumuz dosyanın betimleyicisini verebiliriz. Offset olarak da dosyanın neresini map edeceksek oranın başlangıç offset'ini 
    verebiliriz. Mapping sırasında dosya göstericisinin konumunun bir önemi yoktur. Örneğin:

    char *maddr;
    struct stat finfo;
    ...

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
        exit_sys("mmap");

    Burada biz önce dosyanın uzunluğunu fstat fonksiyonu ile elde ettik sonra da mmap fonksiyonu ile dosyanın hepsini 
    shared mapping yaparak map ettik. Artık dosya bellektedir ve biz dosya işlemleri yerine gösterici işlemleri ile bellekteki 
    dosyayı kullanabiliriz. Örneğin:

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    mapping işleminden sonra artık dosya betimleyicisi close fonksiyonuyla kapatılabilir. Yani kapatım için unmap işleminin 
    beklenmesine gerek yoktur.

    3) Tıpkı POSIX paylaşılan bellek alanlarında olduğu gibi işimiz bittikten sonra yapılan mapping işlemini munmap fonksiyonu ile 
    serbest bırakabiliriz. Eğer bu işlemi yapmazsak proses sonlandığında zaten map edilmiş alanlar otomatik olarak unmap edilecektir. 
    Örneğin:

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    4) Nihayet dosya betimleyicisi close fonksiyonuyla kapatılabilir. Yukarıda da belirttiğimiz gibi aslında map işlemi yapıldıktan 
    sonra hemen de close fonksiyonu ile dosya betimleyicisini kapatabilirdik. Örneğin:

    close(fd);

    Aşağıdaki örnekte komut satırından alınan dosya bellek tabanlı biçimde açılmış ve dosyanın içindekiler ekrana (stdout dosyasına)
    yazdırılmıştır. Aynı zamanda dosyanın başındaki ilk 6 karakter değiştirilmiştir. Programı çalıştırırken dosyanın başındaki 
    ilk 6 karakterin bozulacağına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
        exit_sys("mmap");

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    memcpy(maddr, "xxxxx", 6);        /* dosya güncelleniyor */

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyaları (memory mapped files) açarken ve kullanırken bazı ayrıntılara dikkat edilmesi gerekir. Burada 
    bu ayrıntılar üzerinde duracağız. 

    - Dosyayı bizim mmap fonksiyonundaki sayfa koruma özelliklerine uygun açmamız gerekmektedir. Örneğin biz dosyayı O_RDONLY 
    modunda açıp buna ilişkin sayfaları mmap fonksiyonunda PROT_READ|PROT_WRITE olarak belirlersek mmap başarısız olacak ve errno 
    EACCESS değeri ile set edilecektir. Eğer biz dosyayı O_RDWR modunda açtığımız halde mmap fonksiyonunda yalnızca PROT_READ 
    kullanırsak bu durumda dosyaya yazma hakkımız olsa da sayfa özellikleri "read only" olduğu için o bellek bölgesine yazma 
    yapılırken program SIGSEGV sinyali ile çökecektir.

    - Bellek tabanlı dosyaların O_WRONLY modunda açılması probleme yol açabilmektedir. Çünkü böyle açılmış olan bir dosyanın mmap 
    fonksiyonunda PROT_WRITE olarak map edilmesi gerekir. Halbuki Intel gibi bazı işlemcilerde PROT_WRITE zaten aynı zamanda okuma
    izni anlamına da gelmektedir. Yani örneğin Intel'de PROT_READ diye bir sayfa özelliği yoktur. PROT_WRITE aslında PROT_READ|PROT_WRITE
    anlamına gelmektedir. Dolayısıyla biz dosyayı O_WRONLY modunda açıp mmap fonksiyonunda PROT_WRITE özelliğini belirtirsek 
    bu PROT_WRITE aynı zamanda okuma izni anlamına da geldiği için mmap başarısız olacak ve errno EACCESS değeri ile set edilecektir. 
    POSIX standartlarında da bellek tabanlı dosyaların (aynı durum shm_open için de geçerli) açılırken "read" özelliğinin olması 
    gerektiği belirtilmiştir. Yani POSIX standartları da bellek tabanlı dosyaların O_WRONLY modda açılamayacağını açılırsa mmap 
    fonksiyonun başarısız olacağını ve errno değerinin EACCESS olarak set edileceğini belirtmektedir.

    - Bir dosyanın uzunluğu 0 ise biz mmap fonksiyonunda length parametresini 0 yapamayız. Fonksiyon doğrudan başarısızlıkla 
    sonlanıp errno değeri EINVAL olarak set edilmektedir.

    - Anımsanacağı gibi mmap fonksiyonunun offset parametresi Linux sistemlerinde sayfa uzunluğunun katlarında olması gerekiyordu
    (POSIX bunu "may require" biçimde belirtmiştir). Yani Linux'ta biz dosyayı zaten sayfa katlarından itibaren map edebilmekteyiz. 
    Bu durumda Linux'ta zaten map edilen adres, sayfanın başında olmaktadır.

    - Biz normal bir dosyayı büyütmek için dosya göstericisini EOF durumuna çekip yazma yapıyorduk. Ya da benzer işlemi truncate, 
    ftruncate fonksiyonlarıyla da yapabiliyorduk. Halbuki bellek tabanlı olarak açılmış olan dosyalar bellek üzerinde hiçbir 
    biçimde büyütülememektedir. Biz bir dosyayı mmap fonksiyonu ile dosya uzunluğundan daha fazla uzunlukta map edebiliriz. Örneğin 
    dosya 10000 byte uzunlukta olduğu halde biz dosyayı 20000 byte olarak map edebiliriz. Bu durumda dosyanın sonundan o 
    sayfanın sonuna kadarki alana biz istediğimiz gibi erişebiliriz. Dosyanın uzunluğu 10000 byte ise dosyanın son sayfasında 
    dosyaya dahil olmayan 2288 byte bulunacaktır (3 * 4096 - 10000). İşte bizim bu son sayfadaki 2288 byte'a erişmemizde hiçbir 
    sakınca yoktur. Ancak bu sayfanın ötesinde erişim yapamayız. Yani bizim artık 3 * 4096 = 12288'den 20000'e kadarki alana 
    erişmeye çalışmamamız gerekir. Eğer bu alana erişmeye çalışırsak SIGBUS sinyali oluşur ve prosesimiz sonlandırılır. Pekiyi 
    bir dosyanın uzunluğundan fazla yerin map edilmesinin bir anlamı olabilir mi? Daha önceden de belirttiğimiz gibi bellek 
    tabanlı dosyalar bellek üzerinde büyütülemezler. Yani biz dosyayı uzunluğunun ötesinde map ederek oraya yazma yapmak suretiyle 
    büyütemeyiz. Ancak dosyalar dışarıdan büyütülebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                48. Ders 29/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyaların çalışma mekanizmasının iyi anlaşılması için öncelikle dosya işlemlerinde read ve write işlemlerinin
    nasıl yapıldığı hakkında bilgi sahibi olunması gerekmektedir.

    Biz write POSIX fonksiyonuyla dosyaya bir yazma yaptığımızda write fonksiyonu genellikle doğrudan bu işlemi yapan bir sistem 
    fonksiyonunu çağırmaktadır. Örneğin Linux sistemlerinde write fonksiyonu, prosesi kernel mode'a geçirerek doğrudan sys_write isimli 
    sistem fonksiyonunu çağırır. Pekiyi bu sys_write sistem fonksiyonu ne yapmaktadır? Genellikle işletim sistemlerinde 
    dosyaya yazma yapan sistem fonksiyonları hemen yazma işlemini diske yapmazlar. Önce kernel içerisindeki bir tampona yazma yaparlar. 
    Bu tampona Linux sistemlerinde eskiden "buffer cache" denirdi. Sonradan sistem biraz değiştirildi ve "page cache" denilmeye başlandı. 
    İşte bu tampon sistemi işletim sisteminin bir "kernel thread'i" tarafından belli periyotlarla diske flush edilmektedir. 
    Yani biz diske write fonksiyonu ile yazma yaptığımızda aslında bu yazılanlar önce kernel içerisindeki bir tampona (Linux'ta page cache)
    yazılmakta ve işletim sisteminin bağımsız çalışan başka bir akışı tarafından çok bekletilmeden bu tamponlar diske flush edilmektedir. 
    Pekiyi neden write fonksiyonu doğrudan diske yazmak yerine önce bir tampona (page cache) yazmaktadır? İşte bunun amacı 
    performansın artırılmasıdır. Bu konuya genel olarak "IO çizelgelemesi (IO scheduling)" denilmektedir. IO çizelgelemesi, 
    diske yazılacak ya da diskten okunacak bilgilerin bazılarının bir araya getirilerek belli bir sırada işleme sokulması anlamına 
    gelmektedir. (Örneğin biz dosyaya peşi sıra birkaç write işlemi yapmış olalım. Bu birkaç write işlemi aslında kernel içerisindeki 
    page cache'e yapılacak ve bu page cache'teki sayfa tek hamlede işletim sistemi tarafından diske flush edilecektir.) Tabii işletim 
    sisteminin arka planda bu tamponları flush eden kernel thread'i çok fazla beklemeden bu işi yapmaya çalışmaktadır. Aksi takdirde 
    elektrik kesilmesi gibi durumlarda bilgi kayıpları daha yüksek düzeyde olabilmektedir. Pekiyi biz write fonksiyonu ile yazma yaptığımızda 
    mademki yazılanlar hemen diskteki dosyaya aktarılmıyor o halde başka bir proses tam bu işlemden hemen sonra open fonksiyonu ile dosyayı 
    açıp ilgili yerden okuma yapsa bizim en son yazdıklarımızı okuyabilecek midir? POSIX standartlarına göre write fonksiyonu geri 
    döndüğünde artık aynı dosyadan bir sonraki read işlemi ne olursa olsun write yapılan bilgiyi okumalıdır. İşte işletim sistemleri 
    zaten bir dosya açıldığında read işleminde de write işleminin kullandığı aynı tamponu kullanmaktadır. Bu tasarıma "unified file system" 
    de denilmektedir. Bu tasarımdan dolayı zaten ilgili dosya üzerinde işlem yapan herkes aynı işletim sistemi içerisindeki 
    tamponları kullanmaktadır. Dolayısıyla bu tamponların o anda flush edilip edilmediğinin bir önemi kalmamaktadır. (Tabii bir proses 
    işletim sistemini bypass edip doğrudan disk sektörlerine erişirse bu durumda gerçekten henüz write fonksiyonu ile yazılanların 
    dosyaya yazılmamış olduğunu görebilir.)

    Pekiyi biz bir dosyayı bellek tabanlı olarak açarak o bellek alanını güncellediğimizde oradaki güncellemeler başka prosesler
    tarafından read işlemi sırasında görülecek midir? Ya da tam tersi olarak başka prosesler write yaptığında bizim map ettiğimiz 
    bellek otomatik bu yazılanları görecek midir? İşte POSIX standartları bunun garantisini vermemiştir. POSIX standartlarında 
    bellek tabanlı dosyanın bellek içeriğinde değişiklik yapıldığında bu değişikliğin diğer prosesler tarafından görülebilmesi için ya da 
    diğer proseslerin yaptığı write işleminin bellek tabanlı dosyanın bellek alanına yansıtılabilmesi için msync isimli bir POSIX 
    fonksiyonunun çağrılması gerekmektedir. Her ne kadar POSIX standartları bu msync fonksiyonunun çağrılması gerektiğini belirtiyorsa 
    da Linux gibi pek çok UNIX türevi sistem "unified file system" tasarımı nedeniyle aslında msync çağrısına gereksinim 
    duymamaktadır. Örneğin Linux'ta biz bir bellek tabanlı dosyayı map ettiğimizde aslında sayfa tablosunda bizim map ettiğimiz kısım
    doğrudan zaten işletim sisteminin tamponunu (page cache) göstermektedir. Sistem dosyanın o parçası için her zaman o tamponu 
    kullandığından dolayı aslında bellek tabanlı dosyanın bellek alanına yazma yapıldığında Linux'ta o yazma adeta o anda dosyaya 
    yapılmış gibi bir durum oluşmaktadır. Benzer biçimde başka bir proses dosyaya yazma yaptığında aslında o da aynı tampona 
    (page cache) yazma yapmış olmaktadır. Ancak ne olursa olsun taşınabilir programların bu msync fonksiyonunu aşağıda belirteceğimiz 
    biçimde çağırması gerekmektedir.

    Aşağıdaki örnekte "sample.c" programı bir dosyayı bellek tabanlı olarak açıp beklemiştir. "mample.c" isimli program ise 
    aynı dosyayı open fonksiyonu ile açıp dosyanın başına write işlemi yapıp beklemiştir. Linux sistemlerinde hiç msync fonksiyonu
    çağrılmadan "mample.c" programının yazdığı şeyler "sample.c" programı tarafından görülecektir. Bu testi yaparken önce içi dolu 
    olan bir dosya yaratınız. Bu dosyanın "test.txt" olduğunu varsayalım. Farklı terminallerden programları aşağıdaki gibi çalıştırınız:

    $ ./sample test.txt
    $ ./mample test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
        exit_sys("mmap");

    printf("Press ENTER to continue...\n");

    getchar();

    printf("---------\n");

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    printf("press ENTER to exit...\n");
    getchar();

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, "zzzzz", 5) == -1 )
        exit_sys("write");

    printf("Press ENTER to exit...\n");

    getchar();

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi her ne kadar Linux gibi "unified file system" tasarımını kullanan işletim sistemlerinde msync
    fonksiyonu gerekmiyorsa da bellek tabanlı dosyada yapılan değişikliklerin diskteki dosyaya yansıtılması, diskteki dosyada 
    yapılan değişikliklerin bellek tabanlı dosyanın bellek alanına yansıtılması için msync isimli POSIX fonksiyonun çağrılması 
    gerekmektedir. msync fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    int msync(void *addr, size_t len, int flags);

    Fonksiyonun birinci parametresi flush edilecek bellek tabanlı dosyanın bellek adresini, ikinci parametresi bunun uzunluğunu 
    belirtmektedir. POSIX standartlarına göre birinci parametrede belirtilen adresin "sayfa katlarında olması zorunlu değildir, 
    ancak işletim sistemi bunu zorunlu yapabilir (may require)". Linux sistemlerinde bu adresin sayfa katlarında olması zorunlu 
    tutulmuştur. Fonksiyonun ikinci parametresi flush edilecek byte miktarını belirtmektedir. Burada belirtilen byte miktarı 
    ve girilen adresi kapsayan tüm sayfalar işleme sokulmaktadır. (Örneğin birinci parametrede belirtilen adres sayfa katlarında 
    olsun. Biz ikinci parametre için 7000 girsek sayfa uzunluğu 4K ise sanki 8192 girmiş gibi etki oluşacaktır.) Fonksiyonun son 
    parametresi flush işleminin yönünü belirtmektedir. Bu parametre aşağıdaki bayraklardan yalnızca birini alabilir:

    MS_SYNC: Burada yön bellekten diske doğrudur. Yani biz bellek tabanlı dosyanın bellek alanında değişiklik yaptığımızda bunun
    diskteki dosyaya yansıtılabilmesi için MS_SYNC kullanabiliriz. Bu bayrak aynı zamanda msync fonksiyonu geri döndüğünde flush 
    işleminin bittiğinin garanti edilmesini sağlamaktadır. Yani bu bayrağı kullandığımızda msync flush işlemi bitince geri dönmektedir.

    MS_ASYNC: MS_SYNC bayrağı gibidir. Ancak bu bayrakta flush işlemi başlatılıp msync fonksiyonu hemen geri dönmektedir. Yani
    bu bayrakta msync geri döndüğünde flush işlemi başlatılmıştır ancak bitmiş olmak zorunda değildir.

    MS_INVALIDATE: Buradaki yön diskten belleğe doğrudur. Yani başka bir proses diskteki dosyayı güncellendiğinde bu güncellemenin
    bellek tabanlı dosyanın bellek alanına yansıtılması sağlanmaktadır.

    munmap işlemi ile bellek tabanlı dosyanın bellek alanı unmap edilirken zaten msync işlemi yapılmaktadır. Benzer biçimde proses
    munmap yapmadan sonlanmış olsa bile sonlanma sırasında munmap işlemi işletim sistemi tarafından yapılmakta ve bu flush işlemi de
    gerçekleştirilmektedir.

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Bu durumda biz POSIX standartlarına uygunluk bakımından örneğin bir bellek tabanlı dosyanın bellek alanına bir şeyler yazdığımızda
    o alanın flush edilmesi için MS_SYNC ya da MS_ASYNC bayraklarıyla msync çağrısını yapmamız gerekir:

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
        exit_sys("mmap");

    memcpy(maddr, "ankara", 6);

    if (msync(maddr, finfo.st_size, MS_SYNC) == -1)        /* bellekteki değişiklikler diske yansıtılıyor */
        exit_sys("msync");

    Yine POSIX standartlarına uygunluk bakımından dışarıdan bir prosesin bellek tabanlı dosyada değişiklik yapması durumunda
    onun bellek tabanlı dosyanın bellek alanına yansıtılabilmesi için MS_INVALIDATE bayrağı ile msync fonksiyonunun çağrılması 
    gerekmektedir. Örneğin:

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    /* başka bir proses dosya üzerinde değişiklik yapmış olsun */

    if (msync(maddr, finfo.st_size, MS_INVALIDATE) == -1)        /* diskteki değişiklikler belleğe yansıtılıyor */
        exit_sys("msync");

    msync fonksiyonunda yalnızca tek bir bayrak kullanılabilmektedir. Bu nedenle iki işlemi MS_SYNC|MS_INVALIDATE biçiminde
    birlikte yapmaya çalışmayınız.

    Aşağıda msync fonksiyonunun kullanımına ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
        exit_sys("mmap");

    memcpy(maddr, "ankara", 6);

    if (msync(maddr, finfo.st_size, MS_SYNC) == -1)
        exit_sys("msync");

    printf("Press ENTER to continue...\n");

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bellek tabanlı dosyanın MAP_PRIVATE ile private olarak map edilmesinin nasıl bir amacı olabilir? İşte daha önceden 
    de belirtildiği gibi "private mapping" "copy on write" mekanizması için kullanılmaktadır. Örneğin iki porses aynı dosyayı 
    private mapping yaptığında işletim sistemi bu iki prosesin dosyasını fiziksel bellekte aynı tamponu (page cache) belirtecek 
    biçimde ayarlamaktadır. Ancak proseslerden biri dosyaya yazma yaptığında bu yazma dosyaya değil, tamponun o anda çıkartılan 
    başka bir kopyasına yapılmaktadır. Yani "copy on write" şu anlama gelmektedir: "Okuma yapıldığı sürece aynı tamponu paylaş, 
    yazma yapıldığında o sayfayı ayır".

    Bellek tabanlı dosyalarda private mapping özellikle işletim sistemi tarafından "çalıştırılabilir (executable)" dosyaların 
    ve "dinamik kütüphanelerin" yüklenmesi sırasında kullanılmaktadır. Örneğin "sample" isimli çalıştırılabilir bir ELF dosyasının 
    içeriği "kabaca" şöyledir:

    .text
    .data
    .bss
    diğer bölümler (sections)

    ELF formatı "bölümlerden (sections)" oluşmaktadır. exec fonksiyonları ELF formatını yüklerken her bölümü "sections" private 
    mapping yaparak belleğe yüklemektedir. Dolayısıyla bir programı ikinci kez çalıştırdığımızda aslında mümkün olduğunca aynı 
    fiziksel bellek kullanılmakta bir proses yazma yaptığında ilgili sayfa "copy on write" mekanizması yoluyla farklılaştırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde mmap fonksiyonun MAP_SHARED, MAP_PRIVATE ve MAP_FIXED bayraklarının dışında POSIX'te olmayan başka 
    bayrakları da vardır. Bu bayraklardan en önemlisi MAP_ANONYMOUS bayrağıdır. Bu bayrakla mapping yapıldığında bu duruma
    Linux sistemlerinde "anonymous mapping" denilmektedir. Anonymous mapping, dosya üzerinde (yani bellek tabanlı dosya biçiminde)
    yapılamamaktadır. Dolayısıyla anonymous mapping yapılırken mmap fonksiyonunun fd ve offset parametreleri dikkate alınmamaktadır.

    Anonymous mapping işleminde kalıcı yer olarak (backing store) doğrudan işletim sisteminin "swap dosyaları" kullanılmaktadır. 
    Böylece aslında anonymous mapping adeta bellek tahsisatı anlamına gelmektedir. Zaten glibc kütüphanesindeki malloc, calloc 
    ve realloc fonksiyonları arka planda "anonymous mapping" işlemini yapmaktadır. Tipik olarak glibc kütüphanesinde "malloc" 
    fonksiyonu önce geniş bir alanı mmap fonksiyonu ile anonymous mapping yaparak yaratmakta sonra bu alanı tahsisat için organize 
    etmektedir. Yani malloc fonksiyonu güncel kütüphanede aslında önce geniş bir alanı anonymous mapping yöntemiyle tahsis etmekte 
    sonra orayı organize etmektedir. Pekiyi biz anonymous mapping işlemini malloc işlemi yerine kullanabilir miyiz? Aslında 
    kullanabiliriz. Ancak anonymous mapping sayfa katlarında tahsisat yapmaktadır. Oysa malloc fonksiyonu byte temelinde tahsisat 
    yapmaktadır. Bu durumda anonymous mapping yerine malloc işlemi genel olarak çok daha uygundur. Fakat yine de büyük blokların 
    tahsis edilmesi gibi durumlarda anonymous mapping daha doğrudan ve daha hızlı bir tahsisata olanak verebilmektedir.

    mmap fonksiyonunda MAP_ANONYMOUS kullanıldığında fonksiyonun fd parametresi dikkate alınmamaktadır. Ancak MAP_ANONYMOUS b
    ayrağını destekleyen diğer bazı işletim sistemlerinde bu parametrenin -1 girilmesi gerekmektedir. Bu nedenle bu parametrenin -1 
    olması uygundur. Fonksiyonun offset parametresi de dikkate alınmamaktadır. Bu parametre 0 olarak girilebilir.

    MAP_ANONYMOUS bayrağı MAP_PRIVATE ya da MAP_SHARED ile birlikte kullanılmaktadır. En normal durum MAP_ANONYMOUS bayrağı 
    ile MAP_PRIVATE bayrağının birlikte kullanılmasıdır. Pekiyi MAP_ANONYMOUS|MAP_PRIVATE ile MAP_ANONUMOUS|MAP_SHARED 
    arasında ne farklılık vardır? İşte normal olarak anonymous mapping için ayrılan swap alanı başka prosesler tarafından 
    kullanılamamaktadır. Ancak fork işlemi üst proses bir proses yarattığında tüm mapping alanları alt prosese aktarılmaktadır.
     O halde biz MAP_ANONYMOUS|MAP_SHARED uyguladığımızda fork yapmadıktan sonra bunun MAP_ANONYMOUS|MAP_SHARED işleminden 
     hiçbir farkı olmayacaktır. Ancak fork yapıldığında MAP_ANONYMOUS|MAP_SHARED uygulamasında üst ve alt prosesler aynı 
     anonymous alanı paylaşacaktır. Yani örneğin üst proses buraya bir şey yazdığında alt proses onu görecektir. Ancak 
     MAP_ANONYMOUS|MAP_PRIVATE uygulamasında üst proseslerden biri alana bir şey yazdığında "copy on write" mekanizması 
     devreye girecek ve yazılanı diğer proses görmeyecektir. malloc fonksiyonu da arka planda büyük alanı mmap ile tahsis 
     ederken MAP_ANONYMOUS|MAP_PRIVATE uygulamaktadır.

    Aşağıdaki örnekte mmap ile anonymous mapping örneği verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char *maddr;

    if ((maddr = (char *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    strcpy(maddr, "ankara");
    puts(maddr);

    if (munmap(maddr, 4096) == -1)
        exit_sys("munmap");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre mmap fonksiyonunda bir tahsisat yapıldığında dosyaya ilişkin olmayan tüm alanlar otomatik olarak 
    sıfırlanmaktadır. Linux sistemlerinde de durum böyledir. Default olarak anonymous mapping yapıldığında da tahsis edilen 
    alan sıfırlanmaktadır. Ancak Linux'ta, POSIX'te olmayan MAP_UNINITIALIZED isimli bir bayrak da vardır. Eğer bu bayrak 
    kullanılırsa tahsis edilen alanlar sıfırlanmaz. Bazen programcılar tahsisatı hızlandırmak için MAP_ANONYMOUS|MAP_PRIVATE
    |MAP_UNINITIALIZED biçiminde bayrak kullanabilmektedir.

    Daha önceden de "çalıştırılabilir dosyaların exec fonksiyonları tarafından bölüm bölüm (section section) belleğe mmap 
    mekanizmasıyla map edildiğini belirtmiştik. İşte ilk değer verilmemiş global değişkenlerin bulunduğu ".bss" alanı da 
    zaten mapping işlemi yapılırken sıfırlanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                49. Ders 30/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sanal bellek kullanan işletim sistemlerinde bazı sayfaların lock edilmesine olanak verilebilmektedir. Bir sayfa lock 
    edildiğinde artık o sayfa fiziksel RAM'de yer açmak için işletim sistemi tarafından "swap out" yapılmamaktadır. Bir sayfanın 
    belleğe lock edilmesinin iki avantajı olabilmektedir:

    1) Bu sayede swap out yapılmayacağı için göreli bir hız kazancı sağlanır. Özellikle gerçek zamanlı uygulamalarda bu tür hız 
    kazançları önemli olabilmektedir.
    2) Bu sayede swap dosyalarından bilgi çalmaya çalışan kişiler engellenmiş olur. Tabii swap dosyalarından bilgi çalmak da 
    aslında kolay bir şey değildir.

    Pekiyi bir proses istediği kadar sanal sayfayı lock edebilir mi? Şüphesiz eğer prosesler istedikleri kadar sanal sayfayı 
    lock edebilselerdi swap işlemleri konusunda dolayısıyla sanal bellek kullanımı konusunda bir baskı oluşurdu. Bu nedenle işletim 
    sistemlerinde uygun önceliğe sahip olmayan proseslerin lock edebileceği sayfa sayısında bir sınırlama yapılmaktadır. Linux'ta 
    uygun önceliğe sahip olmayan proseslerin kilitleyebileceği sayfa sayısı RLIMIT_MEMLOCK isimli kaynak limitiyle belirlenmiştir. 
    Bu kaynak limitinin hem hard hem de soft değeri mevcut Linux çekirdeklerinde 509853696 byte (124476 sayfa) kadardır. Ancak 
    Linux sistemlerinde "uygun önceliğe sahip olan (appropriate privileges)" prosesler istedikleri kadar sayfayı kilitleyebilmektedir. 
    Yani bu prosesler prosesin RLIMIT_MEMLOCK limitlerinden etkilenmemektedir.

    Sanal sayfaların belleğe lock edilmesi için birkaç fonksiyon kullanılabilmektedir. Bu amaçla kullanılan mlock isimli POSIX 
    fonksiyonunun prototipi şöyledir:

    int mlock(const void *addr, size_t len);

    Fonksiyon birinci parametresiyle belirtilen adresten itibaren ikinci parametresiyle belirtilen uzunluktaki bellek alanını lock 
    etmektedir. Buradaki adres + uzunluk içerisinde kalan tüm sayfalar lock edilmektedir. (Yani adres bir sayfanın başına hizalanmamışsa 
    uzunluk da başka bir sayfanın ortalarına kadar gidiyorsa baştaki ve sonraki her iki sayfa lock işlemine dahil edilmektedir.)
    POSIX standartlarında birinci parametresiyle belirtilen adresin ilgili sistem tarafından sayfa katlarında olmasının zorunlu 
    tutulabileceği (may require) belirtilmiştir. Linux sistemlerinde birinci parametrede belirtilen adresin sayfa katlarında olması 
    zorunluluğu yoktur. Uzunluk parametresi herhangi bir değerde olabilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir. errno uygun biçimde set edilmektedir.

    Bir adres sayfa katlarına şu şekildee align edilebilir:

    #include <stdint.h>

    void *addr = (void *)((uintptr_t)buf & ~0xFFF);

    mlock fonksiyonu ile kilitlenmeye çalışılan sayfalar o anda RAM'de değilse mlock önce onları RAM'e alıp kilitlemektedir. 
    Yani fonksiyon başarılı bir biçimde geri döndüğünde kesinlikle sayfalar o anda RAM'de bulunmaktadır.

    mlock ile kilitlenen sayfaların kilidini açmak için munlock POSIX fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    int munlock(const void *addr, size_t len);

    Fonksiyonun birinci parametresi unlock edilecek sayfalara ilişkin adresi, ikinci parametresi de uzunluğu belirtmektedir. 
    Yine bu adres + uzunluk değerini içeren tüm sayfalar unlock edilmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri döner ve errno uygun biçimde set edilir. Tabii en kötü olasılıkla proses sonlandığında sayfalar 
    zaten unlock edilip boşaltılmaktadır.

    mlock ve mulock fonksiyonlarında bir sayaç mekanizması yoktur. Yani bir alan birden fazla kez lock yapılsa bile tek bir 
    unlock işlemi ile unlock yapılabilmektedir.

    Aşağıdaki örnekte mlock fonksiyonu ile bir global dizinin bulunduğu sanal sayfa kilitlenmiştir. Tabii bu örnekte aslında 
    dizi 4096 byte olmasına karşın iki sayfa da kilitlenmiş olabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

char buf[4096];

int main(void)
{
    if (mlock(buf, 4096) == -1)
        exit_sys("mlock");

    printf("Ok\n");

    if (munlock(buf, 4096) == -1)
        exit_sys("munlock");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir prosesin bütün sayfalarını lock etmek için mlockall POSIX fonksiyonu kullanılabilmektedir:

    int mlockall(int flags);

    Buradaki flags parametresi aşağıdaki sembolik sabitlerin bit OR işlemine sokulmasıyla oluşturulur:

    MCL_CURRENT: Şu anda RAM'de olan tüm sayfaların kilitleneceği anlamına gelir.
    MCL_FUTURE: Bundan sonra RAM'e alınacak tüm sayfaların kilitleneceği anlamına gelir.

    munlockall fonksiyonu ise ters işlemi yapmaktadır:

    int munlockall(void);

    mlockall fonksiyonu yine prosesin RLIMIT_MEMLOCK kaynak limitinden etkilenmektedir. Bunun soft değeri mevcut çekirdeklerde 
    oldukça yükseltilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

char buf[1000000];

int main(void)
{
    if (mlockall(MCL_CURRENT|MCL_FUTURE) == -1)
        exit_sys("mlock");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Sayfa kilitleme işlemi Linux sistemlerinde mmap fonksiyonu ile mapping yapılırken mapping alanı için de MAP_LOCKED flags
    parametresi ile sağlanabilmektedir. (Bu bayrak POSIX standartlarında yoktur.) Yani biz bu sayede mapping yaptığımız alanları 
    aynı zamanda lock edebilmekteyiz. Tabii burada da prosesin RLIMIT_MEMLOCK kaynak limiti bir kısıt oluşturabilmektedir. 
    Ancak Linux sistemlerinde mmap fonksiyonundaki MAP_LOCKED bayrağı tüm map edilen sayfaları o anda RAM'e çekemeyebilmektedir. 
    Bu durumda fonksiyon başarısız olmamaktadır. Yani başka bir deyişle bu davranış mlock kadar kesin değildir. Aynı davranış 
    aslında Linux'a özgü biçimde klasik Sistem 5 paylaşılan bellek alanlarında da chmctl fonksiyonunda bazı küçük farklılıklarla 
    bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler 90'lı yıllarda işletim sistemlerine sokulmuştur. Microsoft'un thread'li ilk işletim sistemi Windows NT (1993) 
    ve sonra da Windows 95 (1995) sistemleridir. Benzer biçimde UNIX/Linux dünyasına da thread'ler ilk kez 90'lı yıllarla 
    sokulmuştur. Yani thread'ler daha önce denemeler yapılmış olsa da 90'lı yılların başlarında işletim sistemlerine sokulmuş 
    durumdadır. Bugün pek çok programlama dili ve framework kendi içerisinde thread'leri barındıran kütüphanelere sahiptir. 
    Hatta yeni dillerin bazıları artık thread'leri anahtar sözcüklerle dilin sentaksına dahil etmektedir. Örneğin C++ Programlama 
    Dili'ne 2011 versiyonuyla (C++11) bir thread kütüphanesi eklenmiştir. Benzer biçimde .NET ve C#'ın ilk sürümlerinde (2002) 
    bile framework bir thread kütüphanesine sahipti. Benzer biçimde Java Dilininde kütüphanesi içerisinde thread'lerle işlem 
    yapan sınıflar bulunuyordu. Microsoft'un MFC Framework'ü gibi, yaygın kullanılan Qt Framework'ü gibi pek çok framework 
    kendi içerisinde bir thread kütüphanesi barındırmaktadır. Tabii thread işlemleri bir dilin ya da bir framework'ün kontrolü 
    altında olan işlemler değildir. Doğrudan işletim sisteminin kontrolü altında olan işlemlerdir. Dolayısıyla programlama 
    dilleri ya da framework'ler işletim sistemlerinin sunduğu mekanizmayı kullanmaktadır. Tabii bu diller ve framework'ler 
    thread kullanımını "platform bağımsız" hale de getirmektedir. Yani örneğin Windows'un ve Linux'un sağladığı thread mekanizması 
    farklı olmasına karşın C++'ın standart thread kütüphanesi "platform bağımsız" bir kütüphanedir. Başka bir deyişle C++'ın 
    standart thread kütüphanesi Windows sistemlerinde "Windows API Fonksiyonları" kullanılarak UNIX/Linux sistemlerinde "POSIX 
    fonksiyonları" kullanılarak gerçekleştirilmiştir.

    C Programlama Dili'ne de 2011 sürümüyle (C11) birlikte "isteğe bağlı (optional)" mini bir thread kütüphanesi eklenmiştir. 
    Ancak bu mini thread kütüphanesi Microsoft C derleyicisi tarafından ve gcc derleyicileri tarafından desteklenmiyordu. Ancak 
    gcc derleyicilerinin son versiyonları bu thread kütüphanesini desteklemektedir.

    Biz kursumuzda (kursumuz bir sistem programlama kursu olduğu için) UNIX/Linux sistemlerindeki işletim sistemi çekirdeği 
    ile ilgili olan aşağı seviyeli thread mekanizması üzerinde duracağız. Yukarıda da belirttiğimiz gibi programlama dili 
    ya da framework ne olursa olsun UNIX/Linux sistemlerinde eninde sonunda işlemler burada anlatacak olduğumuz thread m
    ekanizması yoluyla yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde bir prosesin bağımsız olarak çizelgelenen akışlarına "thread" denilmektedir. Thread sözcüğü İngilizce 
    "iplik" anlamına gelmektedir. Akışlar ipliklere benzetilerek bu sözcük türetilmiştir. Proses kavramı çalışmakta olan programın 
    tüm bilgisini içermektedir. Oysa thread'ler yalnızca akış belirtmektedir. Bir proses tek bir akışa sahip olmak zorunda 
    değildir. Prosesler birden fazla akışa sahip olabilmektedir. İşte prosesin bu bağımsız akışlarına "thread" denilmektedir. 
    İşletim sistemlerinin "çizelgeleyici (scheduler)" alt sistemleri prosesleri değil thread'leri çizelgelemektedir. Yani 
    çizelgeleyici alt sistem bir thread'i çalıştırıp belli bir quanta süresi dolduğunda ona ara vermekte ve diğer bir thread'i 
    CPU'ya atamaktadır. Ara verilen thread ile akışın CPU'ya verildiği thread aynı prosesin thread'leri olabileceği gibi 
    farklı proseslerin thread'leri de olabilmektedir.

    Prosesler çalışmasına tek bir thread'le başlamaktadır. Yani fork işlemi ile aslında tek bir thread yaratılmaktadır. Bir 
    proses birden fazla thread'e sahipken fork işlemi yapılsa bile yeni yaratılan alt proses tek bir thread ile yaratılmaktadır. 
    O da fork işleminin yapıldığı thread'tir. Diğer thread'ler proses yaratıldıktan sonra programcı tarafından yaratılmaktadır. 
    exec işlemi yapıldığında yine prosesin tüm thread'leri yok edilir. exec yapılan program tek bir thread'le çalışmaya başlar. 
    Program çalışmaya başladığında var olan bu thread'e programın "ana thread'i (main thread)" denilmektedir. Örneğin biz 
    "sample" programını çalıştırdığımızda çalışma tek bir thread ile başlatılmaktadır. Bu "sample" programının ana thread'idir. 
    Thread'lerin olmadığı zamanlarda zaten proseslerin tek bir akışı vardı. Dolayısıyla o zamanlar yalnızca ana thread bulunmaktaydı.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi thread'lere neden gereksinim duyulmaktadır? Bunun birkaç bariz nedenini aşağıda maddeler halinde veriyoruz:

    1) Thread'ler arka plan işlemlerin yapılması için iyi bir araç oluşturmaktadır. Bir işi yaparken aynı zamanda arka planda
    periyodik bir işlem yapmak istediğimizi düşünelim. Bu durumda biz bloke olursak artık o periyodik işlemi yapamayız. Örneğin:

    for (;;) {
        ch = getchar();
        proc(ch);
        <saati bas>
    }

    Buradaki temsili kodda klavyeden bir karakter okunmuş ve o karakter işlenmiştir. Ancak arka planda ekrana bir saat de 
    basılmaktadır. Oysa getchar gibi bir işlemde bloke oluşacağı için ekrandaki saat duracaktır. İşte eskiden bu tür işlemler 
    oldukça zor biçimde ancak dolaylı olarak gerçekleştiriliyordu. Ancak thread'ler kullanılmaya başlandığında bu tür işlemleri 
    gerçekleştirmek çok kolaylaştı. Thread'ler bağımsız çizelgelendiği için bir thread bloke olduğunda prosesin diğer thread'leri 
    çalışmaya devam etmektedir. Örneğin:

    Ana thread:

    for (;;) {
        ch = getchar();
        proc(ch);
    }

    Diğer thread:

    for (;;) {
        <saati bas>
    }

    2) Thread'ler bir işi hızlandırmak için sıkça kullanılmaktadır. Bir işin tek bir akışa yaptırılmasıyla birden fazla 
    akışa yaptırılması arasında önemli bir hız farkı olabilmektedir. Örneğin bir satranç programında thread'lerden biri mümkün 
    hamleleri tespit ederken diğer bir thread bu hamleleri analiz ediyor olabilir. Tek bir CPU'nun bulunduğu durumda da thread'ler 
    prosesin toplam CPU zamanının artırılmasını sağlayabilmektedir. (Örneğin tek bir işlemci bulunuyor olsun. Bizim dışımızda 
    sistemde 10 thread çalışıyor olsun. Biz prosesimizde tek thread oluşturursak (default durum) 1 / 11 CPU zamanı elde ederiz. 
    İki thread oluştursak 2 / 12 CPU zamanı elde ederiz. Üç thread oluştursak 3 / 13 CPU zamanı elde ederiz. Bir kesrin pay 
    ve paydasına aynı sayı eklendiğinde kesrin büyüdüğüne dikkat ediniz.)

    3) Bir programın çeşitli parçalarının çok işlemcili ya da çok çekirdekli makinelerde eş zamanlı biçimde çalıştırılmasına
    "paralel programlama" denilmektedir. Paralel programlama yapabilmek için programcının thread'leri kullanması ve thread'leri 
    farklı işlemcilere ya da çekirdeklere ataması gerekmektedir.

    4) Thread'ler bazı durumlarda mutlak zorunlu olmasa da tasarımı kolaylaştırmak için ve sistemi ölçeklenebilir (scalable) 
    hale getirmek için kullanılabilmektedir.

    5) Thread'ler bazı durumlarda zorunlu olarak da kullanılabilmektedir. Örneğin GUI programlama modelinde bir mesajın 
    işlenmesi uzun süre aldığında bu durumda mecburen thread'ler kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Programın akışına ilişkin birkaç terim bazen birbirleriyle karıştırılmaktadır. (Yine de bilgisayar bilimlerindeki terimlerin 
    çoğu farklı konularda farklı anlamlarda kullanılabilmektedir.)

    Concurrent Computing: Bu terim genel bir şemsiye terimdir. Birden fazla akışın söz konusu olabildiği tüm durumlar için 
    kullanılabilmektedir.

    Multithreading (ya da Multithreaded) Programming: Bir işin birden fazla thread ile gerçekleştirilmesine yönelik uygulamalar 
    için bu terim kullanılmaktadır.

    Reentrancy: Bu terim de genellikle fonksiyon akışının içi içe geçebilmesini belirtmektedir. Örneğin bir fonksiyonun 
    "reentrant" olması demek fonksiyon çalışırken yeniden aynı fonksiyonun çalıştırılması demektir. Reentrancy "özyineleme 
    (recursion)" demek değildir. Özyinelemede tek bir akış vardır. Fakat örneğin iki thread'in aynı fonksiyona girmesi 
    durumunda bir "reentrancy" durumu oluşur. Ya da örneğin bir mikro denetleyici sistemde akış bir fonksiyon üzerinde 
    ilerlerken bir kesme oluştuğunda kesme kodu yeniden aynı fonksiyonu çağırırsa burada da bir "reentrancy" durumu söz
     konusu olur. UNIX/Linux sistemlerinde de hiç thread kullanmamış olsak da "sinyal (signal)" mekanizması bir "reentrancy" 
     durumu oluşturabilmektedir.

    Parallel Programming: Aynı makinede bir prosesin çeşitli thread'lerinin farklı CPU ya da çekirdeklerde eş zamanlı 
    çalıştırılma gayretine paralel programlama denilmektedir.

    Distributed Computing: Bir işin farklı bilgisayarlarda eş zamanlı bir biçimde ele alınmasına ilişkin bir terimdir. Paralel 
    programlamaya benzemektedir. Ancak paralel programlama "aynı makinede" yürütülen bir faaliyetken "distributed computing" 
    işlerin farklı makinelerde koordineli bir biçimde gerçekleştirilmesi anlamına gelmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                50. Ders 06/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread işlemleri işletim sistemlerinde aslında birtakım sistem fonksiyonlarıyla gerçekleştirilmektedir. Örneğin Linux 
    sistemlerinde thread yaratan sys_clone isimli bir sistem fonksiyonu bulunmaktadır. Ancak daha önce de ifade ettiğimiz 
    gibi sistem fonksiyonları taşınabilir değildir ve sistem fonksiyonları genellikle düşük seviyeli fonksiyonlardır. Yani 
    bunların kullanılmaları zordur. Thread'ler UNIX/Linux sistemlerine ilk sokulduğunda farklı thread kütüphaneleri oluşturulmuştu. 
    Programcılar bu kütüphanelerden birini kullanıyorlardı. Ancak 90'lı yılların ortalarında thread kütüphanesi "Realtime 
    Extensions" başlığı altında POSIX standartlarına eklenmiştir. POSIX tarafından desteklenen bu thread kütüphanesine "POSIX 
    Thread Kütüphanesi" ya da kısaca "pthread" kütüphanesi denilmektedir. POSIX thread kütüphanesinin içerisindeki bütün 
    fonksiyonların isimleri pthread_xxx biçiminde "pthread_" öneki ile başlatılmış durumdadır. POSIX thread kütüphanesi 
    "libpthread.so" ve "libpthread.a" isimli kütüphaneler biçiminde oluşturulmuştur. Bu kütüphaneleri kullanırken derleme 
    sırasında "-lpthread" seçeneğinin bulundurulması gerekmektedir. Bu seçenek link aşamasında POSIX thread kütüphanesinin 
    linker tarafından işleme sokulacağını belirtmektedir. Diğer programlama dillerindeki thread kütüphaneleri de UNIX/Linux 
    sistemlerinde pthread kütüphanesi kullanılarak gerçekleştirilmiştir. Yani bu anlamda pthread kütüphanesi "taban (base)" 
    bir kütüphanedir. (Örneğin C++11 ile birlikte C++'a bir thread kütüphanesi eklenmiştir. Bu kütüphanenin UNIX/Linux 
    sistemlerindeki gerçekleştirimi pthread kütüphanesi kullanılarak yapılmıştır. Tabii C++'ın thread kütüphanesi C++'ın 
    standart kütüphanesinin bir parçasıdır. Dolayısıyla "cross platform" özelliği vardır. Yani örneğin aynı kütüphane Windows 
    sistemlerinde Windows API fonksiyonları kullanılarak gerçekleştirilmiş durumdadır.) Benzer biçimde C11 ile birlikte C'ye 
    de isteğe bağlı (optional) minimalist bir thread kütüphanesi eklenmiştir. Mevcut C derleyicileri artık yavaş yavaş bu 
    thread kütüphanesini de desteklemeye başlamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler aynı prosesin bağımsız çizelgelenen farklı akışlarıdır. Bir işi iki thread'e yaptırmakla iki prosese yaptırmak 
    arasında şu önemli farklılıklar vardır:

    - Prosesin thread'leri aynı bellek alanını kullanmaktadır. Yani örneğin bir thread bir global değişkene bir şey yazsa 
    diğer thread bunu görmektedir. Oysa proseslerin bellek alanları tamamen izole edilmiştir. Prosesler arasındaki haberleşme 
    maliyeti yüksektir ve prosesler arası haberleşme kodu daha karmaşık hale getirmektedir. Halbuki thread'ler global değişkenler 
    yoluyla ya da heap yoluyla çok daha az maliyetle haberleşebilmektedir.

    - Thread'lerin yaratılması ve yok edilmesi proseslere göre daha hızlıdır. Çünkü bir proses yaratılırken arka planda prosese 
    özgü pek çok yaratım işlemleri de yapılmaktadır.

    - Thread'ler proseslere göre daha az sistem kaynağı harcama eğilimindedir. Yani bir prosesin yaratılması sırasında harcanan 
    sistem kaynağı bir thread'in yaratılması sırasında harcanan sistem kaynağından daha yüksektir.

    Proses kavramı çalışmakta olan programın tüm bilgilerini belirtmektedir. Thread ise yalnızca bir akış belirtmektedir. Örneğin:

    - Thread'lerin gerçek ve etkin kullanıcı id'leri ve grup id'leri yoktur. Proseslerin vardır. Yani bir prosesin tüm thread'leri 
    aynı kullanıcı ve grup id'sine sahiptir.

    - Thread'lerin çalışma dizinleri, çevre değişkenleri yoktur. Proseslerin vardır. Örneğin biz bir proseste chdir POSIX 
    fonksiyonu ile çalışma dizinini (current working directory) değiştirdiğimizde tüm thread'ler bunu değiştirmiş oluruz.

    - Dosya betimleyici tablosu prosese özgüdür. Dolayısıyla tüm thread'ler aynı dosya betimleyici tablosunu kullanmaktadır.

    - Prosesin thread'lerinin proses id'leri aynıdır.

    Ancak UNIX/Linux dünyasında thread'ler arasında bir altlık-üstlük (parent-child) ilişkisi yoktur. Yani bir thread'in hangi 
    thread tarafından yaratıldığının (istisna bazı durumlar dışında) bir önemi yoktur. Dolayısıyla UNIX/Linux dünyasında 
    "üst thread (parent thread)" ve "alt thread (child thread)" biçiminde kavramlar yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Proses çalışmaya tek bir thread ile başlamaktadır. Diğer thread'ler programcı tarafından yaratılmaktadır. Bir thread 
    yaratılırken thread akışının başlatılacağı bir fonksiyon da belirtilmektedir. Nasıl programın ana thread'i yani akışı main 
    fonksiyonundan başlıyorsa bizim yarattığımız thread'in akışı da bizim belirttiğimiz bir fonksiyondan başlatılmaktadır. 
    Örneğin biz bir thread yaratmış olalım ve thread'imizin akışı da foo fonksiyonundan başlatılmış olsun:

    int main(void)
    {
        ...
    }
    ...
    void *foo(void *param)
    {
        ...
    }
    ...

    Burada bir akış main fonksiyonundan ilerlerken diğer akış bağımsız olarak foo fonksiyonundan itibaren ilerleyecektir. 
    Bu iki akış aynı programın içerisindedir. Dolayısıyla bu akışlardan biri bir global değişkeni değiştirse diğeri de onu 
    değişmiş görecektir. Şimdi bu durumu aşağıdaki durum ile kıyaslayınız:

    int main(void)
    {
        ...
        if ((pid = fork()) == -1)
            exit_sys("fork");
        if (pid == 0)
            foo();
        ...
    }

    void foo(void)
    {
        ...
    }

    Biz burada benzer işlemi fork ile yapmaya çalıştık. Ancak fork yaptığımızda biz maliyetli bir biçimde yeni bir proses yarattık. 
    Bu prosesin bilgileri üst prosesten alınmaktadır. Ayrıca yarattığımız alt proses ayrı bir bellek alanına sahiptir. Dolayısıyla
    örneğin aynı global değişkenleri kendi aralarında paylaşmamaktadır. Örneğin biz alt proseste dosya açsak üst proses bunu 
    görmeyecektir. Halbuki thread'ler aynı prosesin akışlarıdır. Prosesin bir thread'i bir dosya açsa diğer thread'i onu açık 
    olarak görmektedir. Proseslerle thread'ler akış bakımından benzemektedir. Her iki durumda da farklı akış oluşturulmaktadır. 
    Thread'lere ilk zamanlar bu benzerlikten hareketle "lightweight (hafif siklet) proses" de denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Her ne kadar prosesin thread'leri aynı bellek alanını kullanıyorsa da "stack" konusunda bu durum geçerli değildir. Thread'lerin 
    stack'leri birbirinden ayrılmıştır. Başka bir deyişle bir thread yaratıldığında o thread için ayrı bir stack yaratılmaktadır. 
    Yerel değişkenlerin ve parametre değişkenlerinin stack'te yaratıldığını anımsayınız. Thread'lerin stack'leri birbirinden 
    ayrıldığı için farklı thread akışları aynı fonksiyon üzerinde ilerlese bile aynı yerel değişkenleri görmemektedir. Yerel 
    değişkenlerin her thread için ayrı bir kopyası oluşturulmaktadır. Örneğin:

    int g_x;

    void *thread_proc1(void *param)
    {
        ...
        foo();
        ...
    }

    void *thread_proc2(void *param)
    {
        ...
        foo();
        ...
    }

    void foo(void)
    {
        int a = 10;
        static int b = 10;
        ...
        ++a;
        ...
        ++a;
        ...
        ++b;
        ...
        ++g_x;
        ...
    }

    Burada iki thread foo üzerinde ilerlerken aslında yerel değişken olan a'nın kendi kopyaları üzerinde işlem yapmaktadır. 
    Yani bir thread buradaki yerel "a" değişkenini değiştirdiğinde diğer thread bu değişikliği görmez. Başka bir deyişle her 
    thread'in kendine özgü farklı bir "a" değişkeni vardır. Bu durumun teknik açıklaması şöyledir: Yerel değişkenler stack'te 
    yaratılmaktadır. Thread'lerin de stack'leri birbirinden ayrıldığı için bu "a" değişkeni hangi thread akışı o fonksiyonu 
    çağırmışsa onun stack'inde yaratılmaktadır.

    Ancak prosesin bütün thread'leri aynı ".data" ve ".bss" ve "heap" alanını kullanmaktadır. Bu nedenle thread'lerden biri 
    yukarıdaki örnekte "++g_x" global değişkenini artırdığında diğeri onu artırılmış olarak görecektir. Anımsanacağı gibi 
    fonksiyonların static yerel değişkenleri stack'te yaratılmamaktadır. Static yerel değişkenlere eğer ilk değer verilmişse 
    bunlar ".data" alanında, ilk değer verilmemişse ".bss" alanında yaratılmaktadır. Dolayısıyla örneğin bir thread static 
    yerel yerel değişkeni değiştirirse diğer thread onu değişmiş olarak görmektedir.

    İşletim sistemlerinde yaratılan bir thread'in default stack büyüklüğü sistemden sisteme değişebilmektedir. Örneğin Linux 
    sistemlerinde thread'ler default olarak 8 MB stack ile yaratılmaktadır. Ancak thread'ler yaratılırken programcı isterse 
    stack büyüklüğünü kendisi de belirleyebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'lerin errno değişkenleri birbirinden farklıdır. Yani her thread'in ayrı bir errno değişkeni vardır. Örneğin biz 
    bir thread'te bir POSIX fonksiyonu çağırsak o POSIX fonksiyonu başarısız olsa o thread'in errno değişkeni set edilir. 
    Diğer thread'lerin errno değişkenleri bundan etkilenmez. perror fonksiyonu da kendi thread'inin errno değişkenini kullanmaktadır. 
    Yani biz perror fonksiyonu ile hata mesajını stderr dosyasına yazdırmak istersek perror o thread'in errno değişkeninin 
    değerine başvurarak yazıyı oluşturacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX thread kütüphanesini incelemeden önce kütüphanedeki bazı ortak özelliklerin üzerinde durmak istiyoruz:

    - Yukarıda da belirttiğimiz gibi kütüphanedeki bütün fonksiyonların isimleri "pthread_" öneki ile başlatılmıştır.

    - Kütüphanedeki fonksiyonların büyük bölümünün geri dönüş değeri int türdendir. Bu fonksiyonlar başarı durumunda 0 değerine,
    başarısızlık durumunda bizzat errno değerinin kendisine geri dönmektedir. Bu fonksiyonlar errno değişkenini set etmemektedir. 
    Başarısızlık durumunda errno değerinin kendisine geri dönmektedir. Bu durumda başarı kontrolünün yapılması ve hata mesajlarının 
    yazdırılması şöyle yapılabilir:

    int result;
    ...
    if ((result = pthread_xxx(...)) != 0) {
        fprintf(stderr, "pthread_xxx: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    Görüldüğü gibi burada perror fonksiyonu kullanılmamıştır. Çünkü perror fonksiyonu errno değerinin yazısını yazdırmaktadır. Halbuki
    pthread fonksiyonları errno değerini set etmemekte, bizzat errno değerinin kendisiyle geri dönmektedir. strerror fonksiyonunun 
    bir errno numarası için hata yazısını verdiğini anımsayınız. Tabii biz yine bir sarma fonksiyon kullanabiliriz:

    void exit_sys_errno(const char *msg, int eno)
    {
        fprintf(stderr, "%s: %s\n", msg, strerror(eno));

        exit(EXIT_FAILURE);
    }

    Bu durumda biz thread fonksiyonlarını bu sarma fonksiyon yoluyla şöyle çağırabiliriz:

    int result;
    ...
    if ((result = pthread_xxx(...)) != 0)
        exit_sys_errno("pthread_xxx", result);

    errno ismi bazı sistemlerde bir değişken değil makro olduğu için errno isminde bir değişken tanımlamayınız.

    - Bütün POSIX thread fonksiyonlarının prototipleri <pthread.h> dosyası içerisindedir. Dolayısıyla thread işlemleri yapacaksak 
    bizim bu dosyayı include etmemiz gerekmektedir:

    #include <pthread.h>

    - Thread kullanan programları derlerken link aşaması için "-lpthread" komut satırı argümanını kullanmayı unutmayınız. Örneğin:

    $ gcc -o sample sample.c -lpthread

    gcc ve clang derleyicilerinin ileri versiyonlarında başlık dosyalarındaki pragma direktifleri ile belli bir başlık dosyası 
    include edildiğinde ilgili kütüphanenin link aşamasına otomatik biçimde sokulması sağlanabilmektedir. Ancak siz her zaman
    thread'li programları derlerken "-lpthread" seçeneği ile bağlayıcının bu kütüphaneye bakmasını sağlamalısınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler pthread_create isimli POSIX fonksiyonu ile yaratılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);

    Fonksiyonun birinci parametresi thread'in id değerinin yerleştirileceği nesnenin adresini almaktadır. Nasıl proseslerin 
    id değerleri varsa thread'lerin de id değerleri vardır. Proseslerin id değerleri o anda sistem genelinde tektir (unique). 
    Ancak thread'lerin id değerleri sistem genelinde tek olmak zorunda değildir. Fakat proses içerisinde tektir. Yani farklı 
    proseslerin yarattığı thread'lerin id değerleri aynı olabilir, ancak aynı prosesin thread'lerinin id değerleri farklı olmak 
    zorundadır. (Linux sistemlerinde thread'lerin id değerleri onlar için ayrılan task_struct yapısına ilişkin bir değer olduğu 
    için sistem genelinde tektir. Ancak POSIX standartlarında bunun bir garantisi yoktur.)

    pthread_t türü <thread.h> ve <sys/types.h> dosyaları içerisinde typedef edilmiştir. POSIX standartlarına göre pthread_t türü 
    "aritmetik bir tür (yani tamsayı türü ya da gerçek sayı türü)" olmak zorunda değildir. Yani bir yapı türünden de olabilir. 
    Dolayısıyla pthread_t türünden iki nesneyi kendi aralarında karşılaştırmaya çalışmayınız. Linux'ta pthread_t türü 
    "unsigned long int" olarak typedef edilmiştir.

    Fonksiyonun ikinci parametresi yaratılacak thread'in bazı özelliklerini belirten pthread_attr_t türünden bir nesnenin adresini 
    almaktadır. Thread özellikleri konusu ileride ele alınacaktır. Ancak bu parametre NULL adres geçilirse bu durumda thread default
    özelliklerle yaratılmaktadır. Fonksiyonun üçüncü parametresi thread akışının başlatılacağı fonksiyonun adresini belirtmektedir. 
    Thread fonksiyonlarının geri dönüş değerleri ve parametresi void * olmak zorundadır. Fonksiyonun son parametresi thread 
    fonksiyonuna geçirilecek parametreyi belirtmektedir. Böylece aynı thread fonksiyonu farklı bilgilerle başlatılabilmektedir. 
    Thread'e geçirilecek parametrenin void * türünden olduğuna dikkat ediniz. Çünkü adres bilgisi en genel parametrik bilgi 
    durumundadır. Tabii programcı bu parametreye bir adres geçirmeyip bir değer de geçirmek isteyebilir. Bu durumda değeri void * 
    türüne dönüştürmelidir. Fonksiyonun üçüncü parametresiyle belirtilen thread fonksiyonunun geri dönüş değerinin de void * 
    türünden olduğuna dikkat ediniz. Thread'ler de sonlandığında tıpkı prosesler gibi bir exit kodu oluşturmaktadır. Ancak bu exit 
    kodu int türden değil void * türündendir. Bu exit kodunun nasıl elde edileceği izleyen paragraflarda ele alınmaktadır.

    pthread_create fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Bir thread yaratıldığında hemen çalışmaya başlamaktadır. (Örneğin bazı thread kütüphanelerinde önce thread yaratılmakta, sonra 
    "start" gibi bir fonksiyonla thread çalıştırılmaktadır. Halbuki POSIX kütüphanesinde thread'ler zaten yaratıldığında çalıştırılırlar.)
    Tabii pthread_create fonksiyonu ile thread yaratıldığında yaratan thread'in mi yoksa yeni yaratılan thread'in mi ilk olarak 
    CPU'ya atanacağı işletim sisteminin çizelgeleme algoritmasına bağlı olarak değişebilmektedir. POSIX bu konuda herhangi bir 
    garanti vermemektedir.

    Aşağıda thread yaratımına bir örnek verilmiştir. Bir thread'te sleep fonksiyonu kullanıldığında sleep fonksiyonu kendisini 
    çağıran thread'i belirtilen saniye kadar bloke etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread fonksiyonuna parametre geçebiliriz. Bunun için genellikle programcılar heap'te tahsisat yaparlar. Tahsis edilen 
    bu alanlar thread fonksiyonunun sonunda free hale getirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

#define NTHREADS        10

int main(void)
{
    pthread_t tid[NTHREADS];
    int result;
    char *buf;

    for (int i = 0; i < NTHREADS; ++i) {
        if ((buf = (char *)malloc(1024)) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }
        snprintf(buf, 1024, "Thread-%d", i);

        if ((result = pthread_create(&tid[i], NULL, thread_proc, buf)) != 0)
            exit_sys_errno("pthread_create", result);
    }

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    char *str = (char *)param;

    for (int i = 0; i < 10; ++i) {
        printf("%s: %d\n", str, i);
        sleep(1);
    }

    free(str);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread fonksiyonuna getirilecek parametre birden fazla ise tipik olarak programcı bu parametreleri bir yapı biçiminde 
    oluşturur. İlgili yapı türünden bir dinamik bir nesne tahsis eder ve o nesnenin adresini thread fonksiyonuna geçirir. 
    Bu dinamik alan thread fonksiyonu tarafından free hale getirilebilir. Aşağıda buna ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

struct PARAM_INFO {
    char *name;
    int count;
};

int main(void)
{
    pthread_t tid;
    int result;
    struct PARAM_INFO *pi;

    if ((pi = (struct PARAM_INFO *)malloc(sizeof(struct PARAM_INFO))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    pi->name = "other thread";
    pi->count = 10;

    if ((result = pthread_create(&tid, NULL, thread_proc, pi)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    struct PARAM_INFO *pi = (struct PARAM_INFO *)param;

    for (int i = 0; i < pi->count; ++i) {
        printf("%s: %d\n", pi->name, i);
        sleep(1);
    }

    free(param);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread çeşitli biçimlerde sonlanabilmektedir:

    1) Thread fonksiyonu bittiğinde thread'ler otomatik olarak sonlanırlar. Bu en çok karşılaşılan doğal sonlanma biçimidir.

    2) Thread'ler pthread_exit fonksiyonuyla thread fonksiyonunun sonuna gelinmeden de sonlandırılabilmektedir. pthread_exit 
    fonksiyonu "kendi thread'ini" sonlandırmaktadır. Başka bir thread'i sonlandırmamaktadır. Yani hangi thread akışı pthread_exit 
    fonksiyonunu görürse o thread sonlandırılmaktadır. pthread_exit fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    void pthread_exit(void *value_ptr);

    Nasıl exit fonksiyonu prosesi sonlandırırken bir exit kodunu alıyorsa pthread_exit fonksiyonu da thread'i sonlandırırken 
    void * türünden bir exit kodu almaktadır. (main fonksiyonunun geri dönüş değeri int türdendir. exit fonksiyonunun parametresi 
    de int türdendir. İşte thread fonksiyonunun geri dönüş değeri void * türünden olduğu için pthread_exit fonksiyonunun parametresi 
    de void * türündendir.)

    3) Bir programda exit standart C fonksiyonu ya da _exit POSIX fonksiyonu çağrılırsa proses sonlandırılır. Thread kavramı 
    proses kavramının içerisindedir. Dolayısıyla proses sonlandığında prosesin tüm thread'leri de otomatik olarak sonlandırılmaktadır. 
    Tabii exit ya da _exit fonksiyonu herhangi bir thread tarafından da çağrılabilir. Burada önemli bir nokta main fonksiyonu 
    bittiğinde exit işleminin yapılmasıdır. Dolayısıyla main fonksiyonu biterse proses sonlanır; proses sonlanırsa da tüm thread'ler 
    sonlanacaktır. Örneğin aşağıdaki gibi hataları POSIX thread kütüphanesini yeni kullananlar sıkça yapmaktadır:

    int main(void)
    {
        pthread_t tid;
        int result;

        if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
            exit_sys_errno("pthread_create", result);

        /* Dikkat! main bittiğinde proses sonlanacak ve bütün thread'ler de yok edilecektir */

        return 0;
    }

    Burada thread yaratılmıştır ancak proses sonlandığı için yaratılan thread de hemen sonlanacaktır.

    Aslında prosesin ana thread'inin diğer thread'lerden bir farkı yoktur. Yani prosesin ana thread'i diğer thread'lerden önce 
    sonlanabilir. Pekiyi o zaman proses nasıl sonlanacaktır? Çünkü akış main fonksiyonunu bitirmeyecektir. Dolayısıyla akış 
    exit fonksiyonunu görmeyecektir. İşte bir prosesin son thread'i sonlandığında programın akışı exit ya da _exit fonksiyonunu 
    görmese bile proses işletim sistemi tarafından sonlandırılmaktadır.

    4) Prosesler sinyal yoluyla sonlandırılabilmektedir. Bu durumda prosese bir sinyal gönderilirse ve proses de bu sinyali 
    ele almamışsa (handle etmemişse) bazı sinyaller prosesin sonlanmasına yol açabilmektedir. Dolayısıyla bu tür durumlarda 
    da prosesin tüm thread'leri sinyal yüzünden sonlandırılacaktır.

    5) Bir thread başka bir thread'i pthread_cancel fonksiyonu ile sonlandırabilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    Fonksiyon parametre olarak sonlandırılacak thread'in id değerini alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri döner. pthread_cancel fonksiyonu geri döndüğünde thread'in sonlanmış olması gerekmemektedir. Yani 
    sonlanma işlemi asenkron biçimde yapılmaktadır. pthread_cancel fonksiyonu ile thread'leri sonlandırmanın bazı ayrıntıları 
    vardır. Bu ayrıntılar izleyen paragraflarda ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir thread yaratılmış ve thread erken bir biçimde pthread_exit fonksiyonu ile sonlandırılmıştır. 
    pthread_exit fonksiyonu hangi thread akışı tarafından çağrılırsa o thread sonlanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void foo(void);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    foo();

    return NULL;
}

void foo(void)
{
    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            pthread_exit(NULL);
        printf("other thread: %d\n", i);
        sleep(1);
    }
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte proses exit fonksiyonuyla sonlandırılmıştır. Dolayısıyla prosesin tüm thread'leri de exit işlemiyle 
    sonlandırılmış olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            exit(EXIT_SUCCESS);
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte main fonksiyonunda thread yaratılmış ancak hemen main fonksiyonu sonlanmıştır. main fonksiyonu sonlandığında 
    exit fonksiyonu çağrılarak proses sonlandırılacağı için yaratılmış olan thread'ler de sonlandırılmış olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    /* Dikkat! main bittiğinde proses sonlanacak ve dolayısıyla prosesin tüm thread'leri de sonlandırılacaktır. */

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte programın ana thread'i sonlandırılmıştır. Bu durumda prosesin son thread'i sonlandığında hiç exit ya da
    _exit fonksiyonu çağrılmasa bile proses otomatik olarak sonlandırılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            pthread_exit(NULL);
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                51. Ders 07/05/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde (aslında Windows sistemlerinde de böyle) thread'ler arasında altlık-üstlük (parent-child)" ilişkisi 
    yoktur. Örneğin bir thread'in hangi thread tarafından yaratıldığının bir önemi yoktur. Bir thread'in ana thread tarafından 
    yaratılması zorunlu değildir. Bir thread herhangi bir thread akışı tarafından yaratılabilir. Benzer biçimde örneğin thread'lerin 
    exit kodları herhangi bir thread tarafından elde edilebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread'in exit kodu pthread_join fonksiyonu ile elde edilmektedir. pthread_join fonksiyonunun davranışı alt prosesin 
    exit kodunu elde eden wait fonksiyonlarına benzemektedir. Ancak pthread_join fonksiyonu herhangi bir thread akışı tarafından 
    çağrılabilmektedir. pthread_join fonksiyonu exit kodu alınacak thread henüz sonlanmamışsa onun sonlanmasını bekler. Eğer 
    söz konusu thread sonlanmışsa herhangi bir bloke oluşmaz. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_join(pthread_t thread, void **value_ptr);

    Fonksiyonun birinci parametresi exit kodu alınacak thread'in id değerini, ikinci parametresi exit kodunun yerleştirileceği 
    void * türünden göstericinin adresini almaktadır. Bu parametreye NULL adres geçilebilir. Bu durumda thread'in exit kodu 
    programcıya verilmez. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Aşağıdaki örnekte bir thread yaratılmış thread bir exit kodla geri döndürülmüştür. Sonra da bu thread'in sonlanması 
    beklenmiş ve exit kod alınmıştır. Thread'lerin exit kodları birer adres biçiminde olsa da biz aşağıdaki örnekte olduğu gibi
    tamsayı değerleri sanki birer adresmiş gibi exit kod olarak oluşturabiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    void *valptr;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, &valptr)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", (int)valptr);

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return (void *)100;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread'i yaratıp onu pthread_join fonksiyonu ile beklemezsek "zombie proses" benzeri bir durum oluşur mu? 
    Gerçekten de tıpkı zombie proseslerde olduğu gibi işletim sistemleri sonlanan thread'e ilişkin bazı kaynakları "onların 
    exit kodları her an programcı tarafından alınabilir" diye bekletmektedir. Bu durum da zombie proses gibi olumsuzluklara 
    yol açabilmektedir. Gerçi zombie thread'ler zombie prosesler kadar sorunlara yol açmıyorsa da programcıların yarattıkları 
    thread'i pthread_join fonksiyonu ile beklemesi gerekir. Ancak bazen programcılar çok sayıda thread yaratıp bunları bekleyecekleri 
    noktaları oluşturamayabilirler. Bu durumda thread'lerin "detached" modda yaratılmaları ya da yaratıldıktan sonra "detached" 
    moda sokulmaları gerekir. "Detached" thread'ler sonlandığında kaynaklarını otomatik boşaltan dolayısıyla join yapılamayan 
    thread'lerdir. Thread'lerin nasıl detached moda sokulacağı izleyen paragraflarda ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinde (diğer sistemlerde böyle olmak zorunda değil) thread'ler için yine bir task_struct nesnesi tahsis 
    edilmektedir. Yani Linux çekirdeği prosesin thread'lerini adeta sanki aynı bellek alanını kullanan prosesler gibi oluşturmaktadır. 
    Tabii prosesin kendisi için de prosesin thread'leri için de aynı task_struct veri yapısının oluşturulması biraz verimsiz 
    bir bellek kullanımına yol açmaktadır. Çünkü aslında thread'ler bu task_struct yapısının önemli bir kısmını zaten kullanmamaktadır. 
    Ancak bu biçimdeki yaklaşım çekirdeğin kodlanmasını oldukça kolaylaştırmıştır. Bir task_struct yapısında onun bir thread'e 
    ilişkin mi yoksa prosese ilişkin mi olduğu bilgisi tutulmaktadır. Benzer biçimde prosese ilişkin task_struct yapısının 
    içerisinde o prosesin thread'lerine ilişkin task_struct nesneleri de bir biçimde tutulmaktadır. Zaten Linux çekirdeğinde 
    aslında proses yaratmak için de thread yaratmak için de sys_clone isimli aynı sistem fonksiyonu kullanılabilmektedir. 
    Proses yaratmakta kullanılan sys_fork isimli sistem fonksiyonu ve sys_clone sistem fonksiyonu aslında çekirdek içerisindeki 
    do_fork isimli ortak bir fonksiyonu çağırmaktadır. Başka bir deyişle Linux çekirdeğinde aslında sys_fork sistem fonksiyonu 
    sys_clone sistem fonksiyonunun özel bir biçimidir.

    Özetle Linux çekirdeği aslında thread'leri "aynı bellek alanını kullanan prosesler" gibi organize etmektedir. Zaten Linux'ta 
    thread'ler için kullanılan "lightweight process" terimi bu tasarımdan dolayı uydurulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi bir thread prosesin herhangi bir thread'i tarafından sonlandırılmak istenebilir. Buna POSIX 
    terminolojisinde "thread'in cancel edilmesi" denilmektedir. Bu işlem yukarıda da açıkladığımız üzere pthread_cancel POSIX 
    fonksiyonuyla yapılmaktadır.

    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    Tabii biz başka bir prosesin thread'ini pthread_cancel ile sonlandıramayız. Çünkü UNIX/Linux sistemlerinde thread'lerin 
    id değerleri proses özgüdür. Yani o proses için anlamlıdır. Bir thread, pthread_cancel fonksiyonu ile sonlandırıldığında 
    pthread_join fonksiyonundan thread'in exit kodu olarak PTHREAD_CANCELED özel değeri elde edilmektedir. Bu değer pek çok 
    sistemde aşağıdaki gibi define edilmiştir:

    #define PTHREAD_CANCELED    ((void *)-1)

    Aşağıdaki örnekte ana thread pthread_cancel fonksiyonu ile diğer thread'i sonlandırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread'in başka bir thread tarafından pthread_cancel POSIX fonksiyonu ile sonlandırılmasının bazı detayları vardır. 
    Örneğin aslında default durumda sonlandırma ani bir biçimde yapılmamaktadır. Sonlandırma isteği thread'e gönderilmekte 
    thread bazı POSIX fonksiyonlarının içerisine girerse sonlandırma o POSIX fonksiyonlarının içerisinde yapılmaktadır. Bu POSIX
    fonksiyonlarına "cancellation points" denilmektedir. Cancellation point belirten POSIX fonksiyonları standartlarda aşağıdaki 
    bağlantıda listelenmiştir:

    https://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09_05_02

    Burada bizim gördüğümüz pek çok fonksiyonun zaten bir cancellation point belirttiğine dikkat ediniz. Örneğin open, read, write, 
    close, sleep birer cancellation point belirtmektedir.

    Bir thread yukarıda belirtilen POSIX fonksiyonlarına girmezse pthread_cancel ile sonlandırma isteği thread'e gönderilse bile
    bu istek "askıda (pending durumda)" kalmaktadır. Dolayısıyla thread sonlandırılamayacaktır. Örneğin aşağıdaki gibi bir thread 
    pthread_cancel ile sonlandırılamaz:

    void *thread_proc(void *param)
    {
        for (;;) {
            /* bir cancellation point yok */
        }

        return NULL;
    }

    Aşağıdaki örnekte pthread_cancel kullanıldığı halde thread bir cancellation point içerisine girmediği için sonlanmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    for (;;) {
        /* bir cancellation point yok */
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread bu "cancellation" point fonksiyonlarına ihtiyaç duymadan bir döngü içerisinde işlemini yapıyorsa onu nasıl 
    cancel edebiliriz? İşte bunun için yalnızca bu işlevi yerine getirecek pthread_testcancel isimli bir fonksiyon bulundurulmuştur:

    void pthread_testcancel(void);

    Fonksiyonun parametresi yoktur. Fonksiyon bir şey yapmamakta yalnızca cancellation point oluşturmaktadır.

    Aşağıda pthread_testcancel fonksiyonuna ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    for (;;) {
        pthread_testcancel();
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında bir thread'in pthread_cancel fonksiyonu karşısındaki davranışı değiştirilebilmektedir. Bunun için iki POSIX fonksiyonu 
    kullanılmaktadır.

    pthread_setcanceltype isimli fonksiyon thread'in sonlandırma biçimini belirtir. Fonksiyonun prototipi şöyledir:

    #include <thread.h>

    int pthread_setcanceltype(int type, int *oldtype);

    Fonksiyonun birinci parametresi sonlandırma biçimini belirten aşağıdaki iki değerden biri olabilir:

    PTHREAD_CANCEL_DEFERRED
    PTHREAD_CANCEL_ASYNCHRONOUS

    Burada PTHREAD_CANCEL_DEFERRED yukarıda açıkladığımız "cancellation point fonksiyonlarına girildiğinde sonlandırma" 
    anlamına gelmektedir. Thread yaratıldığında thread'in default sonlandırma biçimi böyledir. PTHREAD_CANCEL_ASYNCHRONOUS değeri 
    ise thread'in o anda cancellation point olmadan doğrudan sonlandırılacağı anlamına gelmektedir.

    Fonksiyonun ikinci parametresi önceki sonlandırma biçiminin yerleştirileceği int nesnenin adresini almaktadır. Linux sistemlerinde 
    bu parametre NULL adres geçilebilmektedir. Ancak POSIX standartlarında böyle bir durum belirtilmemiştir. Fonksiyon başarı durumunda 
    0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Fonksiyonda bir thread id belirtilmediğine dikkat ediniz. Yani biz başka bir thread'in sonlanma biçimini değiştiremeyiz. 
    Bu fonksiyonu hangi thread akışı çağırırsa o thread'in sonlanma biçimi değiştirilmektedir.

    Aşağıdaki örnekte thread'in sonlandırma biçimi PTHREAD_CANCEL_ASYNCHRONOUS biçiminde değiştirilmiştir. Dolayısıyla artık 
    thread'e pthread_cancel uygulandığında thread cancellation point'e girmeden o anda ani bir biçimde sonlandırılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    int oldtype;

    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);

    for (;;) {

    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'in pthread_cancel fonksiyonu bağlamındaki sonlandırma durumunun değiştirilmesi için ise pthread_setcancelstate 
    fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_setcancelstate(int state, int *oldstate);

    Fonksiyonun birinci parametresi aşağıdaki iki değerden biri olabilir:

    PTHREAD_CANCEL_ENABLE
    PTHREAD_CANCEL_DISABLE

    PTHREAD_CANCEL_ENABLE değeri thread'in pthread_cancel fonksiyonu ile sonlandırılabileceğini belirtmektedir. PTHREAD_CANCEL_DISABLE
    değeri ise thread'in pthread_cancel fonksiyonu ile sonlandırılamayacağını belirtmektedir. Thread'ler yaratıldığında default olarak 
    sonlandırılabilir yani PTHREAD_CANCEL_ENABLE durumdadır. Thread eğer PTHREAD_CANCEL_DISABLE duruma sokulursa bu durumda pthread_cancel 
    uygulandığında thread sonlandırılmaz. Ancak istek "askıda (pending)" durumda kalır. Thread'in durumu eğer PTHREAD_CANCEL_ENABLE
    hale getirilirse askıda olan sonlandırma eylemi sonlandırma biçiminine göre işleme alınır. Fonksiyonun ikinci parametresi 
    eski sonlandırma durumunun yerleştirileceği int nesnenin adresini almaktadır. Linux'ta bu değer NULL geçilebilirse de POSIX
    standartlarında böyle bir davranış tanımlanmamıştır.

    Aşağıdaki örnekte thread'in durumu PTHREAD_CANCEL_DISABLE yapılmıştır. Ana thread pthread_cancel uyguladığı halde 
    thread sonlandırılmayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    int oldstat;

    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstat);

    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz o anda hangi thread akışının ilerlemekte olduğunu anlamak isteyebiliriz. Bunun için pthread_self isimli POSIX fonksiyonu 
    kullanılmaktadır. pthread_self fonksiyonu, bu fonksiyonu çağıran thread'in id değerini vermektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    pthread_t pthread_self(void);

    Fonksiyon başarısız olamamaktadır.

    Programcı kendi thread'i ile ilgili birtakım işlemler yapmak istediğinde de bu fonksiyonu kullanabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                52. Ders 13/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar thread'lere özellik (attribute) bilgisi geçmedik. pthread_create fonksiyonunda bu özellik parametresine 
    NULL adres verdik. Bu NULL adres thread'in default özelliklerle yaratılacağını belirtmekteydi. Şimdi thread özellikleri 
    üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread özellikleri pthread_attr_t türü ile temsil edilmektedir. pthread_attr_t türü <pthread.h> ve <sys/types.h> dosyalarında
    typedef edilmiştir. Tipik olarak bu pthread_attr_t türü bir yapı biçiminde typedef edilmektedir. Ancak POSIX standartları 
    bu yapının elemanlarını açıklamamıştır. Yani bu yapının elemanları sistemden sisteme o sistemin özelliklerine göre değişebilmektedir. 
    Thread'in özellik bilgileri bu yapının içerisine pthread_attr_setxxx fonksiyonlarıyla set edilmekte ve pthread_attr_getxxx 
    fonksiyonlarıyla da get edilebilmektedir. (Bu durumu nesne yönelimli programlamadaki sınıflara benzetebilirsiniz. Nasıl 
    sınıfın veri elemanları sınıfın "private" bölümünde tutulup onlara getter/setter fonksiyonlarla erişiliyorsa burada da aynı 
    mantık izlenmiştir.)

    Bir thread yaratılırken ona özellik girmek için şu adımlardan geçilmelidir:

    1) Önce pthread_attr_t türünden bir nesne yaratılır.

    2) Yaratılan bu nesneye pthread_attr_init fonksiyonuyla ilk değer verilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_init(pthread_attr_t *attr);

    Fonksiyon pthread_attr_t türünden nesnenin adresini alarak nesneye ilk değer vermektedir. Fonksiyon başarı durumunda 0, 
    başarısızlık durumunda errno değeri ile geri dönmektedir. Fonksiyon, Linux'ta her zaman başarılı olmaktadır. Ancak bazı 
    sistemlerde bu pthread_attr_t yapısı içerisinde bazı göstericiler için alan tahsis ediliyor olabilir ve bu tahsisat 
    başarısızlıkla sonuçlanabilir. Bu durumda pthread_attr_init fonksiyonu ENOMEM değeri ile geri döner. ENOMEM errno değeri 
    malloc, calloc, realloc gibi fonksiyonlarda da kullanılan "not enough memory" durumunu anlatmaktadır.

    3) pthread_attr_t nesnesine ilk değer verildikten sonra artık thread özellikleri pthread_attr_setxxx fonksiyonlarıyla 
    set edilebilir, pthread_attr_getxxx fonksiyonlarıyla da get edilebilir. Bazı thread özellikleri bazı özel konulara ilişkindir. 
    Dolayısıyla biz o özellikleri o konunun anlatıldığı yerde ele alacağız. Örneğin pthread_attr_setstacksize fonksiyonu ile 
    biz özellik nesnesine yaratılacak thread'in stack uzunluğunu set edebiliriz.

    4) Artık set işlemleri de yapıldıktan sonra pthread_create fonksiyonu ile thread bu pthread_attr_t türünden nesnenin adresi 
    verilerek yaratılabilir.

    5) Thread yaratıldıktan sonra pthread_attr_init fonksiyonuyla yapılan işlemler pthread_attr_destroy fonksiyonu ile geri 
    alınabilir. Bu fonksiyon thread yaratıldıktan sonra hemen çağrılabilir. Yani pthread_create fonksiyonu bizim verdiğimiz 
    pthread_attr_t nesnesinin adresini saklayıp kullanmak yerine onun içerisindekileri ilgili yere kopyalamaktadır. pthread_attr_destroy 
    fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_destroy(pthread_attr_t *attr);

    Her ne kadar fonksiyonun geri dönüş değeri benzer biçimde başarı-başarısızlık belirtiyorsa da fonksiyonun başarısız olması için 
    bir neden yoktur. Linux sistemlerinde fonksiyon her zaman başarılı olmaktadır.

    O halde thread özelliklerini oluşturup thread'in bu özelliklerle yaratılması aşağıdaki gibi yapılabilmektedir:

    pthread_attr_t tattr;
    ...

    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);

    if ((result = pthread_attr_setxxx(&tattr, ...)) != 0)
        exit_sys_errno("pthread_attr_setxxx", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread'in kullanacağı stack büyüklüğü thread yaratılırken thread'in özellik bilgileriyle set edilebilmektedir. Bunun 
    için pthread_attr_setstacksize fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);

    Fonksiyonun birinci parametresi thread özelliklerine ilişkin pthread_attr_t türünden nesnenin adresini almaktadır. İkinci 
    parametresi ise stack uzunluğunu belirtmektedir. Eğer bu set işlemi yapılmazsa Linux sistemlerinde glibc kütüphanesi default 
    stack uzunluğunu x86 32 bit sistemlerinde 2 MB, x86 64 bit sistemlerde 8 MB almaktadır.

    pthread_attr_init fonksiyonundan sonra biz bu özellik nesnesinden default stack uzunluğunu pthread_attr_getstacksize fonksiyonu 
    ile elde edebiliriz:

    #include <pthread.h>

    int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);

    Fonksiyonun birinci parametresi özellik nesnesini, ikinci parametresi stack uzunluğunun yerleştirileceği size_t türünden 
    nesnenin adresini belirtmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Aşağıdaki programda önce default stack uzunluğu yazdırılmış, sonra yeni yaratılan thread'in 64K stack kullanması sağlanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;
    size_t size;

    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);

    if ((result = pthread_attr_getstacksize(&tattr, &size)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    printf("Default stack size: %zd\n", size);

    if ((result = pthread_attr_setstacksize(&tattr, 65536)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir thread sonlandığında onun exit kodu pthread_join fonksiyonu ile elde edilip thread zombie olmaktan 
    kurtarılıyordu. pthread_join fonksiyonu thread sonlanana kadar akışı bloke ediyordu. İşte biz bir thread'i "detached" 
    moda sokarsak artık thread sonlandığında otomatik olarak thread nesnesinin tuttuğu kaynaklar boşaltılır. Dolayısıyla zombie 
    thread durumu ortadan kaldırılmış olur. Eğer biz çok sayıda thread yaratıp bunları pthread_join ile beklemek istemiyorsak 
    thread'leri "detached" moda sokmalıyız. Thread'ler yaratıldığında default olarak detached durumda değildir. Bu default 
    duruma "joinable" durum da denilmektedir.

    Detached durumda bir thread pthread_join fonksiyonu ile beklenemez. POSIX standartları bu durumu "tanımsız davranış (undefined 
    behavior)" olarak nitelendirmiştir. Linux sistemlerinde detached bir thread pthread_join ile beklenmeye çalışılırsa 
    pthread_join fonksiyonu EINVAL errno değeri ile başarısız olmaktadır.

    Bir thread'i detached moda sokmanın iki yolu vardır. Birincisi thread yaratılırken thread özellikleri ile bu sağlanabilir. 
    Bunun için int pthread_attr_setdetachstate fonksiyonu kullanılmaktadır:

    #include <pthread.h>

    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);

    Fonksiyonun birinci parametresi özellik nesnesini almaktadır. İkinci parametre şunlardan biri olabilir:

    PTHREAD_CREATE_DETACHED
    PTHREAD_CREATE_JOINABLE

    pthread_attr_init fonksiyonu default olarak zaten bu detached durumunu PTHREAD_CREATE_JOINABLE olarak set etmektedir. 
    Thread özellik parametresi NULL geçilerek yaratıldığında da default olarak "joinable" durumda olur. Fonksiyon başarı 
    durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Aşağıdaki örnekte thread özellik bilgisi ile detached moda sokulmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;

    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);

    if ((result = pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);

    printf("press ENTER to exit...\n");
    getchar();

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'i "detached" moda sokmanın diğer bir yolu thread yaratıldıktan sonra pthread_detach fonksiyonunu çağırmaktır. 
    Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_detach(pthread_t thread);

    Fonksiyon detached duruma sokulacak thread'in id değerini parametre olarak almaktadır. Başarı durumunda 0 değerine, 
    başarısızlık durumunda errno değerine geri dönmektedir. Zaten detached durumda olan bir thread için bu çağrının yapılması 
    POSIX standartlarına göre "tanımsız davranışa" yol açmaktadır. Linux sistemlerinde "joinable" olmayan thread'lerde bu 
    fonksiyon başarısız olmakta ve EINVAL errno değeri ile geri dönmektedir. Thread fonksiyon çağrıldığında zaten sonlanmışsa 
    thread'in kaynakları yine otomatik olarak yok edilmektedir.

    Aşağıdaki örnekte thread pthread_detach fonksiyonu ile detached duruma sokulmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_detach(tid)) != 0)
        exit_sys_errno("pthread_detach", result);

    printf("press ENTER to exit...\n");
    getchar();

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler konusunun önemli bir bölümünü "thread senkronizasyonu" oluşturmaktadır. Thread'lerin birlikte belli bir amacı 
    ortak bir biçimde gerçekleştirirken uyum içinde çalışması gerekebilmektedir. Özellikle ortak kaynaklara erişen thread'lerin
    bu kaynakları bozmadan işleme sokması kritik önemdedir. Thread senkronizasyonunun önemini anlatmak için basit bir örnek 
    verebiliriz. İki thread aynı global değişkeni aşağıdaki gibi artırıyor olsun:

    int g_count = 0;
    ...

    void *thread_proc1(void *param)
    {
        for (int i = 0; i < 1000000; ++i)
            ++g_count;

        return NULL;
    }

    void *thread_proc2(void *param)
    {
        for (int i = 0; i < 1000000; ++i)
            ++g_count;

        return NULL;
    }

    Bu thread'lerin çalışması bittikten sonra bu global değişkenin 2000000 değerinde olması beklenir. Ancak gerçekte bu durum sağlanamayacaktır. 
    Çünkü artırım tek bir C deyimi ile yapılmış olsa bile bunun için birkaç makine komutu gerekebilmektedir. Örneğin:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Burada thread'lerden birinin aşağıdaki noktada quanta süresini bitirdiğini düşünelim. Bu durumda işletim sistemi tam o noktada thread'in
    çalışmasına ara verip CPU'ya başka bir thread'i atayacaktır:

    MOV reg, g_count
    ---> Bu noktada preemptive olarak çalışmaya ara verilmiş olsun
    INC reg
    MOV g_count, reg

    Burada görüldüğü gibi global değişkenin değeri CPU içerisinde bir yazmaca çekilmiştir. Ancak tam o sırada thread'ler arası 
    geçiş (context switch) oluşmuştur. Bu sırada diğer bir thread CPU'ya atanıp çalıştırılmış olabilir. Böylece diğer thread global değişkeni 
    artırmış olacaktır. Sonra yeniden çalışma bu thread'e döndüğünde, thread kalınan yerden çalışmaya devam edecektir:

    INC reg
    MOV g_count, reg

    Görüldüğü gibi çalışma devam ettiğinde global değişkenin o anki değeri kaybedilmiş olmaktadır. Thread'ler arası geçiş oluştuğunda işletim sistemi
    o andaki thread'e ilişkin CPU yazmaçlarının değerlerini de saklayıp geri yüklemektedir. Buradaki problem ise bir işlemin arada kesilmesi ile 
    ilgilidir. Bu tür işlemlerde volatile anahtar sözcüğü bize bir fayda sağlamaz. Örneğin:

    volatile int g_count;

    volatile anahtar sözcüğü işlemin atomik yapılmasını garanti etmemektedir. volatile anahtar sözcüğü yalnızca "ilgili nesne kullanıldığında o nesnenin 
    güncel değeri için belleğe başvurunun yapılacağı" anlamına gelmektedir. Yani burada nesne volatile yapılsa bile üretilen makine kodlarında bir farklılık
    oluşmayacaktır.

    Pekiyi yukarıdaki problemin kaynağı nedir? Problemin asıl kaynağı "thread'lerin ansızın belli bir makine komutunda preemptive 
    biçimde quanta süresini doldurduklarında kesilebilmesi yani çalışmasına ara verilebilmesidir". Pekiyi bu problem nasıl çözülebilir? 
    İşte bu problem iki biçimde çözülebilir:

    1) Söz konusu işlemlerin atomik bir biçimde yapılmasıyla: İşlemlerin atomik yapılması demek o işlemler yapılırken hiç kesilme 
    olmaması yani tek hamlede yapılması demektir. Genellikle böyle bir durumu sağlamak mümkün olmaz. Tabii yukarıdaki örnekte 
    artırma işlemi tek bir makine komutu ile yapılıyor olsaydı işlem atomik olurdu. Dolayısıyla yukarıdaki örnekte bir sorun kalmazdı.
    Thread'ler arası geçiş makine komutları çalıştırılırken gerçekleşmemektedir. Bir makine komutunun çalışması bittikten sonra ancak diğeri
    henüz çalıştırılmadan gerçekleşebilmektedir. Yani makine komutları atomiktir.

    2) Söz konusu işlemler sırasında kesilme (thread'ler arası geçiş) olsa da başka bir akışın bu işlemler bitene kadar bekletilmesiyle:
    Bu yöntem genellikle kullanılan yöntemdir. Bu yöntemde işlemler sırasında ters bir noktada kesilme (thread'ler arası geçiş) olabilir. 
    Ancak geçilen eğer aynı ortak kaynağa erişiyorsa "thread, kesilen thread bu işlemi bitirene kadar" bekletilir.

    Yukarıdaki gibi durumlar thread'lerle çalışmada çok sık karşımıza çıkmaktadır. Örneğin bir thread bir makineyi önce reset edip bir konuma soksun:

    - makine reset ediliyor
    - reset edilen makine belli bir konuma sokuluyor

    Bu konuma sokma işlemi mutlaka reset'ten sonra yapılmak zorunda olsun. Şimdi makineye birden fazla thread'ten eriştiğimizi düşünelim.
    Thread akış'larından biri aşağıdaki noktada kesilmiş olsun:

    - makine reset ediliyor
        ---> thread akışı bu noktada kesilmiş olsun
    - reset edilen makine belli bir konuma sokuluyor

    Bu thread kesilmişken başka bir thread bu makine üzerinde yukarıdaki iki işlemi kesilmeden yapmış olabilir. Bu durumda bu thread 
    çalışmasına devam ettiğinde sanki makineyi reset sonrasında konumlandırıyor gibi bir durum oluşacaktır. Halbuki makinenin durumu 
    değişmiştir.

    Thread senkronizasyonu genellikle "ortak kaynaklara" erişimde gerekmektedir. İki thread birbirinden bağımsız işlemler yapıyorsa
    yani bunlar hiçbir ortak kaynağa erişmiyorlarsa bunların senkronize edilmesi gerekliliği yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Başından sonuna kadar tek bir akış tarafından çalıştırılması gereken kodlara "kritik kodlar (critical sections)" denilmektedir. 
    Kritik kod bloklarına bir thread girdiğinde orada thread akışı kesilebilir. Yani thread'ler arası geçiş oluşabilir. Ancak başka 
    bir thread önceki thread o bloktan çıkana kadar o bloğa girmemelidir. Örneğin:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Burası bir kritik kod bloğudur. Çünkü bu kod bloğu başından sonuna kadar tek bir thread tarafından çalıştırılmalıdır. 
    Bir thread bu kritik kod bloğunda kesilse bile önceki thread bu bloktan çıkana kadar, başka bir thread bu bloğa girmemelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kritik kodlar manuel biçimde oluşturulamazlar. Örneğin aşağıdaki gibi bir çaba sonuçsuz kalacaktır:

    int g_flag = 0;
    ...

    while (g_flag == 1)
        ;
    g_flag = 1;
    ...
    ...        KRİTİK KOD BLOĞU
    ...
    g_flag = 0;

    Burada programcı g_flag 1 olduğu SÜRECE "başka bir thread kritik kodda olduğu için" beklemiştir. g_flag 0'a çekildiğinde
    akış döngüden çıkmakta ve g_flag yeniden 1 yapılmaktadır. Bu kodun iki önemli problemi vardır. Birincisi kesilme döngüden çıkıldığında
    ancak henüz g_flag değişkenine 1 atanmadan gerçekleşmiş olabilir:

    while (g_flag == 1)
        ;
    ---> DİKKAT BU NOKTADA KESİLME OLABİLİR
    g_flag = 1;
    ...
    ...        KRİTİK KOD BLOĞU
    ...
    g_flag = 0;

    Bu kodun ikinci problemi beklemenin "meşgul bir döngüde (busy loop)" yapılmasıdır. Yani burada bekleme bir döngü içerisinde 
    CPU zamanı harcanarak yapılmaktadır. Halbuki beklemenin CPU zamanı harcanmadan thread bloke edilerek yapılması arzu edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi kritik kod blokları nasıl oluşturulmaktadır? İşte kritik kodlar "işletim sisteminin de işe karıştığı" birtakım 
    "senkronizasyon nesneleriyle" oluşturulmaktadır. Bu senkronizasyon nesneleri genel olarak kernel mode'a geçiş yapabilmektedir.
    Kernel mode'da atomik işlemler yapmak işlemcilerin sağladığı bazı özel makine komutlarıyla mümkün olabilmektedir. Artık 
    pek çok modern masasütü ve mobil işlemci "user mode'da" bazı senkronizasyon problemleri için "atomik bir biçimde çalışan" 
    özel komutlar barındırmaktadır. Bazı senkronizasyon nesneleri daha az kernel mode'a geçerek bu makine komutlarının 
    yardımıyla daha etkin kilitleme yapabilmektedir.

    Linux sistemlerinde senkronizasyon nesneleri ismine "futex" denilen bir sistem fonksiyonu yoluyla gerçekleştirilmiştir. 
    Yani Linux senkronizasyon amacıyla kullanılacak bir futex nesnesini bir sistem fonksiyonu olarak bulundurmuştur. Burada ele 
    alacağımız senkronizasyon nesneleri Linux'ta bu "futex" denilen sistem fonksiyonu kullanılarak gerçekleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmak için yaygın kullanılan senkronizasyon nesnelerinden biri "mutex" denilen nesnedir. Mutex sözcüğü 
    "mutual exclusion" sözcüklerinden kısaltma yapılarak uydurulmuştur. Mutex nesneleri pek çok farklı işletim sisteminde benzer 
    biçimlerde bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                53. Ders 20/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde mutex nesneleri tipik olarak şu aşamalardan geçilerek kullanılmaktadır:

    1) Mutex nesneleri pthread_mutex_t türü ile temsil edilmiştir. Bu tür ismi <pthread.h> ve <sys/types> dosyaları içerisinde 
    typedef edilmiş durumdadır. POSIX standartlarına göre pthread_mutex_t türü herhangi bir tür olarak typedef edilmiş olabilir. 
    Örneğin Linux'ta bu tür bir yapı (birliğin içerisinde bir yapı) biçiminde typedef edilmiştir. Programcı pthread_mutex_t 
    türünden global bir nesne tanımlamalıdır. Örneğin:

    pthread_mutex_t g_mutex;

    Bu nesneye ilk değer vermenin iki yolu vardır. İlk değer doğrudan PTHREAD_MUTEX_INITIALIZER isimli makro kullanılarak verilebilir. 
    Bu makro tipik olarak küme parantezleri içerisinde yapıya ilk değer verme biçiminde açılmaktadır. Örneğin:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

    Mutex nesnesine ilk değer vermenin ikinci yolu pthread_mutex_init fonksiyonunu kullanmaktır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

    Fonksiyonun birinci parametresi ilk değer verilecek mutex nesnesinin adresini almaktadır. İkinci parametresi mutex nesnesinin 
    bazı özelliklerini belirten "özellik nesnesinin" adresini almaktadır. Mutex özellikleri daha sonra ele alınacaktır. Bu ikinci 
    parametreye NULL adres geçilirse mutex default özelliklerle yaratılır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönmektedir. Örneğin:

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    Mutex nesnesi PTHREAD_MUTEX_INITIALIZER makrosuyla yaratıldığında mutex nesnesinin özellik bilgisi de default değerlerle 
    oluşturulmaktadır. Yani aşağıdaki iki ilk değer verme biçimi eşdeğerdir:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_init(&g_mutex, NULL);

    Tabii bir mutex nesnesine yalnızca bir kez ilk değer vermeliyiz. POSIX standartlarına göre nesneye birden fazla kez ilk değer vermek tanımsız
    davranışa yol açmaktadır.

    Programcı mutex nesnesinin kullanımı bittikten sonra pthread_mutex_destroy fonksiyonu ile onu boşaltmalıdır. Aslında bazı sistemlerde bu pthread_mutex_destroy
    fonksiyonu boşaltım için bir şey yapmamaktadır. Yani bazı sistemlerde bu içi boş bir fonksiyondur. Ancak POSIX standartlarına göre mutex nesnesi
    yaratılırken birtakım tahsisatlar yapılmış olabilir ve bu tahsisatların geri alınması pthread_mutex_destroy fonksiyonuyla sağlanmaktadır. 
    Yine bazı sistemlerde mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilk değer verilmişse onun boşaltımının yapılması gerekmeyebilmektedir. 
    Ancak POSIX standartlarına göre nesneye makro ile ilk değer verilmiş olsa bile nesnenin boşaltımı yine yapılmalıdır.

    #include <pthread.h>

    int pthread_mutex_destroy(pthread_mutex_t *mutex);

    Fonksiyon, mutex nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine 
    geri döner. Linux'ta bu fonksiyon bir şey yapmamaktadır. Ancak POSIX standartlarına göre bu fonksiyonun çağrılması gerekir. 
    Çünkü yukarıda da belirttiğimiz gibi pthread_mutex_init fonksiyonu içerisinde dinamik tahsisatlar yapılmış olabilir ve 
    bu tahsisatların geri alınması gerekebilir. Tabii aslında bu fonksiyonun başarısız olması da genel olarak mümkün değildir.
    Örneğin:

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destory", result);

    Burada bir noktayı yeniden vurgulamak istiyoruz: Eğer mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilk değer verilmişse
    mutex nesnesinin destroy edilmesi pek çok sistemde gerekmemektedir. Ancak POSIX standartlarında bu durum belirtilmemiştir, 
    bu da mutex nesnesi makroyla initialize edilse bile destroy işlemini yapılması gerektiği anlamına gelmektedir. Ancak pek çok 
    programcı bu tür durumlarda destroy işlemini yapmamaktadır.

    Pekiyi mademki PTHREAD_MUTEX_INITIALIZER makrosu daha pratik bir kullanım sunmaktadır o halde neden pthread_mutex_init fonksiyonuna 
    gereksinim duyulmuştur? İşte bazen mutex nesneleri dinamik bir biçimde de tahsis edilebilmektedir. Örneğin bir yapı nesnesini 
    senkronize etmek için bir mutex kullanılacaksa, mutex o yapının içerisinde yapı elemanı olarak bildirilebilir. Bu durumda ona 
    statik biçimde makroyla ilk değer vermek mümkün olmaz. Çünkü C'de bir yapı nesnesine küme parantezleri ile atama yapamayız. 
    (C99 ile birlikte ismine "compound literals" denilen bir sentaks ile bu durum mümkün hale getirilmiştir.)

    Örneğin (kontroller ihmal edilmiştir):

    struct INFO {
        int a;
        int b;
        int c;
        pthread_mutex_t mutex;
    };
    ...
    struct INFO *info;

    info = (struct INFO *)malloc(sizeof(struct INFO));

    pthread_mutex_init(&info->mutex, NULL);

    2) Mutex nesneleriyle kritik kod aşağıdaki gibi oluşturulmaktadır:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ...
    ...        <KRİTİK KOD>
    ...

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    Görüldüğü gibi kritik kodun başında pthread_mutex_lock fonksiyonu sonunda da pthread_mutex_unlock fonksiyonu çağrılmıştır. 
    Mutex nesneleri, işletim sistemlerinde "thread temelinde sahipliği (ownership) alınan" nesnelerdir. Bir thread, pthread_mutex_lock
    fonksiyonuna girdiğinde mutex nesnesinin sahipliğinin başka bir thread tarafından alınıp alınmadığı fonksiyonda kontrol edilmektedir. 
    Eğer mutex nesnesinin sahipliği başka bir thread tarafından alınmışsa yani mutex nesnesi zaten "kilitlenmişse (locked edilmişse)"
    bu durumda pthread_mutex_lock fonksiyonu thread'i bloke eder, ta ki mutex'in sahipliğini alan thread pthread_mutex_unlock ile 
    mutex'in sahipliğini bırakana kadar. Eğer mutex'in sahipliği herhangi bir thread tarafından alınmamışsa yani mutex kilitli 
    değilse, bu durumda pthread_mutex_lock fonksiyonu mutex'in sahipliğini alır (yani onu kilitler) ve akış kritik kodu girer. 
    Mutex kilitliyken diğer thread akışları pthread_mutex_lock fonksiyonunda bloke edilerek bekletilecektir. Mutex nesnesinin 
    kilidi onu kilitleyen thread tarafından açıldığında pthread_mutex_lock fonksiyonunda bloke olmuş olan thread'lerden biri 
    mutex'in sahipliğini alarak (yani onu kilitleyerek) kritik kodu girecektir. Böylece kritik kod içerisinde başından sonuna kadar 
    tek bir thread akışı bulunuyor olacaktır. Ancak pthread_mutex_lock fonksiyonunda birden fazla thread'in bloke olması durumunda 
    mutex'in kilidi açıldığı zaman hangi thread'in mutex'in sahipliğini alacağı konusunda işletim sistemleri bir garanti vermemektedir. 
    Yani burada bir FIFO sisteminin uygulanmasının bir garantisi yoktur. Ancak işletim sistemleri çeşitli koşullar sağlanıyorsa 
    mümkün olduğunca adil bir durum oluşturmaya çalışırlar. pthread_mutex_lock ve pthread_mutex_unlock fonksiyonlarının prototipleri 
    şöyledir:

    #include <pthread.h>

    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);

    Fonksiyonlar parametre olarak mutex nesnesinin adresini alırlar. Başarı durumunda 0 değerine, başarısızlık durumunda errno 
    değerine geri dönerler.

    Tabii kritik kodun tek bir yerde olması gerekmemektedir. Önemli olan aynı mutex nesnesinin kullanılıyor olmasıdır. Örneğin 
    thread'lerden biri aşağıdaki gibi bir kritik kodla bir fonksiyonda karşılaşmış olabilir:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ...
    ...        <KRİTİK KOD>
    ...

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    Başka bir thread de başka bir fonksiyonda aşağıdaki gibi bir kritik kodla karşılaşmış olabilir:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ...
    ...        <KRİTİK KOD>
    ...

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    Burada kullanılan mutex nesneleri aynı nesnedir. Dolayısıyla iki thread de aynı mutex nesnesini kilitlemeye çalışmaktadır. 
    O halde thread'lerden biri o fonksiyonda kritik kodu girerse, diğer bir thread başka bir fonksiyonda diğer kritik kodu giremez.

    Normal olarak programcının her paylaşılan kaynak için ayrı bir mutex nesnesini bulundurması gerekir. Örneğin global bir bağlı 
    liste söz konusu olsun. Bu bağlı liste üzerinde eleman ekleme, eleman silme ve arama işlemlerini yapan üç fonksiyon bulunuyor 
    olsun:

    add_item(...)
    {
        ...
    }

    remove_item(...)
    {
        ...
    }

    search_item(...)
    {
        ...
    }

    Burada bir thread eleman eklerken diğer thread'lerin bu iş bitene kadar eleman silmeye çalışmaması ya da bağlı listede 
    arama yapmaması gerekir. Ya da bir eleman silerken diğer thread'lerin diğer işleri yapmaması gerekir. O halde bu üç fonksiyonda 
    aynı mutex kullanılarak kritik kod oluşturulmalıdır. Örneğin (sembolik kodlar kullanıyoruz):

    pthread_mutex_t g_llmutex = PTHREAD_MUTEX_INITIALIZER;

    add_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman ekleniyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    remove_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman siliniyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    search_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman aranıyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    Mutex nesnelerinin thread temelinde sahipliği söz konusudur. Yani mutex nesnesinin sahipliği pthread_mutex_lock fonksiyonu 
    ile alındığında ancak alan thread nesnenin sahipliğini pthread_mutex_unlock fonksiyonuyla bırakabilir. Özetle biz başka bir 
    thread'in kilitlediği mutex nesnesinin kilidini açamayız. POSIX standartlarına göre sahipliği alınmamış olan bir mutex 
    nesnesini unlock etmeye çalışmak mutex özelliklerine bağlı olarak "tanımsız davranışa" yol açabileceği gibi pthread_mutex_unlock 
    fonksiyonunun başarısız olmasına da yol açabilmektedir. Normal mutex'ler (yani default özellikle yaratılmış mutex'ler) için 
    POSIX standartları sahipliğini almayan thread'in mutex nesnesinin kilidini açmaya çalışmasının "tanımsız davranışa" yol açacağını 
    belirtmektedir.

    3) Mutex nesneleri için bazı yardımcı fonksiyonlar da bulunmaktadır. Örneğin; biz bir mutex nesnesi kilitliyken bloke olmayı 
    istemeyip "madem nesne kilitli o zaman ben de başka şeyler yapayım" diyebiliriz. Bu işlem pthread_mutex_trylock fonksiyonuyla 
    sağlanabilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_trylock(pthread_mutex_t *mutex);

    Fonksiyon parametre olarak mutex nesnesinin adresini almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri dönmektedir. Eğer mutex nesnesi zaten başka bir thread tarafından kilitlenmişse fonksiyon bloke olmaz ve 
    EBUSY errno değeri ile geri döner. Örneğin:

    result = pthread_mutex_trylock(&g_mutex);

    if (result != 0)
        if (result == EBUSY) {
            <başka bir şeyler yap>
        }
        else
            exit_sys_errno("pthread_mutex_trylock", result);

    Bu örnekte pthread_mutex_trylock fonksiyonu başarısız olduğunda errno değeri EBUSY ise başka birtakım işlemler yapılmaktadır.

    pthread_mutex_timedlock isimli fonksiyon, pthread_mutex_lock fonksiyonunun "zaman aşımlı (timeout)" biçimidir. Fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *abstime);

    Fonksiyonun birinci parametresi mutex nesnesinin adresini, ikinci parametresi de mutlak zamana ilişkin timespec yapı nesnesinin 
    adresini almaktadır. Burada zaman aşımı mutlak zamana ilişkindir. Yani biz örneğin 5 saniyelik bir zaman aşımı vereceksek önce
    01/01/1970'ten geçen saniye sayısını elde edip onun üzerine 5 saniye katarak bu fonksiyona vermeliyiz. Örneğin:

    struct timespec ts;
    ...
    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 5;

    result = pthread_mutex_timedlock(&g_mutex, &ts);

    if (result != 0) {
        if (result == ETIMEDOUT) {
            <fonksiyon zaman aşımından dolayı sonlandı>
        }
        else
            exit_sys_errno("pthread_timedlock", result);
    }
    ...

    Bazı algoritmalarda "kilitlenme (deadlock)" problemlerinin çözümü zor olabilmektedir. Bu tür durumlarda son çare olarak 
    bu fonksiyon kullanılabilmektedir. Bazen makul bir süre aşıldığında arka plan belirli işlemlerin yapılması da gerekebilmektedir. 
    Bu tür seyrek durumlarda da pthread_mutex_timedlock fonksiyonu kullanılabilmektedir. Ancak bu fonksiyona toplamda çok seyrek 
    gereksinim duyulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread kritik kod içerisinde aynı global değişkeni 1000000 kez artırmıştır. Bu durumda global değişken 
    olması gerektiği değerde (2000000) olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++g_count;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++g_count;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread de bir makineyi 1'den 5'e kadar konuma sokmaktadır. Ancak bu işlemlerin iç içe geçmesi istenmemektedir. 
    Örnekte rastgele beklemeler de uygulanmıştır. Burada thread'lerin sırasıyla kritik kodu girmesinin zorunlu olmadığına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void do_something(const char *name);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    const char *name = (const char *)param;

    for (int i = 0; i < 10; ++i)
        do_something(name);

    return NULL;
}

void *thread_proc2(void *param)
{
    const char *name = (const char *)param;

    for (int i = 0; i < 10; ++i)
        do_something(name);

    return NULL;
}

void do_something(const char *name)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: 1. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 2. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 3. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 4. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 5. Step\n", name);
    usleep(rand() % 300000);
    printf("-----------------------\n");

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                54. Ders 21/05/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir veri yapısı thread'ler arasında ortak bir biçimde kullanılıyorsa ve bu thread'ler veri yapısı üzerinde değişiklikler 
    yapabiliyorsa veri yapısının bozulmaması için senkronize edilmesi gerekir. Her veri yapısı için tipik olarak o veri 
    yapısını senkronize etmekte kullanılan bir mutex nesnesinin veri yapısı içerisinde bulundurulması yoluna gidilmektedir. 
    Örneğin thread'ler arasında ortak kullanılabilecek bir "bağlı liste (linked list)" oluşturmak isteyelim. Bu bağlı listeye
    iki thread de eleman eklemeye çalışırsa bağlı liste bozulabilecektir. Bu nedenle bağlı listeyi senkronize etmek için bir mutex
    bulundurulmalı ve bu mutex nesnesi ile senkronizasyon işlemi yapılmalıdır. Aşağıda böyle bir örnek verilmiştir. Bu örnekte 
    create_llist fonksiyonu "tek bağlı (single linked)" bağlı liste yaratmaktadır. Fonksiyon bağlı liste bilgilerinin bulunduğu 
    yapı nesnesinin adresine geri dönmektedir:

    typedef struct tagNODE {
        int val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagLLIST {
        NODE *head;
        NODE *tail;
        size_t count;
        pthread_mutex_t mutex;
    } LLIST;

    LLIST *create_llist(void);

    add_item_tail ve add_item_head fonksiyonları bağlı listenin sonuna ve başına mutex kontrolü ile eleman eklemektedir.

    NODE *add_item_tail(LLIST *llist, int val);
    NODE *add_item_head(LLIST *llist, int val);

    Fonksiyonlar başarı durumunda eklenen düğümün adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Fonksiyonlar başarısızlık 
    durumunda errno değerini de set etmektedir. Bağlı listeyi dolaşan bir walk__llist fonksiyonu da bulunmaktadır:

    int walk_llist(LLIST *llist);

    Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmekte ve errno uygun biçimde set edilmektedir. 
    Nihayet bağlı liste destroy_llist fonksiyonu ile silinmektedir:

    void destroy_llist(LLIST *llist);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <pthread.h>

typedef struct tagNODE {
    int val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE *head;
    NODE *tail;
    size_t count;
    pthread_mutex_t mutex;
} LLIST;

LLIST *create_llist(void);
void destroy_llist(LLIST *llist);
NODE *add_item_tail(LLIST *llist, int val);
NODE *add_item_head(LLIST *llist, int val);
int walk_llist(LLIST *llist);

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

static inline size_t get_count(LLIST *llist)
{
    return llist->count;
}

LLIST *create_llist(void)
{
    LLIST *llist;
    int result;

    if ((llist = (LLIST *)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    llist->head = NULL;
    llist->tail = NULL;
    llist->count = 0;

    if ((result = pthread_mutex_init(&llist->mutex, NULL)) != 0) {
        errno = result;
        free(llist);
        return NULL;
    }

    return llist;
}

NODE *add_item_tail(LLIST *llist, int val)
{
    NODE *new_node;
    int result;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    new_node->val = val;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {
        free(new_node);
        goto FAILED;
    }

    if (llist->head == NULL)
        llist->head = new_node;
    else
        llist->tail->next = new_node;

    llist->tail = new_node;
    ++llist->count;

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0)
        goto FAILED;

    return new_node;

FAILED:
    errno = result;

    return NULL;
}

NODE *add_item_head(LLIST *llist, int val)
{
    NODE *new_node;
    int result;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    new_node->val = val;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {
        free(new_node);
        goto FAILED;
    }

    if (llist->head == NULL)
        llist->tail = new_node;

    new_node->next = llist->head;
    llist->head = new_node;

    ++llist->count;

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0)
        goto FAILED;

    return new_node;

FAILED:
    errno = result;

    return NULL;
}

int walk_llist(LLIST *llist)
{
    NODE *node;
    int result;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {
        errno = result;
        return -1;
    }

    node = llist->head;

    while (node != NULL) {
        printf("%d ", node->val);
        fflush(stdout);
        node = node->next;
    }

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0) {
        errno = result;
        return -1;
    }

    printf("\n");

    return 0;
}

void destroy_llist(LLIST *llist)
{
    NODE *node, *temp_node;

    node = llist->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(llist);
}

int main(void)
{
    pthread_t tid1, tid2, tid3;
    int result;
    LLIST *llist;

    if ((llist = create_llist()) == NULL)
        exit_sys("create_list");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    walk_llist(llist);

    printf("%zd\n", get_count(llist));

    destroy_llist(llist);

    return 0;
}

void *thread_proc1(void *param)
{
    LLIST *llist = (LLIST *)param;

    for (int i = 0; i < 1000000; ++i)
        if (add_item_tail(llist, i) == NULL)
            exit_sys("add_item_tail");

    return NULL;
}

void *thread_proc2(void *param)
{
    LLIST *llist = (LLIST *)param;

    for (int i = 0; i < 1000000; ++i)
        if (add_item_tail(llist, i) == NULL)
            exit_sys("add_item_tail");

    return NULL;
}

void *thread_proc3(void *param)
{
    LLIST *llist = (LLIST *)param;

    for (int i = 0; i < 1000000; ++i)
        if (add_item_head(llist, i) == NULL)
            exit_sys("add_item_head");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mutex nesnesine pthread_mutex_init fonksiyonu ile ilk değer verilirken mutex özellikleri de bu fonksiyonun ikinci parametresinde
    belirtilebilir. Eğer mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilk değer verilmişse bu durumda mutex default 
    özelliklerle yaratılmaktadır. Daha önceden de belirttiğimiz gibi aşağıdaki iki ilk değer verme tamamen eşdeğerdir:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_init(&g_mutex, NULL);

    Mutex özelliklerinin set edilmesi tamamen thread özelliklerinin set edilmesinde olduğu gibi yapılmaktadır. Yani işlemler şu 
    adımlardan geçilerek gerçekleştirilir:

    1) Önce pthread_mutexattr_t türünden bir özellik nesnesi tanımlanır.

    2) Bu özellik nesnesine pthread_mutexattr_init fonksiyonu ile ilk değerleri verilir. Bu nesneye ilk değer vermek için bir 
    makro yoktur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutexattr_init(pthread_mutexattr_t *attr);

    Fonksiyon parametre olarak mutex özellik nesnesinin adresini almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda errno 
    değerine geri döner.

    3) Bundan sonra artık pthread_mutexattr_setxxx fonksiyonlarıyla mutex özellikleri özellik nesnesinin içerisine yerleştirilir.

    4) Artık özellik nesnesi oluşturulmuştur. Mutex nesnesi, bu özellik nesnesi verilerek pthread_mutex_init fonksiyonu ile 
    oluşturulabilir.

    5) Mutex nesnesi yaratıldıktan sonra artık özellik nesnesine gerek kalmamaktadır. Özellik nesnesi pthread_mutexattr_destroy 
    fonksiyonu ile yok edilebilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

    Fonksiyon yine parametre olarak mutex özellik nesnesini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri 
    döner. Özetle işlemler aşağıdaki kod parçasında belirtilen sırada yapılmaktadır:

    pthread_mutexattr_t mattr;
    ...

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    /* pthread_mutexattr_setxxx fonksiyonlarıyla set işlemi */

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread, bir mutex nesnesinin sahipliğini pthread_mutex_lock fonksiyonu ile aldıktan sonra yeniden aynı fonksiyonu 
    çağırarak aynı mutex nesnesinin sahipliğini almaya çalışırsa ne olur? Muhtemel üç durum söz konusudur:

    1) Thread kendi kendini kilitler ve "deadlock" oluşur.

    2) Thread mutex'in sahipliğini ikinci kez alır ve bir sorun oluşmaz. Böyle mutex'lere "recursive mutex" denilmektedir.

    3) Sahipliği alınmış mutex nesnesine yeniden pthread_mutex_lock uygulandığında fonksiyon başarısız olur.

    İşte bu muhtemel senaryoların her biri mutex nesnesinin türü denilen özelliği değiştirilerek sağlanabilmektedir. Mutex nesnesinin 
    türünü değiştirmek için pthread_mutexattr_settype fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

    Fonksiyonun birinci parametresi mutex özellik nesnesini, ikinci parametresi mutex'in türünü almaktadır. Tür şunlardan biri olabilir:

    PTHREAD_MUTEX_NORMAL: Mutex'in sahipliği ikinci kez alınmak istenirse kilitlenme "deadlock" oluşur.

    PTHREAD_MUTEX_ERRORCHECK: Şu durumlarda fonksiyonlar başarısız olmaktadır:

        - Mutex nesnenin sahipliği ikinci kez alınmaya çalışıldığında
        - Mutex nesnesinin sahipliğini almadan pthread_mutex_unlock işlemi uygulandığında

    PTHREAD_MUTEX_RECURSIVE: Mutex'in sahipliğini alan thread yeniden pthread_mutex_lock fonksiyonu ile sahipliği alabilir. 
    Ancak bu durumda fonksiyon sahipliğini aldığı miktarda onu pthread_mutex_unlock uygulamalıdır. Recursive mutex'ler için mutex 
    nesnesinin içerisinde bir sayaç bulundurulmaktadır. (Yani her pthread_mutex_lock fonksiyonundan geçildiğinde mutex'in sayacı 1
    artırılır, her pthread_mutex_unlock fonksiyonundan geçildiğinde sayaç 1 eksiltilir. Sayaç 0'a düşünce mutex'in kilidi açılır.)

    PTHREAD_MUTEX_DEFAULT: Bu default durumdur. POSIX standartlarına göre bu default durum yukarıdaki üç durumdan biri olabilir. 
    Linux sistemlerinde default durum PTHREAD_MUTEX_NORMAL ile aynıdır.

    Eğer mutex nesnesinin türü set edilmediyse mutex nesnesi default olarak PTHREAD_MUTEX_DEFAULT durumda olur. Yukarıda da belirtildiği gibi 
    Linux sistemlerinde bu değer zaten PTHREAD_MUTEX_NORMAL ile aynıdır. Yani default durumda Linux sistemlerinde thread yeniden mutex nesnesinin 
    sahipliğini almaya çalışırsa "deadlock" oluşmaktadır.

    Mutex nesnesinin türü de benzer biçimde pthread_mutexattr_gettype fonksiyonu ile alınabilmektedir:

    #include <pthread.h>

    int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);

    Fonksiyon mutex'in tür bilgisini ikinci parametresiyle belirtilen nesneye yerleştirir. Başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread bir mutex'in sahipliğini almaya çalışmaktadır. Mutex'in sahipliğini alan thread "foo" fonksiyonunu 
    çağırdığında mutex'in sahipliğini ikinci kez almaya çalışmaktadır. Mutex nesneleri Linux'ta default durumda PTHREAD_MUTEX_NORMAL
    türünde olduğu için "deadlock" oluşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void foo(const char *name);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void foo(const char *name)
{
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    foo(name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);

    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    foo(name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki örneği mutex türünü PTHREAD_MUTEX_RECURSIVE yaparak yeniden düzenleyelim. Burada artık mutex nesnesi 
    "recursive" duruma sokulduğu için aynı thread mutex nesnesinin sahipliğini almaya çalıştığında bloke oluşmayacaktır. Ekrana 
    çıkan yazıları dikkatlice inceleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void foo(const char *name);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    pthread_mutexattr_t mattr;

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE)) != 0)
        exit_sys_errno("pthread_mutexattr_settype", result);

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void foo(const char *name)
{
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    foo(name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);

    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    foo(name);

    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s: mutex unlocked...\n", name);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread bir mutex nesnesinin sahipliğini aldıktan sonra sonlanırsa ne olur? (Sahipliği bir thread tarafından alınmış
    ancak o thread'in sonlanmış olması durumunda bu tür mutex'lere "abandoned mutex"ler de denilmektedir.) Bu tür durumlarda 
    iki olası durum söz konusudur:

    1) Thread sonlanmış olsa da mutex'in sahipliği sonlanan thread'te kalır. Dolayısıyla başka bir thread mutex'i kilitlemek 
    isterse ya da zaten pthread_mutex_lock ile blokede bekliyorsa "deadlock" oluşur.

    2) Sahipsiz kalmış mutex bir daha kilitlenemez. Eğer bir thread, bu mutex'i kilitlemeye çalışırsa ya da daha önce kilitlemeye 
    çalışıp bloke olmuşsa pthread_mutex_lock başarısız olur.

    İşte bu iki durumun hangisinin uygulanacağı mutex özellikleri ile belirlenebilmektedir. Bunun için pthread_mutexattr_setrobust
    fonksiyonu kullanılmaktadır:

    int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);

    Fonksiyonun birinci parametresi yine mutex özellik nesnesinin adresini almaktadır. İkinci parametre şu değerlerden biri olabilir:

    PTHREAD_MUTEX_STALLED: Bu durumda mutex kilitli kalır ve başka bir thread mutex'i kilitlemeye çalışırsa "deadlock" oluşur.

    PTHREAD_MUTEX_ROBUST: Bu durumda başka bir thread "abandoned mutex"i kilitlemeye çalışırsa pthread_mutex_lock başarısız olur
    ve fonksiyon EOWNERDEAD errno değeri ile geri döner. Ancak POSIX standartlarına göre bu kilitlemeyi ilk yapmaya çalışan thread'de
    bu hata elde edilir. Diğer thread'lerin yeniden bu mutex'i kilitlemeye çalışması durumunda yeniden EOWNERDEAD hatasının elde edilip
    edilmeyeceği işletim sistemini yazanların isteğine bırakılmıştır. Sahibi sonlanmış bir mutex kilitlenmeye çalışılırken EOWNERDEAD 
    errno değeri ile fonksiyon geri döndüğünde thread'in yeniden kullanılabilir hale getirilebilmesi için pthread_mutex_consistent 
    fonksiyonun çağrılması gerekmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_consistent(pthread_mutex_t *mutex);

    Fonksiyon parametre olarak mutex nesnesinin adresini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri döner. 
    Mutex "consistent" duruma sokulduğunda aynı zamanda kilitlenmiş de olur. Örneğin:

    result = pthread_mutex_lock(&g_mutex);

    if (result == EOWNERDEAD) {
        if ((result = pthread_mutex_consistent(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_consistent", result);

        /* mutex locked durumda *
    }
    else
        exit_sys_errno("pthread_mutex_lock", result);

    Mutex nesneleri default özellikle yaratıldığında robust durumu default olarak PTHREAD_MUTEX_STALLED biçimdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mutex nesnesi default özelliklerle yaratılmıştır. Burada thread_proc1, mutex nesnesinin sahipliğini alarak 
    sonlandırılmıştır. thread_proc2 fonksiyonunun pthread_mutex_lock işleminde "deadlock" oluşacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: thread terminates\n", name);

    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    sleep(1);
    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s mutex unlocked...\n", name);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mutex "robust" duruma sokularak aynı işlemler yapılmıştır. Bu durumda thread_proc2 artık mutex nesnesini 
    kilitlemeye çalıştığında fonksiyon EOWNERDEAD errno değeri ile başarısız olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    pthread_mutexattr_t mattr;

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setrobust(&mattr, PTHREAD_MUTEX_ROBUST)) != 0)
        exit_sys_errno("pthread_mutexattr_setrobust", result);

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: thread terminates\n", name);

    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    sleep(1);
    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s mutex unlocked...\n", name);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri bazı programlama dillerinde bir deyim olarak bile bulundurulmuştur. Örneğin C#'ta lock deyimi ve Java'da 
    synchronize deyimi mutex kontrolü altında işlem yapmak için dile eklenmiştir. Örneğin C#'taki lock deyiminin genel 
    biçimi şöyledir:

    lock (obj)
        <deyim>

    Burada farklı thread'ler aynı nesneyi kullanırlarsa aynı kilit üzerinde işlem yapıyor olurlar. Aslında .NET dokümanlarında
    lock deyiminin Monitor nesnesi kullandığı belirtilmiştir. "Monitor nesnesi" de bir çeşit mutex nesnesi gibidir.

    Aynı deyim Java'da "synchronized" ismiyle bulunmaktadır. Oradaki deyimin genel biçimi de C#'taki gibidir:

    synchronized (obj)
        <deyim>

    Aşağıda C#'ta lock deyiminin kullanılmasına bir örnek verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

using System;
using System.Threading;

namespace CSD
{
    class App
    {
        private static int m_count;
        private static object m_obj = new object();

        public static void Main(string[] args)
        {
            Thread thread1 = new Thread(new ParameterizedThreadStart(ThreadProc1));
            Thread thread2 = new Thread(new ParameterizedThreadStart(ThreadProc2));

            thread1.Start(null);
            thread2.Start(null);

            thread1.Join();
            thread2.Join();

            Console.WriteLine(m_count);
        }

        public static void ThreadProc1(object o)
        {
            for (int i = 0; i < 1000000; i++)
                lock (m_obj)
                {
                    ++m_count;
                }
        }

        public static void ThreadProc2(object o)
        {
            for (int i = 0; i < 1000000; i++)
                lock (m_obj)
                {
                    ++m_count;
                }
        }
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                55. Ders 27/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar mutex nesnelerini aynı prosesin thread'lerini senkronize etmek amacıyla kullandık. Mutex nesneleri 
    farklı proseslerin thread'lerini senkronize etmek için de kullanılabilmektedir. Aynı prosesin thread'leri, mutex nesnesi 
    ile senkronize edilirken mutex nesnesi global bir değişken olarak tanımlanıyordu. Her iki thread de aynı mutex nesnesini 
    kullanabiliyordu. Pekiyi mutex nesneleri farklı prosesin thread'leri arasında senkronizasyon amacıyla kullanılmak istendiğinde 
    iki proses de aynı mutex nesnesini nasıl görecektir? Eğer Windows sistemlerinde olduğu gibi mutex nesnelerinin UNIX/Linux 
    sistemlerinde isimleri olsaydı bu kullanım kolaylıkla sağlanabilirdi. Ancak UNIX/Linux sistemlerinde mutex nesnelerinin isimleri 
    yoktur. O halde tek yol mutex nesnesini paylaşılan bir bellek alanında yaratmaktır. Ancak POSIX standartlarına göre mutex 
    nesnelerinin paylaşılan bellek alanlarında yaratılması prosesler arası kullanım için yeterli değildir. Aynı zamanda mutex 
    nesnesinin prosesler arası paylaşılabilirliğini set etmek gerekir. Bu da mutex özellikleriyle yapılmaktadır. 
    pthread_mutexattr_setpshared fonksiyonu ile mutex paylaşımlı moda sokulabilmektedir:

    #include <pthread.h>

    int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);

    Fonksiyonun birinci parametresi mutex özellik nesnesinin adresini almaktadır. İkinci parametresi ise nesnenin prosesler arası 
    paylaşımını belirtmektedir. Bu parametre PTHREAD_PROCESS_SHARED geçilirse nesne prosesler arasında paylaşılmakta, 
    PTHREAD_PROCESS_PRIVATE geçilirse nesne prosesler arasında paylaşılmamaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönmektedir. Mutex özellik nesnesinin paylaşılabilirlik özelliği pthread_mutexattr_getpshared 
    fonksiyonu ile elde edilebilir:

    #include <pthread.h>

    int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);

    Fonksiyonun birinci parametresi mutex özellik nesnesinin adresini, ikinci parametresi paylaşılabilirlik durum bilgisinin yerleştirileceği 
    int türden nesnesinin adresini almaktadır. Tabii fonksiyon, bu nesneye PTHREAD_PROCESS_SHARED ya da PTHREAD_PROCESS_PRIVATE değerlerinden birini 
    yerleştirmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Mutex özellikleri belirtilmezse ya da pthread_mutexattr_setpshared fonksiyonu ile set edilmezse default durumda nesnenin paylaşım 
    özelliği PTHREAD_PROCESS_PRIVATE biçimindedir.

    Görüldüğü gibi mutex nesnelerinin prosesler arasındaki paylaşımı biraz zahmetlidir. Bu nedenle prosesler arasındaki senkronizasyonlar 
    için daha çok semaphore nesneleri tercih edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki proses ortak bir paylaşılan bellek alanını kullanmaktadır. Paylaşılan bellek alanının başında aşağıdaki 
    gibi bir yapı nesnesi bulunmaktadır:

    typedef struct tagSHARED_INFO {
        int count;
        /* other members... */
        pthread_mutex_t mutex;
    } SHARED_INFO;

    Örneğimizde iki proses de count değerini asenkron biçimde mutex koruması eşliğinde birer milyar kez artırmaktadır. 
    Bu örnekte paylaşılan bellek alanı "prog1.c" programı tarafından yaratılmış ve oradaki mutex nesnesine bu program tarafından 
    ilk değer verilmiştir. Dolayısıyla bizim önce "prog1" programını çalıştırmamız gerekmektedir. Mutex nesnesinin ve count nesnesinin
    paylaşılan bellek alanında bulunduğuna dikkat ediniz. Bu paylaşılan bellek alanı "prog1.c" programı tarafından shm_unlik fonksiyonu 
    ile yok edilmiştir. Tabii anımsanacağı gibi shm_unlink fonksiyonu başka bir proses paylaşılan bellek alanını kullanıyorsa o proses 
    paylaşılan bellek alanı nesnesini bırakana kadar zaten gerçek bir silme yapılmamaktadır. Pekiyi buradaki mutex nesnesi ne zaman 
    destroy edilmelidir? Normal olarak bir nesneyi hangi proses yaratmışsa onun yok etmesi uygun olur. Örneğimizde de mutex 
    nesnesini "prog1.c" programı yarattığına göre onun destroy edilmesi de aynı program tarafından yapılmalıdır. Ancak mutex nesnesini 
    destroy ederken diğer proseslerin artık bunu kullanmadığına emin olmak gerekir. Programların tasarımına göre buna emin olabildiğimiz
    noktalar söz konusu olabilir. Bu durumda biz de mutex nesnesimizi o noktalarda destroy edebiliriz. Ya da destroy işlemi için paylaşılan bellek 
    alanında ayrı bir sayaç da tutulabilir. Mutex'i destroy edecek program da bu sayaca bakabilir. Tabii bu sayacın kontrol edilmesi de blokeli 
    bir biçimde yapılabilir. Bunun için "durum değişkenleri (condition variable)" kullanılabilir. Biz aşağıdaki programda
    her iki prosesin de işini bitirdikten sonra beklemesini sağladık. Böylece mutex'i yine iki program da bittikten sonra "prog1.c" 
    programı destroy etmektedir.

    Programları aşağıdaki gibi derleyip farklı terminallerden çalıştırabilirsiniz:

    $ gcc -o prog1 prog1.c -lrt -lpthread
    $ gcc -o prog2 prog2.c -lrt -lpthread
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <sys/types.h>

#define SHM_NAME        "/shared_memory_for_mutex"

typedef struct tagSHARED_INFO {
    int count;
    /* other members... */
    pthread_mutex_t mutex;
} SHARED_INFO;

#endif

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    int result;

    if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
        exit_sys("ftruncate");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_mutexattr_setpshared", result);

    if ((result = pthread_mutex_init(&shminfo->mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    shminfo->count = 0;

    for (int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++shminfo->count;

        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    printf("Press ENTER to exit...\n");
    getchar();

    printf("%d\n", shminfo->count);

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    int result;

    if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
        exit_sys("shm_open");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    for (int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++shminfo->count;

        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    printf("Press ENTER to exit...\n");
    getchar();

    printf("%d\n", shminfo->count);

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri, UNIX/Linux sistemlerinde nispeten hızlı senkronizasyon nesneleridir. Linux sistemlerinde senkronizasyon 
    nesnelerinin hepsi zaten "futex (fast user space mutex)" denilen sistem fonksiyonu çağrılarak gerçekleştirilmektedir. 
    mutex fonksiyonları duruma göre hiç kernel mode'a geçmeden işlemini user mode'da yapabilmektedir. Şöyle ki: Biz mutex nesnesini 
    pthread_mutex_lock fonksiyonu ile kilitlemek isteyelim. Mutex nesnesi kendi içerisinde bayrak değişkenleri tutarak kilitleme 
    işlemini atomik bir biçimde yapmak isteyecektir. Atomikliği sağlamanın bir yolu "kernel mode'a geçerek CLI gibi makine komutuyla 
    kesme mekanizmasını kapatıp bayrak değişkenlerini set etmek" olabilir. Ancak kernel mode'a geçmenin maliyeti yüksektir. İşte 
    daha önceden de belirttiğimiz gibi yeni modern işlemcilere "compare and set" gibi atomik makine komutları eklenmiştir. Bu 
    makine komutları sayesinde bu tür flag değişkenleri hiç kernel mode'a geçmeden user mode'da atomik bir biçimde set edilebilmektedir.

    Ancak pthread_mutex_lock gibi bir fonksiyonun hiç kernel mode'a geçmeden işlem yapma olanağı da yoktur. Eğer mutex nesnesi kilitli 
    değilse onun kilitlenmesi user mode'da "compare and set" komutlarıyla yapılabilmektedir. Ancak ya mutex nesnesi zaten kilitliyse? 
    İşte bu durumda mecburen fonksiyon kernel mode'a geçerek thread'i bloke edecektir. Tabii aslında mutex kilitliyken bu fonksiyonlar
    hemen kernel mode'a geçip bloke oluşturmazlar. Çünkü pek çok senkronizasyon nesnesi çok kısa bir süre için kilitlenip açılmaktadır. 
    Bu nedenle pthread_mutex_lock, mutex'in kilitli olduğunu gördüğünde birden fazla işlemci ya da çekirdek varsa başka bir işlemci 
    ya da çekirdekteki mutex'i kilitleyen thread'in kısa süre içerisinde kilidi bırakacağını umarak meşgul bir döngüde sürekli 
    bayrak değişkenine bakıp bir süre beklemektedir. Bu tür meşgul döngülere senkronizasyon dünyasında "spin lock" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yaygın senkronizasyon nesnelerinden bir diğeri de "koşul değişkenleri (condition variables)" denilen nesnelerdir. 
    Bu nesneler UNIX/Linux sistemlerinde uzunca bir süredir bulunmaktadır. Windows sistemlerine de belli bir süreden sonra 
    sokulmuştur. Koşul değişken nesneleri tek başlarına kullanılmaz mutex nesneleriyle beraber kullanılmaktadır. Koşul değişkenlerinin 
    temel kullanım amacı "belli bir koşul sağlanana kadar" thread'in blokede bekletilmesidir. Bu koşul programcı tarafından 
    oluşturulur. Örneğin programcı global bir g_count değişkeni 0'dan büyük olana kadar thread'i bloke edip bekletmek isteyebilir. 
    Ya da örneğin programcı bir g_flag değişkeni 1 olana kadar thread'ini blokede bekletmek isteyebilir.

    Maalesef koşul değişkenleri anlaşılması en zor senkronizasyon nesnelerinden biridir. Bu nesnelerin düzgün kullanılabilmesi 
    için belli bir yöntemin izlenmesi gerekmektedir. Programcılar koşul değişkenlerinin kullanımına ilişkin kalıpları anlamakta 
    zorluk çekebilmektedir. Aynı zamanda programcıların kafası bu senkronizasyon nesnelerinin neden gerektiği konusunda da kafası 
    karışabilmektedir. Biz önce koşul değişkenlerinin tipik olarak nasıl kullanılması gerektiği üzerinde duracağız. Sonra konunun 
    ayrıntılarına gireceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenleri tipik olarak şu adımlardan geçilerek kullanılmaktadır:

    1) Programcı önce global düzeyde pthread_cond_t türünden bir koşul değişken nesnesi tanımlar. Koşul değişkenleri pthread_cond_t 
    türü ile temsil edilmiştir. Bu tür <pthread.h> ve <sys/types.h> içerisinde typedef edilmiştir. pthread_cond_t türü sistemlerde 
    tipik olarak bir yapı biçiminde typedef edilmektedir. Örneğin:

    pthread_cond_t g_cond;

    2) Koşul değişkenlerine tıpkı mutex nesnelerinde olduğu gibi statik ya da dinamik olarak ilk değer verilebilmektedir. Biz 
    koşul değişkenlerine statik düzeyde PTHREAD_COND_INITIALIZER makrosuyla ilk değer verebiliriz. Örneğin:

    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

    İlkdeğer verme işlemi dinamik olarak pthread_cond_init fonksiyonuyla da yapılabilmektedir:

    #include <pthread.h>

    int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

    Fonksiyonun birinci parametresi koşul değişken nesnesinin adresini, ikinci parametresi onun özellik bilgilerinin bulunduğu 
    özellik nesnesinin adresini almaktadır. Koşul değişkenlerinin de özellik bilgisi vardır. Koşul değişkenlerinin özellikleri 
    üzerinde daha ileride duracağız. İkinci parametre NULL geçilirse koşul değişkenleri default özelliklerle yaratılmış olur. 
    Aşağıdaki iki yaratım işlevsel olarak eşdeğer etkiyi sağlamaktadır:

    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;
    pthread_cond_init_(&g_cond, NULL);

    3) Koşul değişkenleri denilen senkronizasyon nesneleri tek başlarına kullanılmaz. Bir mutex eşliğinde kullanılmaktadır. Dolayısıyla
    bizim koşul değişkeninin yanı sıra onunla birlikte kullanacağımız bir mutex nesnesine de ihtiyacımız vardır. Örneğin:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

    4) Programcının bazı değişkenlerle ilişkili bir koşul oluşturması gerekmektedir. Örneğin koşul "g_flag değişkeninin 1 olması"
    biçiminde olabilir. Koşul "thread'in bloke olmaması için gerekli olan durumu" belirtmektedir. Bizim koşulumuz g_flag değişkeninin 1 
    olması ise bu durum "eğer g_flag değişkeni 1 değilse blokede beklemek istediğimiz" anlamına gelmektedir. Yani programcının 
    oluşturduğu koşul sağlanmadığı sürece programcı thread'ini blokede bekletmek istemektedir.

    5) Koşul sağlanmadığı sürece blokede beklemek için, koşul sağlanıyorsa bloke oluşturmadan akışın devam etmesi için tipik kalıp 
    aşağıdaki gibidir (kontroller yapılmamıştır):

    pthread_mutex_lock(&g_mutex);

    while (<koşul sağlanmadığı sürece>)
        pthread_cond_wait(&cond, &g_mutex);

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);

    Bu kalıpta koşul değişkenini bekleyen asıl fonksiyon pthread_cond_wait isimli fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

    Fonksiyonun birinci parametresi koşul değişken nesnesinin adresini, ikinci parametresi mutex nesnesinin adresini almaktadır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    6) Durum değişkenlerinde blokede bekleme işlemi pthread_cond_wait tarafından sağlanmaktadır. Bu fonksiyon doğrudan thread'i bloke
    etmektedir. Koşul değişkenini bekleyen bir thread'in uyandırılması iki fonksiyonla yapılabilir: pthread_cond_signal ve pthread_cond_broadcast. 
    Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_cond_broadcast(pthread_cond_t *cond);
    int pthread_cond_signal(pthread_cond_t *cond);

    Her iki fonksiyon da koşul değişkeni nesnesinin adresini almaktadır. Fonksiyonlar yine başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönmektedir. Bir thread, pthread_cond_wait fonksiyonunda blokede beklerken o thread'in blokesini 
    kaldırmak için başka bir thread'in pthread_cond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırması gerekmektedir. 
    pthread_cond_signal fonksiyonunun asıl amacı koşul değişkeninde blokede bekleyen herhangi tek bir thread'i uyandırmaktır. Ancak 
    işletim sistemlerinde kernel tasarımından dolayı bu mümkün olamayabilmektedir. Her ne kadar pthread_cond_signal aslında tek bir 
    thread'i uyandırmak için düşünülmüşse de işletim sisteminin tasarımından dolayı birden fazla thread'i de uyandırabilmektedir. 
    Bu nedenle POSIX standartlarında pthread_cond_signal fonksiyonunun "koşul değişkeninde bekleyen en az bir thread'i uyandıracağı" 
    söylenmiştir. Ancak pthread_cond_broadcast fonksiyonu, kesinlikle o koşul değişkeni ile blokede bekleyen tüm thread'leri 
    uyandırmaktadır. Genellikle algoritmalarda "koşul değişkenini bekleyen tek bir thread'in uyandırılması" istenir. Bu nedenle 
    pthread_cond_broadcast yerine çoğu kez pthread_cond_signal fonksiyonu kullanılır.

    pthread_cond_wait fonksiyonu koşul değişkeni nesnesinin yanı sıra bir de mutex nesnesini de bizden istemektedir. Fonksiyon 
    atomik bir biçimde (yani tek bir işlem gibi) uykuya dalarken (yani bloke olurken) aynı zamanda bu mutex nesnesinin sahipliğini 
    bırakmaktadır. Yani mutex nesnesinin sahipliği yukarıdaki kalıpta aslında pthread_cond_wait tarafından bırakılmaktadır. 
    Örneğin:

    pthread_mutex_lock(&g_mutex);                /* mutex'in sahipliği alındı */

    while (<koşul_sağlanmadığı_sürece>)
        pthread_cond_wait(&cond, &g_mutex);        /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);                /* mutex'in sahipliği bırakılıyor */

    Burada mutex nesnesinin sahipliği alınmış daha sonra koşul sağlanmıyorsa pthread_cond_wait fonksiyonuna girilmiştir. 
    İşte bu fonksiyon thread'i uykuya yatırırken aynı zamanda mutex'in sahipliğini de bırakmaktadır. Pekiyi koşul değişkeni
    pthread_cond_signal ya da pthread_cond_broadcast fonksiyonuyla uyandırıldığında ne olacaktır? İşte pthread_cond_wait fonksiyonu 
    ile koşul değişkeninin blokesi çözüldüğünde fonksiyon buradaki mutex'in sahipliğini de yeniden alarak fonksiyondan çıkmaya 
    çalışır. Koşul değişkeni nesnesi ile mutex nesnesi farklı nesnelerdir. Diğer bir thread, pthread_cond_signal ya da 
    pthread_cond_broadcast uyguladığında koşul değişkeninin blokesinden uyanılmaktadır. Ancak pthread_cond_wait fonksiyonu, 
    geri dönmeden önce mutex nesnesinin de sahipliğini almaya çalışır. pthread_cond_wait fonksiyonunun "sözde kodu (pseudo code)" 
    şöyle düşünülebilir:

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
    {
        1) Atomik biçimde mutex'in sahipliğini bırak (yani kilidini aç) ve uykuya dal.
        2) Şimdi uyandın. Çünkü başka bir thread, pthread_cond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırdı.
        3) Şimdi mutex sahipliğini pthread_mutex_lock ile almaya çalış.

        return <başarı durumu>
    }

    Burada önemli bir nokta şudur: pthread_cond_wait fonksiyonu koşul değişkeninden uyandığında mutex nesnesinin sahipliğini de
    almaya çalışmaktadır. İşte bu noktada, mutex nesnesi kilitliyse pthread_cond_wait geri dönmeyecektir. Ta ki mutex nesnesinin 
    sahipliği bırakılana kadar. Tabii bu durumda her ne kadar pthread_cond_wait geri dönmüyorsa da onun geri dönmesi için artık 
    pthread_cond_signal ya da pthread_cond_broadcast çağrılarına gerek yoktur. Yalnızca mutex kilidinin açılması gerekmektedir.

    Böylece yukarıdaki kalıpta mutex'in kilidi iki kez açılmamaktadır. Zaten pthread_cond_wait fonksiyonundan çıkıldığında mutex 
    yeniden kilitlendiği için kilitli olan mutex'in kilidi kritik kodun sonunda açılmaktadır.

    Pekiyi biz yukarıdaki kalıpta mutex'in sahipliğini almadan pthread_mutex_unlock fonksiyonunu çağırabilir miyiz? pthread_mutex_wait 
    fonksiyonu, mutex'in sahipliğini bırakacağına göre sahipliğin alınmış olması gerekmektedir. Anımsanacağı gibi sahipliği 
    alınmayan mutex'lerin unlock edilmesi duruma göre "undefined behavior" ya da işlemin başarısız olmasına yol açmaktadır.

    Yukarıdaki kalıpta diğer önemli bir nokta, pthread_cond_wait fonksiyonundan çıkıldığında koşul değişkenin bir döngü 
    içerisinde kontrol edilmesidir. Örneğin, biz g_flag değişkenin 1 olması koşulunu uygulayalım. Bu durumda buradaki döngü 
    şöyle olmalıdır:

    pthread_mutex_lock(&g_mutex);                /* mutex'in sahipliği alındı */

    while (g_flag != 1)
        pthread_cond_wait(&cond, &g_mutex);        /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);                /* mutex'in sahipliği bırakılıyor */

    En normal durum pthread_cond_signal ya da pthread_cond_broadcast işlemini yapan ve bizi koşul değişkenindeki uykudan uyandıran 
    thread'in bu işlemi uygulamadan önce koşulu olumlu hale getirmesidir (yani koşulu sağlanır hale getirmesidir). Örneğin:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_mutex);

    Burada koşulun sağlanma işleminin kritik kod içerisinde yapıldığını görüyorsunuz. Normal olarak koşul değişkeninin koşulun 
    sağlanması biçiminde ayarlanması işleminin ve pthread_cond_signal ya da pthread_cond_broadcast işleminin de aynı mutex'i 
    kullanarak kritik kod içerisinde yapılmasıdır. Çünkü programda başka bir thread bu değişkene aynı anda erişirse yine sorun 
    ortaya çıkabilir. Tabii böyle bir durum yoksa koşul kritik kod içerisinde set edilmeye de bilir. Özetle diğer bir thread 
    koşul değişkenindeki blokeyi pthread_cond_signal ya da pthread_cond_broadcast ile kaldırmadan önce koşul değişkenini koşul 
    sağlanacak biçimde set etmesi gerekir. Aksi takdirde koşul sağlanmadığı için pthread_cond_wait fonksiyonundan uyanan thread 
    döngü içerisinde yeniden uykuya dalacaktır.

    7) Kullanım bittikten sonra koşul değişkeni pthread_cond_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_cond_destroy(pthread_cond_t *cond);

    Fonksiyon koşul değişken nesnesinin adresini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine 
    geri döner.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                56. Ders 03/06/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kalıbı uygulayan bir örnek aşağıda verilmiştir. Bu örnekte Thread2 g_flag == 1 koşulu sağlanana kadar koşul 
    değişkeninde blokede beklemektedir. Thread1 ise g_flag == 1 koşulunu sağlayıp pthread_cond_signal fonksiyonu ile Thread2'yi 
    koşul değişkenindeki blokeden kurtarmaktadır. Programın çıktısı aşağıdaki gibi olacaktır:

    Thread2 locked mutex
    Thread2 is waiting at the condition variable...
    Press ENTER to continue...

    Thread1 continues...
    Thread2 unlocked mutex
    Thread2 continues...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

int g_flag = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    printf("Press ENTER to continue...\n");
    getchar();

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    g_flag = 1;

    if ((result = pthread_cond_signal(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_signal", result);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("Thread1 continues...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("Thread2 locked mutex\n");

    while (g_flag != 1) {
        printf("Thread2 is waiting at the condition variable...\n");
        if ((result = pthread_cond_wait(&g_cond, &g_mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result);
    }

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("Thread2 unlocked mutex\n");

    printf("Thread2 continues...\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenlerinin kullanımına ilişkin bazı ayrıntılar vardır. Şimdi o ayrıntılar üzerinde duralım:

    Yukarıda verdiğimiz kalıpta koşul değişkenini pthread_cond_wait ile beklerken bir döngü kullandık. Bu döngünün amacı nedir?

    while (<koşul sağlanmadığı sürece>)
        pthread_cond_wait(&g_cond);

    Yukarıda da belirttiğimiz gibi bir koşul değişkeni için pthread_cond_signal işlemi yapıldığında o koşul değişkeninde bekleyen 
    tek bir thread değil birden fazla thread uyandırılabilmektedir. Her ne kadar pthread_cond_signal tek bir thread'i koşul 
    değişkeninde uyandırmak istese de bu işletim sistemi tasarımından kaynaklanan nedenlerle mümkün olmayabilmektedir. 
    pthread_cond_signal istemeden birden fazla thread'i uyandırdığında bu thread'ler mutex'in sahipliğini almaya çalışırlar. 
    Bunlardan yalnızca biri mutex'in sahipliğini almayı başarır. Diğer thread'ler koşul değişkeninden uyanmıştır. Ancak bunlardan 
    biri mutex nesnesinin sahipliğini aldığı için mutex'te blokede beklerler. Aşağıdaki sözde kodu inceleyeniz:

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
    {
        1) Atomik biçimde mutex'in sahipliğini bırak (yani kilidini aç) ve uykuya dal.
        2) Şimdi uyandın. Çünkü başka bir thread, pthread_cond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırdı.
        3) Şimdi mutex sahipliğini pthread_mutex_lock ile almaya çalış.

        <Thread'lerden biri mutex'in sahipliğini alacak, yanlışlıkla uyanan diğerleri bu noktada bekleyecek>

        return <başarı durumu>
    }

    İşte bu durumda pthread_cond_signal fonksiyonunu uygulayan taraf koşul değişkeninden tek bir thread'in uyandırılıp kritik kodu 
    girmesini isterken yanlışlıkla birden fazla thread uyandırılmış olacaktır. O halde eğer programcı bunu istiyorsa uyanan thread 
    yeniden koşul değişkenini koşul sağlanmaz hale getirebilir ve bu döngü sayesinde diğer thread'ler yeniden uykuya dalabilir. 
    Örneğin:

    pthread_mutex_lock(&g_mutex);                /* mutex'in sahipliği alındı */

    while (g_flag != 1)
        pthread_cond_wait(&cond, &g_mutex);        /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    g_flag = 0;                                    /* Dikkat! koşul yeniden sağlanmaz hale getiriliyor */

    pthread_mutex_unlock(&g_mutex);                /* mutex'in sahipliği bırakılıyor */

    <Artık bu noktada koşul değişkeninden yanlışlıkla uyanmış olan thread'ler koşul sağlanmadığı için yeniden uykuya dalacaklar>

    Tabii burada "koşul yeniden sağlanmaz hale getirildiğine göre diğer uykuya dalan thread'lerin akıbeti" merak edilebilmektedir. 
    İşte thread'ler yeniden koşul sağlandığında teker teker uyandırılacaktır. Yani koşul değişkeninde bekleyen thread'ler de 
    aslında aynı amacı gerçekleştirmek için beklemektedir. Amaç onları teker teker kritik kod içerisinde oradan çıkarmaktır.

    Döngü oluşturulmasının ikinci nedeni "spurious wakeup" denilen durumdur. Bazı sistemlerde hiç pthread_cond_signal ya da 
    pthread_cond_broadcast yapılmasa bile thread'ler işletim sisteminin tasarımından kaynaklanan nedenlerle koşul değişkeninden 
    uyandırılabilmektedir. Bu durumda koşul sağlanmadığına göre yanlışlıkla uyanan ("spurious" Türkçe "yapay, sahte, yanlış"
    anlamlarına gelmektedir) thread'lerin bu döngü sayesinde yeniden uyutulması gerekmektedir.

    pthread_cond_signal işlemi kaydedilen bir işlem değildir. Yani biz pthread_cond_signal yaptığımızda eğer koşul değişkeninde bekleyen 
    hiçbir thread yoksa bu işlem boşa çıkmış olur. Başka bir deyişle biz pthread_cond_signal ya da pthread_cond_broadcast yaptıktan sonra 
    bir thread pthread_cond_wait fonksiyonuna girerse bloke olur. pthread_cond_signal ya da pthread_cond_broadcast işlemi sadece 
    o anda koşul değişkeninde bekleyen thread'ler için bir uyandırma yapmaktadır.

    Şimdi de pthread_cond_signal fonksiyonunun mutex kilidi içerisinde uygulanması üzerinde duralım. Aşağıdaki kodu inceleyiniz:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;

    pthread_cond_signal(&g_cond);
    ...
    pthread_mutex_unlock(&g_mutex);

    Burada biz pthread_cond_signal işleminde koşul değişkeninde bekleyen thread'i uyandırmış olmaktayız. Ancak pthread_cond_wait koşul 
    değişkeninden uyanmakla birlikte mutex'in sahipliğini almak için bloke olur. Tabii biz mutex'in sahipliğini bırakınca o thread mutex'in 
    sahipliğini alıp pthread_cond_wait fonksiyonundan çıkacaktır. Aslında pthread_cond_signal ya da pthread_cond_broadcast fonksiyonlarını 
    mutex'in sahipliğini bıraktıktan sonra da uygulayabiliriz: Örneğin:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_mutex_unlock(&g_mutex);
    pthread_cond_signal(&g_cond);

    Ancak burada duruma göre aşağıdaki gibi bir senkronizasyon sorunu ortaya çıkabilir:

    Bekleyen Thread                                      Diğer Thread
    ---------------                                     ------------
                                                        pthread_mutex_lock(&g_mutex);
                                                        g_flag = 1;
                                                        pthread_mutex_unlock(&g_mutex);
    pthread_mutex_lock(&g_mutex);

    while (g_flag != 1)
                                                        phread_cond_signal(&g_cond);
        pthread_cond_wait(&g_cond, &g_mutex)

    pthread_mutex_unlock(&g_mutex);

    Burada diğer thread'in uyguladığı pthread_cond_signal boşa düşebilecektir. Koşul değişkeninde bekleme döngüsünün oluşturulmasının 
    bir nedeni de şudur: Birden fazla thread koşulu sağlayıp pthread_cond_signal uygulamış olsun. Örneğin:

    Thread'lerden Biri
    ------------------
    pthread_mutex_lock(&g_mutex);
    <koşulun sağlanıyor>
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_mutex);

    Diğer Bir Thread
    ----------------
    pthread_mutex_lock(&g_mutex);
    <koşulun saplanıyor>
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_mutex);

    Burada iki ayrı thread bir üretici-tüketici probleminde değer üretip tüketiciyi uyandırmak istesin. Burada koşul değişkeninde 
    bekleyen birden fazla tüketici thread koşul değişkeninden uyandırılabilecektir. Ancak bunların yalnızca bir tanesi mutex'in 
    sahipliğini alacaktır. İşte mutex'in sahipliğini alan thread kritik kodu girip tüm tüketimi yapıp kritik koddan çıktığında 
    eğer bir döngü olmazsa artık diğer thread kritik kodu girecektir. Üretici-tüketici problemini izleyen paragraflarda ele 
    alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici Problemi (Producer-Consumer Problem) gerçek hayatta en fazla karşılaşılan senkronizasyon problemlerinden 
    biridir. Problemin çeşitli varyasyonları vardır. Üretici-Tüketici problemi aynı prosesin thread'leri arasında uygulanabileceği 
    gibi farklı proseslerin thread'leri arasında da uygulanabilmektedir. Üretici-Tüketici probleminde en az bir üretici thread 
    ve en az bir tüketici thread vardır. Biz bir üretici bir de tüketici thread'in olduğunu varsayalım. Üretici thread belli 
    bir işlemden sonra bir değer üretir. Ancak o değerin işlenmesini tüketici thread'e havale eder. Bunun için ortak bir 
    paylaşılan alan oluşturulur. Üretici thread elde ettiği değeri paylaşılan alana yerleştirir. Tüketici thread de onu oradan 
    alarak kullanır. Yani üretici thread'in görevi değer elde edip onu bir paylaşılan bellek alanına yazmaktır. Tüketici thread'in 
    görevi de onu paylaşılan bellek alanından alıp işlemektir. Tabii eğer problem aynı prosesin thread'leri arasında uygulanacaksa 
    bu durumda paylaşılan alan global bir nesne olabilir. Ancak problem farklı proseslerin thread'leri arasında uygulanacaksa 
    bu durumda paylaşılan alan gerçekten "paylaşılan bellek alanı (shared memory)" olarak oluşturulmalıdır. Problemdeki ana 
    unsur üretici thread'in ve tüketici thread'in asenkron çalışması nedeniyle koordine edilmesi gerekliliğidir. Eğer üretici 
    thread tüketici thread'ten daha hızlı davranırsa daha tüketici thread önceki değeri paylaşılan bellek alanından almadan 
    üretici thread yeni bir değeri oraya yerleştirerek önceki değeri ezebilir. Benzer biçimde eğer tüketici thread, üretici 
    thread'ten daha hızlı davranırsa bu durumda önceki değeri yeniden alıp işlemeye çalışabilir. O halde bu problemde "tüketici 
    thread'in önceki değeri almadan üretici thread'in yeni bir değeri paylaşılan alana yerleştirmemesi" gerekir. Benzer biçimde 
    tüketici thread de "üretici thread yeni bir değeri paylaşılan alana yerleştirmeden aynı değeri ikinci kez" almamalıdır. Yani 
    iki thread'in birbirlerini beklemesi gerekmektedir.

    Bu problemde neden tek bir thread'in hem değeri elde edip hem de onu işlemek yerine iki ayrı thread'in bu işi yapmaya çalıştığını 
    merak edebilirsiniz. Bunun amacı hız kazancı sağlamaktır. Bu sayede üretici thread üretim yaparken tüketici thread de tüketim 
    yapabilmektedir. Halbuki bu işlemler seri bir biçimde yapılırsa üretim ve tüketim faaliyetlerinin eş zamanlı yapılması mümkün 
    olmaz. Tabii birden fazla thread de seri olarak üretim ve tüketim faaliyetlerinde bulunabilir. Ancak çoğu kez üretim faaliyetinin 
    de koordineli bir biçimde yapılması gerekmektedir. Yani bu çözüm de gerekli hızlanmayı sağlamayabilmektedir.

    Tek bir işlemcinin ya da çekirdeğin olduğu durumda üretici-tüketici problemi bir hızlanma sağlayabilir mi? Burada da yine 
    prosesin toplam CPU zamanı birden fazla thread'le fazlalaştırılabilmektedir. Yani üretici thread, üretim işlemi bittiğinde 
    kesildiğinde hemen tüketici thread daha hızlı devreye girebilmektedir. Ancak şüphesiz çok işlemcili ya da çekirdekli sistemlerde 
    performansın daha fazla artması beklenir.

    Üretici-tüketici probleminin değişik biçimleri vardır. Örneğin ortadaki paylaşılan bellek alanı tek bir nesneyi tutacak biçimde 
    değil birden fazla nesneyi tutacak biçimde bir "FIFO kuyruk sistemi olarak" oluşturulabilir. Paylaşılan bir kuyruk sistemi 
    olursa üretici ve tüketicinin birbirlerini bekleme olasılığı azaltılmış olur. Artık üretici thread kuyruk tam dolmuşken,
    tüketici thread de kuyruk tam boşken bloke olacaktır.

    Üretici-tüketici probleminde, üretici ve tüketici thread'ler birden fazla da olabilmektedir. Yani çok üretici ve çok tüketici 
    paralel biçimde çalıştırılabilmektedir. Böylece tek işlemcili ya da çekirdekli sistemlerde bile performans artırılabilmektedir.

    Üretici tüketici probleminin gerçek hayat uygulamalarına çok yerde kaşılaşılmaktadır. Örneğin client-server sistemlerde 
    client'lar üretici durumdadır, server'lar da tüketici durumdadır. Burada birden fazla client thread üretim yapmakta ve 
    birden fazla server thread de tüketim yapmaktadır. Örneğin bir satranç programında üretici thread "geçerli hamleleri" elde 
    ederken tüketici thread bu geçerli hamleleri analiz ediyor olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üretici-tüketici problemi simüle edilmeye çalışılmıştır. Üretici thread 0'dan 99'a kadar sayıları rastgele
    beklemelerle bir global değişkene yerleştirmekte tüketici thread'de rastgele beklemelerle o değeri bu global değişkenden alıp
    ekrana yazdırmaktadır. Buradaki usleep fonksiyonu "mikrosaniye" mertebesinde bekleme yapmaktadır. srand ve rand yerine rand_r 
    isimli onların "thread-safe" versiyonu kullanılmıştır. Buradaki örnek bir çalıştırmadan elde edilen çıktı şöyledir:

    0 1 1 3 3 5 7 9 11 13 14 14 16 18 20 20 22 22 23 24 27 28 29 31 32 33 34 34 36 37 37 38 38 39 41 43 43 43 44 45 45 48 
    49 49 51 51 51 52 54 54 54 55 57 60 60 60 61 61 61 61 62 62 64 66 66 68 69 70 72 73 75 76 76 79 81 81 81 82 83 84 85 
    85 87 87 90 92 93 94 95 98 98 98 99

    Görüldüğü gibi tüketici thread bazı değerleri kaçırmış bazı değerleri de birden fazla kez almıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);
        g_shared = val;
        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        val = g_shared;
        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici problemi tipik olarak semaphore'lar ve koşul değişkenleri kullanılarak çözülmektedir. Semaphore'lar 
    daha basit bir kullanıma sahiptir. Biz burada üretici-tüketici probleminin koşul değişkenleriyle çözümü üzerinde duracağız. 
    Semaphore'lar izleyen paragraflarda ele alınacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici probleminin koşul değişkenleriyle çözümünde, üretici ve tüketici için iki ayrı koşul değişkeni oluşturulur. 
    Koşul bir flag değişkeni ile ifade edilebilir. Çözümdeki temel fikir üreticinin-tüketiciyi beklemekten kurtarması, tüketicinin de 
    üreticiyi beklemekten kurtarması biçimindedir. Adeta bir tahterevalli gibi işlemler yürütülmektedir. Problemin çözümünde kullanılan 
    ortak değişkenler şöyledir:

    pthread mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t g_cond_producer = PTHREAD_COND_INITIALIZER;
    pthread_cond_t g_cond_consumer = PTHREAD_COND_INITIALIZER;

    int g_flag = 0;

    Üretici thread'in sembolik kodu şöyledir:

    for (;;) {
        <değeri elde et>

        pthread_mutex_lock(&g_mutex);

        while (g_flag == 1)
            pthread_cond_wait(&g_producer, &g_mutex);

        <değeri paylaşılan alana yerleştir>

        g_flag = 1;

        pthread_cond_signal(&g_cond_consumer);

        pthread_mutex_unlock(&g_mutex);
    }

    Üretici thread'in sembolik kodu şöyledir:

    for (;;) {
        pthread_mutex_lock(&g_mutex);

        while (g_flag == 0)
            pthread_cond_wait(&g_consumer, &g_mutex);

        <paylaşılan bellek alanından bilgiyi alacak>

        g_flag = 0;

        pthread_cond_signal(&g_cond_producer);

        pthread_mutex_unlock(&g_mutex);
    }

    Burada kodu dikkatlice inceleyiniz. g_flag değişkeninin başlangıçtaki değeri 0'dır. Bu durumda başlangıçta tüketici thread 
    bekleyecek ancak üretici thread beklemeden değeri üretip paylaşılan alana yerleştirecektir. Tüketici çok yavaş çalışsa bile 
    üretici thread değeri paylaşılan bellek alanına yerleştirdikten sonra artık g_flag değişkenini 1 yaptığı için pthread_cond_wait 
    fonksiyonunda bekleyecektir. Bu sırada tüketici thread paylaşılan alandan bilgiyi alıp g_flag değişkenini 0 yaptıktan sonra 
    üreticiyi blokeden kurtaracaktır. Görüldüğü gibi üretici-tüketiciyi, tüketici de üreticiyi beklemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                57. Ders 04/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin koşul değişkenleriyle çözümüne bir örnek verilmiştir. Burada ortadaki paylaşılan
    alan yine tek bir int nesneden oluşmaktadır. Bu tür durumlarda kritik kodun mümkün olduğu kadar kısa tutulması iyi bir 
    tekniktir. Yani biz kodda yalnızca gerekli kısımları kritik kod içerisine almalıyız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;
pthread_cond_t g_cond_producer;
pthread_cond_t g_cond_consumer;
int g_flag = 0;

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_cond_init(&g_cond_producer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&g_cond_consumer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_cond_destroy(&g_cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (g_flag == 1)
            if ((result = pthread_cond_wait(&g_cond_producer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        g_shared = val;
        g_flag = 1;

        if ((result = pthread_cond_signal(&g_cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 456;

    for (;;) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (g_flag == 0)
            if ((result = pthread_cond_wait(&g_cond_consumer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        val = g_shared;
        g_flag = 0;

        if ((result = pthread_cond_signal(&g_cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici probleminde paylaşılan alan bir kuyruk sistemi olursa üreticinin tüketiciyi, tüketicinin de üreticiyi
    bekleme olasılığı düşürülmüş olur. Çünkü bu durumda üretici yalnızca kuyruk tam doluyken tüketici de kuyruk tam boşken 
    bekleyecektir. Böyle bir kuyruk gerçekleştirimi çeşitli biçimlerde yapılabilir.

    En çok kullanılan kuyruk gerçekleştirimlerinden biri "döngüsel kuyruk sistemi (circular queue)" de denilen gerçekleştirimdir. 
    Bu gerçekleştirimde bir dizi oluşturulur. head ve tail olmak üzere iki indeks ya da gösterici kuyruğun başını ve sonunu tutar. 
    Kuyruğa bilgi yerleştiririlirken tail göstericisinin gösterdiği yere yerleştirme yapılır ve tail göstericisi bir artırılır. 
    Kuyruktan eleman alınırken eleman head göstericisinin gösterdiği yerden alınır ve head göstericisi bir artırılır. Tabii head 
    ve tail göstericileri dizinin sonuna geldiğinde yeniden dizinin başına çekilir (zaten "döngüsel" terimi bu nedenle kullanılmaktadır). 
    Kuyrukta o anda kaç elemanının bulunduğu ayrı bir sayaçla tutulabilir. Burada önemli noktalardan biri head ve tail göstericilerinin 
    aynı yeri göstermesi durumunda kuyruğun tam boş ya da tam dolu olabileceğidir. Bunun tespiti sayaç değişkenine bakılarak 
    yapılabilir.

    Üretici-tüketici probleminin kuyruklu çözümünde üreticinin bekleme koşulu şöyle oluşturulabilir (kontroller yapılmamıştır):

    while (g_count == QUEUE_SIZE)
        pthread_cond_wait(&g_cond_producer, &g_mutex);

    Bu koşul üreticinin yalnızca kuyruktaki eleman sayısı kuyruk uzunluğuna eşit olduğunda bloke olacağı anlamına gelmektedir. 
    Yani kuyruk tam doluysa üretici bloke olacaktır. Tüketicinin bekleme koşulu da şöyle oluşturulabilir:

    while (g_count == 0)
        pthread_cond_wait(&g_cond_consumer, &g_mutex);

    Burada da tüketici yalnızca kuyruk tam boş ise bloke olacaktır.

    Aşağıda üretici-tüketici probleminin kuyruklu versiyonuna bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

#define QUEUE_SIZE        10

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;
pthread_cond_t g_cond_producer;
pthread_cond_t g_cond_consumer;

int g_queue[QUEUE_SIZE];
int g_head = 0;
int g_tail = 0;
int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_cond_init(&g_cond_producer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&g_cond_consumer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_cond_destroy(&g_cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (g_count == QUEUE_SIZE)
            if ((result = pthread_cond_wait(&g_cond_producer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        g_queue[g_tail++] = val;
        g_tail %= QUEUE_SIZE;
        ++g_count;

        if ((result = pthread_cond_signal(&g_cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 456;

    for (;;) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (g_count == 0)
            if ((result = pthread_cond_wait(&g_cond_consumer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        val = g_queue[g_head++];
        g_head %= QUEUE_SIZE;
        --g_count;

        if ((result = pthread_cond_signal(&g_cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenlerinin zaman aşımlı bekleme yapan pthread_cond_timedwait isimli bir biçimi de vardır. Bu fonksiyon belli bir 
    zaman aşımı dolduğunda koşul değişkenini otomatik olarak açmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

    Burada yine timespec yapısı ile belirtilen zaman aşımı değeri göreli değil mutlaktır. Fonksiyon yine atomik bir biçimde
    mutex'in sahipliğini bırakır ve çıkışta yine mutex'in sahipliğini almaya çalışır. Ancak koşul değişkeninde bekleme en kötü 
    olasılıkla zaman aşımı dolduğunda sonlanmaktadır. Fonksiyon başarı durumunda 0, başarısızlık durumunda errno değerine geri 
    döner. Yine fonksiyon eğer zaman aşımı dolayısıyla sonlanmışsa ETIMEDOUT değeri ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenleri de özellik (attribute) parametresine sahiptir. Ancak koşul değişkenlerinin set edilebilecek yalnızca 
    iki özelliği vardır. Koşul değişkenlerine özellik iliştirmek diğer nesnelerde olduğu gibi yapılmaktadır. Programcı önce
    pthread_condattr_t türünden bir nesne tanımlar. Sonra bu nesneye pthread_condattr_init fonksiyonuyla ilk değer verir. 
    Sonra pthread_condattr_setxxx fonksiyonlarıyla özellikleri nesne içerisine set eder. Oluşturduğu bu özellik nesnesini de
    pthread_cond_init fonksiyonunda kullanır. Yine özellik nesnesinin pthread_cond_init fonksiyonundan sonra korunmasına gerek 
    yoktur. Özellik nesnesi, pthread_condattr_destroy fonksiyonu ile boşaltılabilir. Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_condattr_destroy(pthread_condattr_t *attr);
    int pthread_condattr_init(pthread_condattr_t *attr);

    Koşul değişkenlerine iki özellik set edip bunları alabiliriz. Birincisi, koşul değişkeninin prosesler arası kullanımını 
    sağlayan özelliktir. Bu özellik pthread_condattr_setpshared fonksiyonu ile set edilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);
    int pthread_condattr_getpshared(const pthread_condattr_t *attr, int * pshared);

    Buradaki pshared parametresi PTHREAD_PROCESS_SHARED ya da PTHREAD_PROCESS_PRIVATE değerinde olabilir. pthread_condattr_getpshared 
    fonksiyonu, bu değeri özellik nesnesinden alıp parametresiyle belirtilen nesneye yerleştirmektedir. Böyle bir set işlemi 
    yapılmazsa default durum PTHREAD_PROCESS_PRIVATE biçimindedir.

    Biz pthread_cond_timedwait fonksiyonunda zaman aşımında kullanılacak saatin cinsini de belirleyebiliriz. Bu işlemler için 
    pthread_condattr_setclock ve pthread_condattr_getclock fonksiyonları kullanılmaktadır:

    #include <pthread.h>

    int pthread_condattr_getclock(const pthread_condattr_t *attr, clockid_t *clock_id);
    int pthread_condattr_setclock(pthread_condattr_t *attr, clockid_t clock_id);

    Fonksiyon, kullanılacak clock nesnesinin id'sini parametre olarak almaktadır. Default olarak "system clock" kullanılmaktadır.

    Tabii koşul değişkenlerinin prosesler arası kullanımı için yine onların paylaşılan bellek alanında oluşturulması gerekmektedir. 
    Tabii bu durumda mutex nesnesinin de paylaşılan bellek alanında oluşturulması gerekecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin prosesler arasında oluşturulmasına ilişkin bir örnek verilmiştir. Bu örnekte tüm koşul 
    değişkenleri, mutex nesnesi ve kuyruk bilgileri paylaşılan bellek alanında oluşturulmuştur. Önce "producer" programı
    çalıştırılmalıdır. Tüm bu nesneleri producer yaratıp kendisi silmektedir. Derleme işlemlerini şöyle yapabilirsiniz:

    $ gcc -Wall -o producer producer.c -lpthread -lrt
    $ gcc -Wall -o consumer consumer.c -lpthread -lrt
---------------------------------------------------------------------------------------------------------------------------*/
/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <sys/types.h>

#define SHM_NAME        "/producer-consumer"
#define QUEUE_SIZE        10

typedef struct tagSHARED_INFO {
    pthread_cond_t cond_producer;
    pthread_cond_t cond_consumer;
    pthread_mutex_t mutex;
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int count;
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    pthread_condattr_t cattr;
    int result;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
        exit_sys("ftruncate");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_mutexattr_setpshared", result);

    if ((result = pthread_mutex_init(&shminfo->mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_condattr_init(&cattr)) != 0)
        exit_sys_errno("pthread_condattr_init", result);

    if ((result = pthread_condattr_setpshared(&cattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_condattrattr_setpshared", result);

    if ((result = pthread_cond_init(&shminfo->cond_producer, &cattr)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&shminfo->cond_consumer, &cattr)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_condattr_destroy(&cattr)) != 0)
        exit_sys_errno("pthread_condattr_destroy", result);

    shminfo->count = 0;
    shminfo->head = 0;
    shminfo->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (shminfo->count == QUEUE_SIZE)
            if ((result = pthread_cond_wait(&shminfo->cond_producer, &shminfo->mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;
        ++shminfo->count;

        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        if ((result = pthread_cond_signal(&shminfo->cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        if (val == 99)
            break;
        ++val;
    }

    if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

    while (shminfo->count != 0 )
        if ((result = pthread_cond_wait(&shminfo->cond_producer, &shminfo->mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result);

    if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    if ((result = pthread_cond_destroy(&shminfo->cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_cond_destroy(&shminfo->cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_mutex_destroy(&shminfo->mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    int result;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
        exit_sys("shm_open");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    for (;;) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        while (shminfo->count == 0)
            if ((result = pthread_cond_wait(&shminfo->cond_consumer, &shminfo->mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result);

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;
        --shminfo->count;

        printf("%d ", val);
        fflush(stdout);

        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);

        if ((result = pthread_cond_signal(&shminfo->cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

    if ((result = pthread_cond_signal(&shminfo->cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result);

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Semaphore'lar (semaphores) en çok kullanılan senkronizasyon nesnelerindendir. Pek çok işletim sisteminde semaphore nesneleri 
    benzer işlevselliklerle bulunmaktadır. UNIX/Linux sistemlerinde semaphore'lar IPC konusuyla ilişkilendirilmiştir. Bu nedenle 
    tıpkı paylaşılan bellek alanlarında ve mesaj kuyruklarında olduğu gibi semaphore'lar için de iki ayrı arayüz fonksiyon grubu
    bulunmaktadır. Ancak Sistem 5 semaphore'ları maalesef oldukça karışık ve kötü bir arayüzle tasarlanmıştır. POSIX semaphore'larında
    bu tasarım düzeltilmiştir. Biz kursumuzda IPC nesnelerini, önce Sistem 5 sonra POSIX olacak biçimde açıklamıştık. Ancak burada 
    bunun tersini yapacağız. Yani önce POSIX semaphore'larını açıklayıp sonra Sistem 5 semaphore'ları üzerinde duracağız. 
    Uygulamada özel bir gerekçe yoksa POSIX semaphore'ları tercih edilmelidir.

    Semaphore'lar "sayaçlı" senkronizasyon nesneleridir. Semaphore sözcüğü "trafikteki dur-geç lambalarından" gelmektedir. 
    (Bu sözcüğü "anafor" sözcüğü ile karıştırmayınız.) Semaphore'lar bir kritik kodu en fazla n tane akışın girmesini sağlamak 
    için düşünülmüştür. Örneğin biz bir kritik kodu en fazla 3 thread'in girmesini ancak daha fazla thread'in girmemesini isteyebiliriz. 
    Bu durumda üç thread kritik kodu girdikten sonra diğer thread'ler kritik kodu giremeyecek ve blokede bekleyecektir. Kritik 
    kodu girmiş olan bir thread kritik koddan çıktığında, bekleyen bir thread kritik kodu girebilecektir. Bu örnekte önemli olan
    üçten daha fazla thread'in aynı anda kritik kodu girmemesinin bloke yoluyla sağlanmasıdır. Kritik kodu birden fazla thread'in
    girmesi kişilere anlamsız gelebilmektedir. Çünkü iki thread bile ortak kaynağı bozabilir. O halde kritik kodu n tane thread'in 
    girmesinin ne anlamı olabilir? İşte bunun en önemli kullanım gerekçesi "kaynak paylaşımının" sağlanmasıdır. Örneğin elimizde 
    üç tane makine olsun. Ancak 10 tane thread bu makineleri kullanmak istesin. Bizim bu üç makineyi yalnızca üç thread'e tahsis 
    etmemiz gerekir. Makineyi kullanmak isteyen diğer thread'ler bu makinelerden biri boşaltılana kadar CPU zamanı harcamadan blokede 
    bekletilmelidir. İşte burada tipik bir semaphore kullanımı söz konusudur. Örneğin:

    <kritik kodun başı>
    ...
    ...
    ...        <KRİTİK KODDA MAKİNE ATAMASI YAPILIYOR>
    ...
    ...
    <kritik kodun sonu>

    Kritik kodu en fazla kaç akışın girebileceği "semaphore sayacı" ile ilgilidir. Eğer semaphore sayacı 1'de tutulursa kritik kodu 
    en fazla bir akış girebilir. Bu tür semaphore'lara "binary semaphore" denilmektedir. Binary semaphore'lar adeta mutex nesneleri 
    gibi bir etkiye sahiptir. Yani bu anlamda binary semaphore'lar bir mutex alternatifi olarak da kullanılabilirler. Ancak mutex
    nesnelerinin thread temelinde sahipliği vardır. Yani mutex'in sahipliğini hangi thread almışsa onun bırakması gerekir. Halbuki 
    semaphore nesnelerinde böyle bir zorunluluk yoktur. Bu nedenden dolayı bazı kesimler tarafından semaphore nesneleri hataya daha 
    açık bir nesneler olarak değerlendirilebimektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            58. Ders 10/06/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    POSIX semaphore nesneleri isimli ve isimsiz olarak yaratılabilmektedir. İsimli semaphore nesneleri prosesler arası kullanım
    için daha uygundur. İsimsiz semaphore nesneleri -her ne kadar prosesler arasında da kullanılabiliyorsa da- özellikle prosesin 
    thread'leri arasındaki senkronizasyonda tercih edilmektedir.

    İsimsiz POSIX semaphore nesnelerinin kullanımı şöyledir:

    1) Semaphore nesneleri sem_t türü ile temsil edilmiştir. POSIX standartlarına göre sem_t herhangi bir tür olarak typedef 
    edilebilmektedir. UNIX türevi sistemlerde tipik olarak sem_t bir yapı biçiminde typedef edilmektedir. Programcı bu türden global 
    bir nesne tanımlar ve ona sem_init fonksiyonuyla ilk değer verir. sem_init fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_init(sem_t *sem, int pshared, unsigned value);

    Fonksiyonun birinci parametresi sem_t türünden nesnesinin adresini alır. İkinci parametre semaphore nesnesinin prosesler arasında 
    paylaşılıp paylaşılmayacağını belirtir. Burada 0 değeri nesnenin prosesler arasında paylaşılmayacağını, sıfır dışı değer ise 
    nesnenin prosesler arasında paylaşılacağını belirtmektedir. Üçüncü parametre başlangıçtaki semaphore sayacının değerini belirtir. 
    Yani bu değer kritik kodu en fazlası kaç akışın girebileceğini belirtmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. (Thread fonksiyonlarının bizzat başarısızlık 
    durumunda errno değeriyle geri döndüğünü anımsayınız. Halbuki POSIX semaphore fonksiyonları doğrudan errno değişkenini set 
    etmektedir.)

    Örneğin:

    sem_t g_sem;
    ...

    if (sem_init(&g_sem, 0, 3) == -1)
        exit_sys("sem_init");

    2) Kritik kod aşağıdaki gibi oluşturulabilir (kontroller yapılmamıştır):

    sem_wait(&g_sem);
    ...
    ...        <KRİTİK KOD>
    ...
    sem_post(&g_sem);

    sem_wait fonksiyonu semaphore sayacına bakar. Semaphore sayacı 0'dan büyükse bloke oluşturmaz. Böylece thread kritik kodu 
    girer. Ancak sem_wait fonksiyonu semaphore sayacı 0'dan büyükse atomik bir biçimde semaphore sayacını 1 eksiltmektedir. Örneğin 
    başlangıçtaki semaphore sayacı 3 olsun. Bu durumda thread'lerden biri sem_wait fonksiyonundan geçtiğinde semaphore sayacı 2 olur. 
    Diğer bir thread de geçtiğinde semaphore sayacı 1 olacaktır. Nihayet bir thread daha sem_wait fonksiyonundan geçtiğinde semaphore
    sayacı 0 olur. Artık kritik kodda 3 tane thread vardır. Başka thread'ler sem_wait fonksiyonuna geldiğinde semaphore sayacı 0 olduğu 
    için bloke olurlar ve kritik kodu giremezler. İşte sem_post fonksiyonu da semaphore sayacını 1 artırmaktadır. Böylece kritik koddan 
    çıkıldığında semaphore sayacı 1 artırılmış olur. sem_wait fonksiyonunda bekleyen thread'lerden biri artık semaphore sayacı 0'dan 
    büyük olduğu için kritik kodu girer. Görüldüğü gibi kritik kodda belli bir anda en fazla 3 thread bulunabilmektedir. Yukarıda da
    belirttiğimiz gibi aslında semaphore'lar belli sayıda kaynağın thread'lere paylaştırılması için kullanılmaktadır. Örneğin elimizde 
    3 tane makine olabilir. Biz bu üç makineyi 10 thread'in kullanmasını isteyebiliriz. Ancak makine atamadığımız thread'lerin 
    CPU zamanı harcamadan bloke durumda bekletilmesi gerekmektedir. O halde biz her kritik kodu giren thread'e bir makine atarız. 
    Tıpkı mutex nesnelerinde olduğu gibi sem_wait fonksiyonunda birden fazla thread'in beklemesi durumunda bu thread'lerin hangisinin 
    kritik kodu gireceği konusunda bir garanti verilmemektedir. İşletim sistemleri belirli koşullarda adil bir sistem uygulamaya 
    çalışsa da bunun bir garantisini vermemektedir.

    Böylece üç makineyi, 10 thread'in etkin bir biçimde kullanmasını sağlarız. sem_wait ve sem_post fonksiyonlarının prototipleri 
    şöyledir:

    #include <semaphore.h>

    int sem_wait(sem_t *sem);
    int sem_post(sem_t *sem);

    Fonksiyonlar semaphore nesnesinin adresini parametre olarak alırlar. Başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine geri dönerler ve errno değişkeni uygun biçimde set edilir.

    sem_wait fonksiyonunun ayrıca bir de sem_timedwait isimli zaman aşımlı bir biçimi de vardır. Bu zaman aşımlı biçim eğer 
    semaphore'da bloke olunmuşsa zaman aşımı dolduğunda blokeyi çözmektedir. sem_timedwait fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_timedwait(sem_t *sem, const struct timespec *abstime);

    Ancak buradaki zaman aşımı yine göreli değil mutlak zamanı belirtmektedir. Fonksiyon eğer zaman aşımından dolayı başarısız
    olursa -1 değerine geri döner ve errno değişkeni ETIMEDOUT değeri ile set edilmektedir.

    3) Semaphore kullanımı bittikten sonra semaphore nesnesi sem_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi 
    şöyledir:

    #include <semaphore.h>

    int sem_destroy(sem_t *sem);

    Fonksiyon semaphore nesnesinin adresini parametre olarak alır. Başarı durumunda 0, başarısızlık durumunda -1 değerine 
    geri döner ve errno değişkeni uygun biçimde set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda basit bir binary semaphore örneği verilmiştir. Bu örnekte yine iki thread tıpkı mutex örneğinde olduğu gibi bir 
    semaphore eşliğinde global bir değişkeni artırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem;
int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((sem_init(&g_sem, 0, 1)) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem) == -1)
        exit_sys("sem_destroy");

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");

        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_wait");
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");

        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_wait");
    }

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki binary semaphore'lar mutex'e çok benzemektedir. Biz hangisini tercih etmeliyiz? İşte mutex'in sahipliği 
    thread temelinde alındığı için mutex genel olarak binary semaphore'lara göre daha güvenlidir. Ayrıca genel olarak işletim 
    sistemlerinde mutex işlemleri, semaphore işlemlerine göre daha hızlı olma eğilimindedir. Yani eğer bir senkronizasyon 
    işlemini mutex kullanarak da binary semaphore kullanarak da yapabiliyorsak mutex'i tercih etmeliyiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte belli sayıda kaynak (örneğimizde 3) belli sayıda thread tarafından (örneğimizde 10) paylaşılmaktadır. 
    Örnekte semaphore kontrolü ile kritik kod oluşturulmuş ve kritik kodu her giren thread'e bir kaynak atanmıştır. Bu örnekten 
    amaç böyle bir durumun simülasyonunun yapılmasıdır. Bu örnekte kaynağı elde edemeyen thread'ler blokede bekletilmektedir. 
    Bir thread'in kaynak kullanımı bittiğinde artık kritik kodu yeni bir thread girmekte ve o kaynak o thread'e atanmaktadır. 
    Örneğimizde bir semaphore nesnesinin yanı sıra bir de mutex nesnesi kullanılmıştır. Bu mutex nesnesi kaynak ataması 
    sırasında oluşabilecek senkronizasyon problemini (race condition) engellemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

#define NTHREADS        10
#define NRESOURCES        3

typedef struct tagRESOURCES {
    int useflags[NRESOURCES];
    sem_t sem;
    pthread_mutex_t mutex;
} RESOURCES;

typedef struct tagTHREAD_INFO {
    pthread_t tid;
    char name[32];
    unsigned seed;
} THREAD_INFO;

void assign_resource(THREAD_INFO *ti);
void do_with_resource(THREAD_INFO *ti, int nresource);
void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

RESOURCES g_resources;

int main(void)
{
    int result;
    THREAD_INFO *threads_info[NTHREADS];

    srand(time(NULL));

    for (int i = 0; i < NRESOURCES; ++i)
        g_resources.useflags[i] = 0;

    if ((sem_init(&g_resources.sem, 0, NRESOURCES)) == -1)
        exit_sys("sem_init");
    if ((result = pthread_mutex_init(&g_resources.mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    for (int i = 0; i < NTHREADS; ++i) {
        if ((threads_info[i] = (THREAD_INFO *)malloc(sizeof(THREAD_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }
        snprintf(threads_info[i]->name, 32, "Thread-%d", i + 1);
        threads_info[i]->seed = rand();
        if ((result = pthread_create(&threads_info[i]->tid, NULL, thread_proc, threads_info[i])) != 0)
            exit_sys_errno("pthread_create", result);
    }

    for (int i = 0; i < NTHREADS; ++i) {
        if ((result = pthread_join(threads_info[i]->tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);
        free(threads_info[i]);
    }

    if ((result = pthread_mutex_destroy(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    if (sem_destroy(&g_resources.sem) == -1)
        exit_sys("sem_destroy");

    return 0;
}

void assign_resource(THREAD_INFO *ti)
{
    int result;
    int i;

    if (sem_wait(&g_resources.sem) == -1)
        exit_sys("sem_wait");

    if ((result = pthread_mutex_lock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    for (i = 0; i < NRESOURCES; ++i)
        if (!g_resources.useflags[i]) {
            g_resources.useflags[i] = 1;
            break;
        }

    if ((result = pthread_mutex_unlock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s thread acquired resource \"%d\"\n", ti->name, i + 1);

    do_with_resource(ti, i + 1);

    if ((result = pthread_mutex_lock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    g_resources.useflags[i] = 0;

    if ((result = pthread_mutex_unlock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s thread released resource \"%d\"\n", ti->name, i + 1);

    if (sem_post(&g_resources.sem) == -1)
        exit_sys("sem_wait");

    usleep(rand_r(&ti->seed) % 10000);
}

void do_with_resource(THREAD_INFO *ti, int nresource)
{
    printf("%s doing something with resource \"%d\"\n", ti->name, nresource);

    usleep(rand_r(&ti->seed) % 500000);
}

void *thread_proc(void *param)
{
    THREAD_INFO *ti = (THREAD_INFO *)param;

    for (int i = 0; i < 10; ++i)
        assign_resource(ti);

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz daha önce üretici-tüketici problemini koşul değişkenleri ile çözmüştük. Aynı problemi semaphore nesneleriyle da daha 
    kolay bir biçimde çözebiliriz. Yine tahterevalli sistemi burada geçerlidir. Semaphore sayaçlarının başka bir thread tarafından
    sem_post fonksiyonu ile artırılabildiğini anımsayınız. Yani sem_post uygulayabilmek için sem_wait yapmış olmak gerekmemektedir. 
    Tipik çözüm şöyledir: Yine üretici ve tüketici için iki semaphore alınır. Semaphore sayaçları paylaşılan alanın uzunluğuna 
    ayarlanır. Biz ortadaki paylaşılan alanın 1 elemanlık olduğunu varsayalım (kontroller yapılmamıştır):

    sem_t g_sem_producer;
    sem_t g_sem_consumer;
    ...
    sem_init(&g_sem_producer, 0, 1);
    sem_init(&g_sem_consumer, 0, 0);

    Başlangıçta üretici semaphore'un sayacının 1 olduğuna, tüketici semaphore'un sayacının 0 olduğuna dikkat ediniz. Böylelikle 
    işin başında tüketici bekleyecek ancak üretici beklemeyecektir.

    ÜRETİCİ THREAD

    for (;;) {
        <değer elde ediliyor>
        sem_wait(&g_sem_producer);
        <değer paylaşılan alana yerleştiriliyor>
        sem_post(&g_sem_consumer);
    }

    TÜKETİCİ THREAD

    for (;;) {
        sem_wait(&g_sem_consumer);
        <paylaşılan bellek alanından bilgi alınıyor>
        sem_post(&g_sem_producer);
        <alınan bilgi işleniyor>
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                59. Ders 11/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin kuyruksuz versiyonu semaphore nesneleri ile çözülmüştür. Burada üretici semaphore'unun
    başlangıçta 1'e tüketici semaphore'unun da 0'a kurulduğuna dikkat ediniz. Üretici tüketiciyi, tüketici de üreticiyi 
    tahterevalli misali blokeden kurtarmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem_producer;
sem_t g_sem_consumer;

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if (sem_init(&g_sem_producer, 0, 1) == -1)
        exit_sys("sem_init");

    if (sem_init(&g_sem_consumer, 0, 0) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem_consumer) == -1)
        exit_sys("sem_destroy");

    if (sem_destroy(&g_sem_producer) == -1)
        exit_sys("sem_destroy");

    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if (sem_wait(&g_sem_producer) == -1)
            exit_sys("sem_wait");

        g_shared = val;

        if (sem_post(&g_sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        if (sem_wait(&g_sem_consumer) == -1)
            exit_sys("sem_wait");

        val = g_shared;

        if (sem_post(&g_sem_producer) == -1)
            exit_sys("sem_post");

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Üretici tüketici probleminin kuyruklu versiyonu da tamamen benzer biçimde semaphore nesneleriyle çözülebilmektedir. Ancak 
    bu durumda üretici semaphore'unun başlangıçta kuyruk uzunluğuna kurulması gerekmektedir. Böylece tüketici hiç çalışmadığında,
    üretici kuyruğu doldurur ve bekler. Benzer biçimde üretici çalışmadığı durumda tüketici kuyruktaki tüm elemanları alır ve 
    bekler. Örneğin:

    sem_t g_sem_producer;
    sem_t g_sem_consumer;
    ...

    sem_init(&g_sem_producer, 0, QUEUE_SIZE);
    sem_init(&g_sem_consumer, 0, 0);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin kuyruklu biçimi için bir veri yapısı oluşturulmuştur. Bu veri yapısı önce init_squeue
    fonksiyonu ile yaratılır. Sonra put_squeue ve get_squeue fonksiyonları ile bu kuyruk veri yapısına eleman eklenip alınır. 
    Kullanım bittikten sonra kuyruk veri yapısı destroy_squeue fonksiyonu ile boşaltılmalıdır.

    Programın testi için derlemeyi şöyle yapabilirsiniz:

    $ gcc -o sample sample.c syncqueue.c -lpthread
---------------------------------------------------------------------------------------------------------------------------*/

/* syncqueue.h */

#ifndef SYNCQUEUE_H_
#define SYNCQUEUE_H_

#include <stddef.h>
#include <semaphore.h>

/* Type Declarations */

typedef int DATATYPE;

typedef struct tagSYNC_QUEUE {
    DATATYPE *queue;
    size_t size;
    size_t head;
    size_t tail;
    sem_t sem_producer;
    sem_t sem_consumer;
} SYNC_QUEUE;

/* Function Prototypes */

SYNC_QUEUE *init_squeue(size_t size);
int put_squeue(SYNC_QUEUE *sd, DATATYPE val);
int get_squeue(SYNC_QUEUE *sd, DATATYPE *val);
int destroy_squeue(SYNC_QUEUE *sq);

#endif

/* syncqueue.c */

#include <stdio.h>
#include <stdlib.h>
#include "syncqueue.h"

/* Function Definitions */

SYNC_QUEUE *init_squeue(size_t size)
{
    SYNC_QUEUE *sq;

    if ((sq = (SYNC_QUEUE *)malloc(sizeof(SYNC_QUEUE))) == NULL)
        goto FAILED1;

    if ((sq->queue = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL)
        goto FAILED2;

    sq->size = size;
    sq->head = sq->tail = 0;

    if (sem_init(&sq->sem_producer, 0, size) == -1)
        goto FAILED3;

    if (sem_init(&sq->sem_consumer, 0, 0) == -1)
        goto FAILED3;

    return sq;

FAILED3:
    free(sq->queue);
FAILED2:
    free(sq);
FAILED1:

    return NULL;
}

int put_squeue(SYNC_QUEUE *sq, DATATYPE val)
{
    if (sem_wait(&sq->sem_producer) == -1)
        return -1;
    sq->queue[sq->tail++] = val;
    sq->tail %= sq->size;
    if (sem_post(&sq->sem_consumer) == -1)
        return -1;

    return 0;
}

int get_squeue(SYNC_QUEUE *sq, DATATYPE *val)
{
    if (sem_wait(&sq->sem_consumer) == -1)
        return -1;
    *val = sq->queue[sq->head++];
    sq->head %= sq->size;
    if (sem_post(&sq->sem_producer) == -1)
        return -1;

    return 0;
}

int destroy_squeue(SYNC_QUEUE *sq)
{
    if (sem_destroy(&sq->sem_producer) == -1)
        return -1;

    if (sem_destroy(&sq->sem_consumer) == -1)
        return -1;

    free(sq->queue);
    free(sq);

    return 0;
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include "syncqueue.h"

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    SYNC_QUEUE *sd;

    if ((sd = init_squeue(10)) == NULL)
        exit_sys("init_squeue");

    if ((result = pthread_create(&tid1, NULL, thread_producer, sd)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, sd)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (destroy_squeue(sd) == -1)
        exit_sys("destroy_squeue");

    return 0;
}

void *thread_producer(void *param)
{
    SYNC_QUEUE *sd = (SYNC_QUEUE *)param;
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if (put_squeue(sd, val) == -1)
            exit_sys("put_squeue");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    SYNC_QUEUE *sd = (SYNC_QUEUE *)param;
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        if (get_squeue(sd, &val) == -1)
            exit_sys("get_squeue");

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    İsimsiz semaphore nesneleri de yine istenirse sem_init fonksiyonunda pshared parametresi sıfır dışı yapılarak ve paylaşılan 
    bellek alanında oluşturularak prosesler arasında kullanılabilir. Ancak prosesler arasında kullanım için isimli semaphore 
    nesneleri genellikle daha uygundur.

    Aşağıda iki proses arasında isimsiz semaphore nesneleri ile üretici tüketici problemi uygulanmıştır. Burada önce "producer"
    programını çalıştırınız. Derleme işlemlerini aşağıdaki gibi yapabilirsiniz:

    $ gcc -o producer producer.c
    $ gcc -o consumer consumer.c
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <semaphore.h>
#include <sys/types.h>

#define SHM_NAME        "/producer-consumer"
#define QUEUE_SIZE        10

typedef struct tagSHARED_INFO {
    sem_t sem_producer;
    sem_t sem_consumer;
    int head;
    int tail;
    int queue[QUEUE_SIZE];
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
        exit_sys("ftruncate");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    if ((sem_init(&shminfo->sem_producer, 1, QUEUE_SIZE)) == -1)
        exit_sys("sem_init");

    if ((sem_init(&shminfo->sem_consumer, 1, 0)) == -1)
        exit_sys("sem_init");

    shminfo->head = 0;
    shminfo->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if (sem_wait(&shminfo->sem_producer) == -1)
            exit_sys("sem_wait");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        if (sem_post(&shminfo->sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    if (sem_destroy(&shminfo->sem_consumer) == -1)
        exit_sys("sem_destroy");

    if (sem_destroy(&shminfo->sem_producer) == -1)
        exit_sys("sem_destroy");

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int fdshm;
    SHARED_INFO *shminfo;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
        exit_sys("shm_open");

    shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
    if (shminfo == MAP_FAILED)
        exit_sys("mmap");

    for (;;) {
        if (sem_wait(&shminfo->sem_consumer) == -1)
            exit_sys("sem_wait");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        if (sem_post(&shminfo->sem_producer) == -1)
            exit_sys("sem_post");

        printf("%d ", val);
        fflush(stdout);

        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

    if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
        exit_sys("munmap");

    close(fdshm);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

/*---------------------------------------------------------------------------------------------------------------------------
    İsimli POSIX semaphore nesneleri daha önce görmüş olduğumuz POSIX paylaşılan bellek alanı ve POSIX mesaj kuyruklarına benzer 
    biçimde kullanılmaktadır. Kullanım adımları şöyledir:

    1) İsimli POSIX semaphore nesneleri sem_open fonksiyonu ile yaratılır ya da zaten var olan nesne açılır. Fonksiyonun prototipi 
    şöyledir:

    #include <semaphore.h>

    sem_t *sem_open(const char *name, int oflag, ...);

    Fonksiyonun birinci parametresi prosesler arasında kullanım için gereken ismi belirtmektedir. Bu isim yine diğer POSIX IPC 
    nesnelerinde olduğu gibi kök dizinde bir dosya ismi gibi verilmelidir. İkinci parametre açış modunu belirtir. Burada eğer 
    O_CREAT kullanılırsa nesne yoksa yaratılır, varsa olan açılır. O_CREAT ile O_EXCL birlikte kullanılabilir. Bu durumda nesne 
    zaten varsa fonksiyon başarısız olmaktadır. Burada açış modunda O_RDONLY, O_WRONLY ya da O_RDWR gibi bayraklar kullanılmaz. 
    Başka bir deyişle isimli semaphore nesnelerinde okuma yapmak ya da onlara yazma yapmak biçiminde işlemler tanımlı değildir. 
    Eğer zaten var olan bir semaphore nesnesi açılacaksa bu ikinci parametre 0 geçilebilir. Eğer semaphore nesnesinin yaratılması 
    söz konusu ise sem_open fonksiyonuna iki argüman daha girilmelidir. Bu durumda üçüncü parametre nesnenin erişim haklarını, 
    dördüncü parametre ise semaphore sayacının başlangıçtaki değerini belirtmektedir. Yani bu durumda adeta fonksiyonun prototipi 
    aşağıdaki gibi olmaktadır:

    sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);

    Semaphore nesneleri için "okuma ve yazma" eylemlerinin tanımsız olduğunu belirtmiştik. Bu nedenle POSIX standartları da nesnenin 
    erişim haklarının hangi durumda erişime izin vereceği yönünde bir açıklama yapmamıştır. Linux sistemlerinde isimli semaphore 
    nesnesi yaratılırken bir prosesin bu nesneye erişmesi isteniyorsa, erişim haklarında hem read hem de write bulunuyor olmalıdır. 
    Yani erişim işlemi sanki "read/write" düzeyde (O_RDWR) yapılan bir işlem gibi kontrole girmektedir. Ancak buradaki erişim hakkı 
    diğer dosya yaratan fonksiyonlarda olduğu gibi prosesin umask değerinden etkilenmektedir.

    Fonksiyon başarı durumunda kendi yarattığı semaphore nesnesinin adresine, başarısızlık durumunda SEM_FAILED özel değerine geri 
    döner. errno değişkeni uygun biçimde set edilmektedir. Örneğin:

    sem_t *sem;
    ...

    if ((sem = sem_open("/my-test-semaphore", O_CREAT, S_IRUSR|S_IWUSR, 1)) == SEM_FAILED)
       exit_sys("sem_open");

    2) Artık kritik kod yine isimsiz semaphore nesnelerinde olduğu gibi sem_wait ve sem_post fonksiyonlarıyla oluşturulabilir. 
    Örneğin (kontroller uygulanmamıştır):

    sem_wait(sem);
    ...
    ...        <KRİTİK KOD>
    ...
    sem_post(sem);

    3) Semaphore nesnesinin kullanımı bittikten sonra nesne sem_close fonksiyonu ile (sem_destroy fonksiyonu ile değil) boşaltılmalıdır.
    Örneğin:

    sem_close(sem);

    Fonksiyonun prototipi şöyledir:

    #include <semaphore.h>

    int sem_close(sem_t *sem);

    Fonksiyon, semaphore nesnesinin adresini alır ve nesneyi kapatır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine geri dönmektedir. errno değişkeni uygun biçimde set edilmektedir.

    4) Nihayet isimli semaphore nesnesi sem_unlink fonksiyonu ile yok edilebilir. Eğer nesne yok edilmezse "kernel persistent" 
    bir biçimde sistem reboot edilene kadar kalmaya devam eder. sem_unlik fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_unlink(const char *name);

    Fonksiyon, semaphore nesnesinin ismini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine 
    geri döner. errno değişkeni uygun biçimde set edilmektedir.

    Linux'ta isimli POSIX semaphore nesneleri de tıpkı POSIX paylaşılan bellek alanı nesnelerinde olduğu gibi /dev/shm dizininde 
    görüntülenmektedir. Ancak bu dizinde bu nesnelerin isimlerinin başında "sem." öneki bulunmaktadır. Programcı isterse 
    bu nesneleri komut satırında rm komutuyla silebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda prosesler arasında üretici-tüketici problemi isimli semaphore nesneleri ile çözülmüştür. Derleme işlemleri aşağıdaki 
    gibi yapılabilir:

    $ gcc -o producer producer.c
    $ gcc -o consumer consumer.c

    Test işleminde önce "producer" programının çalıştırılması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* shared.h */

#ifndef SHARED_H_
#define SHARED_H_

#include <stddef.h>

#define SHM_PATH            "/sample_shared_memory"
#define SEM_PATH_PRODUCER    "/sample_producer_semaphore"
#define SEM_PATH_CONSUMER    "/sample_consumer_semaphore"

#define QUEUE_SIZE        10

struct QUEUE {
    int qarray[QUEUE_SIZE];
    size_t head;
    size_t tail;
};

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <semaphore.h>
#include "shared.h"

void exit_sys(const char *msg);

int main(void)
{
    int fdshm;
    struct QUEUE *queue;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, 4096) == -1)
        exit_sys("ftruncate");

    if ((queue = (struct QUEUE *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED)
        exit_sys("mmap");

    memset(queue, 0, sizeof(struct QUEUE));

    if ((sem_producer = sem_open(SEM_PATH_PRODUCER, O_CREAT, S_IRUSR|S_IWUSR, QUEUE_SIZE)) == SEM_FAILED)
        exit_sys("sem_open");
    if ((sem_consumer = sem_open(SEM_PATH_CONSUMER, O_CREAT, S_IRUSR|S_IWUSR, 0)) == SEM_FAILED)
        exit_sys("sem_open");

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if (sem_wait(sem_producer) == -1)
            exit_sys("sem_wait");

        queue->qarray[queue->tail] = val;
        queue->tail = (queue->tail + 1) % QUEUE_SIZE;

        if (sem_post(sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    sem_destroy(sem_consumer);
    sem_destroy(sem_producer);

    if (sem_unlink(SEM_PATH_CONSUMER) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");

    if (sem_unlink(SEM_PATH_PRODUCER) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");

    if (munmap(queue, 4096) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_PATH) == -1 && errno != ENOENT)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <semaphore.h>
#include "shared.h"

void exit_sys(const char *msg);

int main(void)
{
    int fdshm;
    struct QUEUE *queue;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    int val;

    srand(time(NULL));

    if ((fdshm = shm_open(SHM_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, 4096) == -1)
        exit_sys("ftruncate");

    if ((queue = (struct QUEUE *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED)
        exit_sys("mmap");

    if ((sem_producer = sem_open(SEM_PATH_PRODUCER, O_CREAT, S_IRUSR|S_IWUSR, QUEUE_SIZE)) == SEM_FAILED)
        exit_sys("sem_open");

    if ((sem_consumer = sem_open(SEM_PATH_CONSUMER, O_CREAT, S_IRUSR|S_IWUSR, 0)) == SEM_FAILED)
        exit_sys("sem_open");

    for (;;) {
        if (sem_wait(sem_consumer) == -1)
            exit_sys("sem_wait");

        val = queue->qarray[queue->head];
        queue->head = (queue->head + 1) % QUEUE_SIZE;

        if (sem_post(sem_producer) == -1)
            exit_sys("sem_post");

        usleep(rand() % 300000);

        printf("%d ", val);

        fflush(stdout);

        if (val == 99)
            break;
    }

    putchar('\n');

    sem_destroy(sem_consumer);
    sem_destroy(sem_producer);

    if (sem_unlink(SEM_PATH_CONSUMER) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");

    if (sem_unlink(SEM_PATH_PRODUCER) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");

    if (munmap(queue, 4096) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink(SHM_PATH) == -1 && errno != ENOENT)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                60. Ders 17/06/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi POSIX IPC nesneleri 90'lı yılların ortalarında POSIX standartlarına sokuldu. Daha önceleri 
    klasik Sistem 5 IPC nesneleri kullanıyordu. İşte klasik IPC nesnelerinin içerisinde semaphore nesneleri de bulunmaktadır. 
    Ancak maalesef Sistem 5 semaphore arayüzü oldukça karışıktır. Bu nedenle artık yeni programların eğer özel bir taşınabilirlik 
    sorunu yoksa POSIX semaphore nesnelerini kullanması uygun olur. Sistem 5 semaphore nesneleri, aynı prosesin thread'leri 
    arasında değil farklı prosesler arasında kullanım için düşünülmüştür. (Zaten bunların tasarlandığı yıllarda henüz thread'ler 
    uygulamaya girmemişti.) Halbuki isimsiz POSIX semaphore nesnelerini aynı prosesin thread'leri arasında kullanabilmekteyiz.

    Sistem 5 semaphore nesnelerinin isimlendirme biçimleri ve temel parametrik yapıları diğer Sistem 5 IPC nesnelerine oldukça 
    benzemektedir. Sistem 5 semaphore arayüzünü karışık yapan unsurlardan biri tek hamlede birden fazla semaphore üzerinde (buna
    semaphore set de denilmektedir) işlem yapılmasıdır. Ayrıca sayaç mekanizması da biraz karışık ve çok işlevli tasarlanmıştır.

    Biz kursumuzda Sistem 5 semaphore nesneleri için çok ayrıntıya girmeyeceğiz. Yukarıda da belirttiğimiz gibi karmaşık 
    tasarımlarından dolayı bunlar gittikçe POSIX semaphore nesneleri lehine daha az kullanılır hale gelmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sistem 5 semaphore nesnelerinin tipik kullanımı şöyledir:

    1) Semaphore nesnesi semget fonksiyonu ile (diğer fonksiyonların shmget ve msgget biçiminde isimlendirildiğini anımsayınız)
    yaratılır ya da zaten var olan açılır. Sistem 5 IPC nesnelerinde isim yerine numara (key) kullanıldığını anımsayınız. semget
    fonksiyonunun prototipi şöyledir:

    #include <sys/sem.h>

    int semget(key_t key, int nsems, int semflg);

    Fonksiyonun birinci parametresi prosesler arasında kullanım için gereken anahtar değerdir. Anımsanacağı gibi Sistem 5 IPC 
    nesneleri birer anahtar verilerek yaratılıp açılmakta ve bu işlemden bir id değeri elde edilmektedir. Bu id değerinin sistem 
    genelinde tek (unique) olduğunu anımsayınız. Yine anımsayacağınız gibi bu anahtarı isim gibi kullanabilmek için ftok fonksiyonundan 
    faydalanılabiliyordu. Tabii fonksiyonun birinci parametresi diğer Sistem 5 IPC nesnelerinde olduğu gibi IPC_PRIVATE biçiminde
    girilebilir. Bu durumda sistem olmayan bir anahtar kullanarak bize bir id vermektedir.

    Fonksiyonun ikinci parametresi semaphore kümesindeki semaphore sayısını belirtmektedir. Yani bu parametre toplam kaç tane 
    semaphore'un yaratılacağını belirtmektedir. Fonksiyonun üçüncü parametresi yaratılacak IPC nesnesinin erişim haklarını 
    almaktadır. Bu parametreye ayrıca IPC_CREAT ve IPC_EXCL bayrakları da eklenebilir. Yine IPC_CREAT bayrağı nesne yoksa 
    onu yaratmak için kullanılmaktadır. IOC_EXCL tek başına kullanılamaz. Ancak IPC_CREAT|IPC_EXCL biçiminde kullanılabilir. 
    Bu durumda nesne zaten varsa semget fonksiyonu başarısız olmaktadır.

    semget fonksiyonu başarı durumunda IPC nesnesinin id değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Örneğin:

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
        exit_sys("ftok");

    if ((semid = semget(key, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    Biz bu notlarda "Sistem 5 semaphore nesnesi" demekle aslında bir semaphore kümesini kastetmiş olacağız.

    2) Sistem 5 semaphore nesnesi yaratıldıktan sonra artık bu semaphore nesnesi içerisindeki semaphore'ların ilk değerlerinin 
    verilmesi gerekir. Çünkü Sistem 5 semaphore nesneleri aslında bir semaphore kümesi içermektedir. Yani biz semget ile 
    aslında bir semaphore kümesi yaratmış olmaktayız. Yaratılan semaphore kümesindeki her semaphore'un ilk semaphore "0" 
    olmak üzere bir indeks numarası vardır. Semaphore kümesindeki semaphore'lar üzerinde işlem yapmak için semctl isimli 
    fonksiyon kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/sem.h>

    int semctl(int semid, int semnum, int cmd, ...);

    Fonksiyonun birinci parametresi semaphore nesnesinin id değerini belirtmektedir. İkinci parametresi semaphore kümesindeki 
    üzerinde işlem yapılacak olan semaphore'un indeks numarasını belirtir. Fonksiyonun üçüncü parametresi semaphore kümesindeki 
    semaphore'lara uygulanacak işlemleri belirtmektedir. Bu işlemlere göre fonksiyona bir dördüncü parametre gerekebilmektedir. 
    Eğer fonksiyon çağrılırken bir dördüncü argüman girilecekse bu argüman aşağıdaki gibi bir birlik türünden olmak zorundadır:

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;

    Birlik elemanlarının çakışık yerleştirildiğini anımsayınız. Yani aslında fonksiyonun bu dördüncü parametresi, üçüncü 
    parametredeki işleme göre int, struct semid_ds türünden bir adres ya da unsigned short türden bir adres olabilmektedir. 
    Ancak karışıklığı engellemek için bu türlerin hepsi bir birlik (union) içerisinde toplanmıştır. Maalesef bu birlik bildirimi 
    herhangi bir başlık dosyasında bulunmamaktadır. Dolayısıyla bu bildirimi programcının kendisinin yapması gerekmektedir.

    semctl fonksiyonu başarısızlık durumunda -1 değerine geri dönmektedir ve errno uygun biçimde set edilmektedir.

    semctl fonksiyonunun üçüncü parametresi semaphore kümesindeki semaphore üzerinde hangi işlemin yapılacağını belirtmektedir. 
    Bu işlem şunlardan biri olabilir (IPC_RMID komutu daha sonra açıklanacaktır):

    GETVAL: İkinci parametre ile belirtilen semaphore'un semaphore sayaç değerinin elde edilmesi için kullanılır. Bu durumda 
    semctl fonksiyonu semaphore kümesindeki ikinci parametrede belirtilen semaphore'un sayaç değerine geri döner. Bu işlemin 
    yapılabilmesi için prosesin semaphore nesnesine "read" hakkının bulunuyor olması gerekir. Örneğin (kontroller yapılmamıştır):

    result = semctl(semid, 1, GETVAL);

    Burada biz semaphore kümesi içerisindeki 1 numaralı semaphore'un sayaç değerini elde etmiş olduk.

    SETVAL: Bu durumda ikinci parametreyle belirtilen semaphore'a ilişkin semaphore sayacı fonksiyona girilecek olan 
    dördüncü argümandaki birliğin val elemanı ile set edilmektedir. Bunun için prosesin semaphore nesnesine "write" hakkına
    sahip olması gerekmektedir. Örneğin (kontroller yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;
    ...

    arg.val = 5;

    semctl(semid, 1, SETVAL, arg);

    Burada biz 1 numaralı semaphore'un semaphore sayacını 5 olarak set etmiş olduk.

    GETALL: Bu komutla semaphore kümesindeki belli bir semaphore'un değil tüm semaphore'ların semaphore sayaç değerleri 
    elde edilmektedir. Bu durumda fonksiyona girilecek dördüncü argüman olan birliğin array elemanı semaphore sayaçlarının 
    yerleştirileceği unsigned short türünden dizinin başlangıç adresini göstermelidir. Yani programcı önce unsigned short 
    türden semaphore kümesindeki semaphore sayısı kadar bir dizi açmalı ve bu dizinin adresini birliğin array elemanına 
    yerleştirmeli ve bu birliği de semctl fonksiyonunun son elemanına girmelidir. Örneğin semaphore kümemizde iki semaphore 
    bulunuyor olsun (kontroller yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;

    unsigned short semvals[2];
    ...

    arg.array = semvals;

    semctl(semid, 0, GETALL, arg);

    Bu arada artık semaphore kümesindeki tüm semaphore'ların semaphore sayaçları semvals dizisine yerleştirilecektir. 
    Tabii GETALL komutunda artık fonksiyonun ikinci parametresindeki semaphore numarası dikkate alınmamaktadır. Bu işlemin 
    yapılabilmesi için yine prosesin semaphore nesnesine "read" hakkının olması gerekmektedir.

    SETALL: Bu komut semaphore kümesindeki tüm semaphore'ların semaphore sayaçlarını set etmek için kullanılmaktadır. 
    Yine bunun için fonksiyonun dördüncü parametresine yukarıdaki birlik türünden bir nesne geçirilir. Birliğin array 
    elemanı semaphore sayaçlarının değerinin bulunduğu unsigned short türünden dizinin başlangıç adresini göstermelidir. 
    Tabii bu dizinin yine semaphore kümesindeki semaphore sayısı kadar uzunlukta olması gerekir. Örneğin semaphore kümesinde 
    iki semaphore bulunuyor olsun (kontroller yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;

    unsigned short semvals[2] = {0, 10};
    ...

    arg.array = semvals;
    semctl(semid, 0, SETALL, arg);

    Burada semaphore kümesindeki ilk semaphore'un sayacı "0" olarak ikinci semaphore'un sayacı "10" olarak set edilmiştir. 
    Tabii yine bu durumda semctl fonksiyonunun ikinci parametresi fonksiyon tarafından kullanılmamaktadır. Bu işlemin yapılabilmesi 
    için yine prosesin semaphore nesnesine "write" hakkının olması gerekmektedir.

    GETPID: Bu komutta fonksiyonun dördüncü parametresine gereksinim yoktur. semctl fonksiyonu bize ikinci parametreyle belirtilen 
    semaphore üzerinde en son hangi prosesin semop uyguladığı bilgisini verir. Bu komuta çok seyrek gereksinim duyulmaktadır.
    Bu komut için de prosesin semaphore nesnesine "read" hakkının olması gerekmektedir.

    GETNCNT ve GETZCNT: Bu komutlar da sırasıyla semaphore sayacının artırılmasını bekleyen ve "0" olmasını bekleyen proseslerin 
    sayısını elde etmek için kullanılmaktadır. Bu komutlar için de prosesin semaphore nesnesine "read" hakkının olması gerekmektedir.

    Semaphore nesneleri yine "kernel persistent" biçimdedir. Yani sistem reboot edilene kadar ya da semaphore nesnesi silinene 
    kadar kalıcı olmaktadır.

    3) Kritik kod semop fonksiyonu ile oluşturulmaktadır. Maalesef semop fonksiyonunun kullanımı POSIX semaphore nesnelerinden 
    biraz daha karmaşıktır. Fonksiyonun prototipi şöyledir:

    #include <sys/sem.h>

    int semop(int semid, struct sembuf *sops, size_t nsops);

    Fonksiyonun birinci parametresi semaphore nesnesinin id değerini belirtmektedir. İkinci parametre sembuf isimli bir yapı 
    nesnesinin adresini almaktadır. Bu yapı <sys/sem.h> içerisinde bildirilmiştir. Bu nesnenin içi fonksiyonu çağıran 
    kişi tarafından doldurulur. sembuf yapısı şöyle bildirilmiştir:

    struct sembuf {
        unsigned short sem_num;    /* semaphore number */
        short sem_op;            /* semaphore operation */
        short sem_flg;            /* operation flags */
    };

    Yapının sem_num elemanı semaphore kümesindeki işlem yapılacak semaphore'u belirtmektedir. İkinci parametre semaphore 
    sayacı üzerinde yapılacak işlemi belirtmektedir. Bu parametreye aşağıdaki üç durumdan birine ilişkin bir değer girilebilir:

    a) Eğer yapının sem_op elemanının değeri 0'dan büyük bir değerse bu değer semaphore sayacına toplanır. Örneğin o anda 
    semaphore'un sayacının 1 olduğunu düşünelim. Biz sem_op değerine 1 yerleştirirsek artık semaphore sayaç değeri 2 olacaktır.

    b) Eğer yapının sem_op elemanında negatif bir değer varsa bu durumda semop fonksiyonu o andaki semaphore sayacının değerine 
    bakar. Eğer o anda semaphore sayacından burada belirtilen değer çıkartıldığında (yani negatif değerin mutlak değeri çıkartıldığında)
    semaphore sayacı 0'ın altına düşecek gibi bir durum oluşursa thread'i bloke eder. Ancak bu durumda henüz çıkartma işlemini yapmaz. 
    Ancak semaphore sayacının değerinden bu negatif değerin mutlak değeri çıkartıldığında sonuç 0 ya da 0'dan büyük olacaksa 
    fonksiyon bu çıkartmayı yapar ve blokeye yol açmadan geri döner. Örneğin:

        - Semaphore sayacının değeri 5 olsun. Biz de sem_op değerine -4 girmiş olalım. Bu durumda 5 - 4 = 1 olduğu için bir 
        bloke oluşmaz. semop başarıyla geri döner ve artık semaphore sayacının değeri 1 olur.

        - Semaphore sayacının değeri 5 olsun biz de sem_op değerine -5 girmiş olalım. Bu durumda 5 - 5 = 0 olduğu için bloke oluşmaz. 
        semop başarıyla geri döner ve artık semaphore sayacının değeri 0 olur.

        - Semaphore sayacının değeri 5 olsun. Biz de sem_op değerine -10 girmiş olalım. Şimdi 5 - 10 = -5'tir. Yani semaphore 
        sayacı negatif bir değere düşecek gibi olmuştur. İşte fonksiyon bu durumda asla semaphore sayacını negatif bir değere 
        düşürmeyeceği için thread'i bloke eder. Artık bu blokeden kurtulmanın yolu semaphore sayacını 10 ya da 10'un üzerine 
        çekmektir. Şimdi başka bir prosesin sem_op değerine 5 girerek semaphore sayacını 10'a çektiğini düşünelim. Artık bu 
        proses 10 - 10 = 0  olacağı için blokeden çıkabilecek ve semaphore sayacı 0 olarak set edilecektir.

    Buradaki önemli nokta şudur: Aslında semop hiçbir zaman semaphore sayacını 0'ın altına düşürmemektedir. Eğer semaphore 
    sayacı 0'ın altına düşecek gibi bir durum oluşursa zaten thread'i blokede bekletmektedir.

    c) Eğer yapının sem_op elemanında 0 değeri varsa bu özel ve başka bir durum anlamına gelmektedir. Bu durumda semaphore sayacı 
    0'a düşürülene kadar ilgili proses blokede bekletilir. Blokeden çıkmanın yolu semaphore sayacını 0'ın yukarısına çekmektedir. 
    Örneğin semaphore'un semaphore sayacı 1 olsun. 10 tane proses sem_op değerini 0'a çekerek blokede bekleyebilir. Sonra semaphore 
    sayacı 1 eksiltildiğinde (yani 0'a çekildiğinde) bu 10 proses de blokeden kurtulacaktır. Bu haliyle Sistem 5 semaphore'ları 
    birden fazla prosesi blokede bekletip uyandırmak için kullanılabilmektedir. Ancak bu kullanım çok seyrektir. Yani sem_op 
    değeri 0 ise bu durum "semaphore sayacı 0 olmadığı sürece blokede bekle" anlamına gelmektedir.

    sembuf yapısının sem_flg elemanı IPC_NOWAIT, SEM_UNDO bayraklarının birini ya da her ikisini içerebilir. Tabii bu bayraklardan 
    herhangi birisi girilmeyecekse bu elemana 0 değeri girilmelidir. IPC_NOWAIT blokesiz işlem yapmak için kullanılmaktadır. 
    Eğer bu bayrak belirtilirse bloke oluşturabilecek durumlarda bloke oluşmaz ve semop fonksiyonu -1 değeri ile geri döner ve
    errno değişkeni EAGAIN değeri ile set edilir. SEM_UNDO bayrağı, proses sonlandığında "semaphore adjustment" değerini (semadj) 
    işleme sokarak ters işlem yapmaktadır.

    semop fonksiyonun üçüncü parametresi, ikinci parametredeki sembuf dizisinin eleman sayısını belirtmektedir. Yani aslında 
    ikinci parametreye tek bir sembuf nesnesinin adresi değil, bir sembuf dizisinin adresi geçirilebilmektedir. Bu durumda 
    semop fonksiyonu birden fazla semaphore üzerinde işlem yapar. Fakat böyle bir kullanım genellikle çok seyrektir. 
    Örneğin bizim semaphore nesnemizin (kümemizin) içerisinde iki semaphore olsun. Biz tek bir semop çağrısıyla bir semaphore'un
    sayacını 1 artırırken diğerini 1 eksiltmek isteyebiliriz. Tabii bu kullanım seyrektir. Dolayısıyla genellikle fonksiyonun 
    son parametresi 1 geçilir. Eğer semop fonksiyonunda birden fazla semaphore için işlem yapılacaksa bu işlemler atomik bir 
    biçimde yapılmaktadır. Yani örneğin biz semop fonksiyonu ile iki semaphore'un sayacını 1 eksiltmek isteyelim. Semaphore'lardan 
    birinin sayacı 1, diğerinin sayacı 0 olsun. Şimdi biz sayacı 1 olan semaphore'un sayacını 1 eksiltebiliriz. Ancak sayacı 0 
    olan semaphore'un sayacını 1 eksiltemeyiz. O halde biz bloke oluruz. Ancak bloke olurken sayacı 1 olan semaphore'un sayacı 
    eksiltilmemektedir. Tüm işlemler eğer yapılacaksa tek hamlede tek bir işlem gibi yapılmaktadır.

    semop fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde 
    set edilir.

    Pekiyi Sistem 5 semaphore'ları ile kritik kod nasıl oluşturulmaktadır? İşte bunun tipik senaryosu şöyledir: Başlangıçta 
    semaphore sayacı semctl fonksiyonu ile ayarlanır. Sonra kritik kod aşağıdaki gibi oluşturulur (kontroller yapılmamıştır):

    struct sembuf sbuf;
    ...

    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flags = 0;

    semop(semid, &sbuf, 1);

    ...
    ...        <KRİTİK KOD>
    ...

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flags = 0;

    semop(semid, &sbuf, 1);

    4) Sistem 5 semaphore nesneleri de diğer Sistem 5 IPC nesneleri gibi "kernel persistent" biçimdedir. Yani silinene kadar 
    ya da reboot işlemine kadar kalıcıdır. Semaphore nesnelerini silmek için yine semctl fonksiyonunda IPC_RMID kullanmak gerekir. 
    Bu durumda semctl fonksiyonunun semaphore numarasını alan ikinci parametresi dikkate alınmamaktadır. Örneğin:

    if (semctl(semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                61. Ders 18/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tıpkı Sistem 5 paylaşılan bellek alanı ve mesaj kuyruklarında olduğu gibi Sistem 5 semaphore nesnelerinde de yine semctl 
    fonksiyonunda IPC_GET ve IPC_SET komut kodlarıyla semaphore nesnelerinin bazı değerleri get ve set edilebilmektedir. 
    Sistem 5 semaphore nesneleri için işletim sistemi semid_ds isimli bir yapı nesnesi oluşturmaktadır. Bu yapı nesnesi şöyle 
    bildirilmiştir:

    struct semid_ds {
        struct ipc_perm sem_perm;        /* Ownership and permissions */
        time_t sem_otime;                /* Last semop time */
        time_t sem_ctime;                /* Creation time/time of last modification via semctl() */
        unsigned long sem_nsems;        /* No. of semaphores in set */
    };

    Bu yapının ilk elemanı yine IPC nesnesinin erişim haklarını belirtir. İkinci ve üçüncü elemanları semaphore nesnesi üzerinde
    yapılan son işlemlerin zamanları hakkında bilgi verir. Son elemanı ise semaphore kümesindeki semaphore sayısını belirtmektedir. 
    semctl ile ilk değer verilmemiş semaphore'lar için yapının sem_ctime ve sem_nsems elemanları çöp değerlerdedir. Standartlar
    henüz semop fonksiyonu uygulanmadan yapının sem_otime elemanının 0 olacağını garanti etmektedir. Bu garanti sayesinde iki 
    proses aynı semaphore'a ilişkin initialize işlemi yapmak istediğinde oluşan sorun çözülebilmektedir. İzleyen paragraflarda 
    bu durum yeniden açıklanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sistem 5 semaphore nesneleri prosesler arası kullanım için düşünülmüştür. Özellikle prosesler arasındaki üretici-tüketici 
    problemi gibi tipik senkronizasyon problemleri eskiden bu nesnelerle çözülüyordu. Tabii bu nesneler aslında ağırlıklı 
    olarak Sistem 5 paylaşılan bellek alanlarıyla birlikte kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sistem 5 semaphore nesnelerinin kullanımı POSIX semaphore nesnelerine göre daha zahmetlidir. Ancak istersek sarma fonksiyonlar 
    yazarak Sistem 5 semaphore nesnelerini POSIX semaphore nesneleri gibi de kullanabiliriz. Böylece bu karmaşıklığı ortadan 
    kaldırabiliriz. Aşağıda 6 tane sarma fonksiyon yazılmıştır:

    int sem_create(int key, int mode);
    int sem_open(int key);
    int sem_init(int semid, int val);
    int sem_wait(int semid);
    int sem_post(int semid);
    int sem_destroy(int semid);

    Bu fonksiyonlar semaphore nesnesindeki tek bir semaphore üzerinde çalışmaktadır. sem_create fonksiyonu anahtar ve erişim 
    haklarını alarak semaphore nesnesini yaratır. sem_open fonksiyonu yaratılmış olanı açar. sem_init fonksiyonu semaphore 
    sayacına değerini atar. sem_wait ve sem_post fonksiyonları kritik kod oluşturmakta kullanılır. Nihayet sem_destroy 
    fonksiyonu da semaphore nesnesini yok eder. 
---------------------------------------------------------------------------------------------------------------------------*/

int sem_create(int key, int mode)
{
    return semget(key, 1, IPC_CREAT|mode);
}

int sem_open(int key)
{
    return semget(key, 1, 0);
}

int sem_init(int semid, int val)
{
    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
        struct seminfo *__buf;
    } su;

    su.val = val;

    return semctl(semid, 0, SETVAL, su);
}

int sem_wait(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;
    sb.sem_flg = 0;

    return semop(semid, &sb, 1);
}

int sem_post(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1;
    sb.sem_flg = 0;

    return semop(semid, &sb, 1);
}

int sem_destroy(int semid)
{
    return semctl(semid, 0, IPC_RMID);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda Sistem 5 paylaşılan bellek alanları ve Sistem 5 semaphore nesneleri ile kuyruklu üretici-tüketici problemi örneği
    verilmiştir. Bu örnekte paylaşılan alan aşağıdaki yapıyla temsil edilmiştir:

    typedef struct tagSHARED_INFO {
        int head;
        int tail;
        int queue[QUEUE_SIZE];
        int semid;            /* two semaphore, 0 is producer, 1 is consumer */
    } SHARED_INFO;

    Burada Sistem 5 semaphore'unun id değeri de bu yapının içerisinde bulundurulmuştur. Örneğimizde paylaşılan bellek alanını 
    ve semaphore nesnesini üretici program (producer.c) yaratmaktadır. Tüketici program (consumer.c) yalnızca yaratılmış olan 
    nesneleri kullanmaktadır. Tabii bu nedenle önce üretici programın çalıştırılması gerekmektedir. IPC nesnelerini üretici 
    program yarattığı için bunları yine üretici program silmektedir. Anımsanacağı gibi Sistem 5 paylaşılan bellek alanı shmctl 
    fonksiyonununda IPC_RMID ile silinse bile onu kullanan prosesler shmdt ile alanı serbest bırakmadan silme işlemi gerçek 
    anlamda yapılmıyordu. Ancak örnekte şöyle bir problem vardır: Tüketici program, üretici program bu nesneleri yarattıktan 
    sonra çalıştırılmalıdır. Benzer biçimde üretici program, tüketici program işini bitirdikten sonra semaphore nesnesini 
    silmelidir. Bunun için biz programın bitişine henüz silme işlemi yapılmadan bir bekleme yerleştirdik. Eğer tüketici 
    programın da önce çalıştırılabilmesi isteniyorsa bu problemli durum başka bir senkronizasyon nesnesi ile (örneğimizde 
    bir Sistem 5 semaphore'u olabilir) çözülebilir. Programda semaphore nesnesinin IPC_PRIVATE ile yaratıldığına dikkat ediniz. 
    Bu durumda programcının çakışmayan bir anahtar belirlemesine gerek kalmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARED_H_
#define SHARED_H_

#define SHM_KEY                0x12345678
#define QUEUE_SIZE            10

typedef struct tagSHARED_INFO {
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int semid;            /* two semaphore, 0 is producer, 1 is consumer */
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;

    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, sizeof(SHARED_INFO), IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    shminfo->head = 0;
    shminfo->tail = 0;

    if ((shminfo->semid = semget(IPC_PRIVATE, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    if (semctl(shminfo->semid, 0, SETALL, semvals) == -1)
        exit_sys("semctl");

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        sbuf.sem_num = 1;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        if (val == 99)
            break;
        ++val;
    }

    printf("Press ENTR to exit...\n");
    getchar();

    if (semctl(shminfo->semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

    if (shmdt(shminfo) == -1)
        exit_sys("shmdt");

    if (shmctl(shmid, IPC_RMID, 0) == -1)
        exit_sys("shmctl");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;

    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, 0, 0)) == -1)
        exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    val = 0;
    for (;;) {
        sbuf.sem_num = 1;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        printf("%d ", val);
        fflush(stdout);

        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

    if (shmdt(shminfo) == -1)
        exit_sys("shmdt");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte önce üretici de tüketici de çalışsa, çalışmanın sorunsuz yürütülebilmesi nasıl sağlanabilir? İlk akla 
    gelen yöntem başka bir semaphore'un bu iş için kullanılmasıdır. Bu iş için bir semaphore yaratılır. Ancak hangi programın
    önce çalıştırılacağı bilinmediği için her iki program da bu semaphore'u yaratmaya çalışır. Tabii yalnızca bunlardan biri
    semaphore'u yaratıp diğeri yaratılmış olanı açacaktır. Buradaki semaphore sayacının başlangıç değeri 0'da tutulur. Böylece 
    tüketici bu semaphore'u bekler. Üretici, IPC nesnelerini yarattığında semaphore sayacını 1 artırarak tüketiciyi blokeden 
    kurtarır. Ancak üreticinin de henüz IPC nesnelerini silmeden tüketicinin işini bitirdiğinden emin olması gerekir. Bunun 
    için yine aynı semaphore kullanılabilir. Ancak burada başka bir sorun ortaya çıkmaktadır. Bu semaphore'un sayacına ilk 
    değer olan 0'ı kim verecektir. Eğer üretici önce çalışırsa IPC nesnelerini yaratıp semaphore sayacını artırdıktan sonra 
    tüketici çalışınca, tüketici de semaphore sayacına 0 değerini verirse "kilitlenme (deadlock)" oluşur. Bu problem aslında 
    yaygın bir problemdir. İşte standartlar semid_ds yapısının sem_otime elemanının henüz semop işlem yapılmadıysa 0 olmasını 
    garanti etmektedir. O zaman tüketici program, semctl ile semid_ds bilgilerini elde eder. Sonra yapının bu elemanına bakar. 
    Eğer bu elemanda 0 görürse, demek ki daha üretici işlemine başlamamıştır. O halde tüketici devam etmek için semaphore 
    sayacını initialize edebilir. Eğer bu elemanda 0 değeri yoksa zaten üretici semaphore sayacını initialize etmiştir. 
    Tüketicinin bunu yapmasına gerek yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARED_H_
#define SHARED_H_

#define SHM_KEY                0x12345678
#define SEM_KEY                0x12345678
#define QUEUE_SIZE            10

typedef struct tagSHARED_INFO {
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int semid;            /* two semaphore, 0 is producer, 1 is consumer */
} SHARED_INFO;

 union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int semid;
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;
    union semun arg;

    if ((semid = semget(SEM_KEY, 1, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    arg.val = 0;
    if (semctl(semid, 0, SETVAL, arg) == -1)
        exit_sys("semctl");

    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, sizeof(SHARED_INFO), IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    shminfo->head = 0;
    shminfo->tail = 0;

    if ((shminfo->semid = semget(IPC_PRIVATE, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    arg.array = semvals;
    if (semctl(shminfo->semid, 0, SETALL, arg) == -1)
        exit_sys("semctl");

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        sbuf.sem_num = 1;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        if (val == 99)
            break;
        ++val;
    }

    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if (semctl(shminfo->semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

    if (shmdt(shminfo) == -1)
        exit_sys("shmdt");

    if (shmctl(shmid, IPC_RMID, 0) == -1)
        exit_sys("shmctl");

    if (semctl(semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int semid;
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;
    union semun arg;
    struct semid_ds semds;

    srand(time(NULL));

    if ((semid = semget(SEM_KEY, 1, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    if (semctl(semid, 0, IPC_STAT, &semds) == -1)
        exit_sys("semctl");

    if (semds.sem_otime == 0) {
        arg.val = 0;
        if (semctl(semid, 0, SETVAL, arg) == -1)
            exit_sys("semct");
    }

    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if ((shmid = shmget(SHM_KEY, 0, 0)) == -1)
        exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
        exit_sys("shmat");

    val = 0;
    for (;;) {
        sbuf.sem_num = 1;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        printf("%d ", val);
        fflush(stdout);

        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if (shmdt(shminfo) == -1)
        exit_sys("shmdt");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Sistem 5 semaphore nesneleri prosesler arası kullanım için tasarlanmıştır. Zaten bu nesnelerin tasarlandığı zamanlarda 
    henüz thread'ler kullanılmıyordu. Her ne kadar bu nesneler aynı prosesin thread'leri arasında da kullanılabilirse de böyle 
    bir kullanım verimsiz ve gereksizdir. Thread'ler arasında semaphore kullanmak istiyorsanız isimsiz POSIX semaphore'larını
    tercih etmelisiniz. POSIX senkronizasyon nesneleri UNIX türevi sistemlere thread eklenirken eklenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                62. Ders 01/07/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Barrier nesneleri nispeten az kullanılan senkronizasyon nesnelerindendir. Windows sistemlerinde bu senkronizasyon nesnesinin 
    tam bir karşılığı yoktur. Barrier nesnelerinin çalışması şöyle bir örnekle açıklanabilir: Önümüzde bir bariyer olsun. Biz 
    bu bariyeri kuvvet uygulayarak kırmaya çalışalım. Ama bizim kuvvetimiz bu bariyeri kırmaya yetmesin. Sonra başka birisi 
    bize yardım etmek istesin. Bu kez bu bariyeri iki kişi kuvvet uygulayarak kırmaya çalışalım. Yine iki kişinin kuvveti 
    de bu bariyeri kırmaya yetmiyor olsun. Sonra bir üçüncü kişi de bize yardıma gelmiş olsun. Şimdi üçümüz kuvvet uygulayarak 
    bu bariyeri kırmaya çalıştığımızda bunu başardığımızı düşünelim. Artık bariyer kırıldığına göre üçümüz de yollarımıza 
    devam edebiliriz.

    Yukarıdaki örnekte olduğu gibi bariyer nesneleri ancak n tane thread belli bir noktaya geldiğinde açılmaktadır. Örneğin 
    buradaki açılma koşulunun 3 thread olduğunu düşünelim. Birinci thread bariyere geldiğinde bloke olur. İkinci thread de 
    bariyere geldiğinde bloke olur. Ancak üçüncü thread de bariyere geldiğinde artık bariyer açılır ve diğer iki thread'in 
    de blokesi çözülerek üç thread yollarına devam eder.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Barrier parçalardan oluşan bir işin parçalarının çeşitli thread'lere yaptırıldığı durumlarda bu thread'lerin işlerini 
    bitirdiği zaman nihai işlemin yapılması gerektiği durumlarda kullanılmaktadır. Örneğin büyük bir dizinin sort edilmek 
    istendiğini düşünelim. Biz bu diziyi 10 parçaya ayıralım ve 10 farklı thread'le bu parçaları sıraya dizmek isteyelim. 
    Her thread kendi parçasını sıraya dizdikten sonra artık bunların birleştirilmesi gerekmektedir. Ancak birleştirme işlemi 
    tüm thread'lerin kendi parçalarını sıraya dizdikten sonra yapılmalıdır. (Sıralı dizilerin birleştirilmesi işlemine "merge" 
    denilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Barrier nesneleri aşağıdaki adımlardan geçilerek kullanılmaktadır:

    1) Önce barrier nesnesini temsil eden pthread_barrier_t türünden global bir nesne tanımlanır. pthread_barrier_t türü 
    <pthread.h> ve <sys/types.h> dosyaları içerisinde typedef edilmiş durumdadır. POSIX standartlarına göre pthread_barrier_t
    türü herhangi bir tür olarak typedef edilmiş olabilir. Linux sistemlerinde bu tür bir yapı biçiminde typedef edilmiştir. 
    Örneğin:

    pthread_barrier_t g_barrier;

    2) Tanımlanan bu global barrier nesnesine pthread_barrier_init fonksiyonu ile ilk değer verilmesi gerekmektedir. Fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned count);

    Fonksiyonun birinci parametresi barrier nesnesinin adresini almaktadır. İkinci parametre, barrier nesnesinin özellik bilgilerinin
    bulunduğu pthread_barrierattr_t türünden nesnenin adresini almaktadır. Bu parametre NULL adres geçilebilir. Bu durumda 
    barrier nesnesi default özelliklerle yaratılmaktadır. Fonksiyonun üçüncü parametresi barrier'in kırılması için o noktaya 
    gelecek thread sayısını belirtmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri 
    dönmektedir. Örneğin:

    if ((result = pthread_barrier_init(&g_barrier, NULL, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    Barrier nesnelerine statik düzeyde makroyla ilk değer verilememektedir.

    3) N tane thread'in bir noktada bekletilmesi için pthread_barrier_wait fonksiyonu kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_barrier_wait(pthread_barrier_t *barrier);

    Fonksiyon barrier nesnesinin adresini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri 
    dönmektedir. Ancak fonksiyonun geri dönüş değeri hakkında önemli bir ayrıntı daha vardır. Birtakım thread'ler bir işin 
    parçalarını yaptıktan sonra geri kalan birleştirme işleminin yalnızca bir thread tarafından yapılmasını sağlamak için 
    pthread_barrier_wait fonksiyonu yalnızca tek bir thread'te PTHREAD_BARRIER_SERIAL_THREAD özel değeriyle geri dönmektedir. 
    Yani bekleme başarılıysa pthread_barrier_wait fonksiyonundan thread'ler 0 değeri ile geri dönerler. Ancak bunlardan yalnızca 
    biri PTHREAD_BARRIER_SERIAL_THREAD özel değeriyle geri dönmektedir. PTHREAD_BARRIER_SERIAL_THREAD özel değeri 0'dan farklı 
    bir değerdir. Dolayısıyla fonksiyon bu değerle geri dönmüşse başarısız kabul edilmemelidir. O halde fonksiyonun başarı 
    kontrolü aşağıdaki gibi yapılabilir:

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    Tabii thread'lerden birinde bu birleştirme işlemi yapılacaksa ayrıca yine fonksiyonun geri dönüş değerinin kontrol edilmesi 
    gerekir. Örneğin:

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        /* birleştirme işlemi */
    }

    Tabii bu kontrol aşağıdaki gibi de yapılabilir:

    if ((result = pthread_barrier_wait(&g_barrier)) != 0)
        if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
            /* birleştirme işlemi */
        }
        else
            exit_sys_errno("pthread_barrier_wait", result);

    Barrier nesnesi açıldıktan sonra yeniden otomatik olarak pthread_barrier_init fonksiyonu çağrılmış gibi ilk durumuna
    gelmektedir.

    POSIX standartları hangi thread'in PTHREAD_BARRIER_SERIAL_THREAD değeriyle geri döneceği konusunda bir garanti vermemektedir.

    4) Kullanım bittikten sonra barrier nesnesi pthread_barrier_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi 
    şöyledir:

    #incude <pthread.h>

    int pthread_barrier_destroy(pthread_barrier_t *barrier);

    Fonksiyon barrier nesnesinin adresini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri döner. 
    Örneğin:

    if ((result = pthread_barrier_destroy(&g_barrier)) != 0)
        exit_sys_errno("pthread_barrier_destroy", result);

    5) Barrier nesneleri için tek bir özellik bilgisi vardır. O da nesnenin prosesler arasında kullanılıp kullanılmayacağını 
    belirtmektedir. Default durumda (yani pthread_barrier_init fonksiyonunun ikinci parametresi NULL geçildiğinde) nesne 
    prosesler arasında kullanılamamaktadır. Özellik nesnesinin kullanımı diğer nesnelerde olduğu gibidir. Önce pthread_barrierattr_t 
    türünden bir nesne yaratılır. Sonra bu nesneye pthread_barrierattr_init fonksiyonu ile ilk değer verilir. Sonra nesnenin 
    özelliğinin set ve get edilmesi için pthread_barrierattr_setpshrared ve pthread_barrierattr_getpshrared fonksiyonları kullanılır. 
    Burada prosesler arası paylaşım PTHREAD_PROCESS_SHARED değeri ile belirtilmektedir. Tabii en sonunda bu özellik nesnesi 
    pthread_barrierattr_destroy fonksiyonu ile yok edilmelidir. Özellik ile ilgili fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_barrierattr_init(pthread_barrierattr_t *attr);
    int pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr, int *pshared);
    int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,int pshared);
    int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

    Fonksiyonların hepsi başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Örneğin:

    pthread_barrierattr_t battr;
    ...

    if ((result = pthread_barrierattr_init(&battr)) != 0)
        exit_sys_errno("pthread_barrierattr_init", result);

    if ((result = pthread_barrierattr_setpshared(&battr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_barrierattr_setpshared", result);

    if ((result = pthread_barrier_init(&g_barrier, &battr, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    if ((result = pthread_barrierattr_destroy(&battr)) != 0)
        exit_sys_errno("pthread_barrierattr_destroy", result);

    Tabii barrier nesnesini prosesler arasında kullanabilmek için nesneyi yine paylaşılan bellek alanında oluşturmak gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte 3 thread pthread_barrier_wait ile aynı barrier nesnesinde bekletilmiştir. 3 thread'de rastgele zamanlarda 
    bu noktaya erişmektedir. İçlerinden yalnızca biri PTHREAD_BARRIER_SERIAL_THREAD değeriyle geri dönecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_barrier_t g_barrier;

int main(void)
{
    pthread_t tid1, tid2, tid3;
    int result;

    if ((result = pthread_barrier_init(&g_barrier, NULL, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_barrier_destroy(&g_barrier)) != 0)
        exit_sys_errno("pthread_barrier_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread1 starts...\n");

    seed = time(NULL) + 123;

    stime = rand_r(&seed) % 10;
    printf("thread1 running %d second(s)\n", stime);
    sleep(stime);

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread1 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }

    printf("thread1 terminates...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread2 starts...\n");

    seed = time(NULL) + 456;

    stime = rand_r(&seed) % 10;
    printf("thread2 running %d second(s)\n", stime);
    sleep(stime);

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread2 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }

    printf("thread2 terminates...\n");

    return NULL;
}

void *thread_proc3(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread3 starts...\n");

    seed = time(NULL) + 789;

    stime = rand_r(&seed) % 10;
    printf("thread3 running %d second(s)\n", stime);
    sleep(stime);

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread3 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }

    printf("thread3 terminates...\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir barrier kullanım örneği verilmiştir. 50000000 (elli milyon) tane rastgele değerlerden oluşan int türden bir 
    dizi 10 parçaya bölünmüş ve her parça bir thread tarafından qsort fonksiyonu ile sort edilmiştir. Sonra da bu kendi 
    aralarında sıralı olan bu 10 dizi birleştirilmiştir. Sonra aynı dizi tek bir thread tarafından sıraya dizilmiştir. 3 
    çekirdekli bir Linux sisteminde (kullandığımız sanal makine) thread'li biçim 6 saniye civarında thread'siz biçim 12 saniye 
    civarında zaman almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

#define SIZE            50000000
#define NTHREADS        10

int comp(const void *pv1, const void *pv2);
void *thread_proc(void *param);
void merge(void);
int check(const int *nums);
void exit_sys_thread(const char *msg, int err);

pthread_barrier_t g_barrier;
int g_nums[SIZE];
int g_snums[SIZE];

int main(void)
{
    int result;
    int i;
    pthread_t tids[NTHREADS];
    clock_t start, stop;
    double telapsed;

    srand(time(NULL));
    for (i = 0; i < SIZE; ++i)
        g_nums[i] = rand();

    start = clock();

    if ((result = pthread_barrier_init(&g_barrier, NULL, NTHREADS)) != 0)
        exit_sys_thread("pthread_barrier_init", result);

    for (i = 0; i < NTHREADS; ++i)
        if ((result = pthread_create(&tids[i], NULL, thread_proc, (void *)i)) != 0)
            exit_sys_thread("pthread_create", result);

    for (i = 0; i < NTHREADS; ++i)
        if ((result = pthread_join(tids[i], NULL)) != 0)
            exit_sys_thread("pthread_join", result);

    pthread_barrier_destroy(&g_barrier);

    stop = clock();

    telapsed = (double)(stop - start) / CLOCKS_PER_SEC;

    printf("Total second with threaded sort: %f\n", telapsed);

    printf(check(g_snums) ? "Sorted\n" : "Not Sorted\n");

    start = clock();

    qsort(g_nums, SIZE, sizeof(int), comp);

    stop = clock();

    telapsed = (double)(stop - start) / CLOCKS_PER_SEC;

    printf("Total second with threaded sort: %f\n", telapsed);

    printf(check(g_nums) ? "Sorted\n" : "Not Sorted\n");

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int part = (int)param;
    int result;

    qsort(g_snums + part * (SIZE / NTHREADS), SIZE / NTHREADS, sizeof(int), comp);

    if ((result = pthread_barrier_wait(&g_barrier)) && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_thread("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD)
        merge();

    return NULL;
}

int comp(const void *pv1, const void *pv2)
{
    const int *pi1 = (const int *)pv1;
    const int *pi2 = (const int *)pv2;

    return *pi1 - *pi2;
}

void merge(void)
{
    int indexes[NTHREADS];
    int min, min_index;
    int i, k;
    int partsize;

    partsize = SIZE / NTHREADS;

    for (i = 0; i < NTHREADS; ++i)
        indexes[i] = i * partsize;

    for (i = 0; i < SIZE; ++i) {
        min = indexes[0];
        min_index = 0;

        for (k = 1; k < NTHREADS; ++k)
            if (indexes[k] < (k + 1) * partsize && g_nums[indexes[k]] < min) {
                min = g_nums[indexes[k]];
                min_index = k;
            }
        g_snums[i] = min;
        ++indexes[min_index];
    }
}

int check(const int *nums)
{
    int i;

    for (i = 0; i < SIZE - 1; ++i)
        if (nums[i] > nums[i + 1])
            return 0;

    return 1;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Senkronizasyon dünyasında karşımıza çıkan diğer bir senkronizasyon nesnesi de "spinlock" denilen nesnedir. Spinlock nesneleri 
    tıpkı mutex'ler ya da binary semaphore'lar gibi bir kritik kodun başından sonuna kadar yalnızca tek bir thread tarafından 
    çalıştırılmasını sağlamak için kullanılmaktadır. Bu nesnelerin mutex ve binary semaphore nesnelerinden farkı eğer nesne 
    kilitliyse beklemenin bloke yoluyla değil, meşgul bir döngü yoluyla blokesiz yapılmasıdır. Yani spinlock nesnelerinin 
    içerisinde bir döngü vardır. Bu döngünün içerisinde sürekli "kilit açılmış mı" diye kontrol yapılmaktadır. Şüphesiz bu 
    biçimdeki çalışma eğer nesne kilitliyse gereksiz CPU zamanının harcanmasına yol açacaktır. Ancak bazı durumlarda spinlock'lar 
    hızlandırma sağlayabilmektedir. Çünkü senkronizasyon nesnelerinin kilitli olması durumunda thread'in uykuya yatırılması 
    ve uyandırılması göreli olarak önemli bir zaman kaybı da oluşturmaktadır.

    Spinlock nesneleri yalnızca bazı özel koşullar sağlanıyorsa kullanılmalıdır. Örneğin tek işlemcili ya da tek çekirdekli 
    sistemlerde spinlock kullanımının genellikle zararından başka bir faydası yoktur. Çünkü tek işlemcili ya da tek çekirdekli 
    sistemlerde, bir thread nesneyi kilitlemiş ve thread'ler arası geçiş oluşmuşsa artık o nesnenin kilidinin açılması ancak o 
    thread'in yeniden CPU'ya atanmasıyla gerçekleşeceği için diğer bir thread spinlock içerisinde meşgul bir döngüde CPU zamanı 
    harcayarak bekleyecektir. Halbuki çok işlemcili ya da çekirdekli sistemlerde nesneyi kilitleyen thread bir işlemcide ya da 
    çekirdekte, spinlock'ta bekleyen thread ise başka bir işlemcide ya da çekirdekte çalışıyor olabilir. Bu durumda spinlock 
    çok fazla dönmeden nesneyi kilitleyebilir. Tabii işletim sistemleri, çok işlemcili ya da çekirdekli sistem söz konusu olsa 
    bile bu thread'leri aynı işlemci ya da çekirdeğin kuyruğuna atayabilmektedir. Öte yandan bazı aşağı seviyeli uygulamalarda 
    sistemde tek bir işlemci ya da çekirdek olsa bile bir donanım kesmesi ile kilidin açılmasını mümkün hale getiren bir 
    mekanizma da oluşturulabilmektedir. Mademki işletim sistemleri spinlock'ı kullanan thread'leri aynı işlemci ya da çekirdeğin 
    kuyruğuna atayabilmektedir bu durumda spinlock'ı kilitleyen thread'lerin daha yüksek öncelikli olması, bu tür durumlardaki 
    gereksiz beklemeleri bir ölçüde engelleyebilmektedir. Özetle spinlock kullanılırken dikkat edilmesi gerekir. Uygunsuz 
    yerde spinlock kullanımı performansı tam tersine olumsuz etkileyebilmektedir. Ancak bu nesnenin gerektiği yerde kullanılması 
    da performans üzerinde olumlu etkiler sağlayabilmektedir.

    Spinlock kilidini almak için iki thread'in farklı işlemci ya da çekirdeklerde çalıştığı durumda bunlardan birinin spinlock 
    kilidini aldığında kısa süre içerisinde bırakması en uygun durumdur. Çünkü, diğer işlemci ya da çekirdekteki thread meşgul 
    bir döngüde bekliyor olabilir. Spinlock ile oluşturulan kritik kodun kısa ve çabuk geçilen bir kod olması anlamlıdır.

    Daha önceden de belirttiğimiz gibi aynı prosesin thread'leri arasındaki senkronizasyon için ilk akla gelmesi gereken 
    senkronizasyon nesneleri mutex nesneleridir. Spinlock nesneleri bazı özel durumlarda performansı artırmak için dikkatlice
    kullanılmalıdır.

    Modern mutex, semaphore gibi nesnelerin gerçekleştiriminde de aslında kısa spin işlemleri yapılmaktadır. Örneğin pthread_mutex_lock
    hemen kilide bakıp kilit kapalıysa bloke olmamaktadır. Kısa bir süre spin içerisinde kilidin açılmasını bekleyip sonra bloke 
    olmaktadır. Yani bu nesnelerin gerçekleştiriminde de kısa spin işlemleri yapılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Spinlock nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Spinlock nesneleri pthread_spinlock_t türüyle temsil edilmiştir. Öncelikle bu türden global bir nesnenin tanımlanması 
    gerekir. Örneğin:

    pthread_spinlock_t g_spinlock;

    pthread_spinlock_t türü yine <pthread.h> ve <sys/types.h> dosyaları içerisinde herhangi bir tür olarak typedef edilebilmektedir. 
    Linux sistemlerinde tipik olarak bu tür bir yapı belirtmektedir.

    2) Spinlock nesnesine pthread_spin_init fonksiyonu ile ilk değer verilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_spin_init(pthread_spinlock_t *lock, int pshared);

    Fonksiyonun birinci parametresi spinlock nesnesinin adresini alır. İkinci parametre, nesnenin prosesler arasında kullanılıp 
    kullanılmayacağını belirtmektedir. Bu parametre 0 ya da PTHREAD_PROCESS_SHARED biçiminde geçilir. Nesnenin ayrıca bir 
    özellik (attribute) parametresinin olmadığına dikkat ediniz. Spinlock nesnesine ilk değer vermek için bir makro bulunmamaktadır. 
    Örneğin:

    if ((result = pthread_spin_init(&g_spinlock, 0)) != 0)
        exit_sys_errno("pthread_spin_init", result);

    3) Kritik kod pthread_spin_lock ve pthread_spin_unlock fonksiyonlarıyla oluşturulmaktadır. Fonksiyonların prototipleri 
    şöyledir:

    #include <pthread.h>

    int pthread_spin_lock(pthread_spinlock_t *lock);
    int pthread_spin_unlock(pthread_spinlock_t *lock);

    Fonksiyonlar, spinlock nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri döner. Kritik kod şöyle oluşturulmaktadır (kontroller yapılmamıştır):

    pthread_spin_lock(&g_spinlock);
    ...
    ...        <KRİTİK KOD>
    ...
    pthread_spin_unlock(&g_spinlock);

    Thread'in akışı pthread_spin_lock fonksiyonuna girdiğinde meşgul döngü içerisinde kilide bakılıp beklenmektedir. 
    pthread_spin_unlock fonksiyonu da kilidi açmaktadır.

    Yine buradaki lock fonksiyonunun try'lı biçimi de vardır:

    #include <pthread.h>

    int pthread_spin_trylock(pthread_spinlock_t *lock);

    Fonksiyon kilit açık mı diye bakar. Eğer kilit açık değilse spin yapmadan EBUSY errno değeri ile geri dönmektedir.

    4) Nihayet işlem bittikten sonra spinlock nesnesi pthread_spin_destoy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi
    şöyledir:

    #include <pthread.h>

    int pthread_spin_destroy(pthread_spinlock_t *lock);

    Fonksiyon, spinlock nesnesinin adresini parametre olarak alır ve nesneyi boşaltır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönmektedir. Örneğin:

    if ((result = pthread_spin_destroy(&g_spinlock)) != 0)
        exit_sys_errno("pthread_spin_destroy", result);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                63. Ders 02/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread global bir sayacı spinlock koruması ile artırmaktadır. Buradaki işlem CPU yoğun bir işlemdir. 
    Bu tür CPU yoğun işlemlerde eğer makinenizde birden fazla işlemci ya da çekirdek varsa spinlock daha iyi bir sonuç 
    verebilmektedir. Tabii eğer işletim sistemi, söz konusu bu thread'leri aynı işlemci ya da çekirdeklere atarsa tam tersine 
    spinlock daha kötü bir sonuç da verebilir. Bu örnekte programın çalışma süresini time programıyla ölçebilirsiniz. Aynı 
    örneği mutex nesneleriyle yapıp sonuçlarını karşılaştırabilirsiniz. Örneğin 3 çekirdeği kullanan sanal makinede aşağıdaki 
    sonuçlar elde edilmiştir:

    $ time ./spin
    200000000

    real    0m6,031s
    user    0m11,695s
    sys    0m0,024s

    $ time ./mutex
    200000000

    real    0m11,915s
    user    0m16,650s
    sys    0m7,002s
---------------------------------------------------------------------------------------------------------------------------*/

/* spin.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_spinlock_t g_spinlock;
int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_spin_init(&g_spinlock, 0)) != 0)
        exit_sys_errno("pthread_spin_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_spin_destroy(&g_spinlock)) != 0)
        exit_sys_errno("pthread_spin_destroy", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* mutex.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++g_count;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_lock", result);

            ++g_count;

            if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Diğer sık karşılaşılan bir senkronizasyon nesnesi de "reader-writer lock" denilen nesnedir. Bu nesne, bir veri yapısından 
    birden fazla thread'in okuma yapmasına izin veren ancak bir thread yazma yapıyorsa diğer thread'lerin okuma ya da yazma 
    yapmasını engelleyen bir senkronizasyon nesnedir. Bu senkronizasyon nesnesinin kullanım amacı şöyle bir örnekle açıklanabilir:
    Elimizde global bir bağlı liste olsun. Bu bağlı listeye eleman ekleyen bir grup thread, bu bağlı listeden eleman silen bir 
    grup thread ve bu bağlı listede arama yapan bir grup thread söz konusu olsun. Bir thread bağlı listeye eleman eklerken 
    ya da bağlı listeden eleman silerken, diğer thread'lerin bu işlemin bitmesini beklemesi gerekir. Benzer biçimde bir thread
    bağlı listede arama yaparken diğer thread'lerin bu arama bitene kadar eleman ekleme silme işlemlerine başlamaması gerekir. 
    Ancak buradaki kritik nokta birden fazla thread'in bağlı liste üzerinde arama yapabilmesinin bir sıkıntıya yol açmayacağıdır. 
    Yani birden fazla thread'in bağlı liste üzerinde arama yapması mümkün hale getirilmelidir. Aslında bu örnek bağlı listeye 
    eleman ekleme ya da bağlı listeden eleman silme işlemi bir "write" işlemi olarak ele alınabilir. Benzer biçimde bağlı 
    listede eleman arama işlemi de bir "read" işlemi olarak ele alınabilir. O halde bizim sağlamamız gereken durum şöyle 
    özetlenebilir:

    - Bir thread kaynak üzerinde write işlemi yaparken diğer thread'ler bu işlem bitene kadar aynı kaynak üzerinde read ya da 
    write işlemi yapmamalıdır.

    - Bir thread kaynak üzerinde read işlemi yaparken diğer thread'ler bu işlem bitene kadar aynı kaynak üzerinde write işlemi 
    yapmamalıdır.

    - Bir thread kaynak üzerinde read işlemi yaparken diğer thread'ler kaynak üzerinde read işlemi yapabilmelidir.

    Bu koşulları şöyle de özetleyebiliriz:

    write - write    (izin verilmemeli)
    write - read    (izin verilmemeli)
    read - write    (izin verilmemeli)
    read - read        (izin verilmeli)

    Burada açıkladığımız durumu daha önce gördüğümüz senkronizasyon nesneleriyle sağlamanın basit bir yolu yoktur. İşte bunu 
    sağlamak için "reader-writer lock" denilen özel bir senkronizasyon nesnesi kullanılmaktadır.

    Yukarıdaki problemin bir mutex nesnesiyle neden çözülemeyeceğini de açıklamak istiyoruz. Biz mutex kullanırken okuma ve 
    yazma işlemleri sırasında mecburen mutex'in sahipliğini almak zorunda kalacağız. Bu da birden fazla read durumunu 
    engelleyecektir. Örneğin:

    pthread_mutex_lock(&g_mutex);
    ...
    ...        <READ İŞLEMİ>
    ...
    pthread_mutex_unlock(&g_mutex);

    Görüldüğü gibi bir thread kaynak üzerinde read işlemi yapmaya çalıştığı zaman mutex'i kilitlediği için başka bir thread de
    read işlemi yapamayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Reader-Writer lock nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Programcı pthread_rwlock_t türünden global bir nesne tanımlar. Bu tür yine <thread.h> ve <sys/types.h> dosyalarında 
    herhangi bir türden olabilecek biçimde typedef edilmektedir. Linux sistemlerinde pthread_rwlock_t türü bir yapı belirtmektedir. 
    Örneğin:

    pthread_rwlock_t g_rwlock;

    2) pthread_rwlock_t nesnesine, PTHREAD_RWLOCK_INITIALIZER makrosuyla ya da pthread_rwlock_init fonksiyonuyla ilk değer 
    verilebilir. pthread_rwlock_init fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);

    Fonksiyonun birinci parametresi reader-writer lock nesnesinin adresini, ikinci parametresi ise onun özellik bilgisini 
    almaktadır. Özellik parametresine NULL adres geçilebilmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönmektedir.

    Bu durumda nesneye ilk değer verme işlemi aşağıdaki iki biçimden biri ile yapılabilir:

    pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;
    ...
    if ((result = pthread_rwlock_init(&g_rwlock, NULL)) != 0)
        exit_sys_errno("pthread_rwlock_init", result);

    3) Okuma amaçlı kritik kod oluşturmak için pthread_rwlock_rdlock fonksiyonu, yazma amaçlı kritik kod oluşturmak için 
    pthread_rwlock_wrlock fonksiyonu kullanılmaktadır. Nesne nasıl kilitlenmiş olursa olsun kilidi açmak için pthread_rwlock_unlock
    fonksiyonu kullanılmaktadır. Bu durumda okuma amaçlı kritik kod aşağıdaki gibi oluşturulmalıdır (kontroller yapılmamıştır):

    pthread_rwlock_rdlock(&g_rwlock);
    ...
    ...        <READ İŞLEMİ>
    ...
    pthread_rwlock_unlock(&g_rwlock);

    Yazma amaçlı kritik kod da şöyle oluşturulmalıdır (kontroller yapılmamıştır):

    pthread_rwlock_wrlock(&g_rwlock);
    ...
    ...        <WRITE İŞLEMİ>
    ...
    pthread_rwlock_unlock(&g_rwlock);

    Buradaki fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

    Fonksiyonların hepsi reader-writer lock nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri döner.

    4) Nesnenin kullanımı bittikten sonra nesne pthread_rwlock_destroy fonksiyonu ile boşaltılabilir. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

    Fonksiyon reader-writer lock nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri döner.

    5) Reader-writer lock nesnelerinin de bir özellik bilgisi vardır. Özellik oluşturma daha önce görmüş olduğumuz nesnelerdekine 
    benzer biçimde yapılmaktadır. Önce pthread_rwlockattr_t türünden bir özellik nesnesi tanımlanır. Sonra bu özellik nesnesine 
    pthread_rwlockattr_init fonksiyonu ile ilk değer verilir. Sonra da özellik nesnesine pthread_rwlockattr_setxxx fonksiyonlarıyla 
    özellikler iliştirilir. Sonra da bu özellik nesnesi kullanılarak reader-writer lock nesnesi pthread_rwlock_init fonksiyonuyla
    yaratılır. Aslında şu anda nesnenin tek bir özelliği vardır. O da onun prosesler arasında paylaşılabilirliğini belirtmektedir. 
    Nesne default durumda (yani PTHREAD_RWLOCK_INITIALIZER ile yatarıldığında ya da pthread_rwlock_init fonksiyonunda özellik 
    parametresi NULL geçildiğinde) prosesler arasında paylaşılamamaktadır. Prosesler arası paylaşım için pthread_rwlock_setpshared 
    fonksiyonu kullanılmaktadır. Bu bilginin alınması için de pthread_rwlock_getpshared fonksiyonu bulunmaktadır. Tabii özellik 
    nesnesinin kullanımı bittikten sonra (yani pthread_rwlock_init fonksiyonu çağrıldıktan sonra) onun pthread_rwlock_destroy 
    fonksiyonu ile boşaltılması gerekmektedir. Buradaki fonksiyonların prototipleri aşağıda verilmiştir

    #include <pthread.h>

    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte dört ayrı thread yaratılmıştır. İki thread okuma amaçlı, iki thread de yazma amaçlı kritik kodu girmektedir. 
    Bu örnek bir simülasyon niteliğindedir. Örnekte rastgele beklemeler yapılmıştır. Örnekten görülmesi gereken şey iç içe 
    read işleminin yapılabildiği ancak diğer işlemlerin iç içe yapılamadığıdır. Programın çalıştırılmasında aşağıdakine benzer
    bir çıktı oluşacaktır:

    thread3 ENTERS to critical section for WRITING...
    thread3 EXITS from critical section...
    thread2 ENTERS to critical section for READING...
    thread1 ENTERS to critical section for READING...
    thread1 EXITS from critical section...
    thread2 EXITS from critical section...
    thread4 ENTERS to critical section for WRITING...
    thread4 EXITS from critical section...
    thread1 ENTERS to critical section for READING...
    thread1 EXITS from critical section...
    thread3 ENTERS to critical section for WRITING...
    thread3 EXITS from critical section...
    thread2 ENTERS to critical section for READING...
    thread1 ENTERS to critical section for READING...
    thread2 EXITS from critical section...
    thread1 EXITS from critical section...
    ...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_errno(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void *thread_proc4(void *param);

pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;

int main(void)
{
    int result;
    pthread_t tid1, tid2, tid3, tid4;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid4, NULL, thread_proc4, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid4, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    pthread_rwlock_destroy(&g_rwlock);

    return 0;
}

void exit_sys_errno(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 12345;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread1 ENTERS to critical section for READING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread1 EXITS from critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 23456;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread2 ENTERS to critical section for READING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread2 EXITS from critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_unlock", result);
    }

    return NULL;
}

void *thread_proc3(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 35678;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_wrlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_wrlock", result);

        printf("thread3 ENTERS to critical section for WRITING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread3 EXITS from critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_unlock", result);
    }

    return NULL;
}

void *thread_proc4(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 356123;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_wrlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_wrlock", result);

        printf("thread4 ENTERS to critical section for WRITING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread4 EXITS from critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_unlock", result);
    }

    return NULL;
}

/*---------------------------------------------------------------------------------------------------------------------------
    İşlemcileri, CISC (Complex Instruction Set Computing) ve RISC (Reduced Instruction Set Computing) olmak üzere iki sınıfa 
    ayırabiliriz. Tabii bu iki sınıf aslında bir spektrumdur. Yani işlemciler bir tarafı CISC olan diğer tarafı RISC olan 
    bu spektrumda herhangi bir yerde olabilirler. Intel x86 işlemcileri CISC işlemlerine örnek oluştururken, ARM işlemcileri 
    RISC işlemlerine bir örnek oluşturmaktadır. İki işlemci ailesi arasında temel farklılıklar şunlardır:

    - CISC işlemlerinde çok sayıda makine komutu vardır. Bu komutların bazıları karmaşık işlemler yapmaktadır. Ancak RISC 
    işlemcilerinde az sayıda makine komutu daha etkin çalışacak biçimde tasarlanmıştır.

    - CISC işlemcilerinde makine komutları değişik uzunlukta olabilmektedir. Ancak CISC işlemcilerinde tüm makine komutları 
    aynı uzunluktadır.

    - CISC işlemcilerinde az sayıda genel amaçlı CPU yazmacı vardır. Ancak RISC işlemcilerinde çok sayıda genel amaçlı CPU 
    yazmacı bulunmaktadır.

    - CISC işlemcilerinde komutlar değişik çalışma sürelerine sahiptir. Ancak RISC işlemcilerinde genellikle aynı çalışma 
    süresine sahiptir.

    - RISC işlemcilerinde pipeline işlemleri CISC işlemcilerine göre daha etkin yapılabilmektedir.

    - CISC işlemcilerinde doğrudan bellek üzerinde işlem yapan makine komutları bulunmaktadır. RISC işlemcilerinde ise bellek 
    üzerinde doğrudan işlemler yapılmaz. Her zaman bellekteki nesneler önce CPU yazmaçlarına çekilir. Bu yüzden RISC işlemcilerine 
    "load/store" işlemcileri denilmektedir.

    - CISC işlemcilerinde genel olarak makine komutlarının iki operand'ı bulunur. İşlem sonrasında, işleme giren bir yazmacın 
    değeri bozulmaktadır. Ancak RISC işlemcilerinde makine komutlarının genel olarak üç operand'ı bulunmaktadır. İşlem sonucu 
    operand'ları bozmamaktadır.

    - CISC işlemcileri daha fazla güç harcama eğilimdedir. Ancak RISC işlemcileri daha az güç harcama eğilimindedir.

    Bugün artık RISC tasarımının daha iyi bir tasarım olduğu kabul edilmektedir. Ancak Intel x86 serisi gibi bazı işlemciler 
    çok yaygın kullanıldığı için halen CISC mimarisini devam ettirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bugün çok işlemcili ve çok çekirdekli sistemlerde işlemci-bellek bağlantısında iki mimari kullanılmaktadır:

    - SMP (Symmetric Multiprocessor) Mimarisi
    - NUMA (Non Unified Memory Access) Mimarisi

    SMP mimarisi pek çok işlemci tarafından default olarak kullanılan mimaridir. Bu mimaride işlemciler ya da çekirdekler 
    aynı RAM'e erişmektedir. Dolayısıyla "bus" çakışmasını ortadan kaldırmak için bir işlemci ya da çekirdek RAM'e erişirken 
    diğerleri onun işini bitirmesini beklemektedir. Dolayısıyla bu mimaride aslında işlemci ya da çekirdek sayısı arttıkça
    bus çakışmaları da artar ve performans düşmeye başlar. Tabii bu mimaride, her işlemcinin ve çekirdeğin ayrı bir cache 
    sistemi de bulunmaktadır. Bu işlemciler ya da çekirdekler önce bu cache sistemine başvurmakta bilgi orada yoksa RAM'e 
    başvurmaktadırlar. Tabii cache tutarlılığı (cache consistency) da donanımsal olarak sağlanmaktadır.

    NUMA mimarisinde her işlemcinin ya da her çekirdeğin RAM'de bağımsız olarak erişebileceği ayrı bir bank'ı vardır. Her 
    işlemci ya da çekirdek kendi bank'ına hızlı erişir ancak diğer işlemcilerin ya da çekirdeklerin bank'larına yavaş erişir. 
    Bu nedenle işlemcilerin ve çekirdeklerin belleğe erişim süreleri eriştikleri yere bağlı olarak (non unified) değişebilmektedir. 
    Bugün NUMA mimarisini kullanan işlemciler ve board'lar oldukça azdır. Örneğin Intel Xeon, AMD EPYC, AMD Opteron gibi 
    işlemciler NUMA mimarisini kullanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'ler dünyasında "atomiklik (atomicity)" bir işlemin kesilmeden tek parça halinde yapılmasına denilmektedir. Atomik 
    işlemler tek bir parça halinde thread'ler arası geçiş oluşmadan yapılan işlemlerdir. Pekiyi makine komutları atomik midir?
    Genel olarak makine komutlarının atomik olduğunu söyleyebiliriz. Yani bir makine komutu çalıştırılırken kesilme olmaz. 
    Bir makine komutu çalıştırılırken çalıştırmanın ortasında thread'ler arası geçiş oluşamaz. Çünkü thread'ler arası geçiş 
    donanım kesmeleriyle sağlanmaktadır. Donanım kesmeleri de ancak makine komutlarının arasında etkili olabilmektedir.

    Pekiyi iki işlemci ya da çekirdek aynı global değişkeni aynı anda değiştirmek isteseler ne olur? Burada normalde 
    hangisi bu işlemi geç yaparsa o değişkende o değer gözükecektir. Peki aynı anda bu işlemi yaparlarsa ne olacaktır? 
    Her ne kadar işlemciler ya da çekirdekler RAM'e erişirken diğerleri onu bekliyorsa da (yani erişim aslında aynı anda 
    gerçekleşmiyorsa da) yine de özel bazı durumlarda değişkende bozulmalar olabilmektedir. Şöyle ki, aşağıdaki gibi bir
    INTEL makine komutunu düşünelim:

    INC g_count

    Bu komut çalışırken her ne kadar thread'ler arası geçiş oluşmayacak olsa da maalesef duruma INTEL işlemcisi ya da 
    çekirdeği bu işlem sırasında işlemin başından sonuna kadar BUS'ı tutup işlemi atomik yapmamaktadır. Bu tarz işlemlerde 
    INTEL işlemcileri bus'ı tutup bırakmakta yeniden tutup bırakmakta yani birden fazla kez kesikli bir biçimde bus'ı tutup 
    bırakabilmektedir. İşte bu işlemler sırasında başka bir işlemci ya da çekirdek bus'ın kontrolünü alıp oraya bir şeyler 
    yazmak isteyebilir. Bu durumda o nesnede bozuk bir değer oluşabilir. Tabii bunun olasılığı çok düşüktür. Ancak böyle 
    bir olasılık söz konusu olmaktadır. Şimdi INTEL mimarisinde, iki ayrı çekirdeğin aynı global değişkene tek bir makine 
    komutuyla atama yaptığını düşünelim:

    Birinci Çekirdek:

    MOV g_val, 100

    İkinci Çekirdek:

    MOV g_val, 200

    Burada g_val içerisinde 100 ya da 200 olması normal karşılanacak bir durumdur. Ancak bozuk bir değerin bulunması istenemeyen
    bir durumdur. İşte INTEL işlemcilerinde buradaki g_val belleğe düzgün hizalanmamışsa böyle riskli bir durum oluşabilmektedir.

    Tabii işlemciler genellikle bu biçimdeki erişimlerde makine komutlarının sonuna kadar bus'ın tutulması için de olanak 
    sağlamaktadır. Örneğin INTEL işlemcilerinde komutun başına LOCK prefix'i sayesinde işlemci baştan sona kadar bus'ı tutabilmektedir:

    LOCK INC g_val

    Tabii buradaki LOCK prefix'i komutu yavaşlatmaktadır. Bu durumda derleyiciler böyle bir prefix'i default durumda kullanmazlar.

    Biz daha önce iki thread'in aynı global değişkeni artırmasına yönelik bir örnek yapmıştık:

    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    Elimizdeki C derleyicilerinin çoğu bu artırım işlemini tek bir makine komutuyla değil üç ayrı makine komutuyla yapmaktadır. 
    Çünkü aslında bu üç ayrı makine komutu doğrudan belleği artıran makine komutundan daha hızlı çalışmaktadır:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Tabii artık artırma işlemi atomik olmadığı için thread'ler arası geçiş değişkende bozulma yaratacaktır. Biz bu bozulmayı 
    engellemek için kritik kod bloğu oluşturmuştuk. Pekiyi derleyicimiz yukarıdaki artırma için yavaş olmasına karşın tek bir 
    makine komutu üretseydi bu durumda bozulma oluşur muydu?

    INC g_count

    İşte koşullara bağlı olarak olasılık düşük olsa bile bu durumda bozulma olasılığı yine vardır. Tabii derleyicimiz tek bir 
    makine komutu ile bu işlemi yapıp komutun başına da LOCK gibi bir prefix getirseydi bu durumda bir sorun oluşmazdı:

    LOCK INC g_count

    Burada önemli nokta şudur: Aslında biz tek bir makine komutu ile yapılacak bazı işlemlerin atomik bir biçimde yapılmasını 
    sağlayabiliriz. Ancak derleyicimiz bunu bizim için sağlayamamaktadır. Bazı C derleyicilerinde C ile yazarken arada sembolik 
    makine kodlarını kullanabilmekteyiz. Bu kullanım derleyiciye özgüdür ve bu kullanımın ismine "inline assembly" denilmektedir. 
    Ancak "inline assembly" yazmak zahmetlidir va makine dili bilgisi gerektirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                64. Ders 08/07/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bazı C derleyicilerinde "built-in" ya da "intrinsic" fonksiyon denilen bir kavram vardır. Derleyiciler tarafından prototipe
    gereksinim duyulmadan tanınan ve ne yaptığı bilinen özel fonksiyonlara "built-in" ya da "intrinsic" fonksiyonlar denilmektedir. 
    Tabii bu kavramlar C standartlarında yoktur. Eklenti (extension) biçiminde C derleyicilerinde bulunmaktadır. Bazı built-in 
    ya da intrinsic fonksiyonlar makro gibi derleyici tarafından özel makine komutları ile açılmaktadır. Bazı built-in ya da 
    intrinsic fonksiyonlar ise makro gibi açılmamalarına karşın derleyici bunların ne yaptığını bildiği için o işlemlerde 
    optimizasyon uygulayabilmektedir. Örneğin:

    for (int i = 0; i < strlen(s); ++i) {
        ...
    }

    Normal olarak derleyici strlen fonksiyonunun ne yaptığını bilmediği için burada optimizasyon uygulayıp çağrıyı döngü 
    dışına alamaz. Ancak ilgili derleyicide strlen fonksiyonu aynı zamanda built-in ya da intrinsic bir fonksiyonsa derleyici
    burada bu optimizasyonu yapabilir.

    Her derleyicinin built-in ya da intrinsic fonksiyon listesi diğerinden farklı olabilmektedir. gcc derleyicilerinin built-in 
    fonksiyonlarına aşağıdaki bağlantıdan erişilebilir:

    https://gcc.gnu.org/onlinedocs/gcc/x86-Built-in-Functions.html

    gcc'de bazı built-in fonksiyonlar atomik işlemler için bulundurulmuştur. Ancak gcc'de önceleri bu atomic built-in fonksiyonlar
    __sync_xxx biçiminde isimlendirilmişti. Sonra C++'a <atomic> kütüphanesi eklenince C++ kütüphanesi de kullanabilsin diye
    bu eski __sync_xxx isimli fonksiyonlar yerine bunların "memory model" parametresi alan __atomic_xxx versiyonları oluşturuldu. 
    Artık yeni programların __atomic_xxx biçimindeki bu yeni fonksiyonları kullanması tavsiye edilmektedir. Her iki fonksiyon 
    grubunun dokümanlarına ilişkin bağlantıları aşağıda veriyoruz:

    https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/_005f_005fatomic-Builtins.html
    https://gcc.gnu.org/onlinedocs/gcc-4.1.0/gcc/Atomic-Builtins.html

    __atomic_xxx fonksiyonlarındaki "memory model" parametresi __ATOMIC_SEQ_CST olarak girilebilir. Biz burada bu memory model 
    parametresinin ne anlam ifade ettiği üzerinde durmayacağız.

    Örneğin bir nesneyi atomic bir biçimde 1 artırmak isteyelim. Hiç mutex kullanmadan bunu gcc derleyicilerinde şöyle yapabiliriz:

    __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    Bir değişkene yalnızca değer atamak için aşağıdaki atomic fonksiyon kullanılabilir:

    void __atomic_store_n(type *ptr, type val, int memmodel);
    void __atomic_store(type *ptr, type *val, int memmodel);

    Benzer biçimde bir nesnenin içerisindeki değeri almak için de aşağıdaki atomic fonksiyonlar kullanılabilir:

    void __atomic_load_n (type *ptr, int memmodel);
    void __atomic_load (type *ptr, type *ret, int memmodel);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte global bir değişken iki thread tarafından atomic bir biçimde artırılmıştır. Biz daha önce aynı örneği 
    mutex ve spinlock senkronizasyon nesneleri için de vermiştik. Aşağıda aynı örneğin mutex ve spinlock versiyonlarını da 
    yeniden veriyoruz. Örneğin yapıldığı 2 çekirdekli sanal makinede elde edilen sonuçlar şöyledir:

    Atomic versiyon: 1.86 saniye
    Mutex versiyonu: 4.30 saniye
    Spinlock versiyonu: 2.83 saniye

    Görüldüğü gibi en hızlı yöntem artırma işleminin atomic yapılmasıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* atomic.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* mutex.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);

        ++g_count;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_lock", result);

            ++g_count;

            if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* spinlock.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_spinlock_t g_spinlock;
int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_spin_init(&g_spinlock, 0)) != 0)
        exit_sys_errno("pthread_spin_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_spin_destroy(&g_spinlock)) != 0)
        exit_sys_errno("pthread_spin_destroy", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki anlatımdan da anlaşılacağı gibi atomic built-in ya da intrinsic fonksiyonlar derleyiciler arasında taşınabilir 
    değildir. Örneğin gcc'deki __atomic_xxx_ fonksiyonları yerine Microsoft sistemlerinde InterlockedXXX fonksiyonları kullanılmaktadır. 
    İşte bu tür atomic işlemlerde taşınabilirliği sağlamak için zamanla programlama dillerininin sentaks ve semantiğine atomic 
    işlemler eklenmiştir.

    C11 ile birlikte C'ye thread kavramı sokulunca atomic işlemler de dile "isteğe bağlı olarak (optional)" dahil edilmiştir. 
    C11'de _Atomic anahtar sözcüğü "bir tür niteleyicisi (type qualifier)" olarak eklenmiştir. (Yani sentaks bakımından _Atomic 
    niteleyicisi 
    const ve volatile gibi bir tür niteleyicisi grubundadır.) Örneğin:

    _Atomic int g_count;

    Burada g_count nesnesi atomic olarak tanımlanmıştır. Ayrıca C11'de _Atomic anahtar sözcüğü parantezli biçimiyle bir 
    "tür belirleyicisi (type specifier)" olarak da kullanılabilmektedir. Örneğin:

    _Atomic(int) g_count;

    Bu bakımdan "tür niteleyicisi (type qualifier)" ve "tür belirleyicisi (type specifier)" kullanımları arasında göstericiler
    söz konusu olduğunda farklılıklar oluşabilmektedir. Ancak genellikle programcılar tür niteleyicisi kullanımını tercih 
    etmektedir. Ayrıca C11 ile birlikte <stdatomic.h> başlık dosyası da standartlara eklenmiştir. Bu dosya içerisinde çeşitli 
    atomic fonksiyonların prototipleri bulunmaktadır. Aynı zamanda _Atomic tür niteleyicisi ile oluşturulmuş bazı typedef 
    isimleri de bulunmaktadır. Bu typedef isimlerinin oluşturulma biçimleri aşağıdaki gibidir:

    typedef atomic_bool _Atomic _Bool;
    typedef atomic_char _Atomic char;
    typedef atomic_schar _Atomic signed char;
    typedef atomic_uchar _Atomic unsigned char;
    typedef atomic_short _Atomic short;
    typedef atomic_ushort _Atomic unsigned short;
    typedef atomic_int _Atomic int;
    typedef atomic_uint _Atomic unsigned int;
    typedef atomic_long _Atomic long;
    typedef atomic_ulong _Atomic unsigned long;
    typedef atomic_llong _Atomic long long;
    typedef atomic_ullong _Atomic unsigned long long;
    ...

    Bu durumda örneğin:

    _Atomic int g_count;

    tanımlaması ile aşağıdaki tanımlama eşdeğerdir:

    atomic_int g_count;

    atomic nesnelerin =, ++, --, +=, *=, ... gibi operatörlerle kullanılmasında derleyici işlemleri tıpkı __atomic_xxx 
    fonksiyonlarında olduğu  gibi atomic bir biçimde yapmaktadır. Dolayısıyla örneğin atomic işlemler için gcc'nin built-in 
    __atomic_xxx fonksiyonları yerine doğrudan C11 ile gelen _Atomic niteleyicisi tercih edilebilir.

    C11 ile birlikte gelen _Atomic tür niteleyicisi ve tür belirleyicisinin ve <stdatomic.h> dosyasının bazı ayrıntıları vardır. 
    Biz burada bu ayrıntılara girmeyeceğiz. Bunlar için uygun dokümanlara başvurabilirsiniz.

    C11'deki atomic konusu standartlara "isteğe bağlı (optional)" bir öğe olarak eklenmiştir. Yani her C derleyicisi bunu 
    desteklemek zorunda değildir. (Örneğin bir gömülü sistemde atomic işlemlerin bir anlamı olmayabilir ya da atomic'lik 
    ilgili işlemcide bulunmayabilir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz global nesneyi artırma örneğini bu kez aşağıda C11'deki _Atomic tür niteleyicisi ile yeniden 
    yapıyoruz. Burada programın çalışma zamanı __atomic_xxx built-in fonksiyonunu kullandığımız örnekle çok benzerdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* atomic.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

_Atomic int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        ++g_count;

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        ++g_count;

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Atomic işlemler için C++11'e atomic isimli sınıf şablonu eklenmiştir. Bu sınıf şablonunda tür parametresi atomic nesnenin 
    türünü belirtmektedir. Örneğin:

    #include <atomic>
    ...

    atomic<int> g_count;

    Yukarıdaki örneğin C++'ın atomic sınıfı ile gerçekleştirimi aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* atomic.cpp */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <atomic>
#include <pthread.h>

using namespace std;

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

atomic<int> g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", (int)g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        ++g_count;

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        ++g_count;

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi birden fazla thread'e sahip bir proseste fork işlemi yapıldığında yaratılan alt proses
    her zaman tek bir thread'e sahip olur. O thread de fork işleminin yapıldığı thread'tir. Örneğin biz programamızda 10 tane
    thread yaratmış olalım. Bu thread'lerden birinde fork yaptığımızı düşünelim. Üst prosesin bütün bellek alanı alt prosese
    kopyalanacaktır. Ancak alt proseste yalnızca tek bir thread akışı bulunacaktır. Bu akış da fork işleminin yapıldığı thread 
    akışı olacaktır. Yani alt proses her zaman çalışmasına tek bir thread ile başlamaktadır. Tabii daha önceden de belirttiğimiz
    gibi bir prosesin son thread'i de sonlandığında prosesin çalışması işletim sistemi tarafından sonlandırılır. Bu durumda 
    örneğin üst proseste fork yapan thread, main thread değilse programın akışı exit fonksiyonunu hiç görmeyebilir. Ancak bu 
    thread bittiğinde zaten proses otomatik sonlandırılmaktadır.

    Thread'li bir programda fork işlemi yapıldığında alt proseste yalnızca fork işlemini yapan thread'in yaratılmış olacağını 
    belirtmiştik. Tabii fork işlemi sırasında proseslerin tüm bellek alanları kopyalandığına göre pthread_t türü ile temsil 
    edilen thread id değerleri de kopyalanmaktadır. Yani fork işlemi sonrasında üst prosesin fork işlemini yapan thread'in 
    id'si ile alt prosesin bu thread'e ilişkin id'leri aynı olacaktır. Thread id'lerin prosese özgü olduğunu anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üst proses iki thread yaratmıştır. Üst proses bu iki thread'i yarattıktan sonra ana thread'te fork 
    işlemi yapmıştır. Bu durumu alt proses yalnızca ana thread akışına sahip olacaktır. Örnekte alt prosesteki ana thread'te
    pthread_exit fonksiyonu ile bu ana thread'te sonlandırılmıştır. Bu durumda alt proses otomatik olarak sonlandırılacaktır. 
    Dolayısıyla biz yalnızca üst prosesin thread akışlarının stdout dosyasına yazdıklarını göreceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int err);

int main(void)
{
    int result;
    pthread_t tid1, tid2;
    pid_t pid;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        printf("parent process\n");
    else
    {
        printf("child process\n");
        pthread_exit(NULL);
    }

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üst proses iki ayrı thread yaratmıştır. Ancak fork işlemi bu thread'lerden birinde yapılmıştır. Alt 
    proseste yalnızca fork işleminin yapıldığı thread'in çalıştığına dikkat ediniz. Tabii yine alt proses akışı aslında 
    exit fonksiyonu hiç görmemektedir. Ancak bir prosesin son thread'i sonlandığında zaten proses işletim sistemi tarafından
    sonlandırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int err);

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int i;
    pid_t pid;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        if (i == 10) {
            if ((pid = fork()) == -1)
                exit_sys("fork");
        }
        sleep(1);
    }

    if (pid != 0 && waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bazı çok thread'li uygulamalarda bir thread'in fork işlemi yapması durumunda üst ve alt proseslerde otomatik olarak bazı
    işlemlerin yapılması gerekebilmektedir. Ancak böylesi durumlara oldukça seyrek gereksinim duyulmaktadır. İşte bir thread 
    fork yaptığında üst ve alt proseslerde bazı fonksiyonların otomatik çağrılmasını sağlamak için pthread_atfork isimli bir 
    POSIX fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));

    pthread_atfork fonksiyonu üç fonksiyonu parametre olarak almaktadır. Birinci fonksiyon üst proses tarafından henüz alt 
    proses yaratılmadan çağrılmaktadır. İkinci fonksiyon üst proses tarafından alt proses yaratıldıktan sonra çağrılır. 
    Üçüncü fonksiyon ise alt proses tarafından alt proses yaratıldığında çağrılmaktadır. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda errno değerine geri dönmektedir.

    pthread_atfork fonksiyonu birden fazla kez çağrılabilir. Bu durumda prepare, parent ve child fonksiyonları ters sırada 
    çağrılır.

    Aşağıda pthread_atfork fonksiyonunun kullanımına ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void prepare(void);
void parent(void);
void child(void);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int err);

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_atfork(prepare, parent, child)) != 0)
        exit_sys_errno("pthread_atfork", result);

    if ((result = pthread_atfork(prepare, parent, child)) != 0)
        exit_sys_errno("pthread_atfork", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int i;
    pid_t pid;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        if (i == 10) {
            if ((pid = fork()) == -1)
                exit_sys("fork");
        }
        sleep(1);
    }

    if (pid != 0 && waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void prepare(void)
{
    printf("prepare handler...\n");
}

void parent(void)
{
    printf("parent handler...\n");
}

void child(void)
{
    printf("child handler...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'li uygulamalarda fork yaparken senkronizasyon nesnelerine dikkat edilmelidir. Çünkü fork işlemi sırasında üst
    prosesteki başka bir thread o anda mutex gibi bir nesneyi kilitlemiş olabilir. Bu durumda üst prosesin başka bir thread'i
    fork yaptığında alt proseste bu mutex nesnesi kilitli gibi olacaktır. Alt proseste bu mutex kullanılmak istendiğinde 
    zaten kilitli olduğu için deadlock oluşabilecektir. Çünkü artık alt proseste onu kilitlemiş olan thread bulunmadığı için 
    kilit açılmayacaktır. Örneğin üst prosesteki bir thread aşağıdaki gibi bir kritik kod oluşturmuş olsun:

    thread_proc1()
    {
        ...
        pthread_mutex_lock(&g_mutex);
        ...
        ...    <DİKKAT! Diğer thread burada fork yapmış olabilir>
        ...
        pthread_mutex_unlock(&g_mutex);
        ...
    }

    Üst prosesin diğer bir thread'i bu thread kritik kodun içerisinde fork yapmış olabilir:

    thread_proc2()
    {
        ...
        if ((pid = fork()) == -1)
            exit_sys("fork");
        if (pid == 0) {
            /* child process */
            do_something();
        }
        ...
    }

    Şimdi artık alt proseste bu mutex nesnesi kilitli durumda olacaktır. Çünkü fork işlemi sırasında üst prosesin bütün bellek 
    alanı dolayısıyla mutex'in kilitli olduğuna ilişkin bilgiler de alt prosese aktarılmış olacaktır. Artık bu mutex kilidinin 
    açılma olasılığı yoktur. Dolayısıyla örnekte do_something fonksiyonun içerisinde de kritik kod varsa orada deadlock oluşacaktır.

    İşte bu tür durumlarda pthread_atfork fonksiyonu yararlı bir işlev görebilir. Şöyle ki; fork işleminden önce prepare 
    fonksiyonunda mutex nesnesinin kilidi açılabilir. Bu durumda mutex alt prosese kilidi açık bir biçimde aktarılacaktır. 
    Sonra üst proses, parent fonksiyonunda yine onu kilitleyebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında thread'li programlarda exec amacı olmadan fork işlemi yapmak genellikle kötü bir tekniktir. Çünkü zaten thread'ler 
    proseslerin aynı bellek alanı içerisinde çalışan biçimleri gibidir. Yani aslında thread'li uygulamalarda exec amacıyla 
    olmayan fork gereksinimi de genellikle olmamaktadır. Ancak bazı durumlarda yine de thread'li uygulamalarda fork işleminin 
    yapılması gerekebilmektedir. Programcı, thread'li uygulamalarda mutlak gerekmiyorsa, exec amacıyla olmayan fork işlemi 
    yapmaktan kaçınmalıdır. Thread'li programlarda, programcı exec amacıyla fork yapmış olabilir. Thread'li uygulamalarda 
    exec için fork yapma işlemine nispeten daha fazla gereksinim duyulabilmektedir. Thread'li programlarda alt prosesin fork 
    işleminden sonra exec uygulaması genel olarak probleme yol açmamaktadır. Çünkü exec işlemi ile zaten prosesin bellek alanı 
    tamamen yok edilmektedir. Pekiyi thread'li bir program hiç fork yapmadan exec yaparsa ne olur? İşte thread'li bir program 
    exec işlemi uygularsa prosesin exec yapan thread'i dışındaki tüm thread'leri sonlandırılır. Dolayısıyla exec işlemi 
    sonrasında yine exec yapılan program tek thread'le çalışmaya başlar.

    Özetle thread'li programlarda fork-exec işlemleri için şunlar söylenebilir:

    1) Thread'li programlarda exec amacıyla fork yapmakta sakınca yoktur. Ancak exec amacı olmadan fork yapmak genel olarak 
    kötü bir tekniktir.

    2) Thread'li uygulamalarda fork işlemi sonrasında tek bir thread alt proseste çalışır. Bu thread'te fork işlemini yapan 
    thread'tir.

    3) Thread'li programlarda fork olmadan exec uygulanırsa exec yapılan program yine tek thread'le çalışmaya başlar. Yani 
    proseste o ana kadar yaratılmış olan bütün thread'ler sonlandırılır. Yalnızca exec işlemini yapan thread exec edilen 
    programı çalıştırır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                65. Ders 09/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde proseslerin ve thread'lerin CPU'ya atanıp zaman paylaşımlı olarak çalıştırılmasına proses ya da 
    thread çizelgelemesi denilmektedir. Eskiden thread'ler yokken çizelgelenen şeyler proseslerdi. Ancak daha sonra işletim 
    sistemine thread'ler sokulduğunda artık thread temelinde çizelgeleme yöntemi uygulanmaya başlandı. Bugün Windows, Linux 
    ve macOS gibi sistemler thread temelinde çizelgeleme uygulamaktadır. Yani bu işletim sistemleri thread'leri zaman paylaşımlı 
    biçimde CPU'ya atayıp çalıştırmaktadır. İşletim sistemlerinin thread'leri (eskiden prosesleri) çizelgelemekte kullandığı 
    algoritmalara "çizelgeleme algoritmaları (scheduling algorithms)" denilmektedir. Tarihsel süreç boyunca işletim sistemlerinde 
    çeşitli çizelgeleme algoritmaları denenmiştir. Bu çizelgeleme algoritmaları bazı somut hedefleri gerçekleştirmeye çalışmaktadır. 
    Örneğin "birim zamanda yapılan iş miktarı (throughput)" önemli bir performans ölçütüdür. Thread'ler arası geçiş (context 
    switch) belli bir zaman aldığı için bu zamanın thread'lere ayrılan zamana göre makul olması istenir. İnteraktivite diğer 
    önemli bir ölçüttür. İlgili thread uzun süre çalışmadan bekletilirse bu durum interaktiviteyi olumsuz etkiler ve gerçek 
    zamanlı olayların izlenmesini zorlaştırır. Bir işin toplamda ne kadar sürede bitirileceği (turnaround time) diğer bir 
    ölçüttür.

    Günümüzde en yaygın kullanılan çizelgeleme algoritması "döngüsel çizelgeleme (round robin scheduling)" denilen algoritmadır. 
    Bu algoritmada kabaca thread'ler ismine "çalışma kuyruğu (run queue)" denilen bir kuyruk sisteminde tutulur. Sonra bu 
    kuyruktanalınarak CPU'ya atanır. Belli bir quanta süresi kadar çalıştırılır. Sonra CPU'dan preemptive biçimde (zorla) 
    koparılır. Kuyruktaki sırada thread CPU'ya atanır. Döngüsel çizelgeleme adil bir çizelgeleme yöntemidir. Bir thread 
    CPU'ya atanmışken bloke olduğunda "çalışma kuyruğundan (run queue)" çıkartılır ve o olaya ilişkin bir "bekleme kuyruğuna 
    (wait queue)" yerleştirilir. Blokede bekleyen thread'lerin ilgili olay gerçekleştiğinde yeniden çalışma kuyruğuna yerleştirilmesi 
    genellikle "kesme (interrupt)" mekanizmasıyla sağlanmaktadır. Örneğin bir thread'in sleep fonksiyonu ile 10 saniye beklemek 
    istediğini düşünelim. Bu durumda, bu sleep fonksiyonun içerisinde işletim sistemi thread'i çalışma kuyruğundan çıkartıp 
    sleep için oluşturulan bekleme kuyruğuna yerleştirir. Pekiyi 10 saniyenin geçtiğini işletim sistemi nasıl anlayacaktır? İşte 
    aslında modern işletim sistemlerinde periyodik "timer kesmeleri" oluşturulmaktadır. Örneğin Linux sistemlerinde aslında 
    her bir milisaniyede bir timer kesmesi oluşup işletim sisteminin bir kodu devreye girmektedir. (Linux sistemlerinde buna 
    "jiffy" de denilmektedir.) Bu kod sleep kuyruklarına da bakmakta ve süresi dolan thread'leri yeniden çalışma kuyruğuna 
    yerleştirmektedir. Örneğin bir thread bir soketten okuma yapmak istesin ancak sokete henüz bilgi gelmemiş olsun. İşletim 
    sistemi thread'i bloke ederek çalışma kuyruğundan çıkartır ve ilgili bekleme kuyruğuna yerleştirir. Network kartına bir 
    paket geldiğinde bir kesme de oluşmaktadır. Bu kesme sayesinde network kartına gelen paket işletim sistemi tarafından 
    alınır. Böylece bilginin gelmesini bekleyen thread de uyandırılarak bekleme kuyruğundan yeniden çalışma kuyruğuna 
    yerleştirilir. O halde belli bir zamanda çalışma kuyruğunda belli miktarda thread bulunurken bekleme kuyruklarında da belli 
    miktarda thread bloke durumda bulunmaktadır.

    Döngüsel çizelgelemenin çeşitli varyasyonları vardır. Örneğin Windows sistemlerinde "öncelik sınıfı temelinde döngüsel 
    çizelgeleme" yöntemi kullanılmaktadır.

    Linux sistemlerinde çizelgeleme algoritması temel olarak "döngüsel çizelgeleme" esasına dayanmaktadır. Ancak bu algoritma 
    Linux tarihi boyunca üç kez değiştirilmiştir. Linux'un ilk versiyonları uzunca bir süre özel bir isim verilmeyen bir döngüsel 
    çizelgeleme algoritması kullanıyordu. Sonra çekirdeğin 2.6 versiyonlarıyla (2003) birlikte "O(1) çizelgelemesi" denilen yeni 
    bir algoritma kullanılmaya başlandı. Daha sonra çekirdeğin 2.6.23 versiyonu ile birlikte (2007) şu anda kullanılmakta olan 
    "CFS (Completely Fair Scheduling)" algoritmasına geçilmiştir. Tabii izleyen paragraflarda da ele alınacağı gibi UNIX türevi 
    sistemlerde proseslerin "çizelgeleme politikaları (process scheduling policy)" vardır. Buradaki algoritmalar SCHED_NORMAL 
    ya da SCHED_OTHER denilen politikalar için özellikle etkili olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her prosesin bir "çizelgeleme politikası (scheduling policy)" vardır. POSIX standartlarına göre 
    proseslerin çizelgeleme politikaları şunlardan biri olabilir:

    SCHED_FIFO
    SCHED_RR
    SCHED_OTHER
    SCHED_SPORADIC

    SCHED_SPORADIC çizelgelemesi isteğe bağlı tutulmuştur ve Linux sistemlerinde desteklenmemektedir. POSIX standartlarında
    SCHED_FIFO ve SCHED_RR çizelgelemelerine "gerçek zamanlı (realtime) çizelgeleme politikaları" denilmektedir. Prosesin 
    çizelgeleme politikası fork işlemi sırasında üst prosesten alınmaktadır. Linux'ta default çizelgeleme politikası SCHED_OTHER
    biçimindedir. Linux dünyasında bu çizelgeleme politikasına SCHED_NORMAL da denilmektedir. (Ancak SCHED_NORMAL POSIX standartlarında
    bulunmamaktadır.) Linux'ta ayrıca POSIX standartlarında olmayan SCHED_BATCH ve SCHED_IDLE çizelgeleme politikaları da vardır. 
    POSIX standartlarında prosesin default çizelgeleme politikasının ne olacağı konusunda bir belirlemede bulunulmamıştır. Ancak 
    sistemlerin hemen hepsinde default çizelgeleme politikası SCHED_OTHER biçimindedir.

    POSIX standartlarına göre bir prosesin çizelgeleme politikası onun bütün thread'lerinin çizelgeleme politikasını belirlemektedir. 
    Yani örneğin POSIX standartlarına göre biz prosesin çizelgeleme politikasını değiştirirsek onun mevcut ve yaratılacak olan 
    bütün thread'lerinin çizelgeleme politikasını değiştirmiş oluruz. Ancak Linux sistemleri bu bağlamda POSIX standartlarına 
    uymamaktadır. Linux sistemlerinde bir prosesin çizelgeleme politikası değiştirildiğinde yalnızca onun ana thread'inin 
    çizelgeleme politikası değiştirilmiş olmaktadır.

    POSIX standartlarında SCHED_FIFO ve SCHED_RR çizelgeleme algoritmaları açıkça tanımlanmıştır. Ancak SCHED_OTHER çizelgeleme 
    politikası işletim sistemlerini yazanların isteğine bırakılmıştır. Yukarıda da belirttiğimiz gibi UNIX türevi sistemlerde 
    genellikle proseslerin default çizelgeleme politikaları SCHED_OTHER biçimindedir. Bu SCHED_OTHER çizelgeleme politikası da 
    işletim sistemlerini yazanların isteğine bırakılmıştır. (Ayrıca POSIX standartları SCHED_OTHER politikasının SCHED_FIFO ve 
    SCHED_RR ile aynı olabileceğini de belirtmiştir.) O halde mademki UNIX türevi sistemlerde genellikle proseslerin default 
    çizelgeleme politikaları SCHED_OTHER biçimindedir ve bu SCHED_OTHER da sistemden sisteme değişebilmektedir, o halde aslında 
    UNIX türevi istemlerde çizelgeleme algoritması sistemden sisteme değişebilir niteliktedir. Zaten yukarıda da bahsettiğimiz 
    gibi Linux'ta tarihsel olarak kullanılan üç çizelgeleme algoritması aslında SCHED_OTHER çizelgeleme politikasına ilişkindir. 
    Çünkü SCHED_FIFO ve SCHED_RR çizelgelemeleri zaten POSIX standartlarında açıkça tanımlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tipik olarak UNIX türevi işletim sistemlerinde SCHED_OTHER çizelgeleme politikası (ya da algoritması) kabaca şöyle 
    yürütülmektedir:

    1) İşletim sistemi "çalışma kuyruğundaki (run queue)" her thread için bir quanta sayaç değeri tutar. (Linux işletim 
    sisteminde thread'ler de task_struct yapısı ile temsil edildiği için bu quanta sayaç değeri task_struct içerisindedir.)
    Örneğin bu sayaç değerinin başlangıçta 200 olduğunu varsayalım. (Mevcut Linux sistemlerinde genellikle bir quanta sayaç 
    değeri 1 milisaniyedir.)

    2) Bir thread CPU'ya atandığında, her timer kesmesi oluştuğunda onun quanta sayacı bir eksiltilir. Günümüzdeki Linux 
    sistemlerinde genellikle timer kesmesi 1 milisaniyeye ayarlandığı için her bir milisaniye geçtiğinde bu quanta sayaç 
    değeri 1 eksiltilmektedir.

    3) İşletim sistemi timer kesmesinde (jiffy) thread'in quanta sayaç değeri 0'a düştüğünde thread'ler arası geçiş yoluyla 
    thread'in çalışmasına ara verir ve çalışma kuyruğundaki diğer thread'i CPU'ya atar.

    4) Genellikle işletim sistemleri CPU'ya atanacak thread'i belirlemek için çalışma kuyruğundaki tüm thread'lerin quanta
    sayaç değerlerine bakıp en yüksek quanta sayaç değerine sahip thread'i CPU'ya atamaktadır. Örneğin çalışma kuyruğunda 
    5 thread olsun bunların sayaç değerleri de aşağıdaki gibi olsun:

    T1: 120
    T2: 89
    T3: 0
    T4: 18
    T5: 0

    Şimdi varsayalım ki T3 thread'inin quanta sayacı 0'a düşmüş olsun ve thread'ler arası geçiş yapılsın. Burada T1 thread'i 
    CPU'ya atanacaktır.

    5) Pekiyi çalışma kuyruğunda quanta sayacı 0'a düşmüş olan thread'lerin yeni sayaçları ne zaman doldurulmaktadır? İşte genellikle 
    işletim sistemleri çalışma kuyruğundaki tüm thread'lerin quanta sayaçları 0'a düştüğünde hepsini birden doldurmaktadır. Yani 
    çalışma kuyruğundaki bir thread'in quanta sayacı 0'a düştüğünde onun quanta sayacı hemen doldurulmamakta, çalışma kuyruğundaki 
    tüm thread'lerin quanta sayaçları 0'a düştüğünde hepsi birden doldurulmaktadır. Bu durumda quanta sayacı 0'a düşen thread, 
    çalışma kuyruğundaki diğer thread'lerin hepsinin quanta sayacı 0'a düşene kadar CPU'ya atanmamaktadır.

    6) İşletim sistemi yalnızca çalışma kuyruğundaki thread'leri çizelgelemektedir. Bir thread çalışırken bloke olduğunda çalışma
    kuyruğundan çıkartılıp bekleme kuyruklarına alınır. Artık işletim sistemi o thread'i CPU'ya atamaya çalışmaz. Şimdi bir thread'in 
    quanta sayacı 100'e geldiğinde bloke olduğunu düşünelim. İşletim sistemi de çalışma kuyruğundaki en yüksek sayaçlı thread'i
    CPU'ya atamış olsun ve bu biçimde çalışma kuyruğundaki tüm thread'lerin sayaçları 0'a düşmüş olsun. Pekiyi doldurma işleminde,
    bekleme kuyruklarındaki thread'lere de doldurma yapılacak mıdır? İşletim sistemleri genellikle onlara da doldurma yapar. Ancak 
    bir üst sınır da belirlemektedir. Yani bizim bekleme kuyruğundaki thread'imizin quanta sayacı 100 olsun. Şimdi çalışma kuyruğundaki
    her thread'e doldurma yapılacak olsun. Bu quanta sayacı 100 olan thread'e de doldurma yapılacaktır. Yani bu thread uyandığında 
    daha fazla CPU zamanı kullanacaktır. Böylesi bir sistemin daha adil olduğu düşünülmektedir.

    7) Pekiyi çalışma kuyruğundaki tüm thread'lerin quanta sayaçları 0'a düşmüş olsun. İşletim sistemi de onların quanta sayaçlarını 
    yeniden dolduracak olsun. Hepsini aynı değerle mi dolduracaktır? İşte SCHED_OTHER çizelgeleme politikasına sahip olan thread'ler 
    için bu doldurma değeri onların "nice" değeri ya da "dinamik öncelikleri" denilen bir değerle orantılı bir biçimde yapılmaktadır. 
    POSIX standartları bu nice değerinin bu konuda etkili olacağını söylemiş olsa da hiçbir ayrıntı vermemiştir. nice değerinin 
    etkisi SCHED_OTHER politikasına özgüdür ve sistemden sisteme değişebilir. Örneğin Linux'ta CFS algoritmasında nice değerinin 
    etkisi önceki klasik çizelgeleme ve O(1) çizelgelemesine göre biraz daha artırılmıştır.

    Biz yukarıda tipik olarak bir UNIX türevi sistemin SCHED_OTHER politikasında nasıl döngüsel çizelgeleme yaptığını kabaca 
    açıkladık. Ancak işletim sistemlerinin çizelgeleyici alt sistemlerinin pek çok ayrıntıları vardır. Linux'un CFS algoritmasının 
    ayrıntılarını ilgili dokümanlardan inceleyebilirsiniz.

    Biz yukarıda sanki tek bir CPU ya da çekirdek varmış gibi durumu ele aldık. Günümüz bilgisayarlarında genellikle birden fazla
    CPU ya da çekirdek bulunmaktadır. İşletim sistemlerinin çoğu her CPU ya da çekirdek için ayrı bir çalışma kuyruğu (run queue) 
    oluşturmaktadır. Tabii bir CPU ya da çekirdeğin çalışma kuyruğundaki thread'ler azalırsa, diğerlerinin çalışma kuyruğundaki 
    thread'ler o CPU ya da çekirdeğin kuyruğuna aktarılabilmektedir. Tabii bu konuda sistemler arasında ve algoritmalar arasında 
    farklılıklar söz konusu olmaktadır. Örneğin Linux'un O(1) çizelgeleme algoritmasında tek bir çalışma kuyruğu oluşturulmuştu. 
    Hangi CPU ya da çekirdekteki thread quantasını doldurduğunda bu tek kuyruğa bakılıp oradan seçme yapılıyordu. (Örneğin 
    mağazada üç kasa olabilir. Ancak tek kuyruk olabilir. Bu durumda her kasadaki işlem bittiğinde aynı kuyruktan yeni kişi 
    o kasaya alınmaktadır.) Ancak Linux'ta CFS algoritmasıyla her CPU ya da çekirdek için ayrı çalışma kuyrukları oluşturulmuş 
    ve kuyruktan kuyruğa gerektiğinde transfer imkanı sağlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi SCHED_OTHER çizelgeleme politikasına sahip olan proseslerin (yani onun bütün thread'lerinin) 
    "dinamik önceliği" ya da "nice" değeri denilen onların diğerlerine göre CPU kullanım miktarını ayarlamakta etkili olan 
    değerleri vardır. İşletim sistemleri tipik olarak çalışma kuyruğundaki tüm thread'lerin quanta sayaçları 0'a düştüğünde, 
    onların yeni sayaç değerlerini bu dinamik önceliğe ya da nice değerine göre doldurmaktadır. Ancak bu dinamik öncelik ya da 
    nice değerinin tam olarak bu quanta sayaçları üzerinde nasıl bir etkiye sahip olacağı hakkında POSIX standartlarında bir 
    şey söylenmemiştir. Örneğin Linux'ta SCHED_OTHER prosesler için CFS algoritmasına geçildiğinde bu nice değerinin etkisi 
    her bir nice değeri için %10 civarında olmaktadır.

    Linux sistemlerinde, SCHED_OTHER proseslerin nice değerinin sınır değerleri [0, 39] arasındadır. POSIX standartları bunun 
    orta noktasına NZERO değeri demektedir. POSIX standartlarına göre SCHED_OTHER proseslerin dinamik önceliğinin [0, 2*NZERO-1] 
    aralığında olduğu belirtilmiştir. Yani Linux sistemleri için bu NZERO değeri 20'dir. Dinamik öncelik ya da nice için yüksek 
    değer düşük öncelik, düşük değer ise yüksek öncelik belirtmektedir. (Yani 0 değeri en yüksek önceliği, 39 değeri en düşük 
    önceliği belirtmektedir.) Yukarıda belirttiğimiz gibi Linux sistemlerinde SCHED_OTHER proseslerin nice değerleri için orta 
    nokta (NZERO) 20'dir. Bu 20 değeri ortalama 200 milisaniyelik bir quanta süresine karşı gelmektedir. Bu değer yükseltildikçe 
    quanta süresi düşmekte, düşürüldükçe quanta süresi yükseltilmektedir. Ancak bugün kullanılan CFS algoritmasının bazı 
    ayrıntıları vardır. Bu ayrıntılar "Linux Kernel" kursumuzda ele alınmaktadır.

    İşletim sistemi tarafından çizelgelenen öğelerin prosesler olmadığına thread'ler olduğuna dikkat ediniz. POSIX standartları 
    "prosesin dinamik önceliği ya da nice değeri" demekle onun bütün thread'lerinin dinamik önceliğini kastetmektedir. Yani 
    dinamik öncelik proses temelinde değiştirilse de aslında Linux işletim sistemi bu dinamik öncelikleri thread temelinde 
    ele almaktadır. Ayrıca spesifik bir thread'in dinamik önceliği de değiştirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir SCHED_OTHER politikasına sahip prosesin dinamik önceliği yani nice değeri setpriority fonksiyonuyla set edilebilir 
    ve getpriority fonksiyonu ile alınabilir. Bunun için nice ve renice isimli iki fonksiyon da bulunmaktadır. setpriority 
    ve getpriority fonksiyonlarının prototipleri şöyledir:

    #include <sys/resource.h>

    int getpriority(int which, id_t who);
    int setpriority(int which, id_t who, int value);

    Buradaki which parametresi şunlardan biri olabilir:

    PRIO_PROCESS
    PRIO_PGRP
    PRIO_USER

    PRIO_PROCESS yalnızca tek bir prosesin dinamik önceliğinin alınacağını ya da değiştirileceğini, PRIO_PGRP bir proses 
    grubundaki tüm proseslerin dinamik önceliklerinin alınacağını ya da değiştirileceğini ve PRIO_USER belli bir etkin user 
    id'ye ilişkin tüm proseslerin dinamik önceliklerinin alınacağını ya da değiştirileceğini belirtmektedir. Fonksiyonun who 
    isimli ikinci parametresi, which parametresine göre ilgili prosesin proses id'si, proses grubunun proses grup id'si ve 
    etkin kullanıcı id'si olabilmektedir. (Zaten bu nedenle id_t isimli bir tür uydurulmuştur. Bu tür pid_t ve uid_t türlerinin 
    her ikisini de ifade edebilecek bir türdür.) Fonksiyonun bu ikinci parametresi 0 girilirse duruma göre çağrıyı yapan proses, 
    çağrıyı yapan prosese ilişkin proses grup id ve çağrıyı yapana prosese ilişkin etkin kullanıcı id'si anlamına gelmektedir.) 
    setpriority fonksiyonunun value parametresi set edilecek dinamik öncelik ya da nice değerini belirtmektedir. Burada value 
    değeri NZERO değerine (yani Linux'ta 20) göreli biçimde girilmelidir. Yani örneğin bu value değeri 10 girilirse nice değeri 
    aslında 20 + 10 = 30 anlamına gelir. Ya da örneğin bu value değeri -10 biçiminde girilirse 20 - 10 = 10 anlamına gelir. Bu 
    duruma Linux sistemlerinde bu value değeri [-20, 19] aralığında girilmelidir. Ancak POSIX standartlarına göre bu value 
    değerine, bu aralığın dışında bir değer verilirse bu aralıktaki minimum ya da maksimum değer anlaşılmaktadır. (Yani örneğin 
    biz value değerine -50 verirsek bu değer Linux'ta geçersizdir. Ancak fonksiyon başarısız olmaz. Bu durumda sanki bu değer 
    -20 girilmiş gibi etki gösterir. Yani nice değeri 0 olur.)

    setpriority fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. getpriority fonksiyonu 
    ise başarı durumunda NZERO (20) değerine göreli olan nice değerine, başarısızlık durumunda -1 değerine geri dönmektedir. 
    getpriority fonksiyonunun geri dönüş değeri -1 ise bu durum başarısızlık ya da gerçekten göreli -1 anlamına gelebileceği 
    için bunun kontrolü ayrıca yapılmalıdır. Bu kontrol için baştan errno değeri 0'a set edilir. Sonra fonksiyon -1 değerine 
    geri dönmüşse errno değerine bakılır. Örneğin:

    errno = 0;
    if ((result = getpriority(PRIO_PROCESS, pid)) == -1 && errno != 0)
        exit_sys("getpriority");

    Biz getpriority fonksiyonu ile herhangi bir prosesin, proses grubunun ya da etkin kullanıcı id'sine ilişkin proseslerin nice 
    değerini elde edebiliriz. Bu konuda bir erişim kontrolü uygulanmamaktadır. Ancak biz getpriority fonksiyonu ile bir proses
    grubunun ya da belli bir etkin kullanıcı id'sine ilişkin proseslerin nice değerlerini elde ederken aslında birden fazla proses
    söz konusu olduğu için getpriority fonksiyonu en düşük nice değerini (yani en öncelikli değeri) bize vermektedir.

    Biz setpriority fonksiyonu ile istediğimiz bir prosesin nice değerini değiştiremeyiz. POSIX standartlarına göre ancak uygun 
    önceliğe sahip (örneğin root) prosesler nice değerini düşürerek daha fazla CPU zamanının elde edilmesini sağlayabilirler. 
    Ancak normal prosesler eğer fonksiyonu çağıran prosesin gerçek ya da etkin kullanıcı id'si hedef prosesin etkin kullanıcı 
    id'si ile aynı ise nice değerini yükselterek prosesin daha az CPU kullanmasını sağlayabilmektedir. Özetle kontrol mekanizması 
    şöyledir:

    - Biz herhangi bir prosesin nice değerini yükseltip onun daha az CPU kullanmasını sağlayabilmemiz için o hedef 
    prosesin etkin kullanıcı id'sinin bizim gerçek ya da etkin kullanıcı id'miz ile aynı olması gerekir. Başka bir deyişle 
    biz yalnızca kendi proseslerimizin nice değerini düşürebiliriz.

    - Herhangi bir prosesin (kendimiz dahil) nice değerini düşürmek için (yani daha fazla CPU zamanı kullanmasını sağlamak için)
    bizim uygun önceliğe (tipik olarak root ya da Linux için CAP_SYS_NICE yeterliliğine) sahip olmamız gerekir. Linux 2.6.12 
    çekirdeği ile birlikte prosesin nice değerinin değiştirilmesini prosesin RLIMIT_NICE kaynak limiti ile ilişkilendirmiştir. 
    Uygun önceliğe sahip olmayan prosesler ancak 0 ile 39 arasındaki nice değerini en fazla 20 - rlim_cur değeri olarak düşürebilir. 
    rlim_cur değerinin default değeri ise 0 biçimindedir. Bu da uygun önceliğe sahip proseslerin normal olarak kendi nice 
    değerlerini sayısal olarak düşüremeyeceği anlamına gelmektedir. Prosesin kaynak limitleri konusu ileride ele alınacaktır.

    Daha önceden de belirttiğimiz gibi POSIX standartlarına göre dinamik öncelik ya da nice değeri prosese özgüdür. Yani biz 
    bir prosesin nice değerini set ettiğimizde onun bütün thread'lerinin nice değerini set etmiş oluruz. Ancak maalesef Linux 
    sistemleri bu bakımdan POSIX standartlarına uymamaktadır. Linux'ta biz prosesin nice değerini set ettiğimizde bu işlemden 
    yalnızca o prosesin ana thread'i etkilenmektedir. Aynı durum prosesin nice değerini alırken de söz konusu olmaktadır.

    Linux'ta her ne kadar nice değeri prosese değil thread'e özgü ise de Linux çekirdeği bir thread başka bir thread'i 
    yarattığında yaratan thread'in nice değerini yaratılan thread'e geçirmektedir. Dolayısıyla her ne kadar thread'ler arasında 
    altlık-üstlük durumu yoksa da bu istisnai durumlardan biridir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            66. Ders 16/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte çalışmakta olan programın nice değeri göreli bir biçimde elde edilmiş ve yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(void)
{
    int result;

    errno = 0;
    if ((result = getpriority(PRIO_PROCESS, 0)) == -1 && errno != 0)
        exit_sys("getpriority");

    printf("%d\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte komut satırından alınan proses id'ye ilişkin (argv[1]) prosesin nice değeri yine komut satırından alınan 
    göreli nice değeri (argv[2]) olarak değiştirilmektedir. Örneğin:

    $ ./sample 0 -1

    Burada biz kendi prosesimizin değerini düşürerek önceliğini yükseltmeye çalıştık. Bu işlem başarısızlıkla sonuçlanacaktır. 
    Bunu yapabilmemiz için programı root önceliği ile çalıştırmamız gerekir. Örneğin:

    $ sudo ./sample 0 -1

    Tabii biz kendi prosesimizin nice değerini yükselterek önceliğini düşürebiliriz. Örneğin:

    $ sudo ./sample 0 1

    Bu işlem başarıyla sonuçlanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    pid_t pid;
    int prio;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = (pid_t)atol(argv[1]);
    prio = atoi(argv[2]);

    if (setpriority(PRIO_PROCESS, pid, prio) == -1)
        exit_sys("setpriority");

    printf("success...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz terminalden proseslerin nice değerlerini nasıl görebiliriz? Bunun için ilk akla gelen "ps" komutunu kullanmaktır.
    ps komutu aslında ileride göreceğimiz gibi "proc" dosya sisteminden bilgileri almaktadır. ps komutunun kullanımına ilişkin 
    pek çok ayrıntı vardır. Biz burada komutun bazı kullanımlarını açıklayacağız.

    - Eğer ps komutu hiç seçeneksiz çalıştırılırsa bulunulan terminale ve kullanıcıya ilişkin prosesler kısa biçimde listelenir.
    Örneğin:

    $ ps
    PID TTY          TIME CMD
    5471 pts/2    00:00:00 bash
    5561 pts/2    00:00:00 ps

    - ps komutunda -l seçeneği daha fazla bilgi vermektedir. Bu bilgiler arasında nice değeri de vardır. Örneğin:

    $ ps -l
    F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    0 S  1000    5471    2108  0  80   0 -  3505 do_wai pts/2    00:00:00 bash
    4 R  1000    5564    5471  0  80   0 -  3857 -      pts/2    00:00:00 ps

    Ancak default durumda yine komut ilgili terminalde çalıştırılan prosesler hakkında bilgileri vermektedir.

    - ps default olarak o anki kullanıcının o anki terminaldeki proseslerini görüntüler. Eğer komutta -t ya da --tty belirtilirse
    spesifik bir terminalde çalışan prosesler görüntülenebilmektedir. Örneğin:

    $ ps -l -t pts/1
    F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    1 S     0    5456    5455  0  80   0 -  4718 -      pts/1    00:00:00 sudo
    4 S     0    5457    5456  0  79  -1 -   693 -      pts/1    00:00:00 sample

    - ps komutundaki -u seçeneği belli bir etkin kullanıcı id'sine ilişkin tüm prosesleri görüntülemektedir. Örneğin:

    $ ps -u
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    kaan        2133  0.0  0.1  14152  5624 pts/0    Ss   07:50   0:00 bash
    kaan        5471  0.0  0.1  14020  5316 pts/2    Ss   11:31   0:00 bash
    kaan        5609  0.0  0.0  15428  1580 pts/2    R+   11:49   0:00 ps -u

    - Aslında ps komutundaki sütunlar istenildiği gibi ayarlanabilmektedir. Bunun için -o seçeneği kullanılmaktadır. Sütun 
    isimleri ps komutunun man sayfasında "OUTPUT FORMAT CONTROL" başlığında tek tek belirtilmiştir. Örneğin:

    $ ps -t pts/1 -o pid,ni,cmd

    - ps komutunda prosesin thread'leri de görülmek isteniyorsa bu durumda -T seçeneği kullanılmalıdır. Bu seçenek girildiğinde
    aynı zamanda thread'in "task struct id'leri" de SPID sütunu ile görüntülenmektedir. Örneğin:

    $ ps -l -T -t pts/1
    F S   UID     PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    1 S     0    5681    5681    5680  0  80   0 -  4717 -      pts/1    00:00:00 sudo
    4 S     0    5682    5682    5681  0  79  -1 - 19126 -      pts/1    00:00:00 sample
    1 S     0    5682    5683    5681  0  80   0 - 19126 -      pts/1    00:00:00 sample

    Linux sistemlerinde proseslerin kullandığı kaynakları sort edilmiş bir biçimde görüntülemek için "top" isimli bir komut 
    da bulunmaktadır. Bu komut da bilgileri aslında "proc" dosya sisteminden almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında POSIX standartlarında prosesin nice değeri değiştirildiğinde onun bütün thread'lerinin 
    nice değerinin değiştirilmesi gerekmektedir. Ancak Linux buna uymamaktadır. Aşağıdaki örnekte biz "sample" programında
    bir thread yarattık. Sonra da prosesin nice değerini değiştirdik. Prosesin nice değerini -1 yaptığımızda bundan yalnızca
    prosesin ana thread'inin etkilendiğini göreceksiniz. Programı bir terminalde aşağıdaki gibi çalıştırabilirsiniz:

    $ sudo ./sample 0 -1

    Diğer bir terminalden prosesin thread'lerine aşağıdaki gibi bakabilirsiniz:

    $ ps -t pts/1 -T -l
    F S   UID     PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    1 S     0    6191    6191    6190  0  80   0 -  4706 -      pts/1    00:00:00 sudo
    4 S     0    6192    6192    6191  0  79  -1 -  2742 -      pts/1    00:00:00 sample
    1 S     0    6192    6193    6191  0  80   0 -  2742 -      pts/1    00:00:00 sample

    Görüldüğü gibi yalnızca prosesin ana thread'inin nice değeri değişmiştir.

    Tabii yukarıda da belirttiğimiz gibi biz bu örnekte setpriority fonksiyonunu thread yaratılmadan önce çağırmış olsaydık 
    Linux'ta yalnızca üst thread'in nice değeri değiştirilecekti ancak thread yaratılırken bu nice değeri yaratılan 
    thread'e de geçirilecekti.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/resource.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(int argc, char *argv[])
{
    pid_t pid;
    int prio;
    pthread_t tid;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = (pid_t)atol(argv[1]);
    prio = atoi(argv[2]);

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if (setpriority(PRIO_PROCESS, pid, prio) == -1)
        exit_sys("setpriority");

    printf("success...\n");
    printf("press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    printf("thread is running...\n");

    pause();

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    SCHED_OTHER çizelgeleme politikasına sahip olan proseslerin nice değerlerini değiştirmenin diğer bir yolu da nice isimli 
    POSIX fonksiyonunu kullanmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int nice(int incr);

    Fonksiyon her zaman kendi prosesinin nice değerini değiştirmektedir. Bu anlamda setpriority fonksiyonunun düşük bir alt 
    kümesi gibi çalışmaktadır. Ancak nice fonksiyonu her zaman prosesin o anki nice değerine göreli olarak nice değerini 
    set etmektedir. Örneğin prosesin o anki nice değeri -2 olsun. Biz nice fonksiyonunu -2 değeri ile çağırırsak artık prosesin 
    nice değeri -4 olacaktır. Halbuki setpriority fonksiyonu prosesin o anki nice değerine göreli işlem yapmamaktadır. POSIX 
    standartlarına göre nice fonksiyonu o anda prosesin tüm thread'lerinin nice değerini değiştirmektedir. Ancak Linux sistemleri 
    yalnızcafonksiyonu çağıran thread'in nice değerini değiştirmektedir. Yukarıda da belirttiğimiz gibi nice fonksiyonu ile 
    değiştirilen bu değer, thread başka bir thread yarattığında o thread'e geçirilmektedir. nice fonksiyonu başarı durumunda 
    değiştirilmiş olan yeni nice değerine geri döner. nice fonksiyonu başarısızlık durumunda -1 değerine geri döner. Ancak 
    programcı yine  bu -1 değerinin başarıdan dolayı mı başarısızlıktan dolayı mı oluştuğunu errno değişkeni yoluyla belirlemelidir. 
    Örneğin:

    errno = 0;
    if (nice(-1) == -1 && errno != 0)
        exit_sys("nice");

    Aşağıdaki örnekte prosesin nice değeri, nice fonksiyonuyla iki kez üst üste değiştirilmiştir. Programı aşağıdaki gibi 
    çalıştırabilirsiniz:

    $ sudo ./sample

    Diğer bir terminalden prosesin durumuna baktığınızda aşağıdakine benzer bir rapor elde edeceksiniz:

    $ ps -t pts/1 -T -l
    F S   UID     PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    1 S     0    6516    6516    6515  0  80   0 -  4708 -      pts/1    00:00:00 sudo
    4 S     0    6517    6517    6516  0  76  -4 -  2742 -      pts/1    00:00:00 sample
    1 S     0    6517    6518    6516  0  76  -4 -  2742 -      pts/1    00:00:00 sample

    Bu örnekte önce nice fonksiyonunun çağrıldığına sonra thread'in yaratıldığına dikkat ediniz. Dolayısıyla yaratan thread'in 
    nice değeri yaratılan thread'e aktarılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = nice(-2)) == -1)
        exit_sys("nice");
    printf("%d\n", result);

    if ((result = nice(-2)) == -1)
        exit_sys("nice");
    printf("%d\n", result);

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    printf("success...\n");
    printf("press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    printf("thread is running...\n");

    pause();

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde nice isimli bir kabuk komutu da vardır. Bu komut belirtilen programı belirtilen nice değeri ile
    çalıştırmaktadır. nice komutunun genel biçimi şöyledir:

    nice -<nice değeri> <program>

    Örneğin:

    $ nice -1 ./sample

    Burada sample programı 1 nice değeri ile çalıştırılmaktadır. Burada "-" karakteri seçenek için kullanılan "-" karakteridir. 
    Örneğin aşağıdaki programı nice komutuyla şöyle çalıştıralım:

    $ nice -1 ./sample

    Burada başka bir terminale geçip duruma bakalım:

    $ ps -t pts/0 -T -l
    F S   UID     PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    0 S  1000    2133    2133    2108  0  80   0 -  3538 do_wai pts/0    00:00:00 bash
    0 S  1000    6735    6735    2133  0  81   1 -  2742 futex_ pts/0    00:00:00 sample
    1 S  1000    6735    6736    2133  0  81   1 -  2742 do_sys pts/0    00:00:00 sample

    Prosesin iki thread'inin de nice değerinin değiştiğini görüyorsunuz. Çünkü nice programı önce fork yapıp prosesin nice 
    değerini değiştirip exec yapmaktadır. Linux sistemlerinde de yaratan thread'in nice değerinin yaratılan thread'e 
    aktarıldığını anımsayınız.

    Şimdi de nice değerini düşürüp aynı denemeyi yapalım:

    $ sudo nice --1 ./sample

    Diğer terminalden duruma bakalım:

    $ ps -t pts/1 -T -l
    F S   UID     PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    1 S     0    6777    6777    6776  0  80   0 -  4707 -      pts/1    00:00:00 sudo
    4 S     0    6778    6778    6777  0  79  -1 -  2742 -      pts/1    00:00:00 sample
    1 S     0    6778    6779    6777  0  79  -1 -  2742 -      pts/1    00:00:00 sample
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    printf("success...\n");
    printf("press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    printf("thread is running...\n");

    pause();

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    nice komutu (yani programı) bir nice değeri ile bir programı çalıştırmaktadır. Ancak ayrıca bir de renice isimli komut 
    vardır. Bu renice programı zaten bizim yukarıda setpriority örneğinde yazdığımız program gibi çalışmaktadır. Yani belli bir 
    prosesin nice değerini değiştirmektedir. Bunun için programın zaten çalışıyor olması gerekmektedir. Komutun basit kullanımı 
    şöyledir:

    renice -<nice değeri> -p <proses id>

    Örneğin:

    $ renice -1 -p 6827

    Tabii burada Linux sistemlerinde yalnızca prosesin ana thread'inin nice değeri değişecektir. nice ve renice komutları aslında 
    POSIX standartlarında belirtilmiş olan standart komutlardandır. Ancak POSIX standartlarında renice fonksiyonu prosesin tüm 
    thread'lerinin nice değerinin değişmesine yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki Linux sistemlerinde setpriority ve nice fonksiyonları yalnızca prosesin ana thread'leri üzerinde etkili 
    olmaktadır. Pekiyi bu durumda Linux sistemlerinde belli bir thread'in nice değeri nasıl değiştirilir? İşte Linux'ta prosesler 
    de olduğu gibi tüm thread'ler için de birer task_struct yapısı bulundurulmuştur. Aslında Linux sistemlerinde pid değeri, 
    task_struct yapısına özgü bir değerdir ve her thread'in de bir pid değeri vardır. Bu pid değerine, thread'ler söz konusu 
    olduğunda pid değeri yerine tid değeri de denilebilmektedir.

    Linux çekirdeği ana thread'in task_struct yapısı içerisinde thread_group isimli bir bağlı liste yoluyla o ana thread'e (yani 
    prosese) ilişkin tüm task_struct yapılarını tutmaktadır. Böylece bir çekirdeğe bir prosesin pid değerini verdiğimizde, çekirdek 
    o pid değerinden hareketle prosesin ana thread'inin task_struct yapısını bulmakta ve o yapının thread_group bağlı listesinden 
    hareketle o prosesin tüm thread'lerinin task_struct yapısına erişebilmektedir. task_struct yapısı içerisinde tgid isimli eleman 
    o prosesin ana thread'ine ilişkin task_struct yapısının pid değerini vermektedir. Biz prosesin hangi thread'inde getpid fonksiyonunu 
    çağırırsak çağıralım aslında prosesin ana thread'ine ilişkin task_struct yapısının pid değerini elde etmiş oluruz. Zaten POSIX 
    standartlarında thread'lerin pid değerleri yoktur. Yalnızca proseslerin pid değerleri vardır. Yukarıda da belirttiğimiz gibi 
    Linux'ta thread'lerin task_struct yapısından hareketle elde edilen bu id değerine pid yerine daha çok tid denilmektedir.

    Özetle Linux çekirdeğinde durum şöyledir:

    - Her thread'in ayrı bir task_struct yapısı vardır. Bu durumda aslında her thread'in ayrı bir pid değeri var gibidir. 
    Thread'ler için bu pid değerine tid de denilmektedir.

    - Ana thread'e ilişkin task_struct yapısının pid değeri aynı zamanda prosesin pid değeri olarak kullanılmaktadır. Biz
    hangi thread'te getpid fonksiyonunu çağırırsak çağıralım hep prosesin pid değerini elde ederiz.

    - Prosesin ana thread'inin task_struct yapısı içerisinde prosesin bütün thread'lerinin task_struct adresleri tutulmaktadır. 
    Yani çekirdek bir proses id'den hareketle prosesin tüm thread'lerine ilişkin task_struct yapılarına erişebilmektedir.

    Pekiyi mademki Linux sistemlerinde her thread'in ayrı bir pid değeri (tid değeri) varmış gibi bir durum oluşmaktadır. Thread'lerin 
    bu tid değerlerini nasıl elde edebiliriz? İşte bunun için Linux gettid isimli bir sistem fonksiyonu ve onu çağıran bir kütüphane 
    fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #define _GNU_SOURCE
    #include <unistd.h>

    pid_t gettid(void);

    Fonksiyon başarı durumunda thread'in pid değerine (tid değerine) geri döner. Fonksiyon başarısız olamaz. gettid fonksiyonunun
    bir POSIX fonksiyonu olmadığına, Linux'a özgü bir fonksiyon olduğuna dikkat ediniz. Fonksiyonu kullanabilmek için kaynak 
    kodun tepesinde (<unistd.h> include işleminin yukarısına) _GNU_SOURCE makrosunu define etmelisiniz. Tabii bunun yerine 
    gcc ve clang derleyicilerinde -D seçeneğini de kullabilirsiniz. Örneğin:

    $ gcc -D _GNU_SOURCE -o sample sample.c
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                67. Ders 22/07/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte prosesin pid değeri, ana thread'in pid değeri ve yaratılmış olan thread'in pid değeri yazdırılmıştır. 
    Program çalıştırıldığında aşağıdaki gibi bir çıktı elde edilmelidir:

    Process pid: 3026
    Main thread pid: 3026
    Thread pid (tid): 3027

    Programdan çıkmak için Ctrl+C tuşlarına basınız. Başka bir terminalden durumu ps komutuyla aşağıdaki gibi gözleyebilirsiniz:

    $ ps -t pts/0 -T -l

    Burada programı çalıştırdığınız terminalin hangi terminal olduğunu tty komutu ile belirleyebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pid_t pid;

    pid = getpid();
    printf("Process pid: %jd\n", (intmax_t)pid);

    pid = gettid();
    printf("Main thread pid (tid): %jd\n", (intmax_t)pid);

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pid_t pid;

    pid = gettid();
    printf("Thread pid (tid): %jd\n", (intmax_t)pid);

    pause();

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    O halde Linux'ta belli bir thread'in nice değerini elde etmek ve değiştirmek için getpriority ve setpriority fonksiyonları 
    thread'e ilişkin pid değeri ile (tid değeri ile) çağrılabilir.

    nice fonksiyonu POSIX standartlarında prosesin tüm thread'leri üzerinde etkili olmaktadır. Ancak yukarıda da belirttiğimiz 
    gibi Linux sistemlerinde yalnızca çağıran thread üzerinde etkili olmaktadır. Yani biz herhangi bir thread akışında nice
    fonksiyonunu çağırırsak zaten Linux'ta yalnızca o thread'in nice değerini değiştirmiş oluruz.

    Aşağıdaki örnekte bir thread yaratılmış ve o thread'in nice değeri setpriority fonksiyonu ile set edilip, getpriority 
    fonksiyonu ile get edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/resource.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pid_t pid;
    int prio;

    pid = gettid();

    if (setpriority(PRIO_PROCESS, pid, 10) == -1)
        exit_sys("setpriority");

    errno = 0;
    if ((prio = getpriority(PRIO_PROCESS, pid)) == -1 && errno != 0)
        exit_sys("getpriority");

    printf("Thread priority: %d\n", prio);

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Konunun başında da belirttiğimiz gibi UNIX/Linux sistemlerinde SCHED_FIFO ve SCHED_RR isimli iki "realtime" çizelgeleme politikası
    vardır. Her ne kadar bu politikalara "realtime" çizelgeleme politikaları deniliyorsa da aslında gerçek anlamda bir "realtime"
    uygulama bu politikalarla sağlanamamaktadır. Buradaki "realtime" olsa olsa soft bir realtime uygulamaya izin verebilmektedir.

    POSIX standartlarında bir proses SCHED_FIFO ve SCHED_RR çizelgeleme politikalarına sokulursa bundan o prosesin tüm thread'leri 
    etkilenmektedir. Ancak POSIX standartları belli bir thread'in çizelgeleme politikasının SCHED_FIFO ya da SCHED_RR yapılabilmesine
    de olanak sağlamaktadır.

    SCHED_FIFO ve SCHED_RR çizelgeleme politikaları her zaman SCHED_OTHER politikasından daha baskındır. Yani sistemde o anda çalışabilecek
    bir SCHED_FIFO ya da SCHED_RR thread varsa bunlar bloke olmadıktan sonra ya da sonlanmadıktan sonra SCHED_OTHER thread'ler
    CPU'ya atanmazlar.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Sistemde SCHED_FIFO ya da SCHED_RR thread'lerin "statik önceliği (static priority)" denilen bir öncelik derecesi vardır. 
    Bu static öncelik SCHED_OTHER proseslerdeki nice değeri gibi değildir. POSIX standartları bu statik öncelik derecesinin alt ve 
    üst limitleri konusunda bir belirlemede bulunmamıştır. Yani bu alt ve üst limitler sistemden sisteme değişebilmektedir. 
    Ancak POSIX, bu alt ve üst limitlerin programın çalışma zamanı sırasında elde edilebilmesi için aşağıdaki iki fonksiyonu 
    bulundurmaktadır:

    #include <sched.h>

    int sched_get_priority_max(int policy);
    int sched_get_priority_min(int policy);

    Fonksiyon parametre olarak çizelgeleme politikasının ismini almaktadır. Geri dönüş değeri olarak statik önceliğin alt ve 
    üst limitlerini vermektedir. Fonksiyonlar başarısızlık durumunda -1 değerine geri dönmektedir. Fonksiyona parametre olarak 
    SCHED_OTHER girilmemelidir. Burada parametre SCHED_FIFO ya da SCHED_RR olarak girilmelidir. Thread'lerin static önceliklerinin
    minimum değeri negatif olamamaktadır. Her ne kadar fonksiyonlar çizelgeleme politikalarını parametre olarak alıyorsa da 
    SCHED_FIFO ve SCHED_RR aynı statik öncelik derecelerine sahiptir.

    Linux'ta SCHED_FIFO ve SCHED_RR thread'lerin minimum ve maksimum değerleri [1, 99] arasındadır. Statik öncelikler nice değeri 
    gibi değildir. Statik önceliklerde gerçekten düşük değer düşük öncelik, yüksek değer yüksek öncelik belirtmektedir.

    Aşağıda ilgili sistemdeki minimum ve maksimum statik öncelikler yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sched.h>

void exit_sys(const char *msg);

int main(void)
{
    int priomin, priomax;

    if ((priomin = sched_get_priority_min(SCHED_FIFO)) == -1)
        exit_sys("sched_get_priority_min");

    if ((priomax = sched_get_priority_max(SCHED_FIFO)) == -1)
        exit_sys("sched_get_priority_max");

    printf("SCHED_FIFO primin: %d\n", priomin);
    printf("SCHED_FIFO primax: %d\n", priomax);

    if ((priomin = sched_get_priority_min(SCHED_RR)) == -1)
        exit_sys("sched_get_priority_min");

    if ((priomax = sched_get_priority_max(SCHED_RR)) == -1)
        exit_sys("sched_get_priority_max");

    printf("SCHED_RR primin: %d\n", priomin);
    printf("SCHED_RR primax: %d\n", priomax);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    SCHED_FIFO ve SCHED_RR çizelgeleme politikalarında Windows sistemlerinde olduğu gibi "öncelik sınıfına (priority class)"
    dayalı bir çizelgeleme kuyruğu oluşturulmaktadır. Yani her statik öncelik için ayrı bir kuyruk varmış gibi işlemler 
    yürütülmektedir. Örneğin statik önceliği 10, 10, 10, 12, 12, 12, 12 olan 7 tane SCHED_FIFO ya da SCHED_RR thread olsun.
    Burada statik önceliği 10 olan thread'ler ayrı bir kuyrukta, 12 olan thread'ler ayrı bir kuyrukta bulundurulmaktadır. 
    Mademki Linux'ta statik öncelikler [1, 99] arasındadır. O halde toplam 99 ayrı kuyruk olduğu varsayılabilir.

    Sistem her zaman yüksek öncelikli thread'lerin bulunduğu kuyruktaki thread'leri CPU'ya atamak ister. Örneğin sistemde 
    12 öncelikli SCHED_FIFO ya da SCHED_RR thread varsa bunlar bloke olmadan ya da sonlanmadan hiçbir zaman 10 öncelikli 
    olanlar CPU'ya atanmazlar. Yani sistemde çalışmaya hazır yüksek statik öncelikli bir thread varsa hiçbir zaman düşük 
    statik öncelikli bir thread CPU'ya atanmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    SCHED_FIFO çizelgeleme politikasına sahip aynı statik öncelikte bir grup thread olsun. Bunların çizelgelemesi şöyle 
    yapılmaktadır:

    1) En öncelikli kuyruğun başındaki SCHED_FIFO thread CPU'ya atanır. Ancak quanta süresi diye bir durum yoktur. Bu thread 
    sürekli CPU'da çalıştırılır. Ancak bloke olursa ya da biterse CPU'yu bırakır.

    2) Bloke olmuş olan bir SCHED_FIFO thread'in blokesi çözüldüğünde bu thread kendi öncelik kuyruğunun sonuna yerleştirilir.

    3) Eğer bir SCHED_FIFO thread çalışırken blokesi çözülen daha yüksek öncelikli bir SCHED_FIFO ya da SCHED_RR thread varsa 
    bu SCHED_FIFO thread'in çalışmasına ara verilir ve CPU'ya o thread atanır.

    Örneğin sistemde 10, 10, 10, 12, 12, 12, 12 statik öncelik derecelerine sahip olan 7 tane thread olsun. Bunlar iki ayrı öncelik 
    kuyruğunda bulunacaklardır:

    10'un öncelik kuyruğu -->   T1(10), T2(10), T3(10)
    12'nin öncelik kuyruğu -->  T4(12), T5(12), T6(12), T7(12)

    Burada işletim sistemi 12 kuyruğundaki önde bulunan T4 thread'ini CPU'ya atar. Bu T4 thread'i sürekli çalışır. 
    Ancak bloke olursa sistem bu sefer T5 thread'ini CPU'ya atar ve onu sürekli çalıştırır. O da bloke olursa bu kez T6 thread'ini
    CPU'ya atar. Yani her zaman işletim sistemi o öncelik kuyruğundaki aynı önceliğe sahip olan kuyrukta önde bulunan thread'i 
    CPU'ya atamaktadır. Tabii bu örnekte bloke olmuş olan T4 thread'inin blokesi çözülürse kuyruğun sonuna yerleştirilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    SCHED_RR çizelgeleme politikası SCHED_FIFO çizelgemeleme politikasına benzemektedir. Ancak bu çizelgeleme politikasına sahip
    olan thread'ler CPU'ya bir quanta süresi çalıştırılıp ilgili öncelik kuyruğunun sonuna yerleştirilmektedir. SCHED_FIFO 
    ile SCHED_RR arasında tek farklılık şudur: SCHED_FIFO thread CPU'ya atandığında bloke olmadıkça, sonlanmadıkça ya da 
    daha yüksek öncelikli bir thread'in blokesi çözülmedikçe o thread CPU'da çalışmaya devam eder. Ancak SCHED_RR bir thread 
    bir quanta çalışıp kuyruğun sonuna atanmaktadır. Şimdi örneğin yine aşağıdaki gibi 7 tane SCHED_RR çizelgeleme politikasına 
    sahip thread bulunuyor olsun:

    10'un öncelik kuyruğu -->   T1(10), T2(10), T3(10)
    12'nin öncelik kuyruğu -->  T4(12), T5(12), T6(12), T7(12)

    Burada işletim sistemi önce T4 thread'ini CPU'ya atar onu bir quanta çalıştırır ve kuyruğun sonuna atar. Sonra T5 thread'ini
    CPU'ya atar onu da bir quanta çalıştırır. (Tabii bu thread'ler daha quanta süresi dolmadan da bloke olabilirler.)

    SCHED_RR politikasına sahip thread'lerin quanta süreleri ile SCHED_OTHER politikasına sahip thread'lerin quanta sürelerinin
    bir ilgisi yoktur. SCHED_OTHER thread'lerin quanta süreleri onların nice değerine göre ayarlanabilmektedir. Halbuki SCHED_RR 
    thread'lerin quanta süreleri onların statik öncelikleri ne olursa olsun hep aynıdır. Bugünkü Linux sistemlerinde tipik olarak 
    SCHED_RR politikasına sahip thread'lerin quanta süreleri 100 milisaniye (0.1 saniye) kadardır.

    SCHED_RR thread'lerin quanta sürelerini almak için sched_rr_get_interval isimli bir POSIX fonksiyonu da bulundurulmuştur. 
    Fonksiyonun prototipi şöyledir:

    #include <sched.h>

    int sched_rr_get_interval(pid_t pid, struct timespec *interval);

    Yukarıda da belirttiğimiz gibi güncel Linux sistemlerinde bu fonksiyondan elde edilecek değer 100 milisaniyedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda SCHED_FIFO politikası ile SCHED_RR politikasını ayrı ayrı ele aldık. Aslında öncelik kuyruklarında (yani belli 
    bir önceliğe ilişkin kuyrukta) SCHED_FIFO ve SCHED_RR politikalarına sahip thread'ler bir arada bulunabilirler. Örneğin aşağıdaki 
    gibi thread'ler söz konusu olsun:

    10'un öncelik kuyruğu  -->   T1(SCHED_FIFO), T2(SCHED_RR), T3(SCHED_RR)
    12'nin öncelik kuyruğu -->  T4(SCHED_RR), T5(SCHED_FIFO), T6(SCHED_RR), T7(SCHED_FIFO)

    Sistem her zaman en yüksek öncelik kuyruğunun başındaki thread'i CPU'ya atar. Örneğimizde bu thread T4 thread'idir. 
    Bu thread SCHED_RR politikasına sahip olduğu için bir quanta (yani 100 milisaniye) çalıştırılacaktır. T4 thread'i bir 
    quanta çalıştırıldıktan sonra kuyruğun sonuna alınır. Kuyruğun durumu şöyle olacaktır:

    12'nin öncelik kuyruğu -->  T5(SCHED_FIFO), T6(SCHED_RR), T7(SCHED_FIFO), T4(SCHED_RR)

    Şimdi sistem T5 thread'ini CPU'ya atar. T5 thread'i SCHED_FIFO politikasına sahip olduğu için CPU'da çalışmaya devam eder. 
    Ta ki bloke olana kadar, sonlanana kadar ya da daha yüksek öncelikli bir SCHED_FIFO ya da SCHED_RR thread uyanana kadar. 
    Şimdi T5 thread'inin bloke olduğunu düşünelim. Bu durumda kuyruğun sonuna alınacaktır. Kuyruğun durumu şöyle olacaktır:

    12'nin öncelik kuyruğu -->  T6(SCHED_RR), T7(SCHED_FIFO), T4(SCHED_RR), T5(SCHED_FIFO)

    Şimdi sistem T6 thread'ini CPU'ya atar. Bu thread SCHED_RR politikasına sahip olduğu için bir quanta çalıştırılır. Sonra kuyruğun 
    sonuna yerleştirilir. Çalışma böyle devam eder.

    Burada bir kez daha şu durumu vurgulamak istiyoruz: SCHED_OTHER thread'ler default politikaya sahip thread'lerdir. Sistemde 
    SCHED_FIFO ya da SCHED_RR thread varsa hiçbir zaman çizelgelenmezler.

    Linux çekirdeğinde gerçekleştirimi kolaylaştırmak için sanki SCHED_OTHER thread'lerin bir statik önceliği varmış ve sıfırmış 
    gibi onlar için bir kuyruk oluşturulmaktadır. (Linux'ta SCHED_FIFO ve SCHED_RR politikalarına sahip thread'lerin en düşük önceliklerinin 
    1'den başlatıldığını anımsayınız.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi çok işlemcili ya da çekirdekli sistemlerde yukarıda açıkladığımız kurallar nasıl işletilmektedir? POSIX standartları 
    bu konuda bir şey söylememiştir. Ancak her CPU ya da çekirdek diğerlerinden bağımsız ayrı bir birim gibi ele alınmaktadır. 
    Örneğin iki çekirdekli bir bilgisayarda şu thread'ler bulunuyor olsun:

    T1(SCHED_OTHER), T2(10, SCHED_RR), T3(SCHED_OTHER)

    İşletim sistemi bu durumda örneğin SCHED_RR politikasına sahip olan T2 thread'ini bir çekirdeğe atar. Ancak diğer çekirdek 
    boş kaldığı için onları da diğer çekirdeğe atayabilir. Yani adeta sanki iki ayrı bilgisayar varmış gibi işlemler yürütülmektedir. 
    İki çekirdekli sistemde aşağıdaki gibi thread'ler söz konusu olsun:

    T1(SCHED_OTHER), T2(10, SCHED_RR), T3(SCHED_OTHER), T4(10, SCHED_FIFO)

    Burada işletim sistemi thread'leri önce çekirdeklere atayıp sonra yukarıdaki çizelgeleme kurallarını uygulamaktadır. 
    İşletim sistemi burada isterse bir çekirdeğe T2 ve T4 thread'lerini diğerine de T1 ve T3 thread'lerini atayabilir. 
    Ya da SCHED_RR ve SCHED_FIFO thread'lerini farklı çekirdeklere atayıp eş zamanlı da çalıştırabilir. Özetle birden fazla
    CPU ya da çekirdek varsa önce thread'ler bu CPU ya da çekirdeklere atanıp sonra sanki bu CPU ya da çekirdekler bağımsızmış gibi 
    yukarıdaki kurallara uyularak bir çizelgeleme yapılmaktadır.

    Windows işletim sistemindeki çizelgeleme algoritması UNIX/Linux sistemlerindeki SCHED_RR politikasına çok benzemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'lerin default çizelgeleme politikaları SCHED_OTHER olduğuna göre SCHED_FIFO ya da SCHED_RR hangi durumlarda 
    kullanılmalıdır? SCHED_FIFO ve SCHED_RR politikaları nispeten "soft realtime" uygulamalarda tercih edilmelidir. 
    Bir olay gerçekleştiğinde o olayın hemen ele alınması gerekiyorsa bu politikalar tercih edilmelidir. Örneğin bir ısı sensöründe
    ısının belli bir değere geldiğinde derhal bir müdahalenin yapılması gereksin. Isıyı kontrol eden bir aygıt sürücünün olduğunu 
    düşünelim ve ilgili thread'in blokede beklediğini varsayalım. Isı belli bir dereceye geldiğinde thread uyanacak ancak uyanır 
    uyanmaz hemen CPU'ya atanacaktır. İşte bunu sağlamak için yüksek öncelikli bir SCHED_FIFO thread oluşturulabilir. 
    SCHED_FIFO thread'lerin CPU yoğun olması diğer thread'lerin çalışamamalarına yol açabilmektedir. Bu nedenle SCHED_FIFO
    thread'lerin bloke olması ancak blokeden hızlı bir biçimde uyanıp CPU'ya atanması arzu edilir. Tabii bazen bir gömülü sistemde
    bir thread'in yoğun bir işlemi izlemesi gerekebilmektedir. Bu durumda thread'i bir çekirdeğe bağlayıp SCHED_FIFO önceliği
    verilebilir. Bu durumda adeta thread tek işlemli (single processing) bir sistemde olduğu gibi sürekli çalıştırılacaktır. 
    SCHED_RR politikası bir grup thread'in "soft realtime" işlemler için kendi aralarında zaman paylaşımlı bir biçimde çalıştırılması 
    için kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi proseslerin ve thread'lerin çizelgeleme politikaları ve SCHED_FIFO, SCHED_RR thread'lerin statik öncelikleri nasıl 
    değiştirilmektedir. İşte bu işlemler için birkaç POSIX fonksiyonu bulundurulmuştur. İzleyen paragraflarda bu fonksiyonlar 
    ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    sched_getparam ve sched_setparam POSIX fonksiyonları SCHED_FIFO ve SCHED_RR proseslerin statik önceliklerini alıp set 
    etmek için kullanılmaktadır. Bu fonksiyonları SCHED_OTHER politikasına ilişkin thread'lerle kullanmaya çalışmayınız. 
    Yine POSIX sistemlerinde bir prosesin statik önceliği değiştirildiğinde bu durum onun SCHED_FIFO ya da SCHED_RR olan 
    tüm thread'lerine yansıtılmaktadır. Ancak Linux yalnızca prosesin ana thread'i için bu işlemi yapmaktadır. Tabii Linux'ta
    gettid fonksiyonu ile thread'e özgü pid değeri (tid değeri) bu fonksiyonlara verilirse thread'e özgü işlemler yapılabilmektedir.
    Fonksiyonların prototipleri şöyledir:

    #include <sched.h>

    int sched_getparam(pid_t pid, struct sched_param *param);
    int sched_setparam(pid_t pid, const struct sched_param *param);

    Fonksiyonun birinci parametresi işlemin yapılacağı prosese ilişkin pid değeridir. Bu değer 0 girilirse fonksiyonu çağıran proses
    üzerinde (Linux'ta çağıran thread üzerinde) işlem yapılmaktadır. İkinci parametre sched_param isimli bir yapı türündendir. 
    Her ne kadar fonksiyonlar böyle bir yapı kullansalar da mevcut durumda bu yapının tek bir elemanı vardır. İleriye doğru 
    uyumu korumak için burada böyle bir yapı kullanılmıştır. Yapının mevcut durumu şöyledir:

    struct sched_param {
        int sched_priority;
    };

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde 
    set edilir.

    Yukarıda da belirttiğimiz gibi bu fonksiyonları SCHED_OTHER proses'ler için kullanmamalıyız. Linux'ta sched_getparam, 
    SCHED_OTHER prosesler için her zaman 0 değerini vermektedir. Linux'ta herhangi bir prosesin statik önceliğinin alınması için 
    bir koşul gerekmemektedir. Ancak diğer işletim sistemlerinde bunun için koşullar gerekebilmektedir. Proseslerin statik 
    önceliklerinin set edilmesi için prosesin uygun önceliğe (root önceliği ya da Linux'ta capability'e) sahip olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bir prosesin çizelgeleme politikasını almak ya da değiştirmek için sched_getscheduler ve sched_setscheduler POSIX fonksiyonları
    kullanılmaktadır. sched_getscheduler fonksiyonu yalnızca prosesin çizelgeleme politikasını almaktadır. Ancak sched_setscheduler
    fonksiyonu hem çizelgeleme politikasını set etmekte hem de eğer politika SCHED_FIFO ya da SCHED_RR ise onun statik önceliğini 
    set etmektedir. Fonksiyonların prototipleri şöyledir:

    #include <sched.h>

    int sched_getscheduler(pid_t pid);
    int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param)

    Fonksiyonların birinci parametreleri hedef prosesin pid değerini belirtir. Bu değer 0 geçilirse çağıran proses üzerinde
    işlem yapılır. sched_setscheduler fonksiyonunun ikinci parametresi çizelgeleme politikasını, üçüncü parametresi ise 
    SCHED_FIFO ve SCHED_RR thread'lerin statik önceliklerini belirtmektedir. Fonksiyonlar başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönerler. Prosesin çizelgeleme politikasının değiştirilmesi için prosesin "uygun 
    önceliğe (appropriate privileges)" sahip olması gerekmektedir.

    Prosesin çizelgeleme politikası SCHED_OTHER yapılırken sched_param yapısının sched_priority değeri Linux sistemlerinde 0 olarak
    ayarlanmalıdır. Aksi takdirde Linux sistemleri EINVAL errno değeri ile başarısız olmaktadır. POSIX standartlarında bu durum işletim sistemlerini
    yazanların isteğine bırakılmıştır. (implementation defined)

    POSIX standartlarına göre bu iki fonksiyon, prosesin tüm thread'leri üzerinde etkili olmaktadır. Ancak Linux sistemlerinde 
    yalnızca ilgili thread üzerinde etkili olmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte proses kendisinin çizelgeleme politikasını SCHED_FIFO olarak statik öncelik derecesini de 1 olarak 
    değiştirmektedir. Tabii bu programı root önceliği ile "sudo" yaparak çalıştırmalısınız. Prosesin politikasının ve öncelik 
    derecesinin değiştirilebilmesi için prosesin uygun önceliğe sahip olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sched.h>

void exit_sys(const char *msg);

int main(void)
{
    struct sched_param sparam;
    int policy;

    sparam.sched_priority = 10;

    if (sched_setscheduler(0, SCHED_FIFO, &sparam) == -1)
        exit_sys("sched_setscheduler");

    printf("success...\n");

    if ((policy = sched_getscheduler(0)) == -1)
        exit_sys("sched_getscheduler");

    switch (policy) {
        case SCHED_FIFO:
            printf("SCHED_FIFO policy\n");
            break;
        case SCHED_RR:
            printf("SCHED_RR policy\n");
            break;
        case SCHED_OTHER:
            printf("SCHED_OTHER policy\n");
            break;
        default:
            printf("Any other policy\n");
            break;
    }

    getchar();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                68. Ders 23/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bazen özellikle SCHED_FIFO ya da SCHED_RR thread'lerin kendi isteği ile CPU'yu bırakması istenebilmektedir. Örneğin bir 
    SCHED_FIFO thread CPU'yu tekeline aldığı için hiç bloke olmadan CPU'yu bırakmak isteyebilir. Tabii bu tür gereksinimlerle
    oldukça seyrek bir biçimde karşılaşılmaktadır. İşte bu işlem sched_yield isimli POSIX fonksiyonuyla yapılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <sched.h>

    int sched_yield(void);

    Fonksiyon her zaman o anda çalışmakta olan thread'in çalışmasına ara vererek hiç bloke olmadan ilgili thread'in kendi 
    önceliğindeki çalışma kuyruğunun sonuna yerleştirilmesine yol açmaktadır. Örneğin sistemde şu thread'ler bulunuyor olsun:

    T1(12, FIFO), T2(12, FIFO), T3(12, RR)

    Burada işletim sistemi kuyruğun önündeki FIFO thread'i CPU'ya atayacaktır. Şimdi bu thread hiç bloke olmazsa hep CPU'da
    çalışmaya devam edecektir. İşte programcı sched_yield fonksiyonunu çağırırsa bu durumda bu thread kuyruğun sonuna yerleştirilecektir:

    T2(12, FIFO) T3(12, RR), T1(12, FIFO)

    Bu durumda artık kuyruğun başında T2 thread'i bulunduğu için o thread çizelgelenecektir.

    sched_yield fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Tabii fonksiyonun 
    başarısız olma olasılığı aslında yoktur. POSIX standartlarında başarısızlık durumunda herhangi bir errno kodu da belirtilmemiştir. 
    Linux sistemlerinde fonksiyon her zaman başarılı olmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar hep proses temelinde çalışan çizelgeleme fonksiyonlarını gördük. Ancak yukarıda da belirttiğimiz gibi 
    bu fonksiyonlar Linux sistemlerinde yalnızca prosesin tüm thread'leri üzerinde değil yalnızca tek bir thread üzerinde 
    etkili oluyordu. (Yani bu bağlamda Linux, POSIX standartlarını tam olarak desteklememektedir.) Pekiyi biz belli bir thread'in
    çizelgeleme özellikleri değiştirebilir miyiz? Linux sistemlerinde bunu thread'e özgü pid değerinden hareketle yapabiliyorduk. 
    Aslında POSIX standartlarında thread'e özgü çizelgeleme belirlemelerinin yapılması da mümkündür.

    POSIX standartlarına göre belli bir thread'in çizelgeleme özellikleri thread yaratılırken özellik bilgisi yoluyla belirlenebilmektedir
    ya da bazı özellikler sonra da değiştirilebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread yaratılırken thread özellikleri ile thread'lerin bazı özelliklerinin set edilebildiğini görmüştük. İşte belli bir thread'in
    çizelgeleme özellikleri de thread yaratılırken thread özellikleri ile belirlenebilmektedir. Bunun için kullanılan POSIX fonksiyonları
    şöyledir:

    #include <pthread.h>

    int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);
    int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
    int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
    int pthread_attr_setschedparam(pthread_attr_t * attr, const struct sched_param *param);

    Belli bir thread için çizelgeleme politikasının set edilmesi pthread_attr_setschedpolicy fonksiyonuyla yapılmaktadır. 
    SCHED_FIFO ve SCHED_RR politikalarına ilişkin thread'lerin statik öncelikleri ise pthread_attr_setschedparam fonksiyonu 
    ile set edilmektedir. Bu bilgiler yine özellik nesnesinin içerisinden pthread_attr_getschedpolicy ve pthread_attr_getschedparam 
    fonksiyonlarıyla elde edilebilmektedir. Tabii bu özellik bilgilerinin değiştirilebilmesi için prosesin uygun önceliğe sahip 
    olması gerekmektedir. Tabii kontrol bu özellik bilgilerinin set edilmesi sırasında değil thread'in yaratılması sırasında 
    yapılmaktadır. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    POSIX standartlarında SCHED_OTHER politikasına sahip bir thread'in nice değerini değiştirebilecek bir fonksiyon bulunmamaktadır. 
    Yukarıdaki fonksiyonlar SCHED_FIFO ve SCHED_RR politikaları için düşünülmüştür. Ancak Linux sistemlerinde anımsanacağı gibi 
    sched_setpriority fonksiyonu thread'e özgü pid değeri ile bu işlemi yapabilmektedir.

    Ancak yukarıdaki yöntemle thread'lerin çizelgeleme bilgilerini değiştirebilmek için öncelikle pthread_attr_setinheritsched
    fonksiyonu ile çizelgeleme özelliklerinin üst thread'ten alınmayacağı belirtilmelidir. Bunun için pthread_attr_setinheritsched
    fonksiyonu PTHREAD_EXPLICIT_SCHED parametresiyle çağrılmalıdır. Bu fonksiyonun (ve get eden fonksiyonun) prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched);
    int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);

    Aşağıdaki örnekte SCHED_FIFO çizelgeleme politikası ile statik önceliği 10 olan bir thread yaratılmıştır. Programı sudo ile 
    çalıştırmayı unutmayınız. Programı çalıştırdıktan sonra diğer bir terminalden durumu gözlediğimizde aşağıdaki gibi bir
    durum ortaya çıkmaktadır:

    $ ps -T --tty pts/2 -o pid,pri,policy,cmd,tid
    PID PRI POL CMD                             TID
    9251  19 TS  sudo ./sample                  9251
    9252  19 TS  ./sample                       9252
    9252  50 FF  ./sample                       9253

    Burada prosesin ana thread'inin SCHED_OTHER olduğunu ancak bizim yarattığımız thread'in SCHED_FIFO olduğunu görüyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sched.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;
    struct sched_param sparam;

    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);

    if ((result = pthread_attr_setinheritsched(&tattr, PTHREAD_EXPLICIT_SCHED)) != 0)
        exit_sys_errno("pthread_attr_setinheritsched", result);

    if ((result = pthread_attr_setschedpolicy(&tattr, SCHED_FIFO)) != 0)
        exit_sys_errno("pthread_attr_setschedpolicy", result);

    sparam.sched_priority = 10;

    if ((result = pthread_attr_setschedparam(&tattr, &sparam)) != 0)
        exit_sys_errno("pthread_attr_setschedparam", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);

    printf("Press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pause();

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Bir thread yaratıldıktan sonra da onun çizelgeleme politikaları statik öncelikleri değiştirilebilmektedir. Bu işlem 
    pthread_setschedparam fonksiyonuyla yapılmaktadır. Thread'e ilişkin bu bilgiler pthread_getschedparam fonksiyonu ile
    elde edilebilmektedir. Bu fonksiyonlar hem çizelgeleme politikasında hem de statik öncelikler konusunda etkili olmaktadır. 
    Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param);
    int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param);

    Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Tabii pthread_setschedparam
    fonksiyonunun başarılı olması için prosesin uygun önceliğe sahip olması gerekmektedir.

    Aşağıdaki örnekte önce bir thread yaratılmış daha sonra yaratılmış olan thread'in çizelgeleme politikası SCHED_FIFO, 
    statik önceliği de 10 olacak biçimde pthread_setschedparam fonksiyonu ile değiştirilmiştir. Yine değişikliği başka bir 
    terminalden ps komutu ile görebilirsiniz:

    $ ps -T --tty pts/2 -o pid,pri,policy,cmd,tid
    PID PRI POL CMD                             TID
    9909  19 TS  sudo ./sample                  9909
    9910  19 TS  ./sample                       9910
    9910  50 FF  ./sample                       9911
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sched.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    struct sched_param sparam;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    sparam.sched_priority = 10;

    if ((result = pthread_setschedparam(tid, SCHED_FIFO, &sparam)) != 0)
            exit_sys_errno("pthread_setschedparam", result);

    printf("Press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pause();

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    SCHED_FIFO ve SCHED_RR thread'lerin yalnızca statik önceliklerinin değiştirilmesi için pthread_setschedprio fonksiyonu kullanılmaktadır. 
    Bu fonksiyonun bir get versiyonu yoktur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_setschedprio(pthread_t thread, int prio);

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Bu fonksiyonlar SCHED_OTHER 
    politikası için kullanılmamalıdır.

    Aşağıdaki örnekte bir thread'in çizelgeleme politikası SCHED_FIFO yapılıp, statik önceliği de 10 olarak ayarlanmıştır. Sonra 
    pthread_setschedprio fonksiyonu ile bu öncelik 20 olarak değiştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sched.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    struct sched_param sparam;
    int policy;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    sparam.sched_priority = 10;

    if ((result = pthread_setschedparam(tid, SCHED_FIFO, &sparam)) != 0)
        exit_sys_errno("pthread_setschedparam", result);

    if ((result = pthread_getschedparam(tid, &policy, &sparam)) != 0)
        exit_sys_errno("pthread_getschedparam", result);

    printf("%d\n", sparam.sched_priority);

    if ((result = pthread_setschedprio(tid, 20)) != 0)
        exit_sys_errno("pthread_setschedprio", result);

    if ((result = pthread_getschedparam(tid, &policy, &sparam)) != 0)
        exit_sys_errno("pthread_getschedparam", result);

    printf("%d\n", sparam.sched_priority);

    printf("Press Ctrl+C to exit...\n");

    if ((result = pthread_join(tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pause();

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da defalarca söylendiği gibi POSIX standartlarında belli bir SCHED_OTHER thread'in nice değerini (yani dinamik 
    önceliğini) değiştirmenin standart bir yolu yoktur. setpriority ve getpriority fonksiyonları POSIX'te proses temelinde 
    çalışmaktadır ve bu fonksiyonlar prosesin tüm thread'leri üzerinde etkili olmaktadır. Ancak defalarca belirttiğimiz gibi 
    Linux'ta bu fonksiyonlar thread'e özgü işlemler yapabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                69. Ders 29/07/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Çok işlemcili ya da çok çekirdekli sistemlerde belli bir thread'in hangi işlemci ya da çekirdeğin çalışma kuyruğuna atanacağı
    işletim sisteminin sorumluluğundadır. İşletim sistemleri toplam faydayı göz önüne alarak bu atamayı yapar. Örneğin sistemimizde 
    dört çekirdek olsun. Biz de 4 thread'li bir program yazmış olalım. İşletim sistemi bizim prosesimizin bu dört thread'ini 
    ayrı çekirdeklere atamayabilir. Çekirdeklerin cache'leri birbirinden ayrı olduğu için aynı prosesin thread'lerinin aynı 
    çekirdeğe atanması aslında toplam fayda bakımından işletim sisteminin tercih edeceği bir durumu oluşturabilmektedir. Ancak 
    programcı özel bazı nedenlerden dolayı belli bir thread'in belli bir işlemci ya da çekirdeğin çalışma kuyruğuna atanmasını 
    işletim sisteminden isteyebilir. Örneğin her ne kadar aynı prosesin thread'lerinin aynı işlemci ya da çekirdeğin çalışma 
    kuyruğuna atanması toplam fayda bakımından daha iyi olabiliyorsa da bu durum paralel programlamayı sekteye uğratabilmektedir. 
    Prosesin farklı thread'lerinin farklı işlemci ya da çekirdeklerin çalışma kuyruklarına atanması onların eş zamanlı bir biçimde 
    çalışabilmelerine olanak sağlayabilmektedir.

    İşletim sistemlerinde belli bir thread'in belli bir işlemci ya da çekirdek tarafından çalıştırılmasının sağlanmasına 
    İngilizce "processor affinity" denilmektedir. UNIX/Linux sistemlerinde "processor affinity" bazı fonksiyonlarıyla
    sağlanmaktadır. "Processor affinity" konusu taşınabilir bir konu olmadığı için POSIX standartlarına yansıtılmamıştır. 
    Dolayısıyla bu işlemler işletim sistemine özgü sistem fonksiyonlarıyla ya da onları sarmalayan kütüphane fonksiyonlarıyla
    sağlanmaktadır. GNU libc kütüphanesinde bu konuyla ilgili iki fonksiyon bulunmaktadır:

    #define _GNU_SOURCE

    #include <sched.h>

    int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);
    int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);

    Fonksiyonların birinci parametresi ilgili thread'in pid değerini belirtmektedir. (Yani bu fonksiyonlara biz gettid fonksiyonundan
    elde edilen thread'e özgü pid değerlerini geçirebiliriz.) Bu pid parametresi 0 geçilirse fonksiyonu çağıran thread anlaşılmaktadır. 
    Fonksiyonların üçüncü parametresi cpu_set_t türündedir. Bu tür aslında default olarak 1024 bite sahip olan bir veri yapısıdır. 
    Bu veri yapısı muhtemelen aşağıdakine benzer biçimde typedef edilmiştir:

    typedef struct {
        unsigned long bitarray[16];
    } cpu_set_t;

    Bu türden bir nesnenin bitlerini set ya da reset etmek için çeşitli makrolar bulundurulmuştur. Bu makroların önemli olanları 
    şunlardır:

    void CPU_ZERO(cpu_set_t *set);
    void CPU_SET(int cpu, cpu_set_t *set);
    void CPU_CLR(int cpu, cpu_set_t *set);
    int CPU_ISSET(int cpu, cpu_set_t *set);
    int CPU_COUNT(cpu_set_t *set);

    CPU_ZERO makrosu tüm bit dizisini sıfırlamaktadır. CPU_SET makrosu bit dizisi dizisi içerisindeki belli bir biti 1 yapmaktadır. 
    CPU_CLR makrosu ise bit dizisi içerisindeki belli bir biti 0 yapmaktadır. Bit dizisi içerisindeki belli bir bitin durumunu almak 
    için CPU_ISSET makrosu kullanılmaktadır. CPU_COUNT makrosu ise bit dizisinde kaç bit olduğunu vermektedir. Aslında <sched.h> 
    içerisinde daha pek çok makro vardır. Bunları dokümanlardan inceleyebilirsiniz. Makinemizdeki işlemci ya da çekirdeklerin numaraları
    0'dan başlamaktadır.

    sched_setaffinity ve sched_getaffinity fonksiyonlarındaki ikinci parametre olan cpusetsize, üçüncü parametredeki bit dizisinin 
    byte uzunluğunu belirtmektedir. Bu parametreye tipik olarak üçüncü parametredeki yapı nesnesinin sizeof değeri geçirilir. 
    Fonksiyonlar başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. Tabii sched_setaffinity fonksiyonuna verdiğimiz
    bit dizisindeki elemanların yalnızca CPU sayısı kadar olanları dikkate alınmaktadır. Biz bu fonksiyon ile kendi thread'lerimizin
    CPU ayarını değiştirebiliriz. Ancak başkalarına ait thread'lerin ayarlarını değiştiremeyiz. sched_setaffinity fonksiyonunun başarılı 
    olabilmesi için fonksiyonu çağıran prosesin etkin kullanıcı id'sinin hedef thread'e ilişkin prosesin gerçek kullanıcı id'si 
    ile ya da etkin kullanıcı id'si ile aynı olması gerekmektedir. Tabii proses uygun önceliğe sahipse (appropriate privileges)
    bu durumda herhangi bir thread'in CPU ayarını değiştirebilir.

    Fonksiyonların ikinci parametresine neden gereksinim duyulduğu konusunda tereddütler oluşabilmektedir. Aslında cpu_set_t türünü
    kütüphaneyi yazanlar typedef ettiği için onun sizeof değerini zaten biliyor durumdadırlar. Ancak her ne kadar bu cpu_set_t 
    türü 128 byte yani 1024 bit uzunluğundaysa da CPU ya da çekirdek sayısının çok fazla olduğu sistemlerde bunun artırılması 
    gerekebilmektedir. Bunun artırılması için CPU_ALLOC makrosu kullanılmaktadır. Bu biçimde tahsis edilmiş olan cpu_set_t
    nesnesinin byte uzunluğu CPU_ALLOC_SIZE makrosuyla elde edilmektedir. İşte aslında programcının daha büyük cpu_set_t kullanabileceği 
    olasılığı nedeniyle bu fonksiyonlar bu bit dizisinin byte uzunluğunu da bizden istemektedir.

    Linux sistemlerinde fork işlemiyle birlikte üst prosesin CPU ayarları alt prosese aktarılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte hem ana thread'in hem de yaratılan thread'in kullanabileceği CPU değiştirilmiştir. Ana thread 1 numaralı 
    CPU'yu, yaratılan thread ise 2 numaralı CPU'yu kullanacak biçimde ayarlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sched.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int result;
    cpu_set_t cpuset;
    pthread_t tid;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);

    if (sched_setaffinity(0, sizeof(cpuset), &cpuset) == -1)
        exit_sys("sched_setaffinity");

    printf("Ok\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    pid_t pid;
    cpu_set_t cpuset;

    CPU_ZERO(&cpuset);
    CPU_SET(3, &cpuset);

    if (sched_setaffinity(0, sizeof(cpuset), &cpuset) == -1)
        exit_sys("sched_setaffinity");

    printf("Ok\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Linux'ta ayrıca pthread fonksiyonlarına benzer biçimde thread'in CPU ayarını değiştiren ve alan iki fonksiyon daha
    bulundurulmuştur:

    #define _GNU_SOURCE        /* See feature_test_macros(7) */
    #include <pthread.h>

    int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
    int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset);

    Bu fonksiyonların yukarıdaki fonksiyonlardan farkı thread'e ilişkin pid değeri yerine bizzat pthread_t türüyle belirtilen
    thread id değerini almasıdır. Böylece biz başka bir thread'in akışı içerisinde olmadan onların CPU ayarlarını değiştirebiliriz. 
    Tabii bu iki fonksiyon da Linux'a özgüdür. Yani taşınabilir fonksiyonlar değildir. Fonksiyonlar diğer thread fonksiyonlarında 
    olduğu gibi başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

    Aşağıdaki örnekte yine ana thread'in ve yaratılmış olan thread'in CPU ayarı değiştirilmiştir. Ancak bu değişiklik 
    pthread_setaffinity_np fonksiyonuyla yapılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    int result;
    cpu_set_t cpuset;
    pthread_t tid;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);

    if ((result = pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset)) != 0)
        exit_sys_errno("pthread_setaffinity_np", result);

    CPU_ZERO(&cpuset);
    CPU_SET(2, &cpuset);

    if ((result = pthread_setaffinity_np(tid, sizeof(cpuset), &cpuset)) != 0)
        exit_sys_errno("pthread_setaffinity_np", result);

    printf("Ok\n");

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    printf("Ok\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz işin başında makinemizde kaç CPU ya da çekirdek olduğunu anlayabilir miyiz? Bunu anlamının bir yolu komut 
    satırında nproc ya da lscpu komutlarını kullanmaktır. Örneğin:

    $ nproc
    3

    Örneğin:

    $ lscpu
    Mimari:                           x86_64
    İşlemci işlem-kipi:             32-bit, 64-bit
    Address sizes:                  45 bits physical, 48 bits virtual
    Bayt Sıralaması:                Little Endian
    İşlemciler:                       3
    Çevrimiçi işlemci(ler) listesi: 0-2
    Sağlayıcı Kimliği:                AuthenticAMD
    Modem ismi:                     AMD Ryzen 7 5700G with Radeon Graphics
        İşlemci ailesi:               25
        Model:                        80
        Çekirdek başına iş parçacığı: 1
        Soket başına çekirdek:        1
        Soket(ler):                   3
        Adımlama:                     0
        BogoMIPS:                     7585.55
        Bayraklar:                    fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflus
                                    h mmx fxsr sse sse2 syscall nx mmxext pdpe1gb rdtscp lm constant_tsc rep_good 
                                    nopl tsc_reliable nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq s
                                    sse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hype
                                    rvisor lahf_lm cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw topoext ibp
                                    b vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt
                                    clwb sha_ni xsaveopt xsavec xgetbv1 xsaves clzero arat umip vaes vpclmulqdq r
                                    dpid overflow_recov succor fsrm
    Virtualization features:
    Hypervizör sağlayıcı:           VMware
    Sanallaştırma tipi:             tam
    Caches (sum of all):
    L1d:                            96 KiB (3 instances)
    L1i:                            96 KiB (3 instances)
    L2:                             1,5 MiB (3 instances)
    L3:                             48 MiB (3 instances)
    NUMA:
    NUMA düğümü(leri):              1
    NUMA düğüm0 işlemci:            0-2
    Vulnerabilities:
    L1tf:                           Not affected
    Mds:                            Not affected
    Meltdown:                       Not affected
    Mmio stale data:                Not affected
    Retbleed:                       Not affected
    Spec store bypass:              Vulnerable
    Spectre v1:                     Mitigation; usercopy/swapgs barriers and __user pointer sanitization
    Spectre v2:                     Mitigation; Retpolines, IBPB conditional, STIBP disabled, RSB filling, PBRSB-e IBRS Not affected
    Srbds:                          Not affected
    Tsx async abort:                Not affected
    itlb multihit:                  Not affected

    Aslında bu komutlar proc dosya sisteminden bu bilgileri almaktadır. proc dosya sisteminde /proc/cpuinfo dosyasında bu bilgiler
    bulunmaktadır. Doğrudan cat komutu ile bu bilgiler alınabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında o anda sistemde kaç işlemci ya da çekirdek olduğu Linux'a özgü get_nprocs, get_nprocs_conf fonksiyonlarıyla 
    elde edilebilmektedir. Fonksiyonların prototipleri şöyledir:

    #include <sys/sysinfo.h>

    int get_nprocs(void);
    int get_nprocs_conf(void);

    Buradaki get_nprocs_conf fonksiyonu makinemizdeki işlemci ya da çekirdek sayısını, get_nprocs fonksiyonu ise hali hazırda 
    işletim sisteminin dikkate alarak kullandığı işlemci ya da çekirdek sayısını belirtmektedir. Genel olarak işletim sistemlerinde 
    biz işletim sistemine "makinede şu kadar işlemci ya da çekirdek var ancak sen bunların şu kadarını kullan, diğerlerini 
    görmezden gel" diyebilmekteyiz. Bu fonksiyonlar başarısız olamamaktadır.

    Aşağıdaki örnekte bu fonksiyonların kullanımına örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <sys/sysinfo.h>

int main(void)
{
    printf("get_nprocs: %d\n", get_nprocs());
    printf("get_nprocs_conf: %d\n", get_nprocs_conf());

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Linux'a özgü sched_getcpu isimli fonksiyon o anda fonksiyonu çağıran thread'in hangi işlemci ya da çekirdekte çalışmakta 
    olduğu bilgisini vermektedir. Fonksiyonun prototipi şöyledir:

    #define _GNU_SOURCE

    #include <sched.h>

    int sched_getcpu(void);

    Aşağıdaki örnekte bu fonksiyonun kullanımına örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <sched.h>

int main(void)
{
    printf("CPU: %d\n",sched_getcpu());
    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Thread güvenliliği (thread safety) genel olarak fonksiyonlar için kullanılan bir kavramdır. Bir fonksiyonun thread güvenli
    olması "o fonksiyonu birden fazla thread aynı anda çağırırsa bir sorunun oluşmaması" anlamına gelmektedir. Thread güvenli 
    fonksiyonları biz farklı thread'lerden aynı anda çağırabiliriz. Bu durumda bir sorun oluşmaz.

    Pekiyi bir fonksiyonu thread güvenli (thread safe) olmaktan çıkartan şeyler nelerdir? Şüphesiz bir fonksiyon yalnızca yerel 
    değişkenleri ve parametre değişkenlerini kullanıyorsa o fonksiyon zaten thread güvenlidir. Fonksiyonları thread güvenli olmaktan
    çıkartan unsur statik veri (data) ya da kaynak kullanmaktır. Örneğin bir fonksiyon bir global değişkeni değiştiriyorsa
    ve bu işlem için bir senkronizasyon uygulamamışsa bu fonksiyon thread güvenli olamaz. Çünkü bu fonksiyon birden fazla thread 
    tarafından tesadüfen aynı anda çağrılırsa global değişkenin değeri bozulur. Benzer biçimde statik yerel değişkenleri kullanan
    fonksiyonlar da thread güvenli değildir. Örneğin C'nin localtime fonksiyonu bizden epoch'tan geçen saniye sayısını parametre 
    olarak alır ve onu ayrıştırarak statik bir time_t yapı nesnesinin içerisine yerleştirir ve o nesnenin adresini bize verir. 
    Örneğin:

    time_t t;
    struct tm *ptm;
    ...

    t = time(NULL);
    ptm = localtime(&t);

    Burada localtime fonksiyonu şöyle yazılmıştır:

    struct tm *localtime(time_t *pt)
    {
        static struct tm result;

        <result'ın içi dolduruluyor>

        return &result;
    }

    Burada result değişkeninin toplamda tek bir kopyası olduğuna göre farklı thread'ler aslında aynı nesne üzerinde işlem yapmaktadır. 
    Bu da fonksiyonun iki farklı thread tarafından aynı anda çağrıldığında soruna yol açacağı anlamına gelir.

    Bir fonksiyon statik ömürlü nesne kullanmadığı halde ortak başka kaynakları da kullanıyor olabilir. Bu tür fonksiyonlar da
    thread güvenli değildir.

    Pekiyi biz başkaları tarafından yazılmış olan foo fonksiyonunun thread güvenli olmadığını biliyorsak onu nasıl kullanmalıyız?
    Tabii burada tek seçeneğimiz bir mutex nesnesi ile onu kilitleyerek kullanmaktır. Örneğin:

    pthread_mutex_lock(...);
    foo();
    pthread_mutex_unlock(...);

    Tabii bu kilitleme işleminin de bir zaman maliyeti vardır.

    Biz başkaları tarafından yazılmış olan kütüphaneleri kullanırken onların dokümantasyonlarına bakarak oradaki fonksiyonların
    thread güvenli olup olmadığını öğrenmeliyiz. Eğer kullanacağımız fonksiyon thread güvenli değilse onu yukarıda belirttiğimiz
    gibi bir mutex nesnesi ile kilitlemeliyiz.

    Pekiyi static nesne kullanan standart C fonksiyonları tasarımları gereği thread güvenli olamayacağına göre onları çok 
    thread'li uygulamalarda nasıl kullanmalıyız? Microsoft 2004 yılına kadar standart C kütüphanesinin thread güvenli versiyonuyla
    thread güvenli olmayan versiyonunu ayrı ayrı bulunduruyordu. Ancak 2004 yılında makinelerin hızlandığı gerekçesiyle 
    artık yalnızca thread güvenli standart C kütüphanesini bulundurmaya başlamıştır. Yani biz Micosoft C derleyicilerinde çalışıyorsak
    ilgili standart C fonksiyonları özünde thread güvenli bir tasarıma sahip değilse de Microsoft tarafından thread güvenli hale
    getirilmiştir. Pekiyi UNIX/Linux sistemlerinde durum nasıldır? İşte bu sistemlerde thread güvenlilik konusunda problemli 
    fonksiyonların iki ayrı versiyonu yazılmıştır. Default versiyonlar thread güvenli değildir. Ancak sonu _r ile biten fonksiyonlar
    bunların thread güvenli versiyonlarıdır. Örneğin localtime fonksiyonu thread güvenli değildir. Ancak localtime_r fonksiyonu 
    localtime fonksiyonunun thread güvenli versiyonudur. Burada dikkat edilmesi gereken nokta şudur: POSIX sistemlerinde xxx_r 
    fonksiyonları orijinal fonksiyonlardan farklı parametrik yapılara sahiptir. Bu xxx_r fonksiyonlarında statik nesne kullanımı 
    ortadan kaldırıldığı için bu fonksiyonların parametrik yapıları da orijinalinden farklıdır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                                70. Ders 30/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Örneğin rand fonksiyonu statik veri kullandığı için thread güvenli değildir. Bilindiği gibi srand fonksiyonu "tohum (seed)"
    diye belirtilen bir global değişkeni set eder. Sonra rand fonksiyonu da bu global değişkenden hareketle yeni değerleri elde 
    eder. Her rand çağrıldığında bu global değişkenin değeri güncellenmektedir. D. Ritchie ve B. Kernighan'ın "The C Programming 
    Language" kitabında rand fonksiyonun olası bir gerçekleştirimi şöyle verilmiştir (değişken isimleri değiştirilmiştir):

    unsigned long int g_seed = 1;

    void srand(unsigned int seed)
    {
        g_seed = seed;
    }

    int rand(void)
    {
        g_seed = g_seed * 1103515245 + 12345;

        return (unsigned int)(g_seed / 65536) % 32768;
    }

    Statik veri kullandığı için UNIX/Linux sistemlerinde iki thread'in bu rand ve srand fonksiyonlarını kullanması uygun değildir. 
    İşte rand fonksiyonunun thread güvenli biçimi rand_r ismiyle oluşturulmuştur. rand_r fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    int rand_r(unsigned int *seedp);

    Burada fonksiyon tohum değere ilişkin nesnenin adresini almaktadır. Böylece fonksiyonun static veri kullanmasına gerek 
    kalmamaktadır. Tabii aslında fonksiyona istenirse global bir nesnenin de adresi verilebilir. Ancak burada önemli olan nokta 
    farklı thread'lerin farklı tohum nesnelerini kullanıyor olmasıdır.

    Aşağıdaki örnekte iki thread de rand_r fonksiyonunu kullanmıştır. Ancak bu thread'ler farklı tohum değerleri (seed) 
    kullandığı için bir sorun olmayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);

void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    unsigned seed = time(NULL) + 123;
    int randval;

    for (int i = 0; i < 10; ++i) {
        printf("thread-1: %d\n", i);

        randval = rand_r(&seed);
        usleep(randval % 500000);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    unsigned seed = time(NULL) + 567;
    int randval;

    for (int i = 0; i < 10; ++i) {
        printf("thread-2: %d\n", i);

        randval = rand_r(&seed);
        usleep(randval % 500000);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Örneğin localtime fonksiyonu bize statik bir struct tm nesnesinin adresi vermektedir. Bu nedenle bu fonksiyon thread güvenli 
    değildir. Fonksiyonun thread güvenli biçimi şöyledir:

    #include <time.h>

    struct tm *localtime_r(const time_t *timep, struct tm *result);

    Burada localtime_r fonksiyonu kendi struct tm nesnesini alarak onun adresine geri dönmektedir. Yani kullanım şöyle olmalıdır:

    time_t t;
    struct tm tmval, *ptm;

    t = time(NULL);

    ptm = localtime_r(&t, &tmval);
    printf("%02d:%02d:%02d\n", ptm->tm_hour, ptm->tm_min, ptm->tm_sec);

    Tabii aslında localtime_r fonksiyonunun geri dönüş değerini kullanmak zorunda değiliz. Zaten bu geri dönüş değeri bizim 
    verdiğimiz nesnenin adresidir. Yani kullanım şöyle de olabilirdi:

    time_t t;
    struct tm tmval;

    t = time(NULL);

    localtime_r(&t, &tmval);
    printf("%02d:%02d:%02d\n", tmval.tm_hour, tmval.tm_min, tmval.tm_sec);
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde yalnızca bazı standart C fonksiyonlarının xxx_r'li versiyonları yoktur. Aynı zamanda statik veri 
    kullanan bazı POSIX fonksiyonlarının da xxx_r'li versiyonları vardır. Örneğin getpwnam, getpwuid gibi fonksiyonlar statik 
    nesnelerin adreslerini geri döndürmektedir. Aşağıda bu iki fonksiyonun normal ve _r'li versiyonlarının prototipleri verilmiştir:

    #include <sys/types.h>
    #include <pwd.h>

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };

    struct passwd *getpwnam(const char *name);
    struct passwd *getpwuid(uid_t uid);

    int getpwnam_r(const char *name, struct passwd *pwd, char *buf, size_t buflen, struct passwd **restrict result);
    int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf, size_t buflen, struct passwd **restrict result);

    Fonksiyonların _r'li versiyonları /etc/passwd dosyasındaki satırların yerleştirileceği tampon alanın adresini ve uzunluğunu 
    da istemektedir. Bu fonksiyonlara biz aynı zamanda struct passwd nesnelerinin adreslerini veririz. Fonksiyonların son 
    parametrelerine başarı durumunda bizim verdiğimiz struct passwd nesnesinin adresi yerleştirilir. Başarısızlık durumunda ise
    bu nesneye NULL adres yerleştirilmektedir. Fonksiyonların bu _r'li versiyonları başarı durumunda 0, başarısızlık durumunda 
    errno değerine geri dönmektedir. Fonksiyona vereceğimiz tamponun büyüklüğü sysconf(_SC_GETPW_R_SIZE_MAX) çağrısıyla elde 
    edilebilmektedir. Ancak biz aşağıdaki örnekte geniş bir tampon tutarak fonksiyonu çağırıyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pwd.h>

int main(void)
{
    char buf[4096];
    struct passwd pwd, *ppwd;
    int result;

    result = getpwnam_r("kaan", &pwd, buf, 4096, &ppwd);

    if (result != 0) {
        fprintf(stderr, "getpwnam_r: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    if (ppwd == NULL) {
        fprintf(stderr, "no user found...\n");
        exit(EXIT_FAILURE);
    }
    printf("%s, %lld\n", pwd.pw_name, (long long)pwd.pw_uid);

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    Statik veri kullanan standart C fonksiyonlarının ve POSIX fonksiyonlarının xxx_r'li versiyonlarının nasıl kullanıldığını
    dokümanlardan öğrenebilirsiniz. Biz burada yalnızca birkaç fonksiyonu açıkladık.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Global nesneler ve heap'te yaratılan nesneler thread'ler arasında ortak bir biçimde kullanılıyordu. Ancak thread'lerin 
    stack'leri birbirinden ayrılmıştı. Pekiyi thread'e özgü global değişken gibi bir kavram olabilir mi? Örneğin aşağıdaki gibi 
    bir foo fonksiyonu olsun:

    void foo(void)
    {
        ...
        g_a = ...;
        ...
    }

    Burada g_a'nın global bir değişken olduğunu düşünelim. Bu durumda hangi thread foo fonksiyonunu çağırmış olursa olsun
    toplamda bir tane g_a olduğu için bu thread'lerin hepsi aynı global değişkeni kullanıyor olacaktır. Şimdi bu g_a 
    global değişkeninin tıpkı stack'teki yerel değişkenlerde olduğu gibi thread'e özgü bir kopyasının bulunduğunu varsayalım. 
    Bu durumda bu foo fonksiyonunu hangi thread çağırmışsa bu global değişken o thread'in global değişkeni olacaktır. İşte
    bu biçimde thread'e özgü statik veri kullanımını sağlamaya UNIX/Linux dünyasında "Thread Specific Data (TSD)", Windows 
    dünyasında "Thread Local Storage (TLD)" denilmektedir.

    İşletim sistemi bir thread yaratıldığında yalnızca o thread için bir stack yaratmaz. Aynı zamanda o thread için bir 
    TSD (Thread Specific Data) alanı da yaratır. Her thread için nasıl bir stack alanı varsa ve o stack alanı o thread'e 
    özgü ise her thread için aynı zamanda bir TSD alanı da vardır ve o TSD alanı o thread'e özgüdür.

    Thread'ler için işletim sisteminin ayırdığı TSD alanı slotlardan oluşmaktadır. Alanın tipik veri yapısı şöyledir:

    Slot No                Pointer
    0                    ----->
    1                    NULL
    2                    ----->
    3                    NULL
    ...                    ...

    Burada her slotun bir numarası vardır. Eğer slot doluysa o slot'un pointer elemanı gerçek nesneyi göstermektedir. Eğer slot boşsa
    o slotun pointer elemanı NULL pointer değerine sahiptir.

    TSD alanının kullanımı için dört POSIX bulundurulmuştur:

    #include <pthread.h>

    int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
    int pthread_key_delete(pthread_key_t key);

    void *pthread_getspecific(pthread_key_t key);
    int pthread_setspecific(pthread_key_t key, const void *value);

    Burada slotlar pthread_key_t türü ile temsil edilmiştir. POSIX standartlarına göre bu tür herhangi bir tür olarak typedef
    edilebilirse de tipik olarak int ya da unsigned int gibi bir tamsayı türü biçiminde typedef edilmektedir.

    TSD kullanımı şöyledir:

    1) Önce pthread_key_create fonksiyonu ile boş bir slot elde edilir. Bu slot yaratılmış olan ve yaratılacak olan her thread'de 
    var olacaktır. Fonksiyonun birinci parametresi slot bilgisinin (tipik olarak numarasının) yerleştirileceği pthread_key_t 
    türünden nesnenin adresini almaktadır. Bu pthread_key_t nesnesinin tipik olarak global bir biçimde tanımlanması uygun olmaktadır. 
    Fonksiyonun ikinci parametresi slot yok edilirken çağrılacak fonksiyonu belirtmektedir. Bu parametre NULL geçilebilir. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Örneğin:

    pthread_key_t g_key;
    ...
    if ((result = pthread_key_create(&g_key, NULL) != 0)) != 0)
        exit_sys_errno("pthread_key_create", result);

    Artık biz her thread'te geçerli olan bir slot tahsis etmiş olduk. Bu slot numarasını da g_key değişkenine yerleştirmiş olduk.

    2) Programcı thread'e özgü statik verileri bir yapı olarak oluşturur. Bu yapı türünden dinamik tahsisat yapar ve tahsis ettiği
    alanın adresini pthread_setspecific fonksiyonu ile ilgili thread'in ilgili slotuna yerleştirir. pthread_setspecific fonksiyonunu
    hangi thread çağırmışsa adres o thread'in ilgili slotuna yerleştirilmektedir. pthread_setspecific fonksiyonunun birinci parametresi
    slotu belirten pthread_key_t değerini, ikinci parametresi de slota set edilecek adresi belirtmektedir. Fonksiyon yine başarı durumunda
    0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Örneğin:

    typedef struct tagTHREAD_SPECIFIC_DATA {
        int count;
        /* ... */
    } THREAD_SPECIFIC_DATA;
    ...

    void *thread_proc1(void *param)
    {
        THREAD_SPECIFIC_DATA *tsd;
        int result;

        if ((tsd = (THREAD_SPECIFIC_DATA *)malloc(sizeof(THREAD_SPECIFIC_DATA))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        tsd->count = 10;
        // ...
        if ((result = pthread_setspecific(g_key, tsd)) != 0)
            exit_sys_errno("pthread_setspecific", result);
        // ...
        return NULL;
    }

    3) Thread'in TSD alanındaki belli bir slota yerleştirilmiş olan adresin alınması pthread_getspecific fonksiyonu ile yapılmaktadır. 
    Fonksiyon slotu belirten pthread_key_t değerini parametre olarak alır ve oradaki adresi bize geri dönüş değeri olarak verir. 
    Ancak eğer böyle bir slot yoksa ya da henüz slota bir değer set edilmemişse fonksiyon NULL adrese geri dönmektedir. 
    Başarısızlık için herhangi bir errno kodu verilmemiştir. Örneğin foo fonksiyonunu herhangi bir thread akışı çağırabiliyor olsun. 
    Bu durumda ilgili thread'in TSD'de slotundan ona ilişkin adres şöyle edilecektir:

    void foo(void)
    {
        THREAD_SPECIFIC_DATA *tsd;

        if ((tsd = (THREAD_SPECIFIC_DATA *)pthread_getspecific(g_key)) == NULL) {
            fprintf(stderr, "cannot get thread specific data!...\n");
            exit(EXIT_FAILURE);
        }

        printf("%d\n", tsd->count);
        // ...
    }

    4) İlgili slot kullanım bitince iade edilebilir. pthread_key_delete fonksiyonu her thread'in TSD alanındaki slotu boşaltır.
    Fonksiyon pthread_key_t ile belirtilen slotu parametre olarak almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri dönmektedir.

    5) Pekiyi tahsis edilen dinamik alan nasıl ve ne zaman serbest bırakılacaktır? Normal olarak buradaki dinamik alan thread 
    tarafından tahsis edildiğine göre yine thread tarafından bırakılması uygun olur. Bu işlem manuel olarak yapılabileceği gibi 
    pthread_key_create fonksiyonunda "destructor" fonksiyonu girilerek de yapılabilmektedir. Buraya girilen destructor fonksiyonu 
    her yaratılmış ve adresi set edilmiş slot için sistem tarafından bir kez çağrılmaktadır. Fonksiyon çağrılırken parametresine 
    slot içerisindeki set edilmiş olan adres geçirilmektedir. Örneğin pthread_key_create fonksiyonunda key_delete_proc isimli 
    fonksiyonu parametre olarak vermiş olalım:

    void key_delete_proc(void *ptr)
    {
        free(ptr);
    }

    Aşağıda thread specific data kullanımına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void foo(void);
void key_delete_proc(void *ptr);

void exit_sys_errno(const char *msg, int eno);

pthread_key_t g_key;

typedef struct tagTHREAD_SPECIFIC_DATA {
    int count;
    /* ... */
} THREAD_SPECIFIC_DATA;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_key_create(&g_key, key_delete_proc) != 0) != 0)
        exit_sys_errno("pthread_key_create", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_key_delete(g_key)) != 0)
        exit_sys_errno("pthread_key_delete", result);

    return 0;
}

void *thread_proc1(void *param)
{
    THREAD_SPECIFIC_DATA *tsd;
    int result;

    if ((tsd = (THREAD_SPECIFIC_DATA *)malloc(sizeof(THREAD_SPECIFIC_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    tsd->count = 10;

    if ((result = pthread_setspecific(g_key, tsd)) != 0)
        exit_sys_errno("pthread_setspecific", result);

    foo();

    return NULL;
}

void *thread_proc2(void *param)
{
    THREAD_SPECIFIC_DATA *tsd;

    if ((tsd = (THREAD_SPECIFIC_DATA *)malloc(sizeof(THREAD_SPECIFIC_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    tsd->count = 20;

    if ((result = pthread_setspecific(g_key, tsd)) != 0)
        exit_sys_errno("pthread_setspecific", result);

    foo();

    return NULL;
}

void foo(void)
{
    THREAD_SPECIFIC_DATA *tsd;

    if ((tsd = (THREAD_SPECIFIC_DATA *)pthread_getspecific(g_key)) == NULL) {
        fprintf(stderr, "cannot get thread specific data!...\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", tsd->count);
}

void key_delete_proc(void *ptr)
{
    free(ptr);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                71. Ders 05/08/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bazen bir thread akışının aynı yerden geçtiği halde bir işlemi yalnızca bir kez yapması istenebilir. Bunun için pthread_once
    isimli bir fonksiyon bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

    Fonksiyon pthread_once_t türünden bir nesnenin adresini ve bir de çağrılacak fonksiyonun adresini alır. Fonksiyonun birinci 
    parametresine geçirilecek olan pthread_once_t nesnesine aşağıdaki gibi ilk değer verilmiş olması gerekmektedir:

    pthread_once_t tonce = PTHREAD_ONCE_INIT;

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Thread akışı bu fonksiyona 
    kaç kere girerse girsin yalnızca burada verilen fonksiyon ilk girişte bir kez çağrılmaktadır. Fonksiyonun birinci parametresindeki
    nesne bu bir kez çağırmayı sağlamaktadır.

    pthread_once fonksiyonunda asıl amaç birden fazla thread'in bir işi toplamda bir kez yapmasını sağlamaktır. Tabii aslında 
    bu işlemi ileride görecek olduğumuz mutex nesneleriyle de basit bir biçimde yapılabiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void init_proc(void);

void exit_sys_errno(const char *msg, int eno);

pthread_once_t g_tonce = PTHREAD_ONCE_INIT;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    if ((result = pthread_once(&g_tonce, init_proc)) != 0)
        exit_sys_errno("pthread_once", result);

    printf("Thread-1\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    if ((result = pthread_once(&g_tonce, init_proc)) != 0)
        exit_sys_errno("pthread_once", result);

    printf("Thread-2\n");

    return NULL;
}

void init_proc(void)
{
    printf("init proc\n");
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii aslında pthread_once fonksiyonunu oluşturmak oldukça kolaydır. Bir static mutex nesnesi alınır. pthread_once_t 
    bir bayrak olarak kullanılır. mutex kontrolü içerisinde bu bayrak set edilir.

    Aşağıda buna ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void init_proc(void);

void exit_sys_errno(const char *msg, int eno);

#define MYPTHREAD_ONCE_INIT        0

pthread_once_t g_tonce = MYPTHREAD_ONCE_INIT;

int mypthread_once(pthread_once_t *once_control, void (*init_routine)(void))
{
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    int result;

    if ((result = pthread_mutex_lock(&mutex)) != 0)
        return result;

    if (*once_control == 0) {
        init_routine();
        *once_control = 1;
    }

    if ((result = pthread_mutex_unlock(&mutex)) != 0)
        return result;

    return 0;
}

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    if ((result = mypthread_once(&g_tonce, init_proc)) != 0)
        exit_sys_errno("mypthread_once", result);

    printf("Thread-1\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    if ((result = mypthread_once(&g_tonce, init_proc)) != 0)
        exit_sys_errno("mypthread_once", result);

    printf("Thread-2\n");

    return NULL;
}

void init_proc(void)
{
    printf("init proc\n");
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    TSD kullanan fonksiyonları biz yazıyorsak bu durumda TSD anahtarını (yani slotunu) daha thread'leri yaratmadan pthread_key_create
    fonksiyonu ile yaratabiliriz. Böylece thread'lerimiz zaten yaratılmış olan TSD slotlarını kullanabilir. Zaten biz yukarıdaki 
    örnekte böyle yaptık. Pekiyi TSD kullanan fonksiyonları biz yazmamışsak örneğin bunlar bir kütüphanede bulunuyorsa ve bu 
    fonksiyonları biz kütüphaneden çağırıyorsak bu fonksiyonlar TSD slotunu nasıl yaratmaktadır ve bu TSD alanına nasıl ilk değerlerini 
    vermektedir? Bunun bir yolu eğer ilgili kütüphane standart C kütüphanesi gibi temel bir kütüphane ise TSD slotlarının 
    derleyicilerin başlangıç kodlarında (start-up codes) yaratılması olabilir. Tabii bunun için söz konusu kütüphanenin derleyici 
    ile bağlantılı aşağı seviyeli bir kütüphane olması gerekir. Örneğin Microsoft, standart C fonksiyonlarını bu biçimde thread 
    güvenli hale getirmiştir. Aslında bir C programında ilk çalışan kod main fonksiyonu değildir. Aslında program derleyicinin 
    yerleştirdiği ismine "start-up code" denilen bir koddan başlamaktadır. Bu kod main fonksiyonu çağırmaktadır. Yani bir C 
    programının çalışması aşağıdakine benzerdir:

    ...
    ...        <start-up code>
    ...
    call main
    call exit

    Buradan da görüldüğü gibi main fonksiyonu bittiğinde zaten exit fonksiyonu çağrılmaktadır. İşte eğer derleyici ile bağlantılı
    aşağı seviyeli bir kütüphane TSD kullanacaksa TSD slotları daha main fonksiyonu çağrılmadan start-up kodda yaratılabilir. 
    Bazı derleyiciler start-up kodda main fonksiyonundan önce programcının fonksiyonlarının çağrılmasına izin verebilmektedir. 
    C++ gibi bazı dillerde de main fonksiyonundan önce global değişkenler yoluyla kod çalıştırmak da mümkün olabilmektedir.

    Pekiyi biz C'de başkaları için TSD kullanılarak thread güvenli hale getirilmiş fonksiyonları nasıl yazabiliriz? Buradaki 
    sorun bu TSD slotlarının pthread_key_create fonksiyonu ile ne zaman yaratılacağıdır. Bunun iki yolu olabilir:

    1) Kütüphanemize lib_init gibi bir fonksiyon yerleştirip o fonksiyonun mutlaka programcı tarafından işin başında çağrılması 
    gerektiğini belirtiriz.

    2) pthread_once fonksiyonunu kullanarak yalnızca ilk thread bu fonksiyonu kullandığında bir kez TSD slotlarını yaratırız.

    Birinci yöntem daha etkindir. Ancak bu durumda programcının bu lib_init gibi bir fonksiyonu çağırmayı unutmaması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    TSD kullanımı ile aslında thread güvenli olmayan fonksiyonlar hiç parametre değişikliği yapılmadan thread güvenli hale 
    getirilebilir. Örneğin Windows sistemlerinde bu biçimde bir işlem uygulanmıştır.

    Aşağıdaki örnekte srand ve rand fonksiyonları hiç parametre değişikliği yapılmadan thread güvenli hale getirilmiştir. 
    Bu örnekte bir thread'te ilk kez srand ya da rand fonksiyonu çağrıldığında TSD slotu yaratılmıştır. Sonraki çağırmalarda
    zaten var olan slot kullanılmıştır. Yalnızca ilk çağırmada pthread_setspecific fonksiyonu ile slota yerleştirme yapılmıştır. 
    Tabii büyük kütüphanelerde her fonksiyon için ayrı bir TSD slotunun tahsis edilmesine gerek yoktur. Kütüphanenin tamamı için 
    bir slot yeterlidir. Kütüphanedeki tüm fonksiyonlar aslında aynı slottaki TSD alanını kullanabilirler.

    Programın testi için derlemeyi şöyle yapabilirsiniz:

    $ gcc -o sample sample.c rand.c -lpthread
---------------------------------------------------------------------------------------------------------------------------*/

/* rand.h */

#ifndef RAND_H_
#define RAND_H_

void my_srand(unsigned seed);
int my_rand(void);

#endif

/* rand.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include "rand.h"

#define SEED_INIT        12345

typedef struct tagTSD_RAND {
    unsigned seed;
    /* ... */
} TSD_RAND;

static void destructor(void *ptr);
static void rand_init_once(void);
static TSD_RAND *rand_init(void);
static void exit_sys_errno(const char *msg, int eno);

pthread_once_t g_rand_once;
pthread_key_t g_rand_key;

static void destructor(void *ptr)
{
    free(ptr);
}

static void rand_init_once(void)
{
    int result;

    if ((result = pthread_key_create(&g_rand_key, destructor)) != 0)
        exit_sys_errno("Fatal error pthread_key_create", result);
}

static TSD_RAND *rand_init(void)
{
    int result;
    TSD_RAND *tsdrand;

    if ((result = pthread_once(&g_rand_once, rand_init_once)) != 0)
        exit_sys_errno("Fatal error pthread_once", result);

    if ((tsdrand = pthread_getspecific(g_rand_key)) == NULL) {
        if ((tsdrand = (TSD_RAND *)malloc(sizeof(TSD_RAND))) == NULL) {
            fprintf(stderr, "Fatal error: cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }
        if ((result = pthread_setspecific(g_rand_key, tsdrand)) != 0)
            exit_sys_errno("Fatal error pthread_setspecific", result);

        tsdrand->seed = SEED_INIT;
    }

    return tsdrand;
}

static void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

void my_srand(unsigned seed)
{
    TSD_RAND *tsdrand;

    tsdrand = rand_init();

    tsdrand->seed = seed;
}

int my_rand(void)
{
    TSD_RAND *tsdrand;

    tsdrand = rand_init();

    tsdrand->seed = tsdrand->seed * 1103515245 + 12345;

    return (unsigned int)(tsdrand->seed / 65536) % 32768;
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include "rand.h"

void *thread_proc1(void *param);
void *thread_proc2(void *param);

void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int val;

    for (int i = 0; i < 10; ++i) {
        val = my_rand() % 100;
        printf("Thread-1: %d\n", val);
        sleep(1);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int val;

    for (int i = 0; i < 10; ++i) {
        val = my_rand() % 100;
        printf("Thread-2: %d\n", val);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Biz thread örneklerimizde exit_sys_errno fonksiyonunda strerror fonksiyonunu kullanmıştık. Anımsanacağı gibi strerror 
    fonksiyonunun prototipi şöyleydi:

    #include <string.h>

    char *strerror(int errnum);

    Görüldüğü gibi fonksiyon statik alanın adresiyle geri dönmektedir. O halde bu fonksiyonun aynı anda farklı thread'lerden 
    çağrılması uygun değildir. Çünkü bu fonksiyon thread güvenli değildir. O halde aslında strerror yerine bizim strerror_t
    fonksiyonunu kullanmamız gerekir. Ancak strerror yerine strerror_r fonksiyonun kullanılması da biraz zahmetlidir. Bu nedenle
    UNIX/Linux sistemlerinde standart C kütüphanelerinin bir bölümü zaten kendi içerisinde TSD kullanarak yukarıdaki yaptığımız gibi 
    yöntemlerle bu strerror fonksiyonunu thread güvenli hale getirmiştir. Örneğin GNU'nun glibc kütüphanesinde bu fonksiyon belli 
    bir versiyondan sonra thread güvenlidir. Yani bu fonksiyonu biz iki farklı thread'ten çağırıyor olsak da aslında fonksiyon 
    bize farklı adresler vermektedir.

    strerror_r fonksiyonunun prototipi şöyledir:

    #include <string.h>

    int strerror_r(int errnum, char *buf, size_t buflen);

    Burada fonksiyon static bir alanın adresi ile geri dönmez. Bizzat verilen adrese yazıyı yerleştirir. Bu durumda yukarıda yazdığımız
    sys_exit_errno fonksiyonunun thread güvenli versiyonu şöyle oluşturulabilir:

    int strerror_r(int errnum, char *buf, size_t buflen);

    void exit_sys_errno(const char *msg, int eno)
    {
        char buf[256];

        strerror_r(eno, buf, 256);

        fprintf(stderr, "%s:%s\n", msg, buf);

        exit(EXIT_FAILURE);
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Thread'e özgü global değişken oluşturmak için programlama dillerine zamanla özel bazı belirleyiciler (specifiers) de eklenmiştir.
    Örneğin C'ye C11 ile birlikte _Thread_local isimli bir yer belirleyicisi eklenmiştir. Bu yer belirleyicisi C23 ile birlikte 
    thread_local biçiminde değiştirilmiştir. C11'de thread_local ismi <threads.h> dosyası içerisinde bir makro biçiminde bulunmaktadır.
    C++11 ile birlikte de yine C++'a aynı işlevde thread_local isimli yer belirleyicisi de eklenmiştir. Örneğin:

    _Thread_local int g_x;

    Burada g_x global değişkeninin thread'e özgü kopyaları bulunmaktadır. Yani bir thread akışı bu g_x global değişkenini 
    kullandığında o thread'e özgü olan g_x global değişkenini kullanmış olur.

    gcc ve clang derleyicilerinde ayrıca __thread biçiminde aynı işlevde bir uzantı (extension) niteliğinde belirleyici C11 
    öncesinde de bulunuyordu.

    gcc derleyicileri _thread_local, thread_local ya da __thread belirleyicisi ile tanımlanan nesneleri "thread local storage" 
    biçiminde isimlendirilen bir teknikle thread'lerin stack alanlarının biz uzantısında saklamaktadır. Bu konudaki dokümanlar 
    aşağıdaki bağlantıdan incelenebilir:

    https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html

    Aşağıda C11 ile ile C'ye eklenen _Thread_local belirleyicisinin kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void disp(const char *name);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

_Thread_local int g_x;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    pthread_exit(NULL);

    return 0;
}

void disp(const char *name)
{
    printf("%s: %d\n", name, g_x);        // bu fonksiyonu hangi thread çağırırsa o thread'in g_x'i yazdırılıyor
}

void *thread_proc1(void *param)
{
    g_x = 10;        // thread-1'in g_x'ine 10 yerleştiriliyor
    disp("thread-1");

    return NULL;
}

void *thread_proc2(void *param)
{
    g_x = 20;        // thread-1'in g_x'ine 20 yerleştiriliyor
    disp("thread-2");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi fopen fonksiyonunun bize verdiği FILE adresi FILE türünden bir yapı nesnesini gösteriyordu ve o FILE 
    nesnesinin içerisinde o dosyanın kullandığı tamponun adresi vardı. Pekiyi biz global bir FILE türünden gösterici alıp 
    bu göstericiyle iki farklı thread'te dosya işlemi yaparsak bu işlemler thread güvenli midir? Örneğin:

    FILE *g_f;

    int main(void)
    {
        g_f = fopen(...);
        ...
        return 0;
    }

    Burada g_f dosya bilgi göstericisini (stream) farklı thread'lerden aynı anda kullanırsak bir sorun çıkar mı? İşte POSIX
    standartlarına göre stream işlemleri thread güvenlidir. Yani programcının özel olarak bu konuda bir şey yapmasına gerek kalmaz. 
    Bir dosya işlemi bitmeden diğeri devreye girip iç içe geçme olmamaktadır. Ancak C standartlarında böyle bir thread güvenlilik 
    garanti edilmemiştir. Benzer biçimde Windows sistemlerinde de stream işlemleri thread güvenlidir. Örneğin biz iki thread'te
    fprintf fonksiyonu ile aynı dosyaya bir şeyler yazmak isteyelim. Bu fonksiyonlarda iç içe geçme olmayacaktır. Yani birinin 
    yazdığı şeyler ile diğerinin yazdığı şeyler sanki atomik işlemlermiş gibi ele alınacaktır.

    Aşağıdaki örnekte global bir dosya bilgi gösterici yoluyla fprintf fonksiyonu kullanılarak farklı thread'lerden aynı dosyaya 
    bir şeyler yazılmıştır. Dosyanın içeriğini incelediğinizde iç içe geçmelerin olmadığını göreceksiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);

void exit_sys_errno(const char *msg, int eno);

FILE *g_f;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((g_f = fopen("test.txt", "w")) == NULL) {
        fprintf(stderr, "cannot open file!...\n");
        exit(EXIT_FAILURE);
    }

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    fclose(g_f);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 10000; ++i)
        fprintf(g_f, "thread-1: %d\n", i);

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < 10000; ++i)
        fprintf(g_f, "thread-2: %d\n", i);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                72. Ders 06/08/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Server uygulamalarında server programın çok sayıda client'tan gelen mesajları işlemesi gerekebilmektedir. Bu tür uygulamalarda
    server program client'tan bilgiyi alır, onu işler, işlemlerin sonuçlarını client'a gönderir ve sonra yeniden aynı işlemleri 
    yapar. Yani bu tür programlardaki tipik döngü aşağıdaki gibidir:

    for (;;) {
        msg = get_msg();
        process_msg(msg);
    }

    Burada get_msg client'tan mesajı alan fonksiyonu, process_msg ise o mesajı işleyen fonksiyonu temsil ediyor olsun. Server 
    programın amacı client'ları bekletmeden onların talep ettiği hizmetleri hızlıca yapmaktır. Bu tür client-server uygulamalar 
    genellikle TCP/IP soket programlamada karşımıza çıkmaktadır. TCP/IP soket programlama izleyen bölümlerde ele alınacaktır. 
    Pekiyi buradaki döngü nasıl hızlandırılabilir? İlk akla gelen process_msg fonksiyonunun başka bir thread'e yaptırılması ve 
    server'ın hemen dönerek bir sonraki client'ın isteklerini işlemeye çalışmasıdır. Ancak burada önemli bir sıkıntı şudur: Biz 
    her client mesajı için bir thread yaratmak durumundayız. Ancak bu thread'lerin yaratılması ve yok edilmesi de önemli bir 
    zaman almaktadır. Yani bir client'ın isteğini yerine getirmek için o anda bir thread'in yaratılmasının ve sonra da o thread'in 
    yok edilmesinin de bir zaman maliyeti vardır. İşte bu tür durumlarda iki yöntem uygulanabilmektedir:

    1) Yukarıdaki döngüyü çalıştıran thread'in client'tan aldığı mesajları bir kuyruk sistemine yazması ve üretici-tüketici 
    problemi biçiminde n tane client thread'in aynı kuyruktan istekleri alıp işlemesi yöntemi. Bu yöntemde işin başında n tane 
    thread yaratılır. Bu n tane thread senkronize edilmiş bir kuyruktan client isteklerini alıp onları bağımsız bir biçimde işler. 
    Böylece thread'lerin her client isteğinde yeniden yaratılıp yok edilmesi gerekmeyecektir.

    2) Thread Havuzu (Thread Pool) yöntemi. Bu yöntemde n tane thread yaratılmış bir biçimde suspend durumda bekletilir. Yeni 
    bir client isteği geldiğinde bekleyen thread uyandırılarak client isteği bu thread'e yaptırılır. Burada thread'ler işin başında 
    yaratılmaktadır. Client isteği bu thread'ler tarafından işlendikten sonra thread'ler yok edilmemekte ve yeniden suspend durumda 
    yeni client isteğinin gelmesini beklemektedir.

    Yukarıdaki iki yöntem de aslında birbirine benzer yöntemlerdir. Birinci yöntemdeki üretici-tüketici problemi için bir 
    kuyruk sisteminin oluşturulması ve bu kuyruk sisteminin senkronize edilmesi gerekir. Client isteklerinin kuyruk sistemine 
    yazılması ve oradan alınması da belli bir zaman kaybına yol açmaktadır. Thread havuzu yönteminde daha doğrudan bir işlem 
    söz konusudur. Çünkü burada araya bir kuyruk sistemi sokulmamaktadır. Bu tür durumlarda her iki yöntem de kullanılabiliyor 
    olsa da thread havuzları daha fazla tercih edilmektedir. Pekiyi yukarıdaki her iki yöntemde de n tane thread'in işin 
    başında yaratılacağını belirtmiştik. Bu n sayısı ne olmalıdır?

    Tek işlemcili ya da çekirdekli sistemlerde bu n sayısının büyütülmesi bir fayda sağlayabilir mi? Aslında genel olarak bu 
    yöntemler tek işlemcili ya da çekirdekli sistemlerde önemli bir hız kazancı sağlamayacaktır. Tabii eğer bu sistemlerde 
    bu proses ile rekabet eden başka prosesler varsa bu prosesin fazla thread yaratması bu rekabette bu prosesin öne geçmesine
    yol açabilecektir. Ancak ilgili makinede bu server programın dışında onunla rekabet edebilecek başka programların olmadığını
    varsaydığımızda buradaki hız kazancı sanıldığı kadar fazla olmayabilecektir. Tabii yukarıdaki döngünün tek thread yerine 
    birden fazla thread tarafından işletilmesi bloke konusunda bir avantaj sağlayacaktır. Eğer döngü tek thread tarafından
    işletilirse process_msg içerisindeki blokeden tüm client'lar etkilenir. Ancak process_msg fonksiyonu farklı thread'ler 
    tarafından işletilirse bu fonksiyondaki blokeden tüm client'lar etkilenmez.

    Bu tür uygulamalarda thread sayısını belirten n değeri aslında mesaj işlenirken önemli blokeler oluşmuyorsa işlemci ya da 
    çekirdek sayısı kadar olması uygundur. Hatta programcı bu thread'leri "processor affinity" işlemleriyle farklı işlemci ya da
    çekirdeklere de bağlayabilir. Tabii mesaj işlenirken (process_msg'yi kastediyoruz) blokeler oluşacaksa bu n değeri yükseltilebilir. 
    (Tabii bu tür durumlarda Linux sistemlerinde "processor affinity" uygulanmadığı durumda çizelgeleyicinin CFS algoritması 
    işlemcilerin çalışma kuyruklarını (run queue) toplam fayda çerçevesinde dengelemeye çalışmaktadır.)

    Yukarıdaki açıklamalarımızdan çıkan sonuçları özetleyelim. Aşağıdaki gibi bir server döngüsü söz konusu olsun:

    for (;;) {
        msg = get_msg();
        process_msg(msg);
    }

    1) Burada tek işlemcili ve tek çekirdekli sistemlerde process_msg fonksiyonlarının n tane thread'e yaptırılması eğer bu 
    fonksiyon içerisinde blokeler söz konusu ise fayda sağlar. Ancak bu fonksiyon CPU yoğun ise ve sistemde bu proses ile 
    rekabet etme iddiasında olan başka prosesler yoksa bu durum sanıldığı kadar fayda sağlamayabilir.

    2) Çok işlemcili ve çok çekirdekli sistemlerde eğer process_msg CPU yoğun ise n değeri tipik olarak işlemci ya da çekirdek 
    sayısı kadar olabilir. Ancak process_msg blokelere yol açabiliyorsa n değeri büyütülebilir.

    Thread havuzu yönteminde n tane thread'in baştan yaratılarak havuzda bekletilmesi ve onların gerektiğinde uyandırılarak 
    belli bir fonksiyonu çalıştırması sağlanmaktadır. Thread havuzunda baştan yaratılacak thread sayısı önceden belirlenmekte 
    ancak dinamik biçimde artırılıp azaltılabilmektedir. Yani client istekleri artıp havuzda bunları işleyecek thread'ler 
    kalmadıysa bu thread havuzu sistemi yeni thread'ler yaratarak onları havuza ekler. Client istekleri azaldığında havuzdaki 
    thread'lerin bir bölümünü sisteme iade eder. Tabii çok değişik thread havuzu gerçekleştirimleri vardır. Her birinin özellikleri
    diğerlerinden farklı olabilmektedir.

    Thread havuzları C'nin ve C++'ın standart kütüphanesinde yer almamaktadır. gcc ve clang derleyicilerinin kullandığı glibc 
    kütüphanesinde de thread havuzları için fonksiyonlar yoktur. Ancak Qt gibi, Java ve .NET gibi platformlarda o platformların
    sınıf kütüphanelerinde thread havuzları hazır bir biçimde bulunmaktadır. Thread havuzları Windows sistemlerinde Windows API
    fonksiyonları tarafından desteklenmektedir. (Windows API fonksiyonları POSIX kütüphanesine benzer bir düzeydedir.)

    C için başkaları tarafından yazılmış thread havuzu kütüphaneleri kullanılabilmektedir. Bunun için çeşitli seçenekler 
    bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Defalarca belirttiğimiz gibi POSIX'teki pthread kütüphanesi taban bir kütüphanedir. Diğer platformlardaki thread
    işlemleri aslında UNIX/Linux sistemlerinde bu pthread kütüphanesi kullanılarak gerçekleştirilmektedir. Yani örneğin biz 
    Java'da C#'ta, C++'ta onların sağladığı kütüphaneler yoluyla thread işlemleri yaptığımızda aslında bu kütüphaneler UNIX/Linux 
    sistemlerinde pthread fonksiyonlarıyla, Windows sistemlerinde Windows API fonksiyonlarıyla gerçekleştirmektedir. macOS 
    sistemlerinde de yine pthread kütüphanesi kullanılmaktadır. Ancak bu dillerin ve platformların asıl sağladığı fayda 
    taşınabilirliktir. Örneğin biz C++'ın thread kütüphanesini kullandığımızda o programı Windows'ta da Linux'ta da aynı kodlarla 
    yeniden derleyerek çalıştırabilmekteyiz. Oysa pthread kütüphanesini kullanarak yazdığımız bir programı Windows sistemlerine 
    götürdüğümüzde derlenemeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C Programlama Dili'ne, 2011 versiyonuyla (ISO/IEC 9899:2011 ya da kısaca C11) isteğe bağlı mini bir thread kütüphanesi 
    eklenmiştir. Bu thread kütüphanesi henüz Microsoft derleyicileri tarafından desteklenmemektedir. gcc ve clang derleyicilerinin
    kullandığı glibc kütüphanesinin son versiyonları bu thread kütüphanesini destekler hale gelmiştir. Biz de burada kısaca bu
    kütüphane hakkında temel bilgiler vereceğiz. Kütüphanedeki tüm fonksiyonların prototipleri, sembolik sabitler ve typedef
    isimleri <threads.h> dosyası içerisindedir. Dolayısıyla bu dosyanın include edilmesi gerekmektedir. Bu dosyanın kendi içerisinde
    <time.h> dosyasını include etmesi garanti edilmiştir.

    gcc ve clang derleyicilerinde C11 thread kütüphanesini kullanan programları derlerken -pthread seçeneğinin kullanılması
    gerekmektedir. (pthread kütüphanesi için -lpthread seçeneğini kullandığımızı anımsayınız.) Örneğin:

    $ gcc -o sample sample.c -pthread
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    - Kütüphanedeki fonksiyonların geri dönüş değerleri genellikle int türdendir. Bu fonksiyonlar başarı durumunda thrd_success,
    başarısızlık durumunda thrd_error ya da thrd_nomem değerlerine geri dönerler. Başarı kontrolü şöyle yapılabilir:

    if (thrd_xxx(...) != thrd_success) {
        ...
    }

    - C11'de thread yaratmak için thrd_create fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <threads.h>

    int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);

    Fonksiyonun birinci parametresi thread'i temsil eden id değerinin yerleştirileceği thrd_t türünden nesnesini adresini, ikinci 
    parametresi thread akışının başlatılacağı fonksiyonun adresini ve üçüncü parametresi de thread fonksiyonuna geçirilecek argümanı 
    belirtir. thrd_start_t türü şöyle typedef edilmiştir:

    typedef int (*thrd_start_t)(void *);

    - Thread yine yaratıldıktan sonra thrd_join fonksiyonu ile beklenebilir:

    #include <threads.h>

    int thrd_join(thrd_t thr, int *res);

    Thread'in exit kodunun int türden olduğuna dikkat ediniz.

    - Thread thrd_detach fonksiyonu ile detached duruma sokulabilmektedir:

    #include <threads.h>

    int thrd_detach(thrd_t thr);

    - Thread'i belli bir süre blokede bekletmek için thrd_sleep fonksiyonu kullanılmaktadır:

    #include <threads.h>

    int thrd_sleep(const struct timespec *duration, struct timespec *remaining);

    Aşağıda bu fonksiyonların kullanılmasına yönelik bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <threads.h>

int thread_proc(void *param);

int main(void)
{
    thrd_t tid;

    if (thrd_create(&tid, thread_proc, "other thread") != thrd_success) {
        fprintf(stderr, "cannot create thread!...\n");
        exit(EXIT_FAILURE);
    }

    struct timespec ts;

    ts.tv_sec = 1;
    ts.tv_nsec = 0;

    for (int i = 0; i < 10; ++i) {
        printf("Main thread %d\n", i);
        thrd_sleep(&ts, NULL);
    }

    if (thrd_join(tid, NULL) != thrd_success) {
        fprintf(stderr, "cannot join thread!...\n");
        exit(EXIT_FAILURE);
    }

    return 0;
}

int thread_proc(void *param)
{
    char *name = (char *)param;
    struct timespec ts;

    ts.tv_sec = 1;
    ts.tv_nsec = 0;

    for (int i = 0; i < 10; ++i) {
        printf("%s: %d\n", name, i);
        thrd_sleep(&ts, NULL);
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    C11'de senkronizasyon için yalnızca mutex ve durum değişkenleri nesneleri bulundurulmuştur. Bu mutex nesneleri mtx_t türü ile 
    temsil edilmektedir. Nesnenin kullanılması aşağıdaki fonksiyonlarla yapılmaktadır:

    #include <threads.h>

    int mtx_init(mtx_t *mtx, int type);
    void mtx_destroy(mtx_t *mtx);
    int mtx_lock(mtx_t *mtx);
    int mtx_unlock(mtx_t *mtx);
    int mtx_timedlock(mtx_t *restrict mtx, const struct timespec *restrict ts);
    int mtx_trylock(mtx_t *mtx);

    Aşağıdaki mutex nesnelerinin kullanılmasına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <threads.h>

int thread_proc1(void *param);
int thread_proc2(void *param);

int g_count;
mtx_t g_mutex;

int main(void)
{
    thrd_t tid1, tid2;

    if (mtx_init(&g_mutex, mtx_plain) != thrd_success) {
        fprintf(stderr, "cannot initialize mutex!...\n");
        exit(EXIT_FAILURE);
    }

    if (thrd_create(&tid1, thread_proc1, NULL) != thrd_success) {
        fprintf(stderr, "cannot create thread!...\n");
        exit(EXIT_FAILURE);
    }

    if (thrd_create(&tid2, thread_proc1, NULL) != thrd_success) {
        fprintf(stderr, "cannot create thread!...\n");
        exit(EXIT_FAILURE);
    }

    if (thrd_join(tid1, NULL) != thrd_success) {
        fprintf(stderr, "cannot join thread!...\n");
        exit(EXIT_FAILURE);
    }

    if (thrd_join(tid2, NULL) != thrd_success) {
        fprintf(stderr, "cannot join thread!...\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", g_count);

    return 0;
}

int thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        mtx_lock(&g_mutex);
        ++g_count;
        mtx_unlock(&g_mutex);
    }

    return 0;
}

int thread_proc2(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        mtx_lock(&g_mutex);
        ++g_count;
        mtx_unlock(&g_mutex);
    }

    return 0;
}

/*---------------------------------------------------------------------------------------------------------------------------
    C11'deki diğer thread fonksiyonları için C standartlarını inceleyebilirsiniz. C11'in thread fonksiyonları oldukça 
    minimalist tasarlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    C++'a da C++11 (ISO/IEC 14882: 2011 ya da kısaca C++11) ile birlikte şablon temelli bir thread kütüphanesi eklenmiştir. 
    C++'ın kütüphanesi, C'nin kütüphanesinden daha ayrıntılıdır. Tabii C++'daki thread kütüphanesi sınıfsal bir tasarıma sahiptir.

    C++'ta thread işlemleri için thread isimli bir sınıf bulundurulmuştur. Bu sınıf şablon tabanlı olduğu için thread fonksiyonu 
    herhangi bir parametreye sahip biçimde sınıfın yapıcı fonksiyonuna verilebilmektedir. Thread nesneleri kesinlikle join üye 
    fonksiyonuyla beklenmeli ya da detach üye fonksiyonuyla detach duruma sokulmalıdır.

    Aşağıda C++'ta bir thread yaratımı örneği verilmiştir. Yine derleme işlemi sırasında Linux sistemlerinde -pthread seçeneğinin 
    bulundurulması gerekmektedir. Programın testi için derlemeyi şöyle yapabilirsiniz:

    $ g++ -o sample sample.cpp -pthread
---------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

void thread_proc(int count);

int main()
{
    thread t(thread_proc, 5);

    for (int i = 0; i < 10; ++i) {
        this_thread::sleep_for(chrono::milliseconds(1000));
        cout << "main thread: " << i << endl;
    }

    t.join();

    return 0;
}

void thread_proc(int count)
{
    for (int i = 0; i < count; ++i) {
        this_thread::sleep_for(chrono::milliseconds(1000));
        cout << "other thread: " << i << endl;
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesinde de çeşitli senkronizasyon nesneleri bulunmaktadır. Örneğin mutex nesnesi yine bir sınıf 
    biçiminde bulundurulmuştur. lock ve unlock işlemleri mutex sınıfının üye fonksiyonlarıyla yapılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>

using namespace std;

int g_count;
mutex g_mutex;

void thread_proc1();
void thread_proc2();

int main()
{
    thread t1(thread_proc1);
    thread t2(thread_proc2);

    t1.join();
    t2.join();

    cout << g_count << endl;

    return 0;
}

void thread_proc1()
{
    for (int i = 0; i < 1000000; ++i) {
        g_mutex.lock();
        ++g_count;
        g_mutex.unlock();
    }
}

void thread_proc2()
{
    for (int i = 0; i < 1000000; ++i) {
        g_mutex.lock();
        ++g_count;
        g_mutex.unlock();
    }
}

/*---------------------------------------------------------------------------------------------------------------------------
    C++'ın thread kütüphanesi, C'nin thread kütüphanesinden daha geniştir. Kütüphane şablon tabanlı olduğu için kullanımı 
    konusunda dikkatli olmak gerekir. Tabii C++'ın bu kütüphanesi UNIX/Linux ve macOS sistemlerinde pthread kütüphanesi kullanılarak, 
    Windows sistemlerinde ise Windows API fonksiyonları kullanılarak gerçekleştirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/