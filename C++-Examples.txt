/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												
													C ve Sistem Programcıları Derneği

														C++ Programlama Dili 

											Sınıfta Yapılan Örnekler ve Özet Notlar
			
														Eğitmen: Kaan ASLAN  
					
					Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

								(Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz)
								
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

								
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														1. Ders 14/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Merhaba Dünya C++ programı
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello World" << endl;
    
    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															2. Ders 16/08/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın ilk standardı ISO/IEC tarafından 1998 yılında oluşturuldu (ISO/IEC 14882: 1998).Bunu 2003 yılındaki standartlar izledi. 2003 standartları daha çok düzeltme 
	niteliğinde idi. Daha sonra C++'ın 2011 yılında yeni bir standardı oluşturuldu. Bu standartlarla C++'a pek çok yenilik eklendi. 2011 standartlarını 2014, 2017 
	ve 2020 standartları izledi. Şu anda üzerinde çalışılmakta olan standart 2023'tür. Bu standartlar halk arasında sırasıyla C++98, C++03, C++11, C++14, C++17, 
	C++20 ve C++23 olarak bilinmektedir. 
	
	Klasik C++ olan C++98 ve C++03'e yapılan eklemeler iki kategoride ele ele alınabilmektedir. Bunlardan biri "doğrudan dile yapılan eklemelerdir (core language 
	feaures)",	diğeri ise C++'ın standart kütüphanesine yapılan eklemelerdir. C++'a en önemli eklemeler C++11 standartları ile yapılmıştır. C++11 ve sonrasına 
	C++ dünyasında "Modern C++" da denilmektedir. C++11'den sonra artık standartların üç senelik periyotlarla oluşturulması kabul edilmiştir. Kanımızca üç 
	semelik periyotlar C++ gibi bir dil için çok hızlı bir süreçtir. Bu hızlı gelişme çeşitli sancıları da beraberinde getirmiştir. 

	C Progralama Dilinin ilk standartları "ISO/IEC 9899: 1990" ismiyle 1990 yılında ISO tarafından oluşturulmuştur. Buna halk arasında C90 denilmektedir. 
	(Aslında C standartları önce 1989 yılında Amerika'nın standart kurumu olan ANSI tarafından aluşturulmuştu. 1990 ISO standartları bu ANSI standartlarının alınarak
	bazı bölüm numaralarının değiştirilmesiyle oluşturulmuşur.) C'nin 1999 yılında yeni bir standardı daha oluşturuldu. Buna da C99 denilmektedir. Daha sonra 
	C'nin 2011 yılında yeni bir standardı oluşturulmuştur. Buna da C11 denilmektedir. Nihayet C'nin 2017 yılında son sürümü yayınlandı. Buna da C17 denilmektedir. 
	Ancak bu C17'de yeni özellikler eklenmedi. Yalnızca C11'deki bozukluklar düzeltildi. C'nin üzerinde çalışılan son standart sürümü C23'tür. C23 standartlarının 
	2024'te yayınlanacağı düşünülmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ standartlarının üç senelik periyotlarla hızlı bir biçimde güncellenmesi bazı tasarım hatalarının ve pişmanlıkların oluşmasına da yol açmıştır. Dolayısıyla
	Modern C++'a yönelik bazı ince ayrıntılar C++'ın versiyonundan versiyonuna değişmiş olabilmektedir. Biz yeni öğrenen kişilere C++ standartların doğrudan 
	okunmasını tavsiye etmemekteyiz. Çünkü standart metinleri (bazı diğer standartları da böyle) pedagojik metinler değildir. Olanı tam olarak betimlemek amacıyla 
	oluşturulmuş metinelerdir. Son yıllarda "C++ Reference" isminde C++ standartlarını açıklamalı (annotated) bir biçimde dokümante eden bir girişim oldukça 
	popüler hale gelmiştir. Biz de kursumuzda pek çok yerde doğrudan bu standartlara referans etmektense C++ Reference sitesinden faydalanacağız. Siteye aşağıdaki
	bağlantıdan ulaşabilirsiniz:

	https://en.cppreference.com/w/
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  	Bir C++ programı IDE'ler yoluyla kolayca derlenip, link işlemi yapılarak çalıştırılabilir. Windows sistemlerinde en yaygın kullanılan IDE Microsoft'un
	"Visual Studio" isimli IDE'sidir. C++ için diğer bir IDE seçeneği "Qt-Creator" olabilir. Qt Creator "cross platform" biçimindedir. Yani Windows, macOS ve Linux 
	sistemlerinde benzer biçimde kullanılabilmektedir. Tabii aslında derleyiciler komut satırından çalıştırılan programlar biçiminde oluşturulmuştur. IDe'ler aslında 
	derleyicileri çalıştırarak derleme ve bağlama işlemlerini yapmaktadır. Microsoft'un C ve C++ derleyicisi "cl.exe" isimli programdır. Bu derleyici ile derleme 
	komut satırında şöyle yapılabilir:

	cl sample.cpp

	Derleyici default durumda derleme işleminden sonra bağlayıcı (linker) programı da çalıştırır. Bu işlemden eğer programınızda bir hata yoksa "sample.exe" 
	dosyasını elde edeceksinizç Tabii istersek çalıştırılabilen dosyanın ismini /Fe seçeneği ile de değiştirebiliriz:

	cl /Fe:test.exe sample.cpp

	UNIX/Linux ve macOS sistemlerinde GNU'nun g++ ve clang++ derleyicileri kullanılabilmektedir. g++ derleyicisi ile komut satırından derleme tipik olarak 
	şöyle yapılmaktadır:

	g++ sample.cpp 

	clang++ derleuyicilerinin kullanımları da g++ ile uyumludur:

	clang++ sample.cpp

	Burada derleyici derleme işleminden sonra yine bağlayıcı programı çalıştırmaktadır. Bu durumda çalıştırılabilen dosya "a.out" biçiminde oluşur. Çalıştırılabilen 
	dosyanın ismini değiştirmek için -o seçeneği kullanılmaktadır. Örneğin:

	g++ -o sample sample.cpp

	ya da örneğin:

	clang++ -o sample sample.cpp 

	UNIX/Linux sistemlerinde bir program dosyasını çalıştırmak için dosya isminin önüne ./ getirmeyi unutmayınız. Örneğin:

	./sample

	C++'ın çeşitli standartları olduğuna göre derleme işlemi bu standartlar belirtilerek yapılabilir. Visual Stduio IDE'sinde bu durum menüler yoluyla 
	ayarlanmaktadır. g++ ve clang derleyicinde -std seçeneği ile ayarlama yapılır. Örneğin:

	-std=c++11
	-std=c++14
	-std=c++17
	-std=c++20  (-std=c++2a)
	-std=c++2b

	Örneğin:

	g++ -std=c++2a -o sample sample.cpp

	Burada -std=c++2a artık yeni derleyicilerde -std=c++20 ile değiştirilmiştir. -std=c++2b ise C++23'ün de bazı özelliklerini barındırmaktadır.

	gcc ile C++ programları da derlenebilir. (Aslında gcc önce GNU C derleyicisi olarak geliştirilmişti. Sonra diğer derleyicileri de çalıştıran bir program
	haline getirildi.) Bu durumda gcc zaten g++ derleyicisini çalıştırmaktadır. Ancak gcc ile derleme yapılırken libstdc++ kütüphanesinin "-lstdc++" komut satırı 
	argümanı ile link aşamasında devreye sokulması gerekmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de ve C++'ta standartlarda belirtilen sentaks ve semantik kurallara uyulmadan yazılmış olan programlar yine de derleyici tarafından başarıyla derlenebilirler. 
	Çünkü standartlar geçerli programların derlenmesi gerektiğini koşul olarak ifade etmiştir. Ancak geçesiz programların derlenip derlenmeyeceği konusunda bir hüküm
	belirtmemiştir. Yalnızca standartlarda geçersiz durumlar karşısında derleyicilerin bunu en az bir mesajla (diagnostic message) bildirimeleri zorunlu tutulmuştur. 
	Yani bu durumda	geçerli programlar her zaman başarıyla derlenmek zorundadır. Ancak geçersiz programlar başarıyla derlenebilir ya da derlenmeyebilir. Bu nedenle
	derleme işleminin başarısına bakarak dilin kurallarını öğrenmeye çalışmak iyi bir yöntem değildir. Ayrıca C ve C++'ta derleyiciler diğer derleyicilerde olmayan 
	"eklentilere (extensions)" sahip olabilirler. Neyin bir eklenti olup olmadığının programcı tarafından bilinmesi gerekir. Eğer biz bir derleyicinin eklentisini 
	kullanırsak o kodu başka bir derleyiciye götürdüğümüzde kod başarılı olarak derlenmeyebilir. Çalıştığınız derleyicilerin eklentilerini bilmelisiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın C'den farklılıkları genellikle "fazlalık" biçimindedir. Bu fazlalıkların bir bölümü C++'ı daha iyi bir C yapmak için dile eklenmiştir. Bunlara "C++'ın 
	C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları" diyeceğiz. Biz kurusumuzda önce bunlar üzerinde duracağız. 
	Sonra C++'ı "Nesne Yönelimli bir dil yapan C++ özgü konular üzerinde duracağız. Yani kursumuz kabaca üç bölümden oluşmaktradır:
	
	1) C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları
	2) C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgili Olan Fazlalıkları ve Farklılıkları
	3) C++'ın Diğer Öenmli Özellikleri ve Standart Kütüphanesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu bölümde "C++'ın C'den Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Fazlalıkları ve Farklılıkları" maddeler halinde ele alınacaktır.
	Burada her maddeyi özet bir cümleyle başlatacağız ve sonra onun ayrıntılarına gireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    1) C++'a // ile satır sonuna kadar yorumlama eklenmiştir. Bu özellik C90'da yoktu. Fakat C++98'den sonra sonra çıkan C99 ile birlikte C'ye de eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	cout << "Hello World" << endl;			// Merhaba dünya programı

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    2) C++'ta yerel değişkenler blokların herhangi bir yerinde bildirilebilirler. Halbuki C90'da yerel değişkenler blokların başlarında bildirilmek zorundaydı. 
	Ancak C99 ile birlikte bu kural C'de de C++'takşi gibi değiştirildi. C++'ta bir yerel değişkenin faaliyet alanı bildirim yerinden bildirildiği bloğun sonuna 
	kadarki bölgededir. Yine C++'ta iç içe ya da ayrık bloklarlarda aynı isimli yerel değişkenler bildirilebilir. Ancak aynı blok içerisinde aynı isimli yerel 
	değişkenler bildirilemez. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    3) C++'ta for döngülerinin birinci kısmında bildirimler yapılabilmektedir. Bu özellik C90'da yoktu. Ancak C99 ile birlikte C'ye de eklendi. Ayrıca C++'ta 
	diğer deyimlerin parantezleri içerisinde de bildirimler yapılabilmektedir. for döngüsünün birinci kısmında bildirim yapılabilmesi sentaksını C++'tan almış olan 
	Java ve C# gibi dillerde söz konusudur. Bu özellik döngü yazımını kolaylaştırmaktadır. Örneğin:

	for (int i = 0; i < 10; ++i) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		cout << i << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    for döngüsünün birinci kısmında bildirilen değişkenlerin faaliyet alanları for döngüsü ile sınırlıdır. Başka bir deyişle:

	for (bildirim; ifade; ifade) 
		<deyim>

	işleminin eşdeğeri aşağıdaki gibi düşünülmelidir:

	{
		bildirim;
	
		for (;ifade; ifade) 
			<deyim>
	}

	Yani "for döngüsünü kapsayan bir gizli blok" varmış gibi düşünmelisiniz. for döngüsünün diğer kısımlarında bildirim yapılamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) {
		cout << i << " ";
	}
	cout << endl;

	cout << i << endl;			// error! 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bu biçimdeki bir for döngüsünü aşağıya kopyalarsak faaliyet alanı bakımından bir sorun oluşmayacaktır.Örneğin:

	for (int i = 0; i < 10; ++i) {
		//...
	}
		
	for (int i = 0; i < 10; ++i) {
		//...
	}

	Buradaki i değişkenleri aslında ayrık bloklardaki i değişkenleri gibidir. Yukarıdaki kodun eşdeğerini aşağıdaki gibi düşünmelisiniz:

	{
		int i = 0;
	
		for (; i < 10; ++i) {
			ß//...
		}
	}

	{
		int i = 0;
	
		for (; i < 10; ++i) {
			//...
		}
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) 
		cout << i << " ";
	
	for (int i = 0; i < 10; ++i) 		// Buaraki i başka bir i
		cout << i << " ";

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe for döngülerinde de aynı isimli değişkenlerin bulunması bu bağlamda bir sorun oluşturmaz. Ancak iç for döngüsünde biz dış for döngüsünün birinci 
	kısmında bildirilen değişkenleri kullanamayız. Örneğin:

	for (int i = 0; i < 10; ++i)
		for (int i = 0; i < 10; ++i) {
			//...
		}

	Burada bir sorun yoktur. Çünkü yukarıdaki kodun eşdeğeri aşağıdaki gibidir:

	{
		int i = 0;

		for (; i < 10; ++i) 
			{
				int i = 0;

				for (; i < 10; ++i) {
					//...
				}
			}
	}

	Yani aslında buradaki söz konusu iki i değişkeni aynı blokta değildir, iç içe bloklardadır. Tabii biz iç döngüde dış döngüdeki i değişkenini artık kullanamayız. 

	Her ne kadar iç içe for döngülerinde döngülerin birinci kısmında aynı isimli değişkenler bildirilebiliyorsa da aslında bu durum iyi bir teknik değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		for (int i = 0; i < 10; ++i)
			cout << i << endl;		// Buradaki i iç for döngüsündeki i, diğer i'ye erişemeyiz
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	for döngülerinin birinci kısmında "aynı türden olmak koşulu ile" birden fazla değişkenin bilfirimi de yapılabilir. Örneğğin:

	for (int i = 0,  k = 100; i + k > 50; ++i, k -= 2) {
		//...
	}

	Ancak burada bildirilen değişkenler farklı türlerden olamamaktadır. Örneğin:

	for (int i = 0, long k = 100; ...) {		// geçersiz!..
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0, k = 100; i + k > 50; ++i, k -= 2)
		cout << i << ", " << k << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	for döngüsünün birinci kısmında bildirilen değişkenlere ilkdeğer verilmesi gerekir. Ancak bu durum C++'ta standartlarında zorunlu tutulmamıştır. Genel olarak 
	bu biçimde bildirilen değişkenlere ilkdeğer verilmemesinin bir anlamı yoktur. Örneğin:

	for (int i; i < 10; ++i) {		// geçerli ama çöp değer kullanılıyor
		//...
	}

	Java ve C# gibi diğer dilelrde ilkdeğer verme bir zounluluktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														3. Ders 21/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta if, while switch gibi deyimlerin parantezleri içerisinde de bildirimler yapılabilir. Bu durumda o değişkenlere atanan değerler test işlemine girer. Örneğin:

	if (void *ptr = malloc(1024)) {		// tahsisat başarılı ise
		//...
	}

	Burada ptr'ye atanan değer test işlemine sokulmaktadır. Örneğin:

	while (int a = foo()) {
		//...
	}

	Burada foo fonksiyonu sıfır dışı bir değerle geri döndüğü sürece döngü devam edecektir. Örneğin:

	switch (int a = rand() % 10) {
		//...
	}

	Böyle bir özellik C'de yoktur.

	Deyimlerin parantezleri içerisinde bildirim yapıldıktan sonra artık atanan değerin aynı ifadede işleme sokulması mümkün değildir. Örneğin:

	while ((int i = foo() < 10) {		// geçersiz! böyle bir sentaks yok
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
    static int i = 10;

    return --i;
}

int main()
{
    while (int i = foo())
        cout << i * i << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    4) C++'a bool türü ve bool türünden değer belirten true ve false anahtar sözcükleri de eklenmiştir. bool türü C90'da yoktu. Ancak C99 ile birlikte C'ye de 
	_Bool ismiyle bir boolean tür eklenmiştir. (C99'da <stdbool.h> içerisinde bool ismi ve true ve false isimleri makrolar biçiminde de oluşturulmuşttr.) C++'a 
	bool türü eklenince if gibi while gibi deyimlerdeki koşul ifadeleri de "bool türden olacak" biçimde değiştirilmiştir. Yani C++'ta if deyiminin ve while deyiminin
	koşul ifadesi artık bool türdendir. Eğer bu koşul ifadeleri bool türden değilse derleyici tarafından otomatik olarak (implictly) bool türüne dönüştürülmektedir.  
	Aynı durum for döngüsünün ikinci kısmı için de geçerlidir. 

	C++'ta karşılaştırma operatörlerinin ürettiği değerler de bool türdendir. (C'nin bütün standartlarında karşılaştırma operatörlerinin int türden değer ürettiğini 
	anımsayınız.)

	Standartlar bool türü için ayrılacak yerin derleyiciye bağlı olarak değişebileceğini (implementation-defined) belirtmektedir (8.5.2.3-1). Tipik olarak 
	derleyicileer bool türü için 1 byte yer ayırmaktadır.

	C++'a bool türünün C uyumunu koruyacak biçimde eklendiğine dikkat ediniz. Yani C++'taki bool türü adeta içerisinde 1 ve 0 değerleri bulunan bir tamsayı türü 
	gibidir. Ancak adres türleri otomatik olarak bool türüne dönüştürülebilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 0;
	bool result;

	result = a > 10;		// karşılaştırma operatörleri bool türden değer üretir
	cout << result << endl;

	result = true;			// true ve false birer anahtar sözcüktür

	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bool türü aritmetik işlemlere sokulabilir. Bu durumda "int türüne yükselteme kuralı (integral promotions)" gereğince otomatik olarak int türüne 
	dönüştürüldükten sonra işleme sokulmaktadır (7.6-6). Dönüştürme sırasında true değeri 1 olarak false değer 0 olarak dönüştürülmektedir. Yani örneğin int + bool 
	gibi bir işlemin sonucu int türden, double + bool biçiminde bir işlemin sonucu double türden, bool + bool gibi bir işlemin sonucu int türden elde edilecektir. 
	Skaler türler de bool türüne otomatik olarak (implicitly) dönüştürülebilmektedir. Sıfır dışı skaler değerler true olarak, 0 değeri ise false olarak 
	dönüşürülmektedir. Ayrıca adres türlerinden bool türüne de otomatik dönüştürme vardır. NULL adres değerleri false olarak diğer adresler ise true olarak bool 
	türüne dönüştürülürler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10, c;
	bool b = true;
	char s[10];

	c = a + b;		// geçerli bool türü işlem öncesinde otomatik olarak int türüne dönüştürülür

	cout << c << endl;

	b = 120;		// geçerli, sıfır dışı değerler true olarak dönüştürülür

	cout << b << endl;	

	b = 0;			// geçerli, sıfır değeri false olarak dönüştürülür

	cout << b << endl.i

	b = s;			// geçerli NULL pointer falsde olarak diğer adresler true olarak dönüştürülür

	cout << b << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    5) C++'ta bir fonksiyonun çağrılma noktasına kadar derleyicinin o fonksiyonun prototipiyle ya da tanımlamasıyla karşılaşmış olması gerekmektedir. C90'da 
	fonksiyon çağrısını gören derleyici eğer daha önce fonksiyon hakkında bir bilgi edinmemişse onun int geri dönüş değerine sahip olarak tanımlandığını varsayıyordu.
	Gerçi bu kural da C99 ile birlikte C++'taki gibi değiştirilmiştir. Bu durumda C++'ta örneğin bir kütüphane fonksiyonu çağrılacaksa mutlaka o fonksiyonun 
	prototipinin bulunduğu başlık dosyası da include edilmelidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	foo();		// C90'da geçerli ancak C++'ta ve C99'da geçersiz

	return 0;
}

int foo(void)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    6) C++'ta fonksiyon prototiplerinde parametre parantezinin içinin boş bırakılması ile parametre parantezlerinin içine void yazılması aynı anlamdadır. Ancak 
	C'nin tüm standartlarında bunlar farklı anlamlara gelir. C'de prototiplerde parametre parantezinin içinin boş bırakılması "bu fonksiyon herhangi bir sayıda 
	parametreye sahip olabilir, bu nedenle fonksiyon çağrılırken argümanlar sayıca ve türce kontrol edilmeyecek" anlamına geliyordu. Halbuki C++'ta artık parametre
	parantezinin içinin boş bırakılmasıyla void yazılması tamamen aynı anlama gelmektedir. Tabii C'de de bir fonksiyonun tanımlanması sırasında parametre arantezinin 
	içinin boş bırakılmasıyla void yazılması aynı anlama geliyordu. C ile C++ arasındaki farklılık tanımlamada değil prototip bildiriminde ortaya çıkmaktadır.
	Tabii C++'ta programcı isterse yine prototiplerde ya da tanımalam sırasında parametre parantezlerinin içerisine void yazabilir. 

	Aşağıdaki örnekteki kod C'de geçerli olduğu halde C++'ta geçersizdir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo();

int main()
{
	foo(10, 20);		// C'de geçerli, C++'ta geçersiz

	return 0;
}

int foo(int a, int b)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi hem C'de hemde C++'ta başından beri fonksiyon tanımlaması sırasında parametre parantezinin içinin boş bırakılması fonksiyonun 
	parametreye sahip olmadığı anlamına gelmektedir. Biz Derneğimizde C kurslarında genel olarak parametresiz fonksiyonların tanımlamasında parametre parantezinin
	içini boş bırakmayıp void yazıyorduk. Ancak C++ kurslarımızda parametre almayan fonksiyonlarda tanımlama sırasında ve prototip bildiriminde parametre parantezinin 
	içerisini boş bırakacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()			// C'de de C++'ta da foo fonksiyonun parametresi yok void yazmakla aynı
{
	return 0;
}

int main()
{
	foo(10, 20);		// C'de ve C++'ta geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    7) Hem C'de hem de C++'ta void göstericiye herhangi bir türden adres atanabilir. Ancak void bir adresin void olmayan göstericiye atanması C'de geçerli olduğu 
	halde C++'ta geçersizdir. C++'ta void bir adres void olmayan bir göstericiye tür dönüştürmesi yapılarak atanmalıdır. Örneğin:

	void *pv;
	int *pi;
	//...

	pv = pi;			// hem C'de hep de C++'ta geçerli
	pi = pv;			// C'de geçerli fakat C++'ta geçersiz!
	pi = (int *)pv;		// hem C'de hem de C++'ta geçerli

	C++'ta void adresin void olmayan bir göstericiye atanmasının (yani otomatik olarak dönüştürülmesinin) engellenmesinin temel nedeni aslıda C'deki bir açığı 
	kapatmak içindir. C'de aşağıdkai gibi bir bir açık vardı:

	int *pi;
	char *pc;
	void *pv;
	...

	pv = pi;		// C'de v e C++'ta geçerli
	pc = pv;		// C'de geçerli

	Burada biz aslında pc = pi işlemini yapmış olmaktayız. Normalde geçersiz olması gereken bu işlem araya bir void gösterici sokularak geçerli hale gelmektedir. 
	Oysa C++'ta böylesi bir "arkadan dolaşma" yapılamamaktadır. Tabii C'de neden void bir adresin void olmayan bir göstericiye atanabildiğini sorgulayabilirsiniz. 
	Bu tarihsel bir özelliktir. Zaten C++ fırsat bu fırsat C'nin böylesi açıklarını da kapatmak istemiştir. Bu tür durumlarda tür dönüştürmesi genel olarak 
	"işlemin programcı tarafından yanlışlıkla değil bilinçli olarak yapıldığını" ifade etmektedir. 

	Programlama dillerinde "kuvvetli tür kontrolü (strong type checking)" ve "zayıf tür kontrolü (weak (loose) type checking)" biçimibde bir kavram vardır. Eğer 
	biz bir dilde farklı türleri serbestçe biribine atayıp onları birlikte işleme sokabiliyorsak o dilin tür kontrolü zayıftır. Eğer bir dilde biz farklı türleri 
	birbirine atayamayıp onları birlikte işleme sokamıyorsak o dilin tür kontrolü kuvvetlidir. C ve C++'ın tür kontrolü kuvvetli değildir. Orta düzeydedir. 
	Örneğin Java ve C#'taki tür kontrolü C ve C++'a göre daha kuvvetlidir. Swift gibi Rust gibi dillerde tür kontrolü çok daha kuvvetlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a[10];
	void *pv;
	double *pd;

	pv = a;		// hem C'de hem C++'ta geçerli
	pd = pv;	// C'de geçerli, C++'ta geçersiz

	pd = (double *)pv;					// geçerli 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											4. Ders 23/08/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    8) C'de string'ler char türden bir dizi kabul edilmektedir. (Yani string'leri gören derleyici onun karakterlerini null karakter dahil olmak üzere char türden 
	statik ömürlü bir diziye yerleştirir. String yerine o dizinin kullanıldığını varsayar.) Ancak string'lerin karakterlerinin güncellenmesi "tanımsız davranışa 
	(undefined behavior)" yol açmaktadır. Ancak C++'ta string'ler const char türünden dizi anlamına gelmektedir. Dolayısıyla bir string'i char türden bir göstericiye 
	atarken göstericinin de gösterdiği yer const olan bir gösterici olması gerekir. Örneğin:

	char *str;
	//...

	str = "ankara";			// C'de geçerli C++'ta geçersiz!
	
	Örneğin:

	const char *str;
	//...

	str = "ankara";			// C'de de C++'ta da geçerli

	char türden, signed char türden ve unsigned char türden bir diziye ilkdeğer verirken kullanılan iki tırnakların string belirtmediğini anımsayınız. Bu 
	nedenle C++'ta da tıpkı C'de olduğu gibi char türden, signed char türden ve unsigned char türden diziler iki tırnak ifadesiyle ilkdeğer verilerek 
	tanımlanabilirler.

	char s1[] = "ankara";				// C'de de C++'ta da geçerli
	signed char s2[] = "ankara";		// C'de de C++'ta da geçerli
	unsigned char s[] = "ankara";		// C'de de C++'ta da geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const char *str = "ankara";

	cout << str << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	9) C'de N elemanlı char türden, signed char türden ve unsigned char türden bir diziye iki tırnak içerisinde N karakterli bir yazı ile ilkdeğer verilebilir. Bu 
	durumda derleyici null karakteri diziye yerleştirmez. Ancak bu durum C++'ta geçerli değildir. C++'ta N karakterlik bir yazının ilkdeğer verildiği dizinin
	en azından N + 1 karakter uzunluğunda olması (ya da uzunluk belirtilmemesi) gerekir. Örneğin:

	char s[6] = "ankara";		// C'de geçerli ancak C++'ta geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    10) C++11 ile birlikte UNICODE string'ler ve karakter sabitleri de dile eklenmiştir. UNICODE UTF-8 için u8 öneki, UNICODE UTF-16 için u öneki ve UNICODE 
	UTF-32 için U öneki kullanılmaktadır. u önekli string'ler const char16_t türünden, U önekli string'ler const char32_t türünden ve u8 önekli string'ler de 
	const char8_t türünden bir dizi olarak ele alınmaktadır. C++20'ye kadar char8_t biçiminde bir tür yoktu. Bu tür C++20 ile eklenmiştir. Bu tür isimleri 
	typedef değil anahtar sözcüklerdir. Bu türlerin hepsi işaretsiz bir tamsayı türü belirtmektedir. Bunların işaretli biçimleri de yoktur. C++'ta u önekli string'ler
	const char16_t türünden, U önekli string'ler const char32_t türünden ve u8 önekli string'ler ise const char8_t türünden dizi kabul edilmektedir. Örneğin:

	const char *s = "Ankara";					// default karakter tablosu 
	const char16_t *k = u"Ağrı Dağı";			// UTF-16
	const char32_t *t = U"Ağrı Dağı";			// UTF-32
	const char8_t *m = u8"Ağrı Dağı";			// UTF-8
	
	char8_t türünden, char16_t türünden ve char32_t türünden dizilere u8 önekli, u önekli ve U önekli iki tırnaklı ifadeler ilkdeğer olarak verilebilmektedir. 
	Tabii bu durumda dizilerin const olması gerekmez. Örneğin:

	char8_t s1[] = u8"ankara"; // geçerli
    char16_t s2[] = u"ankara"; // geçerli
    char32_t s3[] = U"ankara"; // geçerli

	C++20'ye kadar char8_t türü yoktu. Dolayısıyla C++20'ye kadar u8 önekli string'ler unsigned char türünden diziler gibi ele alınıyordu. C++20'de u8 önekli 
	string'ler için de char8_t türü eklenmiştir. C++20 satndartları C++20'ye eklenen char8_t türünün unsigned char türü ile aynı uzunlukta olması gerektiği 
	belirtilmiştir. (Başka bir deyişle C++20'de eklenen char8_t türü adeta unsigned char türü gibidir ancak fakat farklı bir türdür.)

	char8_t türü, char16_t türü ve char32_t türü cout ile stdout dosyasına yazdırılamamaktadır. 

	Tabii nasıl u önekli, U önekli ve u8 önekli stringler varsa aynı zamanda bu önekli karakter sabitleri de vardır. Bu karakter sabitleri de sırasıyla char16_t, char32_t 
	ve char8_t türünden sabitler kabul edilmektedir. Örneğin:

    char8_t a = u8'a';
    char16_t b = u'b';
    char32_t c = U'c';

	Karakter kodlamaları (character encoding) ayrıntıları olan uygulamada çetrefil bir konudur. Bir karakter tablosu "glyph", "code point" ve "encoding" denilen 
	üç kavramla ilgilidir. Karakter tablosundaki karakter görüntülerine "glyph" denilmektedir. Karakter tablosunu oluşturanlar her karaktere bir numara verirler. 
	İlgili glyph'in numarasına "code point" denilmektedir. Bir code point'in ikilik sistemde byte'lar haline ifade edilme biçimine de "encoding" denilmektedir. 
	Örneğin ASCII tablosunda 'A' glyph'inin code point'i 65'tir. ASCII tablosu tamamne düz binary dönüştürmeyle encode edilmektedir. Son 20 yıldır ASCII tablosunun 
	ve bu tablonun "code page" varyasonları çeşitli bakımlardan yetersiz kaldığı için UNICODE denilen (ISO 10646) her karakterin kabaca 2 byte ile ifade edilebildiği
	dünyanın bütün karakterlerinin içinde bulunduğu karakter tablosu oldukça yaygınlaşmıştır. Pek çok yeni programlama dilinde "char" türü UNICODE karakterleri
	tutmak için oluşturulmuştur. UNICODE tablonun UTF-16, UTF-32 ve UTF-8 denilen encoding'leri vardır. UTF-16 UNICODE için en doğal encoding'tir. Bu encoding'te 
	kabaca her UNICODE code point WORD biçimde (2 bytelık sayı olarak) kodlanmaktadır. UTF-32'de ise her code point 4 byte ile kodlanmaktadır. Ancak UNICODE tablonun 
	en yaygın encoding'i UTF-8 denilen encoding'tir. UNICODE tablonun ilk 128 karakteri standart ASCII tablosu ile aynıdır. Sonraki 128 karakteri de ISO 8859-1 
	denilen Latin1 code page'i ile aynıdır. UTF8-8 encoding'inde standart ASCII karakterler 1 byte ile diğer karakterler duruma göre 2 byte, 3 byte 4 byte ve 5 byte 
	ile kodlanmaktadır. Bugün kullandığımız programalama editörlerinin büyük kısmının default encoding'i UNICODE UTF-8'dir. 

	Ancak bu konu sanıldığından daha çetrefildir. Çünkü bir C/C++ programı yazarken değişik aktörler devreye girmektedir. Bu aktörlerden birincisi kodu yazdığımız 
	editördür. Bu editörün default bir encoding'i vardır. Örneğin kursun yapıldığı bilgisayardaki Visual Studio IDE'sinin default encoding'i ASCII 1254 code page'idir. 
	Visual Studio Code IDE'sinin defaulşt encoding'i UNICODE UTF-8'dir. İkinci aktör bizzat derleyicinin kendisidir. Derleyici kaynak kodu aldığında o kaynak 
	koddaki yazının da belli bir encoding'e göre kodlandığını varsaymaktadır. Eğer bizim kaynak kodda kullandığımız encoding derleyicinin varsaydığı encoding'ten 
	farklıysa burada da potansiyel bir problem vardır. Buna derleyicinin "kaynak karakter kümesi (source character set)" denilmektedir. Kaynak karakter kümesi 
	derleycilerde komut satırı seçenekleriyle değiştirilebilmektedir. Üçüncü aktör ise programın çalıştırıldığı ortamdaki aygıtların (stdout ve stdin aygıt 
	sürücülerinin) varsaydığı encoding'tir. Buradaki uyuşmazlık karakterlerin doğru gözükmemesine yol açacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    11) C++'ta sınıflarla temel türlerin şablon uyumunun sağlanması için temel türlere de parantezler ile ilkdeğer verilebilmesi mümkün hale getirilmiştir. 
	Örneğin:

	int a = 10;

	Biz bu tanımlamayı şöyle de yapabilirdik:

	int a(10);		// C++'a özgü, C'de böyle bir ilkdeğer verme sentaksı yok

	Ancak parantezlerin içini boş bırakmak "fonksiyon prototipi" anlamına gelmektedir. Örneğin:

	int b();		// bu ilkdeğer verme sentaksı değil! Fonksiyon prototipi

	Örneğin:

	const char *name("ali");

	Pekiyi bir diziye ya da yapıya da bu biçimde ilkdeğer verebilir miyiz? Örneğin:

	int a[3](10, 20, 30);

	Bu durum C++20'ye kadar geçerli değildi. Yani C++20 öncesinde dizilere ve yapılaba normal parantezlerle ilkdeğer verilemiyordu. Ancak C++20 ile birlikte 
	bu durum da geçerli hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    12) C++'ta çeşitli biçimlerde ilkdeğer verme (initialization) sentaksları bulunmaktadır. Örneğin bir değişkene bir ifade ile '=' atomu kullanılarak ilkdeğer 
	verilebilir:

	int a = 10;
	
	Böyle ilkdeğer verme C'de yoktur. Bu normal parantez sentaksı C++'ta sınıflar için düşünülmüştür. Ancak temel türler için de kullanılabilmektedir. 

	Bir diziye küme parantezleriyle ilkdeğer verilir:

	int a[] = {1, 2, 3};

	C'de ve C++'ta skaler türlere de küme parantezi ile ilkdeğer verilebilmektedir. Örneğin:

	int a = {10};

	Bir sınıf nesnesi normal parantezlerle ilkdeğerlenir:

	Sample s(10, 20);

	Yukarıda da belirttiğimiz C++'ta bu sınıflar düşünülmüş olan (...) sentaksı skaler türler için de kullanılabilmektedir. Örneğin:

	int a(10); 

	İşte C++11 ile birlikte her durum için geçerli olan ilkdeğer verme sentaksı oluşturulmuştur. Buna "Uniform Initializer Syntax" denilmektedir. Bu sentaksta 
	hiç '=' atomu kullanılmadan doğrudan küme parantezleri içerisinde ilkdeğer verilir. Örneğin:

	int a{10};
	const char *b{"ali"};
	int c[]{1, 2, 3};
	int d{};				// d = 0

	Bu ilkdeğer verme sentaksına "Uniform Initializer Syntax" denilmesinin nedeni her türden değişkene bu biçimde ilkdeğer verilebilmektedirilmesidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a{10};
	const char *b{"ali"};
	int c[]{1, 2, 3};
	int d{};				// d = 0

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Uniform Initializer Syntax ile ilkdeğer verme sırasında bilgi kaybına yol açabilecek dönüştürmeler geçerli değildir. Bilgi kaybına yol açabilecek dönüştürmelere
	C++11 standartlarında "daraltıcı dönüştürmeler (narrowing conversion)" denilmektedir. Büyük tamsayı türünden küçük tamsayı türüne yapılan dönüştürmeler, 
	gerçek sayı türlerinden tamsayı türlerine yapılan dönüştürmeler bilgi kaybı oluşturabildiği için "daraltıcı dönüştürmeler (narrowing conversion)" durumundadır. 
	Örneğin:

	int a{3.14};		// geçersiz!
	int b = 3.14;		// geçerli
	double c{3.14};		// geçerli
	float d{c}; 		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a{10.2};			// geçersiz!
	int b = 10.2;			// geçerli
	int c[]{1, 2, 3.4, 5};	// geçersiz!

	long d{100};			// geçerli
	int e{d};				// geçersiz

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															5. Ders 28/08/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki dönüştürmeler daraltıcı dönüştürmeler olarak kabul edilmektedir:

	- Gerçek sayı türlerinden tamsayı türlerine yapılan dönüştürmeler (örneğin long double, double ve float türünden int türüne yapılan dönüştürmeler). Örneğin:

	double d{3.0};
    int a{d};			// geçersiz! 
	int b{3.0};			// geçersiz!

	- Büyük gerçek sayı türünden bir daha küçük bir gerçek sayı türüne yapılan dönüştürmeler. Örneğin double türünden float türüne yapılan dönüştürmeler
	daraltıcı dönüştürmelerdir. Ancak büyük gerçek sayı türünden değer bir sabit ifadesi biçiminde verildiyse ve bu sabit ifadesi hedef tür ile tam olarak 
	ifade edilebiliyorsa bu daraltıcı dönüştürme kabul edilmemektedir. Örneğin:

	double d{3.14};
	float f{d};			// geçersiz!
	float e{3.14}		// geçerli, çünkü 3.14 bir sabit ifadesidir ve float türüyle tam olarak temsil edilebilmektedir. 
	float g{3.14 + 1};	// geçerli, çünkü 4.14 bir sabit ifadesidir ve float türüyle tam olarak temsil edilebilmektedir. 

	- Bir tamsayı türünden gerçek sayı türüne dönüştürmeler de bilgi kaybına yol açabilme potansiyeline sahip olduğu için daraltıcı dönüştürmelerdir. Ancak 
	tamsayı türünden değer bir sabit ifadesi biçiminde belirtilmişse ve bu sabit ifadesi hedef tür tarafından tam olarak ifade edilebiliyorsa bu bir daraltıcı
	dönüştürme değildir. Örneğin:

	int a{10};
	double b{a};		// geçersiz!
	char c;
	double e{c};		// geçersiz!
	float f{1234};		// geçerli

	- Bir tamsayı türünden başka bir tamsayı türüne dönüştürme yapılırken eğer hedef tür "o sistemdeki" kaynak türün tüm değerlerini içeriyorsa bu bir daraltıcı 
	dönüştürme değildir. Ancak içermiyorsa bu bir daraltıcı dönüştürmedir. Örneğin:

	int a{10};
    unsigned b{a};      // geçersiz!
	unsigned c{10};
    int d{c};			// geçersiz!
	long e{10};
    int f{e};			// int ile long türünün aynı uzunlukta olduğu sistemlerde geçerli (örneğin Microsoft derleyicilerinde)
						// ancak int ve long türünün farklı uzunluklarda olduğu sistemlerde geçersiz (örneğin 64 bit Linux derleyicilerinde)

	Ancak kaynak tamsayı türündeki değer bir sabit ifadesi ise ve hedef türün sınırları içerisinde kalıyorsa bu bir daraltıcı dönüştürme değildir. 
	Örneğin:

	unsigned a{10};		// geçerli, 10 int türden fakat unsigned int sınırları içerisinde
	unsigned b{-10};	// geçersiz! -10 int türden fakat unsigned int sınırları içerisinde değil
	int c{123L};		// geçerli, 123 long türden ancak int sınırları içerisinde 
	long d{123};		// geçerli, 123 int türden ve long türünün sınırları içerisinde

	- Anımsanacağı gibi adres türlerinden bool türüne otomatik dönüştürme vardı. Ancak adres türlerinden bool türüne yapılan dönüştürmeler daraltı
	dönüştürmelerdir. Örneğin:

	char s[10];
    bool b = s;     // geçerli

    bool c{s};		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++11 ile birlikte küme parantezleri ile ilkdeğer vermelerin hepsinde daraltıcı dönüştürme yasaklanmıştır. Örneğin aşağıdaki ilkdeğer vermeler 
	C++11 öncesi geçerli olduğu halde C++11 ile birlikte artık geçersizdir:

	int a[] = {10.2, 1, 2};				// geçersiz!
	int b = {3.14};						// geçersiz!
	short c[]{10L, 100, 1000};			// geçerli

	Görüldüğü gibi her ne kadar daraltıcı dönüştürmeler C++11'in Uniform Initializer Syntax'ı ile kavramsal olarak dile eklendiyse de yalnızca Uniform Initializer 
	Syntax ile değil tüm küme parantezleri ile ilkdeğer verilirken etkili olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = {10.2, 1, 2};		// C++11 ile birlikte artık geçerli değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	13) C++'ta const nesneler onlara verilen ilkdeğerler "sabit ifadesi (constant expression)" ise sabit ifadesi belirtirler. Halbuki C'de const nesneler hiçbir 
	zaman sabit ifadesi belirtmezler. Ayrıca C++'ta global const nesneler "internal linkage"a sahiptir. (Yani sanki static global nesneler gibi düşünülmelidir.)
	Tabii bir sabit ifadesi sabit ifadeleriyle de oluşturulabilmektedir. Örneğin:

	const int a = 10;		// a sabit ifadesi olarak kullanılabilir
	const int b = a + 20;	// b sabit ifadesi olarak kullanılabilir
	const int c = foo();	// c sabit ifadesi olarak kullanılamaz!

	Anımsanacağı gibi C'de (ve C++'ta) bazı durumlarda sabit ifadesi kullanımı zorunludur. Örneğin case ifadelerinin sabit ifadesi olması gerekir. Örneğin dizi
	tanımlanırken dizi uzunluklarının sabit ifadesi olması gerekmektedir. (C99'da yerel diziler için bu zorunluluk ortadan kaldırılmıştır.) Örneğin C++'ta 
	şablonların tür olmayan (none-type) parametreleri sabit ifadesi olarak girilmek zorundadır. Sabit ifadelerinin diğer önemli bir işlevi de onların değerlerinin 
	derleme zamanında hesaplanabilmesi dolayısıyla programın çalışma zamanı sırasında gereksiz bir biçimde yapılmamasıdır. Bu optimizasyon temsaına "constant folding"
	denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

const int SIZE = 10;

int main(void)
{
	int a[SIZE];			// geçerli SIZE sabiti ifadesi ile ilkdeğer verilmiş bir const nesne
	
	int val;
	const int AA = 2;
	int b = 10;
	const int BB = b;

	cout << "Bir değer giriniz:";
	cin >> val;

	switch (val) {
		case AA:				// geçerli AA bir sabit ifadesi
			break;
		case BB:				// geçersiz! BB bir sabit ifadsi değil, çünkü ona verilen ilkdeğer sabit ifadesi değil
			break;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta global const nesnelerin "internal linkage" özelliğine sahip olması onların başka bir modülden extern yapılsa bile kullanılamayacağı anlamına gelmektedir. 
	Bu durumda derleyiciler global const nesnelere verilen ilkdeğerler sabit ifadesi ise onlar için hiç ayırmayabilirler. Çünkü aslında sabit ifadeleri ile ilkdeğer
	verilmiş olan global const nesneler kod içerisinde kullanıldığında derleyici zaten onların değerlerine koda enjekte edecektir. Bunlar başka bir modülden de
	kullanılamayacağına göre onlar için yer ayrılmasının da bir anlamı kalmayacaktır. Şüphesiz aynı durum yerel const nesneler için de geçerlidir. Anımsanacağı gibi 
	yerel değişkenlerin zaten "linkage" özelliği yoktur. Tabii programcı const nesnelere sabit ifadesi ile ilkdeğer verdikten sonra onların adreslerini alıp 
	kod içerisinde kullanırsa derleyiciler mecburen onlar için yer ayırmak durumunda kalır. 
	
	O halde C++'ta sabit ifadeleriyle ilkdeğer verilmiş global const nesneler adeta #define sembolik sabitleri gibi kullanılabilmektedir. Biz global const 
	nesneleri (özellikle sabit ifadeleriyle ilkdeğer verilmiş olanları) başlık dosyalarına (header files) yerleştirip birden fazla kaynak dosyadan include 
	edebiliriz. Bu durumda herhangi bir problem ortaya çıkmayacaktır. C++ programcıları #define sembolik sabitleri yerine global const nesneleri kullanmayı 
	tercih edebilmektedir.

	Anımsanacağı gibi iki yer belirleyici (storage class specifier) anahtar sözcük bildirimde bir arada kullanılamamaktadır. Örneğin:

	extern static int g_x;		// geçersiz!

	Ancak tür niteleyicileriyle (const ve volatile) yer belirleyicileri birlikte kullanılabilirler. Örneğin:

	extern const int g_x = 10;

	C++'ta const nesneler default durumda "inernal linkage" özelliğine sahiptir. Ancak özellikle extern belirlemesi yapılırsa "external linkage" özelliğine 
	sahip olmaktadır. 

	Ayrıca C++'ta const nesnelere artık ilkdeğer verilmek zorundadır. Halbuki C'de anlamsız olsa da const nesnelere ilkdeğer vermek zorunlu değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    14) C++'ta statik ömürlü değişkenlere (yani global ve statik yerel nesnelere) verilen ilkdeğerler sabit ifadesi olmak zorunda değildir. Halbuki C'de global 
	değişkenlere ve statik yerel değişkenlere verilen ilkdeğerlerin sabit ifadesi olması zorunludur. C'de bu zorunluluk derleyicinin statik ömürlü değişkeni
	ilkdeğeri ile birlikre amaç koda yazma gerekeliliğinden kaynaklanmaktadır. Bu gereklilik C++'ta oratadan kaldırılmıştır. (Çünkü C++'ta main fonksiyonu 
	çağrılmadan önce derleyici başka kodlar da çalıştırabilmektedir.) Örneğin:

	int foo()
	{
		return 10;
	}

	int g_x = foo();			// C'de geçersiz! C++'ta geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    15) C++11 ile birlikte C++'a ismine "constexpr" denilen bir tür niteliyici (type qualifier) da eklenmiştir. constexpr bir değişken her zaman bir sabit ifadesi 
	biçiminde kullanılabilir. (const bir değişken sabit ifadesi olarak kullanılabilmesi için ona verilen ilkdeğerin sabit ifadesi belirtmesi gerektiğini anımsayınız.)
	Ancak constexpr değişkenlere verilen ilkdeğerlerin sabit ifadesi olması zorunludur.  Global constexpr değişkenler de yine "internal linkage" sahiptirler.
	constexpr değişkenler aynı zamanda const nesneler olarak ele alınmaktadır. Dolayısıyla örneğin bir constexpr değişkenin adresi ancak const bir göstericiye 
	atanabilir.	Örneğin:

	constexpr int a = 10;		// geçerli
	constexpr int b = a + 1;	// geçerli
	int c = 20;
	constexpr int d = c + 1;	// geçersiz! constexpr değişkene verilen ilkdeğerin sabit ifadasi olması gerekir
	const int e = 10
	constexpr int f = e + 1;	// geçerli

	constexpr değişkenler const değişkenlerin daha katı bir biçimi gibidir. Biz programımız içerisindeki sembolik sabitleri #define ile değil constexpr değişkenlerle 
	de oluşturabilmekteyiz. Örneğin:

	constexpr int SIZE = 10;

	Derleyiciler eğer onların adresleri alınmadıysa constexpr değişkenler için hiç yer ayırmayabilirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

constexpr int SIZE = 10;

int main(void)
{
	int a[SIZE];						// geçerli, SIZE bir sabit ifadesi

	constexpr int AA = SIZE + 2;		// geçerli, SIZE + 2 bir sabit ifadesi

	int b = 10;
	constexpr int CC = b + 2;			// geçersiz! b + 2 bir sabit ifadesi değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
															6. Ders 04/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr tür niteleyicisi fonksiyonlarda da kullanılabilmektedir. Bu tür fonksiyonlara constexpr fonksiyonlar denilmektedir. constexpr fonksiyonların 
	dile sokulmasından amaç bir fonksiyon çağrısının sabit ifadesi biçiminde derleme zamanında ele alınabilmesini sağlamaktır. const niteleyicisinin böyle bir 
	yeteneği yoktur. Örneğin:

	constexpr int foo()
	{
		return 10;
	}

	Bu fonksiyon çağrıldığında derleyici CALL makine komutu ile fonksiyonu çağırmaz. Doğrudan sanki çağrıdan 10 değeri elde edilmiş gibi 10 değerini kullanır. 
	Örneğin:

	constexpr int x = foo();

	Bu işlem için derleyici aşağıdakine eşdeğer bir kod üretecektir:

	constexpr int x = 10;

	constexpr fonksiyonların bazı ayrıntıları vardır. İzleyen bölümlerde bu ayrıntılar üzerinde duracağız. Örneğin:

	constexpr int x = foo();		// geçerli

	Yukarıdaki foo fonksiyonu sabit ifadesi oluşturduğu için constexpr bir değişkene ilkdeğer vermede kullanılabilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
	return 10;
}

constexpr int bar()
{
	return 10;
}

int main(void)
{
	int a[foo()];		// geçersiz! fonksiyon çağrıları sabir ifadesi oluşturmaz
	int b[bar()];		// geçerli, bar çağrısı sabit ifadesi oluşturur

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr fonksiyonlar aynı zamanda inline fonksiyon olarak kabul edilmektedir. inline fonksiyonlar izleyen paragraflarda ele alınmaktadır. Bu durumda her
	constexpr fonksiyon aynı zamanda bir inline fonksiyondur. Ancak inline fonksiyonlar constexpr fonksiyon değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11'de constexpr fonksiyonların birkaç önemsiz bildirimin dışında tek bir satırdan oluşması gerekiyordu. Yani C++11'de constexpr fonksiyonlar yalnızca return 
	içerebiliyordu. Ancak daha sonra bu constexpr fonksiyonların sentaks ve semantiğinde neredeyse her standartta biraz oynama yapılmıştır. C++20'yi dikkate 
	alırsak artık constexpr fonksiyonların içerisinde if gibi for gibi deyimler kullanılabilmektedir. Yani constexpr fonksiyonlar artık neredeyse normal bir 
	fonksiyon gibi yazılabilir durumuna getirilmiştir. C++11'de constexpr fonksiyonların çağrıldıklarında sabit ifadesi belirtmesi gerekiyordu. Ancak C++14 ile birlikte 
	constexpr fonksiyonların sabit ifadesi belirtme zorunluluğu da ortadan kaldırılmıştır. Ancak constexpr fonksiyonların sabit ifadesi belirtmesi için onlar çağrılırken
	argüman olarak sabit ifadelerinin kullanılıyor olması ve return ifadelerinin de sabit ifadesi oluşturuyor olması gerekmektedir. (Tabii return ifadelerinde parametreler 
	kullanılabilir. Eğer fonksiyon sabit ifadesi argümanlarla çağrılmışsa parametrelerin de sabit ifadesi belirttiği kabul edilmektedir.) Örneğin:

	constexpr int square(int a)
	{
		return a * a;
	}
	//...
	constexpr int a = square(10);		// geçerli
	constexpr int b = square(a + 2);	// geçerli

	int c = 10;
	constexpr int d = square(c);		// geçersiz! square çağrısı sabit ifadesi belirtmiyor.		

	Yukarıda da belirttiğimiz gibi artık constexpr fonksiyonların sabit ifadesi belirtmesi gerekmemektedir. Eğer constexpr bir fonksiyon sabit ifadesi olmayan 
	argümanlarla çağrılmışsa ya da return ifadesinde sabit ifadesi yoksa bu durumda sabit ifadesi belirtmez. Ancak sabit ifadesi belirtmeyen constexpr fonksiyonlar 
	tamamen normal inline fonksiyon gibi işleme sokulmaktadır.	Örneğin:

	int a = 10;
	int b = square(a);		// geçerli

	Burada contstexpr fonksiyon sabit ifadesi belirtmemektedir. Normal bir fonksiyon olarak ele alınacaktır.

	constexpr fonksiyonların geri dönüş değerleri ve parametre türleri "literal türlere (literal types)" ilişkin olmak zorundadır. Literal tür kavramı 
	birtakım yeniliklerin sonucunda dile eklenmiştir. Skaler türler ve void türü literal türlerdir. Literal tür tanımına giren diğer türler başka konuların
	içerisinde ele alınacaktır.

	C++23'e kadar (henüz resmi basımı yapılmadı) constexpr fonksiyonların en azından bir argümanlı çağrısı sabit iafdesi oluşturabilecek potansiyelde olması 
	gerekiyordu. Ancak bu kural da gevşetilmiştir. 

	constexpr fonksiyonun tüm bildirimlerinde constexpr niteleyicisinin kullanılması gerekir. Ancak tabii constexpr fonksiyonun sabit ifadesi olarak ele 
	alınabilmesi için derleyicinin çağrılma noktasına kadar constexpr fonksiyonunun tanımlaması ile karşılaşmış olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

using namespace std;

constexpr int square(int a)
{
	return a * a;
}

int main(void)
{
	int a[square(10)];		// geçerli, burada square(10) çağrısı sabit ifadesi belirtiyor
	int b{10};
	int c[square(b)];		// geçersiz artık square bir sabit ifadesi belirtimiyor
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi constexpr bir fonksiyon yan etkiye sahip olabilir mi? Örneğin:

	using namespace std;

	void foo()
	{
		//...
	}

	constexpr int bar(int a)
	{
		foo();

		return a;
	}

	Böyle bir bar fonksiyonu constexpr olarak tanımlanabilir mi? İşte C++23'e kadar bu durum mümkün değildi. Çünkü C++23'e kadar constexpr fonksiyonların 
	yalnızca sabit ifadesi üretmesi esastı. Buradaki sorun bar fonksiyonunun aslında hiçbir biçimde sabit ifadesi üretememesidir. bar fonksiyonun sabit 
	ifadesi üretmesi yalnıca return ifadesinde sabit ifadesi oluşturması anlamına gelmemektedir. bar fonksiyonun sabit ifadesi oluşturabilmesi demek her şeyiyle
	derleme aşamasında yalnızca bir sabit değerin elde edilebilmesi demektir. Ancak C++23 ile birlikte bu durum da gevşetilmiştir. C++23'te bar fonksiyonun 
	tanımlaması geçerlidir. Ancak fonksiyon hiçbir zaman sabit ifadesi oluşturamayacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun constexpr olması ve onun sabit ifadesi biçiminde açılabiliyor olması derleyicinin ""eğer bir zorunluluk yoksa"" onu derleme aşamasında sabit
	ifadesi olarak ele almasını zorunlu hale getirmemektedir. Örneğin:
	
	constexpr int square(int a)
	{
		return a * a;
	}
	//...

	int result = square(4);

	Burada derleyici square çağrısını derleme aşamasında ele alıp oraya 16 yazmak zorunda değildir. Gerçekten de derleyicilerin bir bölümü optimizasyon seçeneklerini 
	açmadıktan sonra bu çağrıyı sabit ifadesi olarak ele almamaktadır. Ancak C++ standratlarına göre buradaki square çağrısı sabit ifadesi olarak kullanılabilir. 
	Dolayısıyla biz bu square çağrısını sabit ifadesi gereken bir yerde kullanırsak artık derleyici kesinlikle onu bir sabit ifadesi gibi ele alacak ve çağrı 
	yerine doğrudan çağrı sonucunda elde edilecek değeri yerleştirecektir:

	constexpr int square(int a)
	{
		return a * a;
	}
	//...

	constexpr int result = square(4);

	Burada derleyici kodu aşağıdaki gibi ele alacaktır:

	constexpr int result = 16;

	Özetle "constexpr bir fonksiyonun çağrısı sabit ifadesi koşullarını sağlıyor olsa bile eğer çağrı bir sabit ifadesi gereken yerde kullanılmamışsa"" derleme
	aşamasında ele alınmak zorunda değildir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Mademki artık son standartlarda neredeyse constexpr fonksiyonlar normal fonksiyonlar gibi olmuştur. Bu durumda biz her fonksiyonu mümkün olduğunca constexpr
	yapmalı mıyız? Yukarıda da belirttiğimiz gibi hala constexpr fonksiyonlar için bazı kısıtlar bulunmaktadır. Bu kısıtları ayrıntı olduğu gerekçesiyle burada 
	şimdi ele almayacağız. Ancak olabilecek her fonksiyonu constexpr fonksiyon olarak tanımalama çalışmak da iyi bir fikir değildir. Bunun en önemli nedeni 
	constexpr fonksiynların default olarak inline kabul edilmesidir. Biz henüz inline fonksiyonları görmemiş olsak da inline fonksiyonların bazı kısıtları ve 
	dezavantajları söz konusu olabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr fonksiyonlarda fonksiyonun tüm prototip ve tanımlamasında constexpr belirleyicisinin kullanılması gerekmektedir. Örneğin:

	constexpr int square(int a);
	//...
	
	int square(int a)		// geçerli değl! burada da constexpr anahtar sözcüğünün kullanılması gerekirdi.
	{
		return a * a;
	}

	Tabii constexpr fonksiyonlarda fonksiyon çağrılana kadar derleyicinin fonksiyonun tanımlamasını görmesi gerekmemektedir. Ancak burada constexpr etkisi oluşmaz.
	Örneğin:

	constexpr int square(int a);
	//...
	
	int main()
	{
		constexpr int a = square(10);		// geçersiz! tanımalam görülmediği için constexpr etkisi oluşmaz
		int a = square(10);					// geçerli! constexpr fonksiyonların sabit ifadesi belirtmesi zorunlu değildir. 
		//...

		return 0;
	}

	int square(int a)		// geçerli değl! burada da constexpr anahtar sözcüğünün kullanılması gerekirdi.
	{
		return a * a;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında constexpr fonksiyonlarla ilgili bazı ayrıntılar da vardır. Örneğin cbir sınıfın yapıcı fonksiyonu (constructor) constexpr olabilmektedir. Sınıfın 
	üye fonksiyonları da constexpr olabilektedir. Konun bu ayrıntıları ilgili bölümlerde ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	16) constexpr fonksiyonlar C++11 ile dile eklendiğinde amaç bu fonksiyonların her zaman sabit ifadesi oluşurması biçimindeydi. Daha sonra bu koşul gevşetildi ve
	constexpr fonksiyonlar "koşula bağlı olarak sabit ifadesi oluşturur" hale getirildi. İşte C++20 ile birlikte her zmaan sabit ifadesi oluşturması gereken (yani
	C++11'deki constexpr fonksiyonlar gibi) yeni bir fonksiyon biçimi oluşturuldu. Bunlara consteval fonksiyonlar ya da "immediate fonksiyonlar" denilmektedir. 
	consteval bir fonksiyonun her çağrısının sabit ifadesi oluşturması zorunludur. Örneğin:

	constexpr int square1(int a)
	{
		return a * a;
	}

	consteval int square2(int a)
	{
		return a * a;
	}
	...
	
	int x = 10;
    int y = square1(x);			   // geçerli 
    int z = square2(x);            // geçersiz!

	Burada hem square1 hem de square2 çağrıları sabit ifadesi oluşturmamaktadır. Ancak constexpr fonksiyonların zaten çağrıldıklarında sabit ifadesi oluşturma 
	zorunluluğu yoktur. Fakat consteval fonksiyonların çağrıldıklarında sabit ifadesi oluşturma zorunluluğu vardır. Biz consteval fonksiyonları hangi ifadede 
	ve hangi nesneye ilkdeğer vermek için çağırırsak çağıralım çağrının sabit ifadesi oluşturması zorunludur. 

	consteval fonksiyonların constexpr fonksiyonların içerisinde çağrılması bu bakımdan bir farklılık yaratmamaktadır. Örneğin:

	consteval int square1(int a)
	{
		return a * a;
	}

	constexpr int square2(int a)
	{
		return square1(a);
	}

	Burada square2 fonksiyonu square1 fonksiyonunu çağırmıştır. Ancal square1 çağrısında sabit ifadesi kullanılmamış durumdadır. Bu işlemin tersini yapalım:

	constexpr int square1(int a)
	{
		return a * a;
	}

	consteval int square2(int a)
	{
		return square1(a);
	}

	Burada consteval fonksiyon olan square2, constexpr fonksiyon olan square1 fonksiyonunu çağırmıştır. Bu tanımlama derleme aşamsında bir sorun oluşturmayacaktır.
	Tabii square2 çağrılırken yine sabit ifadesi oluşturması gerekmektedir. Örneğin:

	int x = square2(10);		// geçerli

	int z = 10;
	int k = square2(z);			// geçersiz!

	Buradan da görüldüğü gibi önemli olan consteval fonksiyonun çağrısının derleme aşamasında sabit ifadesi oluşturma zorunluluğudur. 

	consteval bir fonksiyon için prototip bulundurulabilir. eğer fonksiyonun prototipinde consteval anahtar sözcüğü kullanılmışsa tanımlamasında da consteval
	anahtar sözcüğünün kullanılması zorunludur. consteval bir fonksiyonun henüz tanımalama görülmeden kullanılması geçerli bir durum oluşturmamaktadır. Örneğin:

	consteval int square(int a);

	int main()
	{
		int result = square(5);		// geçersiz! henüz tamlama görülmedi
		//...

		return 0;
	}

	consteval int square(int a)
	{
		return a * a;
	}

	consteval fonksiyonların adresleri alınamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    17) C'de ifadeler ya "lvalue" ya da "rvalue" biçimindedir. C'de nesne belirtilen ifadelere lvaluei nesne belirtmeyen ifadelere rvalue denilmektedir. C++ da 
	C'nin bu lvalue rvalue terimlerini kullanmıştır. Ancak C++11'e gelindiğinde dile bazı yeni özellikler eklenenince bu lvalue ve rvalue terimleri yetersiz kalmıştır.
	Böylece C++11 ile birlikte bu konu "value categories" ismiyle genişletilmiştir. C++11'de C'deki ve C++11 öncesindeki C++'taki "lvalue" yine "lvalue" olarak kalmıştır. 
	Ancak "rvalue" artık "prvalue (pure rvalue)" olarak değiştirilmiştir. C++11'deki bu konuda yapılmış olan asıl yenilik "xvalue (expiring value)" biçiminde yeni 
	bir kategorinin oluşturulmasıdır. Yukarıda da belirttiğimiz gibi bu kategorinin oluşturulmasının nedeni C++11 ile birlikte dile eklenen bazı özelliklerdendir. 
	C++11'le birlikte eklenen "xvalue" kategorisi duruma göre hem bir "lvalue" gibi hem de "rvalue" gibi kulalnılabilen ifadelerdir. Bu durumda C++11'e "glvalue (generilized
	value)" ve "rvalue" biçiminde iki üst kategori de eklenmiştir. glvalue kategorisi lvalue ve xvalue kategorilerinin birleşiminden oluşmaktadır. rvalue kategorisi ise
	prvalue ve xvalue kategorilerinin birleşiminden oluşmaktdır. Bu durum aşağıdaki şekil ile özetlenebilir:
		
		glvalue     rvalue
		glvalue     rvalue
		/  \	   /  \
	   /    \     /    \
	lvalue   xvalue    prvalue

	C++ standartlarında rvlaue denildiğinde artık prvalue ve xvalue anlaşılmaktadır. glvalue denildiğinde ise lvalue ve xvalue anlaşılmaktadır. Eski lvalue terimi 
	lvalue olarak kaldığına göre ve eski rvalue terimi de prvalue haline geldiğine göre o halde xvalue nedir? xvalue terimi yukarıda da belirttiğimiz gibi "hayatını 
	kaybetmek üzere olan" nesneler için kullanılmaktadır. Konunun ayrıntıları başka konularla ilgili olduğu için burada bu ayrıntılara henüz girmeyeceğiz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	18) C++'ta C'de olmayan ismine "referans (reference)" denilen göstericilere benzer adres tutan yeni bir tür de bulunmaktadır. C++11'e kadar C++'ta yalnızca 
	referans kavramı ve terimi vardı. Ancak C++11 ile birlikte "move semantic" denilen bir özelliğin C++'a eklenebilmesi için ismine "sağ tafa değeri referansı (rvalue
	referance)" denilen yeni bir referas türü daha dile eklenmiştir. Artık C++11 ve sonrasında eski referanslar "sol taraf değeri referansı (lavlue reference)" biçiminde
	isimlendirilmektedir. Yani eski referanslara artık "sol taraf değeri referansları" denilmektedir. C++11 ile eklenen referanslar ise "sağ taraf değeri referanlarıdır".

	Biz "referans" dediğimizde hem sol taraf değeri referanslarını hem de sağ taraf değeri referanslarını kastedeceğiz. Ancak bunları ayırmamız gerektiğinde açıkça
	"sol taraf değeri referansı" ya da "sağ taraf değeri referansı" diyeceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sol taraf değeri referansı dekleratörde & atomuyla tanımlanır. Referanslara tanımlama sırasında ilkdeğer verilmesi zorunludur. Bir sol taraf değeri 
	referansı tipik olarak aynı türden nesne belirten bir ifade ile (yani bir bir sol taraf değeri ile) ilkdeğer verilerek tanımlanmaktadır. Örneğin:

	int a{10};
	int &r = a;

	Sol taraf değerine ilişkin referansa ilkdeğer olarak verilen nesneye ilkdeğer verilmiş olması gerekmez. Örneğin:

	int a;
	int &r = a;		// gayet normal

	Bir referans ilkdeğer verilerek tanımlandığında derleyici ilkdeğer olarak verilen nesnenin adresini referansın içerisine yerleştirmektedir. Örneğin:

	double d{3.14};
	double &r = d;

	Burada derleyici d nesnesinin adresini r referansına yerleştirmektedir. Aslında C++ standartlarında referans için bir yer ayrılmayabileceği söylenmiştir. 
	Yani eğer derleyici referansın refere ettiği nesneyi doğrudan kullanbilirse optimizasyon mekanizması ile referans için hiç yer ayırmayabilir. Ancak tipik 
	olarak derleyiciler referans için bir yer ayırırlar ve referanslar da adres tutarlar. 

	Bir referans ilkdeğer verilmeden tanımlanamaz. Örneğin:

	int &r;				// geçersiz! İlkdeğer verme zorunlu

	Yukarıda da belirttiğimiz gibi sol taraf değeri referansına verilen ilkdeğerin referansla aynı türden nesne belirten bir ifade olması gerekir. Çünkü ancak 
	nesne belirten ifadelerin adresleri alınabilir. Örneğin:

	int a = 10;
	int &r = a;			// geçerli ilkdeğer verilmiş, r referansının içerisinde a'nın adresi var.

	Örneğin:

	int &r = 10;		// geeçersiz! Verilen ilkdeğer bir nesne belirtimiyor
	
	long a = 10;
	int &r = a;			// geçersiz verilen ilkdeğer farklı türden

	int a = 10;
	int &r = a;			// geçerli aynı türden bir nesne ile ilkdeğer verilmiş. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Teknik olarak referanslarla göstericiler çok benzerdir. Referanslar "düzeyi yüksek bir gösterici" gibidir. Yani hem referanslar hem de göstericiler adres 
	tutarlar. Ancak referanslara adresler onlara ilkdeğer verilirken yerleştirilmektedir. Oysa göstericilere istenildiği zaman adresler atanabilmektedir. Örneğin:

	int a = 10;
	int &r = a;

	Burada a'nın adresini derleyici elde edip r referansına yerleştirmektedir. Oysa örneğin:

	int a = 10;
	int *pi = &a;

	Göstericilere atama yaparken nesnenin adresini & operatörüyle bizim elde etmemiz gerekir. 

	Bir referans ilkdeğer verildikten sonra kullanıldığında	artık referansın içerisindeki adreste bulunan nesnenin (referansın refere ettiği nesnenin) kullanıldığı
	kabul edilmeketedir. Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Burada aslında r referansının içerisindeki adreste bulunan nesneye 20 yerleştiriliyor. 
	
	Görüldüğü gibi bir referansa tanımlanma sırasında bir adres yerleştirilmekte ve artık referans o nesneyi göstermektedir (refere etmektedir). Bir referans 
	tanımlandıktan sonra artık başka bir nesneyi gösterir hale getirilemez. 

	Referans içeren kodların eşdeğer gösterici karşılıkları konunun daha iyi anlaşılmasına yardımcı olmaktadır. Referans içeren bir kodun eşdeğer gösterici 
	karşılığı demekle referans yerine gösterici kullanılarak oluşturulan kodu kastediyoruz. Mademki referans içerisindeki adres ilkdeğer verildikten sonra bir daha
	değiştirilememektedir bu durumda referanslar "kendisi const olan const göstericilere" benzetilebilir. 
	
	Örneğin:

	int a = 10;
	int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int * const r = &a;

	Görüldüğü gibi bir referansa bir nesne ile ilkdeğer verildliğinde derleyici o nesnenin adresini kendisi referansa yerleştirmektedir. Ancak göstericilere biz 
	nesnenin adresini elde ederek yerleştirmekteyiz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											7. Ders 06/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi bir referans ilkdeğer verildikten sonra kullanıldığında her zaman artık refere ettiği nesnenin kullanıldığı kabul edilir. 
	Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Bu işlemin eşdeğer gösterici eşdeğeri şöyledir:

	int a = 10;
	int * const r = &a;
	*r = 20;

	Tabii C++11 ve sonrasında referanslara da "uniform initializer syntax" ile ilkdeğer verebiliriz. Örneğin:

	int a{10};
	int &r{a};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi bir referans ilkdeğer verilen nesneyi gösterir (refere eder). Artık referansın başka bir nesneyi göstermesi sağlanamaz. 
	(Çünkü referansı tanımladıktan sonra artık ona değer atadığımızda değer referansın kendisine değil onun refere ettiği nesneye atanmış olmaktadır. Halbuki 
	göstericiler eğer const değillerse herhangi bir zaman başka bir nesneyi gösterebilirler. Referanslar C++'a "güvenli gösterici oluşturmak için" sokulmuştur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a{10};
	int &r = a;

	cout << r << endl;

	r = 20;

	cout << a << endl;
			
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir referansın adresi alındığında biz referansın kendi adresini almış olmayız. Zaten referansın adresini almanın bir yolu da yoktur. Biz referansın adresini 
	aldığımızda referansın refere ettiği nesnenin adresini almış oluruz. Örneğin:

	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		// a'nın adresi alınıyor

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int * const r = &a;
	int *pi;

	pi = &*r;		// a'nın adresi alınıyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		

	*pi = 20;

	cout << a << endl;		// 20
	cout << r << endl;		// 20
		
	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Konunun girişinde de belirttiğimiz gibi C++ standartlarında eğer derleyici bunun bir yolunu bulabilirse referans için hiç yer ayırmayabilir. Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Burada derleyici isterse hiç r referansı için bir yer ayırmadan doğrudan 20 değerini a'ya aatayabilir. Yani derleyici burada aşağıdakine eşdeğer bir kod 
	üretebilir:

	int a = 10;
	
	a = 20;

	Tabii derleyicilerin referanslar için bir yer ayırmayacağı durumlarda aslında referans kullanmanın gerekliliği yoktur. (inline fonksiyonlarda da derleyici buna 
	benzer optimizasyonlar yaoabilmektedir.) Dolayısıyla biz örneklerimizde referans için bir yer ayrıldığını varsayarak konuları ele alacağız.  
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir referans tanımlanabilir. const referanslar gösterdiği yer const olan const göstsericiler gibidir. Yani const bir referansın refere ettiği nesnenin
	değerini değiştiremeyiz. (Referansın kendi içerisindeki adresin referans tanımlandıktan sonra değiştirilemeyeceğini anımsayınız.) Örneğin:

	int a = 10;
	const int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	const int * const pi = &a;

	const bir referans ile o referansın refere ettiği nesneyi değiştiremeyiz. Örneğin:

	int a = 10;
	const int &r = a;

	r = 20;		// geçersiz! referans const
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'de (ve tabii C++'ta da) const bir nesnenin adresi gösterdiği yer const olmayan bir göstericiye atanamaz. Benzer durum C++'taki sol taraf 
	değeri referansları için de söz konusudur. Bir sol taraf değeri referansına aynı türden const bir nesneyi bind edemeyiz. Örneğin:

	const int a{10};
	int &r = a;				// geçersiz! 

	Buradaki sorun programcının nesneyi const yaptığı halde onun referns tarafından değiştirilmesine olanak tanımasıdır. const bir nesne ancak const bir sol taraf 
	değeri referansına bind edilebilir. Örneğin:

	const int a{10};
	const int &r = a;		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İlkdeğer verme (initialization) bir nesne yaratılır yaratılmaz ona değer yerleştirme işlemine denilmektedir. C'de ve C++'ta (ve diğer bazı dillerde) ilkdeğer 
	verme işlemi anlamına gelen üç temel durum vardır:

	1) Tanımlama sırasında '=' ile ya da "Uniform İnitilizer Syntax" ile ilkdeğer verme. Örneğin:

	int a = 10;
	int b{10};

	2) Anımsanacağı gibi fonksiyonların parametre değişkenleri fonksiyon çağrıldığında yaratılmakta ve fonksiyon sonlandığında yok edilmektedir. İşte parametreli 
	bir fonksiyonun çağrılması aslında parametre değişkenlerine argümanlarla ilkdeğer verme anlamına gelmektedir. Örneğin:

	void foo(int a)		// int a = 10 gibi düşünülmeli
	{
		// ....
	}

	foo(10);

	Burada aslında a parametre değişkenine 10 ile ilkdeğer verilmiştir.

	3) return işlemi sırasında bir geçici nesne yaratılıp return ifadesi o geçici nesneye ilkdeğer olarak verilmektedir. Yani return işlemi de aslında bir ilkdeğer
	verme işlemidir. Örneğin:
		

	int foo()
	{
		// ...

		return ifade;
	}
	
	//...
	
	x = foo() * 2;

	Aslında burada şu işlemler arka planda yapılmakatadır:

	1) int temp = return ifadesi;

	2) x = temp * 2;

	3) temp yok yok ediliyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonların parametre değişkenleri sol taraf referansı olabilir. Böyle fonksiyonlar referansla aynı türden bir sol taraf değeri ile (yani nesne
	belirten ifadeyle) çağrılmalıdır. Bu çağırma sırasında derleyici argümanda belirtilen nesnenin adresini alarak referansa yerleştirir. Artık fonksiyonda
	referansı kullandığımızda argümanda belirtilen nesneye erişmiş oluruz. Böylece "call by reference" işlemi C++'ta referanslarla da sağlanmış olmaktadır. Örneğin:

	void foo(int &r)
	{
		r = 20;
	}
	
	//...
	
	int a = 10;
	foo(a);

	Burada aslında fonksiyon çağrıldığında r referansına a'nın adresi yerleştirilmektedir. Fonksiyonda r'yi kullandığımızda aslında r'nin refere ettiği nesne 
	olan a'yı kullanmış oluruz. BYukarıdkai kodun eşdeğer gösterici karşılığı şöyle olacaktır:

	void foo(int * const r)
	{
		*r = 20;
	}

	//...

	int a = 10;
	foo(&a);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r);

int main(void)
{
	int a = 10;

	foo(a);

	cout << a << endl;			// 20
			
	return 0;
}

void foo(int &r)			// int &r = a
{
	cout << r << endl;			// 10

	r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin göstericilerle oluşturulmuş eşdeğer gösterici karşılığı aşağıdaki gibidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int * const r);

int main(void)
{
	int a = 10;

	foo(&a);
	cout << a << endl;
			
	return 0;
}

void foo(int * const r)		// int * const r = &a
{
	cout << *r << endl;
	*r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İki int nesne içerisindeki değerleri yer değiştiren swap isimli fonksiyonu C'de göstericileri kullanarak yazmıştık. C++'ta aynı fonksiyonu referansları 
	kullanarak da yazabiliriz. Örneğin:

	void swap(int &a, int &b)
	{
		int temp = a;
		a = b;
		b = temp;
	}

	//...

	int x = 10, y = 20;

	swap(x, y);
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int x = 10, y = 20;

    cout << "x = " << x << ", y = " << y << endl;

    swap(x, y);

    cout << "x = " << x << ", y = " << y << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta sol taraf değeri referanslarının göstericilerden en önemli farkı şudur: Bir sol taraf değeri referansına aynı türden bir nesne ile ilkdeğer verdiğimizde 
	artık derleyici o nesnenin adresini referansa yerleştirir. Böylece referans o nesnesyi gösterir hale gelir. O referansın başka bir nesneyi göstermesi mümkün 
	değildir. Halbuki göstericilere farklı nesnelerin adreslerini atayarak onların farklı nesneleri göstermesini sağlayabiliriz. Böylece refeanslar daha güvenli 
	bir gösterici olarak kullanılabilmektedir. 

	Bir referansın * ya da [...] operatörleriyle kullanılamayacağına dikkat ediniz. p bir gösterici olmak üzere biz p göstericisinin gösterdiği yerden n ileriye
	p[n] ifadesi ile erişebiliriz. Ancak r bir referans ise böyle bir kullanım geçerli değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta C'de olduğu gibi göstericiyi gösteren gösterici (pointer to pointer) söz konusu olabilir. Ancak referansı refere eden referans olamaz. Tabii bunun 
	olamamasının en açık nedeni aslında referansın kendi adresinin alınamamasıdır. Örneğin:

	int a = 10;
	int &r = a;
	int &k = r;

	Burada biz k referansına r referansının adresini yerleştirmiş olmamaktayız. a nesnesinin adresini yerleştirmiş olmaktayız. Çünkü bir referans ilkdeğer 
	verildikten sonra kullanıldığında artık refere ettiği nesne anlamına gelmektedir. Yukarıdaki kodun eşdeğer gösterici karşılıği şöyledir:

	int a = 10;
	int * const r = &a;
	int * const k = &*r;

	C++'a C++11 ile birlikte eklenen "sağ taraf değeri referansları (rvalue reference)" C++'a yeni başlayan C programcıları tarafından sanki "referansın referansı"
	sanılmaktadır. Oysa sağ taraf değeri referansının bununla hiçbir ilgisi yoktur. Örneğin:

	int &&r = 10;		// bu tamamen başka bir anlama gelmektedir. 

	Bu bildirim tamamen başka bir anlama gelmektedir. İzleyen paragraflarda sağ taraf değeri referansları ele alınacaktır. 

	C++'ta referans dizileri diye de bir kavram yoktur. Örneğin:

	int &r[3] = {a, b, c};		// böyle bir kavram yok! dolayısıyla derleme zamanında error oluşacaktır.

	Ancak tabii göstericileri refere eden referanslar oluşturulabilir. Örneğin:

	int *pi;
	int *&r = pi;

	Burada r referansı int * türünden bir referanstır. Yani bir r referansını kullandığınımızda aslında pi göstericisini kullanmış oluruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int a{10};
    int *pi{&a};

    int *&r = pi;       // geçerli

    cout << *r << endl;     // 10

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'de yapıları genel olarak adres yoluyla fonksiyonlara aktarıyorduk. Bu durumda fonksiyonun parametre değişkeni bir gösteri oluyordu. 
	Biz de fonksiyonu aynı türden bir yapı nesnesinin adresiyle çağırıyorduk. Fonksiyon içerisinde yapı elemanlarına bu gösterici yoluyla -> operatörünü 
	kullnarak erişiyorduk. İşte C++'ta bir yapıyı referans yoluyla da fonksiyona aktaranbiliriz. Bu durumda yapının elemanlarına referans yoluyla erişirken 
	ok operatörü değil nokta operatörü	kullanılmaktadır. Örneğin:

	struct DATE {
		int day;
		int month;
		int year;
	};
	//...

	void disp_date(const struct DATE &r)
	{
		cout << r.day << '/' << r.month << '/' << r.year << endl;
	}
	//...

	struct Date date = {6, 9, 2023};

	disp_date(date);

	Bir referansı ilkdeğer verdikten sonra kullandığımızda artık referansın refere ettiği nesneyi kullanmış olmaktayız. Yani biz bu örnekte disp_date içerisinde 
	r referansını kullandığımızda aslında bütünsel olarak date nesnesini kullanmış gibi oluruz. Bir yapı nesnenin bütünü kullnarak elemanlarına erişmek için 
	nokta operatörünün kullanıldığına dikkat ediniz. 

	Bir yapı nesnesinin C++'ta fonksiyona gösterici yoluyla aktarılmasıyla referans yoluyla aktarılması arasında hiçbir etkinlik farklılık yoktur. İkisi de aynı 
	derecede etkindir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const DATE &r)
{
	cout << r.day << '/' << r.month << '/' << r.year << endl;
}

int main()
{
	struct DATE d = { 10, 12, 2001 };

	disp_date(d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşdeğer gösterici kaşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const struct DATE * const r)
{
	cout << (*r).day << '/' << (*r).month << '/' << (*r).year << endl;
}

int main()
{
	struct DATE d = {10, 12, 2001};

	disp_date(&d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun geri dönüş değeri bir sol taraf değeri türünden referans olabilir. Bu durumda return ifadesinin aynı türden bir nesne belirten bir ifade olması gerekir. 
	Biz böyle fonksiyonları çağırdığımızda elde ettiğimiz ifade return ifadesindeki nesne haline gelmektedir. Örneğin:

	int g_a = 10;

	int &foo()		// int &temp =g_ a
	{
		return g_a;
	}
	//...

	foo() = 20;		// temp = 20

	Burada aartık fonksiyon çağrısı bir sol taraf değeri belirtmektedir. Görüldüğü gibi C'de fonksiyon çağrıları her zaman sağ taraf değeri belirtir. AncakC++'ta
	fonksiyonun geri dönüş değeri sol taraf değeri referansı ise artık fonksiyon çağrısı sol taraf değeri belirtir. Fonksiyon çağrısına bir değer atadığımızda aslında biz
	return ifadesindeki nesneye değer atamış oluruz. Tabii nasıl bir fonksiyon yerel bir nesnenin adresi ile geri dönmemeli ise benzer biçimde aynı durum referanslar
	için de geçerlidir. Yani fonksiyonun geri dönüş değeri bir referans ise biz return ifadesinde yerel bir nense kullanmamalıyız (fonksiyon bittiğinde yerel nesnelerin 
	stack'ten boşaltıldığını anımsayınız.) Örneğin:

	int &foo()
	{
		int x = 10;

		return x;				// geçerli ama tanımsız davranış oluşturur
	}
	//...

	foo() = 20;					// dikkat! değer artık olmayan bir nesneye atanmaya çalışılıyor
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int g_a = 10;

int &foo()			
{
	//...

	return g_a;		// int &temp = g_a
}

int main()
{
	foo() = 20;

	cout << g_a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşedeğer gösterici karşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int g_a = 10;

int *foo()			
{
	//...

	return &g_a;		
}

int main()
{
	*foo() = 20;

	cout << g_a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta "geçici nesne (temporary object)" denildiğinde "derleyicinin kendisi tarafından yaratılan ve yok edilen isimsiz nesneler" anlaşılmaktadır. Örneğin 
	fonksiyonun geri dönüş değerinin oluşturulması bir geçici nesne yolyla yapılmaktadır. İşte C++'ta bazı durumlarda derleyici geçici nesneler yaratılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir sol taraf değeri referansını biz bir sağ taraf değeri ile ilkdeğer vererek tanımlayabiliriz. Bu durumda referansın const olması gerektiğine dikkat ediniz. Örneğin:

	int &r = 10;			// geçersiz! referans const değil
	const int &k = 10;		// geçerli, referans const

	Tabii bu durumda ilkdeğer olarak verilen sağ taraf değerinin referansla aynı türden olması da gerekmez. Örneğin:

	const int &r = 3.14;		// geçerli

	const bir referansa sağ taraf değeri bind edildiğinde derleyici önce referans türüyle aynı türden geçici bir nesne yaratır. Sonra sağ taraf değerini bu geçici nesneye
	yerleştirir. Sonra da bu geçici nesnenin adresini referansa yerleştirir. Örneğin:

	const int &r = 10;

	Burada aslında şu işlemler yapılmaktadır:

	int temp = 10;
	const int &r = temp;

	Burada geçici nesnenin referans türünden olduğuna dikkat ediniz. Örneğin:

	const int &r = 3.14;

	Bu kodun eşdeğeri de şöyledir:

	int temp = 3.14;		// dikkat bilgi kaybı oluşacak ama geçerli
	const int &r = temp;

	Burada artık r referansının gösterdiği int nesnede 3.14 değeri değil 3 değeri olacaktır. 

	Bu örneklerde r referansının artık derleyici tarafından yaratılmış geçici nesneleri gösterdiğine dikkat ediniz. Referans const olduğu için o nesneler üzerinde 
	değişklik yapamayacağız.

	C++ standartlarına göre bu biçimde yaratılmış olan geçici nesneler referansın ömrü boyunca yaşamaya devam eder. Referans yaşamını kaybederken bu geçici nesne 
	de derleyici tarafından yok edilecektir. Bu geçici nesnenin yok edilmesi ile programcının uğraşmadığına dikkat ediniz. 

	Bu biçimde const bir sol taraf değeri referansına sağ taraf değeri ile ilkdeğer verilirken eğer Uniform İnitializer Syntax kullanılıyorsa ya da küme parantezi 
	sentaksı kullanılıyorsa bu durumda daraltıcı dönüştürmelere izin verilmemektedir. Örneğin:

	const int &r {3.14};		// geçersiz! double -> int dönüştürmesi daraltıcı bir dönüştürme
	const int &k = {3.14};		// C++11'den sonra geçersiz! double -> int dönüştürmesi daraltıcı bir dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	const int &r = 10;

	cout << r << endl;		// geçici nesne kullanılıyor		

	r = 20;					// error! Referans const

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sol taraf değeri referansına bir sol taraf değeri ile ilkdeğer verildiğinde derleyicinin tipik olarak bu ilkdeğer olarak verilen nesnenin adresini 
	referansa yerleştirdiğini söylemiştik. Bu durumda bir sol taraf değeri referansına bir dizi ile ilkdeğer verdiğimizde derleyici dizinin adresini referansa 
	,yerleştiecektir. Anımsanacağı gibi C'de bir dizinin adresi alınırsa bu adres "dizi göstericisi (pointer to array)" bir göstericiye yerleştirilebilir. İşte 
	buradan hareketle C++'ta eğer biz sol taraf değeri referansına bir diziyi bind edersek referansın da "dizi referansı (reference to array)" olması gerekmektedir. 
	Örneğin:

	int a[10];
	int &r = a;					// geçersiz!
	int (&r)[10] = a;			// geçerli

	Burada artık r referansını kullandığımızda tamamen a dizisini kullanmış gibi olmaktayız. Yukarıdaki işlemin eşdeğer gösterici karşılığı şöyledir:

	int a[10];
	int (*r)[10] = &a;

	Konunun daha iyi anlaşılması için C'de "dizi göstericileri (pointer to array)" kavramının biliniyor olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														8. Ders 11/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bir sol taraf değeri referansını farklı türden bir nesneyle ilkdeğer vererek tanımlayamayız. Örneğin:

	double a = 10.2;
	int &r = &a;		// geçersiz!

	Ancak sol taraf değeri referansı const ise bu mümkündür. Bu durumda yine derleyici ilkdeğer olarak verilen nesneyi referansla aynı türden bir geçici nesnenin 
	içine yerleştirir, bu geçici nesneyi referansa bind eder. Örneğin:

	double a = 10.2;
	const int &r = a;

	Bu işlemin eşdeğeri şöyledir:

	double a = 10.2;
	int temp = a;
	const int &r = temp;

	Tabii eğer ilkdeğer verme yine "uniform initializer" sektasıyla ya da küme parantezi sentaksıyla yapılıyorsa bilgi kaybına yol açabilen daraltıcı dönüştürmelere 
	izin verilmemektedir. Örneğin:

	double a = 10.4;
	const int &r{a};		// geçersiz!
	cont int &k = {a};		// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ve sonrasında dil hepten karmaşık hale geldiği için daha önce kullanılmayan bazı terimler de uydurulmuştur. Örneğin bir prvalue ifadesinin bu tür 
	durumlarda bir geçici nesneye dönüştürülmesine "temporary materializaition" denilmektedir. 

	Biz kursumuzda yukarıda "sol taraf değeri (lvalue)" ve "sağ taraf değeri (rvalue)" terimlerini C++11 ve sonrasındaki "value category" tanımına göre kullanıyoruz.
	Örneğin "const bir referansa bir sağ değeri ile ilkdeğer verilebilir" derken bu sağ taraf değeri "prvalue" ya da "xvalue" anlamına gelmektedir. Ancak "bir sol 
	değeri referansına bir aynı türden bir sol taraf değeri ile ilk değer verilebilir" derken buradaki "sol taraf değeri" gvalue olmayan sol taraf değeri anlamına 
	gelmektedir. C++11 ile birlikte eklenen "value category" terimlerini aşağıda yeniden vermek istiyoruz:

	   glvalue     rvalue
		/  \	   /  \
	   /    \     /    \
	lvalue   xvalue    prvalue
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi C++11 ile birlikte ismine "sağ taraf değeri referansları (rvalue references)" denilen başka bir referans türü daha dile eklenmiştir. 
	Böylece eski referansların da isimleri "sol taraf değeri referansları (lavlue references)" biçiminde değiştirilmiştir. Sağ taraf değeri referansları dekleratörde 
	&& atomlarıyle belirtilir. (Burada && atomları referansın referansı gibi bir anlama gelmemektedir. Zaten refereransın adresi alınamamaktadır.)

	Bir sağ taraf değeri referansı bir sağ taraf değeri ile (yani nesne belirtmeyen bir ifade ile) ilkdeğer verilerek tanımlanır. Biz nasıl bir (const olmayan) sol 
	taraf değeri referansına bir sağ taraf değerine ilişkin ifadeyi bind edemiyorsak bir sağ taraf değeri referansına da bir sol taraf değerine ilişkin ifadeyi 
	bind edemeyiz. Örneğin:
	
	Örneğin:

	int a = 10;
	int &&r = a;		// geçersiz! a bir sağ taraf değeri değil
	int &&r = 10;		// geçerli, a bir sağ taraf değeri

	Örneğin:
	
	int a = 10, b = 20;
	int &&r = a + b;			// geçerli, a + b sağ taraf değeri belirtiyor

	Tabii normak olan durum bir sağ taraf değeri referansına aynı türden bir sağ taraf değeri ile ilkdeğer vermektir. Ancak bir sağ taraf değeri referansı 
	farklı bir sağ taraf değeri türü ile de ilkdeğer verilerek tanımlanabilir. Örneğin:

	int &&r = 3.14;			// tuhaf ama geçerli
	long a = 10, b = 20;
	int &&k = a + b;		a+ b long türden ama geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sağ taraf değeri referansına bir sağ taraf değeri ile ilkdeğer verdiğimizde derleyici o sağ taraf değerini referansla aynı türden bir geçici nesnenin
	içerisine yerleştirir ve referansa o geçici nesnenin adresini atar. Örneğin:

	int &&r = 10;

	Bu işlemin eşdeğeri şöyledir:

	int temp = 10;
	int &&r = temp'in adresi

	Pekiyi aynı işlemi zaten const olan sol taraf değeri referansı ile de yapabiliyorduk. O halde değişen ne var? Buradaki tek fark sağ taraf değeri referansının 
	const olmaması ve dolayısıyla o geçici nesneyi değiştirebilmesidir. Bu biçimde bir prvalue ifadesi için geçici nesne yaratılmasına C++17'de "temporary materialization"
	dendiğini anımsayınız.

	Yine bir sağ taraf değeri referansını kullandığımızda referansın refere ettiği nesneyi kullanmış oluruz. Yani kullanım bakımından sağ taraf değeri referansının 
	sol taraf değeri referansından bir farkı yoktur. Örneğin:

	int &&r = 10;

	r = 20;						// geçerli, geçici nesne değiştiriliyor

	const int &k = 10;

	k = 20;						// geçersiz! referans const

	Sağ taraf değeri referansları kullanıldıklarında artık sol taraf değeri belirtirler. Örneğin:

	int &&r = 10;
	int &k = r;			// geçerli
	int &&m = r;		// geçersiz!
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int &&r = 10;
	
	cout << r << endl;		// 10

	r = 20;					// geçerli

	cout << r << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sağ taraf değeri referansına biz farklı türden bir sol taraf değeri ile de ilkdeğer verebiliriz. Bu durumda yine farklı türden sol taraf değeri referans 
	ile aynı türden derleyici tarafındna yaratılan geçici nesneye yerleştirilir ve geçici nesnenin adresi referansa atanır. Örneğin:

	double d = 3.14;
	int &&r = d;			// geçerli!

	Bu işlemin eşdeğeri şöyledir:

	double d = 3.14;
	int temp = d;
	int &&r = temp'in adresi

	Tabii burada biz referansa yoluyla referansın refere ettiği yeri deştirdiğimizde d'yi değiştirmiş olmayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	double d = 3.14;
	int &&r = d;

	cout << r << endl;		// 3

	r = 10;

	cout << d << endl;		// 3.14
	cout << r << endl;		// 10

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi sağ taraf değeri referansı da const olabilir mi? Tabii sağ taraf değeri referansları da const olabilir. Ancak sağ taraf değeri referanslarının dile
	eklenmesinin asıl nedeni zaten sağ taraf değerini güncelleyebilmesidir. Yani const bir sağ taraf değeri referansının anlamlı bir kullanımı yoktur. const bir 
	sağ taraf değeri referası zaten const bir sol taraf değeri referansıyla benzer işleve sahiptir. Özetle sağ taraf değeri referansları const olabilse de bunun 
	aslında anlamı yoktur. Örneğin:

	const int &&r = 10;		// geçerli

	r = 20;					// geçersiz! r const
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yine eğer sağ taraf değeri referansına ilkdeğer verme işlemi Uniform Initializer Syntax ile ya d aküme parantezleri kullanılarak yapılıyorsa daraltıcı 
	dönüştürmelere izin verilmemektedir. Örneğin:

	int &&r{3.14};			// geçersiz! double -> int dönüştürmesi daraltıcı dönüştürme
	int &&k = {3.14};		// geçersiz! geçersiz! double -> int dönüştürmesi daraltıcı dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun parametre değişkeni sağ taraf değeri referansı olabilir. Bu durumda fonksiyon bir sağ taraf değeri argüman yapılarak ya da farklı türden 
	sol taraf değeri ile çağrılmak zorundadır. Örneğin:

	void foo(int &&r)
	{
		cout << r << endl;
	}

	//...

	int a = 10, b = 20;

	foo(10);			// geçerli
	foo(a + b);			// geçerli

	foo(a);				// geçersiz!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &&r)
{
	cout << r << endl;
}

int main(void)
{
	int a = 10, b = 20;

	foo(10);			// geçerli
	foo(a + b);			// geçerli

	foo(a);				// geçersiz!
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun geri dönüş değeri sağ taraf taraf değeri referansı olabilir. Böyle fonksiyonlar çağrıldığında "xvalue" belirtirler. Bu konu ileride 
	ele alınacaktır. Ancak bu tür durumlarda yaratılacak geçici nesne fonksiyonun yerel değişkeni biçiminde yaratılır. Dolayısıyla aşağıdaki gibi 
	bir tanımlama "tanımsız davranışa (undefined behavior)" yol açmaktadır:

	int &&foo()
	{
		return 10;		// dikkat temporary yerel bir nesne olarak yaratılacak
	}

	Bu tanımlamanın eşdeğeri şöyledir:

	int &&foo()
	{
		int temp = 10;

		return temp'in adresi;
	}

	Görüldüğü gibi fonksiyondan çıkıldığında bu geçici nesne yok edilecektir. Böyleci geçici nesnelerin fonksiyon içerisinde onun stack'inde yaratıldığına
	dikkat ediniz. 

	Yukarıda da belirttiğimiz gibi geri dönüş değeri sağ taraf değeri referansı olan fonksionların çağrı ifadeleri "xvalue" belirtmektedir. "xvalue" bir "glavlue"
	olmasına karşın "lvalue" değildir. Dolayısıyla bir "xvalue" sol atarf değeri referansına bind edilemez. Örneğin:
	
	int &r = foo();		// geçersiz! xvalue bir lvalue değildir. 

	Ancak "xvalue" bir "rvalue" olduğuna göre sağ taraf değeri referansına bind edilebilir. Örneğin:

	int &&r = foo();		// geçerli

	Pekiyi bu durumda fonksiyonun geri dönüş değerinin sağ taraf değeri referansı olmasının ne anlamı vardır? İşte aslında ilerideki konularda da görüleceği gibi 
	bir sol tafa değeri "sanki bir sağ taraf değeri imiş gibi" geri döndürülmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int &&foo()
{
	return 10;		// geçerli ama tanımsız davranışa yol açar
}

int main(void)
{
	const int &r = foo();

	cout << r << endl;		// tanımsız davranış!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri sağ taraf değeri referansı olan fonksiyonların return ifadelerindeki sağ taraf değeri için yaratılacak yerel değişkeninin o fonksiyonun  
	yerel değişkeni gibi olması böyle bir fonksiyonun anlamsız olduğunu akla getirmektedir. Ancak aslında bu tür fonksiyonlar belli bir amaç doğrultusunda 
	kullanılabilmektedir. Bu tür fonks,yonların kullanımına ilşkin anlamlı örneklerle ilerideki konularda karşılaşacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	19) C++'ta dinamik bellek yönetimi için new ve delete isimli iki operatör eklenmiştir. Tabii C++ C'nin standrat kütüphanesini de kapsadığı için biz C++'ta
	C'de kullandığımız malloc, calloc, realloc ve free fonksiyonlarını da kullanbiliriz. Ancak C++'ta dinamik bellek tahsisatı için C++'a özgü new ve delete
	operatörlerinin kullanılması iyi bir tekniktir. 
	
	new operatörü iki biçimde kullanılabilir:

	1) new <tür>
	2) new <tür><[uzunluk ifadesi]>

	Birinci biçimde heap'te ilgili türden tek bir elemanlık yer tahsis edilir. İkinci biçimde ilgili türden belirtilen uzunlukta yer tahsis edilir. new
	operatörü tahsis edilen alanın başlangı adresini ilgi türden bize verir. Örneğin:

	int *pi;
	char *pc;

	pi = new int;
	pc = new char[10];

	Burada birinci satırda heap'te bir int uzunluğunda bir alan tahsis edilip onun başlangıç adresi pi göstericisine atanmıştır. İkinci satırda ise heap'te char 
	türden 10 elemanlı bir dizi tahsis edilmiş dizinin başlangıç adresi pc göstericisine atanmıştır. 

	new operatörü ilgili tür türünden bir adres vermektedir. (malloc, calloc ve realloc fonksiyonlarının void adres verdiğini anımsayınız.) Örneğin:

	int *pi;

	pi = new char[10];		// geçersiz! char türden adres int türden göstericiye atanmış!
	
	new operatörü ile tahsis etmiş olduğumuz alan içerisinde çöp değerler vardır. new operatörü normal kullanımda başarıszlık durumunda "bad_alloc" isimli bir 
	exception fırlatmaktadır. Dolayısıyla programcı tahsisatın başarıını NULL gösteri ile kontrol etmez. Böyle bir kontrol yapmayınız. 

	Exception sözcüğü programın çalışma zamanı sırasında oluşan problemli durumları anlatmaktadır. C++'ta bir exception oluştuğunda programcı oluşan excception'ı 
	ele alabilir (handle edebilir) bu durumda çalışma normal bir biçimde başka yerden devam eder. Ancak programcı oluşan exception'ı ele almazsa program çökmektedir. 
	C++'ta exception ayrıntıları olan geniş bir konudur. Biz de ilerideki bçlümlerde bu konuyu ayrı başlık altında ele alacağız. 

	new her ne kadar bir operatörse de aslında tahsisat işlemi yine programın akışı new yapılan yere geldiğinde çalışma azamanı yapılmaktadır. new operatörü 
	"operator new" denilen bir tahsisat fonksiyonunu çağırarak athsisatını yapmaktadır. new operatörünün bir operatör olmasının nedeni sınıflar konusuyla ilgilidir. 
	new operatörüyle bir sınıf türünden tahsisat yapıldığında new operatörü tahsisat yapıldıktan sonra sınıfın "yapısı fonksiyonunun (constructor)" çağrılmasına da
	yol açmaktadır. 

	T bir tür belirtmek üzere new operatörü ile bir elemanlık yer tahsisatını iki biçimde yapabiliriz:

	new T
	new T[1]

	Bu iki new ifadesi de bir elemanlık yer tahsis ediyor olsa da bu iki ifadenin arasında semantik bazı farklılıklar vardır. izleyen paragraflarda bu durum ele 
	alınacaktır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int *pi;

	pi = new int[10];

	for (int i = 0; i < 10; ++i)
		pi[i] = i * i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << ' ';
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														9. Ders 13/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ile yapılan dinamik tahsisatlar delete operatörü ile serbest bırakılır. delete operatörünün de iki sentaktik biçimi vardır:

	1) delete <adres>
	2) delete [] <adres>

	Eğer new ile köşeli parantezsiz tahsisat yapılmışsa bunun boşaltımı köşeli parantezsiz delete yapılmalıdır. Eğer new ile köşeli parantezli bir tahsisat 
	yapılmışsa bunun bhoşaltımı da köşeli parantezli delete ile yapılamlıdır.  Örneğin:

	int *pi;
	char *pc;
	//...

	pi = new int;
	pc = new char[32];

	//...

	delete[] pc;
	delete pi;
	
	Tahisa edilen 1 elemanlık bile olsa eğer tahsisat new operatörünün köşeli parantezli biçimi ile yapılmışsa alanı serbest bırakmak için delete operatörünün 
	yine köşeki panatezli biçimi ile yapılmalıdır. Örneğin:

	int *pi = new int[1];
	//...
	delete[] pi;

	new operatörü ile tahsis edilen alan delete operatörü ile boşaltılmazsa Windows, macOS, Linux gibi yaygın işletim sistemlerinin hepsinde program bittiğinde 
	bu alanlar otomatik olarak boşaltılmaktadır. Çünkü işletim sistemlerinde genel oalrak "heap alanı prosese özgüdür". Yani her prosesin heap alanı diğerlerinden 
	farklıdır. Yani bir programda yapılan dinamik tahsisatın diğer çalışmakta olan programlara hiçbir etkisi yoktur. Ancak heap alanının prosese özgü olduğu 
	C ve C++ standartlarında garanti edilmemiştir. (Yani başka işletim sistemlerinde heap alanı prosese özgü olmayabilit.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int *pi;

	pi = new int[1];

	delete [] pi;			// doğru

	pi = new int[10];

	delete[] pi;			// doğru

	pi = new int;			
	delete pi;				// doğru

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii tıpkı malloc fonksiyonunda olduğu gibi new operatörü ile tahsisat yapılırken de uzunluğun sabit ifadesi ile belirtilmesi gerekmez. Örneğin:

	char *pc;
	int size;
	//...

	cin >> size;
	pc = new char[size];
	//...
	delete[] pc;
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte new ile tahsis edilen alana küme paramtezleriyle ilkdeğer verilebilmektedir. Örneğin:

	pi = new int[3] {10, 20,30};

	Tabii tahsis edilen dizideki az sayıda elemana bu biçimde ilkdeğer verilebilir. Bu durumda geri kalan elemanların hepsi sıfırlanmaktadır. Örneğin:

	pi = new int[10] {1};		// geri kalanelemanlar 0

	Küme parantezinin içi boş da bırakılabilir. Bu durumda da tüm elemanlar sıfırlanır. Örneğin:

	pi = new int[10] {};	// tüme elemanlar sıfırlanır

	İlkdeğer verilirken köşeli parantezlerin içi boş bırakılabilir. Bu durumda derleyici verilen ilkdeğerleri sayar ve dinamik dizinin o kadar elemandan 
	oluştuğnu kabul eder. Örneğin:

	pi = new int[] {10, 30, 40};		// 3 elemanlık tahsisat yapılıyor

	İlkdeğer verme sentaksında köşeli parantezlerin içerisinin sabit ifadesi olması gerekmemektedir. (Bazı dillerde benzer sentakslarda sabit ifadesi zorunluğu
	vardır.) Ancak bu durumda tahsisat uzunluğundan fazla ilkdeğer verilirse "tanımsız davranış" oluşmaktadır. Örneğin:

	int size;
	
	cout << "size:";
	cin >> size;

	int *pi = new int[size] {1, 2, 3, 4, 5};

	Burada size değeri 5'ten küçükse tanımsız davranış oluşacaktır. size değeri 5'ten büyükse tahsis edilen alandaki diğer değerler sıfırlanacaktır.

	Tabii C++11 ve sonrasında bütün küme parantezi sentakslarında "daraltıcı dönüştüre (narrowing conversion)" yasaklanmıştır. Örneğin:

	int *pi = new int[] = {1, 2, 3.14};		// geçersiz! double -> int dönüştürmesi daaraltıcı dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int *pi;

	pi = new int[3]{ 10, 20, 30 };		// C++11 ile birlikte

	for (int i = 0; i < 3; ++i)
		cout << pi[i] << endl;

	delete [] pi;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new operatörü ile biz bir gösterici dizisi de tahsis edebiliriz. Tabii bu durumda tahsis edilen gösterici dizisinin adresinin göstericiyi gösteren göstericye 
	atanması gerekir. Örneğin:

	int a = 10, b = 20, c = 30;
	int **ppi;

	ppi = new int *[] {&a, &b, &c};
	//...
	delete[] ppi;

	Burada tahsisatın new int * biçiminde yapıldığına dikkat ediniz. Tabii boşaltım yine delete operatörünün köşeli parantezli versiyonu ile yapılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const char **names;

	names = new const char *[] {"ali", "veli", "selami", NULL};

	for (int i = 0; names[i] != NULL; ++i)
		cout << names[i] << endl;

	delete[] names;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new operatörü ile çok boyutlu diziler için tahsisatlar yapabiliriz. Ancak çok boyutlu dizilerin başlangıç adreslerinin yerleştirileceği göstericilerin 
	dizi göstericileri türünden olması gerekir. Örneğin:

	int *pi;

	pi = new int[3][4];		// geçersiz! tür uyuşmazlığı var!

	new int[3][4] bir tahsisatın adresinin atanacağı göstericisinin int (*)[4] türünden olması gerekmektedir. Örneğin:

	
	int (*pa)[4];
	pa = new int[3][4];		// geçerli
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int (*pa)[4];

	pa = new int[3][4]{{1, 2, 3, 4}, {5, 6, 7, 8}, {0, 1, 2, 3}};

	for (int i = 0; i < 3; ++i) {
		for (int k = 0; k < 4; ++k)
			cout << pa[i][k] << " ";
		cout << endl;
	}

	delete[] pa;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ C'nin standart kütüphanesini de desteklediğine göre biz C++ programları içerisinde C'nin malloc, calloc, realloc ve free fonksiyonlarını kullanabiliriz. 
	Ancak bir C++ programı içerisinde hem "new ve delete" hem de "malloc, calloc, realloc ve free" fonksiyonları birlikte kullanılmamalıdır. Tahsisat işlemleri 
	için tahsisat algoritmaları kullanılmaktadır. İşte C++'ın new ve delete operatörlerinin kullandığı tahsisat algaoritması ile C'nin dinamik bellek fonksiyonlarının 
	kullandığı tahsisat algoritması farklı olabilmektedir. Bunun sonucu olarak da C++'ın new operatörü ile tahsis edilmiş olan bir alan C'nin tahsisat 
	fonksiyonları tarafından tahsis edilmemiş olarak gözükebilmektedir. Tabii tersi de söz konusu olabilmektedir. Bazı C++ derleyicilerinde new işlemi sıreasında
	çağrılan operator new fonksiyonu kendi içerisinde malloc fonksiyonu ile tahsisatı yapıyor olabilir. Benzer biçimde delete işlemi ile tahsis edilen alan serbest 
	bırakılırken operator delete fonksiyonu free fonksiyonu ile bunu yapıyor olabilir. Bu sistemlerde vu iki dilin tahsisat mekanizmasının birlikte kullanılması 
	soruna yol açmayabilir. Ancak C++ standartları bunun garantisi vermemiştir. Bu nedenle aynı programda bu iki grup tahsisat sistemini birlikte kullanmak 
	sorunlara yol açabilmektedir. 
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new ve delete operatörlerine ilişkin bazı ayrıntılar vardır. Örneğin bu operatörlerin "placement" versiyonları bulunmaktadır. Biz bu placement versiyonlar 
	sayesinde örneğin new operatörünün bellek tahsisatı yapılamadığı durumda bad_alloc ile exception fırlatmak yerine NULL adres ile geri dönmesini sağlayabiliriz. 
	Bu operatörlerin "placement" versiyonları "operatör fonksiyonları" konusunda ele alınacaktır.
------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	20) C++'ta C'nin tüm standart fonksiyonları kullanılabilir. Ancak bu konuda birkaç ayrıntı vardır. Birincisi C++'ta C'nin başlık dosyalarının ismi değiştirilmiştir. 
	C'nin standart bir başlık dosyası <x.h> olmak üzere bunun C++'taki ismi <cx> biçimindedir. Uzantının olmadığına ve başlık dosyalarının başına 'c' harfi getirildiğine 
	dikkat ediniz. İkinci farklılık standart C fonksiyonlarının std isim alanına taşınmış olmasıdır. 

	Biz henüz isiö alanları (name space) konusunu görmedik. Ancak C++'ın tüm kütüphanesindeki isimler std isim alanında ya da o isim alanın içerisindeki bir isim alanında
	bulunmaktadır. Bir isim alanındaki bir ismi kullanmak için <isim_alanı_ismi>::<isim> sentaksı kullanılmaktadır. Burada :: operatörüne "çözünürlük operatörü (scope 
	resolution operator)" denilmektedir. Biz örnek programlarımızda bu çözünürlük operatörünü kullanmamak için programın yukarısına aşağıdaki direktifi yerleştirdik:
	
	using namespace std;
	
	Bu direktif bizim std isim alanındaki isimleri çözünürlük operatörü olmadan doğrudan kullanmamızı sağlamaktadır. Eğer bu operatör olmasaydı cout gibi endl gibi 
	isimleri çözünürlük operatörü ile kullanmak zorunda kalırdık. Örneğin:

	std::cout << "test" << std::endl;

	İsim alanları konusu ayrıntıları olan ayrı bir konudur. Kursumuzun ilerleyen bölümlerinde bu konu zaten ele alınacaktır. 

	C++'ta <cx> biçiminde belirttiğimiz başlık dosyalarındaki isimlerin aynı zamanda global isim alanında bulunup bulunmayacağı derleycicileri yazanların isteğine 
	bırakılmıştır. Ancak C++'ta biz <x.h> biçimindeki başlık dosyalarını da C'de olduğu gibi include edebiliriz. Bu başlık dosyalarındaki isimler bu durumda
	global isim alanına yerleştirilmiş olmak zorundadır. Fakat <x.h> dosyalarının aynı zamanda std isim alanına da yerleştirilip yerleştirilmeyeceği derleyicileri 
	yazanların isteğine bırakılmıştır. Ancak C++'ta C'nin başlık dosyalarının <x.h> biçiminde include edilmesi kötü bir tekniktir. Biz kurusumuzda C'nin başlık 
	dosyalarını <cx> biçimind include edeceğiz ve oradaki isimlerin std isim alanında olduğunu varsayacağız. 

	Her ne kadar C++ C'nin standart fonksiyonlarını destekliyorsa da ayrıca C++'ın kendine özgü "template" tabanlı bir standart kütüphanesi de vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>

using namespace std;

int main()
{
	printf("This is a test\n");		// printf std isim alanının içeisinde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    21) C++'ta makrolara benzer ismine "inline fonksiyon" denilen fonksiyonlar da bulunmaktadır. Aslında inline fonksiyon kavramı C'de de çok uzun süredir çeşitli 
	derleyicilerde birier eklenti (extension) biçiminde bulunuyordu. Ancak inline fonksiyonlar C ailesine ilk kez C++'ta resmi olarak eklenmiştir. C++'tan sonra 
	inline fonksiyonlar C99 ile birlikte C'ye de sokulmuştur. Ancak C++'ın inline fonksiyonlarıyla C99'un inline fonksiyonları arasında semantik farklılıklar vardır. 
	Ayrıca C99 ile C'ye eklenmden önce derleycilerin eklenti biçiminde bulundurduğu inline fonksiyon semantiklerinde de farklılıklar bulunmaktadır. Tabii biz burada
	C++'taki inline fonksiyonları ele alacağız. 

	Bir fonksiyon "inline" belirleyici (function specifier) kullanılarak inline yapılabilir. Örneğin:
	
	inline void foo()
	{
		//...
	}

	inline bir fonksiyon çağrıldığında derleyici fonksiyon çağrısı yerine inline fonksiyonun iç kodunu çağrılan yere enjekte edebilmektedir. Böylece fonksiyon
	çağrısının bazı maliyetleri (function call overhead) ortadan kaldırılmış olmaktadır. Bir fonksiyon çağrıldığında derleyiciler normal olarak fonksiyonu CALL 
	makine komutuyla çağırmaktadır. CALL işleminden	önce argümanlar fonksiyonun parametre değişkenlerine kopyalanır. Fonksiyonda da geri dönüşü sağlamak için RET 
	makine komutu gerekir. Yine fonksiyonun stack üzerinde işlemler yapabilmesi için "stack frame düzenlemesine" gereksinim duyulabilmektedir. Bu düzenleme de 
	birkaç makine komutu ile yapılmaktadır. İşte fonksiyonların CALL işlemi yerine iç kodlarının çağrılan yere enjekte edilmesi bu ekstra makine komutlarını elimine 
	edebilmektedir. Örneğin şağaıdaki gibi bir fonksiyon söz konsu olsun:

	int add(int a, int b)
	{
		return a + b;
	}
	
	Bu fonksiyonu biz şöyle çağırmış olalım:

	result = add(10, 20);

	32 Bit Intel işlemcilerinin kullanıldığı sistemlerde add fonksiyonu için tipi olarak şu makine komutları üretilmektedir:Ç

	_add:
		push	ebp
		mov		ebp, esp
		mov		eax, [ebp + 8]
		add		eax, [ebp + 12]
		mov		esp, ebp
		pop		evp
		ret

	Burada aslında asıl toplamayı yapan aşağıdaki iki makine komutudur:

	mov		eax, [ebp + 8]
	add		eax, [ebp + 12]

	Diğer makine komutları ekstra maliyete yol açmaktadır. Fonksiyon çağrılması sırasında da tipik olarak şu makine komutları üretilmektedir:

	push	20
	push	10
	call	_add
	add		esp, 8

	Görüldüğü gibi aslında iki makine komutu ile yapılabilecek işlem 11 makine komutuyla yapılabilmiştir. Şimdi add fonksiyonunun inline olduğunu düşünelim:

	inline int add(int a, int b)
	{
		return a + b;
	}
	...
	result = add(10, 20);

	İşte bu durumda derleyici fonksiyonun iç kodunu çağrılan yere enjekte ederek çağırma işlemini elimine edebilmektedir. inline açımda (inline expansion) üretilecek 
	komutlar muhtemelen aşağıdaki gibi olacaktır:

	mov		eax, 10
	add		eax, 20
	mov		result, eax
	
	Klasik olarak C'de inline fonksiyon öncesinde bu tür optimizasyonlar parametreli makrolarla sağlanıyordu. Örneğin:

	#define add(a, b)		((a) + (b))

	Böylece kod enjekte işlemi derleme modülü tarafından değil önişlemci modülü tarafındna yapılıyordu. Örneğin:

	result = add(10, 20);

	Önişlemci bu kodu aşağıdaki biçime dönüştürüyordu:

	result = ((10) + (20))

	Ancak parametrelerin makroların şu dezavantajları vardır:

	1) Yazımları oldukça zordur.
	2) Tanımsız davranışa yol açabilirler. Bu konuda dikkat edilmesi gerekir. 
	3) Birkaç satırlık makroların yazımları problemlidir. 
	4) Önişlemci C'yi bilmemektedir. Dolayısıyla pek kontrolğ önişlemci yapamamaktadır. 

	Örneğin:

	#define square(a)		((a) * (a))

	Böyle bir makroyu aşağıdaki gibi çağırmış olalım:

	int x = 10;

	result = square(++x);

	Burada square bir fonksiyon olsaydı kod gayet normal olarak ele alınacaktı. Ancak makrolarda açım aşağıdaki gibi yapılacağından tanımsız davranış olşuacaktır:

	result = ((++x) * (++x))

	Ancak tabii inline bir fonksiyonun çokça çağrılması neticesinde bir kod büyümesi söz konusu olabilir. O halde kısa (örneğin bir iki satırlık) fonksiyonların 
	inline yapılması uygun bir yaklaşımdır. 

	inline belirleyicisi "bir emir değil rica" niteliğindedir. Yani biz bir fonksiyonu inline yaptığımızda derleyici onun iç kodunu enjekte etmek zorunda değildir. 
	inline fonksiyona yine derleyici normal fonksiyon muamelesi yapabilir. Bu konuda herhangi bir uyarı mesajı da vermeyebilir. inline konusu derleyicilerde genel 
	olarak optimizasyon konusu ile ilişkilendirilmiştir. Yani derleyicimizin optimizasyon seçeneklerini yeteri kadar açmazsak derleyicimiz inline açım yapmaz. 
	Microsoft derleyicilerinde en azından /O2,  g++ ve clang++ derleyicilerinde -O2 seçeneği "inline açım (inline expansion) için uygulanmalıdır. 

	Biz derleyicilerde optimizasyon seçeneklerini açsak bile derleyiciler "döngü içeren, iç içe çok fazla if deyiminin bulunduğu, uzun kodları" kodları
	inline olarak açmak istemezler. Bazı kodlar (örneğin özyineleme içeren) yine inline olarak açılamamaktadır. 

	Derleyiciler kodu inline olarak genellikle açmamışsa herhangi bir uyarı mesajı vermemektedir. Pekiyi biz fonksiyonuninline açılıp açılmadığını nasıl 
	anlayabiliriz? Bunun en sağlam yolu kodun sembolik makine dili çıktısını incelemek ya  da programı debugger altında çalıştırmaktır. Microsoft derleyicilerinde
	"assembly listing" oluşturmak için /FA seçeneği g++ ve clang++ derleyicilerinde ise -S seçeneği kullanılmaktadır. (Visual Studio IDE'sinde bu işlem) proje
	ayarlarından "Properties/C-C++/Output Files/Assembly Output" menüsüyle le yapılbilmektedir.)

	Örneğin:

	g++ -S -masm=intel sample.cpp

	-o seçeneği kullanılmamışsa üretilen dosya ".s" uzantılı olacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

inline int square(int a)
{
	return a * a;
}

int main(void)
{
	int result;
	int val;

	cout << "Bir değer giriniz:";
	cin >> val;

	result = square(val);		// result = val * val
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
 												10. Ders 18/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    inline fonksiyonlar kütüphanelere yerleştirilemezler (yerleştirilmeye çalışılmaları hata oluşturmayabilir ancak anlamlı değildir.) Çünkü her derleme işleminde 
	inline açım yapabilmesi için derleyicinin inline fonksiyonun tanımlamasını görmesi gerekir. C++ standartlarına göre bir inline fonksiyon farklı kaynak dosyalardan 
	kullanılacaksa her kaynak dosyada inline olarak ve tamamen ödeş biçimde tanımlanmalıdır. Örneğin aşağıdaki gibi bir inline fonksiyon olsun:

	inline int square(int a)
	{
		return a * a;
	}

	Biz bu fonksiyonu projemizi oluşturan "a.cpp", "b.cpp" ve "c.cpp" dosyalarından kullanmak isteyelim. İşte bu fonksiyon -eğer kullanacaksak- bu kaynak dosyalarda 
	inline olarak aynı biçimde tanımlanmış olması gerekir. 
	
	Bir inline fonksiyonun projenin farklı kaynak dosyalarında inline olarak aynı biçimde kullanılabilmesinin en pratik yolu bir başlık dosyası oluşturmak, inline 
	fonksiyonu o başlık dosyasının içerisine yerleştirmek ve dosyayı kullanılacak olan modillerden include etmektir. Yani inline fonksiyonlar tipik olarak projelerde
	başlık dosyalarının içerisine yerleştirilirler. 

	inline fonksiyonlar başlık dosyalarına yerleştirildiğinde ve birden fazla modülde o başlık dosyası include edildiğinde inline fonksiyon da bireden fazla modülde 
	tanımlanmış olacaktır. Pekiyi inline fonksiyonların birden fazla modülde tanımlanmış olması link aşamasında bir problem oluşturmaz mı?

	Yukarıda da belirttiğimiz gibi standartlara göre bir fonksiyon bir modülde inline olarak tanımlanmışsa o fonksiyonu kullanan her modül fonksiyonu yine inline 
	olarak aynı biçimde tanımlamak zorundadır. Bu "aynı biçimde tanımlama" tipik olarak inline fonksiyonun bir başlık dosyasına yerleştirilip modüllerden include 
	edilmesi ile sağlanmaktadır. İşte derleyici eğer inline fonksiyonu inline olarak açarsa ve fonksiyonun adresi de herhangi bir biçimde kodda kullanılmadıysa bu 
	durumda derleyici fonksiyonun derlenmiş halini hiç object dosyaya yazmayabilir. Ancak derleyici inline fonksiyon için inline açım yapmamışsa ya da fonksiyonun 
	adresi kullanılmışsa mecburen fonksiyonu object dosyaya yazacaktır. Bu biçimde projeyi oluşturan tüm modüllerde bu fonksyion object dosyaya yazılacağına göre 
	link aşamasında bir sorun oluşmayacak mıdır? İşte linker farklı object dosyalarda aynı inline fonksiyonun tanımlaması ile karşılaştığında onun herhangi bir 
	object dosyadaki tek bir kopyasını çalıştırılabilen dosyaya yazmaktadır. Bunun için modern object dosya formatlarında "common" bölümler ya da attribute'lar 
	bulunmaktadır. 

	C++'ta inline fonksiyonlar (static inline yapılmadıktan sonra) yine "external linkage'a" sahiptirler. Biz bir inline fonksiyonun adresini alabiliriz. 
	Bu durumda derleyici inline açım yapıyor olsa bile mecburen fonksiyon tanımlamasını yine object dosyaya yerleştirir. Benzer biçimde biz inline bir fonksiyonun 
	farklı modüllerde adresini alsak bile bu adreslerin hepsi aynı olmak zorundadır. Bu durum static olmayan inline fonksiyonun "external linkage'a" sahip olduğunu 
	açık biçimde göstermektedir. Bir inline fonksiyonun farklı modüllerde adresinin alınması durumunda bütün adreslerin aynı olması nasıl sağlanabilmektedir?
	İşte "linker" programları object dosyaları birleştirirken kodun bazı bölümlerinde düzeltmeler de yapmaktadır.

	Özetle programcı birkaç satırlık fonksiyonların hızlı çalışmasını istiyorsa onu inline yapabilir. inline fonksiyonlar tipik olarak başlık dosyalarına 
	yerleştirilirler. Böylece projeyi oluşturan her modülde onlar aynı biçimde bulunurlar. Eğer inline açım yapılırsa çalıştırılabilir dosyada bu inline 
	fonksiyon hiç bulunmayabilir. Eğer inline açım yapılmamışsa ya da inline fonksiyonun adresi kullanılmışsa bu fonksiyonların çalıştırılabilen dosyada 
	tek kopyası bulundurulmaktadır. 

	constexpr fonksiyonların otomatik olarak inline kabul edildiklerini anımsayınız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	inline anahtar sözcüğü fonksiyon prototiplerine yerleştirilebilir. Bu durumda fonksiyon tanımlanırken inline anahtar sözcüğü yazılabilir ya da yazıalmayabilir. 
	Örneğin:

	inline void foo();
	//...

	void foo()		// burada inline yazılmamış olsa bile prototipte inline belirtildiği için fonksiyon inline durumdadır. 
	{
		//...
	}

	Derleyici bir fonksiyon prototipini inline olarak gördükten sonra henüz fonksiyonun tanımlamasını görmeden fonksiyon çağrılırsa onu inline olarak açabilir 
	ya da açmayabilir. Genel olarak derleyiciler bu durumda fonksiyonu inline açmamktadır. Örneğin:

	inline void foo();
	
	int main()
	{
		foo();		// derleyici inline açım yapamayabilir

		return 0;
	}

	void foo()
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	22) C++11 ile birlikte auto anahtar sözcüğü otomatik tür belirleme için bir "tür belirleyicisi (type specifier)" haline getirilmiştir. Eskiden bu auto anahtar 
	sözcüğü (hala C'de böyle) gerçek bir işlevi olmayan "storage class specifier" olarak bulundurulan bir anahtar sözcüktü. C++11 ile bu atıl durumdaki auto anahtar
	sözcüğüne yeni bir işlev yüklenmiştir. 

	Bir değişken auto anahtar sözcüğü ile tanımlanıyorsa ona ilkdeğer verilmek zorundadır. Örneğin.

	auto int a;		// geçersiz!

	Derleyici auto anahtar sözcüğü ile tanımlanmış bir nesnenin türünü ona verilen ilkdeğerden hareketle belirler. Ona verilen ilkdeğer hangi türdense auto yerine
	sanki o türün yazılmış olduğunu kabul eder. Örneğin:

	int foo()
	{
		//...
	}

	//...

	auto a = 123;		// int a = 123;
	auto b = 12.3;		// double b = 12.3;
	auto c = foo;		// void (*c)() = foo;
	auto d = foo();		// int d = foo();

	auto tür belirleyici ile birden fazla değişken tanımlanabilir. Ancak onlara verilen ilkdeğerin hepsinin aynı türden olması gerekir. Örneğin:

	auto a = 10, b = 20;		// geçerli
	auto c = 10, d = 2.3;		// geçersiz!

	auto tür belirleyicisi ile birden fazla değişkenin bildiriminin yapıldığı durumda onların herbirinin türünün verilen ilkdeğerlere göre 
	tespit edildiğine ve bu türlerin aynı türler olması gerektiğine dikkat ediniz. Örneğin:

	auto a = 10, b = "ankara";		// geçersiz!

	Burada a için auto int türünü, b için const char * türünü temsil etmektedir. Bu türler farklı olduğundan bildirim geçersizdir. 

	auto özellikle karmaşık kullanıcı tanımlı türlerin ifade edilmesi konusunda programcıya pratiklik sağlamaktadır. Örneğin:

	vector<int> v;

	auto iter = v.begin();		// vector<int>::iterator iter = v.begin();

	Bildirimdeki auto belirleyicisinin bir tür belirttiğine dikkat ediniz. Örneğin:

	auto a = 10;

	Burada auto tür belirleyicisi int türünü temsil etmektedir. 

	auto belirleyici ile yer belrleyicileri ve tür niteleyicileri (cv qualifers) ve karmaşık dekleratörler birlikte kullanılabilir. Bu durumda tür tespiti 
	"şablon türlerin tespit edilmesi (template argument deduction)"	sürecinde olduğu gibi yapılmaktadır. Örneğin:

	int a = 10;
	auto &r = a, b = 20;					// auto = int
	const auto *s = "ali", ch = 'a';		// auto = char
	auto k = "veli"							// auto = const char *

	Örneğin:

	auto a = "ankara";			// auto = const char *
	auto *b = "ankara";			// auto = const char
	const auto *c = "ankara";	// auto = char

	Yukarıda da belirttiğimiz gibi ilkdeğerden hareketle auto tür belirleyicisinin belirttiği türün tespit edilmesi şablonlardaki tür tespitindeki kurallarla 
	yapılmaktadır. Şablonlar (templates) konusu çok sonra ele alacağımız bir konu olsa da burada yine auto belirleyicisinin şablon eşdeğeri üzerinde bir açıklama
	yapmak istiyoruz. Aşağıdaki gibi bir auto bildirimi yapılmış olsun:

	auto x = ifade;

	Buradaki tür tespiti aşağıdaki şablon parametrelerinin türlerinin tespit eedilmesindeki gibi yapılmaktadır:

	template <typename T>
	void foo(T x)
	{
		//....
	}
	
	foo(ifade);

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											11. Ders 20/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	auto belirleyici ile tür tespiti yapılırken dekleratöre göre kabaca üç farklı durum oluşmaktadır:

	1) auto ile bildirilen değişkenin referans ya da gösterici olmaması durumu (yani dekleratörde &, && ya da * kullanılmaması durumu)
	2) auto ile bildirilen değişkenin sol taraf değeri referansı ya da gösterici olması durumu (yani dekleratörde & ya da * kullanılması durumu)
	3) auto ile bildirilen değişkenin sağ taraf değeri referansı olması durumu (yani dekleratörde && kullanılması durumu)

	auto ile bildirilen değişken bir referans ya da gösterici değilse ilkdeğer olarak verilen nesnenin const ya da volatile olması tür üzerinde etkili 
	olmamaktadır. Örneğin:

	const int a = 10;
	auto b = a;			// auto = int

	Burada b int türdendir, const int türünden değildir. Örneğin:

	const volatile int a = 10;
	auto b = a;		// auto = int

	Burada b int türdendir, const volatile int türden değildir. 

	auto ile bildirilen değişken bir sol taraf değeri referansı ya da bir gösterici ise ilkdeğer verilen ifadedeki const ve volatile niteleyicileri
	türde etkili olmaktadır. Örneğin:

	const int a = 10;
	auto &b = a;			// auto = const int

	Burada b const int türünden bir referanstır.

	Bu durumda tür tespiti yapılırken üst düzey (top level) olmayan tür niteleyicilerinin de dikkate alındığına dikkat ediniz. Örneğin:

	const volatile int a = 10;
	auto &b = a;				// auto = const volatile int

	Burada b const volatile int türünden referanstır. Örneğin:

	const int a = 10;
	auto *p = &a;				// auto = cont int *

	Burada p gösterdiği yer const olan int türden bir göstericidir (yani const int * türündendir). 

	Eğer auto ile bildirilen değişken bir sağ taraf değeri referansı ise bu özel bir durum belirtmektedir. Bu tür referanslara "forwarding reference" ya da 
	"universial	reference" denilmektedir. Bu konu şablon işlemlerinin anlatıldığı bölümde ayrıntılarıyla ele alınacaktır. Ancak burada yine de bazı açıklamalar 
	yapmak istiyouz. 
	
	Normal olarak bir sağ taraf değeri referansına bir sol taraf değeri bind edilememektedir. Ancak "forwarding reference" özel ve istisnai bir durumdur. 
	auto belirleyicisi ile bildirilmiş olan bir sağ taraf değeri reeferansına bir sol taraf değeri ile ilkdeğer verilirse bildirilen değişken bir sol taraf 
	değeri referansı, bir sağ taraf değeri ile ilkdeğer verilirse bildirilen değişken bir sağ taraf değeri referansı olur. Örneğin:

	int a = 10;
	auto &&b = a;		

	Burada b bir sol taraf değeri referansıdır. Yani b int & türündendir. b referansının içerisine a'nın adresi yerleştirilmektedir. Örneğin:

	const int a = 10;
	auto &&b = a;

	Burda b const bir sol taraf değeri referansıdır. Yani b const int & türündendir. Ancak örneğin:

	auto &&b = 10;

	Burada b bir sağ taraf değeri referansıdır. Yani b int && türündendir. Forward reference konusunun ayrıntıları ileride diğer konular içerisinde ele alınacaktır.

	auto belirleyicisi bildirimde tek başına kullanılmak zorunda değildir. auto belirleyicisi ile birlikte yer ve tür belirleyicileri de kullanılabilir, dekleratörde
	başka atomlar da bulundurulabilir. Bu durumda auto belirleyicisinin hangi türü temsil ettiği yukarıda da belirttiğimiz gibi "şablon parametrelerinin türlerinin
	belirlenmesi (template argument deduction)" kuralına göre yapılmaktadır. Bu konunun ayrıntıları şablonların (templates) anlatıldığı bölümde ele alınacaktır. Örneğin:

	int a = 10;
	const auto &b = a, c = 10;		// auto = int

	Burada b const int & türünden, c ise const int türündendir. Buradaki const belirleyicisinin dekleratöre değil türe ilişkin olduğuna dikkat ediniz. 
	Örneğin:

	int a[10];
	auto b = a;				// auto = int *
	auto c = &a;			// auto = int (*)[10]

	Burada b int türünden bir gösterici (yani b int * türünden), c de 10 elemanlı int türden bir dizi göstericisidir (yani c int (*)[10] türündendir). Örneğin:

	int a[10];
	auto &b = a;		// auto = int[10]

	Burada b int türden 10 elemanlı bir dizi referansıdır (yani b int (&r)[10] türündendir).
	
	Örneğin:

	int a[10];
	auto (&b)[10] = a, c = 20;		// auto = int

	Burada auto int türünü temsil etmektedir. Böylece b bir 10 elemanlı bir diziyi temsil eden referans (yani b int (&r)[10] türündendir) c de int türünden bir nesne 
	belirtmektedir. 

	auto belirleyicisi ile bildirilmiş olan değişkenlere küme parantezleri ile ilkdeğer verildiğinde özel bir durum söz konusu olmaktadır. Bu durumu birkaç madde ile
	açıklamak istiyoruz:

	a) C++17'ye kadar auto ile küme parantezleri ile ilkdeğer verilmesi durumunda değişkenin initializer_list<T> türünden olduğu kabul ediliyordu. C++17'ye kadarki durumu
	aşağıdaki örnekle açıklamak istiyoruz.

	auto a{10};					// C++17'ye kadar a initilizer_list<int> türünden
	auto b = {10};				// b initializer_list<int> türünden
	auto c = {10, 20 , 30};		// c initializer_list<int> türünden
	auto d{10, 20, 30};			// geçersiz!
	auto e(10, 20, 30);			// geçersiz!

	b) C++17 ile birlikte küme parantezi ile tek elemanlı doğrudan (yani '=' olmadan) ilkdeğer vermelerde artık tür initializer_list<T> olarak değil doğurdan T olarak
	belirlenmektedir. Örneğin:
	
	auto a{10};					// a C++17'ye kadar a initializer_list<int> türünden ancak C++17 ve sonrasında int türden
	auto b = {10};				// b C++17 sonrasında ve öncesinde initializer_list<int> türünden

	C++17'den sonraki durum için aşağıdaki örnekleri vermek istiyoruz:

	auto a{10};					// C++17'ye kadar a initializer_list<int> türünden ancak C++17 ve sonrasında int türden
	auto b = {10};				// b C++17 sonrasında ve öncesinde initializer_list<int> türünden
	auto c = {10, 20 , 30};		// b C++17 sonrasında ve öncesinde initializer_list<int> türünden
	auto d{10, 20, 30};			// geçersiz!
	auto e(10, 20, 30);			// geçersiz!

	Özetle bu konudaki kurallarda C++17 öncesi ve sonrasındaki tek farklılık "uniform initilizer syntax" ile küme parantezleri kullanıldığındaki durumdur. C++17 
	öncesiinde bildirilen değişken initializer_list<T> kabeul edilirken C++17 ve sonrasında artık T kabul edilmektedir.

	C++14 ile birlikte fonksiyonun geri dönüş değeri için de auto kullanılabilir hale gelmiştir. Fonksiyonun geri dönüş değerinin türü yerine auto kullanılırsa
	derleyici geri dönüş değerinin türünü return ifadesindeki türe bakarak belirler. Örneğin:

	auto foo()		// auto = int
	{
		return 10;
	}

	Burada foo fonksiyonun geri dönüş değerinin int türden olduğu anlaşılmaktadır. Tabii fonksiyon içerisinde birden fazla kez return deyimi kullanılmışsa return 
	ifadelerinin tür tespitinin yapılabilmesi için aynı türden olması gerekir. Örneğin:

	auto foo(int a)		
	{
		if (a > 0)
			return 3.14;

		return 3;		// geçersiz!
	}

	auto void tür tespiti için de kullanılabilir. Eğer fonksiyonda hiç return kullanılmamışsa ya da tüm return deyimlerinde bir ifade bulundurulmamışsa bu durumda
	fonksiyonun geri dönüş değerinin void olduğu tespit edilir. Örneğin:

	auto foo(int a)			// auto = void
	{
		if (a < 0)
			return;

		cout << "foo" << endl;
	}

	C++20 ile birlikte fonksiyonun parametre değişkeninde de auto artık kullanılabilmektedir. Ancak bu kullanım fonksiyonun "gizli bir biçimde şablon olduğu" anlamına gelmektedir. 
	Örneğin:

	auto foo(auto a)
	{
		cout << a << endl;
	}

	int main(void)
	{
		foo(10);		// auto = int
		foo(20.2);		// auto = double
		foo("ankara");	// auto = const char *
	
		return 0;
	}

	Burada aslında derleyici bir tane foo değil üç farklı foo oluşturmaktadır. Bu kavrama C++'ta "şablon (template)", Java ve C# gibi diğer dillerde "generic"
	denilmektedir. Şablon konusu ileride ayrı bir bölüm olarak ele alınacaktır.

	Buradaki foo fonksiyonunun fonksiyon şablonu olarak eşdeğeri şöyledir:

	template <typename T>
	void foo(T a)
	{
		cout << a << endl;
	}

	C++11 ile eklenen auto tür belirleyicisinin ayrıntıları vardır. Ancak bu ayrıntılar üzerinde daha ileride ilgili konuların içerisinde duracağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    23) C++11 ile birlikte C++'a "aralık tabanlı for döngüsü (range based loop)" ismiyle yeni bir for döngüsü eklenmiştir. Aslında bu tarz for döngüleri 
	zaten C# gibi Java gibi dillerde "foreach" döngüsü ismiyle bulunuyordu. Aralık tabanlı for döngüsünün genel biçimi şöyledir:

	for (<tür> <değişken ismi> : <dizi ismi ya da dolaşılabilir nesne>)
		<deyim>

	C++20 ile birlikte aralık tabanlı for döngülerine normal for döngülerindeki gibi bir "init" bölümü de eklenmiştir ve genel biçim şu hale gelmiştir:

	for ([ifade ya da bildirim>;] <tür> <değişken ismi> : <dizi ismi ya da dolaşılabilir nesne>)
		<deyim>

	Aralık tabanlı for döngüleri şöyle çalışmaktadır: Bir dizi ya da dolaşılabilir (iterable) bir nesnenin her elemanı için döngü bir kez yinelenir. Her yinelemede 
	dizinin ya da dolaşılabilir nesnenin sıradaki elemanı döngü değişkenine yerleştirilir ve döngü deyimi çalıştırılır. Örneğin:

	int a[] {10, 20, 30, 40, 50};

    for (int x : a)
        cout << x << endl;

	Burada sırasıyla dizinin her elemanı döngü değişkeni olan x'e yerleştirilmiş ve döngü deyimi çalıştırılmıştır. Aralık tabanlı for döngüsünde döngü değişkeninin 
	faaliyet alanı yine for döngüsü ile sınırlıdır. Örneğin:

	for (int x : a) {
		//...
	}
	
	Biz x döngü değişkenini yalnızca döngünün içerisinde kullanabiliriz, döngünün dışında kullanamayız. 

	Aralık tabanlı for döngüleri "dizilerle ya da iterator yoluyla dolaşılabilir" nesnelerle kullanılabilmektedir. Biz bu nesnelere anlatımı kolaylaştırmak
	için "dizilim" diyeceğiz. (C++ standartlarında böyle bir terim yoktur. C++ standartlarında buna "range expression" denilmektedir.)

	Standartlarda aralık tabanlı for döngülerinin eşdeğeri iteratör kullanılarak verilmiştir. Ancak bi zhenüz iteratör kavramını bilmiyoruz. Hatalı olsa da
	şimdilik aralık tabanlı for döngüsünün dizisel eşdeğerini şöyle varsayabilirsiniz. Aralık tabanlı for döngüsü bir dizi ile aşağıdaki gibi kullanılmış olsun:

	T a[] = {1, 2, 3, 4, 5};

	for (T x : a) {
		//...
	}

	Bunun yaklaşık eşdeğer (tam eşdeğeri değil) şöyledir:

	auto __begin = a
	auto __end = a + 5;

	for (; __begin != __end; ++__begin) {
		T x = *begin;
		//...
	}

	Bu yaklaşık eşdeğerlilikte dikkat edilmesi gereken noktalardan biri "döngü değişkeninin sanki her yinelemede yeniden yaratılıyormuş gibi" olmasır. Diğer 
	dikkat edilmesi gereken nokta da dizilimin sıradaki elemanının döngü değişkenine "ilkdeğer veriliyormuş gibi" yerleştirilmesidir. 

	Aralık tabanlı for döngülerinde dizilimin her elemanı döngü değişkenine ilkdeğer veriliyormuş gibi atandığı için döngü değişkeni bir referans da olabilmektedir. Örneğin:

	int a[] {10, 20, 30, 40, 50};

    for (int &r : a)
        r = 2 * r;

	Burada a dizisinin her bir elemanı sanki referansa ilkdeğer veriliyormuş gibi düşünülmelidir. Dolayısıyla döngü deyiminde r referansına değer atanması
	aslında dizinin ilgili elemanına değer atanması anlamına gelmektedir. O halde örneğin:

	T a[] = {1, 2, 3, 4, 5};

	for (T &r : a) {
		//...
	}

	işleminin eşdeğeri şöyledir:

	auto __begin = a
	auto __end = a + 5;

	for (; __begin != __end; ++__begin) {
		T &r = *begin;
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int a[]{10, 20, 30, 40, 50};

    for (int x : a)
        cout << x << " ";
    cout << endl;

    for (int &r : a)
        r = 2 * r;

    for (int x : a)
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngüsünde herhangi bir türden dizi kullanabiliriz. Tabii normal olarak döngü değişkeninin de o dizi türüne uygun olması gerekir. Örneğin:

	const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (const char *name : names) {
		//...
	}
    
	Burada dizinin her elemanı const char * türündendir ve bir ismin adresini tutmaktadır. Döngü her yinelendiğinde name isimli gösterici sırasıyla dizideki
	isimleri gösterecektir. 

	String'ler de const char türünden dizi belirttiğine göre biz bir string'teki karakterleri de aralık tabanlı for döngüleri ile dolaşabiliriz. Örneğin:

	for (char ch : "ankara) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <iostream>

using namespace std;

int main()
{
    const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (const char *name : names)
        cout << name << " ";
    cout << endl;

    for (char ch : "ankara")
        cout << ch << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde ':' atomunun sağındaki dizilim belirten ifade (range expression) bir gösterici olamaz. Dizi isimlerinin ifadelere sokulduğunda
	dizinin ilk elemanını gösteren adreslere dönüştürüldüğünü biliyoruz. Ancak aralık tabanlı for döngülerinde böyle bir dönüştürme yapılmamaktadır. Dolayısıyla
	aralık tabanlı for döngülerinde ':' atomunun sağındaki ifadenin diziyi gösteren bir gösterici değil bizzat dizi nesnesinin kendisi olması gerekir. Örneğin:

	int a[] {1, 2, 3, 4, 5};

	for (int x : a) {		// geçerli
		//...
	}

	Ancak örneğin:

	int a[] {1, 2, 3, 4, 5}, *pi = a;

	for (int x : pi) {		// geçersiz!
		//...
	}

	Dolayısıyla ':' atomunun sağına biz bir string yerleştirdiğimizde aslında oaray const char türünden bir dizi nesnesini yerleştirmiş gibi olmaktayız. Örneğin:

	for (char ch : "ankara") {
		//...
	}

	Bu döngünün eşdğerinin aşağıdaki gibi olduğu varsayılmalıdır:

	const char __temp[] = "ankara";

	for (char ch : __temp) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi aralık tabanlı for döngüleri iteratör desteği olan dolaşılabilir (iterable) sınıf nesneleri ile de kullanılabilmektedir. 
	Örneğin C++'ın standart kütüphanesindeki vector gibi list gibi sınıflar dolaşılabilir olduğu için aralık tabanlı for döngülerinde kullanılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main(void)
{
	vector<int> v{ 10, 20, 30, 40, 50 };

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda auto belirleyicisi ile küme parantezi kullanılarak ildeğer vermelerde (C++17'deki küçük değişikliği anımsayınız) aslında initializer_list<T>
	türünden bir sınıf nesnesinin yaratıldığını söylemiştik. İşte initializer_list sınıfı da iteratör yoluyla dolaşılabildiği için aralık atablı for döngülerinde
	kullanılabilmektedir. Örneğin:

	auto a = {1, 2, 3, 4, 5};		// a initializer_list<int> türünden

	for (int x : a) {	// geçerli
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    auto a = {1, 2, 3, 4, 5};       // a initializer_list<int> türünden

    for (int x : a)
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aralık tabanlı for döngülerinde döngü değişkeninin normal olarak ilgili dizilimin eleman türünden olması gerekir. Örneğin biz int bir diziyi aralık tabanlı 
	for döngüsüyle dolaşacaksak döngü değişkeninin int türdne olmasını bekleriz. Pekiyi o zaman döngü değişkeninin türünü belirtmeye ne gerek vardır? İşte aslında 
	mademki döngü değişkenine dizinin elemanları ilkdeğer veriliyormuş gibi yerleştirilmektedir o halde aslında bu türler farklı olabilir. Örneğin:

	double a[]{3.14, 2.718, 12.34, 5.2, 7.8};

    for (int x : a) {
        //....
    }

	Tabii burada double türünden int türüne dönüştürme sırasında bilgi kaybı söz konusu olacaktır. İşte bazı konular dikkate alındığında döngü değişkeninin 
	farklı türden olabilmesi dah esnek bir kullanım oluşturmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    double a[]{3.14, 2.718, 12.34, 5.2, 7.8};

    for (int x : a) 
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														12. Ders 25/09/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde döngü değişkeninin türü yerine "auto" tür belirleyicisi kullanılabilir . Bu durumda eğer dolaşılan nesne bir dizi ise dizinin 
	türüne dayalı tür tespiti yapılır. Eğer dolaşılan nesne iteratör yoluyla dolaşılabilir bir nesne ise burada iteratörün türüne göre tür tespiti yapılmaktadır.
	(Bu tür durumlarda ilgili sınıfının * operatör fonksiyonu çağrıldığı için bu operatör fonksiyonunun geri dönüş değerine dayalı olarak tür tespiti yapılmaktadır.)
	Örneğin:

	int a[] = {1, 2, 3, 4, 5};
	
	//...

	for (auto x : a) {			// auto = int
		//...
	}

	Burada dizi int türden olduğu için dizi elemanları da int türdendir. Dolayısıyla auto belirleyicisi int türünü olarak belirlenecektir. Örneğin:

	const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};
	
	//...

	for (auto x : names) {			// auto = const char *
		//...
	}

	Burada names dizisi const char * türünden olduğu için auto da cont char * türü olarak belirlenecektir. Örneğin:

	vector<int> v{1, 2, 3, 4, 5};

	//...

	for (auto x : v) {		auto = int
		//...
	}

	Her ne kadar vector sınıfını görmemiş olsak da burada bu vector nesnesi int türden değerler tuttuğu için auto da int olarak belirlenecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    double a[]{3.14, 2.718, 12.34, 5.2, 7.8};
    vector<int> v{1, 2, 3, 4, 5};
    const char *names[] = {"ali", "veli", "selami", "ayse", "fatma"};

    for (auto x : a)            // auto = double
        cout << x << " ";
    cout << endl;

    for (auto &x : a)            // auto = double
        cout << x << " ";
    cout << endl;

    for (auto x : v)            // auto = int
        cout << x << " ";
    cout << endl;

    for (auto x : names)        // auto = const char *
        cout << x << " ";
    cout << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde döngü değişkeni dizilim için doğrudan küme parantezleri içerisinde bir değer listesi kullanılabilir. Bu durumda bu küme 
	parantezli listederleyici tarafından otomatik olarak initializer_list<T> türüne dönüştürülmektedir. Ancak bu dönüştürmenin yapılabilmesi için küme parantezleri 
	içerisindeki değerlerin aynı türden olması gerekmektedir. initilizer_list<T> türünün iteratör yoluyla dolaşılabilen bir tür olduğunu anımsayınız. initializer_list 
	sınıfı kursumuzun ilerleyen zamanlarında ele alınacaktır. Örneğin:

	for (auto x : {1, 2, 3, 4, 5}) {		// auto = int
		//...
	}

	Burada auto belirleyicisi int olarak tespit edilecektir. Tabii biz aslında auto yerine doğrudan int türünü de kullanabilirdik. Örneğin:

	for (int x : {1, 2, 3, 4, 5}) {			// geçerli
		//...
	}

	Bu biçimdeki for döngülerinde küme parantezi içerisindeki elemanların aynı türden olması gerekmektedir. Örneğin:

	for (auto x : {1, 2, 3.5, 4, 5}) {		// geçersiz! 
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++20 ve sonrasında aralık tabanlı for döngülerinde ""isteğe bağlı olarak (optional)" bir "init" kısmı bulundurulabilmektedir. Eğer "init" kısım 
	bulundurulacaksa bunu ";" atomu izlemelidir. Örneğin:

	int total;

	//...

	for (total = 0; auto x : {1, 2, 3, 4, 5})
        total += x;
    cout << total << endl;

	Bu "init" ifadesi boş da bırakılabilir. Ancak bunun bir anlamı yoktur. Örneğin:

	for (; auto x : a) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    int total;

    for (total = 0; auto x : {1, 2, 3, 4, 5})
        total += x;
    cout << total << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	24) C'de tek tırnak içerisindeki karakterler int türden kabul edilmektedir. Örneğin C'de 'a' karakter sabiti her ne kadar karakter sabiti ise de int türdendir. 
	Ancak C++'ta içerisinde yaşnızca tek bir karakter bulunan karakter sabitleri int türden değil char türdendir. Örneğin C++'ta 'a' sabiti char türdendir. 
	Dolayısıyla örneğin sizeof('a') C'de int türünün byte uzunluğunu verirken C++'ta 1 verecektir. Tabii hem C'de hem de C++'ta aslında tek tırnak içerisine
	int türünün byte uzunluğu kadar karakter girilebilir. C++'ta tek tırnak içerisine birden fazla karakter girilirse bu durumda böyle sabitler C'de olduğu 
	gibi int türden kabul edilmektedir. Yani örneğin 'ab' sabiti hem C'de hem de C++'ta int türdendir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    25) C++'ta yapılar, birlikler, sınıflar ve enum türleri için tür bilgisi ifade edilirken "struct", "union", "class"  ve "enum" anahtar sözcüklerinin 
	kullanımı zorunlu değildir. Halbuki C de yapı, birlik ve enum türleri yalnızca isimle belirtilmemektedir. Örneğin C'de date isimli bir yapı bildirmiş olalım. 
	Biz bu yapı türünden nesne tanımlarken tür ismi olarak "struct date" kullanmak zorundayız. Halbuki C++'ta yalnızca "date" ismi yeterli olmaktadır. Örneğin:

	struct complex {
		double real;
		double imag;
	};

	complex z;			// C'de geçersiz, C++'ta geçerli

	C'de yukarıdaki yapı bildirimi ile oluşturulan türün ismi "complex" değildir, "struct complex" biçimindedir. Halbuki C++'ta bu yapıya ilişkin tür yalnızca
	"complex" ismiyle kullanılabilmektedir. Tabii C++'ta istersek tür isminin önüne struct, class, union, enum anahtar sözcüklerini getirebiliriz. Örneğin:

	struct complex z;		// Hem C'de hem de C++'ta geçerli

	Tabii bu tür isimleri tür isminin kullanılabildiği yerde bu biçimde kullanılabilir. Örneğin:

	date *pd;			// geçerli
	void *pv;
	//...

	pd = (date *)pv;		// geçerli 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct date {
    int day, month, year;
};

int main()
{
    date d = {10, 12, 2009};            // C'de geçersiz, C++'ta geçerli
    struct date k = {10, 12, 2009};     // Hem C'de hem de C++'ta geçerli

    cout << d.day << '/' << d.month << '/' << d.year << endl;
    cout << k.day << '/' << k.month << '/' << k.year << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    26) C'de enum türleri ile int türü arasında bir farklılık yoktur. Yani C'de bir enum türünden nesne sanki int türden bir nesneymiş gibi derleyiciler tarafından 
	ele alınmaktadır. Benzer biçimde C'de enum sabitleri de (enumators) sanki int türden sabitler gibi ele alınmaktadır. Dolayıısyla biz C'de enum türünden bir 
	değişkene int türünden bir değişkene atayabileceğimiz her şeyi atayabiliriz. Benzer biçimde C'de enum sabitleri ya da enum türünden nesneler sanki int türündenmiş
	gibi işlem öncesi tür dönüştürmesine sokulmaktadır. Örneğin aşağıdaki gibi bir C kodu olsun:
	
	enum Direction {
		Up, Right, Down, Left
	};
	//...

	enum Direction d;
	int val;

	d = 2;				// geçerli
	val = d + 1;		// geçerli
	val = Down + 1;		// geçerli
		
	Ancak C++'ta her enum türü bağımsız ve farklı bir türdür. mümerik türlerden enum türlerine otomatik dönüştürme yoktur. Ancak bunun tersi olan enum türlerinden 
	nümerik türlere otomatik dönüştürme vardır. Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};
	//...
	
	Direction d;
    int val;

    d = Right;
    val = d + 1;
    cout << val << endl;            // 2

    val = Right + Down;

    cout << val << endl;            // 3

	d = 2;                          // geçersiz!
    d = (Direction)2;               // geçerli

	Görüldüğü gibi C'de biz nümerik türden bir değeri doğrudan enum türünden bir değişkene atayabilmekteyiz. Ancak C++'ta bu durum geçerli değildir. Ancak C++'ta
	biz enun türünden bir değeri nümerik türlerle işleme sokabiliriz. Bu durumda enum türü sanki bir tamsayı türüymüş gibi işleme sokulmaktadır. Yine C'de 
	iki farklı enum türünü birbirlerine atayabiliriz. Çünkü C'de enum türleri tamamen int türü gibi ele alınmaktadır. Ancak C++'ta iki farklı enum türü arasında
	otomatik dönüştürme yoktur. Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};

	enum Color {
		Red, Green, Blue
	};

	Color c;

	c = Right;		// geçersiz! Direction türünden Color türüne otomatik dönüştürme yok!

	C'de enum sabitleri de (enumerators) int türden kabul edilmektedir. Halbuki C++'ta enum türleri farklı bir tür belirttiği için enum sabitleri de ilgili 
	enum türündendir. Örneğin:

	enum Day {
		Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
	};

	Burada örneğin Sunday, Thursay enum sabitleri Day isimli enum türündendir. Örneğin:

	Day d;

	d = Thursday;		// geçerli, d de Thursday de Day türünden

	Tabii yukarıdaki örnekte de görüldüğü gibi tür dönüştürme operatöryle nümerik türler enum türlerine, enum türleri başka enum türlerine dönüştürülebilir. 
	Örneğin:

	enum Direction {
		Up, Right, Down, Left
	};

	enum Color {
		Red, Green, Blue
	};
	//...

	Direction d;

	d = Green;					// geçersiz!
	d = (Direction)d;			// geçerli fakat anlamlı olmayabilir

	C++'ta her enum türünün "ilişkin oldu bir tamsayı türü (underlying integer type)" vardır. enum türünün ilişkin olduğu tamsayı türü aslında o enum türünün 
	gerçekte derleyici tarafından ele alındığı tamsayı türüdür. enum türünün ilişkin olduğu tamsayı türünün bizim için iki önemi vardır:

	1) İlgili enum türünden bir nesne tanımladığımızda o nesne o enum türünün ilişkin olduğu tamsayı türü kadar yer kaplamaktadır.
	2) enum türünden bir değer artimetik işlemlere sokulduğunda ya da atama işlemine sokulduğunda derleyici sanki işleme giren değerin o enum türünün ilişkin 
	olduğu tamsayı türüymüş gibi olduğunu kabul etmektedir. 

	Özetle enum türü aslında C++ derleyicisi için arka planda bir tamsayı türü imiş gibi işleme sokulmaktadır. İşte buna enum türünün ilişkin olduğu tamsayı türü 
	denilmektedir. 
	
	enum türünün ilişkin olduğu tamsayı türü naısl belirlenmektedir? İşte C++11 ile birlikte enum türünün ilişkin olduğu tamsayı türü açıkça ": <tür>" sentaksıyla 
	belirtilebilmektedir. Örneğin:

	enum Direction : int {
		Up, Right, Down, Left
	};

	Burada Direction isimli enum türünün ilişkin tamsayı türü açıkça "int" olarak belirtilmiştir. Tabii ": <tür>" sentaksındaki türün tamsayı türlerinden biri 
	olması gerekmektedir. (C++ standartlarında buna enum türünün ilişkin olduğu tamsayı türünün "fixed" yapılması de denilmektedir.) Tabii ": <tür" sentaksı 
	C++11 ile C++'a eklenmiştir ve bu sentaks enum bildiriminde kullanılmak zorunda değildir. Pekiyi bu durumda enum türünün ilişkin olduğu tamsayı türü ne 
	olacaktır? İşte bu durumda C++ standratlarına göre enum türünün ilişkin olduğu tamsayı türü tüm enum sabitlerinin değerini içerecek biçimde herhangi bir tamsayı 
	olabilmektedir. Ancak standartlar eğer enum sabitlerinin değeri int ve unsigned int türünün sınırlarını aşmadıysa int ve unsigned int türünden büyük bir tür 
	olamayacağını da söylemektedir. Örneğin:

	enum Direction {
		Up = 10, Right = 20, Down = 30, Left = 40
	};

	Burada Direction isimli enum türünün ilişkin olduğu tamsayı türü char, signed char, unsigned char, short, unsigned short ve int ve unsigned int olabilir. 
	Ancak long, unsigned long, long long ve unsigned long long olamaz. 

	Bir enum türünün enum sabitleri o enum türünün ilişkin olduğu tamsayı türünün sınırları dışında değer alamaz. Örneğin:

	enum Direction : unsigned char {
		Up, Right, Down=255, Left               // geçersiz! Left = 256 ama unsigned char sınırlarının dışında
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de ve C++'ta normal enum türlerinde enum sabitleri (enumerators) enum bildirimi hangi faaliyet alanında yapılmışsa sanki o faaliyet alanındaki değişkenler 
	gibi kabul edilmektedir. Örneğin:

	enum Color {
		Red, Green, Blue
	};

	Burada Color isimli enum türü eğer global alanda bildirilmişse Red, Green ve Blue bir global değişken gibi, yerel blokte bildirilmişse bir yerel değişken gibi 
	kullanılmaktadır. Bu da farklı kütüphanelerin bir arada kullanılmasında "isim çakışması (name collision)" oluşturabilmektedir. Örneğin biz iki farklı kaynak 
	tarafından oluşturulmuş olan "x.hpp" ve "y.hpp" dosyalarını include ettiğimizde o dosyalardaki farklı enum türlerinde tesadüfen aynı enum sabitleri bulunabilmektedir.
	Bu durumda aynı faaliyet alanı ieçrisinde aynı değişkenden birden fazla kez tanımlanması nedeniyle error oluşmaktadır. Tabii C++'ta ileride görecek olduğumuz 
	"isim alanları (namespace)" kullanılarak bu farklı kaynaklar bu enum türlerini kendi isim alanlarında bildirebilirler. Böylece isim çakışmasının önüne 
	geçilebilmektedir. Tabii bunun da ayrı bir zahmeti vardır. 

	C++11 ile birlikte dile ismine "faaliyet alanlı enum (scoped enumeration)" denilen yeni bir enum türü daha eklenmiştir. Faaliyet alanlı enum "enum struct" ya da 
	"enum class" anahtar sözcükleriyle bildirilmektedir. Bu iki bildirim arasında hiçbir farklılık yoktur. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};

	Faaliyet alanlı enum türlerinde enum sabitleri (enumerators) artık enum bildiriminin yapıldığı faaliyet alanında değildir. enum sabitlerine her zaman 
	<enum_ismi>::<enum sabiti> ifadesiyle erişilmektedir. Örneğin:

	Direction d;

	d = Direction::Up;			// geçerli
	d = Up;						// geçersiz!

	Burada enum sabitlerine erişmekte kullanılan :: operatörüne "çözünürlük operatörü (scopre resolution operator)" denilmektedir. Atomlar arasında istenildiği 
	kadar boşluk karakteri bırakılabileceğinie göre aşağıdaki yazım da geçerlidir:

	d = Direction :: Up

	Ancak programcılar genel olarak çözünürlük operatörünün iki tarafında boşluk kullanmazlar. Çözünürlük operatörü ile ileride başka onularda da karşılaşacağız. 
	Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};

	enum class Style {
		Up, Down, Hatch, Cross
	};

	Bu iki faaliyet alanlı enum türünün birlikte bulunmasının bir sakıncası yoktur. Çünkü bunların enum sabitlerine artık enum ismi belirtilerek erişilmektedir. 

	Faaliyet alanlı enum türünün normal enum türünden bir farklılığı da otomatik dönüştürmeye izin vermemesidir. Biz faaliyet alanlı bir enum türünü bir tamsayı türüne 
	ya da nümerik türe atayamayız. Faaliyet alanlı bir enum türünü nümerik türlerel işleme sokamayız. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};
	//...

	Direction d = Direction::Down;
	int val;

	val = d;		// Normal enum türleri için geçerli ama faaliyet alanlı enum türleri için geçersiz!
	val = d + 1;	// Normal enum türleri için geçerli ama faaliyet alanlı enum türleri için geçersiz!
	d = 1;			// Hem normal enum türleri için hem de faaliyet alanlı enum türleri için geçersiz!
	
	Görüldüğü gibi faaliyet alanlı enum türleri tür dönüştürmesi bakımından daha katıdır. 

	Tabii faaliyet alanlı enum türlerine ilişkin değerler de tür dönüştürme operatörleriyle nümerik türlere dönüştürülebilir. Nümerik türler de yine tür dönüştürme 
	operatörleriyle faaliyet alanlı enum türlerine dönüştürülebilir. Örneğin:

	enum class Direction {
		Up, Right, Down, Left
	};		
	//...

	Direction d = Direction::Down;
    int val;

    val = (int)d;               // geçerli
    cout << val << endl;

    d = (Direction)(val + 1);   // geçerli

	Faaliyet alanlı enum türlerinin de ilişkin olduğu tamsayı türü vardır. Bu tamsayı türü yine normal enum türlerinde olduğu gibi ": <tür>" sentaksıyla 
	belirtilmektedir. Örneğin:

	enum class Color : unsigned char {
		Red, Green, Blue
	};

	Ancak faaliyet alanlı enum türlerinde ilişkin olunan tamsayı türü belirtilmezse default durum "int" kabul edilmektedir. Örneğin:

	enum class Color {			// Color enum türünün ilişkin olduğu tamsayı türü int
		Red, Green, Blue
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum Direction {
    Up, Right, Down, Left
};

void move(Direction d)
{
    switch (d) {
        case Direction::Up:
            cout << "moving up...\n";
            break;
        case Direction::Right:
            cout << "moving right...\n";
            break;
        case Direction::Down:
            cout << "moving down...\n";
            break;
        case Direction::Left:
            cout << "moving left...\n";
            break;
    }
}

int main()
{
    move(Direction::Up);
    move(Direction::Down);

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
												13. Ders 27/09/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    27) C++14 ile birlikte C++'a tamsayı türlerine ilişkin sabitlerin 2'lik sistemde ifade edilebilmesi özelliği eklenmiştir. Anımsanacağı gibi C'de tamsayı 
	türlerine ilişkin sabitler 10'luk, 16'lık ve 8'lik sistemlerde ifade edilebiliyordu. C++14 ile birlikte 2'lik sistemde de ifade olanağı dile eklenmiştir. 
	Tamsayıların 2'lik sistemde ifadesi için 0b ya da 0B önekleri kullanılmaktadır. Örneğin:

	c = 0b10101100;

	Aynı özellik C'ye de C23 ile eklenmek istenmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    unsigned char a = 0B1000011;

    printf("%02X\n", a);

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    28) C++'a C++14 ile birlikte sabitlerdeki basamakların birbirinden görsel olarak ayırt edilebilmesi için basamak ayıracı özelliği eklenmiştir. Büyük sayıların 
	ayıraçsız bir biçimde oluşturulması sayıların okunabilirliğini zorlaştırmaktadır. Örneğin:

	a = 1000000000;

	Burada a'ya atanan değerin kaç olduğunu anlayabilmek için özel bir dikkatin sarf edilmesi gerekmektedir. C++14 ile birlikte artık ' (tek tırnak) basamakları
	görsel biçimde ayırmak için kullanılabilmektedir. Örneğin:

	a = 1'000'000'000;

	Tabii burada tek tırnak karakterlerinin üçlü basamakları ayırmak için kullanılması zorunlu değildir. Örneğin:

	a = 1'0'0'0'0'0'0'0'0'0;		// geçerli

	Ancak tek tırnak sayının başında ya da sonunda olamaz. Örneğin:

	a = '10'000;					// geçersiz!
	a = 10000';						// geçersiz!

	Sabit içerisinde yan yana birden fazla tek tırnak ayıracı da kullanılamamaktadır. Örneğin:

	a = 1''000'000'000;				// geçersiz!

	Aslında basamak ayırçları pek çok dilde eskiden beri bulunuyordu, bazılarına ise onların çeşitli versiyonlarında eklendi. Örneğin Python, C# ve Java'da
	basamak ayıracı olarak _ (alt tire) kullanılmaktadır. 

	Basamak ayıraçları yalnızca 10'luk sistemde belirtilen sabitlerde değil diğer sistemlerde belirtilen sabitlerde de kullanılabilmektedir. Örneğin:

	a = 0x12'34'56'78;
	b = 0'12'456;
	c = 0b1000'1010

	Tek tırnak ayıracı 0x ya da 0X, 0b ya da 0B'den hemen sonra getirilemez. Ancak octal sistemde 0'dan hemen sonra getirilebilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
 
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    29) C++'ta C'de olmayan uzmanlaşmış tür dönüştürme operatörleri vardır. C'nin "(tür) operand" biçimindeki tür dönüştürme operatörü C++'ta aslında aynı biçimde
	kullanılabilmektedir. Ancak C'nin tür dönüştürme operatörü değişik dönüştürmeleri bir arada yaptığı için hatalara zaemin hazırlayabilmektedir. İşte C++'ta 
	farklı tarzda tür dönüştürmeleri için farklı operatörler bulundurulmuştur. C++'ta C tarzı tür dönüştürmesi yerine bu özel operatörlerin kullanılması iyi bir 
	ekniktir. C++'ın özel tür dönüştürme operatörleri şunlardır:

	static_cast
	const_cast
	reinterpret_cast
	dynamic_cast

	Bu operatörler şablon senktası biçimde kullanılır. Yani dönüştürülecek tür açısal parantezler içerisinde belirtilir. Dönüştürülecek ifade de paranteze alınır. 
	Kullanımın genel biçimi şöyledir:

	xxx_cast<tür>(ifade)

	Örneğin:

	val = static_cast<int>(color);

	C'nin C++'ta da kullanılabilen tür dönüştürme operatörü adeta static_cast, const_cast, reinterpret_cast operatörlerinin birleşimi gibidir. Ancak bu konuda 
	bazı ayrıntılar da vardır. dynamic_cast sınıflar konusuyla ilgilidirç Bu nedenle bu cast operatörü çok ileride ele alınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	static_cast "standart dönüştürmeler (standard conversion)" için kullanılmaktadır. Standart dönüştürme demekle aritmetik türler arası dönüştürmeler, enum ile nümerik 
	dönüştürmeleri, void * dönüştürmeleri, türemiş sınıftan taban sınıfa adres dönüştürmeleri kastedilmektedir. Örneğin double bir değeri int türüne dönüştürmek 
	isteyelim:

	double d = 12.34;
	int i;

	i = d;							// geçerli
	i = static_cast<int>(d);		// geçerli

	Görüldüğü gibi otomatik dönüştürmenin yapıldığı her yerde static_cast operatörü de kullanılabilmektedir. Örneğin:

	int a, b;
	double c;
	//...

	a = 10;
	b = 4;
	c = static_cast<double>(a) / b;

	static_cast operatörü ile enum türleri nümerik türlere, nümerik türler de enum türlrine dönüştürülebilir. Örneğin:

	enum class Color {
		Red, Green, Blue
	};
	//...

	Color c;
    int val;

    c = Color::Green;
    val = static_cast<int>(c);
    
	void bir adresin türü belirli bir adrese, türü belirli bir adresin de void adrese dönüştürülmesi static_cast ile yapılabilmektedir. Örneğin:

	pi = static_cast<int *>(malloc(10 * sizeof(int)));

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void *foo()
{
	return NULL;
}

enum Color {
	Red, Green, Blue
};

int main(void)
{
	double a = 10.2;
	int val;
	int *pi;
	Color color;

	val = static_cast<int>(a);			// Zaten operatöre gerek yok
	pi = static_cast<int *>(foo());		// void *'dan diğer adres türlerine 
	color = static_cast<Color>(2);		// geçerli, static_cast bu dönüştürmeyi yapar
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	const_cast adres dönüştürmelerinde const'luğu atmak için (const away cast) kullanılmaktadır. Örneğin:

	int a = 10;
	const int *pci = &a;
	int *pi;

	pi = const_cast<int *>(pci);

	const_cast ile aynı türdeki adreslerde const'luk atılabilir. Örneğin:

	int a = 10;
	const int *pci = &a;
	char *pc;

	pc = const_cast<char *>(pci);		// geçerli değil! yalnızca canst'luk atılmıyor

	const_cast adreslerdeki const'luğu atmaktadır. Dolayısıyla const_cast operatörğndeki hedef türün bir adres olması gerekektedir. Örneğin:

	const int a = 10;
	int b;

	b = const_cast<int>(a);		// geçersiz! const_cast adresler için kullanılır

	const_cast const olmayan bir adresin const adrese dönüştürülmesinde de kullanılabilir. Ancak bu dönüştürme zaten otomatik yapıldığı için bu operatörün 
	kullanılmasına gerek yoktur. Yukarıda da belirttiğimiz gibi otomatik dönüştürmelerin hepsi zaten static_cast operatörü ile de yapılabilmektedir. Yani biz 
	örneğin int * türünü const int * türüne static_cast ile de dönüştürebiliriz. const_cast operatörünün asıl yaptıı şey adreslerdeki const'luğu atmaktır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	const int *pci = &a;
	int *pi;

	pi = const_cast<int *>(pci);		// geçerli
	*pi = 20;

	cout << a << endl;

	pi = (int *)pci;					// geçerli fakat kötü teknik!
	*pi = 30;

	cout << a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    reinterpret_cast farklı türlerdeki adresler arasında ve adres türleriyle aritmetik türler arasında tür dönüştürmeleri için kullanılmaktadır. Örneğin:

	int a = 12345;
	unsigned char *pc;

	pc = reinterpret_cast<unsigned char *>(&a);

	Burada int * türü unsigned int * türüne dönüştürülmüştür. Örneğin:

	int a = 12345;
	unsigned long addr;

	addr = reinterpret_cast<unsigned long>(&a);

	Burada bir adresin sayısal bileşeni bir tamsayı türüne reinterpret_cast operatörü ile dönüştürülerek atanmıştır. Örneğin:

	int *pi;

	pi = reinterpret_cast<int *>(0x123456);

	Burada 0x12345 int türden sabit bir adresin sayısal bileşeni olarak int türden göstericiye yerleştirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = { 1, 2, 3, 4, 5 };
	unsigned char *pc;
	unsigned long addr;

	pc = a;											// error!
	pc = (unsigned char *)a;						// geçerli ama C++'ta kötü teknik
	pc = reinterpret_cast<unsigned char *>(a);		// iyi teknik

	addr = (unsigned long)a;						// geçerli ama C++'ta kötü teknik
	addr = reinterpret_cast<unsigned long>(a);		// geçerli ve iyi teknik

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hem adresteki const'luğu atmak hem de adresi farklı türe dönüştürmek için iki operatör birlikte kullanılmalıdır. Örneğin:

	const int *pi;
	char *pc;
	//...

	pc = reinterpret_cast<char *>(const_cast<int *>(pi));

	ya da şöyle de yapılabilirdir:

	pc = const_cast<char *>(reinterpret_cast<const char *>(pi));
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	const int *pci;
	unsigned char *pc;

	pci = &a;

	pc = const_cast<unsigned char *>(reinterpret_cast<const unsigned char *>(pci));
	
	for (size_t i = 0; i < sizeof(a); ++i)
		printf("%02X ", pc[i]);
	printf("\n");

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	dynamic_cast operatörü sınıflarla ilgili işlem yapmaktadır. Bu operatör çok ileride ele elınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	30) C++'ta C'deki tür dönüştürme operatörünün sentaks olarak ters biçimini andıran "fonksiyonel tür dönüştürme operatörü" de bulunmaktadır. Fonksiyonel 
	tür dönüştürme operatörü hem sınıflar konusunda uyum oluşturmak için hem de şablon mekanizmasını desteklemek için bulundurulmuştur. Bu operatör C++'ın ilk
	zamanlarından beri varlığını sürdürmektedir. Ancak C++11 ile "uniform initializer syntax" dile eklenince bunun küme parantezli biçimi de oluşturulmuştur. 
	Fonksiyonel tür dönüştürme operatörü yukarıda da belirttiğimiz gibi adeta klasik tür dönüştürme operatörünün sentaks bakımından tersidir. Yani T bir 
	tür belirtmek üzere C'nin klasik tür dönüştürme operatörü (T)ifade biçimindedir. Fonksiyonel tür dönüştürme operatörü ise T(ifade) biçimindedir. Burada 
	dönüştürülecek türün değil ifadenin paranteze alındığına dikkat ediniz. T(ifade) bir fonksiyon çağrısına benzediği için buna "fonksiyonel tür dönüştürme
	operatör" denilmiştir. Örneğin:

	int a = 10;
	int b = 4;
	double c;
	//...
	
	c = double(a) / b;

	Fonksiyonel tür dönüştürme operatörü işlev olarak C'nin tür dönüştürme operatörü gibidir. Yani yine static_cast, const_cast ve reinterpret_cast operatörlerinin
	bir birleşmi gibidir. Başka bir deyişle C tarzı tür dönüştürme operatörü ile yapılan hger şey fonksiyonel tür dönüştürmesi ile de yapılabilmektedir. 
	
	Fonksiyonel tarzda tür dönüştürmesinin önemli bir sentaks kısıtı vardır. Bu dönüştürmede dönüştürülecek türün tek atomdan oluşması gerekmektedir. Örneğin:

	double a = 12.345;
	unsigned long b;
	
	b = unsigned long(a);		// geçersiz! unsigned long iki atomdan oluşuyor

	Burada unsigned long türü iki atomdan oluştuğu için kullanım geçersizdir. Tabii unsigned long türünü typedef edip tek atomla ifade edersek bu durumda 
	dönüştürme geçeli olur:

	double a = 12.345;
	unsigned long b;
	typedef unsigned long ulong;

	b = ulong(a);

	Buradaki tek atom koşuluna dikkat ediniz:

	int a = 10;
	char *pc;

	pc = char *(&a);		// geçersiz! char * tek atomdam oluşmuyor

	Yine typedef işlemi ile bunu geçerli hale getirebiliriz:

	int a = 10;
	char *pc;
	typedef char *char_ptr;

	pc = char_ptr(&a);

	C++11 ile birlikte "uniform initializer syntax" dile eklenince fonksiyonel tarza tür dönüştümesinin küme parantezli versiyonu da oluşturuldu. T bir tür belirtmek 
	üzere T{ifade} sentaksı da fonksiyonel tarzda tür dönüştürmesi gibi kullanılabilmektedir. Ancak burada "uniform initializer syntax" dolayısıyla daraltıcı 
	dönüştürmelere izin verilmemektedir. Örneğin:

	int a = 10;
	int b = 4;
	double c;

	c = double{a} / b;		// geçersiz! int -> double dönüştürmesi daraltıcı bir dönüştürme
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10;
	int b = 4;
	double c;

	c = double(a) / b;
	cout << c << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											14. Ders 02/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	30) C'de fonksiyonlar ve diziler bütünsel olarak birer nesne kabul edilmektedir. Ancak fonksiyon isimleri bir ifade de kullanıldığında derleyici tarafından 
	otomatik olarak fonksiyonun başlangıç adresine dönüştürülmektedir. Aynı durum C'de diziler için de söz konusudur. Bir dizi ismini biz bir ifadede kullandığımızda 
	derleyici bu dizi nesnesini otomatik olarak dizinin başlangıç adresine (yani ilk elemanın adresine) dönüştürmektedir. O halde C'de bir fonksiyonun ismi ifade
	içerisinde kullanıldığında onun başlangıç adresini belirtmektedir. Pekiyi fonksiyon çağırma operatörünün operandı ne olmalıdır? C standartlarına göre fonksiyon 
	çağırma operatörünün operandı bir fonksiyon adresi olmalıdır. Dolayısıyla foo bir fonksiyon nesnesi olmak üzere foo(...) ifadesi aslında foo adresinden başlayan 
	fonksiyonun çağrılması anlamına gelmektedir. Öte yandan foo fonksiyon nesnesi ifade kullanıldığında zaten fonksiyon adresine dönüştürüldüğü için *foo ifadesi de
	yeniden fonksiyon nesnenin kendisi anlamına gelir. O halde fonksiyon nesnesi ifadede kullanıldığında fonksiyon adresine dönüştürüleceğine göre (*foo)(...) 
	geçerli olmaktadır. Aynı durum fonksiyon göstericilerinde de böyledir. pf bir fonksiyon göstericisi olmak üzere bu göstericinin gösterdiği yerdeki fonksiyon 
	pf(...) ifadesiyle ya da (*pf)(...) ifadesiyle de çağrılabilmektedir. Ayrıca C'de gerekmiyor olsa da bir fonksiyon nesnesinin adresi & operatöryle alınabilmektedir. 
	Örneğin pf bir fonksiyon göstericisi foo da onunla uyumlu bir fonksiyon olmak üzere aşağıdaki iki ifade eşdeğerdir:

	pf = foo;
	pf = &foo;
	
	C++ tasarım olarak C'yi kapsayacak biçimde oluşturulmuştur. Tabii bu kapsama mutlak değildir. Ancak C++ tasarlanırken özellikle ilk yıllarda C uyumunun korunmasına 
	çalışılmıştır. Ancak C++'ta referanslar da olduğu için durum biraz daha farklılışamaktadır. C++'ta bir fonksiyon türünden referanslar söz konusu olabilir. Tabii 
	böyle referanslar bir fonksiyon ile ilkdeğer verilerek tanımlanmalıdır. Örneğin:

	void foo()
	{
		cout << "foo" << endl;
	}
	//...

	void (&f)() = foo;

	f();

	Bu referans ifadesinin eşdeğer gösterici karşılığı şöyle oluşturulabilir:

	void (*f)() = &foo;

	(*f)();

	İşte C++'ta fonksiyon referansı ile fonksiyon göstericilerine ilkdeğer verirken aslında doğrudan fonksiyon isimleri kullanılabilmektedir. Ancak genel eğilim 
	(üye fonksiyon göstericilerinde zorunlı olan durum) fonksiyon göstericilerinde fonksiyonun adresinin programcı tarafından alınmasıdır. Örneğin:

	void (*pf1)() = foo;			// geçerli!
	void (*pf2)() = &foo;			// C++'a göre daha uygun 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	32) C++'a C++11 ile birlikte decltype isimli bir "tür belirleyicisi (type specifier)" eklenmiştir. decltype belirleyicisi parantez içerisinde bir ifade ile 
	kullanılmaktadır. Genel biçimi şöyledir:

	decltype(<ifade>)

	C++ statik tür sistemine sahip bir programlama dili olduğu için bir ifadenin türü derleme aşamasında derleyici tarafından belirlenebilmektedir. İşte decltype
	belirleyicisi bizim ona verdiğimiz ifadenin türünü belirtir. Yani decltype belirleyicisine bir ifade verdiğimizde aslında biz o ifadenin türünü belirtmiş gibi 
	oluruz. Örneğin:

	int a;
	const long b = 10;

	Burada decltype(a) int türünü, decltype(b) const long türünü, decltype(a + b) ise long türünü belirtmektedir. Biz tür bilgisi gereken her yerde decltype
	belirleyicisini kullanabiliriz. Örneğin:

	decltype(a) c;			// burada c int türünden
	decltype(b) d = 10;		// burada d const long türünden
	decltype(a + b) e;		// burada e long türden

	Örneğin:

	int foo(int a)
	{
		//...
	}
	//...
	
	decltype(&foo) pf;		// burada pf int (*)(int) türünden
	decltype(foo()) a;		// burada a int türden

	decltype belirleyicisinde parantezler içerisine bir fonksiyon ismi yazıldığında oluşturulan tür fonksiyon adres türü olmamaktadır. O fonksiyonun türü 
	olmaktadır. Dolayısıyla eğer parantezler içerisinde bir fonksiyon ismi bulundurulacaksa bu durumda gösaterici ya da referans oluşturmak için dekleratörde * 
	ya da & atomunun bulundurulması gerekmektedir. Örneğin:

	decltype(foo) *pf;		// burada decltype foo int(int) türünden bir fonksiyon belirtmektedir. 

	Aynı durum diziler için de söz konusudur. decltype belirleyicisinin parantezleri içerisinde bir dizi ismi verilirse decltype bu dizi türünü belirtir. 
	Örneğin:

	int a[10];

	decltype(a) b;		// int b[10] ie eşdeğer, yani b int[10] türünden

	Tabii decltype belirleyicinin parantezi içerisinde yazdığımız ifade çalıştırılmamaktadır. Derleyici yalnızca o ifadenin türüyle ilgilenmektedir. 

	Anımsanacağı gibi fonksiyon parametresi olarak dizi ya da fonksiyon dekleratörü kullanılırsa bu dekleratör gösterici belirtmektedir. Örneğin:

	void foo(int a[])
	{
		//...
	}

	Burada a int türden bir göstericidir. Örneğin:

	void bar(void f())
	{
		//...
	}

	Burada f geri dönüş değeri void olan parametresi olmayan bir fonksiyon göstericisidir. Tabii prototiplerde biz değişken isimlerini yazmak zorunda değiliz:

	void foo(int[]);
	void bar(void());

	Bu tür durumlarda decltype belirleyicisinden de faydalanılabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	void bar(decltype(foo) f)
	{
		//...
	}

	Buradaki bar fonksiyonunun tanımlanması aşağıdaki tanımlamayla eşdeğerdir:

	void bar(void f())
	{
		//...
	}

	Tabii dekleratörde açıkça gösterici de kullanabilirdik:

	void bar(decltype(foo) *f)
	{
		//...
	}

	Buradaki bar tanımlaması da aşağıdaki ile eşdeğerdir:

	void bar(void (*f)())
	{
		//...
	}

	Aynı tanımlamayı şöyle de yapabilirdik:

	void bar(decltype(&foo) f)
	{
		//...
	}

	decltype belirleyicisi fonksiyon adreslerine dönen fonksiyonların yazımını da kolaylaştırabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	void (*bar())()
	{
		//...

		return foo;
	}

	Burada bar geri dönüş değeri void parametresi olmayan bir fonksiyon adresine geri dönmektedir. Aynı tanımlamayı şöyle de yapabilirdik:

	decltype(foo) *bar()
	{
		//...

		return foo;
	}

	Ya da şöyle de yapabilirdik:

	decltype(&foo) bar()
	{
		//...

		return foo;
	}

	decltype belirleyicisine operand olarak sol taraf değeri oluşturan bir ifade verilirse bu durumda tür sol taraf değeri referansı olmaktadır. Örneğin:

	int a[1];
	int b = 10;

	decltype(a[0]) c = b;
    
	Burada c bir referanstır ve "int &" türündendir. decltype belirleyicisine operand olarak bir değişken ismi verilmesiyle sol taraf değeri oluşturan bir ifade
	verilmesi arasındaki farka dikkat ediniz:

	int a[0];
	int b;

	Burada decltype(a[0]) "int &" türünü, decltype(b) int türünü belirtmektedir. Bir ismi paranteze aldığımızda bir ifade oluşturduğuna göre burada decltype((a))
	da "int &" türünü belirtecektir.

	C++14 ile birlikte decltype belirleyicisi auto belirleyici ile birlikte de kullanılabilir hale getirilmiştir. Örneğin:

	int a;
	decltype(auto) b = a;

	decltype bu biçimde auto ile yalnızca bildirimlerde kullanılabilir ve decltype(auto) ile bildirilen değişkenlere ilkdeğer verilmek zorundadır. Örneğin:

	decltype(auto) x;		// geçersiz! ilkdeğer verilmemiş

	Örneğin:

	int a;
	decltype(auto) b = a;

	decltype(auto) ile auto arasında ince bir farklılık vardır. Normal olarak auto olarak bildirilmiş olan değişkene verilen ilkdeğer referans ise bildirilen değişken 
	referans olmaz. Örneğin:

	int a = 10;
    int &b = a;
    auto c = b;       // c int türden

	Ancak decltype(auto) ile bildirilen değişkene verilen ilkdeğer referans ise bildirilen değişken de referans olmaktadır. Örneğin:

	int a = 10;
    int &b = a;
    decltype(auto) c = b;       // c int türden referans yani int & türünden

	decltype(auto) özellikle fonksiyonların geri dönüş değerlerinde anlamlı bir biçimde kullanılmaktadır. Örneğin:

	decltype(auto) foo()
	{
		//...
	}

	Burada foo fonksiyonun return ifadesinde bir referans varsa fonksiyonun geri dönüş değeri de return ifadesindeki tür türünden bir referans olacaktır. Eğer 
	return ifadesinde bir referans yoksa bu durumda fonksiyonun geri dönüş değeri return ifadesindeki tür türünden olacaktır. Yukarıda da belirttiğimiz gibi 
	C++14 ile eklenen decltype(auto) belirleyicisi daha çok fonksiyonların geri dönüş değerlerinde karşımıza çıkmaktadır. Ancak bu konudaki örnekler şablon içeren
	nispeten karmaşık örneklerdir. Bu nedenle biz burada bu duruma örnek vermeyeceğiz. İlerideki konularda bununla ilgili örnekler verilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	32) C++11 ile birlikta C++'a NULL adres sabitini temsil eden nullptr anahtar sözcüğü eklenmiştir. Anımsanacağı gibi C'de NULL adres sabiti iki biçimde 
	belirtiliyordu:

	1) 0 değerini veren tamsayı türlerine ilişkin sabit ifadeleri
	2) 0 değerini veren tamsayı türlerine ilişkin sabit ifadelerinin void * türüne dönüştürülmüş hali. Örneğin (void *) 0 gibi.

	C++'ta NULL adres sabiti başından beri 0 değerini veren tamsayı türlerine ilişkin sabit ifadesi biçiminde oluşturulmaktaydı. (C++'ta void * türü diğer
	türlere otomatik biçimde dönüştürülmediği için NULL adres sabiti olarak kullanılmamaktadır.) C++'ta NULL sembolik sabiti de tipik olarak şöyle define edilmiştir:

	#define NULL	0

	Tabii standartlara bakılırsa NULL sembolik sabiti 0 değerini veren tamsayı türlerine ilişkin bir sabit ifadesi olarak da define edilebilir. 

	NULL adres her ne kadar 0 ile temsil ediliyor olsa da NULL adresin sayısal bileşeni derleyicileri yazanlar tarafından belirlenmektedir. Yani NULL adres 
	belleğin tepesindeki 0 adresi olmak zorunda değildir. NULL adres derleyici tarafından o sistemde kullanılmayan herhangi bir adres olabilir. Ancak yaygın 
	sistemlerin hemen hepsinde derleyiciler NULL adres olarak gerçekten belleğin tepesindeki 0 adresini almaktadır. 
	
	Örneğin:

	int *pi;

	pi = 0;		// pi'ye int 0 değil NULL adres değeri atanıyor

	Burada pi göstericisine 0 adresi atanmamaktadır. O sistemdeki NULL adres neyse o atanmaktadır. Benzer biçimde örneğin:


	if (pi == 0) {		// pi'nin içerisinde 0 adresi vr mı diye bakılmıyor, o sistemdeki NULL adres var mı diye baklılıyor
		//...
	}

	Burada da pi'nin içerisinde 0 adresi var mı diye kontrol yapılmamaktadır. O sistemdeki derleyicini belirlediği NULL adres var mı diye kontrol yapılmaktadır. 
	Örneğin:

	if (pi) {
		//...
	}

	Bu ifade C'de ve C++'ta aşağıdaki ile eşdeğer kabul edilmektedir:

	if (pi != 0) {
		//...
	}

	NULL adresin tamsayı 0 ile temsil edilmesi C'nin ilk zamanlarından beri problem yaratan bir durum olmuştur. İşte C++11 ile artık NULL adres için nullptr 
	isminde bir anahtar sözcü dile eklenmiştir. Örneğin:

	int *pi;

	pi = nullptr;		// C++11 ve sonrasında izlenmesi gereken iyi teknik

	Burada pi göstericisine yine o sistemde derleyicini belirlediği NULL adres atanmaktadır. nullptr anahtar sözcünün C++ standartlarında nullptr_t isimli bir 
	türden olduğu belirtilmektedir. Standartlar nullptr türünü şöyle açıklamıştır:

	typedef decltype(nullptr) nullptr_t;

	Burada biraz komik özyinelemeli bir anlatım uygulanmıştır. "nullptr nullptr_t türündendir. nullptr_t ise nullptr'nin türüdür". Özetle nullptr_t yalnızca nullptr 
	değerine sahip olan özel bir türdür. 

	C++11 ve sonrasında artık NULL adres sabiti için 0 yerine bu nullptr anahtar sözcüğünün kullanılması iyi bir teknik kabul edilmektedir. Bu anahtar sözcüğün 
	eklenmesiyle birlikte "overload resolution" mekaznizması bu bakımdan güçlendirilmiştir. 

	Null adresi temsil etmek için C23'e de aynı biçimde bir nullptr anahtar sözcüğünün eklenmesine karar verilmiştir. Belki de C'de en başından beri bu NULL adresin 
	bir anahtar sözcük ile temsil edilmesi gerekiyordu. Pascal, Java, C# diller çok önceleri NULL adres için bir anahtar sözcük kullanmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	33) typedef anahtar sözcüğü bir bildirime eklenebilir ve bildirimdeki değişkeni o değişkenin türüne ilişkin tür ismi haline getirir. C++11 ile birlikte bazı 
	nedenlerden dolayı alternatif bir typedef mekanizması da dile eklenmiştir. Buna "type alias" da denilmektedir. Bu alternatif typedef mekanizmasının genel biçimi 
	şöyledir:

	using <isim> = <sembolik tür>;

	Örneğin:

	using I = int;

	Bu aşağıdaki typedef bildirimi eşdeğer etki oluşturmaktadır:

	typedef int I;

	Örneğin:

	using STRA = const char *[5];

	Burada STRA türü 5 elemanlı her elemanı const char türünden bir gösterici olan diziyi temsil etmektedir. Yani:

	STRA names;

	bildirimi ile:

	const char *names[5];

	bildirimi eşdeğerdir. Örneğin:

	using PF = void (*)();

	Burada PF geri dönüş değeri void parametresi olmayan bir fonksiyon adres türünü temsil etmektedir. Yani:

	PF pf;

	bildiri ile aşağıdaki bildirim eşdeğerdir:

	void (*pf)();

	C'de ve C++'ta void anahtar sözcüğü de teknik olarak bir tür belirtmektedir. Örneğin:

	using VOID = void

	VOID *pv;

	Bu bildirim aşağıdaki ile eşdeğerdir:

	void *pv;

	Pekiyi C++11 ile birlikte neden böyle alternatif bir typedef mekanizması eklenmiştir? Öncelikle bu yeni mekanizma daha doğal bir görünüme sahiptir. typedef
	bildirimleri kişiler tarafından zor öğrenilmektedir. Ancak bu alternatif typedef mekanizmasının dile asıl yerleştirilme gerekçesi şablon konusunda sağladığı 
	kolaylıklardır. Bu mekanizma şablon mekanizması ile birlikte kullanılabilmektedir. Bu bağlamda çeşitli kolaylıklar sunmaktadır. Şablon mekanizması ileride ele 
	alınacaktır. 

	decltype belirleyicisi ise typedef ya da using tür bildirimi birlikte de kullanılabilmektedir. Örneğin:

	void foo()
	{
		//...
	}

	using FP = decltype(foo) *;

	FP bar()
	{
		//...

		return foo;
	}

	Ya da örneğin:

	typedef decltype(&foo) FP;

	FP bar()
	{
		//...

		return foo;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											15. Ders 04/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	34) C++'ta parametre değişkenleri default değer alabilmektedir. Fonksiyon çağrılırken default değer alan parametre değişkenleri için argüman girilmeyebilir. 
	Bu durumda sanki argüman olarak o default değerlerin girilmiş olduğu kabul edilir. Eğer default değer alan parametre değişkenleri için argüman girilmişse bu 
	durumda	bu default değerler dikkate alınmaz. Örneğin:

	void foo(int a, int b = 10, int c = 20)
	{
		//...
	}

	Burada a parametre değişkeni için argüman girilmek zorundadır. Ancak b ve c parametre değişkenleri için argüman girilmeyebilir. Default argümanın verilme
	biçimine dikkat ediniz. Önce parametre değişkeninin ismi sonra '=' atomu ve sonra default değer belirtilmektedir. Default değer alan parametre değişkenlerine 
	ilişkin fonksiyuonlar çağrıldığında aslında her zaman parametre değişkenleri için argüman ataması yapılmaktadır. Örneğin:

	foo(100, 200);

	Burada c parametre değişkeni için argüman belirtilmemiştir. Bu durumda c parametre değişkenine default olarak 20 değeri atanacaktır. Yani yukarıdaki çağrının
	eşdeğeri aşağıdaki gibidir:

	foo(100, 200, 20);

	Default argüman yalnızca çağrımı kolaylaştırmaktadır. Örneğin:

	foo(100, 200);

	Bu çağrının makine kodlarına bakıldığında aslında c paarametre değişkeni için 20 değerinin akratıldığı görülecektir. Yani verilen default değerlerin aktarımı 
	konusunda bir etkinlik söz konusu değildir. Buradaki fonksiyon her zaman üç parametreye sahiptir ve çağrım sırasında her zaman bu üç parametre için üç argüman 
	aktarılmaktadır. Yukarıdaki fonksiyonu aşağıdaki gibi çağırmış olalım:

	foo(100);

	Bu çağrının eşdeğeri şöyledir:

	foo(100, 10, 20);

	Bu örneğimizde a parametre değişkeni default değer almadığı için bu parametre değişkeni için argüman girilmesi zorunludur. 

	Bir fonksiyonun bütün parametre değişkenleri default değer alabilir. Örneğin:

	void foo(int a = 10, int b = 20, int c = 30)
	{
		//...
	}

	Böyle bir fonksiyonu biz argümansız da çağırabilirdik:

	foo();

	Bu çağrının eşdeğeri şöyledir:

	foo(10, 20, 30);

	Bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer almış olması gerekmektedir. Örneğin:

	void foo(int a = 10, int b, int c = 20)			// geçersiz!
	{
		//...
	}

	Burada yukarıda belirttiğimiz kurala uyulmamıştır. a parametre değişkeni default değer aldığı için onun sağındakilerin hepsinin default değer alması gerekirdi.
	Bu kural şöyle ifade edilebilir: Default değer alan parametre değişkenleri parametre listesinin sağında birikmiş olmalıdır. Eğer yukarıdaki gibi bir durum 
	geçerli olsaydı aşağıdaki gibi bir sentaksın da geçerli olması gerekirdi:

	foo(100, , 200);		// böyle bir sentaks yok!

	Halbuki böyle bir sentaks yoktur.

	Parametre değişkenlerine verilen ilkdeğerler tipik olarak sabit ifadesi olmaktadır. Ancak global değişkenler ve hatta fonksiyonlar da bu ilkdeğer vermede 
	kullanılabilmektedir. (Sınıflar konusuna geldiğimizde üye fonksiyonlar için sınıfın veri elemanları da ilkdeğer vermede kullanılabilmektedir.)
	Örneğin:

	int g_x = 10;

	void foo(int a = g_x + 1)		// geçerli
	{
		//...
	}

	Ancak verilen ilkdeğerde önceki parametre değişkenleri kullanılamamaktadır. Örneğin:

	void foo(int a, int b = a + 1)		// geçerli değil!
	{
		//...
	}

	Örneğin parametre değişkenine verilen default değer bir string olabilir:

	void putmsg(const char *msg = "Ok")
	{
		cout << msg << endl;
	}
	//...
	
	putmsg("invalid command");
	putmsg();

	Parametre değişkenine verilen default değer fonksiyon çağrısının geri dönüş değeri ile ilişklili de olabilir. Örneğin:

	int square(int a)
	{
		return a * a;
	}

	void bar(int a = square(10))
	{
		//...
	}

	Tabii parametre değişkenlerine aslında fonksiyon çağrısı sırasında değer atanmaktadır. Yani parametre değişkeni örneğin global bir değişkene bağlı ise 
	global değişkenin son değeri işleme sokulacaktır. Örneğin:

	int g_x = 10;

	void foo(int a = g_x + 1)
	{
		//...
	}
	//...

	foo();

	Buradaki çağrının eşdeğeri şöyledir:

	foo(g_x + 1);

	Dolayısıyla a parametre değişkenine 11 değeri kopyalanacaktır. Örneğin:

	g_x = 20;

	foo();

	Buradaki çağrının da eşdeğeri yukarıdaki gibi olduğuna göre o anca g_x global değişkeninin değeri kullanılacağından a parametre değişkenine 21 kopyalanacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a = 100, int b = 200)
{
    cout << "a = " << a << ", b = " << b << endl;
}

int main(void)
{
    foo();              // foo(100, 200)
    foo(10);            // foo(10, 100)
    foo(10, 20);        // foo(10, 20)

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Default değer alan parametre değişkenlerine sahip fonksiyonlarda default değerler prototipte belirtilebilirler (genellikle böyle yapılır). Default değerler
	hem prototipte hem de tanımlamada belirtilemezler. Ya prototipte (tercih böyle olmalıdır) ya da tanımlamada belirtilmelidirler. Örneğin:

	void foo(int a = 10, int b = 20);
	void bar(double = 3.14);

	void foo(int a = 10, int b = 20)		// error!
	{
		//...
	}

	void bar(double a)						// geçerli
	{
		//...
	}

	Yukarıda da belirttiğimiz gibi eğer prototip bulunduruluyorsa default değerlerin prototipte belirtimesi tanımlama sırasında belirtilmemesi iyi tekniktir. 
	Örneğin:

	void foo(int a = 10, int b = 20, int c = 30);
	//...

	void foo(int a, int b, int c)
	{
		//...
	}

	Tabii prototiplerde de bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer alması gerekir. Örneğin:

	void foo(int a = 10, int b, int c = 20);		// geçersiz prototip!

	Prototiplerde değişken ismi belirtilmeyebileceğine göre aşağıdaki prototipler biraz tuhaf gözükmekle birlikte geçerlidir:

	void foo(int = 10, int = 20, int = 30);		// tuhat ama geçerli

	Standartlara göre bir paramere değişkenine yalnızca bir kez default değer verilebilir. Amcak bazı default değerler prototipte, bazıları ise tanımlama sırasında 
	da belirtilebilmektedir. Örneğin aşağıdaki bildirimler geçerlidir:

	void foo(int a, int b = 10, c = 30);

	void foo(int a = 20, int b, int c)		// geçerli, ama kötü teknik!
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void dispmsg(const char *msg = "Ok");

int main(void)
{
    dispmsg();
    dispmsg("error");

    return 0;
}

void dispmsg(const char *msg)
{
    cout << msg << endl;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Parametre değişkenlerine verilen default değerlerin yaygın kullanılan değerlerden olması gerekir. Aksi takdirde parametre değişkenin default değer almasının 
	bir anlamı kalmaz. Parametre değişkenlerine herhangi bir değeri default değer olarak vermek kötü bir tekniktir. Örneğin:
	
	int add(int a = 10, int b = 20)
	{
		return a + b;
	}

	Burada verilen default değerlerin diğer değerlerden hiçbir farkıyoktur. Dolayısıyla böyle bir kullanım kötü bir tekniktir. Bu biçimde verilen ilkdeğerler bir 
	anlam ifade etmediği gibi kodu inceleyenleri de yanlı yönlendirebilmektedir. Fakat örneğin:

	void disp_number(int a, int base = 10);

	Burada fonksiyonun ikinci parametresi birinci parametresindeki int değerin kaçlık sistemde ekrana yazdırılacağını belirtiyor olsun. Burada verilen default değer
	anlamlıdır. 

	Parametre değişkenlerinin default değer alması kullanım kolaylığı da sağlamaktadır. Bazen fonksiyonların çok fazla parametresi olabilir. Fonksiyonu çağıran 
	kişi bu detayları bilmek istemeyebilir. Böylece default değer almış parametreler programcı argüman girmez. Onlar için makul değerler fonksiyonu yazanlar tarafından 
	zaten kullanılmış durumdadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen parametre değişkenine verilen default değer aslında o parametre değişkeni için argüman girilmediğini tespit etmekte kullanılmaktadır. Programcı asıl 
	default değeri başka bir biçimde elde ediyor olabilmektedir. Örneğin:

	void disp_date(int day = 0, int month = 0, int year = 0);

	Burada aslında parametre değişkenlerine verilen 0 değeri çok kullanıldığı için verilmemiştir. Fonksiyonun default değerle çağrılıp çağrılmadığını anlamak 
	için verilmiştir. Örneğin:

	void disp_date(int day = 0, int month = 0, int year = 0)
	{
		auto t = time(nullptr);
		tm *pt;

		pt = localtime(&t);

		if (!day)
			day = pt->tm_mday;
	
		if (!month)
			month = pt->tm_mon + 1;

		if (!year)
			year = pt->tm_year + 1900;

		cout << day << '/' << month << '/' << year << endl;
	}

	Burada eğer ilgili parametre için argüman girilmemişse o anda içinde bulunulan tarihe ilişkin değer kullanılmıtr. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

void disp_date(int day = 0, int month = 0, int year = 0)
{
	auto t = time(nullptr);
	tm *pt;

	pt = localtime(&t);

	if (!day)
		day = pt->tm_mday;
	
	if (!month)
		month = pt->tm_mon + 1;

	if (!year)
		year = pt->tm_year + 1900;

	cout << day << '/' << month << '/' << year << endl;
}

int main()
{
	disp_date();
	disp_date(12);
	disp_date(12, 10);
	disp_date(12, 10, 2020);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	35) Anımsanacağı gibi C'de statik ömürlü (yani global ve statik yerel) nesnelere verilen ilkdeğerlerin sabit ifadesi olması zorunludur. Örneğin aşağıdaki gibi
	bir global değişken tanımalması C'de geçerli değildir:

	int square(int a)
	{
		return a * a;
	}

	int g_x = square(10);		// C'de geçersiz!

	Bu kuralın gerekçesi statik ömürlü nesnelerin ilkdeğerleriyle birlikte amaç dosyaya ve çalıştırılabilir dosyaya yazılması zorunluluğudur. Dolayısıyla derleyicinin 
	derleme aşamasında statik ömürlü nesnelere verilen ilkdeğeri belirlemiş olması gerekmektedir. Ancak C++'ta böyle bir zorunluluk yoktur. Yani C++'ta statik ömürlü 
	nesneleri sabit ifadeleriyle ilkdeğer verilmesi zorunlu değildir. Yukarıdaki kod C'de geçersiz olduğu halde C++'ta geçerlidir. 
	
	Pekiyi C++'ta statik ömürlü nesnelere nasıl ilkdeğer verilmektedir? Aslında bir C programında ve C++ programında akışın başlatıldığı yer main fonksiyonu değildir. 
	Akış derleyicilerin yerleştirdiği ismine "start-up code" denilen bir koddan başlatılır. Bu kod main fonksiyonunu çağırmaktadır. main bitince akış yine start-up 
	code döner. Zaten exit fonksiyonu da start-up code tarafından çağrılmaktadır. Startup-up code'un temsili şöyledir:

	...
	...				<Start-up code>
	...
	status = main()
	exit(status)

	İşte C++'ta eğer global değişkenlere sabit ifadesi ile ilkdeğer verilmemişse bu ilkdeğer verme işlemi main fonksiyonundan önce start-up code tarafından yapılmaktadır. 
	Bunun basit bir sınaması aşağıdaki programla yapılabilir:

	#include <iostream>

	using namespace std;

	int square(int a)
	{
		cout << "square" << endl;

		return a * a;
	}

	int g_x = square(10);


	int main()
	{
		cout << "main" << endl;

		cout << g_x << endl;

		return 0;
	}

	Program çalıştırıldığında ekrana (stdout dosyasına) şunlar basılacaktır:

	square
	main
	100

	C++ standartlarına göre global değişkenlere verilen aynı kaynak dosya (translation unit) için yukarıdan aşağıya doğru ilkdeğerleri verilmektedir. Ancak 
	proje birden fazla kaynak dosyadan oluşuyorsa bunların birbirlerine göre durumu hakkında bir sıra belirtilmemektedir. 

	Statik yerel değişkenlere sabit ifadeleriyle ilkdeğer verilmemişse eğer fonksiyon çağrılmışsa ve yalnızca ilk çağrıldığında akış ilkdeğer verme noktasına 
	geldiğinde bu ilkdeğer verme işlemi gerçekleştirilmektedir. Aşağıdaki program kuralın test edilmesinde kullanılabilir:

	#include <iostream>

	using namespace std;


	int square(int a)
	{
		cout << "square" << endl;

		return a * a;
	}

	void foo()
	{
		cout << "foo" << endl;

		static int x = square(10);

		cout << x << endl;
	}

	int main()
	{
		foo();
		foo();

		return 0;
	}

	Eğer burada foo hiç çağrılmasaydı square fonksiyonu da çağrılmayacaktı. foo birden fazla kez çağrıldığında yalnızca ilk çağırmada toplamda bir kez square
	çağrılacaktır. Akış statik yerel değişkenin tanımlandığı noktaya gelmezse square zaten hiç çağrılmayacaktr.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	36) C'de fonksiyon tanımlamada parametre değişkenlerine isim verilmesi zorunludur. Ancak C++'ta böyle bir zorunluluk yoktur. Örneğin:

	void foo(int)		// C'de geçersiz, C++'ta geçerli
	{
		//...
	}

	Tabii parametre değişkenine isim verilmemesi onun kullanılamayacağı anlamına da gelmektedir. C++'ta parametre değişkenine isim verilmemiş olsa da çağırma 
	sırasında yine onun için argüman tedarik edilmek zorundadır. Örneğin:

	void foo(int)
	{
		//...
	}
	//...

	foo();		// geçersiz!
	foo(10)		// geçerli

	Yine isimsiz parametreler için default argüman belirtilebilmektedir. Ancak bu durum genel olarak bir faydaya yol açmamaktadır. Örneğin:

	void foo(int = 10)			// geçerli ama tuhaf
	{
		//...
	}

	İsim verilmemiş parametre değişkenlerinin parametre listesinin sonunda toplanması gibi bir zorunluluk yoktur. Örneğin:

	void foo(int a, int, int b)		// geçerli
	{
		//...
	}

	Parametre değişkenlerine isim verilmemesi onların programcı tarafından kullanılamamasına yol açmaktadır. Pekiyi neden programcı böyle bir şeyi tercih etsin?
	İşte bazen programcının aynı parametrik yapıya sahip birden fazla fonksiyon tanımlaması gerekebilmektedir. Bu tür durumlarda kullanılmayan ama sözde (dummy)
	bir parametre değişkenine gereksinim duyulmaktadır. Sonraki paragrafta fonksiyonların overload edilmeleri konusu ele alınmaktadır. 

	Tabii mademki isim verilmemiş parametre değişkenleri aslında fonksiyon tarafından kullanılamamaktadır. O halde optimizasyon sırasında derleyici o parametre
	değişkeni için bazı koşullar da sağlanıyorsa agrüman parametre aktarımını hiç yapmayabilir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											16. Ders 09/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    37) C++'ta parametrik yapıları farklı olmak koşuluyla aynı faaliyet alanında aynı isimli birden fazla fonksiyon bulunabilir. Bu duruma İngilizce "function 
	overloading" denilmektedir. Halbuki C'de hiçbir durumda aynı isimli birden fazla fonksiyon bulunamamaktadır. Parametrik yapıların farklı olması demek parametrelerin 
	türce veya sayıca farklı olması demektir. Parametre değişkenlerinin isimlerinin ve fonksiyonların geri dönüş değerlerinin türlerinin bu bağlamda bir önemi yoktur. 
	Önemli olan parametre değişkenlerinin türlerinin ya da sayılarının farklı olmasıdır. Örneğin aşağıdaki foo fonksiyonları C++'ta birlikte bulunabilir:

	void foo(int a)
	{
		//...
	}

	void foo(double a)
	{
		//...
	}

	void foo(int a, int b)
	{
		//...
	}

	void foo()
	{
		//...
	}

	Ancak aşağıdaki fonksiyonlar bir arada bulunamazlar:

	void bar(int a)
	{
		//...
	}

	void bar(int b)
	{
		//...
	}

	int bar(int c)
	{
		//...
	}

	Fonkisyonların geri dönüş değerlerinin farklı olması bu bağlamda dikkate alınmamaktadır. Yani parametrik yapısı aynı olan ancak geri dönüş değerleri farklı 
	olan aynı isimli fonksiyonlar bir arada bulunamazlar. Örneğin:

	void foo(int a, int b)
	{
		//...
	}

	int foo(int a, int b)		// geçersiz! overload edilemez
	{
		//...
	}

	Buradaki iki foo fonksiyonu overload edilemez. Çünkü bu iki fonksiyonun parametrik yapısı aynıdır. Bunların geri dönüş değerlerinin farklı olması bu bağlamda
	bir farklılık oluşturmamaktadır.

	Farklı parametrik yapılara ilişkin aynı isimli fonksiyonların bulunabilmesi özelliği yalnızca C++'ta değil diğer nesne yönelimli programlama dilelrini büyük 
	bölümünde de vardır. Örneğin bu özelliğe Java ve C#'ta "method overloading" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyon ismi ve parametre türlerinin oluşturduğu dizilime "fonksiyonun imzası (function signature)" da denilmektedir. Örneğin:

	void foo(int *pi, int size)
	{
		//...
	}

	Burada fonksiyonun imzası "foo, int *, int" biçimindedir. İmzaya parametre değişkenlerinin isimlerinin ve fonksiyonun geri dönüş değerinin dahil edilmediğine 
	dikkat ediniz. Örneğin:

	int bar(int a, long b)
	{
		//..
	}

	Burada bar fonksiyonunun imzası "bar, int, long" biçimindedir. 

	O halde overload edilme kuralını şu biçimde de ifade edebiliriz: "Aynı faaliyet alanı içerisinde aynı imzaya sahip olan birden fazla fonksiyon tanımlanamaz,
	ancak farklı imzalara sahip fonksiyonlar tanımlanabilir." 

	Fonksiyon imzasının bir küme değil bir dizilim belirttiğine dikkat ediniz. Aşağıdaki iki fonksiyonun imzası farklıdır, dolayısıyla bu fonksiyonlar overload
	edilebilirler:

	void foo(int a, long b)		// imza: foo, int, long
	{
		//...
	}

	void foo(long a, int b)		// imza: foo, long, int
	{
		//...
	}

	Tabii türlerin typedef ya da using isimleri değil onların gerçek türleri imzayı oluşturmaktadır. Örneğin:

	void foo(size_t size)
	{
		//...
	}

	void foo(unsigned a)
	{
		//...
	}

	Burada eğer size_t türü ilgili sistemde unsigned int olarak typedef edilmişse bu iki fonksiyonun imzası aynı olur. Dolayısıyla overload edilemez. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türlerdeki "üst düzey const ve volatile niteleyicileri (top level cv qualifiers)" türleri farklılaştırmamaktadır. Yani fonksiyonun imzası oluşturulurken üst 
	düzey const ve volatile niteleyicileri atılmaktadır. Üst düzey const ve volatile niteleyicileri "nesnenin kendisini niteleyen" const ve volatile niteleyicileridir. 
	Örneğin:

	const int a = 10;						// buradaki const üst düzey
	const volatile int b = 20;				// buradaki const ve volatile üst düzey
	const int *pi;							// buradaki const üst düzey değil
	const char * volatile str;				// buradaki volatile üst düzey, const üst düzey değil
	const char * const *names;				// buradaki her iki const da üst düzey değil

	Referanslardaki const ve volatile niteleyicileri referansların kendilerine ilişkin olmadığı için üst düzey değildir. Zaten referanslarda üst düzey const ve volatile 
	oluşturulamamaktadır. Örneğin:

	int a = 10;
	const int &r = a;		// buradaki const üst düzey değil
	
	Örneğin:

	void foo(int a)
	{
		//...
	}

	void foo(const int a)
	{
		//...
	}

	Burada iki foo fonksiyonunun imzaları aynıdır. Dolayısıyla aynı anda bulunamazlar. Ancak üst düzey olmayan const ve volatile niteleyicileri türleri 
	farklılaştırmaktadır. Yani fonksiyonun imzasında üst düzey olmayan const ve volatile belirleyicileri korunmaktadır. Örneğin:

	void foo(int *pi, int size)				// imza: foo, int *, int
	{
		//...
	}

	void foo(const int *pi, int size)		// imza: const int *, int
	{
		//...
	}

	Burada ilk fonksiyonun imzası "foo, int *, int" ikinci fonksiyonun imzası "foo, const int *, int" biçimindedir. Aynı durum referanslar için de söz konusudur. 
	Örneğin:

	void foo(int a)					// imzası: foo, int
	{
		//...
	}

	void foo(int &r)				// imzası: foo, int &
	{
		//...
	}

	void foo(const int &r)			// imzası: foo, const int &
	{
		//...
	}

	Buradaki üç foo fonksiyonunun da parametrik yapıları dolayısıyla imzaları farklıdır. Overload işlemi geçerlidir. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonlardaki default argümanlar imzayı etkilememektedir. Örneğin:

	void foo(int a, int b = 10)
	{
		//...
	}

	void foo(int a)		// parametrik yapılar yani imzalar farklı, overload işlemi geçerli
	{
		//...
	}

	Bu iki fonksiyonun parametrik yapıları yani imzaları farklıdır. Birinci fonksiyonun inzası "foo, int, int" ikinci fonksiyonun imzası ise "foo, int"
	biçimindedir. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

 /*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Amaç dosya formatlarında (object file formats) aynı isimli birden fazla global sembol bulunamamaktadır. Bu durumda C++ derleyicileri overload edilmiş 
	fonksiyonların isimlerini mecburen onların parametre türleriyle kombine ederek amaç dosyaya yazmaktadır. Genel olarak bir global sembolün isminin değiştirilerek
	amaç dosyaya yazılmasına İngilizce "name decoration" ya da "name mangling" denilmektedir. Böylece programcı fonksiyonlara aynı isimleri vermiş olsa da aslında 
	C++ derleyicisi onları farklı isimlerle amaç dosyaya yazmaktadır. C++ standartları "name decoration" konusunda herhangi bir belirlemede bulunmamıştır. Yani 
	bu konu tamamen derleyicileri yazanların isteğine bırakılmıştır. Derleyiciler arasında "name decoration" bakımından önemli farklılıklar bulunabilmektedir. 
	Genellikle C++ programcılarının bu konunun ayrıntılarını bilmesine gerek yoktur. Ancak sembolik makine dilinde C++ için fonksiyon yazanların mecburen bu durumun
	farkında olması gerekmektedir. Aslında "name decoration" C'de uygulanabilmektedir. Örneğin Microsoft C derleyicileri global sembollerin başın "_" öneki getirerek 
	onu amaç koda yazmaktadır. Yine 32 bit sistemlerde Microsoft değişik "fonksiyon çağırma biçimlerine (calling convention)" değiik isim dekorasyonu kullanmaktadır. 

	Aşağıdaki bağlantıda Microsoft C++ derleyicilerinin uyguladığı isim dekoroasyonu hakkında ayrıntılı bilgiler verilmektedir:

	https://en.wikiversity.org/wiki/Visual_C%2B%2B_name_mangling

	g++ ve clang++ derleyicilerinin isim dekorasyonları için de aşağıdaki bağlantıyı kullanabilirsiniz:

	https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli bir fonksiyon çağrıldığında o fonksiyonlardan hangisinin çağrıldığının tespit edilmesi sürecine İngilizce "overload resolution" denilmektedir. 
	Overload resolution işleminin bazı ayrıntılı kuralları vardır. Ancak overload resolution işlemi en basit haliyle şöyledir: "Çağrılma ifadesindeki argümanların 
	türleriyle tam uyuşan bir fonksiyon varsa o fonksiyon çağrılır." Örneğin:
	
	void foo(int a)		
	{
		cout << "int" << endl;
	}

	void foo(long a)	
	{
		cout << "long" << endl;
	}

	void foo(double a)
	{
		cout << "double" << endl;
	}

	void foo(const char *str)
	{
		cout << "const char *" << endl;
	}

	Burada biz foo fonksiyonunu şöyle çağırmış olalım:

	foo(10);

	10 int türdne bir sabittir. Dolayısıyla argüman int türdendir. O halde int paranetreye sahip olan foo fonksiyonu çağrılacaktır. Örneğin:

	foo(3.14);

	3.14 double türdendir. O halde double türden parametreye sahip olan foo fonksiyonu çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a)
{
	cout << "int" << endl;
}

void foo(long a)
{
	cout << "long" << endl;
}

void foo(double a)
{
	cout << "double" << endl;
}

void foo(int a, int b)
{
	cout << "int, int" << endl;
}

void foo(const char *str)
{
	cout << "const char *" << endl;
}

int main()
{
	long x = 100;

	foo(10);			// int
	foo(10.2);			// double
	foo("ankara");		// const char *
	foo(x);				// long
	foo(10, 20);		// int, int

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi ya çağrılma ifadesindeki argümanların türleriyle tam bir uyuşma gösteren fonksiyon yoksa ne olacaktır? İşte bu durumda iki sonuç oluşabilir. Birincisi 
	çağırma işlemi geçersiz olabilir. Yani çağırma error ile sonuçlanır. İkincisi mevcut aynı isimli fonksiyonlardan bir tanesi "kötünün iyisi" olarak seçilir. 
	Bu noktada "overload resolution" sürecinin ayrıntıları devreye girmektedir. İzleyen paragraflarda ayrıntılı kurallar açıklanacaktır. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Derleyici tarafından yapılan dönüştürmelere "otomatik tür dönüştürmeleri (implicit type conversions)" denilmektedir. Overload resolution sürecinin ayrıntılarını 
	anlayabilmek için otomatik (implicit) tür dönüştürmeleri arasındaki kalite farklılıklarının bilinmesi gerekir.

	T1, T2 ve T3 birer tür belirtmek üzere T1 -> T3 dönüştürmesi ile T2 -> T3 dönüştürmesi arasında bir iyiilk kıyaslaması yapıldığında üç durum söz konusu olabilir:

	1) T1 -> T3 dönüştürmesi T2 -> T3 dönüştürmesinden daha iyi olabilir. 
	2) T2 -> T3 dönüştürmesi ile T1 -> T3 dönüştürmesinden daha iyi olabilir
	3) T1 -> T3 dönüştürmesi ile T2 -> T3 dönüştürmelerinden hiçbiri diğerinden iyi ya da kötü olmayabilir. 

	Örneğin:

	int -> long
	char -> long

	Burada T1 türü int türünü, T2 türü char türünü ve T3 türü de long türünü temsil etmektedir. C++ standartlarına göre bu iki dönüştürme arasında bir kalite farklılığı 
	yoktur. Örneğin:

	char -> int
	long -> int

	C++ standartlarına göre char -> int dönüştürmesi long -> int dönüştürmesinden daha iyidir. 

	Otomatik dönüştürmeler arasındaki kalite farklılıkları iyiden kötüye doğru şöyle sıralanmaktadır:

	1) Tam Uyum (Exact Match): Üst düzet const ve volatile belirleyicileri atıldıktan sonra iki tür birbirinin aynısı ise tam uyum söz konusudur. Örneğin:

	int -> int
	const int -> int
	int -> volatile int
	double -> double

	2) Int Türüne Yükseltme Dönüştürmesi (Ineteger Promotion Conversion) ya da Double Türüne Yükseltme Dönüştürmesi (Floating Point Promotion): Bilindiği gibi 
	int türünden küçük olan türlerin int türüne dönüştürülmesine standartlarda "integer promotion" ya da "integral promotion" denilmektedir. Benzer biçimde float
	türünden double türüne dönüştürmeye de "floating point promotion" denilmektedir. Örneğin:

	char -> int
	shor -> int
	float -> double

	3) Nümerik Dönüştürmeler (Numeric Conversions): Yukarıdaki durumların dışında kalan temel nümerik türler arasındaki dönüştürmelerdir. Örneğin:

	int -> long
	char -> long
	long -> int
	char -> long
	double -> float

	4) Kullanıcı Tanımlı Dönüştürmeler (User Defined Conversion): Bu dönüştürmeler sınıflar konusu ile ilgilidir. Burada üzerinde durmayacağız. 

	O halde artık T1 -> T3 ve T2 -> T3 dönüştürmelerinin kıyaslamasını yapabiliriz. Örneğin:

	char -> int
	long -> int

	Burada char -> int dönüştürmesi daha iyidir. Örneğin:

	float -> double
	int -> double

	Burada float -> double dönüştürmesi daha iyidir. Örneğin:

	float -> long double
	int -> long double

	Burada iki dönüştürme de aynı kalitededir. Örneğin:

	int -> double
	long -> double

	Burada da iki dönüştürme aynı kalitededir. Örneğin:

	short -> long
	int -> long

	Burada da iki dönüştürme aynı kalitededir. 
	
	Java ve C# ile C++ bu bakımdan farklılıklar göstermektedir. Örneğin bu dillerde int -> long dönüştürmesi shprt -> lng dönüştürmesinden daha iyi kabul edilmektedir. 
	Bu dillerden geçenler bu durumlara dikkat etmemlidirler. 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çağrılma ifadesindeki argümanların türleriyle tam uyuşan bir fonksiyon yoksa derleyici bazı kurallara göre mevcut fonksiyonların içerisinden birini seçebilmektedir
	ya da çağrıyı geçersiz kabul edebilmektedir. İşte bu noktada "overload resolution" işleminin bazı ayrıntıları devreye girmektedir. Şimdi bu ayrıntılar üzerinde 
	duracağız. 
	
	Overload resolution işlemi üç aşamada yürütülmektedir:

	1) Önce aday fonksiyonlar (candidate functions) belirlenir.
	2) Aday fonksiyonların içerisinden uygun olan (viable) fonksiyonlar seçilir. 
	3) Uygun olan fonksiyonlar arasından en uygun olan (the best viable) fonksiyon seçilmeye çalışılır. 

	Eğer en uygun fonksiyon varsa ve bir tane ise overload resolution işlemi başarıyla sonuçlandırılır. En uygun fonksiyon yoksa ya da birden fazla ise overload 
	resolution işlemi başarısızlıkla sonuçlanacaktır.

	Overload resolution işlemini iş yerine personel alımı için işletilen sürece benzetebiliriz. Önce kişiler CV'lerini gönderirler. Bunlar adaylardır. Onların 
	arasından uygun olanlar seçilir ve mülakata çağrılır. Onların arasından da en uygun kişi seçilmeye çalışılır. 

	1) İlgili faaliyet alanında çağrılma ifadesi ile aynı isimli olan tüm fonksiyonlar aday fonksiyonlardır. Yani bir fonksiyonun aday olması için isminin aynı olması 
	yeterlidir. 

	2) Çağrılma ifadesindeki argümanların sayısı ile aynı sayıda parametre değişkenine sahip olan ve her argümandan parametre değişkenine otomatik (implicit) tür 
	dönüştürmesinin mümkün olduğu fonksiyonlar uygun (viable) fonksiyonlardır. (Yani uygun fonksiyon demek "eğer bu fonksiyon tek başına bulunsaydı çağrılabilirdi" 
	demektir.) Bir aday fonksiyonunun uygun olabilmesi için argümanlarla aynı sayıda parametre değişkenine sahip olması ve argümanlardan parametre değişkenlerine 
	otomatik dönüştürmenin mümkün olması gerekmektedir. Fonksiyonun n tane parametresi olduğunu ve fonksiyon k tane argümanla çağrıldığını varsayalım. Bu k tane 
	argümanın hepsinden n tane parametrenin ilk k tanesi ile otomatik dönüştürme mümkün olsun. Eğer fonksiyonun n - k tane parametresi defult değer alıyorsa bu 
	fonksiyon da uygun fonksiyondur. Benzer biçimde fonksiyonun k + 1'inci parametresi ya da default değer almış olan parametrelerin sonundaki 
	parametresi "... (ellipsis)" biçimindeyse bu fonksiyon da uygun fonksiyondur. 

	3) En uygun fonksiyon "her argüman parametre deönüştürmesi diğer uygun fonksiyonlara göre ya daha iyi olan ya da daha kötü olmayan" fonksiyondur. Eğer böyle tek bir 
	fonksiyon varsa o fonksiyon en uygun (best viable) fonksiyon olarak seçilir. Eğer bu biçimde birden fazla fonksiyon varsa ya da hiçbir fonksiyon yoksa çağırma 
	işlemi geçersizdir ve error ile sonuçlanır. 

	Örneğin aşağıdaki gibi overload edilmiş foo fonksiyonları olsun:

	void foo(int a, int b)						// 1
	{
		cout << "int, int" << endl;
	}

	void foo(int a, double b)					// 2
	{
		cout << "int, double" << endl;
	}

	void foo(double a, double b)				// 3
	{
		cout << "double, double" << endl;
	}

	void foo(const char *str, double a)			// 4
	{
		cout << "int, double" << endl;
	}

	void foo(int a)								// 5
	{
		cout << "int" << endl;
	}

	void bar(int a)								// 6
	{
		cout << "bar int" << endl;
	}

	Biz de bu fonksiyonu aşağıdaki gibi çağırmış olalım:

	foo(12.3f, 3.2f);

	Burada 1, 2, 3, 4 ve 5 numaralı fonksiyonlar aday fonksiyonlardır. Ancak yalnızca 1, 2 ve 3 numaralı fonklsiyonlar uygun fonksiyonlardır. Bu 1, 2 ve üç 
	numaralı fonksiyonları çağrılma ifadesindeki her argüman parametre dönüştürmesi için birbirleriyle kıyazlayalım. Birinci argüman-parametre dönüştürmesi 
	şöyledir:

	float ->int			// 1
	float -> int		// 2
	float -> double		// 3

	Burada 3 numaralı fonksiyonun birinci argüman parametre dönüştürmesi diğer uygun fonksiyonlardan daha iyidir. Şimdi ikinci argüman-parametre dönüştürmesine 
	bakalım:

	float -> int		// 1
	float -> double		// 2
	float -> double		// 3

	Burada da 2 ve 3 numaralı fonksiyonlar eşit iyiliktedir ancak daha kötü değildir. O halde "tüm argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da 
	daha kötü olmayan" fonksiyon 3 numaralı fonksiyondur. Oberload resolution işleminden bu fonksiyon seçilecektir. 

	Şimdi çağrısının şöyle yapıldığını varsayalım:

	foo('a', 2.3f);

	Bu durumda yine 1, 2 ve 3 numaralı fonksiyonlar uygun fonksiyonlardır. "Her argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da dha kötü olmayan"
	bir fonksiyon vardır. O da 2 numaralı fonksiyondur. Bu durumda overload resolution işleminden 2 numaralı fonksiyon seçilecektir. 

	Çağrının şöyle yapılmış olduğunu varsayalım:

	foo(3.14, 10);

	Burada 3 numaralı fonksiyonun birinci argüman-parametre dönüştürmesi diğerlerinden daha iyidir. Ancak ikinci argüman-parametre dönüştürmesi 1 numaralı fonksiyondan 
	kötüdür. Benzer biçimde 1 numaralı fonksiyonun da nirinci argüman-parametre dönüştürmesi 3 numaralı fonksiyondan kötüdür. O halde burada "tüm argüman-parametre 
	dönüştürmeleri diğerlerinden daha iyi olan ya da daha kötü olmayan" bir fonksiyon yoktur. Dolayısıyla overload resolution işlemi error ile sonuçlanacaktır. 
	Bu tür error durumlarına İngilizce "ambiguity error" de denilmektedir. 

	Aşağıdaki gibi iki bar fonksiyonu olsun:

	void bar(int a, long b)
	{
		//...
	}

	void bar(long a, int b)
	{
		//...
	}

	Biz de fonksiyonu şöyle çağırmış olalım:

	bar(10, 20);

	Burada da en uygun fonksiyon bulunamamaktadır. Şimdi aşağıdaki foo fonksiyonları bulunyor olsun:

	void foo(double a, double b)
	{
		//...
	}

	void foo(float a, float b)
	{
		//...
	}

	foo(10, 20);

	Burada "her argüman-parametre dönüştürmesi diğerlerinden daha iyi olan ya da daha kötü olmayan" iki fonksiyon vardır. Dolayısıyla en uygun fonksiyon 
	iki tanedir. Budurum da error ile sonuçlanacaktır. 

	Tabii biz çok sayıda uygun fonksiyonun olduğu durumda çağrı ifademizdeki argümanlarının türlerini bu uygun fonksiyonlardan birinin parametre türleriyle 
	aynı yaparsak kesinlikle o fonksiyon seçilir. Çünkü tam uyumdan (exact match) daha iyi olabilecek bir fonksiyon yoktur. Tam uyumu sağlayan da zaten birden 
	fazla fonksiyonun overload edilmesi mümkün değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, long b)					// 1
{
    cout << "int, long" << endl;
}

void foo(long a, long b)				// 2
{
    cout << "long, long" << endl;
}

void foo(double a, long b)				// 3
{
    cout << "double" << endl;
}

void foo(int a, int b)					// 4
{
    cout << "int, int" << endl;
}

void foo(double a, double b)			// 5
{
    cout << "double, double" << endl;
}

void foo(char a, short b)				// 6
{
    cout << "char, short" << endl;
}

void foo(int a, const char *s)			// 7
{
    cout << "int , const char *" << endl;
}

void foo(int a)							// 8
{
    cout << "int" << endl;
}

void bar(int a)							// 9
{
    cout << "bar, int" << endl;
}

int main()
{
    int a = 10;
    long b = 20;

    foo(a, b);		// int, long
    foo('a', 'b');	// ambiguity error!
    foo(10L, 2.3);  // ambiguity error!

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													17. Ders 11/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz. İlk iki çağrıda en uygun fonksiyon 1 numaralı fonksiyon olarak seçilecektir. Ancak üçüncü çağrıda en uygun fonksiyon bulunamayacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, int b)          // 1
{
    cout << "int, int" << endl;
}

void foo(double a, int b)       // 2
{
    cout << "double, int" << endl;
}

void foo(long a, long b)    // 3
{
    cout << "long, long" << endl;
}

int main()
{
    foo('a', 3.2);   // int, int
    foo('a', 'b');   // int, int
	foo(3.2, 10L);   // ambiguity error

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi overload resolution işleminde gösterici ve referanslardaki "üst düzey (top level) olmayan" const ve volatile niteleyicisi 
	kaliteyi etkilemektedir. Her zaman kendi niteleyicine dönüştürme daha iyidir. Örneğin:

	void foo(const int *pi)			// 1
	{
		//...
	}
	
	void foo(int *pi)				// 2
	{
		//...
	}
	
	Aşağıdkai gibi bir çağrının yapıldığını varsayalım:

	const int a = 10;
	foo(&a);						

	Burada 1 numaralı fonksiyon seçilecektir. Çünkü 2 numaralı fonksiyon zaten uygun bir fonksiyon değildir. Dolayısıyla üçüncü adıma zaten yalnızca birinci 
	fonksiyon girmektedir. Çağrının şöyle yapıldığını varsayalım:

	int b = 10;
	foo(&b);						

	Burada her iki fonksiyon da aday ve uygundur. Ancak int * -> int * dönüştürmesi ile int * -> const int * dönüştürmesi kıyaslandığında int * -> int * 
	dönüştürmesi daha iyi kabul edilmektedir. Tabii aynı durum referanslar için de söz konusudur. Örneğin:

	void bar(int &r)				// 1
	{
		//...
	}
	
	void bar(const int &r)			// 2
	{
		//...
	}
	
	Çağrı şöyle yapılmış olsun:

	int a = 10;
	bar(a);		
	
	Aynı gerekçeyle burada yine 1 numaralı fonksiyon daha iyidir. Çağrı şöyle yapılmış olsun:

	bar(10);

	Burada 1 numaralı fonksiyon yine uygun bir fonksiyon değildir. Dolayısıyla 2 numaralı fonksiyon seçilecektir. 

	T1, T2 ve T3 birer tür belirtiyor olsun:

	T1 -> const T3 &
	T2 -> const T3 &

	Buradaki otomatik dönüştürmeler arasındaki kalite kıyaslaması referanslar dikkate alınmadan türlere bakılarak belirlenmektedir. Örneğin:

	int -> const int &
	int -> const double &

	Burada int -> const int & dönüştürmesi daha iyidir. Örneğin:

	char -> const int &
	char -> const double &

	Burada char -> const int & dönüştürmesi daha iyidir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(const int &r)          // 2
{
    cout << "const int &" << endl;
}

int main()
{
    int a{10};

    foo(a);         // 2

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir tür belirtmek üzere T ve T & parametrelerine sahip aynı isimli fonksiyonlar birlikte bulunabilir. Bunların imzaları farklıdır. Örneğin:

	void foo(int a)
	{
		//...
	}

	void foo(int &r)
	{
		//...
	}

	Ancak T bir belirtmek üzere T -> T dönüştürmesi ile T -> T & dönüştürme arasında bir kalite farklılığı yoktur. Her iki dönüştürme de "tam uyum (exact match)"
	kabul edilmektedir. Dolayısıyla aşağıdaki gibi bir çağrım geçerli değildir:

	int x = 10;
	foo(x);

	Burada her iki fonksiyon da "en uygun fonksiyon" durumundadır. 

	T bir tür belirtmek üzere:

	T -> T
	T -> const T &

	dönüştürmeleri arasında da bir kalite farkı yoktur. Benzer biçimde:

	const T -> T
	const T -> const T 6

	dönüştürmeleri arasında da bir kalite farklılığı yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(int a)          		// 2
{
    cout << "int" << endl;
}

int main()
{
    int a = 10;
    
    foo(a);     // ambiguity error!
    foo(10);    // 2 seçilir çünkü 1 uygun fonksiyon değil

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Default argüman almış parametre değişkenleri "overload resolution" işleminin üçüncü adımında hiç dikkate alınmamaktadır. Örneğin:

	void foo(int a, int b = 10)
	{
		//...
	}

	void foo(int a)
	{
		//...
	}

	Bu iki fonksiyonun aynı anda bulunmasında bir sorun yoktur. Çünkü bunların parametrik yapıları farklıdır. Şimdi fonksiyonu şöyle çağırmış olalım:

	foo(10);

	Bu çağrım error ile sonuçlanacaktır. Çünkü birinci fonksiyonun default argüman alan parametreleri zaten overload resolution işleminin üçüncü adımında 
	yokmuş gibi ele alınacaktır. Dolayısıyla burada her iki fonksiyon da en uygun fonksiyondur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İleride çokça karşılaşacağımız bir durum da sol taraf değeri referansı ve sağ taraf değeri referansı parametrelerine sahip aynı isimli fonksiyonlardır.
	Bunların birlikte bulunması bir soruna yol açmaz. Çünkü bunlar farklı türlerdendir ve overload edilebilirler. Örneğin:

	void foo(int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada foo fonksiyonu bir sdol taraf değeri ile çağrılırsa 2 numaralı fonksiyon, bir sağ taraf değeri ilke çağrılırsa 1 numaralı fonksiyon uygun fonksiyon olmaz. 
	Dolayısıyla bir "ambiguity" durumu yaşanmaz. Örneğin:

	int x = 10;
	foo(x);			// 1 numaralı fonksiyon çağrılır

	foo(10);		// 2 numaralı fonksiyon çağrılır

	Pekiyi sol taraf değeri referansı const olsaydı ve fonksiyon sağ taraf değeir ile çağrılsaydı ne olurdu? Örneğin:

	void foo(const int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada fonksiyonun şöyle çağrıldığını varsayalım:

	foo(10);

	Her iki fonksiyon da uygun fonksiyonlardır. Ancak bu durumda sağ taraf değeri referansına sahip olan fonksiyonun daha iyi bir dönüştürme uyguladığı kabul 
	edilmektedir. Dolayısıyla 2 numaralı fonksiyon seçilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli sol taraf değeri referansı paranetresine ve sağ taraf deeri referansı parametresine sahip olan iki fonksiyonun bulunduğu bir durumda biz bu
	fonksiyonu sol taraf değeri ile çağrıdığımızda sol taraf değeir referans parametreli fonksiyonun çağrılacağını yukarıda söylemiştir. Örneğin:

	void foo(int &r)		// 1
	{
		//...
	}

	void foo(int &&r)		// 2
	{
		//...
	}

	Burada foo fonksiyonunu sol taraf değeri ile çağıralım:

	int x = 10;
	foo(x);

	Yukarıda da belirttiğimiz gibi zaten ikinci fonksiyon uygun fonksiyon olmadığı için birinci fonksiyon çağrılacaktır. Ancak ileride göreceğimiz bazı nedenlerden 
	dolayı bazen programcılar bu sol taraf değeri ile sağ taraf değeri referans parametresine sahip fonksiyonun çağrılmasını isteyebilmektedir. Bu nasıl sağlanabilir?
	Sol taraf değerini paranteze almak bize bir fayda sağlamamaktadır. Çünkü C++'a göre bir sol taraf değerini paranteze alsak da o solf taraf değeri olmaya
	devam etmektedir. Örneğin:

	foo((x));

	Burada yine birinci fonksiyon çağrılacaktır. int türüne dönüştümek geçici nesne oluşturacağı için fayda sağlayabilir. Örneğin:

	foo((int)x);		// foo(static_cast<int>(x));

	Ancak bu genel bir çözüm değildir. Çünkü T bir tür ve t de o türden bir sol taraf değeri belirtmek üzere biz her tür için (T)t işlemini yapamayız. 
	Sol taraf değerini sol taraf değeri referansına dönüştürürsek hiçbir fayda sağlayamayız. Örneğin:

	foo((int &)x);		// foo(static_cast<int &>(x));

	Burada yine bir numaralı fonksiyon çağrılacaktır. İşte bu işlemin en taşınabilir ve normalk yolu sol taraf değerini sağ taraf değeri referansına dönüştürmektir. 
	Örneğin:

	foo((int &&)x);		// static_cast<int &&>(x));

	Artık ikinci fonksiyon çağrılacaktır. Yukarıda da belirriğimiz gibi böyle bir gereksinim başka konularda karşımıza çıkacaktır. Bunu daha resmi olarak yapabilmek
	için C++'ın standart kütüphanesine C++11 ile birlikte move isimli bir fonksiyon eklenmiştir. move fonksiyonun bazı detrayları vardır. Ama yaptığı işlem 
	bir sol taraf değerini sanki sağ taraf değeri gibi işleme sokmaktır. Örneğin:

	foo(move(x));

	Burada ikinci fonksiyon çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													18. Ders 16/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Overload işlemi aynı faaliyet alanında yapılan bir işlemdir. Dolayısıyla "overload resolution" aynı faaliyet alanındaki aynı isimli fonksiyonlar arasında 
	yürütülmektedir. Başka bir deyişle "verload resolution" işlemi için "aday fonksiyonlar (candidate functions)" isim aramsı sırasında ismin bulunduğu faaliyet
	alanındaki fonksiyonlardan oluşturulmaktadır. Özellikle sonraki maddede açıklayacak olduğumuz isim alanları ve daha sonra görecek olduğumuz sınıflar konusunda 
	bunun önemi ortaya çıkacaktır. 

	Aşağıdaki örnekte main fonksiyonu içerisinde foo fonksiyonu çağrılmıştır. foo fonksiyonu main fonksiyonunun yerel bloğunda bulunduğu için artık o yerel 
	blokta bildirilen fonksiyonlar overload resolution işleminde aday fonksiyon olarak seçilecektir. Dolayısıyla double parametreye sahip olan foo aday fonksiyon 
	olmadığı için overload resolution işlemine girmeyecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(double a)
{
    cout << "double" << endl;
}

void foo(long a)
{
    cout << "long" << endl;
}

void foo(int a)
{
    cout << "int" << endl;
}

int main()
{   
    void foo(int a);            

    foo(3.14);          // int parametreli foo çağrılacak

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi farklı parametrik yapılara sahip aynı isimli fonksiyon tanımlamanın bize ne faydası vardır? Yani bu özellik C++'a neden eklenmiştir? NYPT birtakım 
	anahtar kavramların bileşimi olarak ele alınabilir. Bu anahtar kavramların hepsi aslında uzun kodların daha kolay algılanmasına	yönelik kavramlardır. İşte 
	NYPT'te benzer işlemleri yapan ama aralarında küçük farklılıklar bulunan fonksiyonlara özellikle aynı isimler verilmektedir. Böylece "sanki farklı çok sayıda
	fonksiyon var" algısından "tek bir fonksiyon var" algısına geçiş yapılır. Zaten NYPT insanın doğayı algılayış biçiminden modellenmiştir. Örneğin çok farklı 
	sandalyeler olabilir. Bunların renkleri yapıldığı malzemeler farklı olabilir. Ancak neticede bizim için hepsi oturulabilecek sandelyedir. Zaten doğada biribirinin 
	aynısı olan şeyler genellikle bulunmamaktadır. Dikkatle incelendiğinde aynı marka ve renkteki sandalyeler arasında da farklılıklar olduğunu görürüz. Ancak 
	bizim için o sandalyeler biribirinin aynısı gibidir. Görüldüğü gibi birtakım nesneleri farklılaştırmak algısal karışıklık yaratmaktadır. Benzer olanları 
	aynıymış gibi algılamak ise algısal açıklık sağlamaktadır. Eğer bizim bilişsel sistemimiz farklı olan ancak biribirine benzeyenleri aynıymış gibi ele alamasydı
	dünya beynimizin işleyebileceğinden çok daha karmaşık bir hale gelirdi. 

	İşte NYPT'de benzer işlemleri yapan ama ayrıntıda farklılar içeren fonksiyonlara aynı isimleri vermek iyi bir tekniktir. Örneğin:

	int abs(int a);
	long abs(long a);
	double abs(double a);
	...

	Burada abs fonksiyonlarının hepsi benzer işlemleri yapmaktadır. Yalnızca işlem yaptıkları tür farklıdır. O halde bunlara aynı isimleri vermek iyi bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    38) C++'ta global "isim kirliliğini (name pollution)" engellemek için "isim alanları (namespaces)" denilen C'de olmayan bir özellik bulunmaktadır. Farklı firma 
	ya da kurumların kütüphanelerinin bir arada kullanıldığı projelerde "isim çakışmaları (name collisions)" oluşabilmektedir. Örneğin A firmasının kütüphanesi 
	ile B firmasının kütüphanesini birlikte kullanırken bu iki firma tesadüfen bir yapı ya da sınıfa aynı isimleri vermiş olabilirler. Bu önemli bir problemdir. 
	Biz her iki firmanın kütüphanelerini kullanmak için onların başlık dosyalarını include ettiğimizde isim çalışması nedeniyle error'ler oluşacaktır. İşte isim 
	alanları bu problemleri ortadan kaldırmak için düşünülmüştür. Örneğin A firmasının kütüphanesi ile B firmasının kütüphanesini birlikte kullanmak isteyelim. 
	Bunun için iki firmanın oluşturduğu başlık dosyalarını include edelim:

	#include "a.hpp"
	#include "b.hpp"

	İki firma da tesadüfen bir yapıya aynı ismi vermiş olabilir. Bu durumda derleme sırasında error oluşacaktır. Bu error'leri pratik bir biçimde düzeltmek de 
	mümkün değildir. Çünkü kütüphane derlenmiştir ve oradaki isimler object modüllere çoktan yazılmıştır. Yani çakışan isimleri başlık dosyasında dğeiştirmek 
	bir fayda sağlamayacaktır. 

	Bir isim alanı bildiriminin genel biçimi şöyledir:

	namespace <isim> 
	{
		// namespace içindeki eleman bildirimleri
	}

	İsim alanları global bölgede bildirilirler. Yerel isim alanları oluşturmak mümkün değildir. Global alanda yapılabilen tüm bildirimler ve tanımlamalar isim 
	alanları içerisinde de yapılabilmektedir. İsim alanları içerisindeki fonksiyonlar yine global fonksiyonlardır. İsim alanları içerisinde tanımlanmış olan 
	değişkenler yine global değişkenlerdir. İsim alanları yalnızca isimleri farklılaştırma işlevini görmektedir. Her isim alanı farklı bir faaliyet alanı 
	belirtmektedir. 

	Aynı isim alanı içerisinde aynı isimli birden fazla değişken tanımlanamaz. Ancak farklı isim alanlarında aynı isimli değişkenler tanımlanabilmektedir. (Farklı 
	isim alanlarındaki aynı isimli fonksiyonlar için "overload" terimi kullanılmaz. Çünkü "overload" aynı faaliyet alanındaki fonksiyonlar için kullanılmaktadır.) 
	Yerel bir bloğun içerisinde isim alanı oluşturulamamaktadır. İsim alanları global bölgede oluşturulmak zorundadır.

	Bir isim alanı içerisindeki bir isme isim alanı ismi ve :: operatörü ile erişilir. :: operatörü iki operandlı araek bir operatördür. Bu operatöre 
	"çözünürlük operatörü (scope resolution operator)" denilmektedir. Örneğin:

	CSD::foo();

	gibi bir ifadede foo fonksiyonunun CSD isim alanı içerisinde olduğunu belirtmekteyiz. Çözünürlik operatörü aslında başka bağlamlarda da kullanılmaktadır. 
	Burada çözünürlük operatörünün solundaki opendın isim alanı ismi, sağındaki operandın o isim alanı içerisindeki bir isim olduğuna dikkat ediniz. Çözünürlük 
	operatörü ile belirtilen isimlere "niteliklendirilmiş (qualified)" isimler denilmektedir. 

	Her kurum global isimlerini kendine özgü bir isim alanı içerisinde oluşturursa global isim kirliliği büyük ölçüde (ama tamamen değil) engellenmiş olmakradır.

	İsim alanına benzer benzer kavramlar pek çok yeni dilde de bulunmaktadır. Örneğin bu kavram Java'da "paket (package)", Python'da "modül (module)" ismiyle 
	karşımıza çıkmaktadır. C# her ne kadar büyük ölçüde Java'dan kopya çekilmişse de kendini C++'a dah fazla yaklaştırmıştır. C# C++'ın isim alanlarını basitleştirerek 
	bünyesine katmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    int a = 10;

    void foo()
    {
        cout << "CSD::foo" << endl;
    }
}

namespace Other
{
    int a = 20;

    void foo()
    {
        cout << "Other::foo" << endl;
    }
}

int main()
{
    cout << CSD::a << endl;
    cout << Other::a << endl;

    CSD::foo();
    Other::foo();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe (nested) isim alanları söz konusu olabilir. Bu durumda içteki isim alanınının elemanlarına dışarıdan birden fazla çözünürlük operatörü kullanılarak 
	erilişir. Örneğin:
	
	namespace CSD
	{
		namespace Util
		{
			void foo()
			{
				cout << "CSD::Util::foo" << endl;
			}
		}

		void foo()
		{
			cout << "CSD::foo" << endl;
		}
    
	}

	int main()
	{   
		CSD::foo();
		CSD::Util::foo();

		return 0;
	}

	Birbirlerini kapsayan isim alanlarında da aynı isimli değişkenler bulunabilirler. Bunlar birbirleriyle karışmaz. Bu örnekteki foo fonksiyonlarından biri
	doğrudan CSD isim alanı içerisinde diğeri ise CSD isim alanı içerisindeki Util isim alanı ieçrisindedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    namespace Util
    {
        void foo()
        {
            cout << "CSD::Util::foo" << endl;
        }
    }

    void foo()
    {
        cout << "CSD::foo" << endl;
    }
    
}

int main()
{   
    CSD::foo();
    CSD::Util::foo();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç bir isim alanı C++17 ile birlikte artık hamlede bildirilebilmektedir. Örneğin:

	namespace A::B::C 
	{
		void foo()
		{
			//...
		}
	}

	Burada foo fonksiyonu A isim alanının içerisindeki B isim alanının içerisindeki C isim alanının içerisine yazılmıştır. Yani aşağıdaki bildirim yukarıdaki ile 
	eşdeğerdir:

	namespace A
	{
		namespace B 
		{
			namespace C
			{
				void foo()
				{
					//...
				}
			}
		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A::B::C
{
    void foo()
    {
        cout << "A::B::C::foo" << endl;
    }
}

int main(void)
{
   A::B::C::foo();
   
    return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir isim alanı ismi dışarıdan çözünürlük operatörü ile isim alanı ismini belirterek kullanabiliyorduk. Ancak aynı isim alanı içerisindeki bir isim doğrudan 
	kullanılabilmektedir. Örneğin:

	namespace CSD
	{
		int g_x;

		void foo()
		{
			cout << g_x << endl;		// geçerli
		}
	}

	Burada foo fonksiyonu g_x değişkenini hiç niteliklendirmeden doğrudan kullanabilmektedir. Çünkü foo fonksiyonunun kendisi de aynı isim alanı içeisindedir. 
	Niteliksiz isim arama (unqualified name lookup) sırasında isim alanlarına içten dışa doğru bakılmaktadır. Dolayısıyla iç bir isim alanı onun dışındaki isimleri 
	de niteliklendirmeden kullanabilir. İsim aramsı (name lookup) ayrıntıları ileride ele alınacaktır. Örneğin:

	namespace CSD
	{
		int g_x;

		namespace Util
		{
			void foo()
			{
				cout << g_x << endl;		// geçerli
			}
		}
	}

	Burada g_x değişkeni Util isim alanı içerisinde değildir, util isim alanını kapsayan isim alanı ieçrisindedir. Ancak g_x aranırken isim alanlarına içten dışa 
	doğru bakıldığı için g_x bulunacaktır. 
	
	İsim alanları ayrı faaliyet alanları belirtmektedir. Faaliyet alanı kuralına niteliksiz aramalarda göre dar faaliyet alanındaki isme erişilir. Örneğin:

	namespace CSD
	{
		int g_x;

		namespace Util
		{
			int g_x;

			void foo()
			{       
				cout << g_x << endl;        // Buradaki g_x kendi isim alanındaki g_x. CSD::g_x görünür (visible) değil
			}
		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aynı isim alanını birden fazla kez bildirmek tamamen geçerli bir durumdur. Bu durum isim alanına ekleme yapıldığı anlamına gelir. Örneğin:

	namespace CSD
	{
		void foo()
		{
			//...
		}
	}
	
	//...

	namespace CSD
	{
		void bar()
		{
			//...
		}
	}

	Burada foo ve bar fonksiyonlarının her ikisi de CSD isim alanı içerisindedir. Yani isimn alanları tek parça olarak yazılmak zorunda değildir. Tabii aynı isim 
	alanı içerisinde aynı isimli tek bir değişken tanımlamabilir. Örneğin:

	namespace CSD
	{
		int g_x;
	}
	
	//...

	namespace CSD
	{
		int g_x;		// geçersiz! aynı isim alanında aynı isimli tek bir değişken tanımlanabilir
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
    void foo()
    {
        cout << "A::foo" << endl;
    }
}

namespace A                 // geçerli
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main()
{
    A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii farklı isim alanlarının içerisindeki aynı isim alanları aslında farklı isim alanlarıdır. Burada ekleme işlemi söz konusu değildir. Örneğin:

	namespace A 
	{
		namespace B
		{
			//...
		}
	}

	namespace B
	{
		//...
	}

	Buradaki B isim alanları tamamen farklı isim alanlarıdır. Dolayısıyla birleştirilmezler. Aynı isim alanlarının içindeki aynı isimli isim alanalrı 
	birleştirilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    namespace A
    {
        void foo()
        {
            cout << "A::foo" << endl;
        }
    }
}

namespace A
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main()
{
    CSD::A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hiçbir isim alanının içerisinde olmayan global bölge de bir isim alanı belirtmektedir. O bölgeye "global isim alanı (global namespace)" denilmektedir. 
	Örneğin:

	namespace CSD
	{
		void foo()
		{
			//...
		}
	}

	void bar()
	{
		//...
	}

	int main()
	{
		//...
	}

	Burada bar fonksiyonu global isim alanı içerisindedir. CSD isim alanı da global isim alanı içerisindedir. Her isim alanınının doğrudan ya da dolaylı olarak
	global isim alanı içerisinde olduğuna dikkat ediniz. main fonksiyonu da global isim alanı içerisindedir. İsim alanlarını bir dizin (directory) ağacına 
	benzetirsek global isim alanını kök dizine benzetebiliriz. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{	
    void foo()                  // global isim alanı içerisindeki CSD isim alanının içerisinde
    {
        cout << "A::foo" << endl;
    }	
}

void foo()                  // global isim alanının içersinde
{
    cout << "foo" << endl;
}

int main()
{
    CSD::foo();     // CSD'nin içerisindeki foo çağrılıyor
    foo();          // global isim alanı içerisindeki foo çağrılıyor

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun prototipi bir isim alanı içerisinde bildirilip tanımlaması onu kapsayan herhangi bir isim alanında niteliklendirilerek yapılabilir. Örneğin:

	namespace CSD
	{
		void foo();
		//...
	}

	void CSD::foo()		// geçerli
	{
		//...
	}

	Burada foo fonksiyonu aslında CSD isim alanı içerisindedir. Ancak tanımlaması global isim alanında yapılmıştır. Tanımlama sırasında foo isminin nitelikli 
	bir biçimde belirtildiğine dikkat ediniz. Örneğin:

	namespace CSD
	{
		namespace Util
		{
			void foo();
			//...
		}
		
		void Util::foo()		// geçerli
		{
			//...
		}
	}

	Burada prototip bildirimi CSD::Util içerisinde yapılmış, tanımlama onu kapsayan CSD isim alanı alnı içerisinde yapılmıştır. Tabii tanımlamanın hemen bir 
	yukarıdaki isim alanı içerisinde yapılması zorunlu değildir. Kapsayan herhangi bir isim alanı içerisinde yapılabilir. Örneğin:

	
	namespace CSD
	{
		namespace Util
		{
			void foo();
			//...
		}
		//...		
	}

	void CSD::Util::foo()		// geçerli
	{
		//...
	}
	
	Global isim alanının CSD isim alanını kapsadığına dikkat ediniz. 

	Ancak prototip de tanımalamada kapsayan isim alanında yapılamaz. En azından prototipin kendi isim alanınde bildirilmesi gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	namespace B
	{
		void foo();
		void bar();
		void tar();
		//...

		void foo()
		{
			cout << "A::B::foo" << endl;
		}
	}

	void B::bar()
	{
		cout << "A::B::bar" << endl;
	}
}

void A::B::tar()
{
	cout << "A::B::tar" << endl;
}

int main()
{
	A::B::foo();
	A::B::bar();
	A::B::tar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Çözünürlük operatörünün tek operandlı (unary) biçimi de vardır. Tek operand'lı kullanım şöyledir:

	::<isim>
	
	Çözünürlük operatörünün tek operand'lı biçimi isim aramasını global isim alanında yapmaktadır. Örneğin:	

	::foo();

	Burada global isim alanındaki foo çağrılmıştır. Eğer isim global isim alanında bulunamazsa başka bir isim alanına bakılmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo()
{
	cout << "foo" << endl;
}

namespace CSD
{
	void foo()
	{
		cout << "CSD::foo" << endl;
	}

	void bar()
	{
		foo();		// CSD::foo
		::foo();	// global isim alanındaki foo
	}
}

int main()
{
	CSD::bar();

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında önce isim araması yapılır. İsim bulunursa ismin bulunduğu faaliyet alanındaki aynı isimli fonksiyonlar aday fonksiyon olarak 
	overload resolution	işlemine sokulur. Daha üst isim alanlarındaki fonksiyonlar aday fonksiyon olarak seçilmezler. Yani overload işlemi aynı isim alanındaki 
	aynı isimli fonksiyonların bulunması anlamına gelmektedir. Örneğin:

	void foo(double a)
	{
		cout << "::foo, int" << endl;
	}

	void foo(long a)
	{
		cout << "::foo, long" << endl;
	}

	namespace CSD
	{
		void foo(int a)
		{
			cout << "CSD::foo, int" << endl;
		}

		void bar()
		{
			foo(3.2);		// CSD::foo, int çağrılır
		}
	}

	Burada CSD::bar fonksiyonunda foo fonksiyonu double bir argümanla çağrılmıştır. Niteliksiz isim aramada CSD içerisindeki foo fonksiyonu bulunacaktır. İşte 
	artık aday fonksiyonlar CSD isim alanı içerisindeki foo fonksiyonları olacaktır. Bu örnekte global isim alanı içerisinde "tam uyum (exact match)" sağlayan
	bir foo fonksiyonu olsa da o fonksiyonun çağrılmayacağına dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	void foo(const char *str)
	{
		cout << "A::foo const char *" << endl;
	}

	namespace B
	{
		void foo(double a)
		{
			cout << "A::B::foo double" << endl;
		}

		namespace C
		{
			void foo(int a)
			{
				cout << "A::B::C::foo int" << endl;
			}

			void bar()
			{
				foo(12.3);		// A::B::C::foo çağrılıyor
				foo("ankara");	// geçersiz!
			}
		}
	}
}

int main()
{
	A::B::C::bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											19. Ders 18/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi içerisindeki ve C++'ta C'nin standart kütüphanesi içerisindeki tüm öğeler "std" isimli bir isim alanı içerisine yerleştirilmiştir. 
	Bu nedenle bu isimler kullanılırken isimlerin "std" ismi ile niteliklendirilmesi gerekir. Aksi takdirde isimler global isim alanında aranır ve o isim alanında
	bulunamayacaklardır. Örneğin:

	std::cout << a << std::endl;

	Biz şimdiye kadar böyle bir niteliklendirme yapmadık. Bunun nedeni programın yukarısa using namespace denilen direktifi yerleştirmiş olmamızdır:

	using namespace std;

	Bu direktif sayesinde std isim alanındaki isimleri kullanırken niteliklendirmeyi elimine etmekteyiz. Ancak bazı programcılar bu direktifi kullanmazlar ve 
	std isim alanındaki isimlere nitelikli bir biçimde erişirler. Böyle kodlçar görürseniz yadırgamamalısınız. Biz kursumunda gebel olarak bu direktiften 
	faydalanacağız. Bu direktifin işlevi izleyen paragraflarda ele alınmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdio>

int main()
{
	std::cout << "this is a test" << std::endl;
	
	std::printf("this is a test\n");

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Farklı isim alanları içerisindeki aynı değişkenlerin birbirleriyle karışmaması nasıl sağlanmaktadır. Aslında amaç dosya (object file) formatlarında isim alanı
	biçiminde bir kavram yoktur. Yani isim alanları C++'ın bir kabulüdür. Aslında C Programala Dili C++ Programlama Dilinden daha doğaldır. Burada "doğallık" 
	makinede olanları daha doğrudan ifade etme ve ona yakınlık anlamında kullanılmaktadır. C++ C'den yüksek seviyeli bir programlama dilidir. Örneğin bir şey 
	"C'de böyle ancak C++'ta şöyle yapılıyorsa" gerçekte C'deki gibi yapılmaktadır. İşlemciler C'deki gibi çalışmaktadır. C++'taki pek çok kavram NYPT'yi uygulamak
	dile eklenmiş yapay kavramlardır. Örneğin amaç kod düzeyinde isim alanı diye bir kavram yoktur. Sınıf diye de bir kavram yoktur. 

	Derleyiciler isim alanları içerisindeki isimleri amaç dosyaya (object file) isim alanı isimleriyle kombine ederek yazmaktadır. Bu nedenle farklı isim alanlarının 
	içerisindeki aynı isimler aslında amaç dosyada farklı isimler gibi bulurlar. Tabii daha önceden de belirttiğimiz gibi isim dekorasyonu (name decoration) 
	derleyiciden derleyiciye değişebilmektedir. Bu nedenle bir derleyicide oluşturulmnuş bir amaç dosya diğer derleyicide kullanılamamaktadır. Örneğin;:

	namespace CSD
	{
		namespace Util
		{
	
			int x;
		}
	}

	Buradaki x ismini Microsoft derleyicileri amaç dosyaya şöyle yazmaktadır:

	?x@Util@CSD@@3HA

	Aynı ismi g++ derleyicisi amaç dosyaya şöyle yazmıştır:

	ZN3CSD4Util1xE

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun başka bir modülde (yani başka bir C++ kaynak dosyasında) tanımlanmış olduğunu ya da kütüphane içerisinde bulunduğunu varsayalım. Bi bu 
	fonksiyonu başka bir modülden (C++ kaynak dosyasından) kullanmak istiyorsak onun prototipini bulundurmamız gerekir. Fonksiyonun kendisi link aşamasında 
	linker tarafından bulunmaktadır. Tabii bu prototip bildiriminin aynı isim alanı içerisinde yapılması gerekmktedir. Örneğin:

	namespace CSD
	{
		void foo();
		//...
	}

	Buraki fonksiyonlar muhtemelen başka bir kaynak dosya içerisinde CSD alanında tanımlanmıştır. Bizim bu isimleri başka bir kaynak dosyadan kullanabilmemiz için 
	prototip bildirimini de aynı isim alanı içerisinde yapmalıyız. Bunun yukarıdakinden daha bir prtaik bir yolu yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İsim alanı bildirimi yapılırken namespace anahtar sözcüğünden sonra isim alanı ismi belirtilmeden doğrudan blok açılırsa böyle isim alanlarına "isimsiz isim
	alanları (unnamed namespace)" denilmektedir. Örneğin:

	namespace 
	{
		int g_x;

		void foo()
		{
			//...
		}
	}
	
	Burada g_x ve foo isimsiz isim alanı içerisindedir. İsimsiz isim alanlarındaki isimler o isimsiz isim alanı hangi isim alanı içerisinde bildirilmişse sanki 
	o isim alanındaki isimler gibi kullanılabilmektedir. Yukarıdaki örneğimizde isimsiz isim alanı global isim alanı içerisinde bildirilmiştir. (Genellikle hep 
	böyle yapılır.) o halde biz g_x ismini ve foo ismini sanki global isim alanındaymış gibi kullanabiliriz. Örneğin:

	#include <iostream>

	using namespace std;

	namespace 
	{
		int g_x;

		void foo()
		{
			cout << "foo" << endl;
		}
	}

	int main()
	{
		g_x = 10;				// geçerli

		foo();					// geçerli

		cout << g_x << endl;	// geçerli

		return 0;
	}

	Pekiyi isimsiz isim alanları neden kullanılmaktadır? İsimsiz isim alanlarını gören derleyici aslında bu isim alanlarına kendisi "tek (unique)" olan bir isim 
	uydurmaktadır. Yani örneğin:

	namespace 
	{
		//...
	}

	gibi bir isimsiz isim lanaı bildirimi aşağıdaki ile eşdeğerdir:

	namespace compiler_generated_unique_named
	{
		//...
	}

	using namespace compiler_generated_unique_named;

	Yani aslında isimsiz isim alanı içerisindeki isimler amaç dosyaya derleyici tarafından üretilmiş olan bir isim alanı ismi eşliğinde yazılmaktadır. Dolayısıyla
	farklı C++ kaynak dosyalarındaki isimsiz isim alanları içerisindeki aynı isimler karışmamaktadır. Çünkü derleyici her kaynak dosyadaki isimsiz isim alanını 
	diğerlerinden farklı olacak bir isim ile kombine ederek amaç dosyaya yazmaktadır. İşte isimsiz isim alanları "modüle özgü global değişken oluşturabilmek"
	için kullanılmaktadır. Farklı modüllerdeki isimsiz isim alanları içerisinde aynı isimli değişkenler bulunabilir. Anımsanacağı gibi modüle özgü global değişkenler
	C'de "static" anahtar sözcüğü ile "static global" değişkenler olarak oluşturulmaktadır. C++'ta her ne kadar static global değişken bildirimi yine varsa da
	bu yöntem "modüle özgü global değişken oluşturabilmek için" kötü bir teknik olarak kabul edilmektedir. static global değişkenler yerine C++'ta "isimsiz isim 
	alanları (unnamed namespaces)" kullanılmalıdır. Tabii derleyiciler isimsiz isim lanalarının içerisindeki değişkenleri aslında amaç dosyaya PUBLIC olarak 
	yazmamaktadır. Yani tıpkı static global değişkenlerde olduğu gibi bu değişkenler gerçekten ismi biliniyor olsa bile başka bir modülden extern bildirimi ile 
	kullanılamamaktadır. Başka bir deyişle aslında isimsiz isim alanınındaki isimlerin static belirleyicisi ile oluşturulmuş isimlerden link işlemi bakımından 
	bir farklılık oluşmamaktadır. 

	İsimsiz isim alanları başka isim alanlarının içerisinde de olabilmektedir. Örneğin:

	namespace CSD
	{
		namespace 
		{
			int g_x;
			//...
		}
	}

	Buradaki g_x ismi sanki CSD isim alanındaymış gibi kullanılabilir. Örneğin biz bu ismi CSD::g_x biçiminde kullanabiliriz. Tabii bu isimlerin de başka bir 
	modülden (C++ kaynak dosyasından) kullanılma olanağı yoktur. Yukarıdaki bildirimin eşdeğerini şöyle düşnebilirsiniz:

	namespace CSD
	{
		namespace compiler_generated_unique_name
		{
			int g_x;
			//...
		}

		using namespace compiler_generated_unique_name;
	}

	using namespace direktifi izleyen paragraflarda ele alınmaktadır. 

	Tabii aynı isim alanı içerisindeki isimsiz isim alanları yine tek bir isimsiz isim alanı biçiminde birleştirilmektedir. Başka bir deyişle biz isimsiz isim 
	alanlarını da tek parça olarak yazmak zorunda değiliz. 

	İsimsiz isim alanı içerisindeki değişkenlerle aynı isimli üst isim alanında değişkenler bulunabilir. Bu durum bir soruna yol açmaz. Örneğin:

	namespace 
	{
		int g_x = 10;
		//...
	}

	int g_x;

	Ancak bu örnekte her iki g_x değişkeni de isim aramsı sırasında sanki global isim alanındaymış gibi bir etki oluşacağına göre bu ismin niteliksiz kullanımı
	soruna yol açacaktır. Örneğin:

	cout << g_x << endl;		// geçersiz! hangi g_x olduğu belli değil

	Tabii global olana erişmek için tek operand'lı çözünürlük operatöründen faydalanabiliriz. Örneğin:

	cout << ::g_x << endl;		// geçerli, global isim alanındaki g_c kullanılıyor.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte inline isim alanları biçiminde bir isim alanı türü de dile eklenmiştir. inline isim alanları herhangi bir isim alanının içerisinde 
	bildirilebilir. Bildirim sırasında inline anahtar sözcüğü de kullanılmaktadır. Örneğin:

	inline namespace CSD
	{
		//...
	}

	inline anahtar sözcüğünün fonksiyonlarla kullanımını görmüştük. Ancak buradaki inline anahtar sözcüğünün inline fonksiyonlardaki inline anahtar sözcüğü ile 
	semantik bir benzerliği yoktur. inline isim alanı içerisindeki isimler inline alanı hangi isim alanının içerisinde bildirilmişse sanki o isim alanındaki 
	isimlermiş gibi kullanılabilmektedir. (Anımsanacağı gibi isimsiz isim alanlarındaki isimler de bu biçimde kullanılabiliyordu) Örneğin:
		
	inline namespace CSD
	{
		int g_x;

		void foo()
		{
			cout << "CSD" << endl;
		}
	}

	Biz burada G-x ve foo isimlerini inline CSD isim alanı içerisinde bildirdik. CSD isim alanı global isim alanı içerisinde olduğu için sanki bu isimler 
	global isim alanı içerisindeymiş gibi de kullanılabilmektedir. Örneğin:

	g_x = 10;					// geçerli, niteliklebdirmeye gerek yok

	cout << g_x << endl;		// geçerli, niteliklendirmeye gerek yok

	foo();						// geçerli, niteliklendirmeye gerek yok

	Tabii istersek yine bu isim alanındaki isimleri nitelikli de kullanbiliriz:

	
	CSD::g_x = 10;				// geçerli, açıkça niteliklendirme yapılmış

	cout << CSD::g_x << endl;	// geçerli, açıkça niteliklendirme yapılmış

	CSD::foo();					// geçerli, açıkça niteliklendirme yapılmış

	Pekiyi bunun anlamı nedir? Aslında inline isim alanları o kadar sık kullanılabilecek bir özellik değildir. Özellikle kütüphanelerin farklı versiyonlarının 
	kolay bir biçimde default hale getirilmesi için düşünülmüştür. Örneğin:

	namespace CSD
	{
		namespace utilV1 
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		inline namespace utilV2
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}
		//...
	}

	Burada aslında CSD isim alanı içerisinde foo ve bar fonksiyonları bulunmaktaymış. Ancak zamanla bu fonksiyonların ileri versiyonları oluşturulmuş. Programcı da
	eski versiyonları muhafaze ederek yeni versyionları default hale getirmek istemiş olabilir. Burada UtilV2 içerisindeki isimler sanki CSD içerisindeymiş 
	gibi bir etki oluşmaktadır. Daha ileride bu kütüphanein üçüncü versiyonu çıkartıldığnda programcı muhtemelen şöyle yapacaktır:

	namespace CSD
	{
		namespace utilV1 
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		namespace utilV2
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}

		inline namespace utilV3
		{
			void foo()
			{
				//...
			}

			void bar()
			{
				//...
			}
		}
		//...
	}

	Eski versiyonlara yine erişilebildiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
											20. Ders 23/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   39) Gereksiz niteliklendirmeyi elimine edebilmek için "using namespace direktifi" denilen bir direktiften faydalanılmaktadır.  using namespace direktifinin 
   genel biçimi şöyledir:

	using namespace <isim_alanı_ismi>;

	Burada isim alanı ismi tek bir isimden olaşabileceği gibi :: operatörü kullanılarak oluşturulan iç bir isim alanı da olabilir. Örneğin:

	using namespace CSD;
	using namespace CSD::Util::Test
	using namespace std;

	using namespace direktiflerinin ayrı ayrı oluşturulması gerekmektedir. Aşağıdaki gibi bir arada oluşturulamamaktadır:

	using namespace CSD, CSD::Util, std;		// geçersiz! böyle bir sentaks yok

	Bu direktiflerin aşağıdaki gibi ayrı ayrı oluşturulması gerekir:

	using namespace CSD;
	using namespace CSD::Util;
	using namespace std;

	using namespace direktifi bir isim alanına ya da yerel bir bloğa yerleştirilebilir (bir sınıf içerisine yerleştirilemez). Tabii using namespace direktifinde 
	belirtilen isim alanının daha önce derleyici tarafından görülmüş olması gerekmektedir. Yani önce isim alanı bildirimi yapılmalı daha sonra o isim alanı için 
	using namespace direktifi kullanılmalıdır. Olmayan bir isim alanına using namespace direktifi uygulanamaz. 

	using namespace direktifini ele almadan önce "isim araması (namelookup)" denilen bir kavramdan kısaca bahsedeceğiz. İsim araması kavramı C standratlarınd olmayan 
	C++'ın karmaşıklığı nedeniyle C++ standartlarına bulunan bir kavramdır. Derleyici bir isim ile karşılaştığında o isme ilişkin bir bildirimi bulmaya çalışır. 
	Çünkü her ismin bir bildirimi olmak zorundadır. İşte derleyici isimleri sırasıyla bazı faaliyet alanlarında aramaktadır. İsim bir faaliyet alanında bulunursa
	başka bir faaliyet alanına bakılmamaktadır. Yani arama isim bulunamadığı sürece devam ettirilmektedir. Örneğin C'de (her ne kadar bu kavram C'de yoksa da)
	yerel bir blokte bir isim kullanıldığında önce o ismin bildirimi içten dışa doğru yerel bloklarda aranmaktadır. Nihayet bu yerel bloklarda bulunamazsa global 
	alana da bakılmaktadır. C++'ta isim araması iki grubua ayrılmaktadır:

	1) Niteliksiz isim araması (unqualified name lookup)
	2) Nitelikli isim arama (qualified name lookup)

	Çözünürlük operatörü olmadan yazılmış isimlerin aranması ve çözünürlük operatörlerinin en solundaki isimlerin aranması niteliksiz isim arama kurallarına göre 
	yapılmaktadır. Örneğin:

	a = 10;
	CSD::Util::foo();

	Burada a ve CSD isimleri niteliksiz isim arama kurallarına göre aranmaktadır. 

	Çözünürlük operatörünün sağındaki isimler nitelikli isim arama kurallarına göre aranmaktadır. Örneğin:

	std::cout << "test" << std::endl;

	Burada std niteliksiz isim arama kurallarına göre cout ve endl nitelikli isim arama kurallarına göre aranmaktadır. İsim araması biraz karmaşık bir konudur. 
	Çünkü ileride görülecek başka konular da devreye girdiğinde konu biraz da ayrıntılı hale gelmektedir. Ancak biz bu aşamada en basit bir biçimde diğer konuları 
	hiç dikkate almadan isim araması konusunda bazı şeyler söylmek istiyoruz. Niteliksiz isim araması kabaca şu aşamalarla yapılmaktadır (else-if biçiminde):

	1) İsim kullanıldığı bloğun içerisinde kullanım yerine kadar olan yerel bölgede aranır. 
	2) İsim yerel bloğu kapsayan yerel bloklarda içten dışa doğru değişkenin kullanıldığı bölgede sırasyla aranır. 
	3) İsim yerel bloğun ilişkin olduğu fonksiyonun içinde bulunduğu isim alanında kullanım yerine kadarki bölgede aranır.
	4) İsim kapsayan isim alanlarında içten dışa doğru kullanım yerine kadarki bölgede aranır. 
	5) İsim nihayet global isim alanında kullanım yerine kadarki bölgede aranır.

	Niteliksiz isim aramasını şuna benzetebiliriz: "Biz arkadaşımıza Ahmet'i gördün mü?" diye bir soru soralım. Arkadaşımız Ahmet'i önce arkadaş çevresinde, bulamazsa
	okulda, bulamazsa şehirde, bulamazsa ülkede, bulamazsa dünyada bulamazsa evrende arayacaktır. 

	Nitelikli isim aramada isim kabaca (ayrıntıları vardır) ilgili isim alanında aranmaktadır. Eğer isim o isim alanında bulunamazsa kapsayan isim alanlarına 
	bakılmamaktadır. Örneğin:

	CSD::a = 10;

	Burada a değişkeni CSD isim alanında aranır. Eğer orada bulunmazsa CSD'yi kapsayan isim alanlarında arama yapılmamaktadır. Nitelikli isim aramayı da şuna 
	benzetebiliriz: Biz arkdaşımıza "Okuldaki Ahmet'i gördün mü?" diye sorsaydık. Arkadaşımız Ahmet'i yalnızca okulda arardı. Okulda bulmazsa şehre bakmazdı. 
	Çünkü biz zaten onun okulda olması gerektiğini söylemiş olmaktayız. 

	using namepspace direktifinde iki isim alanı söz konusudur. Birincisi direktifin yerleştirildiği isim alanı, ikincisi direktifte belirtilen isim alanı. Eğer 
	direktif bir yerel bloğa yerleştirilmişse direktifin yerleştirildiği isim alanı o yerel bloğu kapsayan isim alanıdır. 

	Derleyici using namespace direktifini gördüğünde önce direktifin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim alanını 
	tespit eder. Örneğin:

	namespace A
	{
		namespace B
		{
			//...
		}

		using namespace B;
		//...
	}

	Burada direktifin yerlşetirildiği isim alanı A'dır. Direktifte belirtilen isim alanı ise B'dir. İkisini kapsayan en dar isim alanı A'dır. Örneğin:

	using namespace std;

	Burada direktifin yerleştirildiği isim alanı global isim alanıdır. Direktifte belirtilen isim alanı ise std isim alanıdır. İkisini de kapsayan en dar isim alanı 
	global isim alanıdır. Örneğin:

	namespace A
	{
		namespace B
		{
			namespace C
			{
				//...
			}
		}

		using namespace B::C;
		//...
	}

	Burada direktifin yerleştirildiği isim alanı A, direktifte belirtilen isim alanı A::B::C'dir. İki isim alanını kapsayan en dar isim alanı A'dır.
	
	
	using direktif şöyle etki göstermektedir: Niteliksiz isim araması (unqualified name lokkup) sırasında sanki direktifte belirtilen isim alanının 
	içerisindekiler direktifin yerleştirildiği ve direktifte belirtilen isim alanı kapsana en dar isim alanına enjekte edilmiş gibi olmaktadır. Ancak 
	bu enjekte edilme niteliksiz isim aramaları (unqualified name lookup) sırasında (yani doğrudan yazılan isimlerin aranması sırasında) ve yalnızca
	direktifin yerleştirildiği faaliyet alanında etkili olmaktadır. Örneğin:
	
	#include <iostream>

	using namespace std;

	int main()
	{
		cout << "this is a test" << endl;

		return 0;
	}

	Burada cout ve endl isimleri aranırken sanki std isim alanı içerisindeki her şey global isim alanındaymış gibi bir etki oluşmaktadır. Böylece cout ve endl 
	isimleri aslında std isim alanında olduğu halde derleyici tarafından global isim alanında bulunacaktır.
	
	Tabii niteliksiz isim araması sırasında aranan isim using direktifinin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim
	alanına kadar bulunursa zaten direktifin bir etkisi kalmamaktadır. Örneğin:

	namespace CSD
	{
		int a;
	}

	using namespace CSD;

	int main()
	{
		int a;

		a = 10;				// yerel a, CSD isim alanındaki a değil

		return 0;
	}

	Burada main fonksiyonunun içerisindeki a ismi (a = 10'daki a ismi) zaten yerel blokta bulunacaktır. Dolayısıyla CSD içerisndeki a sanki global isim alanı 
	içerisindeymiş gibi oluşan etki burada bir fayda sağlamayacaktır. 

	using namespace direktifinin etki göstermesi için niteliksiz isimlerin aranmasında direktifin yerleştirildiği isim alanına baklıyor olması gerekmektedir. 
	Aksi takdirde bu direktif ilgili ismin aranmasında bir etki göstermemektedir. Örneğin:

	namespace A
	{
		namespace B
		{
			namespace C
			{
				using namespace std;

				void foo()
				{
					cout << "A::B::C::foo" << endl;		// geçerli
				}
			}
		}
	}

	int main()
	{
		cout << "this is a test" << endl;		// error!

		return 0;
	}

	Burada A::B::C içerisine yerleştirilmiş olan using namespace direktifi main fonksiyonundaki isimlerin aranmasında etkili olmaz. Çünkü main fonksiyonundaki 
	isimlerin aranması sırasında using namespace direktifi görülmemektedir. Örneğin:

	using namespace std;

	namespace A
	{
		namespace B
		{
			namespace C
			{
				void foo()
				{
					cout << "A::B::C::foo" << endl;		// geçerli
				}
			}
		}
	}

	int main()
	{
		cout << "this is a test" << endl;		// geçerli

		return 0;
	}


	Artık hem A::B::C::foo içerisindeki hem de main içerisindeki isimlerin aranmasında direktif etkili olacaktır. 

	using namespace direktifi bir yerel bloğa yerleştirilirse yalnızca o yerel bloktaki niteliksiz aramalarda direktif görüleceği için etki yalnızca o yerel 
	blokta oluşacaktır. Örneğin:

	int main()
	{
		using namespace std;

		cout << "this is a test" << endl;		// geçerli

		return 0;
	}

	void foo()
	{
		cout << "this is a test" << endl;	// geçersiz'
	}
	
	main fonksiyonu içerisindeki direktifin foo fonksiyonunda bir etkisi yoktur. 

	İsim hem direktifte belirtilen isim alanında hem de direktifin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim alanında 
	bulunursa bu durum geçersizdir. Örneğin:

	namespace CSD
	{
		int a = 10;
	}

	int a = 20;

	int main()
	{
		using namespace CSD;

		cout << a << endl;		// ambigous? Hangi a?
	
		return 0;
	}

	Tabii bu örnekte eğer isim global isim alanına kadar isim araması sırasında bulunsaydı herhangi bir sorun oluşmayacaktı. Örneğin:

	#include <iostream>

	using namespace std;

	namespace CSD
	{
		int a = 10;
	}

	int a = 20;

	int main()
	{
		int a = 100;

		using namespace CSD;

		cout << a << endl;		// main fonksiyonundaki a

		return 0;
	}

	Burada CSD içerisindeki a sanki global isim alanındaymış gibi etki göstermektedir. Oysa global isim alanında da bir a değişkeni bulunmaktadır. Bu durumda 
	isim araması başarısz olacaktır. Benzer biçimde isim birden fazla using namespace direktifi ile belirtilen isim alanında bulunyorsa bu durumda da isim araması
	başarısız olur. Örneğin:

	namespace A
	{
		int x;
		int y;
	}

	namespace B
	{
		int x;
		int z;
	}

	using namespace A;
	using namespace B;

	int main()
	{
		x = 10;		// geçersiz! hangi x?
		y = 20;		// sorun yok, A::y nalaşılır
		z = 30;		// sorun yok B::z anlaşılır

		return 0;
	}

	Tabii burada using namespace direktiflerinin yerleştirilmesinde bir sorun yoktur. Sorun a isminin niteliksiz biçimde kullanılması sırasında oluşmaktadır. 
	Bu tür durumlarda çakışma olmadığı sürece isimleri niteliksiz bir biçimde, çakışma durumda da nitelikli bir biçimde kullanabiliriz. Örneğimizde x değişkenini
	niteliksiz kullanamadığımıza göre A::x ve B::x biçiminde nitelikli kullanma yoluna gidebiliriz. 

	Niteliksiz isim aramsı sırasında using namespace direkifi ile bleirtilen isim alanında da using namespace direktifi varsa etki geçişli olarak devam eder. Örneğin:

	
	namespace A
	{
		int x;
		//...

	}

	namespace B
	{
		using namespace A;

		int y;
		//...
	}

	using namespace B;

	int main()
	{
		x = 10;			// geçerli
	
		return 0;
	}

	Burada etki şöyle düşünülmelidir. "using namespace B" direktifi ileB isim alanı içerisindeki isimler global isim alanına enjekte edilmiş gibi olmaktadır. 
	Böylece isim alanındaki "using namespace A" direktifi de sanki global isim alanındaymış gibi etkiye sahip olacaktır. Bu etki de A isim alanı içerisindekilerin
	global isim alanına enjekte edilmesine yol açacaktır. 

	Oveload resolution işlemi sırasında aday fonksiyonların seçilmesinde using namespace direktifi etkili olmaktadır. Aşağıdaki örneği inceleyiniz:

	using namespace std;

	namespace A
	{
		void foo(int a)
		{
			cout << "A::foo(int)" << endl;
		}
	}

	namespace B
	{
		using namespace A;

		void foo(long a)
		{
			cout << "B::foo(long)" << endl;
		}
	}

	void foo(double a)
	{
		cout << "::foo(double)" << endl;
	}

	using namespace B;

	int main()
	{
		foo(10);		// A::foo çağrılır
		foo(10L);		// B::foo çağrılır
		foo(3.14);		// ::foo çağrılacak
	
		return 0;
	}

	Burada tüm foo fonksiyonları aslında global isim alanındaymış gibi düşünülmelidir. Dolayısıyla bu fonksiyonların hepsi aday fonksiyon olarak seçilecektir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Nitelikli isim araması sırasında yalnızca belirtilen isim alanına bakıldığına dikkat ediniz. Örneğin:

	int a = 10;

	namespace CSD
	{
		int b = 20;
		//...
	}

	int main()
	{
		CSD::a = 10;		// geçersiz!

		return 0;
	}

	Burada CSD::a ifadesindeki a ismi nilikli bir biçimde yalnızca CSD isim alanında aranacaktır. Eğer orada bulunmazsa kapsayan isim alanlarına bakılmayacaktır.

	Nitelikli isim araması sırasında "isim ilgili isim alanında bulunamazsa" o isim alanındaki using namespace direktiflerinde belirtilen isim alanlarında da
	nitelikli arama yapılmaktadır. (Burada en dar isim alanı tanımı kullanılmamaktadır.) 
	
	Örneğin:
		
	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int y = 20;
		//...
	}

	int main()
	{
		cout << B::x << endl;		// geçerli A::x anlaşılır

		return 0;
	}

	Burada B::x ifadesindeki x ismi B isim alanında bulunamadığı için A isim alanına da bakılacak ve orada bulunacaktır. Eğer isim ilgili isim alanında bulunsaydı 
	o isim alanındaki using namespace direktifleri etkili olmayacaktı. Örneğin:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int y = 20;
		int x = 30;
		//...
	}

	int main()
	{
		cout << B::x << endl;		// geçerli, B::x anlaşılır

		return 0;
	}

	Burada B::x ifadesindeki x ismi B'de bulunduğu için A'da aranmayacaktır. Aşağıdaki örneği inceleyiniz:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		using namespace A;

		int x = 20;
		//...
	}

	namespace C
	{
		using namespace B;

		//...
	}

	int main()
	{
		cout << C::x << endl;		// geçerli, B::x anlaşılır

		return 0;
	}

	Buradaki C::x ifadesinde x'in aranması sırasında bir sorun oluşmayacaktır. Çünkü standartlara göre isim C isim alanında bulunamadığında sanki B::x gibi 
	aranacaktır. Dolayısıyla isim B isim alanında bulunduğu için sorun çıkmayacaktır. 
	
	Aşağıdaki örnekte ise C::x ifadesindeki x birden fazla isim alanında buulunacağı için isim araması başarısız olacaktır. Bu tür durumlarda using namespace 
	direkt,flerinin sırasının hiçbir önemi yoktur:

	namespace A
	{
		int x = 10;
		//...
	}

	namespace B
	{
		int x = 20;
		//...
	}

	namespace C
	{
		using namespace A;
		using namespace B;

		//...
	}

	int main()
	{
		cout << C::x << endl;	// geçersiz! ambiguity, A::x ve B::x arasında seçim yapılamaz

		return 0;
	}

	Bu tür durumlarda isimlerin farklı isim alanlarında bulunuyor olmaması gerekir. Bulunma derinliğinin bir önemi yoktur. Örneğin:

	namespace CSD
	{
		int x;
		//...
	}

	namespace A
	{
		using namespace CSD;
		//...
	}

	namespace B
	{
		int x = 20;
		//...
	}

	namespace C
	{
		using namespace A;
		using namespace B;
		//...
	}

	int main()
	{
		cout << C::x << endl;	// geçersiz! ambiguity, B::x ve CSD::x arasında seçim yapılamaz

		return 0;
	}

	Burada C::x isminin aranması yine başarısızlıkla sonuçlanacaktır. 

	using namespace direktifindeki isim alanlarına ilişkin isimler de isim aramsına sokulmaktadır. Örneğin:

	using namespace CSD::Util

	Burada derleyici CSD ismini "niteliksiz olarak", Util ismini de CSD içerisinde nitelikli olarak arayacaktır. Direktifin geçerli olması için burada belirtilen 
	isim alanı isimlerinin bulunuyor olması gerekir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													21. Ders 25/10/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    40) using namespace direktifinin dışında C++'ta ayrıca bir de "using bildirimi" denilen bir bildirim de vardır. using bildirimi bir isim alanındaki ismi 
	bir faaliyet alanına sokmak için kullanılmaktadır. Bu nedenle bu bir direktif değil bildirimdir. Çünkü bildirimlerde yeni bir isim bir faaliyet alanına 
	katılmaktadır. using bildiriminin genel biçimi şöyledir:

	using <isim_alanı_ismi>::<isim>, [<isim_alanı_ismi>::<isim>], [...];

	Buradaki isim_alanı_ismi iç bir isim alanı (nested namespace) belirtebilir. Örneğin:

	using std::cout, std::endl;
	using CSD::Util::test

	//...
	cout << "this is a test" << endl;
	test();

	Tabii using bildirimi bir faaliyet alanına yenibir ismi soktuğuna göre o faaliyet alanında o ismin tek olması gerekmektedir. Örneğin:

	namespace CSD
	{
		int a;
		//...
	}

	void foo()
	{
		using CSD::a;
		int a;				// geçersiz! aynı faaliyet alanında aynı isim birden fazla kez bildirilemez
		//...
	}

	using bildirimi bir fonksiyona uygulandığında o isim alanındaki aynı isimli tüm fonksiyonlar ilgili faaliyet alanına sokulmuş olur.  Yalnızca aynı 
	isimli tek bir fonksiyonunun using bildirimi ile faaliyet alanına sokulması mümkün değildir. Örneğin:

	namespace CSD 
	{
		void foo()
		{
			//...
		}

		void foo(int a)
		{
			//...
		}
		//...
	}

	int main()
	{
		using CSD::foo;

		foo();				// geçerli
		foo(10);			// geçerli

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
	int x, y, z;

	void foo()
	{
		cout << "CSD::foo()" << endl;
	}

	void foo(int a)
	{
		cout << "CSD::foo(int)" << endl;
	}

	void bar()
	{
		cout << "CSD::bar" << endl;
	}
}

void foo(double a)
{
	cout << "CSD::foo(double)" << endl;
}

int main()
{
	using CSD::foo, CSD::x;

	foo();				// CSD::foo()
	foo(10);			// CSD::foo(int)
	foo(3.14);			// CSD::foo(int)

	x = 10;				// geçerli
	CSD::y = 20;		// geçerli
	CSD::z = 30;		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	41) İsim alanlarına ilişkin diğer bir bildirim de "namespace alias" denilen bildirimdir. Bu bildirim bir isim alanı ismini daha kolay kullanmak için düşünülmüştür. 
	Örneğin isim alanı ismi uzun olabilir. Biz bunu kısa bir biçimde kullanmak isteyebiliriz. Ya da örneğin iç bir isim alanınını tek bir isim iel kullanmak isteyebiliriz. 
	bildirimin genel biçimi şöyledir:

	namespace <isim> = <isim_alanı_ismi>;

	Burada '=' atomunun sağında bir isim alanı bulunmak zorundadır. Bir tür ismi bulunamaz. Tabii buradaki isim alanı iç bir isim alanı olabilir. Örneğin:

	namespace U = CSD::Util;

	Artık burada U demekle CSD::Util demek tamamen aynı anlama gelmektedir. Bu işlemin bir typedef işlemi olmadığında dikkat ediniz. typedef işleminde ya da 
	onun modern biçimi olan using işleminde bir türe alternatif isim verilmektedir. İsim alanları tür belirtmemektedir. Bu nedenle bu bildirime "namespace alias"
	bildirimi denilmektedir. 	

	namespace alias bildirimi herhangi bir isim alanına ya da herhangi bir bloğa yerleştirilebilir. Tabii ismin faaliyet alanı yerleştirildiği yere bağlı olarak 
	değişmektedir. 

	namespace alias bildirimi tek tek yapılma zorundadır. Örneğin:

	namespace U = CSD::Util
	namespace T = CSD::Test

	Aşağıdaki gibi yapılamaz:

	namespace U = CSD::Util, T = CSD::Test
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	42) C++11 ile birlikte diğer bazı dillerde çeşitli biçimlerde bulunan "öznitelikler (attributes)" konusu dile eklenmiştir. Öznitelikler derleyici için 
	kullanılan direktiflerdir. Özniteliklerin temel amacı derleyicinin daha iyi kod üretmesini sağlamak, uyarı mekanizması üzerinde etkili olmak ve derleyicinin 
	bazı davranışlarını değiştirmektir. 

	C'de derleyicinin kimi davranışları komut satırı argümanlarıyla ya da #pragma direktifi yardımıyla değiştirilebilmektedir. #pragma direktifi C'de standart 
	bir direktif olmasına karşın direktifin	yanındaki komutlar derleyiciden derleyiciye değişebilmektedir. Örneğin:

	#pragma pack(1)

	struct SAMPLE {
		char a;
		short b;
		int c;
	};

	#pragma pack komutu yapı elemanlarının hizalanması üzerinde etkili olmaktadır. Bu pragma komutu pek çok derleyici tarafından desteklenmektedir. Ancak pek çok 
	pragma direktifi ilgili derleyiciye hatta ilgili platforma özgü olabilmektedir. C'de pragma direktifleri önişlemci aşamasında parse edilmektedir. Dolayısıyla
	zayıf bir kullanım alanına sahiptir. İşte öznitelikler bu pragram direktiflerinin standart ve genel bir biçimi gibi düşünülebilir. 

	C++11 ile dile eklenen öznitelikler zaman içerisinde neredeyse tüm sentaktik öğelerde kullanılabilir duruma getirilmiştir. İzleten paragraflarda tipik olarak 
	bu özniteliklerin hangi sentaktik öğelerde kullanılabileceğinin bir listesini (ayrıntılı olmayan listesini) vereceğiz. 

	Bir öznitelik oluşturmanın genel biçimleri şöyledir:

	[[öznitelik_ismi]]
	[[öznitelik_ismi()]]
	[[öznitelik_ismi(argüman_listesi)]]
	[[öznitelik_isim_alanı::öznitelik_ismi]]
	[[öznitelik_isim_alanı::öznitelik_ismi()]]
	[[öznitelik_isim_alanı::öznitelik_ismi(argüman_listesi)]]
	[[using öznitelik_isim_alanı: öznitelik_ismi, öznitelik_ismi, ...]]

	Yukarıdaki iki köşeli parantezler içerisindeki çznitelik isimleri birden fazla olabilir. Bu durumda öznitelikler ',' atomu ile ayrılmalıdır. Aşağıda 
	bazı geçerli öznitelik oluşturma örnekleri vermek istiyoruz:

	[[xxx]]
	[[xxx, yyy]]
	[[xxx(aaa, bbb)]]
	[[xxx(), yyy(aaa, bbb)]]
	[[nnn::xxx]]
	[[nnn::xxx(aaa, bbb)]]
	[[nnn::xxx(aaa, bbb), kkk::yyy(cccc)]]
	[[using N: xxx, yyy]]

	Burada xxx, yyy, aaa, bbb, ccc gibi isimler herhangi bir isim olarak kullanılmıştır. Öznitelik isim alanı iç içe olamamaktadır. Örnepşn:
	
	[[nnn::kkk::xxx]]		

	Böyle bir öznitelik isim alanı geçerli değildir. Yani öznitelik bildiriminde en fazla bir tane :: atomu kullanılmalıdır. 
	
	Bir sentaktik öğeye tek bir [[...]] yerleştirilmek zorunluluğu da yoktur. Birden fazla [[...]] aralarına başka bir atom bulundurulmadan yerleştirilebilir. 

	Yukarıda da belrttiğimiz gibi öznitelikler (attributes) pek çok sentaktik öğede kullanılabilmektedir. Özniteliğin sentakstaki yerine göre kimin için yazıldığı 
	belirlenebilmektedir. Örneğin:

	[[xxx::yyy]] void foo()
	{
		//...
	}

	Burada öznitelik fonksiyonun kendisi bulundurulmuştur. Örneğin:

	[[xxx::yyy]] int a, b, c;

	Burada öznitelik bildirimin tamamı için bulundurulmuştur. Örneğin:

	int a [[xxx::yyy]], b, c;

	Burada öznitelik a değişkeni için bulundurulmuştur. Örneğin:

	namespace [[xxx::yyy]] CSD
	{
		//...
	}

	Burada öznitelik CSD isim alanı için bulundurulmuştur. Özetle özniteliğin bulundurulduğu yer o özniteliğin sentaksın hangi parçasını nitelediğini belirtmektedir. 

	Öznitelikler kabaca şu sentaktik öğelerde kullanılabilmektedir:

	- İsim alanlarında isim alanı isimlerinden önce. Örneğin:

	namespace [[xxx::yyy]] CSD
	{
		//...
	}

	- Bildirimlerde tür belirleyicilerinden ve niteleyicilerinden önce (yani bildirimlerin başında). Örneğin:

	[[xxx::yyy]] int a, b, c;

	- Bildirimlerde dekleratördeki isimlerden sonra. Örneğin:

	int a [[xxx::yyy]], b;

	- Dizi dekleratörlerinde diziyi belirten köşeli parantezlerden sonra. Örneğin:

	int a[10] [[xxx::yyy]];

	- Gösterici ve referanslarda *, & ve && atomlarından sonra. Örneğin:

	int * [[xxx::yyy]]pi;
	int & [[xxx::yyy]] r = x;

	- Fonksiyonlarda bildirimin başında. Örneğin:

	[[xxx::yyy]] void foo()
	{
		//...
	}

	- Fonksiyonlarda fonksiyonun parantezlerinden sonra. Örneğin:

	void foo() [[xxx::yyy]]
	{
		//...
	}

	- Fonksiyonlarda fonksiyon isimlerinden sonra. Örneğin:

	void foo [[xxx::yyy]]()
	{
		//...
	}

	- Parametre değişkenlerinde tür belirleyicisndne önce. Örneğin:

	void foo([[xxx::yyy] int a, int b)
	{
		//...
	}

	- Parametre değişkenlerinde değişken isminden sonra. Örneğin:

	void foo(int a [[xxx::yyy], int b)
	{
		//...
	}

	- Deyimlerin başlarında. Örneğin:

	[[xxx::yyy]]
	if (ifade) {
		//...
	}

	[[xxx::yyy]]
	{
		ifade1;
		ifade2;
		ifade3;
	}

	[[xxx::yyy]]
	for (int i = 0; i < 10; ++i) {
		//...
	}

	- Boş deyimlerde. Örneğin:

	[[xxx::yyy]];

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
														22. Ders 30/10/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Belli bir sentaktik öğeye yerleştirilen özniteliklerin ne anlam ifade ettiği (yani semantiiği) derleyicileri yazanların isteğine bırakılmıştır. Yani 
	derleyicilerin farklı öznitelikleri olabilmektedir. Her öznitelik her sentaktik öğede geçerli olmayabilir. Örneğin bazı öznitelikler yalnızca fonksiyon 
	bidiriminde ya da tanımlamasında kullanılabilir. Bazı öznitelikler değişken tanımlamasında kullanılabilir. C++ standartlarında her derleyicinin desteklemesi 
	gereken az sayıda öznitelik baştan belirlenmiştir. (C++'ın çeşitli sürümlerinde bu listeye eklemeler yapılmıştır.) Bunlara "standart öznitelikler" diyebiliriz. 
	Standanrtlara göre isim alanı içermeyen tüm öznitelikler ve std isim alanı içeren öznitelikler "reserved" bırakılmıştır. Yani bunların programcılar tarafından 
	ve derleyiciler tarafından kullanılması yasaklanmıştır. (Genel olarak standartlarda "reserved" özelliklerin kullanılması "tanımsız davranış" olarak ele 
	alınmaktadır.) Örneğin [[xxx]] biçiminde isim alanı içermeyen bir öznitelik programcılar tarafından da derleyicleri yazanlar tarafından da kullanılmamalıdır. 
	Benzer biçimde [[std:xxx]] biçimindeki bir öznitelik de "reserved" durumdadır. O halde derleyicileri yazanlar kendileri öznitelik isim alanı uydurup kendi 
	özniteliklerini bu öznitelik isim alanı ile oluşturmalıdırlar. Örneğin [[gnu::xxx]] gibi, [[msvc::xxx] gibi. Ayrıca standartlar "derleyici tarafından tanınmayan"
	bütün özniteliklerin derleyici tarafından "görmezden gelinmesi (ignore) gerektiğini" belirtmektedir. Bu durumda biz derleyicilerde olmayan bir öznitelik ismi 
	uydursak programda herhangi bir hata ortaya çıkmayacaktır. (Tabii derleyiciler tanıyamadıkları öznitelikler için uyarı mesajları verebilirler.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi özniteliklere neden gereksinimn duyulmaktadır? Temel nedenleri şöyle ifade edebiliriz:
	
	- Derleyicilerde bazı davranışların değiştirilmesini sağlamak için
	- Derleyiciye ipucu vererek daha etkin kod üretimini sağlamak için
	- Derleyicilerin uyarı mekanizmalarında etkili olabilmek için
	- Derleyicilerin bazı "implementation defined" durumlarına yönelik açıklama yapmak için
	- Kodun okunabilirliğini artırmak için

	Konunun başında de belirttiğimiz gibi yukarıdaki amaçların bazıları komut satırı argümanlarıyla ve #pragma direktifleriyle kısmen sağlanabilmektedir. Ancak
	öznitelikler "daha genel ve çok daha spesifik" bir yöntem sunmaktadır. Öznitelikler neredeyse her sentaktik öğeye getirilebildiği için çok daha ince belirlemelerin
	yapılmasına olanak sağlamaktadır. Standart özniteliklerin yanı sıra çalıştığınız derleyiciye özgü özniteliklere göz gezdirebilirsiniz. Biz bu bölümde 
	bazı standart öznitelikleri gözden geçireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[noreturn]] özniteliği yalnızca fonksiyonlarda kullanılabilmektedir. Bir fonksiyonu bu biçimde özniteliklendirirsek derleyiciye bu fonksiyonun 
	geri dönmeyeceğini söylemiş oluruz. Böyle fonksiyonların geri dönmesi "tanımsız davranış" oluşturmaktadır. noreturn özniteliği herhangi bir argüman almamaktadır. 
	Bu öznitelik C++11'den beri bulunmaktadır. Bir fonksiyonun prototipinde ya da tenımlamasında [[noreturn]] özniteliği kullanılmışsa bütün prototiplerinde ve
	tanımlamasında bu özniteliğin kullanılması gerekmektedir. 
	
	
	Pekiyi bir fonksiyonun geri dönmemesi nasıl mümkün olabilir? İşte aşağıda bazı senaryolaır görüyorsunuz:

	[[noreturn]] void foo()
	{
		//...

		exit(EXIT_SUCCESS);
	}

	[[noreturn]] void bar()
	{
		//...

		for (;;) {			// sonsuz dönü
			//...
		}
	}

	[[noreturn]] void tar()
	{
		//...

		throw exception();
	}

	Öte yandan standrat kütüphanedeki bazı fonksiyonlar da artık [[noreturn]] ile bildirilmiştir. Örneğin exit fonksiyonu böyledir:

	[[noreturn]] void exit(int exit_code);

	
	Pekiyi bir fonksiyonun geri dönmeyeceğini derleyiciye söylemekle kim ne kazanmış olmaktadır? Derleyiciler fonksiyonları geri döndürebilmek için bazı makine
	komutlarını üretilen koda yerleştirmek zorundadır. (Örneğin pek çok işlemcide geri dönüşü "ret" isimli makine komutu sağlamaktadır. Ancak tek başına bu "ret")
	makine komutu yeterli de olmayabilir. Derleyici bazı yazmaçları geri dönmeden önce girişteki değerlerle yeniden yüklemek zorunda kalabilmektedir. Dolayısıyla
	fonksiyonun geri dönmeyeceğini anlayan derleyici bu kodları fonksiyona eklemeyebilir. Bu da daha etkin bir kod üretimi anlamına gelmektedir. Öte yandan 
	fonksiyon çağrısında da kodun geri dönmeyeceğini anlayan derleyici orada da bazı optimizasyonları yapabilmektedir. [[noreturn]] programcılar için okunabilirliği 
	de artırmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[deprecated]] özniteliği pek çok sentaktik öğeye getirilebilmektedir. Bu öznitelik ilgili özelliğin "deprecated" yapıldığını belirtir. Bu öznitelik 
	C++14 ile eklenmiştir. Örneğin:

	[[deprecated]] void foo();

	Burada foo fonksiyonunun ilgili kütüphanede artık "deprecated" yapıldığı belirtilmiştir. Deprecated sözcüğü "hala desteklenen ancak ileri verisyonlarda 
	artık kaldırılabilecek olan" öğeleri belirtmektedir. Yukarıdaki örnekte foo fonksiyonunu biz hala kullanabiliriz. Ancak ileride bu fonksiyon kaldırılabileceğine
	göre bunu kullanmamaız daha uygun olacaktır. Genellikle "deprecated" öğeler için "daha iyi" alternatifler bulundurulmaktadır. Programcının bu daha iyi olan 
	alternatifleri kullanması uygun olacaktır. Tipik olarak derleyiciler "deprecated" özellikleri gördüklerinde bir uyarı mesajıyla durumu programcıya bildirmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[likely]] ve [[unlikely]] öznitelikleri deyimlerde ve etiketlerde (labels) kullanılabilmektadır. Bu öznitelik C++20 ile eklenmiştir. Örneğin:

	if (koşul) [[likely]] {
		//...
	}
	else {
		//...
	}

	Burada if deyimim doğruysa ksımından sapması çok daha muhtemel bir durum olarak belirtilmiştir. derleyiciler bu tür durumlarda daha iyi makine komutları 
	üretebilmektedir. Bu konu "instruction scheduling", "instruction reordering" ve "jump prediction" denilen optimizasyon temalarıyla ilgilidir. İşlemciler bir
	makine komutunu yaparken aynı zamanda sonraki komutlar üzerinde de birtakım hazırlık işlemlerini yapabilmektedir. Bu nedenle if deyimlerinde mümkün olan 
	durumun makine komutları olarak öne yerleştirilmesi önemlidir. Örneğin:

	if (foo() == -1) [[unlikely]] {
		//...
	}

	Burada foo başarısız olduğunda -1 değerine geri dönüyor olsun. Programcı derleyiciye "bu fonksiyonun başarsız olma olasılığı çok düşük" demek istemektedir.
	Bu bilgiyi elde eden derleyici daha etkin makine komutları üretebilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standat [[assume(ifade)]] özniteliği belli bir noktada belli bir koşulun kesinlikle sağlanması gerektiğini belirtmktedir. Bu öznitelik boş deyime uygulanabilir. 
	(Yani bu öznitelikten sonra ';' atomunun gelmesi gerekir.) Eğer söz konusu koşul sağlanmazsa "tanımsız davranış" oluşmaktadır. Örneğin:

	void foo(int a)
	{
		[[assume(a > 0)]];
		//...
	}

	Burada fonksiyonun pozitif bir argümanla çağrılacağı derleyiciye bildirilmiştir. Derleyici bu varsayımı kullanarak daha etkin kod üretebilir. Eğer assume
	özniteliğine geçirilen argüman virgül operatörü içeriyorsa bu virgül operatörü paranteze alınmalıdır. Bu durumda virgül operatörünün sol tarafı öncül işlemi
	sağ tarafı koşulu belirtir. Örneğin:

	[[assume((foo(), x > 0))]]

	Burada foo çağrıldıktan sonra x değişkeninin değerinin pozitif olacağı belirtilmiştir. Tabii assume özniteliğindeki ifade işletilmez. Yai bu örnekte foo 
	çağrılmayacaktır. Derleyici ileride foo çağrıldığında bu çağrıdan sonra x'in 0'dan büyük olacağını anlayacaktır. Örneğin (cppreference.com sitesinden 
	alınmıştır):

	x = 3;
    int z = x;
 
    [[assume((h(), x == z))]];	
								
    h();
    g(x); // Derleyici bu işlemi g(3) ile eşdeğer olarak ele alabilir
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Standart [[fallthrough]] özniteliği swith deyimlerinde case etiketleri için kullanılmaktadır. Öznitelik boş deyimlere uygulanabilmektedir. Fallthroug işleminin 
	kasten yapıldığını belirtmektedir. Dolayısıyla derleyiciler bu tür durumlarda "yanlışlıkla yapılan fallthrough işlemlerinde" verdikleri uyarı mesajlarını 
	vermezler. Bu öznitelik C++17 ile birlikte standartlara eklenmiştir. Örneğin:

	void f(int n) 
	{
		void g(), h();

		switch (n) {
			case 1:
			case 2:
				g();
				[[fallthrough]];
			case 3: 
				h();
		}
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	standart [[maybe_unused]] özniteliği bildirilen bir değişkenin kullanılmadığında oluşabilecek uyarıyı ortadan kaldırmak için kullanılmaktadır. Bu öznitelik
	değişken bildirimlerinde, sınıf bildirimlerinde enum bildirimlerinde, enum sabit bildiriminde, typedef isimlerinin bildiriminde sınıfın veri elemanlarının,
	global fonksiyonların ve üye fonksiyonların (ileride görülecek) bildirimlerinde kullanılabilir. Örneğin:

	[[maybe_unused]] int a;

	void foo(int a, [[maybe_unused]] b)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	43) C++'ın çeşitli versyonlarında deyimlerde de bazı eklemeler yapılmıştır. 
	
	C++17 ile birlikte if deyimine isteğe bağlı bir "init kısmı" eklenmiştir. Bu init kısmı bir ifade içerir. İfadeden sonra ';' atomunun bulunması gerekir. 
	Yukarıda da belirttiğimiz gibi bu "init" kısmı deyidme bulundurulmak zorunda değildir. Dolayısıyla deyim eski biçimiyle uyumludur. Örneğin:

	if (ifade; koşul) {
		//...
	}
	else {
		//...
	}

	Bu deyim aşağıdaki ile eşdeğerdir:

	{
		ifade;

		if (koşul) {
			//...
		}
		else {
			//...
		}
	}

	if deyim,ne eklenen bu "init" kısmının adeta for döngüsünün birinci kısmı gibi deyime girişte yapıldığına dikkat ediniz. if deyiminin init ksımında bir bildirim 
	de bulunabilmektedir. Bu durumda bildirilen değişken if deyimi içerisinde kullanılabilir. Örneğin:

	if (char buf[32]; fgets(buf, 32, stdin) != NULL) {
		//...
	}

	Burada if deyiminin "init" kısmında buf dizisi bildirilmiş ve if içerisinde kullanılmıştır. Buradaki buf dizisinin faaliyet alanı if ile sınırlıdır. "init"
	kısmı boş da bırakılabilir. Tabii böyle bir kullanımın anlamı yoktur. Örneğin:

	if (; koşul) {		// geçerli ama anlamsız
		//...
	}

	Benzer biçimde switch deyimine de "init" kısmı eklenmiştir. Genel kullanım if deyiminde belirttiğimiz gibidir. Örneğin:

	switch (int x = foo(); x) {
		//...
	}

	C++20 ile birlikte Aralık tabanlı for döngülerine de "init" kısmının eklendiğini aralık tabanlı for döngülerini anlattığımız kısımda belirtmiştik. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	44) C++17 ile birlikte "constexpr if" C++23 ile de "consteval if" deyimi biçiminde yeni iki if deyimi varyasyonu eklenmiştir. constexpr if deyiminin genel biçimi 
	şöyledir:

	if constexpr ([init;] koşul) 
		<deyim>
	[
		else 
			<deyim>
	]

	constexpr if deyiminde koşul ifadesinin sabit ifadesi olması gerekmektedir. Aslında constexpr if deyimi #if önişlemci komutunu çağrıştırmaktadır. Anısanacağı
	gibi #if komutunda #if anahtar sözcüğünün yanınadaki sabit ifadesi sıfırdan farklı ise #else anahtar sözcüğüne kadarki kısım derleme modülüne veriliyordu, 
	eğer #if anahtar sözcüğünün yanındaki ifade 0 ise #else ile #endif arasındaki kod bölümü derleme modülüne veriliyordu. Başka bir deyişle #if deyiminin koşula 
	göre bir kısmı koddan atılmaktaydı. İşte constexpr if deyimi de bunun bir benzerini yapmaktadır. Ancak bu işlem önişlemci aşamasında değil derleme aşamasında
	yapılmaktadır. Örneğin:

	constexpr int x = 10;
	//...

	if constexpr (x > 0) 
		foo();
	else 
		bar();
	
	Burada if deyiminin else kısmı tamamen koddan kaldırılacaktır. consexpr if deyimi #if önişlemci komutunu çağrıştırıyor olsa da aralarında önemli farklılıklar 
	vardır. constexpr if deyiminin derleme aşamasında derleme modülü tarafından yapılıyor olması çeşitli durumlarda esneklikler sağlamaktadır. constexpr if 
	deyimi özellikle şablonlarla birlikte kullanılmaktadır. constexpr if deyiminde deyimin bir kısmı kodda atılıyor olsa bile atılan kısmın yine de sentaks ve 
	semantik kısıtları sağlıyor olması gerekmektedir. Örneğin:

	constexpr int x = 10;
	int *pi;
	//...

	if constexpr (x > 0) {
		foo();
	}
	else {
		pi = 10;			// geçersiz!
	}

	Burada constexpr if deyiminin yanlışsa kısmı koddan atılacak olsa da buradaki deyimler üzerinde sentaks ve semantik kontroller yine yapılacaktır.

	C++23 ile birlikte consteval if deyimi de dile eklenmiştir. 

	consteval if deyiminin işlevi ve gerekliliği biraz daha karmaşıktır. Deyimin genel biçimi şöyledir:

	1) 

	if consteval {
		<deyim>
	}
	[ else {
		<deyim>
	  }]
	
	2) 

	if consteval {
		<deyim>
	}
	[ else {
		<deyim>
	  }]

	
	Bu özellik C++'a çok yeni eklendiği için derleyicileriniz bu özelliği desteklemiyor olabilir. Bu if deyimi şu anlama gelmektedir: "Eğer söz konusu kod parçası 
	sabit ifadesi gereken bir bağlamda kullanılmışsa buradaki if deyimi doğruysa biçimde sapacak, eğer söz konusu kod parçası sabit ifadesi gereken bir bağlamda 
	kullanılmadıysa buradaki if deyimi yanlışsa biçiminde sapacaktır." Örneğin:

	constexpr int cube(int a)
	{
		if consteval {
			return a * a * a;
		}
		else {
			return pow(a, 3);	
		}
	}

	Burada cube fonksiyonu parametresi ile aldığı sayının kübüyle geri dönmektedir. Ancak bu constexpr fonksiyon sabit ifadesi gereken bir bağlamda da çağrılmış 
	olabilir, sabit ifadesi gerekmeyen bir bağlamda da çağrılmış olabilir. Eğer bu fonksiyon sabit ifadesi gereken bir bağlamda çağrılmışsa bu durumda consteval if 
	deyimim doğruysa kısmı derleme aşamasında devreye girecek ve a * a * a işlemi ile derleme aşamsında değer hesaplanacaktır. Eğer bu fonksiyon sabit ifadesi gerekmeyen 
	bir bağlamda çağrılmışsa bu durumda consteval if deyiminin yanlışsa kısmı devreye girecek ve küp alma işlemi derleme zanında değil fonksiyon çağrılarak 
	yapılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	45) C++'ta ilk standartlardan beri "anonim birlik (anonymous union)" oluşturma özelliği bulunmaktadır. Anonim birlik oluşturabilmek için birliğe bir isim 
	verilmemesi ve birlik bildiriminde aynı zamanda nesne tanımlamanın yapılmamış olamsı gerekmektedir. Örneğin:

	union {
		int a;
		long b;
		double c;
	};

	Burada biz a, b, ve c değişkenlerini doğrudan kullanabiliriz. Bu değişkenler çakışık yerleştirilmektedir. Yani burada yapılmak istenen şey aşağıdakiyle 
	eşdeğerdir:

	union SomeName {
		int a;
		long b;
		double c;
	};

	SomeName sn;

	Biz burada sn.a, sn.b ve sn.c ile çakışık yerleştirilen birlik elemanlarını kullanabiliriz. Ancak anonim birliklerde buna hiç gerek yoktur. 

	Yukarıda da belirttiğimiz gibi anonim birlik oluşturabilmek için birliğe isim verilmemiş olamsı gerekmektedir. Örneğin:

	union U {
		int a;
		long b;
		double c;
	};

	Burada artık biz a, b, ve c değişkenlerini doğrudan kullanamayız. Benzer biçimde:

	union {
		int a;
		long b;
		double c;
	} x;

	Burada da biz a, b ve c değişkenlerini doğrudan kullanamayız. 

	Birlikler C++'ta aslında sınıflar gibi özelliklere sahiptir. Dolayısıyla anonim birlikler sınıflara ilişkin özleliklere sahip olamazlar. (Örneğin ileride
	birliklerin içerisinde üye fonksiyonların bulunabileceğini göreceğiz. Ancak anonim birliklerde üye fonksiyonlar bulunamamaktadır.)

	Anonim birliklerin yazım kolaylığı sağladığına dikkat ediniz. Örneğin:

	union {
		int a;
		double;
	};

	ile aşağıdaki tanımlamalara dikkat ediniz:

	int a;
	double b;

	Bu ikisi tanımlama arasındaki tek fark anonim birlik tanımlamasında a ve b nesnelerinin çakışık yerleştirilmesidir. 

	Anonim birlikler bir isim alanının içerisinde (yani global düzeyde) tanımlanacaksa union anahtar sözcüğünün önüne static anahtar sözcüğünün getirilmesi 
	gerekmektedir. Örneğin:

	static union {
		int a;
		double b;
	};

	Ancak anonim birlik sisimsiz isim alanı içerisine yerleştirilirse bu static belirleyicisine gerek kalmamaktadır. Anom birliklerin elemanlarının birliğin 
	yerleştirildiği faaliyet alanına enjekte edildiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	46) C++11 ile birlikte dile static_assert isimli bir bildirim (decalartion) eklenmiştir. static_assert bildirimi derleme zamanında assert kontrolü yapmaktadır. 
	Bilindiği gibi standart assert fonksiyonu programın çalışma zamanı sırasında işleme sokulmkatadır. Halbuki static_assert bildirimi derleme aşamsında işleme 
	sokulur. Derleme aşamasında #if önişlemci komutuyla da bazı kontroller yapılıp #error önişlemci komutuyla derleme işlemi sonlandırılabilmektedir. 
	Ancak önişlemci aşamasında yapılacek kontroller oldukça sınırlıdır. assert bildiriminin genel biçimi şöyedidr:

	static_assert(sabit_ifadesi_koşulu, "mesaj");

	Derleme aşamasında eğer buradaki koşul sağlanmazsa derleyici derleme işlemini keser ve ikinci argümanla girilen hata mesajını yazdırır. Örneğin.

	static_assert(sizeof(int) >= 4, "int type too small");

	Burada programcı int türünün 4 byte'tan küçük olmamasını istemektedir. sizeof bir derleme zamanı operatörü olduğu için kontrolün bizzat derleme aşamasında 
	yapılması gerekmektedir. C++17 ile birlikte buradaki ikinci parametre artık bulundurulmak zorunda değildir. Örneğin:

	static_assert(sizeof(int) >= 4);

	Tabii static_assert bildiriminde koşulun sabit ifadesi biçiminde oluşturulması gerekmektedir. 

	Her ne kadar semantik olarak static_assert bir bildirime benzemiyorsa da static_assert C++ standartlarında bir "bildirim (declaration)" olarak gramere eklenmiştir. 

	static_assert özellikle şablonlarla birlikte sıkça kullanılmaktadır. 

	static_assert bildiriminin derleme aşmasında ele alındığına dikkat ediniz. Bu bildirim bir fonksiyonun içerisine yerleştirilirse etki göstermesi için 
	o fonksiyonun çağrılmasına gerek yoktur. Çünkü fonksiyonun çağrılması çalışma zamanına ilişkin bir etkinliği belirtir. 

	İleride göreceğimiz şablon işlemlerinde "şablon açımları (template instantiation)" derleme aşamasında yapılmaktadır. Eğer static_assert fonksiyon şablonlarında
	kullanılırsa bunların devreye girmesi "açım (instantiation)" yapılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	47) C99 ile birlikte C'ye "designated initializer" denilen ilkdeğer verme biçimi eklenmişti. Bu sayede artık C99 ve sonrasında yapıların ve dizilerin 
	elemanlarına sırasıyla ilkdeğer verme zorunluğu kaldırılmış oldu. C'de sentaks aşağıdaki gibidir:

	struct SAMPLE {
		int a, b, c, d;
	};

	struct SAMPLE s = {.c = 10, .a = 20};
	int a[10] = {[5] = 20, [3] = 30, 40};

	İşte bu "designated initiaizer" sentaksı daraltılarak C++20 ile C++'a da sokulmuştur. Ancak C99'da olmayan aşağıdaki kısıtlar oluşturulmuştur:

	- C++'ta dizilerde designated initializer kullanımı yoktur.

	- Bazı koşulları sağlayan C ile uyumlu yapılarda ve sınıflarda (C++'ta yapılar da birer sınıftır) designated initializer kullanılabilmektedir. Ancak yapıların 
	ve sınıfların sıralı elemanlarına bu biçimde değer verilebilmektedir. 

	struct Sample {
		int a, b, c, d;
	};

	Sample s = {.b = 10, .d = 20};		// geçerli
	Sample k = {.d = 20, .b = 10};		// geçersiz!

	Burada yapı (ya da sınıf) elemanlarına önceki eleman önde olacak biçimde ilkdeğer verilmek zorundadır. Halbuki C99'da böyle bir zorunluluk yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
													24. Ders 06/11/2023 - Pazartesi
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
							C++'ın Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgili Olan Farklılıkları ve fazlalıkları
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Biz şimdiye kadar "C++'ın C'den Nesne Yönelimli Programalama Tekniği İle Doğrudan İlgili Olamayan Farklılıkları ve Fazlalıkları" üzerinde durduk. Artık
	C++'ı "nesne yönelimli (object oriented)" bir dil yapan sınıflar ve onlarla ilgili konuları ele alacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ı nesne yönelimli bir dil yapan en önemli özellik "sınıflar (classes)" konusudur. Sınıflar C'deki yapılara benzer olmakla birlikte yalnızca data değil 
	aynı zamanda fonksiyon da içeren veri yapılarıdır. Yani C'deki yapılar yalnızca data içerirken C++'taki sınıflar aynı zamanda fonksiyon da içermektedir. 
	Zaten C'deki yapılar ve birlikler de artık C++'ta sınıf anlamına gelmektedir. C++'ta "sınıf türü (class type)" denildiğinde yalnızca sınıflar değil, yapılar 
	ve birlikler de anlaşılmalıdır. C++'ta bir sınıf hem data hem fonksiyon içermek zorunda değildir. Yalnızca data ya da yalnızca fonksiyon da içerebilir. Bu 
	durumda sınıf kavramı aslında C'deki yapılar üzerinde bir fazlalık gibi değerlendirilebilir. 

	Sınıflar nesne yönelimli programlama tekniğinin yapı taşlarıdır. Tüm nesne yönelimli dillerde sınıf isminde ya da bu işlevde bir veri yapısı bulunmaktadır. 
	Tabii diller arasında bu veri yapıları arasında temel özellikleri aynı olmak üzere farklılıklar bulunabilmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf bildiriminin genel biçimi şöyledir:

	class <isim> {
		[data ve fonskiyon bildirimleri ve tür tanımlamaları]
	};

	struct <isim> {
		[data ve fonksiyon bildirimleri ve tür tanımlamaları]
	};

	Örneğin:

	class Sample {
		//...
	};

	struct Mample {
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta bir sınıfın içerisindeki fonksiyonlara "üye fonksion (member function)" denilmektedir. Halbuki Java, C#, Python gibi dillerde buna "metot (method)" 
	denilmektedir. C++'ta bir sınıf "public", "protected" ve "private" olmak üzere üç bölümden oluşmaktadır. Bir bölüm, bölüm belirten anahtar sözcük ve ':' atomu 
	ile başlatılır, başka bir bölüm belirten anahtar sözcüğe kadar devam eder. Sınıf bildirimi içerisinde bu bölüm belirten anahtar sözcükler birden fazla kez 
	kullanılabilirler. Örneğin:

	class Sample {
	public:
		//...
	protected:
		//...
	private:
		//...
	public:
		//...
	private:
		//...
	};

	Sınıf isimleri pek çok programcı tarafından "Pascal tarzı (Pascal casting)" ile harflendirilmektedir. Pascal tarzında her sözcüğün ilk harfi büyük harf 
	ile yazılır. Biz de kursumuzda bu isimlendirmeyi tercih edeceğiz. Ancak C++'ın standart kütüphanesindeki sınıf isimleri "klasik C tarzı (snake casting)" 
	ile isimlendirilmiştir.

	Bir sınıf bildirimine hiçbir bölüm belirten anahtar sözcük ile başlanmazsa bu durumda sınıf bildirimi "class" anahtar sözcü ile yapılmışsa default bölüm "private",
	"struct" anahtar sözcüğü ya da "union" ile yapılmışsa default bölüm "public" biçimdedir. Bunun dışında sınıf bildiriminin class ya da struct anahtar sözcüğüyle 
	yapılmasının bir farkı yoktur. struct ve union bildirimlerinde C ile uyumu korumak amacıyla default bölüm public yapılmıştır. Örneğin:

	class Sample {
		// buradaki elemanlar private bölümde
	public:
		// buradaki elemanlar public bölümde
		
	protected:
		// buradaki elemanlar protected bölümde
	};

	Örneğin:

	struct Test {
		// buradaki elemanlar public bölümde
	private:
		// buradaki elemanlar private bölümde
	protected:
		// buradaki elemanlar protected bölümde
	};

	Sınıf içerisinde bölümlerin oluşturulma sırasının hiçbir önemi yoktur. Ancak ağırlıkı tercih edilen durum önce public, sonra protected, sonra da private
	bölümdür. Örneğin:

	class Sample {
	public:
		//...
	protected:
		//...
	private:
		//...
	};

	Tabii sınıf bildiriminde bu bölümlerin hepsi olmak zorunda değildir. Herhangi biri ya da birden fazlası olabilir. C'deki struct ve union türleri C++'ta
	birer sınıf belirtmekle birlikte C uyumunun korunması için onların default bölümü public yapılmıştır. Örneğin:

	struct Sample {
		int a, b, c;		// bu elemanlar public bölümde
	};

	Biz bu bölümlerin ne anlam ifade ettiğini görene kadar sınıf elemanlarını hep public bölüme yerleştireceğiz. 

	Diğer bazı nesne yönelimli dillerde public, protected ve private bölümlerin dışında başka bölümler de olabilmektedir. (MÖrneğin C#'ta "internal" ve "protected 
	internal" bölümler vardır.) Python gibi bazı dilelrde sınıflarda bölümler yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta sınıflar global ya da yerel biçimde bildirilebilirler. Ancak C'deki yapılarda olduğu gibi hemen her zaman sınıflar yerel değil global olarak bir 
	isim alanının içerisinde bildirilmektedir. (Hiçbir isim alanının içinde olmayan global bölgenin de "global isim alanı" denilen bir isim alanı belirttiğini 
	anımsayınız.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın üye fonksiyonlarının yalnızca prototipleri sınıf bildirimi içerisinde belirtilebilir. Tanımlamaları o sınıfın içinde bulunduğu isim alanında 
	ya da o isim alanını kapsayan isim alanlarından birinde yapılabilir. Üye fonksiyon tanımlaması sınıf dışında yapılırken fonksiyon isminin sınıf ismi ile 
	:: operatörü kullanılarak niteliklendirilmesi gerekir. Üye fonksiyonu dışarıda tanımlamanın genel biçimi şöyledir:

	<geri dönüş değerinin türü> <[isim alanı isimleri::]sınıf ismi>::<fonksiyon ismi>([prametre bildirimi])
	{
		//...
	}

	Örneğin:

	class Sample {
	public:
		void foo();
		void bar();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Standratlara göre üye fonksiyon tanımalamaları sınıf bildirimini kapsayan daha dış bir isim alanında isim alanını ismi de bedlirtilerek yapılabilir. Örneğin:

	namespace CSD
	{
		class Sample {
		public:
			void foo();
			void bar();
			//...
		};

		void Sample::foo()		// geçerli
		{
			//...
		}
	}

	void CSD::Sample::bar()		// geçerli
	{
		//...
	}

	int main()
	{
		//...

		return 0;
	}

	Tabii en normal durum sınıf bildirimi hangi isim alanı içerisinde yapılmışsa üye fonksiyon tanımalamarının da o isim alanının içerisinde yapılmasıdır. Tabii 
	using namespace direktifi ile yine sınıf isminin görülmesi sağlanabilir. Örneğin:

	namespace CSD
	{
		class Sample {
		public:
			void foo();
			void bar();
			//...
		};

		void Sample::foo()		// geçerli
		{
			//...
		}
	}

	using namespace CSD;

	void Sample::bar()		// geçerli
	{
		//...
	}

	Burada Sample ismi CSD ile niteliklendirilmemiştir. Çünkü zaten derleyici tarafından Sample ismi görülmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main(void)
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir üye fonksiyonun tanımlaması sınıf içerisinde yapılabilir. Ancak bu durumda üye fonksiyon inline kabul edilmektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo()		// foo inline
		{
			//...
		}

		void bar()		// bar inline
		{
			//...
		}
	};

	Bu nedenle programcılar inline olarak açılmasını istedikleri küçük küçük üye fonksiyonların tanımlamalarını doğrudan sınıf bildirimi içerisinde yapabilmektedir. 
	Tabii üye fonksiyonun prototipinin önüne inline anahtar sözcüğü getirilip fonksiyon yine dışarıda tanımlanırsa da inline olur. Ancak bu biçim pek tercih 
	edilmemektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		inline void foo();		// foo inlile
		inline void bar();		// bar inline
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Java ve C# gibi dillerde prototip olmadığı için mecburen sınıfın metotları sınıf içerisinde tanılanmaktadır. Bu dillerde inline diye bir kavram da yoktur. 
	Bu dillerde metotlar sınıfın içerisinde yazılmak zorunda olduğu için bölüm C++'taki gibi bölüm kavramının okunabilirliği azaltacağı düşünülmüştür. Bu nedenle 
	bu dillerde bölüm belirten anahtar sözcükler ayrıca her alan'da ve metotta belirtilmektedir. Örneğin:

	// Dikkat C#/Java örneği

	class Sample {
		private int a;
		private int b;

		public void foo()
		{
			//..
		}

		public void bar()
		{
			//...
		}

		void tar()			// C#'ta private, java'da internal
		{
			//...
		}
	}

	Bu dillerde alan ya da metotlarda erişim belirleyici anahtar sözcükler yazılmazsa default durum C#'ta private, Java'da ise internal kabul 
	edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo()
	{
		cout << "Sample::foo" << endl;
	}

	void bar(int a)
	{
		cout << "Sample::bar" << endl;
	}
};

int main(void)
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıda da belirttiğimiz gibi C++'ta bir fonksiyon ya sınıfların dışında yani global bölgede bulunabilir ya da sınıfların içerisinde bulnabilir. Sınıfların 
	içerisinde bulunan fonksiyonlara "üye fonksiyon (member function)" dendiğini söylemiştik. Biz kurusuuzda sınıfların içerisinde olmayan C'de ki gibi fonksiyonlara  
	"global fonksiyonlar (global functions)" da diyeceğiz. Tabii global fonksiyon dendiğinde global isim alanındaki fonksiyonlar anlaşılmamlıdır. Global fonksiyonlar
	sınıfların içerisinde bulunmayan fonksiyonlardır. Yani herhangi bir isim alanın içerisinde bulunan ancak bir sınıfın içerisinde bulunmayan fonksiyonlara 
	"global fonksiyon" diyeceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta sınıflar (yapıların ve birliklerin de bir sınıf olduğunu anımsayınız) bir "faaliyet alanı (scaope)" da belirtmektedir. Dolayısıyla C++'ta farklı 
	sınıflarda aynı isimli ve aynı parametrik yapıya sahip fonksiyonlar bulunabilir. Bunlar farklı faaliyet alanlarında bulundurklarından sorun oluşturmazlar. 
	Tabii aynı zamanda aynı isimli ve aynı parametrik yapıya sahip bir global fonksiyon da bulunabilmektedir. Örneğin:

	class Sample {
	public:
		void foo();
		//...
	};

	class Test {
	public:
		void foo();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Test::foo()
	{
		//...
	}

	void foo()
	{
		//...
	}

	Örnekteki bu fonksiyonların hepsinin birlikte bulunmasında hiçbir sakınca yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıflar hem data hem de fonksiyonlara sahip olabiliyordu. C++'ta sınıflar içerisindeki fonksiyonların "üye fonksiyon (member function)" biçiminde isimlendirildiğini 
	belirtmiştik. İşte C++'ta sınıftaki data elemanlarına da "veri elemanları (data member)" denilmektedir. Hem üye fonksiyonlar hem de veri elemanları sınıfın 
	elemanlarıdır. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	Burada a ve b Sample sınıfının veri elemanlarıdır. foo ve bar ise üye fonksiyonlarıdır. Sınıflardaki veri elemanlarının isimlendirilmesi dilden dile 
	değişebilmektedir. Örneğin C# ve Java'da bunlara "alan (field)" denilmektedir. Python'da ise "öznitelik (attribute)" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta her sınıf bir tür de belirtmektedir. Sınıflar türünden nesneler tanımlanabilir. Örneğin:

	class Sample {
		//...
	};

	Sample s;			// s nesnesi Sample türünden
	class Sample k;		// tür isminde class ve struct sözcükleri de kullanılabilir, ancak gereksizdir.

	Sınıfların tür isimleri yalnızca sınıf isimleriyle belirtilebilmektedir. Ancak tür isminde class anahtar sözcüğü de kullanılabilir. Örneğin:

	class Sample {
		//...
	};

	int Sample;			// geçerli
	Sample s;			// geçersiz!
	class Sample k;		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi içerisinde sınıfın üye fonksiyonları (member functions) yer kaplamaz. Üye fonksiyonlar mantıksal bakımdan sınıfla ilişkilendirilmiş durumdadır. 
	Üye fonksiyonlar tıpkı global fonksiyonlar gibi programın ".text" denilen bölümünde yer kaplarlar. Sınıf nesnesi içerisinde yalnızca sınıfın "static olmayan 
	veri elemanları (nonstatic data member)" yer kaplamaktadır. C++'ta veri elemnanları ve üye fonksiyonlar static olabilir ya da static olmayabilir. 
	Static veri elemanları ve static üye fonksiyonlar ileri ele alınacaktır. Örneğin:

	class Sample {
	public:
		int a;				// nesne içerisinde yer kaplar
		int b;				// nesne içerisinde yer kaplar
		static int c;		// nesne içerisinde yer kaplamaz! static veri elemanları ileride ele alınacak

		void foo();			// nesne içerisinde yer kaplamaz
		void bar();			// nesne içerisinde yer kaplamaz
		static void tar();	// nesne içerisinde yer kaplamaz! static üye fonksiyonlar ileride ele alınacaktır. 
	};

	Pekiyi bir sınıf nesnesi içerisindeki eleman organizasyonu nasıldır? İşte sınıf türünden türünden nesneler statik olmayan veri elemanlarından oluşan bileşik 
	nesnelerdir. C++ standartlarına göre "iki bölüm belirten anahtar sözcük arasındaki veri elemanları ilk yazılan eleman düşük adreste olacak biçimde ardışıl 
	bir biçimde" yerleştirilir. Ancak farklı bölümlerdeki elemanların birbirlerine göre durumu standartlarda derleyicileri	yazanların isteğine bırakılmıştır. 
	Fakat yaygın tüm derleyiciler bölüm farkı gözetmeksizin ilk yazılan eleman düşük adreste olacak biçimde ardışıl bir yerleşim uygulmaktadır. Tabii yine 
	derleyiciler C'de olduğu gibi elemanlar arasında hizalama amaçlı kontrollü boşluklar (padding) bırakabilmektedir. Örneğin:

	class Sample {
	public:
		int a;
		int b;
	private:
		int c;
		int d;
	};

	Burada a ile b ve c ile d ilk yazılan eleman düşük adreste olacak biçimde ardışıl yerleştirilmek zorundadır. Ancak hangi bölümün nesnenin düşük adresinde 
	bulunacağı standartlarda derleyicileri yazanların isteğine bırakılmıştır. Yaygın derleyicilerin hepsi bölümleri dikkate almaksızın tıpkı yapılarda 
	olduğu gibi elemanları yukarıdan aşağıya doğru ardışıl dizmektedir. Standartlardaki anlatıma göre biz bir sınıf nesneninin adresini aldığımızda bu adres ile
	sınıfın ilk veri elemanının adresi aynı olmak zorunda olmak zorunda değildir. (Halbuki C'deki yapılarda bir yapı nesnesinin adresi onun ilk elemanının adresi 
	ile aynı olmak zorundadır. C'de yapı nesnelerinin başında derleyiciler padding uygulayamazlar.)

	Biz kurusmuzda gösterimlerde sınıfın veri elemanlarını ilk yazılan eleman düşük adreste olacak biçimde peşi sıra geliyormuş diziliyormuş gibi göstereceğiz. 
	Böylece bazı açıklamaları daha anlaşılabilir bir hale getirebileceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main(void)
{
	Sample s;	// s'in içerisinde yalnızca a ve b veri elemanları yer kaplıyor.

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
																25. Ders 08/11/2023 - Çarşamba
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Üye fonksiyonlar global fonksiyonlar gibi doğrudan isim belirtilerek çağrılamazlar. Üye fonksiyonlar ilgili sınıf türünden bir nesne ile "." operatörü 
	kullanılarak çağrılırlar. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	Sample s;			// s Sample sınıfı türünden bir nesne

	s.foo();			// üye fonksiyonlar ilgili sınıf türünden bir nesne ile çağrılabilir
	s.bar();			// üye fonksiyonlar ilgili sınıf türünden bir nesne ile çağrılabilir

	Görüldüğü gibi bir üye fonksiyonu çağırabilmek için önce ilgili sınıf türünden bir nesnenin tanımlanmış olması gerekmektedir. 

	Burada üye fonksiyonların Sample::foo() ve Sample::bar() biçiminde çağrılmadığına, ilgili sınıf türünden bir nesne kullanılarak çağrıldığına dikkat ediniz. 
	İleri üye fonksiyonların static de olabileceğini göreceğiz. static üye fonksiyonlar nesne olmadan sınıf ismiyle niteliklendirilerek (yani Sample::tar() gibi)
	çağrılabilmektedir. Ancak biz bu konuyu anlatana kadar zaten üye fonksiyonların static olmayan (nonstatic) üye fonksiyonlar olduğunu varsayacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

void foo()
{
	cout << "global foo" << endl;
}

void bar()
{
	cout << "global bar" << endl;
}

int main(void)
{
	foo();		// global foo
	bar();		// global bar

	Sample s;		// s nesnesi Sample türünden

	s.foo();		// Sample sınıfının üye fonksiyonu olan foo
	s.bar();		// Sample sınıfının üye fonksiyonu olan bar

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların veri elemanlarına da yine ilgili sınıf türünden bir nesne ile "." operatörü kullanılarak erişilmektedir. Bu erişim biçimi zaten C'deki yapılarda 
	da böyledir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};
	//...

	Sample s;

	s.a = 10;			// geçerli
	s.b = 20;			// geçerli
	
	s.foo();			// geçerli
	s.bar();			// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;

	s.a = 10;
	s.b = 20;

	cout << s.a << endl;
	cout << s.b << endl;

	s.foo();
	s.bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta "sınıf faaliyet alanı (class scope)" isminde yeni bir faaliyet alanı daha vardır. Sınıf faaliyet alanı sınıf bildiriminin içerisinde ve
	sınıfın tüm üye fonksiyonların içerisinde bir ismin doğrudan kullanılabilirliğini anlatmaktadır. Bu durumda C++'ta faaliyet alanları genişten dara doğru 
	şöyledir:

	- Dosya faaliyet alanı (file scope)
	- Sınıf faaliyet alanı (class scope)
	- Fonksiyon faaliyet alanı (function scope)
	- Block faaliyet alanı (block scope)

	Sınıfın tüm elemanaları yani sınıf bildirimi içerisinde bildirilen tüm isimler sınıf faaliyet alanı kuralına uyarlar. Biz bu isimleri doğrudan üye fonksiyonlar 
	içerisinden kullanabiliriz. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void foo();
		void bar();
	};

	void Sample::foo()
	{
		a = 10;			// geçerli, a sınıf faaliyet alanına ilişkin 
		b = 20;			// geçerli b sınıf faaliyet alanına ilişkin 
	}

	void Sample::bar()
	{
		cout << a << endl;	// geçerli, a sınıf faaliyet alanına ilişkin 
		cout << b << endl;	// geçerli b sınıf faaliyet alanına ilişkin 

		foo();				// geçerli foo sınıf faaliyet alanına ilişkin
	}

	Burada sınıf bildiriminin içerisinde bildirilmiş olan a, b, foo ve bar değişkenleri "sınıf faaliyet alanı (class scope)" kuralına uymaktadır. Bu nedenle 
	bu isimler Sample sınıfının üye fonksiyonları içerisinde doğrudan (yani niteliklendirilmeden) kullanılabilirler. Sınıf faaliyet alanının "bir grup fonksiyon
	içerisinde" tanınma aralığı anlamına geldiğine ve bu nedenle fonksiyon faaliyet alanından daha geniş ancak dosya faaliyet alanından daha dar bir faaliyet
	alanı belirttiğine dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	a = 10;			// geçerli, a sınıf faaliyet alanına ilişkin 
	b = 20;			// geçerli b sınıf faaliyet alanına ilişkin 
}

void Sample::bar()
{
	cout << a << endl;	// geçerli, a sınıf faaliyet alanına ilişkin 
	cout << b << endl;	// geçerli b sınıf faaliyet alanına ilişkin 

	foo();				// geçerli foo sınıf faaliyet alanına ilişkin
}

int main(void)
{
	//...

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir üye fonksiyonun içerisinde kullanılan sınıfın veri elemanları aslında o üye fonksiyon hangi nesne ile çağrılmışsa o nesnenin veri elemanlarıdır. 
	Zaten üye fonksiyonların nesne ile çağrılmasının nedeni budur. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void set(int x, int y);
		void disp();
	};

	void Sample::set(int x, int y)
	{
		a = x;
		b = y;
	}

	void Sample::disp()
	{
		cout << a << ", " << b << endl;
	}

	Buradaki set ve disp iye fonksiyonlarının içerisinde a ve b değişkenleri aslında bu üye fonksiyonlar hangi nesneyle çağrılırsa onun a ve b veri elemanlarıdır.
	Örneğin:

	Sample s, k;

	s.set(10, 20);
	k.set(30, 40);

	Burada s.set(10, 20) çağırısında 10 değeri s'in a elemanına, 20 değeri ise s'in b elemanına atanmaktadır. Benzer biçimde k.set(30, 40) çağrısında da 30 ve 40
	k nesnesinin a ve b elemanlarına atanmaktadır. Örneğin:

	s.disp();
	k.disp();

	Burada s.disp() çağrısındaki a ve b s nesnesinin a ve b elemanlarıdır. Bunların içeisinde 10 ve 20 bulunduğuna göre ekrana 10 ve 20 basılacaktır. k.disp()
	çağrısındaki a ve b ise k nesnesinin a ve b elemanlarıdır. k nesnesinin a ve b elemanlarında 30 ve 40 değerleri vardır. Bu durumda 30 ve 40 değerleri 
	ekrana basılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;
	Sample k;

	s.set(10, 20);
	k.set(30, 40);

	s.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bu durumda sınıfın veri elemanları ve üye fonksiyonları ne anlama gelmektedir? İşte sınıfın veri elemanları aslında üye fonksiyonlar tarafından ortak
	bir biçimde kullanılan data'ları temsil etmektedir. Sınıfın üye fonksiyonları aynı nesnenin veri elemanlarını ortak olarak kullanmaktadır. Bir üye 
	fonksiyon o elemanlara değer yerleştirdiğinde diğer bir üye fonksiyon o değerleri kullanabilmektedir. Sınıflar belli bir konuda faydalı işlemler yapan 
	üye fonksiyonlardan oluşmaktadır. Üye fonksiyonların da bu faydalı işlemleri yapabilmesi için ortak veri elemanlarını kullanması gerekmektedir. 

	NYPT'de sınıflar belli bir konu (kavram) üzerinde işlemler yapan üye fonksiyonlar gibi değerlendirilebilir. Örneğin Date isimli bir sınıf tarih konusunda 
	yararlı birtakım işlemleri yapan üye fonksiyonlara sahip olabilir. String isimli bir sınıf bir yazı üzerinde işelmler yapan üye fonksiyonlara sahip olabilir. 
	Benzer biçimde SerialPort isimli bir sınıf seri port işlemlerini yapan üye fonksiynlara sahip olabilir. 

	NYPT'de artık fonksiyonlar temelinde konuşmak yerine sınıflar temelinde konuşulur. Böylece "birbirinden farklı çok sayıda fonksiyon var" algısı yerine 
	"belli işlemleri yapan belli sınıflar var" oluşturulmaktadır. Bu da tasarım ve yazım işlemlerini algısal bakımdan kolaylaştırmaktadır. 

	O halde biz NYPT'de bir sınıf ile karşılaştığımıuzda "bu sınıfın belli bir konu üzerinde faydalı işlemler yapan üye fonksiyonlara sahip olduğunu, bu üye 
	fonksiyonların da sınıfın veri elemanlarını (yani nesnesinin parçalarını) ortak biçimde kullanıdığını" anlamalıyız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın bir üye fonksiyonu başka bir üye fonksiyonunu doğrudan (niteliklendirmeden) çağırabilir. Çünkü üye fonksiyonlar da sınıf faaliyet alanındadır. Bu durumda 
	çağıran üye fonksiyon hangi nesneyle çağrılmışsa çağrılan üye fonksiyonun da aynı nesneyle çağrılmış olduğu kabul edilir. Örneğin:

	class Sample {
	public:
		int a;
		int b;

		void set(,nt x, int y);
		void disp();
	};

	void Sample::set(int x, int y)
	{
		a = x;
		b = y;

		disp();		// set hangi nesneyle çağrılmışsa disp de o nesneye çağrılmış gibi işlem görür
	}

	void Sample::disp()
	{
		cout << a << ", " << b << endl;
	}

	Burada set fonksiyonu şöyle çağrılmış olsun:

	Sample s;

	s.set(10, 20);

	Bu durumda set içerisindeki a ve b elemanları s nesnesinin a ve b elemanlarıdır. set üye fonksiyonu disp üye fonksiyonunu çağırmıştır. İşte burada sanki 
	disp üye fonksiyonu da s ile çağrılmış gibi bir etki oluşacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;

	disp();
}

void Sample::disp()
{
	cout << a << ", " << b << endl;
}

int main()
{
	Sample s;

	s.set(10, 20);

	return 0;
}

<BURADA KALDIK>

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın üye fonksiyonları da overload edilebilir. Yani bir sınıf içerisinde parametrik yapıları farklı olan aynı isimli üye fonksiyonlar bulunabilir. 
	Bu durumda "overload resolution" işlemi daha önce açıkladığımız kurallarla yürütülmektedir. Örneğin:

	class Sample {
		public:
			void foo(int a);
			void foo(double a);
			void foo(const char *str);
			//...
	};

	Sample s;

	s.foo(10);		// foo(int)
	s.foo(12.3);	// foo(double)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın üye fonksiyonları sınıfın veri elemanları üzerinde işlem yapan fonksiyonlardır. Başka bir deyişle sınıfın veri elemanları aslında üye fonksiyonlar
	tarafından ortak kullanılan elemanlardır. Eğer bir üye fonksiyon sınıfın veri elemanları ile ilgili işlem yapmasaydı bu durumda o üye fonksiyon global bir fonksiyon gibi de
	yazılabilirdi.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi yaratıldığında derleyici tarafından otomatik olarak çağrılan sınıfın özel üye fonksiyonlarına "yapıcı fonksiyonlar (constructors)" denilmektedir. 
	Yapıcı fonksiyonlar tipik olarak birtakım ilk işlemleri yapmak ve sınıfın veri elemanlarına birtakım ildeğerleri vermek için kullanılmaktadır. 

	Yapıcı fonksiyonlar sınıf ismiyle aynı isimli olan üye fonksiyonladır. Yapıcı fonksiyonlar da overload edilebilirler. Sınıfın parametresiz yapıcı fonksiyonuna özel olarak
	"default yapıcı fonksiyon (default constructor)" denilmektedir. 

	Yapıcı fonksiyonların geri dönüş değerleri diye bir kavramları yoktur. Bu nedenle yapıcı fonksiyonlarda geri dönüş değerlerinin türü yerine hiçbir şey yazılmaz.
	Geri dönüş değerinin türü yerine void yazmak da geçerli bir durum değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);
	
};

Sample::Sample()
{
	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	a = x;
	b = y;
}

int main(void)
{
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi eğer isimden sonra hiç parantez açılmadan tanımlanırsa bu durumda derleyici nesne için sınıfın default yapıcı fonksiyonunu (default constructor)
	çağırır. Örneğin:

	Sample s;

	Eğer isimden sonra parantezler açılırsa parantezlerin içerisine argümanlar yerleştirilir. Bu durumda overload resolution kuralına göre çağrılacak yapıcı fonksiyon
	tespit edilir. Örneğin:

	Sample s(10, 20);

	Bu durumda tüm aday fonksiyonlar sınıfın yapıcı üye fonksiyonlardır. Bunlar arasından uygun olanlar ve nihayet en uygun yapıcı fonksiyon seçilmeye çalışılır. 
	C++11 ile birlikte "uniform initializer" sentaks ile burada küme parantezleri de kullanılabilmektedir. Ancak uniform initializer sentaksında "narrowing conversion"a 
	izin verilmediğini anımsayınız. Örneğin:

	Sample s{10, 20};

	Burada "narrowing conversion" dikkate alınarak uygun fonksiyonlar tespit edilmemektedir. Önce en uygun fonksiyon overload resolution kurallarına göre bulunmakta 
	eğer bu en uygun fonksiyon narrowing conversion gerektiriyorsa error oluşmaktadır. 

	Default yapıcı fonksiyon çağrılacak biçimde nesne yaratma işlemi aşağıdaki gibi yapılamamaktadır:

	Sample s();

	Çünkü bu bir prototip bildirimidir. Tabii C++11 ile birlikte aşağıdaki tanımlama default yapıcı fonksiyonun çağrılması için geçerlidir:

	Sample s{};

	Çünkü böyle bir prototip bildirim sentaksı yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);

};

Sample::Sample()
{
	cout << "default constructor" << endl;

	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	cout << "int, int constructor" << endl;
	a = x;
	b = y;
}

int main(void)
{
	Sample s;
	Sample k(10, 20);

	cout << "ok" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yerel sınıf nesneleri için yapıcı fonksiyonlar programın akışı nesnenin tanımlandığı noktaya geldiğinde çağrılmaktadır. Ancak global sınıf nesneleri için yapıcı 
	fonksiyonlar akış main fonksiyonuna girmeden önce çalıştırılır. Global sınıf nesneleri için yapıcı fonksiyonların çağrılma sırası yukarıdan aşağıya doğrudur. 
	Ancak program birden fazla kaynak dosyadan oluşuyorsa bunlar arasındaki sıra "belirsiz (unspecified)" bırakılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);
};

Sample::Sample()
{
	cout << "default constructor" << endl;

	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	cout << "int, int constructor" << endl;
	a = x;
	b = y;
}

Sample x;
Sample y(10, 20);

int main(void)
{
	cout << "main begins..." << endl;

	Sample k(30, 40);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yapıcı fonksiyonların içerisinde kullandığımız sınıfın veri elemanlarının o anda henüz yaratılmış olan nesnenin veri elemanları olduğuna dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	int day, month, year;

	Date(int d, int m, int y);
	void disp();
};

Date::Date(int d, int m, int y)
{
	day = d;
	month = m;
	year = y;
}

void Date::disp()
{
	cout << day << '/' << month << '/' << year << endl;
}

int main(void)
{
	Date d{ 10, 12, 2007 };

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer programcı sınıf için hiçbir yapıcı fonksiyon yazmamışsa (standart terminolojisi ile sınıfın "user provided" yapıcı fonksiyonu yoksa) bu durumda derleyici 
	sınıf için default yapıcı fonksiyonu public bölümde içi boş olarak inline biçimde kendisi tanımlar. Böylece biz bir sınıf için hiçbir yapıcı fonksiyon yazmadıysak
	o sınıf türünden default yapıcı fonksiyonun çağrılacağı bir nesne tanımlayabiliriz. Eğer biz bir sınıf için herhangi bir yapıcı fonksiyon yazmışsak bu durumda
	derleyici default yapıcı fonksiyonu kendisi yazmamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	//...
};

class Mample {
public:
	Mample(int a)
	{}
};

int main(void)
{
	Sample s;		// geçerli, default yapıcı fonksiyon derleyici tarafındna yazılmış
	Mample k;		// geçersiz! sınıf için programcı yapıcı fonksiyon yazdığından dolayı artık derleyici 
					// default yapıcı fonksiyonu kendisi yazmaz.

	Mample m(10);	// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte "explicitly defaulted constructor" biçiminde bir kavram dile eklenmiştir. Bir default yapıcı fonksiyon için prototipten sonra " = default"
	sentaksı kullanılırsa bu sentaks derleyiciye "default yapıcı fonksiyonu içi boş olarak sen yaz" anlamına gelmektedir. Örneğin:

	class Sample {
	public:
		Sample() = default;
		Sample(int a, int b);
		//...
	};

	Burada sınıfın başka bir yapıcı fonksiyonu olduğu için derleyici default yapıcı fonksiyonu kendiliğinden yazmayacaktır. İşte " = default" 
	sentaksı bunu sağlamaktadır. Tabii "= default" dentaksı yerine bir zaten içi boş bir default yapıcı fonksiyonu kendimiz de oluşturabilirdik. Ancak teknik anlamda 
	aşağıdaki yazım arasında bazı ince farklılıklar vardır:

	Sample() = default;
	Sample() {}

	Bu farklılıklar hakkında henüz bir açıklama yapmayacağız.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yine C++11 ile birlikte "deleted constructor" sentaksı da dile eklenmiştir. Bir default yapıcı fonksiyonda " = delete" sentaksı kullanılırsa artık derleyici 
	sınıfın programcı tarafından yazılmış olan bir yapıcı fonksiyonu olmasa bile sınıfın default yapıcı fonksiyonunu kendisi yazmaz. 

	Tabii default yapıcı fonksiyonun bu biçimde silinmesi fazlaca karşılaşılan bir durum değildir ve böyle bir duruma çok seyerek gereksinim duyulmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = delete;
	//...
};

int main(void)
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin yaşamı sona ererken yani sınıf nesnesi bellekten yok edilirken derleyici tarafından otomatik olarak çağrılan üye fonksiyona
	"yıkıcı fonksiyon (destructor)" denilmektedir. Yıkıcı fonksiyonların isimleri ~sınıf_ismi biçimindedir. (~ ile sınıf ismi bitişik yazılmak zorundadır).
	Yıkcı fonksiyonların da geri dönüş değerleri biçiminde bir kavramları yoktur. Yani bunların da geri dönüş değerleri yerine bir şey yazılmaz. Yıkıcı fonksiyonlar
	overload edilemezler. Yıkıcı fonksiyonlar parametresiz biçimde bulunurlar. 

	Yıkıcı fonksiyonlar yapıcı fonksiyonlar tarafından yapılan birtakım ilk işlemleri geri almak amacıyla kullanılmaktadır. Ancak yıkıcı fonksiyonlara yapıcı 
	fonksiyonlar kadar gereksinim duyulmamaktadır. Çünkü bir sınıf nesnesi için o nesne yok edilirken yapılacak özel bir şeyler	olmayabilir. 
	Eğer programcı sınıfı için yıkıcı fonksiyon yazmamışsa sınıf için yıkıcı fonksiyon derleyici tarafından public bölümde inline olarak
	içi boş bir biçimde yazılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	~Sample();
	//...
};

Sample::Sample()
{
	cout << "default constructor" << endl;
}

Sample::~Sample()
{
	cout << "dstructor" << endl;
}

int main(void)
{
	Sample s;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin yapıcı fonksiyon ieçrisinde new operatörü ile bir bellek tahsisatı yapılmış olabilir, bu tahsisat yıkıcı fonksiyon içerisinde delete operatörüyle
	free hale getirilebilir. 

	Aşağıdaki örnekte String sınıfının str isimli veri elemanı için sınıfın yapıcı fonksiyonunda bir tahsisat yapılmıştır. Bu tahsisat sınıfın yıkıcı fonksiyonunda 
	serbest bırakılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstring>

using namespace std;

class String {
public:
	char *str;

	String();
	String(const char *s);
	~String();

	void disp();
};

String::String()
{
	str = new char[1]{ '\0' };
}

String::String(const char *s)
{
	str = new char[strlen(s) + 1];
	strcpy(str, s);
}

String::~String()
{
	delete[] str;
}

void String::disp()
{
	cout << str << endl;
}

int main(void)
{
	String s("ankara");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta ilerideki konuları da kapsayacak biçimde yapıcı ve yıkıcı fonksiyonların çağrılma sıraları ile ilgili temel bir kural vardır: "C++'ta her zaman yapıcı fonksiyonlarla 
	yıkıcı fonksiyonlar ters sırada çağrılırlar." Örneğin a, b, c nesnelerinin yapıcı fonksiyonlarının bu sırada çalıştırılmış olduğunu varsayalım.,
	Bunların yıkıcı fonksiyonları c, b, a biçiminde çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yerel sınıf nesneleri için yıkıcı fonksiyonlar programın akışı o yerel nesnenin tanımlandığı bloktan çıkarken çağrılmaktadır. Eğer o blokta birden fazla yerel sınıf nesnesi 
	tanımlanmışsa bunların yıkıcı fonksiyonları ters sıra çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;

	Sample(int x);
	~Sample();
};

Sample::Sample(int x)
{
	a = x;
	cout << "constructor: " << a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << a << endl;
}

int main(void)
{
	Sample s(10), k(20);

	{
		Sample m(30);
		Sample r(40);

		cout << "nested block ends..." << endl;
	}
	
	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Global sınıf nesneleri için yıkıcı fonksiyonlar akış main fonksiyonundan çıktıktan sonra yapıcı fonksiyonlara göre yine ters sırada çağrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;

	Sample(int x);
	~Sample();
};

Sample::Sample(int x)
{
	a = x;
	cout << "constructor: " << a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << a << endl;
}

Sample x(100);

int main(void)
{
	cout << "main begins..." << endl;

	Sample s(10), k(20);

	{
		Sample m(30);
		Sample r(40);

		cout << "nested block ends..." << endl;
	}
	
	cout << "main ends..." << endl;

	return 0;
}

Sample y(200);

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte sınıfların yıkıcı fonksiyonları da "defaulted" ve "deleted" yapılabilmektedir. Zaten bir sınıf için yıkıcı fonksiyon 
	yazılmamışsa derleyici tarafından onun içi boş olarak yazılacağını belirtmiştik. O halde bir yıkıcı fonksiyonun defaulted yapılmasının anlamı ne olabilir?
	İşte bazı ince konular için bu durum gerekli olabilmektedir. Yine bir yıkıcı fonksiyonun "deleted" yapılması ise çok seyrek bazı durumlarda gerekebilmektedir.
	Yıkıcı fonksiyon deleted yapılırsa artık biz o sınıf türünden nesneyi yok edemeyiz. Çünkü yok ederken yıkıcı fonksiyon çağrılmaktadır. Bu tür durumlarda hata 
	link aşamasında değil derleme aşamasında ortaya çıkmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	Sample() = default;
	~Sample() = delete;
};

int main(void)
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın yapıcı fonksiyonları nesneyle normal bir üye fonksiyon gibi çağrılamaz. Ancak yıkıcı fonksiyonları normal bir üye fonksiyon gibi çağrılabilmektedir. Örneğin:

	class Sample {
		//...
	};
	//...

	Sample s;

	s.Sample();		// geçersiz! yapıcı fonksiyonlar açıkça çağrılamazlar
	s.~Sample();	// geçerli, yıkıcı fonksiyonlar diğer üye fonksiyonlar gibi çağrılabilirler. 

	Tabii yıkıcı fonksiyonların açıkça çağrılması dikkat edilmesi gereken özel bir durumdur. Çünkü progracı yıkıcı fonksiyonları açıkça çağırdıktan sonra yine 
	nesne hayatını kaybederken derleyici tarafından çağrılacaktır. Bu durumda bu fonksiyonun iki kez çağrılması sorunlara yol açabilecektir. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın veri elemanları tüm üye fonksiyonlar içerisinden doğrudan kullanılabilmektedir. İşte bu durum faaliyet alanı bakımından bu veri elemanı isimlerinin yanlışlıkla
	gizlenmesi sonucunu doğurabilmektedir. Örneğin bir üye fonksiyonun parametre değişkeni sınıfın bir veri elemanının ismiyle aynı olursa biz bu üye fonksiyon içerisinde
	artık sınıfın bu veri elemanına erişemeyiz: Çünkü C ve C++'ta aynı blokta birden fazla aynı isimli değişken faaliyet gösteriyorsa o blokta dar faaliyet alanına
	sahip olan değişkenlere erişilebilmektedir. Yine bir üye fonksiyonu inceleyen kişi oradaki değişkenin bir veri elemanı ya da bir yerel değişken olup olmadığını çabuk anlarsa
	kodu daha iyi anlamlandırır. İşte bu ndenlerden dolayı C++ programcıları sınıfın veri elemanlarını özel öneklerle ya da soneklerle isimlendirmektedir. Örneğin Microsoft 
	sınıfların veri elemanlarını m_xxxx biçiminde m_ öneki ile isimlendirmektedir. Bazı programcılar da d_ önekini tercih ederler. Biz de kursumuzda bundan sonra sınıfın bütün 
	veri elemanlarını m_xxxx biçiminde m_ öneki ile isimlendireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	int m_day, m_month, m_year;

	Date(int d, int m, int y);
	void disp();
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main(void)
{
	Date date(10, 12, 1995);

	date.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların public, protected ve private bölümleri sınıf elemanlarına nereden erişilebileceği üzerinde etkili olmaktadır. Sınıflardaki erişim kuralları şöyledir:

	1) Sınıfın elemanlarına o elemanlar hangi bölümde olursa olsun sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde doğrudan erişilebilir. 

    2) Sınıfın public bölümü dışarıdan erişime açık olan bölümüdür. Sınıfın public bölümündeki elemanlara o sınıf türünden nesnelerle ya da referanslarla "." opeatörünü kullanarak, 
	ya da o sınıf türünden göstericilerle "->" operatörünü kullanarak her yerden erişebiliriz. Biz şimdiye kadar sınıfın bütün elemanlarını public bölümde
	aldık.

	3) Sınıfın private bölümündeki elemanlara sınıfın üye fonksiyonu olmayan bir fonksiyon içerisinde o sınıf türünden bir nesne, referans ya da gösterici yoluyla "." ya da 
	"->" operatörünü kullanarak erişemeyiz. Yani private bölümdeki elemanlar sınıfın dışından erişime kapalıdır. 

	4) Sınıfın protected bölümü dışarıdan (yani sınıfın üye fonksiyonu olmayan fonksiyonlardan) erişime kapalı ancak türemiş sınıf erişimine açık bölümüdür. 
	Sınıfın protected bölümündeki elemanlara türemiş sınıfın üye fonksiyonları doğrudan erişebilmektedir. Ancak private bölümdeki elemanlara türemiş sınıfın üye fonksiyonları 
	tarafından da erişilememektedir. 

	Sınıfın en korunaklı bölümü private bölümdür. Bu bölümdeki elemanlara yalnızca sınıfın üye fonksiyonları tarafından yani sınıfın kendisi tarafından erişilebilmektedir. 
	Sınıfın herkese açık bölümü public bölümdür. public bölümdeki elemanlara sınıfın dışından (yani sınıfın üye fonksiyonu olmayana fonksiyonlardan) o sınıf türünden nesne ya da
	gösterici yoluyla erişilebilmektedir. 
	Sınıfın protected bölümü dışarıdan erişilemeyen ancak türemiş sınıflar tarafından erişilebilen bölümüdür. Sınıfın bölümleri korunaklılık durumuna göre public, protected, 
	private biçimindedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int m_a;
	void foo();
protected:
	void bar();
private:
	int m_b;
	void tar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample:bar" << endl;
}

void Sample::tar()
{
	cout << "Sample::tar" << endl;
}

int main(void)
{
	Sample s;

	s.foo();		// geçerli, foo public bölümde
	s.tar();		// geçersiz! tar private bölümde

	s.m_a = 10;		// geçerli, m_a public bölümde
	s.m_b = 20;		// geçersiz! m_b private bölümde

	s.bar();		// geçersiz! bar protected bölümde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne yaratırken o sınıfın yapıcı ve yıkıcı fonksiyonlarının o anda erişilebilir olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	Sample();
	//...
};

Sample::Sample()
{
	//...
}

int main()
{
	Sample s;		// error! yapıcı fonksiyon private bölümde, erişilebilir değil!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT (Nesne Yönelimli Programlama Tekniğinin) birtakım anahtar kavramların birleşimi olarak düşünülebilir. Bu anahtar kavramlar birbirleriyle 
	iç içe geçmiş durumdadır. NYPT'nin anahtar kavramlarından biri "kapsülleme (encapsulation)" denilen kavramdır. Kapsülleme bir olguyu bir sınıfla temsil edip, 
	sınıfın dış dünyayı ilgilendirmeyen, iç işleyişe ilişkin kısımlarının private bölüme yerleştirilerek dış dünyadan gizlenmesi anlamına gelmektedir. Kapsülleme 
	aslında gerçek dünyada da karşılaştığımız bir olgudur. Örneğin arabanın önemli fakat kullanıcıyı ilgilendirmeyen öğeleri kaput içerisine gizlenmiştir. Biz televizyonu
	yalnızca public bölümü temsil eden kumandayla kullanırız. Televizyonun iç devreleri çerçeve içerisinde gizlenmiştir. Bir bankaya gittiğimizde biz yalnızca
	public bölümdeki memurlarla işlerimizi yürütürüz. Bankanın temizliği ile, yönetmi ile, oradaki kişilerin birbirleriyle ilişkileri ile kafamızı yormayız. 
	Bunlar o sınıfın private bölümündeki öğelerdir. 

	Bir sınıf için iki bakış açısı önemlidir: Sınıfı kullananların bakış açısı ve sınıfı yazanların bakış açısı. Sınıfı kullananlar yalnızca public bölüm ile ilgilenirler. 
	Sınıfı yazanlar ise sınıfın her bölümünü bilmek durumundadırlar. Sınıfın kullanıcı için dokümantasyonu yapılırken private bölüm açıklanmaz. Yalnızca public ve protected 
	blümlerin dokümantasyonu yapılır. 

	Örneğin Sample isimli bir sınıf yazacak olalım. Bu sınıfın do_something_important isimli bir üye fonksiyonu olsun. Bu fonksiyon da işlemlerini yapmak için işin bazı
	kısımlarını yapan foo, bar, tar üye fonksiyonlarını çağırıyor olsun. Birisibin bu foo, bar, tar fonksiyonlarını çağırmasının bir anlamı olmadığı gibi bunları
	çağırması sorunlara da yol açabilir. Budurumda bizim foo, bar, tar fonksiyonlarını sınıfın private bölümünde gizlememiz uygun olur.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void do_something_important();
private:
	void foo();
	void bar();
	void tar();
};

void Sample::do_something_important()
{
	//...
	foo();
	//..
	bar();
	//...
	tar();
	//...
}

int main(void)
{
	Sample s;

	s.do_something_important();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcılar tarafından genel olarak sınıfın veri elemanları iç işleyişe ilişkin oldukları gerekçesiyle sınıfın private bölümünde gizlenmektedir. Bu duruma
	NYPT'de "veri elemanlarının gizlenmesi (data hiding)" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.disp();

	Date k{10, 12, 2005};

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarını private bölüme yerleştirince artık bunlara dışarıdan erişemeyiz. Ancak erişmek istersek ne yapaliriz? İşte private veri elemanlarına
	dışarıdan erişebilmek için sınıfın public bölümüne o elemanların içeriisndeki değerleri alan "getter" üye fonksiyonlar, o elemanların içerisine değer yerleştiren 
	"setter" üye fonksiyonlara gereksinim duyulmaktadır. Bu tür fonksiyonlara "erişimci fonksiyonlar (accessors)" denilmektedir. Erişimci fonksiyonlar genellikle (her zaman değil)
	küçük fonksiyonlar olma eğilimindedir. Bu nedenle bunların inline olarak yazılabilirler. 

	getter fonksiyonların isimleri programcılar tarafından ilgili veri elemanı xxx olmak üzere getxxx, get_xxx, getXxx ya da xxx() biçiminde verilebilmektedir. Deve notasyonu C++'ta
	sıkça kullanılmaktadır. Ancak C++'ın standart kütüphanesinde klasik alt tireli yazım tercih edilmiştir. Benzer biçimde setter fonksiyonların isimleri de 
	setxxx, set_xxx, setXxx viçiminde verilebilmektedir. C++'ta farklı parametrik yapılara ilişkin aynı isimli fonksiyonlar bulunabildiğine göre getter ve setter fonksiyonların
	isimleri de aynı olabilir. Bazı programcılar her iki erişimciye de aynı ismi verebilmektedir. Örneğin sınıfın m_day elemmanına erişmek için erişimciler şöyle de isimlendirilebilmektedir:

	int day();				// getter
	void day(int day);		// setter

	Yukarıdaki Date sınıfı için erişimci fonksiyonları aşağıdaki gibi yazabiliriz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() 
	{ 
		return m_day; 
	}

	void set_day(int day)
	{
		m_day = day;
	}

	int month()
	{
		return m_month;
	}

	void set_month(int month)
	{
		m_month = month;
	}

	int year()
	{
		return m_year;
	}

	void set_year(int year)
	{
		m_year = year;
	}

private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.disp();

	cout << d.day() << '/' << d.month() << '/' << d.year() << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarını private bölüme yerleştirmenin gerekçelerinden biri şudur: Sınıfın veri elemanları tür ve isim bakımından sıkça değiştirilme potansiyelindedir.
	Eğer onlar sınıfın public bölümüne yerleştirilseler onları programcı doğrudan kullanabileceği için onlarda yapılacak değişiklik onları kullanan kodları geçersiz 
	hale getirecektir. Ancak veri elemanları prvate bölüme yerleştirildiğinde ve onlara public getter/setter fonksiyonlarla erişildiğinde onlarda değişikler yapıldığında bu 
	getter/setter fonksiyonların içi yeniden düzenlenerek onları kullanmış olan kodların bu değişiklikten etkilenmemesi sağlanabilmektedir. 

	Yukarıdaki Date sınıfında biz tarih bilgisini üç int nesne yerine 11 elemanlı bir char dizide "mm/dd/yyy" biçiminde bir yazı olarak tutmak isteyelim. Bu durumda
	bizim amacımız daha önce yazılmış olan kodların bu değişiklikten etkilenmemesini sağlamak olmalıdır. İşte biz de bunun için sınıfın üye fonksiyonlarının içini değiştirirz. 
	Bu değişikliği sınıfı kullanan kişiler fark etmezler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <cstdlib>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() 
	{ 
		return atoi(m_date);
	}

	void set_day(int day)
	{
		sprintf(m_date, "%02d", day);
		m_date[2] = '/';
	}

	int month()
	{
		return atoi(m_date + 3);
	}

	void set_month(int month)
	{
		sprintf(m_date + 3, "%02d", month);
		m_date[5] = '/';
	}

	int year()
	{
		return atoi(m_date + 6);
	}

	void set_year(int year)
	{
		sprintf(m_date + 6, "%04d", year);
	}

private:
	char m_date[11];		// "dd/mm/yyyy"
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	sprintf(m_date, "%02d/%02d/%04d", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900);
}

void Date::disp()
{
	cout << m_date << endl;
}

Date::Date(int day, int month, int year)
{
	sprintf(m_date, "%02d/%02d/%04d", day, month, year);
}

int main(void)
{
	Date d;

	d.disp();

	cout << d.day() << '/' << d.month() << '/' << d.year() << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer biz veri elemanlarını sınıfın private bölümüne yerleştirip onlara değer atamayı setter fonksiyonlarına yaptırırsak bu durumda onlara atanacak değerin
	sınamasını bu setter fonksiyonları içerisinde yapabiliriz. Sınamanın başarısz olduğu durumda bir exception fırlatılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day()
	{
		return m_day;
	}

	void set_day(int day)
	{
		if (day < 1 || day > 31)
			throw invalid_argument("invalid day");

		m_day = day;
	}

	int month()
	{
		return m_month;
	}

	void set_month(int month)
	{
		if (month < 1 || month > 12)
			throw invalid_argument("invalid month");

		m_month = month;
	}

	int year()
	{
		return m_year;
	}

	void set_year(int year)
	{
		m_year = year;
	}

private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.set_day(40);		// eception oluşacak!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen sınıfın veri elemanları arasında birtakım ilişkiler söz konusu olabilir. Yani bir veri elemanının değerini değiştirdiğimizde başka veri elemanlarının değerlerini 
	ona göre değiştirmek durumunda kalabiliriz. İşte bu tür durumlarda sınıfın veri elemanlarını public bölüme yerleştirirsek bu durumda tüm ilişkiyi programcının bilmesi 
	ve uygulaması gerekir. Halbuki bu veri elemanlarını private bölüme yerleştirirsek bu ilişki setter fonksiyonlarında arka planda oluşturulabilir. 

	Aşağıdaki örnekte Circle sınıfının m_radius elemanı m_area elemanı ile ilişkilidir. set_radius işleminde m_area elemanı da değiştirilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Circle {
public:
	Circle(double x, double y, double radius)
	{
		m_x = x;
		m_y = y;
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	void set_radius(double radius)
	{
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	void foo();		// m_area'yı kullanıyor
	void bar();		// m_area'yı kullanıyor
	void tar();		// m_area'yı kullanıyor

private:
	double m_x;
	double m_y;
	double m_radius;
	double m_area;
};

int main(void)
{
	Circle c(1, 2, 3);

	c.set_radius(4);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen sınıfın bir veri elemanı üzerinde işlem yaparken arka planda başka birtakım işlemlerin de yapılması gerekebilir. Örneğin SerialPort isimli bir sınıfta
	seri porun hızı sınıfın public bir m_baudrate elemanında tutuluyor olsun. Biz şimdi bu elemana değer yerleşirdiğimizde seri portu hızı değişmeyecektir. 
	Seri portun hıznını değiştirmek için UART işlemcisiin programlanması gerekir. Ancak biz m_baudrate elemanını private bölümde tutup onu set_baudrate fonksyonu ile
	set etmeye kullanıcıyı zorlarsak set_baudrate fonksiyonu içerisinde biz UART işlemcisini de programlayabiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıda açıkladığımız dört gerekçenin hiçbiri bizim geçerli olmayabilir. Yani biz sınıfın veri elemanlarını değiştirmeyeceğmizden eminsek, o veri elemanları 
	üzerinde sınır kontrolü gerekmiyorsa ya da bunun programcı tarafından yapılmasını istiyorsak, o veri elemanı başka bir veri elemanı ile ilişkili değilse, 
	o veri elemanını kullanırken başka işlemler yapmamız gerekmiyorsa o zaman pekala biz veri elemanlarımızı public bölüme yerleştirebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf tipik olarak iki kaynak dosya biçiminde yazılmaktadır. Sınıfın ismi X olmak üzere "x.hpp" ve "x.cpp". Sınıfın bildirimleri "x.hpp" dosyası içerisine yerleştirilir. 
	Sınıfın üye fonksiyonları ise "x.cpp" dosyasına yerleştirilir. Böylece sınıfın kullanılacağı her yerde "x.hpp" dosyası include edilir. "x.cpp" dosyası derlenerek 
	kütüphanelere yerleştirilebilir. Ya da object modül biçiminde link aşamasında yeniden derlenmeden kullanılabilir. X sınıfı Y sınıfını kullanıyorsa bu durumda
	"y.hpp" dosyası tipik olarak "x.hpp" dosyası içerisinde include edilir. 

	Ancak programcılar birkaç sınıf için ortak bir başlık dosyası ve cpp dosyası da oluşturabilmektedir. Örneğin X, Y, Z sınıflarınının bildirimleri "xyz.hpp"
	dosyası içerisine, bunların üye fonksiyon tanımlamaları da "xyz.cpp" içerisine yerleştirilebilmektedir.

	using nanespace direktiflerinin başlık dosyalarının içerisine yerleştirilmesi kötü bir tekniktir. 

	Örneğin Dare sınıfını aşağıdaki gibi iki dosya olarak organize edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() { return m_month; }
	void set_month(int month) {	m_month = month; }
	int year() { return m_year;	}
	void set_year(int year)	{ m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main(void)
{
	Date d;

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Basit bir String sınıfını iki dosya biçiminde aşağıdaki gibi organize edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main(void)
{
	String s("ankara");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesinde zaten hazır bir biçimde bulunan yazısal işlemleri yapmak için yazılmış olan bir string sınıfı vardır. Standart string sınıfı
	aslında basic_string isimli bir şablon sınıfın char türünden açılımı biçiminde typedef edilmiştir. string sınıfı <string> başlık dosyası içerisinde bildirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının const char * parametreli yapıcı fonksiyonu bizden bir yazı alıp onu dinamik bir biçimde tahsis etmiş olduğu char türden dizi içerisinde tutar. 
	cout nesnesi zaten standart string nesnelerini de yazdırabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	cout << s << endl;		// ankara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının diğer çok kullanılan yapıcı fonksiyonu bizden bir sayı ve bir karakter alır. Nesneyi o karakterden o sayıda lacak biçimde oluşturur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s(10, 'a');		// aaaaaaaaaa

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının + operatör fonksiyonu iki yazıyı birleştirip yeni bir string nesnesi vermektedir. Operatör fonksiyonları ileride ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), k("izmir"), result;

	result = s + k;
	
	cout << result << endl;			// ankaraizmir

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının + operatör fonksiyonu char türden bir gösterici ile toplama işlemi de yapabilmektedir. Bu durumda operatör fonksiyonu C tarzı ile bir yazı ile
	string nesnesinin toplanmasına olanak sağlar. u da yine yazıların birleştirilmesi anlamına gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), result;

	result = s + "izmir";
	
	cout << result << endl;			// ankaraizmir

	result = "izmir" + s;

	cout << result << endl;			// izmirankara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının karşılaştırma operatör fonksiyonları da bulunmaktadır. (Ancak C++20 ile birlikte == operatör fonksiyonu dışındakiler kaldırılmış, yer,ine <=> 
	operatör fonksiyonu eklenmiştir.) Bu operatör fonksiyonları hem iki string nesnesi üzerinde işlem yapabilmekte hem de bir string nesnesi ile C tarxı bir string üzerinde de
	işlem yapabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s;

	cout << "Enter password:";

	cin >> s;

	if (s == "maviay")
		cout << "ok" << endl;
	else
		cout << "incorrect password!" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'taki string sınıfı Java, C#, Python gibi dillerdeki string sınıfları gibi "değiştirilemez (immutable)" değildir. Biz C++'ta bir string nesnesiin karakterlerini
	değiştirebiliriz. Ona yeni karakterler ekleyebiliriz. Onun bazı karakterlerini silebiliriz. Örneğin append isimli overload edilmiş metotlar string'in sonuna yazı ve karakter
	eklemek için kullanılabilmektedir. Yani append metotları ile şu eklemeleri yapabiliriz:

	1) string'e C tarzı string ekleyebiliriz. Bunun için sınıfın cons har * parametreli append fonksiyonu vardır. 
	2) string'e başka bir string nesnesini ekleyebiliriz. 
	3) string'e belli bir sayıda bir karakterden ekleyebiliriz. 
	4) string'e C tarzı C string'in ilk n karakterini ekleyebiliriz. 
	5) string'e başka bir string'in belli bir indeksinden itibaren n tane karakterini ekleyebiliriz. 

	Ayrıca iteratör yoluyla ekleme yapan append üye fonksiyonları da vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), k("eskisehir");

	s.append("izmir");			// 1
	s.append(k);				// 2
	s.append("erzurum", 3);		// 3
	s.append(10, 'x');			// 4
	s.append(k, 3, 2);			// 5

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının erase isimli üye fonksiyonları string'ten karakter silmek için kullanılarlar. iki parametreli erase fonksiyonu belli bir indeksten itibaren 
	n tane karakteri silmektedir. Bu iki parametre de girilmezse yazının tamam silinmektedir. Birinci parametre girilip ikinci parametre girilmezse o indeksten itibaren 
	yazının geri kalanı silinmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	s.erase(2, 3);

	cout << s << endl;			// ana

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    [] operatörü ile string nesnesinin belli bir karakterine erişilebilir. O karakter değiştirilebilir. Bu işlem sınıfın [] operatör fonksiyonu ile yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	cout << s[2] << endl;
	s[2] = 'x';

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aralık tabanlı for döngüleri ile string'i dolaşabiliriz. Bu durumda string'in karakterlerini elde ederiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	for (char ch : s)
		cout << ch;
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii aralık tabanlı for döngüsünde referans da kullanabiliriz. Bu durumda bu referans string içerisindeki karakterleri gösterir. Yani onun güncellenmesi 
	string'in karakterlerinin güncellenmesi anlamına gelecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cctype>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	for (auto &ch : s)
		ch = toupper(ch);

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın += operatör fonksiyonları bir string'e başka bir string'i ya da yazıyı eklemek için kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	s += "izmir";		// s = s + "izmir;
	s += "bursa";		// s = s + "izmir;

	cout << s << endl;

	string k("van");

	s += k;

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının substr üye fonksiyonu belli bir indeksten itibaren string'in n tane karakterini bir string olarak elde etmek için kullanılmaktadır. İkinci parametre girilmezse
	string'in sonuna kadarki tüm karakterler elde edilir. İki parametre de girilmezse yazının aynısı elde edilmektedir. Bu da kopyalama anlamına gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string result;

	result = s.substr(2, 2);
	cout << result << endl;			// ka
	
	result = s.substr(2);			
	cout << result << endl;			// kara
	
	result = s.substr();			
	cout << result << endl;			// ankara
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınfın replace isimli üye fonksiyonları string içeriisndeki yazının belli bir kısmını başka bir yazıyla yer değiştirmektedir. Yani bu belli kısım önce silinip
	sonra o yere insert işlemi yapılıyor gibi bir etki oluşturmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string k("izmir");

	s.replace(2, 2, k);	

	cout << s << endl;	// anizmirra
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu işlemi C tarzı string'lerle de yapabiliriz.  Overload edilmiş olan diğer replace üye fonksiyonları için dokümantasyona başvurabilirisiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	char k[] = "izmir";

	s.replace(2, 2, k);

	cout << s << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının pek çpk overload edilmiş insert fonksiyonları vardır. Bu insert fonksiyonlarının bazıları şunlardır:

	1) string'in belli bir indeksine belli bir karakterden n tane insert eden fonksiyon
	2) string'in belli bir indeksine C tarzı bir string'i insert eden fonksiyon
	3) string'in belli bir indeksine başka bir string'i insert eden fonksiyon.

	Diğer overload edilmiş string fonksiyonları için dokümantasyonlara başvurunuz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	s.insert(3, 2, 'x');			// 1
	cout << s << endl;				// ankxxara

	s = "ankara";

	s.insert(2, "izmir");			// 2
	cout << s << endl;				// anizmirkara

	s = "ankara";
	string k("izmir");

	s.insert(2, k);					// 3
	cout << s << endl;				// anizmirkara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının find isimli üye fonksiyonları yazı içerisinde bir karakteri ya da başka bir yazıyı bulmak iin kullanılmaktadır. Eğer söz konusu karakter ya da yazı
	yazı içerisinde bulunursa bulunduğu yerin indeks numarasıyla geri döner bulunamazsa string::npos değeriyle geri döner. find fonksiyonlarının geri dönüş değerleri 
	string sınıfı içerisinde typedef edilmiş olan size_type türündendir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type pos;

	pos = s.find('k');
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	find işleminde arama belli bir indeksten itibaren de başlatılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type pos;

	pos = s.find('a', 2);
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yazının belli bir indeksinden başlanarak belli bir yazı da aranabilir. Bu yazı C tarzı bir string olabileceği gibi başka bir string nesnesi de olabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("bugun hava cok guzel");
	string::size_type pos;

	pos = s.find("hava");
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ ile birlikte string kütüphanesine stoxxx biçiminde global fonksiyonlar da eklenmiştir. Bu fonksiyonların listesi şöyledir:
	
	stoi
	stol
	stoll
	stoul
	stoull
	stof
	stod
	stold

	Bu fonksiyonlar string nesnesi içeisindeki sayısal yazıyı ilgili C türünde dönüştürürler. (Yani bunlar atoi, atol, atof gibi standart C fonksiyonlarının yaptığı 
	işleri yapmaktadır.)

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("1234");
	string k("123.45");

	auto result = stoi(s);

	cout << result << endl;

	auto result2 = stod(k);
	cout << result2 << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yine C++11 ile birlikte string kütüphanesine dile bir grup overload edilmiş global to_string fonksiyonları eklenmiştir. Bu fonksiyonlar stoxxx fonksiyonlarının tersini yapmaktadır. 
	Yani parametreleriyle int, lng, double gibi değerleri alıp o sayıları string nesnesi biçiminde bize verirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	int val = 1234;
	string s;

	s = to_string(val);
	cout << s << endl;

	s = to_string(12.34);
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının atama operatör fonksiyonları da vardır. Böylece biz bir string nesnesine "=" operatörü ile C tarzı bir string'i ya da başka bir string nesnesini atayabiliriz. 
	Bu durumda o string nesnesi artık atadığımız yazıyı tutuyor hale gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	cout << s << endl;		// ankara

	s = "izmir";

	cout << s << endl;		// izmir

	string k("hatay");

	s = k;

	cout << s << endl;		// hatay

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string nesnesi içerisindeki yazının karakter uzunluğunu size ya da length üye fonksiyonu ile elde edebiliriz. Bu üye fonksiyonlar bize yazının uzunluğunu string::size_type
	türünden vermektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type n;

	n = s.size();
	cout << n << endl;

	n = s.length();
	cout << n << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin adresi alınabilir. Bu adres aynı türden bir sınıf göstericisine atanabilir. Biz de bir sınıf göstericisi yoluyla sınıfın elemanlarına 
	gösterici ps olmak üzere (*ps).a gibi bir ifadeyle ya da ps->a ifadesiyle erişebiliriz. ps bir sınıf türündne gösterici foo da bu sınıfın bir üye fonksiyonu olsun. 
	Bu gösterici yoluyla foo fonksiyonu (*ps).foo() biçiminde ya da ps->foo() biçiminde çağrılabilir. Burada foo fonksiyonu ps göstericisinin gösterdiği yerdeki nesnenin 
	veri elemanlarını kullanıyor durumda olacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
private:
	int m_a;
};

int main(void)
{
	Sample s(10);
	Sample *ps;

	ps = &s;

	(*ps).disp();		
	ps->disp();

	ps->set_a(20);
	cout << ps->a() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new operatör ile sınıflar türünden heap'te dinamik tahsisatlar yapılabilir. Bu durumda new operatörü önce o sınıfın elemanlarını içerecek uzunlukta dinamik 
	tahsisatı yapar. Sonra sınıfın uygun yapıcı fonksiyonunu çağırır. Dinamik tahsis edilmiş sınıf nesneleri delete operatöryle serbest bırakılmalıdır. delete operatörü de
	nesneyi heap'ten boşaltmadan önce sınıfın yıkıcı fonksiyonunu çağırır. new ile tahsisat aşağıdaki sentaktik biçimlerle yapılmaktadır:

	new Sample			// default yapıcı fonksiyon çağrılır
	new Sample()		// default yapıcı fonksiyon çağrılır
	new Sample(...)		// overload resolution işlemiyle seçilen fonksiyon çağrılır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
private:
	int m_a;
};

int main(void)
{
	Sample *ps;

	ps = new Sample(10);
	ps->disp();

	delete ps;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bir sınıf nesnesinin dinamik bir biçimde tahsis edilmesine neden gereksinim duyulmaktadır? İşte biz bir sınıf nesnesini programın belli bir notasında yaratıp
	belli bir noktasında yok etmek isteyebiliriz. Yerel sınıf nesneleriyle ve global sınıf nesneleriyle bunun yapılması mümkün değildir. 

	Aşağıdaki örnekte bu tema gösterilmiştir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
private:
	int m_a;
};

Sample *foo()
{
	cout << "foo" << endl;

	auto ps = new Sample(10);

	return ps;
}

int main(void)
{
	Sample *ps;

	ps = foo();
	ps->disp();

	delete ps;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıflar türünden referanslar oluşturulabilir. Bir sınıf türünden bir sol taraf değeri referansı aynı sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanmalıdır. 
	Sınıf referanslarıyla sınıfın üye fonksiyonları "." operatörüyle çağrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}

private:
	int m_a;
};

int main(void)
{
	Sample s(10);
	Sample &r = s;

	r.disp();			// 10
	r.set_a(20);
	s.disp();			// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları "const üye fonksiyonlar" yapılabilir. Bunun için fonksiyonun parametre parantezinden sonra "const" anahtar sözcüğü kullanılmaktadır. 
	Buradaki const anahtar sözcüğü hem prototipte hem de tanımlama sırasında bulundurulmak zorundadır. 

	Sınıfın const ye fonksiyonları sınıfın veri elemanlarını  kullanabilirler ancak değiştiremezler. Yani bir üye fonksiyonu const yapan programcı derleyiciye
	"o üye fonksiyon içerisinde sınıfın (static olmayan) bir veri elemanını değiştirmeyeceği sözünü"" vermektedir. 

	const bir üye fonksiyon içerisinde biz sınıfın yalnızca const üye fonksiyonlarını çağırabiliriz. Sınfın yapıcı ve yıkıcı fonksiyonları const yapılamazlar.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Number {
public:
	Number(int val = 0);
	void disp() const;
private:
	int m_val;
};

Number::Number(int val)
{
	m_val = val;
}

void Number::disp() const
{
	cout << m_val << endl;
}

int main(void)
{
	Number n;

	n.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi const yapılabilir. const sınıf nesneleri için çağrılan yapıcı ve yıkıcı fonksiyonlar o nesnenin veri elemanlarında değişiklik yapabilirler. 
	Ancak bu istisna durum dışında const nesnenin veri elemanları herhangi bir biçimde değiştirilemezler. 

	cont bir sınıf nesnesi ile sınıfın yalnızca const üye fonksiyonları çağrılabilir. Çünkü const üye fonksiyonların sınıfın veri elemanlarını 
	değiştirmeyeceği derleyici tarafından zaten denetlenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// number.hpp

#ifndef NUMBER_HPP_
#define NUMBER_HPP_

class Number {
public:
	Number(int val = 0);
	void disp() const;
	void set_val(int val);
private:
	int m_val;
};

#endif

// number.cpp

#include <iostream>
#include "number.hpp"

using namespace std;

Number::Number(int val)
{
	m_val = val;
}

void Number::disp() const
{
	cout << m_val << endl;
}

void Number::set_val(int val)
{
	m_val = val;
}

// app.cpp

#include <iostream>
#include "number.hpp"

using namespace std;

int main(void)
{
	const Number n(10);

	n.disp();			// geçerli
	n.set_val(20);		// error! const bir sınıf nesnesi ile sınıfın const olmayan üye fonksiyonları çağrılamaz.
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı bir sınıf için üye fonksiyon yazarken üye fonksiyon eğer sınıfın veri elemanlarını değiştirmiyorsa onu const yapmalıdır. Aksi takdirde üye fonksiyon
	aslında const nesnelere çağrılabileceği halde çağrılamaz duruma gelir. Aynı durum const referanslar için, const göstericiler için de geçerlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void foo(const Number *pn)
{
	pn->disp();		// geçerli disp const
}

int main(void)
{
	Number  s(10);
	const Number &r = s;

	r.disp();		// geçerli, disp const

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	 Biz bir sınıf türünden nesneyi kendi sınıfı türünden bir nesneyle ilkdeğer vererek tanımlayabiliriz. Bu durumda yeni yarattığımız nesnenin veri elemanlarının 
	 ona ilkdeğer olarak verdiğimiz nesnenin veri elemanlarıyla aynı olmasını bekleriz. Örneğin:

	 Sample s;
	 Sample k = s;		

	 Burada k nesnesinin içeriğinin s nesnesinin içeriği ile aynı olmasını istiyoruz. Bu ilkdeğer verme işlemi şöyle de yapılabilirdi:

	 Sample s;
	 Sample k(s);

	 C++11'den sonra aşağıdaki gibi de yapılabilmektedir:

	 Sample s;
	 Sample k{s};

	 İşte bir sınıf nesnesinin kendisi ile aynı türden bir sınıf nesnesi ile ilkdeğer verilerek yaratıldığı durumlarda yaratılacak nesne için çağrılan sınıfların yapıcı 
	 fonksiyonlarına "kopya yapıcı fonksiyonları (copy constructors)" denilmektedir. 

	 Fonksiyon çağrılırken argümanlardan parametre değişkenlerine yapılan aktarımın parametre değişkenine ilkdeğer verme anlamına geldiğini anımsayınız. Benzer biçimde
	 fonksiyonların geri dönüş değerleri oluşturulurken return işleminin geri dönüş değeri için yaratılacak geçici nesneye ilkdeğer verme anlamına geldiğini de anımsayınız. 

	 C++'ta kopya yapıcı fonksiyonları şu durumlarda çağrılmaktadır:

	 1) Bir sınıf nesnesinin aynı sınıf türünden bir nesneyle ilkdeğer verilerek tanımlandığı durumlarda yeni tanımlanan nesne için kopya yapıcı fonksiyonu çağrılır.
	 2) Fonksiyonun parametre değişkeni bir sınıf türünden ise bu fonksiyon aynı sınıf türünden bir sınıf nesnesiyle çağrıldığında parametre değişkeni için de 
	 kopya yapıcı fonksiyonu çağrılır.
	 3) Fonksiyonun geri dönüş değeri bir sınıf türünden olabilir. Bu durumda return işleminde return anahtar sözcüğünün yanında aynı sınıf türünden bir nesne olmalıdır. 
	 İşte geri dönüş değeri için yaratılacak olan geçici nesne için sınıfın kopya yapıcı fonksiyonu çağrılır.

	 Sınıfın kopya yapıcı fonksiyonu sınıfın kendi türünden referans parametreli yapıcı fonksiyonudur. Sınıfın ismi T olmak üzere aşağıdaki parametrelere sahip yapıcı foksiyonların 
	 hepsi kopya yapıcı fonksiyon (copy contructor) olarak kullanılabilir:

	 - const T &
	 - T &
	 - volatile T &
	 - const volatile T &

	 Sınıfın en çok kullanılan kopya yapıcı fonksiyonu "const T &" parametreli yapıcı fonksiyonudur. 

	 Sınıfın kopya yapıcı fonksiyonu ne yapmalıdır? Madem ki kopya yapıcı fonksiyonu bir sınıf nesnesi aynı türden bir sınıf nesnesi ile ilkdeğer verilerek tanımlanırken
	 çağrılıyor o zaman kopya yapıcı fonksiyonunun ilkdeğer olarak verilen nesnenin içeisindeki değerlerin aynısını yaratılmakta olan nesnede oluşturması beklenir. 
	 
	 Kopya yapıcı fonksiyonu derleyici tarafından çağrıldığında ilkdeğer olarak verilen nesnenin adresi kopya yapıcı fonksiyonunun referans parametresine aktarılır. 
	 Kopya yapıcı fonksiyonunu yazan programcı da o nesnenin içeriğini yeni yaratılan nesnede oluşturmaya çalışır. 

	 Sınıfın başka sınıf türünden veri elemanlarının bulunduğu durumda sınıfın kopya yapıcı fonksyonu bu veri elemanları için kendi sınıflarının kopya yapıcı fonksiyonlarının
	 çağrılmasını sağlamalıdır. Bu işlemin nasıl yapılacağı ileri MIL sentaksı açıklanırken ele alınacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(int a, int m);
	Sample(const Sample &r);

	void disp() const;
	int a() const {	return m_a;}
	int b() const { return m_b; }
private:
	int m_a;
	int m_b;
	string m_s;
};

Sample::Sample(int a, int b)
{
	m_a = a;
	m_b = b;
}

Sample::Sample(const Sample &r) 
{
	m_a = r.m_a;
	m_b = r.m_b;
}

void Sample::disp() const
{
	cout << "m_a = " << m_a << ", m_b = " << m_b << endl;
}

void foo(Sample k)		// k için kopya yapıcı fonksiyon çağrılır
{
	k.disp();
}

Sample bar()
{
	Sample s(30, 40);			


	return s;			// copy constructor çağrılır
}

int main(void)
{
	Sample s(10, 20);

	Sample k = s;		// copy constructor çağrılır

	s.disp();
	k.disp();

	foo(s);			// copy constructor çağrılır

	bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı sınıfı için kopya yapıcı fonksiyonunu hiç yazmayabilir. Bu durumda derleyici sınıf için kopya yapıcı fonksiyonunu kendisi yazar. Derleyicinin
	kendisinin yazdığı kopya yapıcı fonksiyonu kaynak nesnenin veri elemanlarını hedef nesneye bire bir kopyalamaktadır. Bu işleme "memberwise copy" denilmektedir. 
	Yani yukarıdaki örnekte biz sınıf için kopya yapıcı fonksiyonunu hiç yazmasaydık da zaten derleyici bunu bizim yazdığımız gibi karşılıklı elemanları kopyalayacak
	biçimde yazacaktı. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int m);

	void disp() const;
	int a() const {	return m_a;}
	int b() const { return m_b; }
private:
	int m_a;
	int m_b;
	string m_s;
};

Sample::Sample(int a, int b)
{
	m_a = a;
	m_b = b;
}

void Sample::disp() const
{
	cout << "m_a = " << m_a << ", m_b = " << m_b << endl;
}

void foo(Sample k)		// k için kopya yapıcı fonksiyon çağrılır
{
	k.disp();
}

Sample bar()
{
	Sample s(30, 40);			


	return s;			// copy constructor çağrılır
}

int main(void)
{
	Sample s(10, 20);

	Sample k = s;		// copy constructor çağrılır

	s.disp();
	k.disp();

	foo(s);			// copy constructor çağrılır

	bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi madem derleyici biz yazmazsak da bizim için kopya yapıcı fonksiyonunu kendisi yazmaktadır. O halde bunu bizim yazmamızı gerektirecek bir durum var mıdır?
	İşte bazen derleyicinin kendisinin yazdığı kopya yapıcı fonksiyonu sınıfın karşıklı veri elemanlarını kopyaladığı için sorunlara yol açabilir. Örneğin sınıfın 
	bir gösterici veri elemanı varsa "memberwise copy" işlemi sırasında bu göstericinin içerisindeki adres hedefe kopyalanır. Böylece iki sınıf nesnesinin gösterici veri 
	elemanları aynı yeri gösterir durumda olurlar. Sonra bu nesneler için yıkıcı fonksiyonlar çağrıldığında bu yıkıcı fonksiyonlar aslında iki nesnenin ortak kullandığı alanı
	serbest bırakabilir. Bu da sorunlara yol açar. İşte bu tür durumlarda programcının sınıf için kopya yapıcı fonksiyonunu kendisinin "içerik kopyalaması" yapacak 
	biçimde yazması gerekir. İçerik kopyalaması göstericilerin içerisindeki adreslerin değil onların gösterdikleri yerdeki bilgilerin kopayalnmasıdır. 
	İçerik kopyalamasına Java ve C# gibi dillerde "derin kopyalama (deep copy)" da denilmektedir. 

	Örneğin biz daha önce basit bir String sınıfını aşağıdaki gibi oluşturmuştuk:


	class String {
	public:
		String();
		String(const char *str);
		void disp();

		~String();

	private:
		char *m_str;
		std::size_t m_len;
	};

	Burada m_str veri elemanı dinamik tahsis edilen alandaki yazıyı göstermektedir. İşte eğer biz bu sınıf için içerik kopyalaması yapmazsak derleyicinin yazdığı 
	kopya yapıcı fonksiyon "memberwise copy" yapacak ve bu da aşağıdaki gibi kodlarda hemen soruna yol açacaktır:

	void foo(String k)
	{
		//...
	}
	//...
	String s("ankara");

	foo(s);


	Aşağıdaki örnekte böyle bir String sınıfı için kopya yapıcı fonksiyonun nasıl yazılması gerektiği gösterilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)			// copy constructor içerikl kopyalaması yapıyor
{
	m_str = new char[r.m_len + 1];
	strcpy(m_str, r.m_str);
	m_len = r.m_len;
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "String.hpp"

using namespace std;

void foo(String k)
{
	k.disp();
}

int main(void)
{
	String s("ankara");

	foo(s);

	s.disp();			// undefined behavior!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi hangi durumlarda derleyicinin yazdığı kopya yapıcı fonksiyonu bir soruna yol açmaz? Eğer sınıfın bir gösterici veri elemanı yoksa muhtemelen derleyicinin 
	yazmış olduğu "memberwise copy" yapan kopya yapıcı fonksiyon bizim işimizi görecektir. Ancak yine de bazen gösterici olmayan veri elemanları da ortak alanları temsil 
	ediyor olabilir. Bu özel durumlara da dikkat etmek gerekir. 

	Örneğin aşağıdaki gibi bir Complex sayı sınıfı için programcının kopya yapıcı fonksiyonnuu kendisinin yazmasına hiç gerek yoktur. Zaten derleyicinin "memberwise copy"
	yapan kopya yapıcı fonksiyonu istenileni yapacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	void disp() const;
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

void Complex::disp() const
{
	cout << m_real;

	if (m_imag)
		cout << '+' << m_imag << 'i';

	cout << endl;
}

// app.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

int main(void)
{
	Complex z(3, 2);
	Complex k = z;

	z.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta T bir tür ismi (genellikle sınıf) olmak üzere T([argüman listesi]) biçminde bir ifade ""T türünden geçici nesne yarat" anlamına gelmektedir. Bu biçimde geçici nesne 
	yaratıldığında derleyici eğer yaratılan bir sınıf nesnesi ise bu nesne için uygun yapıcı fonksiyonunu çağırır. Sonra bu geçici nesne bu geçici nesnenin yaratıldığı ifade 
	bittiğinde yıkıcı fonksiyon çağrılarak yok edilir. Eğer bir ifadede birden fazla geçici sınıf nesnesi yaratılmışsa onların yıkıcı fonksiyonları yapıcı fonksiyonlarına göre ters
	sırada çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int val)
	{
		cout << "constructor: " << val << endl;
		m_val = val;
	}

	void disp() const
	{
		cout << m_val << endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}

private:
	int m_val;
};

void foo(Sample s)
{
	s.disp();
}

int main(void)
{
	foo(Sample(10));		// Burada geçici nene yaratılır, bu geçici nesne fonksiyona aktarılır.

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir sınıf belirtmek üzere T(...) biçiminde yaratılan geçici nesneler sağ taraf değeri (prvalue) belirtir. Dolayısıyla biz onu ancak const bir sol taraf değeri referansına 
	bind edebiliriz. Ya da bir sağ taraf değeri referansına bind edebiliriz. Örneğin:
		
	Sample &r = Sample(10);				// error! geçici nesne prvalue fakat referans const değil!
	const Sample &k = Sample(10);		// geçerli, geçici nesne prvalue ve referans const
	Sample &&m = Sample(10);			// geçerli, geçici nesne prvalue ancak referns rvalue referans

	BU tür durumlarda geçici nesne referansın ömrü kadar yaşamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int val)
	{
		cout << "constructor: " << val << endl;
		m_val = val;
	}

	void disp() const
	{
		cout << m_val << endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}

private:
	int m_val;
};

int main(void)
{
	const Sample &r = Sample(10);				
	
	cout << "continues..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta C++17'ye kadar bazı durumlarda derleyicinin kopya yapıcı fonksiyonunu çağırmayabileceği, nesneyi doğrudan hedefte yaratabileceği belirtilmiştir. Ancak 
	bu durum derleyicileri yazanların isteğine bırakılmıştır. Buna "kopya yapıcı fonksiyonun elimine edilmesi (copy elision)" denilmektedir. Ancak C++17 ile birlikte 
	bazı durumlarda artık "copy elision"steğe bağlı olmaktan çıkartılıp zorunlu hale getirilmiştir. (Yani derleyici bu özel durumlarda artık kopya yapıcı 
	fonksiyonunu elimine etmek zorundadır.)

	C++17 ile birlikte bir nesne sağ taraf değerine (prvalue) ilişkin bir nesne ile ilkdeğer verilerek yaratıldığında (yani tipik olarak bir geçici nesne ile ilkdeğer verilerek yaratıldığında) 
	yeni yaratılan nesne için kopya yapıcı fonksiyonu çalıştırılmaz. Doğrudan yeni nesne geçici nesne için çağrılacak yapıcı fonksiyonla ilkdeğer alır. Örneğin:

	Sample s = Sample(a, b, c);

	Burada normalde geçici nesne için yapıcı fonksiyon çağrılır, sonra s için kopya yapıcı fonksiyonu çağrılır. Ancak "copy elision" kuralı gereği bu işlem tamamen
aşağıdakine eşdeğer hale gelmektedir:

	Sample s(a, b, c);

	Örneğin:
	
	Sample s(Sample(Sample(Sample(a, b, c))));

	Bu işlem yine aşağıdakine eşdeğerdir:

	Sample s(a, b, c);

	Örneğin:

	Sample foo()
	{
		//...

		return Sample(a, b, c);
	}

	Sample s(foo());

	Burada return işleminde yaratılacak geçici nesne için kopya yapıcı fonksiyonu çalıştırılmaz. Doğrudan bu nesne a, b, c parametreli yapıcı fonksiyonla 
	yaratlır. Benzer biçimde aslında buradaki kodda yalnızca s için default yapıcı fonksiyon çağrılacaktır. 

	Bu biçimdeki "copy elision" C++17 öncesinde zorunlu değildi. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "default constructor" << endl;
	}
	Sample(const Sample &r)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
};

Sample foo()
{
	return Sample()
}

int main(void)
{
	Sample s = Sample();		// Yalnızca s için default yapıcı fonksiyon çalışıtırılır
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca tüm C++ verisyonları dahil olmak üzere birkaç durumda da "isteğe bağlı (optional)" biçimde bir "copy elision" yapılabilmektedir. Bunlardan en önemli olanı 
	NRVO (Named Return Value Optimization) denilen durumdur. Bir fonksiyonun geri dönüş değeri bir sınıf türündense ve fonksiyonun return ifadesi o sınıf türünden 
	bir sınıf nesnesinin isminden oluşuyorsa bu durumda derleyici bu yerel sınıf nesnesi için yapıcı fonksiyonu çağırıp, geri dönüş değeri için kopya yapıcı fonksiyonu çağırmak yerine
	doğrudan bu yerel nesneyi zaten geri dönüş değeri ile aktarılacak geçici nesne biçiminde oluşturabilir. Dolayısıyla return işlemi sırasında kopya yapıcı fonksiyonu 
	çalıştırılmaz. Örneğin:

	Sample foo()
	{
		Sample s;

		//...

		return s;
	}

	Burada aslında s nesnesi zaten geri dönüş değeri için yaratılacak nesne biçiminde oluşturulabilir. Yani burada derleyici isterse geri dönüş değerine ilişkin nesneyi
	s gibi yaratabilir. Böylece kopya yapıcı fonksiyonu hiç çağrılmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "default constructor" << endl;
	}
	Sample(const Sample &r)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
};

Sample foo()
{
	Sample s;

	//...

	return s;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf başka bir sınıf türünden veri elemanlarına sahip olabilir. Örneğin Student öğrencilerin bilgilerini tutup onlar üzerinde işlem yapan bir sınıf olsun. 
	Öğrencinin ismi std::string sınıfı türünden bir nesne ile tutulabilir. Öğrencinin doğum tarihi Date isimli bir sınıf nenesi yoluyla tutulabilir:

	// student.hpp

	#ifndef PERSON_HPP_
	#define PERSON_HPP

	#include <string>
	#include "Date.hpp"

	class Student {
	public:
		//...
	private:
		int m_no;
		std::string m_name;
		Date m_bdate;
	};

	#endif

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Elemana sahip sınıf türünden bir nesne yaratıldığında eleman olan sınıf nesneleri o sınıfların kendi yapıcı fonksiyonları ile ilkdeğerlerini alır. Yani C++'ta
	elemana sahip sınıfın yapıcı fonksiyonları elemana ilişkin sınıfların yapıcı fonksiyonlarını çağırarak elemanlara ilkdeğerlerini vermektedir. Pekiyi elemana sahip sınıfın 
	yapıcı fonksiyonları elemana ilişkin sınıfın hangi yapıcı fonksiyonlarını ne zaman çağırmaktadır. İşte elemana sahip sınıfın yapıcı fonksiyonun elemana ilişkin sınıfın 
	hangi yapıcı fonksiyonunu çağıracağı MIL sentaksı denilen bir sentaks ile belirlenmektedir. MIL sentaksı yalnızca yapıcı fonksiyonlarda kullanıan bir sentakstır. 
	Elemana sahip sınıfın ismi T olmak üzere MIL sentaksının genel biçimi şöyledir:

	T::T(...) : eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), ...
	{
		//...
	}

	Burada elemanlar için argüman listesine uygun yapıcı fonksiyonlar çağrılmaktadır. Buradaki argüman listesinde global değişkenler kullanılabilir, 
	elemana sahip sınıfın yapıcı fonksiyonlarının parametreleri kullanılabilir, sınıfın veri elemanları kullanılabilir.

	C++'ta her zaman elemana ilişkin sınıfların yapıcı fonksiyonları elemana sahip sınıfların yapıcı fonksiyonlarından daha önce çalıştırılır.
	Yani önce elemanlar için yapıcı fonksiyonlar çağrılır, sonra programın akışı elemana sahip sınıfın ana bloğundan içeri girer. Derleyiciler genellikle elemana ilişkin
	sınıf nesneleri için onların yapıcı fonksiyonlarını elemana sahip sınıfın yapıcı fonksiyonlarının başına yerleştirdikleri gizli bir çağırma kodu yoluyla çağırmaktadır.

	Elemanlar için yapıcı fonksiyonlar sınıf bildirimindeki sıraya göre çağrılmaktadır. MIL sentaksındaki sıranın hiçbir önemi yoktur. Örneğin:

	Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year)
	{
		m_no = no;
	}

	Burada m_name elemanı std::string türünden, m_bdate elemanı Date sınıfı türündendir. m_no ise int türdendir. Burada bildiriminde ilk belirtilen veri elemanı
	hangisiyse onun için yapıcı fonksiyon önce çağrılacaktır. MIL sentaksındaki sıranın bir önemi yoktur. 

	Sınıfın başka sınıf türünden bir veri elemanı MIL sentaksında belirtilmemişse o veri elemanı için o sınıfın default yapıcı fonksiyonu yine bildirimde belirtilen sırada
	çalıştırılmaktadır. Bu nedenle aşağıdaki gibi ilkdeğerleme işlemleri kötü bir tekniktir:

	Student::Student(const char *name, int day, int month, int year, int no) : m_bdate(day, month, year)
	{
		m_name = name;			// kötü teknik!
		m_no = no;
	}

	Burada m_name elemanı MIL sentaksında belirtilmemiştir. Bu durumda derleyici bu eleman için sınıfın default yapıcı fonksiyonunu çağırır. Elemanlar için yapıcı 
	fonksiyonlar çağrıldıktan sonra programın akışı ana bloğa girecek bu kez gereksiz bir biçimde m_name elemanı için std::string sınıfının atama operatör fonksiyonu çalıştırılacak 
	ve nihai değerler bu biçimde nesneye yerlştirilmiş olacaktır. Burada adeta nesneye iki kez değer yerleştirme durumu söz konusu olmaktadır. 
	
	Sınıfın temel türlere ilişkin (int, long double gibi) veri elemanları da MIL sentaksında belirtilebilir.

	Elemanlar için yapıcı fonksiyonlar sınıf bildirimindeki sıraya göre çağrılmaktadır. MIL sentaksındaki sıranın hiçbir önemi yoktur. Örneğin:

	Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year), m_no(no)
	{}

	Ancak temel türlere ilişkin veri elemanlarına MIL sentaksında değer atamak ile ana blok içerisinde değer atamak arasında bir etkinlik farkı yoktur. Yani derleyici 
	sınıfın temel türlere ilişkin veri elemanları için MIL sentaksında ilkdeğerleme yapılmadıysa zaten onlara herhangi bir değer yerleştirmez. Tabii işlemlerin yapılma sırası
	bakımından farklılık söz konusu olabilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp() const;

	int day() { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }
	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

// student.hpp

#ifndef PERSON_HPP_
#define PERSON_HPP

#include <string>
#include "Date.hpp"

class Student {
public:
	Student() = default;
	Student(const char *name, int day, int month, int year, int no);
	void disp() const;
private:
	int m_no;
	std::string m_name;
	Date m_bdate;
};

#endif

// student.cpp

#include <iostream>
#include "student.hpp"

using namespace std;

Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year)
{
	m_no = no;
}

void Student::disp() const
{
	cout << m_name << endl;
	m_bdate.disp();
	cout << m_no << endl;

}

// app.cpp 

#include <iostream>
#include "student.hpp"

using namespace std;

int main(void)
{
	Student student("Hasan Oz", 12, 11, 2001, 1234);

	student.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın başka sınıf türünden veri elemanlarını get etmek için kullanılan getter fonksiyonları kopya yapıcı fonksiyonun çalıştırılmasına yol açabilmektedir. Örneğin:

	class Person {
	public:
		//...
		std::string name() const { return m_name;}
	private:
		std::string m_name;
		in m_no;
	};

	Burada name isimli getter fonksiyon bize string nesnesi verdiği için kopya yapıcı fonksiyonun çalıştırılmasına yol açacaktır. Bazen programcılar bunu 
	engellemek için getter fonksiyonunun geri dönüş değerini const referans almaktadır. Örneğin:

		class Person {
	public:
		//...
		const std::string &name() const { return m_name;}
	private:
		std::string m_name;
		in m_no;
	};

	Burada aslında name isimli getter fonksiyon m_name elemanının adresiyle geri dönmektedir. Referansın const yapılması fonksiyonun adresini aldığı nesneyi değiştirememesi için 
	gerekmektedir. Tabii bu tür durumlarda sınıfın veri elemanı olan nesnenin türü değiştilemez. Çünkü bu durumda getter fonksiyonlarını kullanan kodların da değiştirilmesi 
	gerekir. Ancak genel olarak getter fonksiyonlar yazılırken bu biçimde referanslaa geri dönmemek daha iyi bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   Şimdi GUI işlemleri için kullanılabilecek bir Point sınıfı ve Rectangle sınıfı oluşturalım. Point sınıfı ekrandaki bir noktanın koordinatlarını tutup
   bazı faydalı işlemler yapmaktadır. Rectangle sınıfı ise dikdörtgenin sol-üst ve sağ-alt köşe koordinatlarını Point nesnesi olarak tutup birtakım faydalı 
   işlemler yapmaktadır. Bu tür Point ve Rectangle sınıfları GUI framework'lerinde benzer biçimlerde bulunmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// point.hpp 

#ifndef POINT_HPP_
#define POINT_HPP_

class Point {
public:
	// constructors
	Point() = default;
	Point(int x, int y) : m_x(x), m_y(y)
	{}

	//getter/settr
	int x() const { return m_x; }
	void set_x(int x) { m_x = x; }
	int y() const { return m_y; }
	void set_y(int y) { m_y = y; }
	
	// utilities
	void move(int x, int y);
	void move(const Point &pt);

	void move_delta(int dx, int dy);
	void move_delta(const Point &pt);

	void disp() const;
private:
	int m_x;
	int m_y;
};

#endif

// point.cpp

#include <iostream>
#include "point.hpp"

using namespace std;

void Point::move(int x, int y)
{
	m_x = x;
	m_y = y;
}

void Point::move(const Point &pt)
{
	m_x = pt.m_x;
	m_y = pt.m_y;
}


void Point::move_delta(int dx, int dy)
{
	m_x += dx;
	m_y += dy;
}

void Point::move_delta(const Point &pt)
{
	m_x += pt.m_x;
	m_y += pt.m_y;
}

void Point::disp() const
{
	cout << '(' << m_x << ',' << m_y << ')' << endl;
}

#ifndef RECTANGLE_HPP_
#define RECTANGLE_HPP_

#include "point.hpp"

class Rectangle {
public:
	// constructors
	Rectangle() : m_pt1(0, 0), m_pt2(0, 0)
	{}
	Rectangle(int x1, int y1, int x2, int y2) : m_pt1(x1, y1), m_pt2(x2, y2)
	{}
	Rectangle(const Point &pt1, const Point &pt2) : m_pt1(pt1), m_pt2(pt2)
	{}

	// utilities

	int width() const;
	int height() const;

	bool contains(int x, int y) const;
	bool contains(const Point &pt) const;

	void move_delta(int dx, int dy);
	void move_delta(const Point &pt);

	void disp() const;

private:
	Point m_pt1;
	Point m_pt2;
};

#endif

#include <iostream>
#include "rectangle.hpp"

using namespace std;

int Rectangle::width() const
{
	return m_pt2.x() - m_pt1.x();
}

int Rectangle::height() const
{
	return m_pt2.y() - m_pt1.y();
}

bool Rectangle::contains(int x, int y) const
{
	return x > m_pt1.x() && x < m_pt2.x() && y > m_pt1.y() && y < m_pt2.y();
}

bool Rectangle::contains(const Point &pt) const
{
	return pt.x() > m_pt1.x() && pt.x() < m_pt2.x() && pt.y() > m_pt1.y() && pt.y() < m_pt2.y();
}

void Rectangle::move_delta(int dx, int dy)
{
	m_pt1.move_delta(dx, dy);
	m_pt2.move_delta(dx, dy);
}

void Rectangle::move_delta(const Point &pt)
{
	m_pt1.move_delta(pt);
	m_pt2.move_delta(pt);
}

void Rectangle::disp() const
{
	cout << "x1 = " << m_pt1.x() << ", y1 = " << m_pt1.y() << ", x2 = " << m_pt2.x() << ", y2 = " << m_pt2.y() << endl;
}

// app.cpp 

#include <iostream>
#include "point.hpp"
#include "rectangle.hpp"

using namespace std;

int main(void)
{
	Rectangle rect(10, 10, 20, 20);

	if (rect.contains(15, 15))
		cout << "içeride" << endl;
	else
		cout << "içeride değil" << endl;
	
	cout << rect.width() << endl;
	cout << rect.height() << endl;


	Rectangle rect2(Point(12, 15), Point(20, 25));

	rect2.disp();

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	MIL sentaksı kopya yapıcı fonksiyonlarında da benzer biçimde kullanılmaktadır. Örneğin bir sınıfın başka sınıf türünden veri elemanları varsa ve biz bu 
	sınıf için kopya yapıcı fonksiyonunu yazıyorsak bu durumda bu kopya yapıcı fonksiyonu elemanların MIL sentaksıyla kopya yapıcı fonksyonlarını çalıştıracak biçimde
	yazılmalıdır. Aksi takdirde yine elemanlar için default yapıcı fonksiyon çalıştırılır. Tabii derleyicinin kendi yazdığı kopya yapıcı fonksiyonu zaten elemanlar için 
	onların kopya yapıcı fonksiyonlarını çağırmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;
	int day() const { return m_day; }
	int month() const { return m_month; }
	int year() const { return m_year; }

private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

// person.hpp

#ifndef PERSON_HPP_
#define PERSON_HPP_

#include <string>
#include "date.hpp"

class Person {
public:
	Person(const char *name, const Date &bdate, int no);
	Person(const Person &person);
	void disp() const;

private:
	std::string m_name;
	Date m_bdate;
	int m_no;
};

#endif

#include <iostream>
#include "person.hpp"

using namespace std;

Person::Person(const char *name, const Date &bdate, int no) 
	: m_name(name), m_bdate(bdate), m_no(no)
{}

Person::Person(const Person &person) : m_name(person.m_name), m_bdate(person.m_bdate), m_no(person.m_no)
{
}

void Person::disp() const
{
	cout << m_name << ", " << m_bdate.day() << '/' << m_bdate.month() << '/' << m_bdate.year() << ", " << m_no << endl;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta const bir sol taraf değeri referans parametresine sahip bir fonksiyonla aynı isimli sağ taraf referans parametreli bir fonksiyon bir arada bulunabilir. Bu durumda
	overload resolution işlemi sırasında eğer fonksiyon bir sol taraf değeri ile çağrılırsa sol taraf değeri referansına ilişkin fonksiyon, sağ taraf değeri ile çağrılırsa
	sağ taraf değeri referansına ilişkin fonksiyon seçilir. Zaten böylesi bir durumda fonksiyon bir sol taraf değeri ile çağrıldığında sağ taraf değeri referansına sahip olan fonksiyon
	"uygun (viable)" olmayacaktır. Ancak fonksiyon bir sağ taraf değeri ile çağrıldığında her iki fonksiyon da "uygun (viable)" durumda olur. İşte bu durumda sağ taraf değeri 
	referansına sahip olan fonksiyon daha iyi bir dönüştürme sunmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(const int &r)
{
	cout << "foo, const int &" << endl;
}

void foo(const int &&r)
{
	cout << "foo, const int &&" << endl;
}

int main(void)
{
	int a = 10;

	foo(a);			// const int & parametreli olan çağrılır
	foo(10);		// int && parametreli olan çağrılıe

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın sınıf ismi T olmak üzere aşağıdaki parametre yapısına sahip yapıcı fonksiyonlarına "taşıma yapıcı fonksiyonları (move constructors)" denilmektedir:
	
	- T && 
	- const T &&
	- volatile T &&
	- const volatile T &&

	Taşıma yapıcı fonksiyonlarının const parametreli olmasının anlamı yoktur. Dolayısıyla taşıma yapıcı fonksiyonları tipik olarak T && parametreli olur.

	Taşıma yapıcı fonksiyonları C++11 ile birlikte dile eklenmiştir. Zaten C++11 ile birlikte "sağ taraf değeri referanslarının" dile eklenmesinin asıl nedeni 
	"taşıma semantiği (move semantics)" denilen bu durumun sağlanması içindir. Örneğin:

	class Sample {
	public:
		Sample(const Sample &r);		// copy constructor
		Sample(Sample &&r);				// move constructor (C++11 ile birlikte)
		//...
	};

	Pekiyi taşıma yapıcı fonksiyonuna neden gereksinim duyulmaktadır? Bir sınıfın bir veri elemanı için dinamik tahsisat yaptığını düşünelim. Bu dinamik tahsisat
	yıkıcı fonksiyonda serbest bırakılacaktır. Bu tür durumda sınıfın aynı sınıf türünden hayatını kaybetmekte olan bir nesneyle ilkdeğer verilerek yaratılması işleminde kopya yapıcı fonksiyonun
	içerik kopyalaması yapacak biçimde programcı tarafından yazılması gerektiğini belirtmiştik. İşte bu kopya yapıcı fonksiyonu içerik kopyalaması için yeni bir alan tahsis etmek durumundadır. 
	Daha önce yazığımız String sınıfının kopya yapıcı fonksiyonunu yeniden gözden geçiriniz:

	String::String(const String &r)
	{
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
		m_len = r.m_len;
	}

	Ancak bazı durumlarda bir nesne zaten hayatını kaybederken onun kopya yapıcı fonksiyonu yoluyla yeni bir nesneye kopyalanması gereksiz olabilmektedir. Bu tür durumlar
	özellikle operatör fonksiyonlarında önemli bir performans kaybına yol açmaktadır. Halbuki hayatını kaybetmekte olan nesnenin kaynakları (yani onun tahsis ettiği alnlar vs.)
	o nesneden alınıp yeni nesneye taşınabilir. Böylece yeni yaratılan nesne gereksiz bir tahsisat yapmayacaktır. C++11'de hayatını kaybetmek üzere olan nesnelere xvalue
	denilmektedir. xvalue aslında rvalue gibi işlemlere sokulur. Ancak bunlar bellekte bir nesne de belirttikleri için aynı zamanda lvalue özelliğine de sahiptirler. 

	İşte C++'ta C++11 ile birlikte taşıma yapıcı fonksiyonları hayatını kaybetmekte olan nesnenin kaynaklarını alarak kullanmak için yazılmaktadır. Yaşamını kaybetmek
	üzere olan bir sınıf nesnesi yeni yaratılmakta olan bir sınıf nesnesine ilkdeğer verilmişse bu durumda yeni yaratılan sınıf nesnesi için o sınıfın varsa taşıma yapıcı fonksiyonu, 
	yoksa normal kopya yapıcı fonksiyonu çağrılmaktadır. Örneğin:

	String foo()
	{
		String s("istanbul");

		s.disp();

		return s;
	}

	Burada return s ifadesindeki s hayatını kaybetmekte olan bir sınıf nesnesidir. Bu sınıf nesnesi geri dönüş değeri için yaratılacak nesneye ilkdeğer olarak verilmiştir. 
	İşte bu durumda geri dönüş değeri için String sınıfının varsa taşıma yapıcı fonksiyonu çağrılır. Pekiyi bu String sınıfının taşıma yapıcı fonksiyonu nasıl yazılmalıdır?
	İşte taşıma yapıcı fonksiyonları kaynak taşıması yapacak biçimde yazılmalıdır. Örneğin:

	String::String(String &&r)
	{
		m_str = r.m_str;
		m_len = r.m_len;
		r.m_str = 0;
	}

	Biz bir sınıf için taşıma yapıcı fonksiyonunu yazmak zorunda değiliz. Bu durumda o sınıf için yine kopya yapıcı fonksiyonu çağrılacaktır. Ayrıca C++11'de 
	bir sınıf için programcı taşıma yapıcı fonksiyonunu yazmışsa ancak kopya yapıcı fonksiyonunu yazmamışsa artık kopya yapıcı fonksiyonu derleyici tarafından otomatik 
	yazılmamaktadır. 

	Programcı sınıfı için taşıma yapıcı fonksiyonunu yazmamışsa bazı koşullarda bu taşıma yapıcı fonksiyonu public inline olarak içerik kopyalaması yapacak biçimde yazılmaktadır.
	Ancak programcı kopya yapıcı fonksiyonunu sınıf için yazmışsa derleyici taşıma yapıcı fonksiyonu yazmamaktadır. Bu konuda bazı detaylar bulunmaktadır. 

	Aşağıdaki örnekte daha önce yazmış olduğumuz String sınıfına taşıma yapıcı fonksiyonu (move constructor) eklenmiştir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	m_str = new char[r.m_len + 1];
	strcpy(m_str, r.m_str);
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = 0;
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "String.hpp"

using namespace std;

String foo()
{
	String s("istanbul");

	s.disp();

	return s;			// move constructor çağrılır (copy elision da yapılabilir)
}

int main(void)
{
	String s = foo(); // C++17 ile birlikte copy elision zorunlu hale getirildi	

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen elimizde bir sınıf türünden sol taraf değeri belirten bir nesne bulunur. Ancak biz onu sağ taraf değeri referanslı bir fonksiyona göndermek isteyebiliriz. 
	Bu durumda bizim sol taraf değerini geçici bir nesne yaratmadan sağ taraf değeri haline getirmemiz gerekir. Bunun en temel yolu ilgili sol taraf değerini
	aynı türden bir sağ taraf değeri referansına dönüştürmektir. Örneğin:

	foo(static_cast<Sample &&>(s));

	gibi. 

	Aslında bu iş bir fonksiyona da yaptırırlabilir. Zaten C++11 ile birlikte bu işlemi yapan tanımlaması <utility> dosyasında bulunan move isimli şablon bir fonksiyon bulundurulmuştur.
	Bu durumdaaynı işlemi şöyle de yapabiliriz:

	foo(move(s));

	Bu durumda elimizde bir sınıf nesnesi varsa onun hayatını kaybetmesini beklemeden move fonksiyonunu kullanarak onu sağ taraf değeri referansına dönüştürüp
	taşıma yapıcı fonksiyonuna (ya da taşıma operatör fonksiyonuna) vererek kaynaklarını taşıyabiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <utility>

using namespace std;

class Sample {
public:
	//...
};

void foo(const Sample &r)
{
	cout << "foo, const Sample &" << endl;
}

void foo(Sample &&r)
{
	cout << "foo, Sample &&" << endl;
}

int main(void)
{
	Sample s;

	foo(s);					// const Sample & parametreli olan çağrılır
		
	foo(Sample());			// Sample && parametreli olan çağrılır

	foo(static_cast<Sample &&>(s));		// Sample && parametreli olan çağrılır
	foo(move(s));						// Sample && parametreli olan çağrılır
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda biz return işlemi ile yaşamını kaybetmekte olan nesneler eğer bir sınıf türünden nesneye ilkdeğer olarak kullanılıyorsa zaten sınıfın taşıma yapıcı 
	fonksiyonun çağrılacağını belirtmiştik. Bu özel durumda sol taraf değerini move ile sağ taraf değerine dönüştürmemiz gerekmemektedir. 

	String foo()
	{
		String s("ankara");

		s.disp();

		return s;			// return move(s) ile aynı anlamda
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'ın standart kütüphanesindeki bazı sınıflar için de taşıma yapıcı fonksiyonları eklenmiştir. Örneğin artık string, vector gibi sınıflar
	kaynak taşıması yapabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

string foo()
{
	string s("ankara");

	cout << s << endl;

	return s;			// string sınıfının move constructor'ı çağrılır
}

int main(void)
{
	string s;

	s = foo();			

	cout << s << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte sınıfın bir yapıcı fonksiyonun başka bir yapıcı fonksiyonunu çağırması mümkün hale getirilmiştir. Buna "delegating constructor" denilmektedir. 
	Aslında bu özellik Java, C# gibi dillerde zaten başından beri bulunmaktaydı. Ancak C++'a C++11 ile eklenmiştir. Bir yapıcı fonksiyonun diğerini çağırması 
	MIL sentaksı ile yapılmaktadır. Bu biçimdeki delege edilmiş yapıcı fonksiyon çağrılırken MIL sentaksına başka bir eleman yerleştirilemez. Örneğin:

	class Sample {
	public:
		Sample() : Sample(0)		// Burada MIL sentaksında başka öğe yerleştirilemez
		{
			//...
		}

		Sample(int a)
		{
			m_a = a;
			//...
		}
	private:
		int m_a;
	};

	Tabii bu durumda akış önce MIL sentaksında belirtilen yapıcı fonksiyona aktarılır. Bu yapıcı fonksiyon çalıştırıldıktan sonra akış asıl yapıcı fonksiyondan 
	ana bloğundan girer. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() : Sample(0, 0, 0)
	{
		cout << "Sample::Sample()" << endl;
	}

	Sample(int x, int y, int z)
	{
		cout << "Sample::Sample(int, int, int)" << endl;

		m_x = x;
		m_y = y;
		m_z = z;
	}

private:
	int m_x;
	int m_y;
	int m_z;
};

int main()
{
	Sample s;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir proje nesne yönelimli olarak modellenecekse önce projedeki kavramlar sınıflarla temsil edilir. Sonra bu kavramlar türünden gerçek nesneler yaratılır ve 
	program sınıflar kullanılarak yazılır. Örneğin bir hastane otomasyonunda "hastane", "doktor", "hemşire", "hasta" vs. gibi kavramlar birer sınıfla temsil edilmelidir. 
	Örneğin hastanemizde 10 doktor varsa biz 10 doktor nesnesi yaratırız. Tüm hastaneyi temsil eden bir tane hastane nesnesi yaratırız. 

	Ancak sınıflar da mantıksal bakımdan birbirleriyle ilişkili olabilirler. Sınıflar arasında dört temel ilişki biçimi vardır:

	1) İçerme ilişkisi (composition)
	2) Birleşme ilişkisi (aggregation)
	3) Türetme ilişkisi (inheritance)
	4) Çağrışım ilişkisi (association)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden bir nesne başka bir sınıf türünden bir nesnenin bir parçasını oluşturuyorsa bu iki sınıf arasında "içerme ilişkisi (compoistion)" 
	vardır. İçerme ilişkisi bire-bir olabileceği gibi bire-çok biçimde de olabilir. İçerme ilişkisi UML sınıf diyagramlarında içeren sınıf tarafında içi dolu bir 
	baklavacık (dimaond) ile gösterilmektedir. 

	İçerme ilişkisinin iki temel özelliği vardır:

	1) İçerilen nesne tek bir nesne tarafından içerilir. 
	2) İçeren nesne ile içerilen nesnenin ömürleri yaklaşık aynıdır.

	Bu durumda örneğin insan ile böbrek sınıfı arasında içerme ilişkisi vardır. Böbrekle insan aynı zamanda hayata başlarlar ve aynı zamanda yaşamlarını bitiriler. 
	Bir böbrek tek bir insanın böbreğidir. Aynı zamanda başka bir insanın böbreği değildir. Tabii bu tür modellemelerde tipik durumlar dikkate alınmalıdır. 
	Yani örneğin böbrek nakli tipik bir durum değildir. Böbrek naklinin yapılıyor olması bir böbreğin başkaları tarafından da tipik olarak kullanıldığı anlamına 
	gelmez. Örneğin "oda" ile "duvar" arasındaki ilişki içerme ilişkisi değildir. Her ne kadar oda ile duvarın yaşamları aynıysa da duvar yandaki odanın da duvarıdır. İnsan ile Böbrek 
	sınıfları arasındaki içermel ilişkisi bire-iki biçimindedir. Yani bir insanda iki böbrek bulunmaktadır. 

	C++'ta içerme ilişkisi iki biçimde oluşturulabilir:

	1) İçeren sınıfın private bölümünde içerilen sınıf türünden bir veri elemanı alınır. İçeren sınıf nesnesi yaratıldığında içerilen nesne de yaratılmış olacaktır.
	2) İçeren sınıfın private bölümünde içerilen sınıf türünden bir gösterici veri elemanı bulundurulur. İçeren sınıfın yapıcı fonksiyonunda da new operatörüyle bu veri elemanı 
	için dinamik tahsisat yapılır. Tabii bu tahsisat içeren sınıfın yıkıcı fonksiyonunda delete operatörü ile yok edilmelidir. 

	İçerme ilişkisine İngilizce aynı zamanda "has a" ilişkisi de denilmektedir. 

	Aşağıda içerme ilişkisinin birinci birinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
    //...
private:
    Motor m_motor;
    //...
};

int main(void)
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda da içerme ilişkisinin ikinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
public:
    Araba();
    ~Araba();
private:
    Motor *m_motor;
    //...
};

Araba::Araba()
{
    m_motor = new Motor();
    //...   
}

Araba::~Araba()
{
    //...
    delete m_motor;
}

int main(void)
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Birleşme (aggregation) ilişkisinde bir sınıf türünden nesne başka bir sınıf türünden nesneyi kullanmaktadır. Ancak kullanılan nesne başka nesneler tarafından da
	kullnılıyor olabilir. Kullanan nesne ile kullanılanılan nesnenin yaşamları aynı olmayabilir. Genel olarak içerme ilişkisine uymayan kullanma ilişkisi birleşme
	ilişkisi biçimindedir. Örneğin Hastana ile Doktor sınıfları arasında, Bilgisayar ile Fare sınıfları arasında birleşme ilişkisi vardır. Birleşme ilişkisi 
	UML sınıf diyagramlarında kullanan sınıf tarafında içi boş bir baklavacık (dimaond) ile gösterilmektedir. Birleşme ilişkisi de bire-bir olabileceği gibi bire-çok
	olabilir. 

	Birleşme ilişkisi C++'ta tipik olarak kullanan sınıf içerisinde kulalnılan sınıfa ilişkin bir gösterici tutularak gerçekleştirilir. Tabii bu gösterici dışsarıda
	yaratılmış olan bir nesneyi gösterecektir. Bu sayede birden fazla nesne gösterici yoluyla aynı nesnesiyi kullanabilmektedir. 

	Birleşme ilişkisine İngilizce'de aynı zamanda "holds a" ilşkisi de denilmektedi. 

	Aşağıdaki örnekte Computer ile Mouse sınıfları arasındaki birleşme ilişkisi görülmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Mouse {
    //...
};

class Computer {
public:
    Computer() : m_mouse(nullptr)
    {
        //...
    }

    void attach_mouse(Mouse *mouse)
    {
        m_mouse = mouse;
    }

    Mouse *detach_mouse()
    {
        Mouse *mouse = m_mouse;
        m_mouse = nullptr;

        return mouse;
    }
private:
    Mouse *m_mouse;
    //...
};

int main(void)
{
    Computer computer1;
    Computer computer2;
    //...
    Mouse *mouse1 = new Mouse();
    computer1.attach_mouse(mouse1);

    auto mouse = computer1.detach_mouse();
    computer2.attach_mouse(mouse);

    Mouse *mouse2 = new Mouse();
    computer1.attach_mouse(mouse2);

    delete mouse1;
    delete mouse2;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki bir satranç tahtasının NYPT ile modellenmesi örneği verilmiştir. Burada Board sınıfı tahtayıi Square sınıfı tahtanının karelerini ve Figure 
	sınıfı ise satranç taşlarını temsil etmektedir. Board sınıfı ile Square sınıfı arasında "içerme (composition)", Square sınıfı ile Figure sınıfı arasında ise
	"birleşme (aggregation)" ilişkisi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum class Color {
    White, Black
};

enum class Type {
    King, Queen, Rook, Bishop, Knight, Pawn
};

class Figure {
public:
    Figure(Type type, Color color) : m_type(type), m_color(color)
    {}
    Type type() const { return m_type; }
    Color color() const { return m_color; }
    string to_string();
    friend ostream &operator <<(ostream &os, Figure *figure);
    //...
private:
    Type m_type;
    Color m_color;
};

class Square {
public:
    Square() = default;
    Square(Color color) : m_color(color)
    {}
    Color color() const { return m_color; }
    void set_color(Color color) { m_color = color;}
    Figure *figure() const { return m_figure; }
    void set_figure(Figure *figure) { m_figure = figure; }
    //...
private:
    Color m_color;
    Figure *m_figure;
};

string Figure::to_string()
{
    static const char *figure_names[] = {"King", "Queen", "Rook", "Bishop", "Knight", "Pawn"};

    string s;

    s += m_color == Color::Black ? "Black " : "White ";
    s += figure_names[static_cast<int>(m_type)];

    return s;       // move constructor çağrılacak
}

ostream &operator <<(ostream &os, Figure *figure)
{
    os << figure->to_string();

    return os;
}

class Board {
public:
    Board();
    Square &square(int row, int col)
    {
        return m_squares[row][col];
    }
private:
   Square m_squares[8][8];
};

Board::Board()
{
    for (int row = 0; row < 8; ++ row)
        for (int col = 0; col < 8; ++col) {
            m_squares[row][col].set_color((row + col) % 2 == 0 ? Color::Black : Color::White);
            m_squares[row][col].set_figure(nullptr);
        }

    m_squares[0][0].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][0].set_figure(new Figure(Type::Rook, Color::Black));

    m_squares[0][1].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][1].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][2].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][2].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][3].set_figure(new Figure(Type::Queen, Color::White));
    m_squares[7][3].set_figure(new Figure(Type::Queen, Color::Black));

    m_squares[0][4].set_figure(new Figure(Type::King, Color::White));
    m_squares[7][4].set_figure(new Figure(Type::King, Color::Black));

    m_squares[0][5].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][5].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][6].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][6].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][7].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][7].set_figure(new Figure(Type::Rook, Color::Black));

    for (int col = 0; col < 8; ++col) {
        m_squares[1][col].set_figure(new Figure(Type::Pawn, Color::White));
        m_squares[6][col].set_figure(new Figure(Type::Pawn, Color::Black));
    }
}

int main(void)
{
    Board board;

    cout << board.square(0, 0).figure()->to_string() << endl;

    cout << board.square(0, 5).figure() << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de "kalıtım (inheritance)" bir sınıfa ona dokunmadan ekleme yapmak için kullanılan bir yöntemdir. Elimizde A isimli bir sınıf bulunuyor olsun. 
	Biz bu sınıfa onu bozmadan birkaç üye fonksiyon eklemek isteyelim. İşte bu A sınıfından bir B sınıfını türetiriz. Ekleyeceğimiz üye fonksiyonları bu
	B sınıfına ekleriz. Burada ekleme yapmak istediğimiz A sınıfına "taban sınıf (base class)" eklemelerin yapıldığı B sınıfına da "türemiş sınıf (derived class)"
	denilmktedir. Türemiş sınıf hem taban sınıf gibi davranmakta hem de kendine özgü fazlalıklara sahip olmaktadır. Türemiş sınıftan da sınıflar türetilebilir. 
	Bu durumda türemiş sınıf onun taban sınıflarının tüm işlevselliklerine sahip olur. UML sınıf diyagramlarında türetme ilişkisi "türemiş sınıftan taban sınıfa doğru
	çekilen içi boş bir okla" temsil edilmektedir.

	C++'ta türetme ilişkisine İmgilizce "is a" ilişkisi de denilmektedir. 

	Bir sınıf birden fazla sınıfın taban sınıfı durumunda olabilir. Bu durum tamamen normal bir durumdur. Ancak bir sınıfın birden fazla taban sınıfa sahip olması 
	durumu özel bir durumdur. Buna NYPT'de "çoklu türetme (multiple inheritance)" denilmektedir. Java, C#, Swift gibi dillerin bazılarında çoklu türetme yoktur.
	Ancak C++, Object Pascal, Python gibi dillerde çoklu türetme vardır. 

	Türetmenin en önemli kullanım nedeni sınıfa onu bozmadan eklemeler yapmak ve kod tekrarını ortadan kaldırmaktır. İki sınıf ortak elemanlara sahipse
	bu sınıfların bağımsız yazılması durumunda gereksiz kod tekrarı oluşur. Halbuki bu ortak elemanlar bir taban sınıfta toplanırsa bu kod tekrarı ortadan 
	kaldırılmış olur. Örneğin B isimli bir sınıfta foo, bar ve tar fonksiyonları bulunuyor olsun. C isimli bir sınıfta da foo, bar ve zar fonksiyonları bulunuyor olsun.
	Burada foo ve bar fonksiyonları her iki sınıfta da tekrarlanmaktadır. Biz bu iki fonksiyonu taban bir A sınıfına yerleştirip B ve C'yi bu sınıftan türetirsek 
	kod tekrarını ortadan kaldırmış oluruz. 

	C++'ta türetme işlemleri özel bir setaksla yapılmaktadır. İzleyen bölümde türetme işlemlerinin nasıl yapıldığı açıklanacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Çağrışım ilişkisinde (association) bir sınıf bir sınıfı kullanmaktadır. Ancak bu kulanma onu bünyesine katarak (yani bir veri elemanında saklayarak) yapılmaz.
	Yalnızca üye fonksiyonlar tarafından yapılır. Yani kullanma bazı alanlarla sınırlıdır. Örneğin Hastane sınıfı gerektiğinde reklam yapacaktır. Bunun için sınıfın
	reklam_yap gibi bir üye fonksiyonu reklam şirketini kullanabilir. Bir ticari taksi ile şoför arasında bir birleşme ilişkisi vardır. Bunlarla taksinin sahibi 
	arasında bir birleşme ilişkisi vardır. Ancak taksi ile yolcu arasındaki ilişki yüzeyseldir. Bu ilişki çağrışım ilişkisi biçiminde ifade edilebilir.

	Çağrışım ilişkisi UML sınıf diyagramlarında kullanan sınıftan kullanılan sınıfa doğru ince bir çizgi ve bir okla temsil edilmektedir.  

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta türetme işleminin genel biçimi şöyledir:

	class <türemiş sınıf ismi> : [türetme biçimi] <taban sınıf ismi> {
		//...
	};

	Buradaki türetme biçimi "public", "protected" ya da "private" biçiminde olabilir. Türetme biçimi belirtilmezse türemiş sınıf class anahtar sözcüğü ile oluşturulmuşsa
	"private", struct anahtar anahtar sözcüğü ile oluşturulmuşsa "public" kabul edilir. En yaygın kullanılan türetme biçimi public türetmesidir. Java, C# gibi dillerde
	türetme biçimi yoktur. Ancak o dillerdeki türetme C++'taki "public türetmesi" gibidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türetme işleminde türemiş sınıf hem taban sınıf gibi kullanılabilmekte hem de ek birtakım elemanlara sahip olabilmektedir. Aşağıdaki örnekte B sınıfı A'dan
	türetilmiştir. B sınıfı hem A gibi kullanılabilir hem de kendi elemanlarına sahiptir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;


class A {
public:
	void foo();
	void bar();
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

class B : public A {
public:
	void tar();
	//....
};

void B::tar()
{
	cout << "B::tar" << endl;
}

int main()
{
	B b;

	b.foo();
	b.bar();
	b.tar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf veri elemanları bakımından da taban sınıfı içermektedir. Yani türemiş sınıf türünden bir nesne hem türemiş sınıfın veri elemanlarını hem de taban 
	sınıfın veri elemanlarını içerir. Standartlarda türemiş sınıf nesnesi içerisindeki veri eleman diziliminde taban sınıfın mı yoksa türemiş sınıfın mı
	veri elemanlarının düşük adreste bulundurulacağı konusunda bir belirlemede bulunulmamıştır. Ancak derleyicilerin hemen hepsi türemiş sınıf nesnesi yaratıldığında
	önce taban sınıf veri elemanlarını sonra türemiş sınıf veri elemanlarını ardışıl bir biçimde yerleştimektedir. Örneğin B sınıfı A sınıfından türetilmiş olsun.
	Biz de B sınıfı türünden bir nesne yaratmış olalım. Tipik organizasyon şöyledir:

	A-data-members
	B-data-members

	Dolayısıyla türemiş nesnesinin adresini aldığımızda önce onun taban kısmıyla karşılaşırız. Aşağıdaki örnekte taban ve türemiş sınıf içerisinde ikişer int 
	türen veri elemanı bulundurulmuştur. Bunların sizeof değerlerine dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_x;
	int m_y;
};

class B : public A {
public:
	int m_z;
	int m_k;
};

int main()
{
	B b;

	cout << sizeof b << endl;			// 16

	b.m_x = 10;
	b.m_y = 20;
	b.m_z = 30;
	b.m_k = 40;

	cout << b.m_x << ", " << b.m_y << ", " << b.m_z << ", " << b.m_k << endl;		// 10, 20, 30, 40

	A a;

	cout << sizeof a << endl;		// 8


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıflarda erişim kuralları türetme biçimine göre değişmektedir. Yukarıda da belirttiğimiz gibi en çok kullanılan türetme biçimi "public türetmesisir".

	public türetmesinde taban sınıfın public bölümü türemiş sınıfın public bölümüymüş gibi, taban sınıfın protected bölümü türemiş sınıfın protected bölümüymüş gibi
	işlem görür. Taban sınıfın private bölümü tamamen korunmuştur. Türemiş sınıf tarafından erişilemez. 

	public türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfın yalnızca public bölümündeki elemanlara erişebiliriz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Burada taban sınıfın protected bölümüne kendi sınıfı dışında yalnızca türemiş sınıfın üye fonksiyonları tarafından erişilebildiğine dikkat ediniz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : public A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();		// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// geçerli
	b.zar();		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	protected türetmesinde taban sınıfın public ve protected bölümleri türemiş sınıfın protected bölümüymüş gibi işlem görmektedir. Taban sınıfın private bölümü 
	tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez. 

	protected türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	public ve protected türetmesi arasındaki fark taban sınıfın public bölümüne dışarıdan türemiş sınıf nesnesi, gösterici ve referansı yoluyla erişilebilmesi ancak 
	protected türetmesinde erişilememesidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : protected A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();	// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	// b.foo();		// error!
	b.zar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	private türetmesinde taban sınıfın public ve protected bölümleri türemiş sınııfn private bölümüymüş gibi işlem görmektedir. 

	private türetmesinden çıkan sonuçlar sanki protected türetmesinden çıkan sonuçlarla aynı gibidir:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Her ne kadar protected türetmesiyle private türetmesinden çıkan sonuçlar aynı gibi gözküyorsa da bir dizi türetme yapıldığında arada farklılıklar oluşabilmektedir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme yapıldığında yukarıdaki kurallar geçişli biçimde devam etmektedir. Aşağıdaki gibi bir türetme şeması olsun:

	class A {
		//...
	};

	class B : public A {
		//...
	};

	class C : public B {
		//...
	};

	Burada C sınıfının bir üye fonksiyonu içerisinde biz hem A2nın public ve protected elemanlarını hem de B2nin public ve protected elemanlarını doğrudan
	kullanabiliriz. Yine dışarıdan C nesnesi, göstericisi ya da referansı tyoluyla hem A'nın hem B2nin hem de C'nin public elemanlarına erişebiliriz. 

	Şimdi B sınıfı A'dan private türetilmiş olsun:

	class A {
		//...
	};

	class B : private A {
		//...
	};

	class C : public B {
		//...
	};

	Burada biz artık C'nin üye fonksiyonları içerisinde A'nın public ve protected elemanlaırnı kullanamayız. Şimdi B sınıfı A'dan protected türetilmiş olsun:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	class C : public B {
		//...
	}; 

	Biz burada artık C2nin üye fonksiyonları içerisinde A'nın ve B'nin public ve protected bölümlerindeki elemanları doğrudan kullanabiliriz. 
	Görüldüğü gibi protected ve private türetmesi arasında bu tür durumlarda semantik farklılık oluşmaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tüm bunların ışığı altına sınıfların protected bölümleri için şunlar şöylenebilir: Sınıfın protected bölümü türemiş sınıfların üye fonksiyonları tarafından 
	doğrudan kullanılabilen ancak dışaıdan kullanılamayan bölümüdür. Biz bir elemanı protected bölüme neden yerleştiririz? İşte bizim yazdığımız sınıftan bir türetme
	yapılabileceğini öngörüp türemiş sınıfı yazanlara erişim kolaylığı sağlamak için bazı elemanları protected bölüme yerleştirebilriz. Ancak sınıfın protected 
	bölümünde bir değişiklik yapıldığında yalnızca o sınıfın içinin değil tüm türemiş sınıfların içlerinin yeniden yazılması gerekir. Bu nedenle bazı teorisyenler
	protected bölümün hiç kullanılmaması gerektiğini de düşünmektedir. Tabii bir sınıfta public bölüm gibi protected bölümün de dokümantasyonu yapılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın "taban sınıfları (base classes)" denildiği zaman yukarıya doğru onun bütün taban sınıfları anlaşılır. Bir sınıfın "doğruan taban sınıfları (direct base class)"
	denildiğinde ise o sınıfın hemen bir yukarısındaki taban sınıfları anlaşılır. Bir sınıfın "dolaylı taban sınıfları (indirect base classes)" ise o sınıfın doğurdan 
	taban sınıflarının taban sınıfları anlaşılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta (Java ve C#'ta da böyle) türemiş sınıf türünden bir nesne yaratıldığında türemiş sınıfın uygun yapıcı fonksiyonu çağrılır. Ancak türemiş sınıfın yapıcı 
	fonksiyonu taban sınıfın private bölümüne erişemediğine göre onun taban sınıf elemanlarına ilkdeğer veremez. İşte bunu sağlamak için şöyle bir mekanizma
	bulundurulmuştur: Türemiş sınıfın yapıcı fonksiyonu türemiş sınıfın taban sınıf kısmı için taban sınıfın yapıcı fonksiyonunu çağırmaktadır. Böylece nesnenin taban 
	sınıf kısmı taban sınıfın yapıcı fonksiyonu ile ilkdeğerlenmiş olur. Türemiş sınıfın yapıcı fonksiyonunun taban sınıfın yapıcı fonksiyonunu çağırması 
	türemiş sınıfın yapıcı fonksiyonun ana bloğunun başında derleyicinin yerleştirdiği gizli bir çağırma kodu yoluyla yapılmaktadır. Böylece önce taban sınıf yapıcı 
	fonksiyonu sonra türemiş sınıf yapıcı fonksiyonu çalıştırılmış olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme olduğu durumda her sınıfın yapıcı fonksiyonu kendi sınıfının doğrudan taban sınıfının yapıcı fonksiyonunu çağırmaktadır. Böylece
	aslında yapıcı fonksiyonlar yukarıdan aşağıya doğru çalıştırılmış olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

class C : public B {
public:
	C();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

C::C()
{
	cout << "C constructor" << endl;
}

int main()
{
	C c;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi taban sınıfın birden fazla yapıcı fonksiyonu varsa nesnenin taban sınıf parçası için taban sınıfın hangi yapıcı fonksiyonu çağrılacaktır? İşte bu durum
	daha önce görmüş olduğumuz MIL sentaksıyla belirlenmektedir. MIL sentaksında ':' atomundan sonra taban sınıfın ismi belirtilerek bir argüman listesi 
	girilirse o argüman listesine uygun taban sınıfın yapıcı fonksiyonu çağrılmaktadır. Eğer MIL sentaksında bu biçimde taban sınıf ismi belirtilmediyse bu durumda
	nesnenin taban sınıf parçası için taban sınıfın default yapıcı fonksiyonu çağrılmaktadır. 

	Tabii biz türemiş sınıfın yapıcı fonksiyonunda MIL sentaksında o yapıcı fonksiyonun parametrelerini taban sınıf yapıcı fonksiyonu için argüman olarak kullanabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	A(int x);
	
	int x() const { return m_x; }
private:
	int m_x;
};

class B : public A {
public:
	B();
	B(int x, int y);

	int y() const { return m_y; }
private:
	int m_y;
};

A::A()
{
	m_x = 0;
}

A::A(int a)
{
	m_x = a;
}

B::B()
{
	m_y = 0;
}

B::B(int x, int y) : A(x)
{
	m_y = y;
}

int main()
{
	B b1;

	cout << b1.x() << endl;		// 0
	cout << b1.y() << endl;		// 0

	B b2(10, 20);

	cout << b1.x() << endl;		// 10
	cout << b1.y() << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonlar ters sırada çalıştırılmaktadır. Bu durumda türemiş sınıfın yıkıcı fonksiyonunun ana bloğunun 
	sonunda derleyici tarafından yerleştirilen gizli bir çağırma kodu yoluyla taban sınıfın yıkıcı fonksiyonu çağrılmaktadır. Yani önce türemiş sınıfın sonra taban 
	sınıfın yıkıcı fonksiyonları çalıştırılmış olmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

A::~A() 
{
	cout << "A destructor" << endl;
}

B::B() 
{
	cout << "B constructor" << endl;
}

B::~B() 
{
	cout << "B destructor" << endl;
}

int main()
{
	cout << "main begins..." << endl;
	{
		B b;

		cout << "continues..." << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir sınıf hem başka bir sınıftan türetilmiş olsun hem de sınıfın başka sınıf türünden bir veri elemanı bulunyor olsun. Bu durumda yapıcı ve yıkıcı fonksiyonların
	çağrılma sıraları nasıl olacaktır? İşte her zaman önce taban sınıfın yapıcı fonksiyonu çalıştırılır, sonra elemanlara ilişkin sınıfların yapıcı fonksiyonu çalıştırılır 
	sonra da türemiş sınıfın yapıcı fonksiyonu çalıştırılır.  Tabii yıkıcı fonksiyonların çağrılma sırası ters biçimde olacaktır.

	C++'ta hiçbir zaman MIL sentaksındaki sıranın bir önemi yoktur. Yani örneğin biz MIL sentaksında önce eleman için belitim yapsak bile yine taban sınıfın 
	yapıcı fonksiyonu önce çağrılacaktır. Daha önceden de elemanlar için yapıcı fonksiyonların bildirimdeki sıraya göre çağrıldığını görmüştük.

	Aşağıdaki örnekte B sınıfı A sınıfından türetilmiştir ve X sınıfı türünden bir veri elemanına sahiptir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class X {
public:
	X();
	~X();
	//...

};

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
private:
	X m_x;
	int m_y;
};

X::X()
{
	cout << "X constructor" << endl;
}

X::~X()
{
	cout << "X destructor" << endl;
}

A::A()
{
	cout << "A constructor" << endl;
}

A::~A()
{
	cout << "A destructor" << endl;
}

B::B() : m_x(), A()		// MIL sentaksındaki sıranın hiçbir önemi yok! Yine önce A için yapıcı fonksiyon çağrılır
{
	cout << "B constructor" << endl;
}

B::~B()
{
	cout << "B destructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çoklu türetme durumunda sınıfın doğrudan taban sınıfı birden fazla olabilmektedir. Bu durumda taban sınıfların yapıcı fonksiyonlarının çağrılma sıraları 
	bildirimdeki sıraya göredir. MIL sentaksındaki sıranın bir önemi yoktur. Yine MIL sentaksında belirtilmeyen sınıflar için o sınıfların default yapıcı fonksiyonlarında çağrılmaktadır. 
	Tabii yıkıcı fonksiyonlar yine ters sırada çağrılırlar. Örneğin:

	class A {
		//...
	};

	class B {
		//...
	};

	class C : public A, public B {
		//...
	};

	Burada C'nin yapıcı fonksiyonu şöyle yazılmış olsun:

	C::C(...) : B(...)
	{
		//...
	}

	Burada MIL sentaksında A taban sınıfı belirtilmemiştir. Ancak yine derleyici önce A için default yapıcı fonksiyonu sonra B için belirtilen yapıcı 
	fonksiyonu çağırır.

	Sınıfın temel türlerine ilişkin veri elemanları için de MIL sentaksında ilkdeğer verilebildiğini görmüştük. Bunlar da tamamen sınıfın başka sınıf türünden 
	veri elemanlarıyla aynı hakka sahip olarak bildirimdeki sıraya göre ilkdeğer alırlar. Örneğin C sınıfı şöyle olsun:

	class C : public A, public B {
	public:
		//...
	private:
		int m_x;
		Y m_y;
	};

	C::C(...) : m_y(...), m_x(...), B(...)
	{
		//...
	}

	Burada önce A için default yapıcı fonksiyon çağrılır. Sonra B için belirtilen yapıcı fonksiyon çağrılır. Sonra X için ilkdeğerleme yapılır, sonra
	m_y için Y sınıfının uygun yapıcı fonksiyonu çağrılır. Tabii yıkıcı fonksiyonlar her zaman ters sırada çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir göstericiye (void gösterici dışında) farklı türden bir adres bilgisini doğrudan atayamayız. Ancak C++'ta istisna olarak türemiş sınıf türünden bir adres
	taban sınıf türünden bir göstericiye doğrudan atanabilmektedir. Yani türemiş sınıf adresleri taban sınıf adreslerine doğrudan dönüştürülebilmektedir. Örneğin,
	B sınıfı A sınıfından türetilmiş olsun:

	A *pA;
	B b;

	pA = &b;		// geçerli

	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye atanması sonrasında artık taban sınıf türünden gösterici türemiş sınıf nesnesinin
	taban sınıf kısmını gösteriyor durumda olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;
	A *pA;

	b.m_a = 10;
	b.m_b = 20;

	pA = &b;
	cout << pA->m_a << endl;					// 10

	pA->m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemin tersi geçerli değildir. Yani biz taban sınıf türünden bir nesnenin adresini türemiş sınıf türünden bir göstericiye doğrudan atayamayız.
	Eğer böyle bir şey mümkün olsaydı türemiş sınıf göstericisi yoluyla biz aslında var olmayan elemanlara erişebilirdik. Bu da tanımsız davranışa yol açardı.
	Türemiş sınıf türünden nesnenin adresini taban sınıf türünden göstericiye atayabiliyor olmamız türemiş sınıf nesnesinin taban sınıfı kapsamasından kaynaklanmaktadır.
	Halbuki taban sınıf nesnesi türemiş sınıf nesnesini kapsamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme söz konusu olduğunda türemiş sınıf nesnesinin adresi o türemiş sınıfın büütn taban sınıfları türünden göstericilere atanabilmektedir. Örneğin
	C sınıfı B sınıfından B sınıfı da A sınıfından türetilmiş olsun:

	A
	B
	C

	Biz burada C sınıfı türünden bir nesnenin adresini A sınıfı türünden ya da B sınıfı türünden bir göstericiye atayabiliriz. Yani türemiş sınıf adreslerinden 
	o sınıfın tüm taban sınıflarının adreslerine otomatik (implicit) tür dönüştürmesi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Referanslar da bir çeşit gösterici olduğuna göre türemiş sınıftan taban sınıfa adres dönüştürmeleri referanslar yoluyla da yapılabilmektedir. Yani taban sınıf
	türünden bir referans türemiş sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanabilir. Bu durumda taban sınıf türünden referans türemiş sınıf nesnesinin
	yine taban kısmının adresini tutacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;

	b.m_a = 10;
	b.m_b = 20;

	A &r = b;

	cout << r.m_a << endl;						// 10

	r.m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye ya da referansa atanması bir türetme şeması üzerinde genel işlemleri yapabilen fonksiyonların
	yazılmasını mümkün hale getirmektedir. Aşağıdaki gibi bir türetme şeması olsun:

                           Employee
              Worker        Manager        SalesPerson
			               Executive


	Burada her sınıf aslında Employee sınıfından türetilmiştir. Aşağıdaki gibi bir fonksiyon olsun:

	void disp_employee(const Employee &e);

	Biz bu fonksiyon ile çalışan kişi kim olursa olsun onun temel bilgilerini display edebiliriz. Çünkü bu temel bilgiler zaten Employee sınıfı içerisindedir ve
	her türemiş sınıfın aslında bir Employee kısmı vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// employee.hpp

#ifndef EMPLOYEE_HPP_
#define EMPLOYEE_HPP_

#include <string>

class Employee {
public:
	Employee(const char *name, const char *address, int no);
	
	std::string name() const { return m_name; }
	std::string address() const { return m_address; }
	int no() const { return m_no; }

private:
	std::string m_name;
	std::string m_address;
	int m_no;
};

#endif

// employee.cpp

#include "employee.hpp"

Employee::Employee(const char *name, const char *address, int no)
	: m_name(name), m_address(address), m_no(no)
{
	//...
}

// worker.hpp

#ifndef WORKER_HPP_
#define WORKER_HPP_

#include "employee.hpp"

enum class Shift {
	Morning, Noon, Even
};

class Worker : public Employee {
public:
	Worker(const char *name, const char *address, int no, Shift shift, int overtime);
private:
	Shift m_shift;
	int m_overtime;
};

#endif

// worker.cpp

#include "worker.hpp"

Worker::Worker(const char *name, const char *address, int no, Shift shift, int overtime)
	: Employee(name, address, no)
{
	m_shift = shift;
	m_overtime = overtime;
}

// manager.hpp

#ifndef MANAGER_HPP_
#define MANAGER_HPP_

#include <string>
#include "employee.hpp"

class Manager : public Employee {
public:
	Manager(const char *name, const char *address, int no, const char *department);
	//...
private:
	std::string m_department;
};

#endif

// manager.cpp

#include "manager.hpp"

Manager::Manager(const char *name, const char *address, int no, const char *department)
	: Employee(name, address, no), m_department(department)
{}

// app.cpp

#include <iostream>
#include "employee.hpp"
#include "worker.hpp"
#include "manager.hpp"

using namespace std;


void disp_employee(const Employee &e)
{
	cout << e.name() << ", " << e.address() << ", " << e.no() << endl;
}

int main()
{
	Worker w("Kaan Aslan", "Atasehir", 567, Shift::Morning, 2);
	Manager m("Necati Ergin", "Mecidiyekoy", 678, "Uretim");

	disp_employee(w);
	disp_employee(m);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf nesnesinin adresini taban sınıf türünden gösterici ya da referansa atayabilmemiz için türetme biçiminin "public türetmesi" olması gerekir. 
	Zaten en fazla kullanılan türetme biçiminin "public türetmesi" olduğunu anımsayınız. Örneğin:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	B b;
	A *pa = &b;		// error!

	Eğer böyle bir şeye izin verilseydi o zaman b yoluyla A'nın public bölümüne erişemediğimiz halde bu yolla erişebilir duruma gelirdik.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta derleyici bir isimle karşılaştığında o ismin bir bildirimini bulmak zorundadır. Bir isme ilişkin bildirimin bulunması sürecine standartlarda 
	"isim araması (name lookup)" denilmektedir. İsim araması ikiye ayrılmaktadır:

	1) Niteliksiz isim araması (unqualified name lookup)
	2) Nitelikli isim araması (qualified name lookup)

	Düz yazılan yani ".", "->" ve "::" opereatörü olmadan yazılan isimlerin aranması niteliksiz arama kurallarına göre yapılır. Ancak nokta operatörünün, 
	ok operatörünün ve :: operatörünün sol tarafındak isimlerin aranması niteliksiz, sağ tarafındaki isimlerin aranması nitelikli isim arama kuralına göre yapılmaktadır. İsim araması sırasıyla bazı faaliyet alanlarına sırasıyla bakılarak yapılır. 
	İsim sırasıyla çeşitli faaliyet alanlarınd aranır. İsim bulunursa arama devam ettirilmez. İsim bulunmazsa error oluşur. 

	Niteliksiz isimlerin aranması aşağıdaki sırada yapılmaktadır.

	1) İsim bir fonksiyon içerisinde kullanılmışsa derleyici ismi önce kullanım yerinden yukarıya doğru fonksiyonun yerel blokları içerisinde içten dışa doğru arar. 
	2) İsim bir üye fonksiyonun içerisinde kullanılmışsa o üye fonksiyonun ilişkin olduğu sınıf bildiriminin  her yerinde aranır (fonksiyon inline olarak sınıf içerisinde
	yazılmış olsa da sınıf bildiriminin her yerine bakılır.)
	3) İsim üye fonksiyonun ilişkin olduğu sınıfın taban sınıflarında aşağıdan yukarıya doğru onların sınıf bildirimlerinin her yerinde aranır. Eğer çoklu türetme 
	söz konusuysa ismin taban sınıf kollarından yalnızca birinde bulunuyor olması gerekir. Eğer farklı kollarda isim bulunursa bu durum error oluşturur. İsmin farklı kollardaki bulunduğu düzeyin 
	bir önemi yoktur. Yani çoklu türetmede arama kollarda herhangi bir sırada yapılmamaktadır. Başka bir deyişle bir kolun diğer kola herhangi bir üstünlüğü yoktur.
	4) İsim kullanıldığı fonksiyonun içinde bulunduğu isim alanı içerisinde kullanım yerinden yukarıdaki bölgede aranır.
	5) İsim kullanıldığı isim alanını kapsayan isim alanlarında içten dışa doğru kullanım yerinden yukarıdaki bölgede aranır.
	6) İsim nihayet global isim alanında kullanım yerinden yukarıdaki bölgede aranır.

	C++'ta her zaman önce isim araması yapılır. Sonra erişim kontrolü uygulanır. Yani arama erişilebilen isimler arasında yapılmaz. 

	C++'ta (Java ve C# gibi dillerde böyle değil) bir isim bir sınıfta bulunursa artık isim araması bitirilir. Dolayısıyla bulunan isim bir fonksiyon ismi 
	ise overload resolution işlemine aday fonksiyon olarak ismin bulunduğu sınıftaki aynı isimli fonksiyonlar sokulur. Taban sınıftaki fonksiyonlar artık
	overload resolution işlemine sokulmaz. Yani C++'ta "overload resolution" işlemi yalnızca aynı faaliyet alanındaki fonksiyonlar arasında yapılmaktadır. 

	Yukarıda belirttiğimiz gibi ".", "->" ve "::" operatörlerinin sağ tarafındaki isimler "nitelikli isim araması" kurallarına göre aranmaktadır. Nitelikli isim araması
	aşağıdaki sırada yapılmaktadır:

	1) Nokta ya da ok operatörünün sağındaki isimler solundaki nesne ya da gösterici hangi sınıf türündense o sınıf bildirimi içerisinde sınıf bildiriminin her 
	yerinde aranır. Eğer isim o sınıfta bulunamazsa aşağıdan yukarıya doğru isim o sınıfın taban sınıflarında onların bildirimlerinin her yerinde sırasıyla aranır.
	Ayrıca kapsayan isim alanlarında herhangi bir arama yapılmaz.  
	2) :: operatörünün sağındaki isimler eğer bu operatörün solunda bir isim alanı varsa yalnızca o isim alanında kullanım yerinden yukarıdaki bölgede aranır.
	Kapsayan isim alanlarına bakılmaz. Eğer :: operatörünün solunda bir sınıf ismi varsa isim o sınıf bildiriminde aranır, bulunamazsa taban sınıfların bildirimlerinde de 
	aşağıdan yukarıya doğru aranır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public: 
	void foo(double a)
	{
		cout << "A::foo double" << endl;
	}
	void foo(const char *name)
	{
		cout << "A::foo const char *" << endl;
	}
};

class B : public A {
public:
	void foo(int a)
	{
		cout << "B::foo int" << endl;
	}
	void bar()
	{
		foo(10.2);		// dikkat isim isim bulununca artık taban sınıflara bakılmaz!
		foo("ali");		// error! isim bulunuca artık taban sınıflara bakılmazm!
	}
};

int main()
{
	B b;

	b.bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıf ile türemiş sınıfta aynı isimi elemanların bulunduğu durumda isim arama kurallarına göre önce türemiş sınıftaki elemanlara bulunamazsa aşağıdan
	yukarıya doğru taban sınıftaki elemamlara bakılmaktadır. Bu tür durumlarda taban sınıftaki elemanlarına taban sınıf ismi ve çözünürlük operatörü ile erişilebilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// B::foo

	b.A::foo();		// A::foo

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de çokbiçimlilik biyolojiden aktarılmış bir kavramdır. Biyolojide çokbiçimlilik "bir canlının çeşitli doku ve organlarının temel işlevleri aynı kalmak üzere
	onların yaşam koşullarına göre farklılaşması" anlamına gelmektedir. Örneğin "kulak" pek çok canlıda vardır. Temel işlevi duymaktır. Ancak her canlının kulağı az çok 
	diğer canlılardan farklılıklar göstermektedir. 

	Pek çok teorisyene göre bir dilin nesne yönelimli olması için "sınıf", "türetme" dışında çokbiçimliliğe de sahip olması gerekmektedir. Eğer bir dilde sınıf varsa, türetme varsa
	ama çokbiçimlilik yoksa bu dillere "nesne yönelimli (object oriented)" değil "nesne tabanlı (object based)" diller denilmektedir. 
	
	Çokbiçimlilik (polymorphism) NYPT'nin en önemli anahtar kavramlarından biridir. Çeşitli bakış açılarına göre çeşitli biçimlerde tanımlanabilir:

	1) Çokbiçimlilik türden bağımsız kod paraçalarının oluşturulması için kullanılan bir tekniktir. (Yazılım mühendisliği tanımı)
	2) Çokbiçimlilik taban sınııfn belli bir fonksiyonunun türemiş sınıflar tarafından onlara özgü bir biçimde gerçekleştirilmesidir. (Biyolojik tanım)
	3) Çokbiçimlilik önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesi özelliğidir (Aşağı seviyeli tanım)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta çokbiçimlilik sanal fonksiyonlarla (virtual functions) gerçekleştirilmektedir. Yalnızca sınıfların static olmayan üye fonksiyonları sanal yapılabilmektedir. 
	Bir üye fonksiyonu sanal yapabilmek için üye fonksiyon bildiriminde "virtual" anahtar sözcüğünün kullanılması gerekir. virtual anahtar sözcüğü tanımlama sırasında
	kullanılamaz. Yalnızca bildirimde kullanılabnilir. Örneğin:

	class A {
	public:
		virtual void foo();		// sanal fonksiyon
		//...
	};

	void A::foo()				// tanımşama sırasında virtual anahtar sözcüğü kullanılmaz
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki bir sanal fonksiyon türemiş sınıfta "aynı isimle, aynı parametrik yapıyla" ve "aynı geri dönüş değeri türü ile" bildirilirse bu duruma 
	"taban sınıftaki sanal fonksiyonun türemiş sınıfta "override" edilmesi denilmektedir. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir geri dönüş 
	değeri türü ile override edilemez. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir parametrik yapıyla da override edilemez. 

	Taban sınıftaki sanal fonksiyon türemiş sınıfta override edildiğinde override edilmiş olan bu fonksiyon da sanal kabul edilir. Bu fonksiyonun başına
	virtual yazılmasa bile yazılmış kabul edilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	Taban sınıfta sanal olmayan bir fonksiyon türemiş sınıfta aynı biçimde yeniden tanımlanırsa bu bir override işlemi değildir. Override terimi sanal fonksiyonlar
	için kullanılır. Örneğin:

	class A {
	public:
		void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// bu bir override işlemi değil!
		//...
	};

	Taban sınıftaki sanal fonksiyon yanlışlıkla türemiş sınıfta farklı bir parametrik yapıyla (const'luk da dahil olmak üzere) yazılırsa bu durum override anlamına 
	gelmez. Bu konuda dikkat etmek gerekir. Örneğin:

	class A {
	public:
		virtual void foo() const;
		virtual void bar(int a);
		virtual void tar(int a);
		//...
	};

	class B : public A {
	public:
		void foo();			// geçerli ancak bu bir override işlemi değil! çünkü const'luk belirtilmemiş
		void bar();			// geçerli ancak bu bir override işlemi değil! parametrik yapılar farklı
		int tar(int a);		// geçersiz! aynı parametrik yapıyla farklı geri dönüş değeri türüyle override işlemi yapılamaz
		//...
	};

	Override işlemi bir dizi türetmede devam ettirilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Tabii sanallık daha sonra da başlatılabilir. Örneğin:

	class A {
	public:
		void foo();		// sanal değil
		//...
	};

	class B : public A {
	public:
		virtual void foo();				
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Override işlemi için sanal fonksiyonun doğrudan taban sınıfta olması gerekmemektedir. Yani sınııfn doğurdan taban sınıfında değil dolaylı taban sınıflarında 
	sanal yapılmış bir fonksiyon da overrde edilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
	};

	class B : public A {
	public:
		void foo(int a);		// override işlemi değil
	};

	class C : public B {
	public:
		void foo();				// geçerli override işlemi 
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden gösterici ya da referansın "statik" ve "dinamik" türü vardır. Sınıf türünden olmayan değişkenlerin yalnızca statik türleri vardır.
	Bir sınıf türünden gösterici ya da referansın statik türü bildirimde belirtilen türüdür. Dinamik türü ise o gösterici ya da referans bir nesneyi gösteriyorken 
	eğer aslında başka bir nesnenin türemiş sınıf parçasını gösteriyorsa gösterdiği nesnenin bütününün türüne o gösterici ya da referansın dinamik türü denilmektedir. 
	Gösterici ya da referansların statik türleriyle dinamik türlerinin farklılaşması türemiş sınıf nesnesinin adresinin taban sınıf türünden bir gösterici ya da 
	referansa atanmasıyla olur. Aşağıdaki gibi bir türetme şeması olsun:

	A
	B
	C

	C c;
	A *pA;

	pA = &c;

	Burada pA göstericisinin statik türü A'dır. Ancak dinamik trü C'dir. Çünkü pA aslında bütünü C olan bir nesnenin A parçasını göstermektedir. Örneğin:

	B *pB;

	pB = &c;

	Burada pB'nin statik türü B'dir. Ancak dinamik türü C'dir. Aynı durum referanslar için de söz konusudur. Örneğin:

	C c;
	B &b = c;

	Burada b referansının statik türü B, dinamik türü C'dir. Örneğin:

	C *pC;

	pC = &c;

	Burada pC göstericisinin statik türü ile dinamik türü aynıdır ve C'dir. 

	Statik tür değişmez. Ancak dinamik tür değişebilir. Örneğin:

	A
	B
	C

	C c;
	B b;
	A a;
	A *pA;

	pA = &c;		// pA'nın statik türü A, dinamik türü C
	//...
	pA = &b;		// pA'nın statik türü A, dinamik türü B
	//...
	pA = &a;		// pA'nın statik türü A, dinamik türü A

	Örneğin:

	void foo(A &r)
	{
		//...
	}
	//...
	C c;
	B b;
	A a;

	foo(c);			// r referansının dinamik türü A
	foo(b);			// r referansının dinamik türü A
	foo(a);			// r referansının dinamik türü A

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli (polymophic) mekanizma şöyledir: Bir sınıf türünden gösterici ya da referans ile o sınıfın bir üye fonksiyonu çağrılmış olsun. Bu üye fonksiyon 
	isim araması kuralına göre gösterici ya da referansın statik türüne ilişkin sınıfta aranır (tabii o sınıfta bulunamazsa taban sınıflara da bakılır). Sonra bulunan 
	fonksiyonun sanal olup olmadığına bakılır. Eğer bulunan fonksiyon sanal değilse bulunan fonksiyon çağrılır. Eğer bulunan fonksiyon sanal ise o fonksiyonun 
	çağrılmasında kullanılan gösterici ya da referansın dinamik türüne ilişkin override edilmiş sanal fonksiyon çağrılır. Eğer gösterici ya da referansın dinamik türüne 
	ilişkin sınıfta ilgili sanal fonksiyon override edilmemişse yukarıya doğru o sanal fonksiyonun override edilmiş olduğu ilk taban sınıfın sanal fonksiyonu çağrılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo();
	virtual void bar();
};

class B : public A {
public:
	void foo();		// override işlemi değil
	void bar();		// override işlemi
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void B::bar()
{
	cout << "B::bar" << endl;
}

int main()
{
	B b;
	A *pA;

	pA = &b;

	pA->foo();		// A::foo() çağrılır, çünkü foo sanal değil
	pA->bar();		// B::bar çağrlır, çünkü bar sanal

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansın dinamik türüne ilişkin sınıfta fonksiyon override edilmemiştir. Bu durumda yukarıya doğru fonksiyonun override edildiği ilk taban sınıfın
	fonksiyonu çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

int main()
{
	C c;

	A &r = c;		// referansın statik türü A, dinamik türü C

	r.foo();		// B::foo çağrılır, çünkü C'de foo override edilmemiş	

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte test fonksiyonun parametresi taban sınıf türünden bir göstericidir. Bu test fonksiyonu türemiş sınıf türünden nesnelerin adresleriyle çağrılmıştır.
	Çokbiçimli mekanizma gereği dinamik türe ilişkin sınıfların override edilmiş üye fonksiyonlarının çağrıldığına dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
public:
	void foo();
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void C::foo()
{
	cout << "C::foo" << endl;
}

void test(A *pA)
{
	pA->foo();
}

int main()
{
	A a;
	B b;
	C c;

	test(&a);
	test(&b);
	test(&c);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli teknikte ideal olarak kod üzerinde değişiklikler yapılmaz. Her zaman ekleme yöntemi uygulanır. Daha önceki kod sağlam çalışıyorsa ve ekleme işleminden 
	sonra problem oluşmuşsa problem eklenen kısımla ilgilidir. Bu durumda eklenen kısmın test edilmesi yeterlidir. Halbuki biz kodda bir değişiklik yaparsak
	tüm kodun yeniden test edilmesi gerekir. Çünkü yaptığımız değişiklik başka yerleri bozuyor olabilir. 

	İşte çokbiçimlilik türden bağımsız kod parçalarının ekleme yöntemiyle oluşturulması için kullanılan bir tekniktir. NYPT'de değişebilecek öğelere doğrudan değil 
	çokbiçimli olarak erişilir. Örneğin top ile oynanan bir oyun programında top değişebilir bir öğe olsun. Bu durumda biz top kavramını bir sınıfla temsil ederiz. 
	Oyunda "patlak topu", "zıplayan topu", "normal topu" bu top sınıfından türetme yaparak oluştururuz. Oyunda top genel bir kavram olarak Top sınıfıyla temsil edilir. 
	Ancak topun çeşiti eylemleri sanal fonksiyonlarla ifade edilir. Böylece bu top değiştiğinde artık kodda değişiklik yapılması gerekmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayantop gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("patlak");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda oyuna yeni bir top cinsi ekleyecek olalım. Tek yapacağımız şey aslında bu yeni top sınıfını Top sınıfından türetmek ve sanal fonksiyonları 
	bu sınıfta override etmektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

class HafifTop : public Top {
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayan top gidiyor" << endl;
}

void HafifTop::git()
{
	cout << "Hafif top gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else if (isim == "hafif")
		top = new HafifTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("hafif");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki birssanal fonksiyon bazen programcılar tarafından "override" edildi sanılmakta ancak programcı bu işlem sırasında parametre 
	türlerini yanlış yazdığı için aslında override işlemi yapılamamaktadır. İşte bu tür hataları engellemek için C++11 ile birlikte C++'a override anahtar sözcüğü 
	de eklenmiştir. Fonksiyonun parametre parantezinden sonra "override" anahtar sözcüğü yazılırsa bu durumda eğer taban sınıfta override edilecek bir sanal fonksiyon yoksa
	derleme aşamasında error oluşmaktadır. Örneğin:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(int a) override;		/* derleme sırasına error oluşacak */
		//...
	};

	Yine C++11 ile birlikte zaten Java ve C# gibi dillerde olan "final override" kavramı da C++'a eklenmiştir. Eğer fonksiyonun parametre parantezinden sonra "final" 
	anahtar sözcüğü getirilirse bu durumda o sanal fonksiyon artık daha fazla override edilemez. Edilmeye çalışılırsa derleme zamanı sırasında error oluşur. Örneğim:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(long a) override final;		// foo artık daha fazla override edilemez!
		//...
	};

	class C : public B {
	public:
		void foo(long a);		// compile time error!
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli uygulamalarda çoğu kez taban sınıf aslında türden bağımsız işlem yapmak için bulundurulmaktadır. Aslında o taban sınıf türünden bir nesne yaratılmamaktadır.
	İşte bu tür durumlarda taban sınıftaki sanal fonksiyonların boşuna gövdeye sahip olması gerekmez. Eğer taban sınıftaki sanal fonksiyonun gövdeye sahip olması istenmiyorsa
	fonksiyonun parametre parantezinden sonra "= 0" sentaksı kullanılır. Yalnızca sanal fonksiyonlarda bu sentaks kullanılabilmektedir. Bu tür fonksiyonlara C++'ta
	"saf sanal fonksiyonlar (pure virtual functions)" denilmektedir. En az bir saf sanal fonksiyona sahip olan sınıfa da "soyut sınıf (abstract class)" denir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class A {
public:
	virtual void foo() = 0;		// pure virtual
	//...
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

class C : public A {
public:
	void foo()
	{
		cout << "C::foo" << endl;
	}
};

class D : public A {
public:
	void foo()
	{
		cout << "D::foo" << endl;
	}
};

int main()
{
	vector<A *> v{new B(), new C(), new D(), new C()};

	for (A *pa : v)
		pa->foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Soyut sınıflar türünden nesneler yaratılmaz. Ancak göstericiler ve referanslar tanımlanabilir. Örneğin A bir soyut sınıf olsun B de bu soyut sınıftan türetilmiş
	soyut olmayan (somut (concrete) de diyebiliriz) bir sınıf olsun:

	A a;	// error! soyut sınıf türündne nesne yaratılamaz.
	A *pa;	// geçerli, soyut sınıf türünden gösterici yaratılabilir. 

	Bir soyut sııf türündne gösterici ya da referansa tipik olarak o sınıftan türetilmiş bir sınıf nesnesinin adresi atanabilir. Örneğin:

	A *pa;
	B b;

	pa = &b;		// geçerli
	A &r = b;		// geçerli

	pa->foo();		// B::foo çağrılır
	r.foo();		// B::foo çağrılır

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir soyut sınıftan türetme yapıldığında türemiş sınıfın taban soyut sınıftaki tüm saf sanal fonksiyonları override etmesi beklenir. Eğer türemiş sınıf taban 
	sınıftaki tüm saf sanal fonksiyonları override etmezse bu durumda tüemiş sınıf da soyut olur, türemiş sınıf türünden de nesneler yaratılmaz. Örneğin:

	class A {
	public:
		//...
		virtual void foo() = 0;
		virtual void bar() = 0;
		//...
	};

	Burada A soyut (abstract) bir sınıftır. A sınıfı türünden nesneler yaratamayız. Şimdi A sınıfından B sınıfını türetelim:

	class B : public A {
	public:
		//...
		void foo() override		// yalnızca foo override edilmiş olsun
		{
			//...
		}
		//...
	};

	Burada B sınıfında yalnızca foo override edildiği için B sınıfı da soyuttur ve B sınıfı türünden de nesneler yaratamayız. 

	A soyut sınıfındaki saf sanal fonksiyonların bir bölümü ondan türetilmiş B sınıfında override edilmiş olsun. Bu duurmda B de soyut bir sınıftır. Ancak geri 
	kalan saf sanal fonksiyonlar B'den türetilmiş  C override edilirse C artık soyut olmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo() = 0;
	virtual void bar() = 0;
	//...
};

class B : public A {
public:
	void foo() override 
	{
		//...
	}
	//...
};

class C : public B {
public:
	void bar() override
	{
		//...
	}
};

int main()
{
	A *pa = new C();		// geçerli, C soyut değil somut'
	//...

	delete pa;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Saf sanal fonksiyonların kullanılmasına yönelik Tetris örneğinin basit biimi aşağıdaki gibi olabilir. Bu örnekte taban Shape sınıfı "şekil kavramını"
	temsil etmektedir. Bu Shape sınıfından sınıflar türetilmiş ve sanal fonksiyonlar override edilmiştir. Shape sınıfı türünden hiçbir nesne yaratılmayacağı için
	Shape sınıfı soyut bir sınıf yapılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <cstdlib>
#include <Windows.h>
#include <conio.h>

using namespace std;

class Shape {
public:
	virtual void move_down() = 0;
	virtual void move_left() = 0;
	virtual void move_right() = 0;
	virtual void rotate() = 0;

private:
	//...
};

class BarShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class TShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class ZShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class SquareShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class LShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class Tetris {
public:
	Tetris();
	void run();
private:
	Shape *get_random_shape();		// static olabilir ancak henüz görmedik
	//...
};

void BarShape::move_down()
{
	cout << "Barshape move down" << endl;
}

void BarShape::move_left()
{
	cout << "Barshape move left" << endl;
}

void BarShape::move_right()
{
	cout << "Barshape move right" << endl;
}

void BarShape::rotate()
{
	cout << "Barshape rotate" << endl;
}

void TShape::move_down()
{
	cout << "TShape move down" << endl;
}

void TShape::move_left()
{
	cout << "TShape move left" << endl;
}

void TShape::move_right()
{
	cout << "TShape move right" << endl;
}

void TShape::rotate()
{
	cout << "TShape rotate" << endl;
}

void ZShape::move_down()
{
	cout << "ZShape move down" << endl;
}

void ZShape::move_left()
{
	cout << "ZShape move left" << endl;
}

void ZShape::move_right()
{
	cout << "ZShape move right" << endl;
}

void ZShape::rotate()
{
	cout << "ZShape rotate" << endl;
}

void SquareShape::move_down()
{
	cout << "SquareShape move down" << endl;
}

void SquareShape::move_left()
{
	cout << "SquareShape move left" << endl;
}

void SquareShape::move_right()
{
	cout << "SquareShape move right" << endl;
}

void SquareShape::rotate()
{
	cout << "SquareShape rotate" << endl;
}

void LShape::move_down()
{
	cout << "LShape move down" << endl;
}

void LShape::move_left()
{
	cout << "LShape move left" << endl;
}

void LShape::move_right()
{
	cout << "LShape move right" << endl;
}

void LShape::rotate()
{
	cout << "LShape rotate" << endl;
}

Tetris::Tetris()
{
	srand(time(NULL));
}

void Tetris::run()
{
	Shape *pshape;
	int ch;

	for (;;) {
		pshape = get_random_shape();
		for (int i = 0; i < 25; ++i) {
			pshape->move_down();
			Sleep(500);
			if (_kbhit()) {
				ch = _getch();
				switch (ch) {
					case 'a':				// move left
						pshape->move_left();
						break;
					case 'd':				// move right
						pshape->move_right();	
						break;
					case 's':				// rotate
						pshape->rotate();
						break;
					case 'q':
						goto EXIT;
				}
			}

		}
	}
EXIT:
	;
}

Shape *Tetris::get_random_shape()
{
	Shape *pshape;

	switch (rand() % 5) {
		case 0:
			pshape = new TShape();
			break;
		case 1:
			pshape = new ZShape();
			break;
		case 2:
			pshape = new SquareShape();
			break;
		case 3:
			pshape = new LShape();
			break;
		case 4:
			pshape = new BarShape();
			break;
	}

	return pshape;
}

int main()
{
	Tetris tetris;

	tetris.run();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında sınıf (class) ve üye fonksiyon (member function), veri elemanı (data member) gibi kavramlar yapay kavramlardır. İşlemcilerimiz prosedürel teknikte
	kodladığımız programları çalıştırmaya uygundur. Nesne yönelimli teknik yapay bir kavramdır. Gerçek makinenin çalışması C'deki gibidir, C++'taki gibi değildir. 
	Bu nedenle C++'ta bir sınıf aslında derlendiğinde C gibi kodlar üretilmektedir. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi de makinede 
	mümkün değildir. Dolayısıyla sınıf faaliyet alanı da yapay bir kavramdır. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi aslında derleyicilerin
	üye fonksiyonlara gizlice geçirdikleri bir parametre yoluyla sağlanmaktadır. Derleyiciler üye fonksiyonun çağrılmasında kullanılan nesnenin adresini üye fonksiyona
	gizlice (genellikle birinci parametre olarak) geçirirler ve veri elemanına erişmeyi bu gizli parametre yoluyla yaparlar. Bu gizlice geçirilen parametreye 
	this göstericisi denilmektedir. Aşağıdaki gibi bir sınıf söz konusu olsun:


	class Sample {
	public:
		void set_val(int val);
		void disp();
	private:
		int m_val;
	};

	void Sample::set_val(int val)
	{
		m_val = val;
	}

	void Sample::disp()
	{
		cout << m_val << endl;
	}

	int main()
	{
		Sample s;

		s.set_val(10);
		s.disp();

		return 0;
	}

	Aslında bu kod derlendiğinde makine kodları incelendiği zaman bu kodların tamamen C gibi ve aşağıdakine benzer olduğu görülür:

	#include <stdio.h>

	using namespace std;

	struct Sample {
		int m_val;
	};

	void Sample_set_val(struct Sample *this, int val)
	{
		this->m_val = val;
	}

	void Sample_disp(struct Sample *this)
	{
		printf("%d\n", this->m_val);
	}

	int main()
	{
		struct Sample s;

		Sample_set_val(&s, 10);
		Sample_disp(&s);

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    this göstericisi üye fonksiyonlara gizlice geçiriliyor olsa da üye fonksiyon içerisinde açıkça kullanılabilir. this hangi sınıfın üye fonksiyonu içerisinde kullanılıyorsa
	o sınıf türünden bir gösterici belirtmektedir. Bir üye fonksiyon içerisinde sınıfın m_val gibi bir veri elamanına doğrudan m_val ismiyle erişmekle this->m_val 
	biçiminde erişmek arasında hiçbir performans farklılığı yoktur. Zaten programcı bu elemana m_val biçiminde eriştiğinde aslında derleyici ürettiği kodda buna
	this->m_val gibi erişmektedir. 

	foo gibi bir üye fonksiyon içerisinde bar üye fonksiyonun aşağıdaki gibi çağrıldığını düşünelim:

	void Sample::foo()
	{
		//...
		bar();
		//...
	}

	Aslında bu çağrı tamamen this->bar() gibi yapılmaktadır. Yani bar fonksiyonuna geçirelecek this göstericisi aslında foo fonksiyonun this göstericisidir. 

	void Sample::foo()
	{
		//...
		this->bar();		// bar(); ile eşdeğer
		//...
	}

	const bir üye fonksiyon aslında ona gizlice geçirilen this göstericisinin const olduğu (gösterdiği yer const olduğu) bir fonksiyondur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir üye fonksiyonun geri dönüş değeri kendi sınıfı türünden bir sol taraf değeri referansı olur. Fonksion da *this ifadesiyle geri döner. Bu durumda *this
	üye fonksiyonun çağrıldığı nesnedir. Dolayısıyla fonksiyon da aslında bize bu nesneyi geri döndürür. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample &foo();
	void bar();
	//...
};

Sample &Sample::foo()
{
	cout << "Sample::foo" << endl;

	return *this;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;

	s.foo().bar();		// s.foo(); s.bar(); ile eşdeğer etki

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir sınıfın üye fonksiyonları ve veri elemanları static olabilir ya da olmayabilir. Biz şimdiye kadar hep static olmayan (nonstatic)  üye fonksiyonlarını
	ve veri elemanlarını kullandık. Gerçekten de static üye fonksiyonlar ve veri elemanları seyrek kullanıldığı için "üye fonksiyon" denildiğinde özellikle static'lik 
	belirtilmediyse static olmayan üye fonksiyon anlaşılmalıdır. Benzer biçimde "veri elemanı" denildiğinde de özellikle static'lik belirtilmediyse static olmayan
	veri elemanı anlaşılmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı global fonksiyonlar belli bir konuyla ilgili iş yapıyor olabilirler. Bu durumda o global fonskiyonların o konuya ilişkin sınıf ile ilişkilendirilmeleri 
	iyi bir tekniktir. Örneğin bir yılın artık yıl olup olmadığını belirleyen isleap isimli bir fonksiyon mantıksal ilgi nedeniyle Date sınıfın static bir üye fonksiyonu
	yapılmalıdır. static üye fonksiyonlar sınıfın veri elemanlarını kullanamazlar. Eğer sınıfın veri elemanlarını kullanmayan fonksiyonlar sınıfın static olmayan 
	bir üye fonksiyonu olarak yazılırsa bu durumda gereksiz biçimde onun bir nesne ile çağrılma zorunluluğu ortaya çıkar. Halbuki bu fonksiyonlar sınıfın veri elemanlarını zaten kullanmamaktadır.
	İşte bir üye fonksiyon static yapılırsa artık o üye fonksiyon bir nesne olmadan sınıf ismi ve :: operatörüyle (tabii public bölümdeyse) çağrılabilmektedir. Bir üye fonksyonu static yapabilmek için
	sınıf bildirimi içerisindeki prototipin önüne "static" anahtar sözcüğü getirilir. static anahtar sözcüğü tanımlamada kullanılamaz. Örneğin:

	class Sample {
	public:
		void foo();
		static void bar();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	int main()
	{
		Sample::foo();		// nesne olmadan sınıf ismiyle çağırabiliriz

		return 0;
	}

	static üye fonksiyonlar nesne ile çağrılmadığı için onlara this parametresi geçirilmez. Dolayısıyla da static üye fonksiyonlar sınıfın static olmayan veri elemanlarını
	ve static olmayan üye fonksiyonlarını kullanamazlar. 

	Aslında static üye fonksiyonlar bir nesne, gösterici ya da referans yoluyla da çağrılabilirler. Bu çağrımada derleyici static üye fonksiyonun çağrıldığı 
	nesnenin türüne bakar ve üye fonksiyonun o sınıf ismi ile çağrıldığını kabul eder. Tabii bu durumda yine this göstericisi fonksiyona geçirilmemektedir. Örneğin:

	Sample::foo();

	Sample s;
	s.foo();		// tamamen Sample::foo() ile eşdeğer

	Sınıfın static üye fonksiyonları const üye fonksiyonlar yapılamaz. Zaten static üye fonksiyonlar sınııfn static olmayan veri elemanlarına erişemedikleri için 
	bunların const yapılmasının bir anlamı da yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }

	static bool isleap(int year);
	static Date today();
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date date;

	cout << (Date::isleap(2000) ? "Artik" : "Artik degil") << endl;
	date = Date::today();

	date.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların static veri elamanlarının toplamda tek bir kopyası bulunur. static veri elemanları sınıf türünden nesnelerin içerisinde yer kaplamazlar. Yani nesnelerin
	bir parçası değillerdir. O sınıf türünden nesne yaratılsa da yaratılmasa da her zaman bu tek kopya yaratılmış bir biçimde bulunur. Sınıf içerisinde bu static
	veri elemanı kullanıldığında her zaman o tek olan kopya kullanılıyor durumdadır. Aslında sınıfın veri veri elemanaları pekala global bir nesne olabilecek durumdadır. 
	Ancak programcı onu global yapmak yerine sınıf ile mantıksal ilişkisi nedeniyle sınıfın içerisine yerleştirmiştir ve static yapmıştır. 

	Sınıfların static veri elemanları ismiyle de kullanılabilmektedir. Çünkü onlar aslında hiçbir nesnenin parçası değildir. 
	Veri elemanını static yapmak için sınıf bildiriminde static anahtar sözcüğü kullanılır. Ancak static veri elemanlarının sınıfın dışında  bir tanımlamasının 
	yapılması gerekir. Bu tanımlama sınıf ismi ve çözünürlük operatörü ile yapılır. Tanımlama sırasında static anahtar sözcüğü kullanılmaz ancak ilkdeğer verilebilir. Örneğin:

	class Sample {
	public:
		//...
		int m_a;
		int m_b;
		static int m_c;
	};

	int Sample::m_c;

	int main()
	{
		Sample::m_c = 10;

		cout << Sample::m_c << endl;

		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

struct Sample {
	//...
	int m_a;
	int m_b;
	static int m_c;
};

int Sample::m_c;

int main()
{
	Sample::m_c = 10;

	cout << Sample::m_c << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın static veri elemanlarının da private bölüme konularak onlara public getter/setter fonksiyonlar ile erişilmesi veri gizlemesi (data hidening) bakımından
	tavsiye edilmektedir. Tabii bu durumda getter/setter fonksiyonların static üye fonksiyon olması anlamlıdır. static üye fonksiyonlar sınıfın diğer static üye 
	fonksiyonlarını doğrudan çağırabilir ve sınıfın static veri elemanlarını doğrudan kullanabilir. Ancak static olmayan elemanlarını kullanamaz. 

	Sınıfın static veri elemanlarına yine o sınıf türünden nesne, gösterici ya da referans yoluyla erişebiliriz. Bu durumda erişimde kullanılan nesne aslında yalnızca
	sınıfın türünü belirtmektedir. Bu biçimde erişimler yanlış anlaşılmaya yol açabilmektedir. Bu nedenle static veri elemanlarına sınıf ismiyle erişmeye gayret etmelisiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a = 0, int b = 0) : m_a(a), m_b(b)
	{
		++m_count;
	}
	static int count() { return m_count; }
	static void set_count(int count) { m_count = count; }

private:
	int m_a;
	int m_b;
	static int m_count;
};

int Sample::m_count;

int main()
{
	Sample s;
	Sample k;
	Sample z;

	cout << Sample::count() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz sınıfın üye fonksiyonlarına ve veri elemanlarına "sınıfın elemanları" diyelim. static olmayan üye fonksiyonlarına ve static olmayan veri elemanlarına da "static olmayan elemanları"
	diyelim. Bu durumda static üye fonksiyonlar sınıfın yalnızca static elemanlarını kullanabilirler. Ancak static olmayan üye fonksiyonlar sınıfın hem static olmayan
	elemanlarını hem de static olan elemanlarını kullanabilirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }
	
	const char *get_day_name() const;

	static bool isleap(int year);
	static Date today();
	
private:
	static long get_total_days(int day, int month, int year);
	static const char *get_day_name(int day, int month, int year);
private:
	int m_day;
	int m_month;
	int m_year;

	static int ms_montab[12];
	static const char *ms_monnames[7];
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

int Date::ms_montab[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const char *Date::ms_monnames[7] = {"Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi"};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << '-' << get_day_name() << endl;
}

const char *Date::get_day_name() const
{
	return get_day_name(m_day, m_month, m_year);
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

long Date::get_total_days(int day, int month, int year)
{
	long total = 0;

	for (int i = 1900; i < year; ++i)
		total += isleap(i) ? 366 : 365;

	ms_montab[1] = isleap(year) ? 29 : 28;
	for (int i = 0; i < month - 1; ++i)
		total += ms_montab[i];

	total += day;

	return total;
}

const char *Date::get_day_name(int day, int month, int year)
{
	auto tdays = get_total_days(day, month, year);

	return ms_monnames[tdays % 7];
}

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date d(23, 4, 1920);

	d.disp();

	cout << d.get_day_name() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Global bir fonksiyon ya da başka bir sınıfın üye fonksiyonu bir sınıfın arkadaş fonksiyonu yapılabilir. Bu durumda arkadaş yapılan fonksiyon özel bir 
	erişim ayrıcalığına sahip olur. Arkadaş fonksiyonlar içeriisinde arkadaş olunan sınıf türünden bir nesne, gösterici ya da referans yoluyla o sınıfın tüm 
	bölümlerine erişebiliriz. friend bildirimi sınıfın herhangi bir bölümünde yapılabilir. Hangi bölümünde yapıldığının bir önemi yoktur. 

	Global bir fonksiyon friend yapıldığında friend bildirimi için o global fonksiyonun prototipinin ya da tanımlamasının görülmüş olması gerekmez. Ancak 
	friend bildirimi dışarısı için bir prototip bildirimi olarak kullanılamaz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend void foo();
private:
	int m_a;
};

void foo()
{
	Sample s;

	s.m_a = 10;					// geçerli çünkü foo friend

	cout << s.m_a << endl;		// geçerli çünkü foo friend
}

int main()
{
	foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Arkadaş sınıf bir sınıfın tüm üye fonksiyonlarının arkadaş olduğu anlamına gelmektedir. Bir sınıfı arkadaş yapabilmek için "friend class" bildirimi gerekir. 
	Örneğin:

	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend class Mample;
	};

	Burada Mample sınıfı Sample sınıfının arkadaş sınıfıdır. Yani Mample içerisindeki foo ve bar üye fonksiyonlarında Sample türünden bir nesne, gösterici ya da referenas 
	yoluyla Sample sınıfının her bölümüne erişilebilir. Arkadaş bildiriminde arkadaş olarak bildirilen sınıf daha sonra bildirilebilir. Örneğin:

	class Sample {
		//...
		friend class Mample;
	};
	
	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	Tabii bunun için friend anahtar sözüğünün yanında class anahtar sçzcüğünün bulundurulması gerekir. Eğer arkadaş sınıf daha yukaıda bildiriliyorsa bu durumda 
	class anahtar sözcüğünün bulundurulması gerekmez. Örneğin:

		class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend Mample;		// geçerli
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend class Mample;
private:
	int m_a;
};

class Mample {
public:
	void foo()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}

	void bar()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}
};

int main()
{
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bir bağlı liste bir sınıfla temsil edilmiş olsun. Onun düğümleri de bir sınıfla temsil edilmiş olabilir. Bu durumda bağlı listenin bu düğümlerin
	private elemanlarına erişmesi gerekebilmektedir. İşte Node sınıfında bağlı sınıfını arkadaş sınıf yapabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// linkedlistint.hpp 

#ifndef LINKEDLISTINT_HPP
#define LINKEDLISTINT_HPP

#include <cstddef>

class Node {
public:
	Node() = default;
	Node(int val) : m_val(val), m_next(nullptr)
	{}
	friend class LinkedListInt;
private:
	Node *m_next;
	int m_val;
};

class LinkedListInt {
public:
	LinkedListInt() : m_head(nullptr), m_tail(nullptr), m_size(0)
	{}
	~LinkedListInt();
	Node *add_tail(int val);
	void disp() const;
	std::size_t size() const { return m_size; }
private:
	Node *m_head;
	Node *m_tail;
	std::size_t m_size;
};

#endif

// linkedlistint.cpp

#include <iostream>
#include "linkedlistInt.hpp"

using namespace std;

Node *LinkedListInt::add_tail(int val)
{
	Node *new_node = new Node(val);

	if (m_head != nullptr)
		m_tail->m_next = new_node;
	else
		m_head = new_node;

	m_tail = new_node;

	++m_size;

	return new_node;
}

void LinkedListInt::disp() const
{
	for (Node *node = m_head; node != nullptr; node = node->m_next)
		cout << node->m_val << " ";
	cout << endl << m_size << " element listed" << endl;
}

LinkedListInt::~LinkedListInt()
{
	Node *node, *temp;

	node = m_head;
	while (node != nullptr) {
		temp = node->m_next;
		delete node;
		node = temp;
	}
}

// app.cpp

#include <iostream>
#include "LinkedListInt.hpp"

using namespace std;

int main()
{
	LinkedListInt lli;

	for (int i = 0; i < 100; ++i)
		lli.add_tail(i);

	lli.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesinde dinamik olarak büyütülen dizileri temsil eden vector isimli şablon bir sınıf bulunmaktadır. vector sınıfının bildirimi 
	<vector> dosyası içerisinde yapılmıştır. Bir vector tutacağı elemanların türü belirtilerek sınıfın default yapıcı fonksiyonuyla yaratılabilir. Örneğin:

	vector<int> v;

	Vekötörün sonına eleman eklemek için push_back isimli üye fonksiyon kullanılmaktadır. vector sınıfının [] operatör fonksiyonu yazılmış durumadır. (Operatör
	fonksiyonları sonraki konuda ele alınacaktır.) Biz bu sayede vektörün herhangi bir indeksli elemanına erişebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i)
		v.push_back(i);

	for (int i = 0; i < 100; ++i)
		cout << v[i] << " ";
	cout << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'a eklenen "initializer list yapıcı fonksiyonu yoluyla" biz kme pareantezleri içerisinde elemanları belirterek de bir vektörü 
	oluşturabiliriz. Vektörler aralık tabalı for döngüsüyle dolaşılabilirler. Bu durumda döngünün her yünelenmesinde biz vektörün yeni bir elemanını 
	elde etmiş oluruz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii aralık tabanlı for döngsünde dönü değişkeni bir referans olarak alınabilir burada auto belirleyicisi de kullanılabilir.     
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int &x : v)
		x += 10;
	
	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir vektörde vektöre yerleştirilmiş eleman sayısına "size", vektör için tahsis edilmiş eleman sayısına ise "capacity" denilmektedir. Normalde capacity değeri
	size değerinden büyüktür. Ancak vektöre eleman eklendikçe size değeri artar. size değeri capacity değerine geldiğinde vektör capacity değerini yeniden tahsisat 
	yaparak büyütür. Capacity değerinin ne kadar büyütüleceği standartlarda belirtilmemiş olsa da tipik olarka eskisinin iki katı kadar büyütme uygulanmaktadır. 

	Vektördeki size değeri size üye fonksiyonu ile capacity değeri capacity üye fonksiyonu ile elde edilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	size ve capacity değerinin artışı aşağıdaki gibi gözlemlenebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i) {
		v.push_back(i);
		cout << "size: " << v.size() << ", capacity: " << v.capacity() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında bir vector belli bir size işin başında belirtilerek de yaratılabilir. Tabii bu durumda burada belirtilen miktarda eleman eğer vektör temel türleri 
	tutuyorsa 0'larla sınıf türlerini tutuyorsa onların default yapıcı fonksiyonlarıyla doldurulacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v(10);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Vektöre eleman insert etme iteratör yoluyla yapılmaktadır. Biz enüz iteratör konusunu bilmiyoruz. Ancak eğer vektörün n'inci indeksine
	bir insert yapacaksanız buna ilişkin iteratörü v.begin() + n ifadesi ile oluşturabilirsiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.insert(v.begin() + 3, 100);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Vektörden eleman silme işlemi de iteratör yoluyla yapılmaktadır. Ancak yukarıda da belirttiğimiz gibi pratik bir yöntem olarak iteratör pozisyonu
	v.begin() + n ifadesi ile oluşturulabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.erase(v.begin() + 3);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector sınıfının clear üye fonksiyonu vektördeki tüm elemanları silmek için kullanılmaktadır. Ancak clear işleminden sonra vektörün size değeri 0 olmasına
	karşın, capacity değeri değiştirilmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.clear();

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir vektörün içinin boş olup olmadığı empty üye fonksiyonu ile anlaşılabilir. Tabii aynıişlem v.size() == 0 ile de yapılabilir. C++11 ile birlikte ayrıca
	vektör sınıfına shrink_to_fit fonksiyonu eklenmiştir. Bu fonksiyon capacity değerini size değerine çekmektedir. Yine C++11 ile birlikte vektör sınıfına
	initializer_list atama operatör fonksiyonu eklenmiştir. Dolayısıyla biz bu sayede küme parantezli bir ifadeyi vektör nesnesine atayabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v = {10, 20, 30};		// C++11 ile birlikte

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii vector sınıfında taşıma yapıcı fonksiyonu ve taşıma operatöçr operatör fonksiyonu olduğu için taşıma işlemleri etkin bir biçimde yapılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

vector<int> foo()
{
	vector<int> v = {1, 2, 3, 4, 5};

	return v;		// taşıma yapıcı fonksiyonu çağrılır
}

int main()
{
	vector<int> v;

	v = foo();		// taşıma operatör fonksiyonu çağrılacak

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii vector sınıfı şablon bir sınıf olduğu için aslında herhangi türden bir nesneyi tutabilir.    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> v = {"ali", "veli", "selami"};

	v.push_back("fatma");

	for (auto s : v)
		cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları (operator ovrloading) C++'ın yanı sıra C#, Swift, Python gibi dillerde de olan bir özelliktir. Operatör fonksiyonları sayesinde sınıf nesneleri
	sanki temel türlerden nesnelermiş gibi +, -, * gibi operatörlerle işleme sokulabilmektedir. Operatör fonksiyonları aslında dile ilave bir işlevsel katmaz. 
	Yalnızca okunabilirlilk sağlamaktadır. 

	Operatör fonksiyonları bir sınıfın static olmayan üye fonksiyonları biçiminde yazılabilir ya da global bir fonksiyon biçiminde yazılabilir. Operatör fonksiyonlarının 
	genel biçimi şöyledir:

	<geri dönüş değerini türü> operator <operatör sembolü> ([parametre bildirimi])
	{
		//...
	}

	Operatör fonksiyonları tamamen normal bir fonksiyon gibidir. Bunların tek farkı isimlerinin operator anahtar sözcüğü ve operatör sembolünden oluşmasıdır. 

	Operatör fonksiyonlarının geri dönüş değerleri herhangi bir biçimde olabilir. Ancak operatör fonksiyonlarının parametre sayıları üzerinde kısıt vardır. Şöyle ki:

	- Operatör fonksiyonu iki operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon tek parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon iki parametreye sahip olmak zorundadır. 

	- Operatör fonksiyonu tek operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon sıfır parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon bir parametreye sahip olmak zorundadır. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları olmasaydı biz sınıflar üzerindeki operatörsel işlemleri normal fonksiyonlara yaptırırdık. Örmeğin aynı sınıf üründen iki sınıf nesnesini 
	toplamak için sınıf içerisine add isimli bir static olmayan üye fonksiyon ya da static bir üye fonksiyon yerleştirebilirdik. Gerçekten de örneğin Java'da operatör
	fonksiyonları olmadığı için böyle işlemler üye fonksiyonlarıyla (metotlarla) yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number add(const Number &a) const;
	static Number add(const Number &x, const Number &y);

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
	
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::add(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::add(const Number &x, const Number &y)
{
	Number result;

	result.m_val = x.m_val + y.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a.add(b);	
	c.disp();

	c = Number::add(a, b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşte operatör fonksiyonları aslında yukarıdaki gibi normal fonksiyonlardır. Onların tek farklılıkları isimlerinin operator anahtar sözcüğü ve operatör sembolünden
	oluşmasıdır. Tabii operatör fonksiyonları aslında isimle de çağrılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a + b;	// a.operator +(b)
	c.disp();

	c = a.operator +(b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ derleyicisi bir operatörle karşılaştığında önce operand'ların türlerine bakar. Eğer operand'lar temel türlere ilişkinse işlem öncesi otomatik tür 
	dönüştürmesi yoluyla işlemi yapar. Eğer operand'lardan en az bir tanesi bir sınıf türündense bu işlemi yapabilmek için sınıf içerisinde ve global düzeyde 
	operatör fonksiyonu araştırır. Operatör sembolü @ ile temsil ediliyor olsun:

	1) a @ b gibi bir işlem için derleyici a operand'ının ilişkin olduğu sınıfta a.operator @(b) çağrısına uygun bir @ operatör fonksiyonu araştırır. Aynı zamanda 
	derleyici bu işlemi yapabilecek global düzeyde operator @(a, b) çağrısına uygun bir global operatör fonksiyonu araştırmaktadır. Sınıfın operator @ ve global operator @
	fonksiyonları aday fonksiyonlar olarak seçilir ve "over resolution" işlemine sokulur. 

	2) @a ya da a@ gibi unary bir operatör için derleyici yine sınıfın içerisinde ve global düzeyde operator @ fonksiyonları araştırmaktadır. Sınıfın içerisinde 
	a.operator @() çağrısına uygun ya da global düzeyde operator @(a) çağrısına uygun global operatör fonksiyonlarını aday fonksiyon olarak belirler ve bunları 
	"overload resolution" işlemine sokar.

	Yukarıdaki örnekte:

	c = a + b;

	Burada derleyici bu toplama işlemini yapabilecek Number sınıfında operator + isimli üye fonksiyonu ile global düzeyde operator + isimli global fonksiyonları 
	araştıracaktır. Dolayısıyla derleyici için bu işlem aşağıdakiyle eşdeğer olacaktır:

	c = a.operator +(b);

	C++'ta ".", "::", "?:" ve ".*" operatörlerine ilişkin operatör fonksiyonları zaten hiç yazılamamaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Operatör fonksiyonları kombine edilebilir. Ancak bu duurmda operatör fonksiyonlarının çağrılma sırası operatör nceliklerine göre yapılmaktadır. Operatör
	önceliklerini değiştirmenin bir yolu yoktur. Örneğin:

	result = a + b * c;

	gibi bir işlemde önce b ile c operator * fonksiyonu ile işleme sokulur. Buradan elde edilecek değer a ile toplanır. Yani bu işlemin eşdeğeri şöyledir:

	result = a.operator +(b.operator *(c));

	Örneğin:

	result = a + b + c;

	Bu işlemin de eşdeğeri şöyledir:

	result = a.operator +(b).operator +(c);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator *(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + b * c;		// result = a.operator +(b.operator *(c));
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları anlamlı ve herkes tarafındna tahmin edilebilecek bir işleve sahip olacaksa bulundurulmalıdır. Bazı operatörler varsa onunla ilişkili 
	bazı operatörlerin de sınıfta bulundurulması uygun olur. Örneğin sınıfta '+' operatör fonksiyonu varsa '-' operatör fonksiyonu da sınıfta bulundurulmalıdır.
	'*' operatör fonksiyonu varsa '/' operatör fonksiyonu da sınıfta bulundurulmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + a + a;		
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları da "overload" edilebilirler. Yani farklı parametrik yapılara sahip aynı isimli birden fazla operatör fonksiyonu bir arada bulunabilir. 
	Örneğin iki Number nesnesini toplayan + operatör fonksiyonunun yanı sıra bir Number nesnesi ile bir int değeri toplayan bir + operatör fonksiyonu bir arada 
	bulunabilir. Ancak bazı operatörlerin değişme özelliğinin sağlanması da gerekir. Örneğin bir Number nesnesi ile bir int değeri toplayabiliyorsak, bir int değerle
	bir Number nesnesini de toplayabilmemiz gerekir. Ancak bir int değerle birt Number nesnesini toplayabilen üye operatör fonksiyonu yazmak mümkün değldir. Örneğin:

	int a = 10;
	Number b(20);
	Number result;

	result = a + 10;		// result = a.operator +(10);
	result = 10 + a;		// result = 10.operator +(a); Dikkat! int bir sınıf değil! mümkün değil

	İşte bu tür durumlarda global operatör fonksiyonları ile bu işlemler yapılabilmektedir. C++'ta birkaç operatörün operatör fonksiyonları üye operatör fonksiyonu 
	biçiminde yazılmak zorundadır. Ancak pek çok operatör üye operatör fonksiyonu biçiminde ve global operatör fonksiyonu biçiminde yazılabilmektedir. Bu tür durumlarda
	programcılar genellikle üye operatör fonksiyonu olarak yazabildiklerini üye operatör fonksiyonu olarak, yazamadıklarını da global operatör fonksiyonu olarak 
	yazmalıdırlar.

	Operatör fonksiyonunu global operatör fonksiyonu olarak yazdığımızda artık sınıfın private elemanlarına erişemeyeceğimize dikkat ediniz. Bu durumda mecburen 
	sınıfın getter/setter fonksiyonlarındna faydalanırız. Aslında bu tür fonksiyonların "arkadaş (friend)" yapılması çok karşılaşılan bir durumdur. 

	Tabii aslında bu tür global operatör fonksiyonları bir "sarma (wrapper)" fonksiyon olarak da yazılabilmektedir. Örneğin:

	inline Number operator +(int val, const Number &x)
	{
		return x + val;
	}

	C++'ta dört operatöre ilişkin operatör fonksiyonlarının üye operatör fonksiyonu olarak yazılması zorunlu tutulmuştur. Bunlar "=", "(...)", "[]" ve "->" operatör
	fonksiyonlarıdır. Diğer operatörlerin operatör fonksiyonları üye operatör fonksiyonu ya da global operatör fonksiyonu biçiminde yazılabilirse de programcı 
	mümkün olduğu kadar üye operatör fonksiyonu biçiminde bunları yazmaya çalışmalıdır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	Number operator +(int val) const;
	Number operator -(int val) const;
	Number operator *(int val) const;
	Number operator /(int val) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

Number Number::operator +(int val) const
{
	Number result;

	result.m_val = m_val + val;

	return result;
}

Number Number::operator -(int val) const
{
	Number result;

	result.m_val = m_val - val;

	return result;
}

Number Number::operator *(int val) const
{
	Number result;

	result.m_val = m_val * val;

	return result;
}

Number Number::operator /(int val) const
{
	Number result;

	result.m_val = m_val / val;

	return result;
}

inline Number operator +(int val, const Number &x)
{
	Number result;

	result.set_val(val + x.val());

	return result;		// return x + val;
}

Number operator *(int val, const Number &x)
{
	Number result;

	result.set_val(val * x.val());

	return result;
}

int main()
{
	Number a(1), result;

	result = a + 2;
	result.disp();

	result = 2 + a;
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatör fonksiyonlarının geri dönüş değerleri herhangi bir türden olabilir ancak bunların bool türden olması en uygun durumdur. 
	Karşılaştırma operatör fonksiyonlarının mümkünse hepsi yazılmalıdır. Yani örneğin eğer biz < operatör fonksiyonunu yazmış isek > opertör fonksiyonunu da
	yazmalıyız. == operatör fonksiyonunu yazmış isek != operatör fonksiyonunun da yazılması uygun olur. Yani mümkünse <, >, <=, >=, ==, != operatör fonksiyonlarının
	hepsinin yazılması tavsiye edilmektedir. Tabii bazı sınıflar için örneğin == ve != operatörleri anlamlı iken <, >, <=, >= operatör fonksiyonlaırnın bir anlamı olmayabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    ++ ve -- operatörlerine ilişkin operatör fonksiyonları da yazılabilir. Ancak bu operatörler hem önek (prefix) hem de sonek (postfix) kullanılabildiğinden dolayı
	bunların yazımları için bazı noktalaa dikkat edilmesi gerekir. Birinci nokta önek ++ operatörünün C++'ta nesnenin kendisine ilişkin sol taraf değeri üretmesidir. 
	Bu özelliğin sağlanabilmesi için bu operatör fonksiyonu yazılırken fonksiyonun geri dönüş değerinin türü aynı sınıf türünden bir referans olmalı ve fonksiyon 
	*this ifadesi ile geri dönmelidir. C++'ta bu operatörlerin sonek versiyonları nesne belirtmez bu nedenle bu operatörlerin seonek versiyonları yazılırken geri dönüş değerinin 
	türü kendi sınıfı türünden const bir nesne (referans değil) olmalıdır. Sonek versiyonların nesnenin değerini önce yerel bir nesnede saklayıp artırım ya da eksiltimi nesne üzerinde yapması 
	ve sonra da bu yerel nesneyle geri dönmesi uygun olur. Bu operatörlere ilişkin operatör fonksiyonlarının yazılması sırasında bunların önek ve sonek biçimleri 
	ayrı ayrı yazılır. Sonek biçiminde aslında programcının kullanmayacağı "dummy" bir int parametre bulundurulur. Örneğin:

	class Complex {
		//...
		Complex &operator ++();				// önek
		const Complex operator ++(int);		// sonek
		Complex &operator --();				// önek
		const Complex operator --(int);		// sonek
	};

	Aşağıdak Complex sayı sınıfında bu operatörlerin kullanılmasına ilişkin bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP_
#define COMPLEX_HPP_

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0);
	Complex operator +(const Complex &r) const;
	Complex operator +(double real) const;
	Complex operator -(const Complex &r) const;
	Complex operator *(const Complex &r) const;

	Complex &operator ++();			// prefix
	const Complex operator ++(int);	// postfix

	Complex &operator --();			// prefix
	const Complex operator --(int);	// postfix

	void disp() const;
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

Complex::Complex(double real, double imag)
{
	m_real = real;
	m_imag = imag;
}

void Complex::disp() const
{
	cout << m_real << '+' << m_imag << 'i' << endl;
}

Complex Complex::operator +(const Complex &r) const
{
	Complex result;

	result.m_real = m_real + r.m_real;
	result.m_imag = m_imag + r.m_imag;

	return result;
}

Complex Complex::operator +(double real) const
{
	Complex result;

	result.m_real = m_real + real;
	result.m_imag = m_imag;

	return result;
}

Complex Complex::operator -(const Complex &r) const
{
	Complex result;

	result.m_real = m_real - r.m_real;
	result.m_imag = m_imag - r.m_imag;

	return result;
}

Complex Complex::operator *(const Complex &r) const
{
	Complex result;

	result.m_real = m_real * r.m_real - m_imag * r.m_imag;
	result.m_imag = m_real * r.m_imag + m_imag * r.m_real;

	return result;
}

Complex &Complex::operator ++()
{
	++m_real;

	return *this;
}

const Complex Complex::operator ++(int)	
{
	Complex z = *this;

	++m_real;

	return z;
}

Complex &Complex::operator --()
{
	--m_real;

	return *this;
}

const Complex Complex::operator --(int)
{
	Complex z = *this;

	--m_real;

	return z;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{
	Complex z{3, 2}, k{1, 2};

	z.disp();

	auto result = z-- + k;

	z.disp();
	result.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesini [] operatörüyle kullanabilmek için o sınıfta bir [] operatör fonksiyonunun bulunuyor olması gerekir. a bir sınıf nesnesi olmak 
	üzere a[n] işleminin eşdeğeri a.operator[](n) biçimindedir. Gerçekten de standrat kütüphanedeki vector gibi string gibi sınıflar bu operatör fonksiyonuna sahiptir. 
	[] opeartör fonksiyonu üye operatör fonksiyonu olarak yazılmak zorundadır. 
	
	[] operatörüne ilişkin operatör fonksiyonları yazılırken fonksiyonun bir referansa geri dönmesi gerekir. Çünkü köşeli parantez 
	ifadesine aynı zamanda atama da yapılabilmektedir. const nesnelerle köşeli parantez operatörünün kullanılabilmesi için bu operatör fonksiyonun 
	const bir biçimi de bulundurulmalıdır. Tabii bu biçimin const bir referansa geri dönmesi uygun olur.

	Aşağıdaki örnekte Date sınıfının day, month, year bileşenleri [] operatör fonksiyonu ile elde edilmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date(int day, int month, int year) : m_day(day), m_month(month), m_year(year)
	{}
	void disp() const;
	int &operator[] (size_t index);
	const int &operator[] (size_t index) const;
private:
	int m_day;
	int m_month;
	int m_year;
};

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int &Date::operator[] (size_t index)
{
	if (index == 0)
		return m_day;
	if (index == 1)
		return m_month;
	if (index == 2)
		return m_year;

	throw invalid_argument("index out of range");
}

const int &Date::operator[] (size_t index) const
{
	if (index == 0)
		return m_day;
	if (index == 1)
		return m_month;
	if (index == 2)
		return m_year;

	throw invalid_argument("index out of range");
}

int main()
{
	Date d(12, 11, 2007);

	cout << d[0] << endl;
	cout << d[1] << endl;
	cout << d[2] << endl;

	d[0] = 13;
	d[1] = 6;
	d[2] = 2022;

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    En önemli operatör fonksiyonlarından biri de "atama operatör" fonksiyonudur. Bir atama işleminde sol taraftaki nesne bir sınıf türündense bu duurmda atama 
	işlemi sınıfın "atama operatör fonksiyonu" denilen bir fonksiyon çağrılarak yapılır. Yani a bir sınıf nesnesi olmak üzere:

	a = b;

	işleminin derleyici için eşdeğeri şöyledir:

	a.operator=(b);

	Atama operatör fonksiyonları "overload" edilebilir. Ancak bir sınıfın kendi sınıfı türünden bir nesneyi atamakta kullanılan operatör fonksiyonuna "kopya atama
	operatör fonksiyonu" denilmektedir. Kopya atama operatör fonksiyonu sınıfın ismi T olmak üzere aşağıdkai parametrelere sahip atama operatör fonksiyonlarıdır:

	T &operator =(const T&r);
	T &operator =(T &r);
	T &operator =(volatile T &r);
	T &operator =(const volatile T &r);
	T &operator =(T r);

	Eğer programcı sınıf için kopya atama operatör fonksiyonu yazmamışsa bu fonksiyon derleyici tarafından public inline biçiminde aşağıdaki parametrik 
	yapıyla yazılmaktadır:

	T &operator =(const T&r);

	Bu konuda bazı ayrıntılar da vardır. Derleyicinin yazdığı kopya atama operatör fonksiyonu sınıfın karşılıklı veri elemanlarını biribrine atar (memberwise copy).
	Tabii bir sınıfın gösterici veri elemanı gibi veri elemanları varsa programcı yine kopya atama operatör fonksiyonunu içerik kopyalaması yapacak biçimde kendisi 
	yazmalıdır. 

	Bie sınıf için ne zaman kopya yapıcı fonksiyonu gerekiyorsa o sınıf için aynı zamanda kopya atama operatör fonksiyonu da gerekmektedir. 

	C++11 ile birlikte kopya atama operatör fonksiyonu için bazı ayrıntılar da dile eklenmiştir. Örneğin bir sınıf taşıma yapıcı fonksiyonuna sahipse artık derleyici 
	o sınıf için kopya atama operatör fonksiyonunu "deleted" kabul etmektedir. Yazi yazmamaktadır. Ancak kopya atama operatör fonksiyonu "defaulted" yapılarak 
	derleyici tarafoan yazılması zorlanabilir. Örneğin:

	class T {
	public:
		//...
		T & operator =(const T&) = default;
	};

	Sınıfın kopya atama operatör fonksiyonu tıpkı kopya yapıcı fonksiyonunda olduğu gibi içerik kopyalaması yapmalıdır. 

	C++'ta atama operatöründen elde edilen değer bir nesne belirtmektedir. Ancak C'de nesne belirtmemektedir. Örneğin aşağıdaki ifade C'de geçersiz olduğu halde 
	C++'ta geçerlidir:

	(a = b) = c;		// C'de geçersiz! C++'ta geçerli

	İşte atama operatöründen elde edilen ürünün nesnebelirtmesi için atama operatör fonksiyonunun kendi sınıfı türünden bir referansa geri dönmesi ve return ifadesinde
	de *this bulunması gerekmektedir. 

	Ayrıca a = a gibi bir işlem anlamsız olsa da buna önlem almak gerekebilir. 


	Aşağıdaki örnekte kendi yazdığımız String sınıfına atama operatör fonksiyonlarını ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	String &operator =(const String &r);
	String &operator =(const char *str);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s("ankara");
	String k;

	k = s;		// k.operator =(s);

	s.disp();
	k.disp();

	k = "istanbul";		// s.operator =("istanbul");
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Geçici bir sınıf nesnesinin sağ taraf değeri belirttiğini anımsayınız. Bu durumda biz bir sınıf nesnesine bir geçici nesne atarsak o geçici nesnedeki kaynakları
	etkin biçimde taşıyabiliriz. İşte bu işlem "taşıma atama operatör fonksiyonu (move assignment operator)" ile yapılmaktadır. Örneğin:

	String s;

	s = String("Ankara");

	Burada eğer taşıma atama peratör olmasaydı (C++11 öncesinde durum böyleydi) önce String nesnesi yaratılıp sonra o nesne kopya atama operatör fonksiyonu yoluyla
	s'ye atanacaktı. Halbuki C++'ta bu atama sırasında yine içerik kopyalaması yapılacaktı. Bu atamada aşağıdaki parametrik yapıya sahip taşıma atama operatör fonksiyonu çalıştırılabilmektedir:

	String &operator =(String &&s);

	Genel olarak bir sınıf taşıma yapıcı fonksiyonuna sahipse taşıma atama operatör fonksiyonuna da sahip olmalıdır. Tabii taşıma atama operatör fonksiyonu bir nesnesine aynı sınıf 
	türünden sağ taraf değeri ile atama yapıldığı diğer durumlarda da çağrılmaktadır. Örneğin:

	String foo()
	{
		//...
	}
	//...
	String s;

	s = foo();		// taşıma atama operatör fonksiyonu çağrılır

	Burada yine taşıma atama operatör fonksiyonu çağrılacaktır.

	Aşağıdaki örnekte daha önce yazdığımız String sınıfınına taşıma operatör atama fonksiyonunu ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s;

	s = String("istanbul");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda vector sınıfına benzeyen ama şablon olmayıp yalnızca int türden değerleri tutan örnek bir sınıf oluşturulmuştur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// intvector.hpp

#ifndef INTVECTOR_HPP_
#define INTVECTOR_HPP_

#include <cstddef>

const int DEF_CAPACITY = 4;

class IntVector {
public:
	IntVector();
	IntVector(std::size_t size);
	IntVector(const IntVector &r);
	IntVector(IntVector &&r);
	~IntVector();

	std::size_t size() const { return m_size; }
	std::size_t capacity() const { return m_capacity; }

	void push_back(int val);
	inline int &operator[](std::size_t index);
	inline const int &operator[](std::size_t index) const;

	IntVector &operator =(const IntVector &r);
	IntVector &operator =(IntVector &&r);

	void disp() const;
private:
	int *m_pv;
	std::size_t m_size;
	std::size_t m_capacity;
};

int &IntVector::operator[](std::size_t index)
{
	return m_pv[index];
}

const int &IntVector::operator[](std::size_t index) const
{
	return m_pv[index];
}

#endif

// intvector.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector::IntVector()
{
	m_capacity = DEF_CAPACITY;
	m_size = 0;
	m_pv = new int[DEF_CAPACITY];
}

IntVector::IntVector(std::size_t size)
{
	m_capacity = size;
	m_size = size;
	m_pv = new int[size];
}

IntVector::IntVector(const IntVector &r)
{
	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_capacity = m_size = r.m_size;
}


IntVector::IntVector(IntVector &&r)
{
	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;
}

IntVector::~IntVector()
{
	delete[] m_pv;
}

void IntVector::push_back(int val)
{
	int *pv_new;

	if (m_size == m_capacity) {
		pv_new = new int[m_capacity * 2];
		for (size_t i = 0; i < m_size; ++i)
			pv_new[i] = m_pv[i];
		m_capacity *= 2;
		delete[] m_pv;
		m_pv = pv_new;
	}
	m_pv[m_size++] = val;
}

IntVector &IntVector::operator =(const IntVector &r)
{
	if (this == &r)
		return *this;

	delete[] m_pv;

	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_size = r.m_size;
	m_capacity = r.m_capacity;

	return *this;
}

IntVector &IntVector::operator =(IntVector &&r)
{
	delete[] m_pv;

	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;

	return *this;
}

void IntVector::disp() const
{
	for (size_t i = 0; i < m_size; ++i)
		cout << m_pv[i] << " ";

	cout << endl;
}

// app.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector foo()
{
	IntVector v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	return v;
}

int main()
{	
	IntVector k;

	k = foo();

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Operatör fonksiyonları üye operatör fonksiyonları ya da global operatör fonksiyonları biçiminde yazılabilmektedir. Ancak =, (), ->, [] operatör fonksiyonlarının
	üye operatör fonksiyonu olarak yazılması zorunlu tutulmuştur. Global operatör fonksiyonları özellikle sol tarafı temel türlere ilişkin sağ tarafı bir sınıf türünden 
	olan operatör fonksiyonlarının yazılması için gerekmektedir. Örneğin Number sınıfında bir number nesnesi ile bir int nesneyi toplayan operatör fonksiyonu olsun:

	Number x(10), result;

	result = x + 20;

	Eğer x + 20 gibi bir işlem geçerliyse 20 + x gibi bir işlemin de geçerli olması beklenir. Ancak bu işlemi yapabilecek bir üye operatör fonksiyonu yazılamamaktadır. 
	O halde bu operatör fonksiyonu ancak global operatör fonksiyonu olarak yazılabilir. Genel eğilim operatör fonksiyonlarının mümkün olduğunca üye operatör fonksiyonu 
	olarak yazılmasıdır. Ancak global operatör fonksiyonu gerektiğinde buna benzer olanların da global operatör fonksiyonu olarak yazılması daha güzel bi görüntü 
	vermektedir. Global operatör fonksiyonları sınıfın dışındaki fonksiyonlar olduğu için bunların sınıfın private bölümüne erişebilmesi friend yapılması yaygın 
	bir tekniktir. Hatta bir operatör fonksiyonunun diğer bir operatör fonksiyonu çağırarak yazılması da sık uygulanan bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP_
#define COMPLEX_HPP_

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0);
	Complex operator +(const Complex &r) const;
	Complex operator -(const Complex &r) const;
	Complex operator *(const Complex &r) const;

	Complex &operator ++();			// prefix
	const Complex operator ++(int);	// postfix

	Complex &operator --();			// prefix
	const Complex operator --(int);	// postfix

	void disp() const;


	friend Complex operator +(const Complex &r, double real);

private:
	double m_real;
	double m_imag;
};

Complex operator +(double real, const Complex &r);


#endif

// complex.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

Complex::Complex(double real, double imag)
{
	m_real = real;
	m_imag = imag;
}

void Complex::disp() const
{
	cout << m_real << '+' << m_imag << 'i' << endl;
}

Complex Complex::operator +(const Complex &r) const
{
	Complex result;

	result.m_real = m_real + r.m_real;
	result.m_imag = m_imag + r.m_imag;

	return result;
}

Complex operator +(const Complex &r, double real)
{
	Complex result;

	result.m_real = r.m_real + real;
	result.m_imag = r.m_imag;

	return result;
}

Complex operator +(double real, const Complex &r)
{
	return r + real;
}

Complex Complex::operator -(const Complex &r) const
{
	Complex result;

	result.m_real = m_real - r.m_real;
	result.m_imag = m_imag - r.m_imag;

	return result;
}

Complex Complex::operator *(const Complex &r) const
{
	Complex result;

	result.m_real = m_real * r.m_real - m_imag * r.m_imag;
	result.m_imag = m_real * r.m_imag + m_imag * r.m_real;

	return result;
}

Complex &Complex::operator ++()
{
	++m_real;

	return *this;
}

const Complex Complex::operator ++(int)	
{
	Complex z = *this;

	++m_real;

	return z;
}

Complex &Complex::operator --()
{
	--m_real;

	return *this;
}

const Complex Complex::operator --(int)
{
	Complex z = *this;

	--m_real;

	return z;
}

// app.cpp


#include <iostream>
#include "complex.hpp"

int main()
{
	Complex x(3, 2), result;

	result = x + 3;

	result.disp();

	result = 3 + x;

	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz başından beri ekrana (yani stdout dosyasına) birşeyler yazmak için cout değişkenini, klavyeden (yani stdin dosyasından) bir şeyler okuyabilmek için
	cin nesnesin kullandık. Pekiyi bu bu değişkenler nedir? İşte aslında cout ostream denilen bir sınıf türünden, cin ise istream denilen bir sınıf türündne global 
	nesnelerdir. ostream sınıfı basic_ostream şablon sınıfının char açılımıdır. Benzer biçimde istream sınıfı da aslında basic_istream şablon sınıfının char için 
	açılımıdır. Yani ostream ve istream aslında typedef isimleridir. Biz şablon sınıfları izleyen konularda göreceğiz. Bu nedenle bu sınıfların şablonluk özelliği 
	üzerinde durmayacağız. 

	C++'ın iostream sınıfları şablonluk özelliğini söz konusu etmezsek aşağıdaki biçimde bir türetme şemasına sahiptir. 

              ios_base 
			     |
				 |
                ios
			   /    \
              /      \       
          istream  ostream
	        \        /
	         \      /  
		      \    /
               \  /
			 iostream

	Buradan da görüldüğü gibi iostream sınıfı istream ve ostream sınıfından çoklu türetilmiştir. istream ve ostream sınıflarının ortak elemanları basic_ios 
	sınıfından türetilmiş durumdadır. basic_ios sınıfı da ios_base sınıfındn türetilmiştir. ostream sınıfının bir grup overload edilmiş << operatör fonksiyonu, 
	istream sınıfının da overload edilmiş bir grup >> operatör fonksiyonu bulunmaktadır. cout nesnesi ostream sınıfı türünden olduğna göre viz bu nesneyle 
	yalnızca << operatör fonksiyonlarını, cin nesnesi de istream sınıfı türünden olduğuna göre biz bu nesneyle yalnızca >> ıperatör fonksiyonlarını kullanabiliriz. 
	Şablonluk özelliği bir yana bırakılırsa bu sınıfların aşağıdaki gibi bir yapıya sahip olduğu söylenebilir:

	class ostream : public basic_ios {
	public:
		ostream &operator <<(int a);
		ostream &operator <<(long a);
		ostream &operator <<(double a);
		ostream &operator <<(char a);
		//...
	};

	class istream : public basic_ios {
	public:
		istream &operator >>(int &a);
		istream &operator >>(long &a);
		istream &operator >>(double &a);
		istream &operator >>(char &a);
		//...
	};

	Şimdi cout nesnesinin aşağıdaki gibi kullanıldığını düşünelim:

	cout << a << ", " << b << "\n";

	Bunun eşdeğeri şöyledir:

	cout.operator <<(a).operator <<(", ").operator <<(b).operator <<("\n");

	Bu operatör fonksiyonlarının nesnenin kendisine geri döndüğüne dikkat ediniz. Böylece örneğin cout.operator <<(a) gibi bir çağrıdan cout nesnesinin yine 
	kendisi elde edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda ostream ve istream sınıflarınımn nasıl yazılmış olacbileceğine ilişkin bir örnek verilmiştir. Bu örneğin amacı ostream ve istream sınıflarının
	orijinalini yazmak değildir. Yalnızca ostream ve istream sınıfının nasıl yazılmış olabileceğine ilişkin bir ipucu vermektisr. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>
#include <string>

class ostream {
public:
	ostream &operator <<(int a);
	ostream &operator <<(long a);
	ostream &operator <<(double a);
	ostream &operator <<(char a);
	ostream &operator <<(const char *str);
	ostream &operator <<(std::string &s);
	ostream &operator <<(ostream &(&f)(ostream &));
};

ostream &ostream::operator <<(int a)
{
	std::printf("%d", a);

	return *this;
}

ostream &ostream::operator <<(long a)
{
	std::printf("%ld", a);

	return *this;
}

ostream &ostream::operator <<(double a)
{
	std::printf("%f", a);

	return *this;
}

ostream &ostream::operator <<(char a)
{
	std::printf("%c", a);

	return *this;
}

ostream &ostream::operator <<(const char *str)
{
	std::printf("%s", str);

	return *this;
}

ostream &ostream::operator <<(std::string &s)
{
	std::printf("%s", s.c_str());

	return *this;
}

ostream &ostream::operator <<(ostream &(&f)(ostream &))
{
	return f(*this);
}

ostream &endl(ostream &os)
{
	os << '\n';

	return os;
}

class istream {
public:
	istream &operator >>(int &a);
	istream &operator >>(long &a);
	istream &operator >>(double &a);
	//...
};

istream &istream::operator >>(int &a)
{
	scanf("%d", &a);

	return *this;
}

istream &istream::operator >>(long &a)
{
	scanf("%ld", &a);

	return *this;
}

istream &istream::operator >>(double &a)
{
	scanf("%lf", &a);

	return *this;
}

ostream cout;
istream cin;

int main()
{	
	int a;
	double b;

	cin >> a >> b;

	cout << "a = " << a << ", b = " << b << endl;
	cout << "this is a test" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar bir sınıf yazdığımızda o sınıfın içerisindeki bilgileri ekrana (stdout dosyasına) yazdırmak için sınıfta disp isimli fonksiyonlar 
	bulundurduk. Aslında C++'ta sınıf nesnesinin içerisindeki bilgilerin ekrana yazdırılması cout yoluyla yapılmalıdır. Yani cout nesnesi ile biz nasıl 
	int, long gibi temel türlere ilişkin bilgileri yazdırabiliyorsak kendi sınıfımıza ilişkin bilgileri yazdırabilmeliyiz. 

	Kendi sınıflarımıza ilişkin nesneleri ekrana (stdout dosyasına) yazdırabilmemiz mecburen global bir operatör fonksiyonu yazmamız gerekir. Örneğin:

	Sample s;

	cout << s;		// cout.operator(s)

	Burada biz ostream sınıfının içerisine fonksiyonumuzu yerleştiremeyeceğimize göre mesburen bu işlemi yapan bir global operatör fonksiyonu yazmalıyız. 
	Yazacağımız global operatör fonksiyonunun birinci parametresi ostream & türünden olmalıdır. İkinci parametresi ise kendi sınıfımız türünden const bir referans
	olabilir. Kombine edilebilirliği sağlamak için bu operatör fonksiyonun çağırısından bizim yine ostream nesnesinin kendisini elde etmemiz gerekir. Bu durumda 
	fonksiyonun geri dönüş değeri ostream & olmalıdır. Tabii bu global operatör fonksiyonun friend yapılması uygun olur. Özetle Smaple sınıfı için yazılacak 
	<< operatör fonksiyonu aşağıdaki gibi olmalıdır:

	class Sample {
		friend ostream &operator <<(ostream &os, const Sample &s);
		//...
	};

	ostream &operator <<(ostream &os, const Sample &s)
	{
		//...

		return os;
	}

	Aşağıda Complex sınıfı için bu operatör fonksiyonun yazımını görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z(3, 2);

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de String sınıfımız için bu operatör fonksiyonunu yazalım.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>
#include <ostream>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor
	~String();

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	friend std::ostream &operator <<(std::ostream &os, const String &r);
	
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

String::~String()
{
	delete[] m_str;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

ostream &operator <<(ostream &os, const String &r)
{
	os << r.m_str;

	return os;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s{"ankara"};

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Kendi sınıflarımızı cin ile okumasını yapmak çoğu kez mümkün olmaz. Çünkü sınıf nesneleri bileşik türlerdir. Bunların basit bir biçimde klavyeden (stdin dosyasından)
	mümkün olmayabilir. Ancak biz yine de burada Sample sınıfı için bunun nasıl yapılacağının ipucunu vermek istiyoruz.

	class Sample {
		friend istream &operator >>(istream &is, Sample &r);
		//...
	};

	istream &operator >>(istream &is, Sample &r)
	{
		//...

		return is;
	}

	Aşağıda Complex sınıfı için bir örnek verilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>
#include <istream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
	friend std::istream &operator >>(std::istream &is, Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

istream &operator >>(istream &is, Complex &r)
{
	is >> r.m_real >> r.m_imag;

	return is;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z;

	cout << "Bir karmaşık sayıyı gercek ve sanal kisimlarini belirterek giriniz:";
	cin >> z;

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bir sınıf nesnesi sanki bir fonksiyonmuş gibi fonksiyon çağırma operatörüyle kullanılabilir. Bunun için sınıfın fonksiyon çağırma operatör fonksiyonun
	yazılmış olması gerekir. a bir sınıf türünden nesne olmak üzere:

	a(...)

	ifadesinin eşdeğeri:

	a.operator()(...)

	biçimindedir. Bir sınıf nesnesinin bir fonksiyon gibi kullanılmasına İngilizce "function object" ya da kısaca "functor" denilmektedir. C++'ın standart kütüphanesinde
	bir fonksiyon isteyen şablon sınıflar bu biçimde functor nesnelerini de kabul ederler. Sınıflar durumsal bilgileri tutabildikleri için yetenekli fonksiyonların yazılmasına
	izin vermektedir. Fonksiyon çağırma operatör fonksiyonu üye operatör fonksiyonu olarak yazılmak zorundadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// app.cpp

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(const char *str) : m_str(str)
	{}
	void operator()(int a, int b) const;
private:
	string m_str;
};

void Sample::operator()(int a, int b) const
{
	cout << m_str << ": " << a << ", " << b << endl;
}

int main()
{
	Sample s("test");

	s(10, 20);		// s.operator()(10, 20)

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bir gösterici gibi davranan sınıflara "akıllı gösterici (smart pointer)" sınıfları denilmektedir. C++11 ile birlikte C++'a unique_ptr gibi, shared_ptr 
	gibi smart pointer sınıfları eklenmiştir. Bir sınıfın bir gösterici gibi davranmasının bazı faydaları söz konusu olabilir. Ancak en önemli fayda otomatik boşaltımın
	sağlanmasıdır. Programcı smart pointer sınıfı için bir nesneyi dinamik olarak tahsis eder. Ancak bunun delete edilmesi sınıfın yıkıcı fonksiyonu yoluyla otomatik 
	yapılır. Tabii standart kütüphanedeki unique_ptr gibi shared_ptr gibi sınıflar şablon olarak yazılmıştır. 

	* operatörü bir sol taraf değeri ürettiğine göre bu operatöre ilişkin operatör fonksiyonunun bir referansa geri dönmesi uygun olur.

	Aşağıda int türünden bir göstericiyi taklit eden bir smart pointer sınıfı örneği verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class IntPtr {
public:
	IntPtr(int *pi) : m_pi(pi)
	{}
	~IntPtr()
	{
		delete m_pi;
	}
	int &operator *()
	{
		return *m_pi;
	}
	const int &operator *() const
	{
		return *m_pi;
	}
	int *release()
	{
		auto temp = m_pi;
		m_pi = nullptr;

		return  temp;
	}
	void reset(int *pi)
	{
		delete m_pi;

		m_pi = pi;
	}
private:
	int *m_pi;
};


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    -> operatör fonksiyonu bir sınıf türünden gçstriciyi taklit eden sınıflar için kullanılmaktadır. -> operatör fonksiyonu üye fonksiyon biçiminde yazılmak zorundadır. 
	-> operatör fonksiyonu bir sol taraf değeri ile değil bizzat sınıf türünden bir adresle geri dönmelidir. Çünkü s bir smart pointer nesnesi olmak üzere:

	s->a

	gibi bir işlemin C++ operatör fonksiyonu eşdeğeri aslında şöyledir:

	s.operator->()->a 

	Aşağıda string sınıfı türünden göstericiyi temsil eden örnek bir smart pointer sınıfı verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class StringPtr {
public:
	StringPtr (string *ps) : m_ps(ps)
	{}
	~StringPtr()
	{
		delete m_ps;
	}
	string &operator *() const
	{
		return *m_ps;
	}
	string *operator ->() const
	{
		return m_ps;
	}
private:
	string *m_ps;
};

int main()
{
	StringPtr ss(new string("ankara"));
	string s;

	cout << *ss << endl;

	s = (*ss).substr(0, 3);
	cout << s << endl;

	s = ss->substr(0, 3);		// s = ss.operator->()->substr(0, 3)
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte şablon tabanlı unique_ptr ismiyle genel bir smart pointer sınıfı standart kütüphaneye eklenmiştir. unique_ptr sınıfı (ismi üzerinde) 
	bir nesneyi gösteren tek bir smart pointer nesnesinin olmasını hedefleyen bir sınıftır. uniqe_ptr bir göstericiyi taklit eder. Ancak o göstericinin gösterdiği 
	yeri gösteren başka bir	uniqe_ptr nesnesinin bulunamayacağını da garanti etmektedir. Başka bir deyişle hiçbir zaman iki unique_ptr nesnesi aslında aynı dinamik alanı gösteremez. 

	uniqe_ptr nesnesi dinamik tahsis edilmiş bir nesnenin adresiyle yaratılmalıdır. Örneğin:

	unique_ptr<int> pi(new int);
	unique_ptr<string> ps(new string("ankara"));

	unique_ptr sınıfının yapıcı fonksiyonu "explicit" olduğu için (explicit yapıcı fonksiyonlar ileride ele elınacaktır) biz nesneyi '=' ile llkdeğer vererek yaratamayız. 
	Örneğin:

	unique_ptr<int> pi = new int;		// error!
	unique_ptr<int> pi(new int);		// geçerli
	unique_ptr<int> pi{new int};		// geçerli

	unique_ptr sınıfının * ve -> operatörleri overload edilmiştir. Örneğin:

	unique_ptr<string> ps(new string("ankara"));
	string result;

	cout << *ps << endl;

	result = ps->substr(0, 3);
	cout << result;

	Sınıfın yıkıcı fonksiyonu tabii dinamik alanı delete etmektedir. Sınıfın kopya yapıcı fonksiyonu ve kopya operatör fonksiyonu "deleted" biçimdedir. Yani aşağıdaki 
	gibi biz unique_ptr nesnesinin kopyasını çıkartamayız:

	unique_ptr<int> p1(new int);		// geçerli
	unique_ptr<int> p2(p1);				// error!

	p2 = p1;							// error!

	Sınıfın release isimli üye fonksiyonu sınıfın tuttuğu adresini geri dönüş değeri olarak verir. Ancak sınıfın içerisindeki göstericiye null adres atar. Yani release
	işleminden sonra artık sınıf o dinamik nesneyi göstermez hale gelr. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.release();				// us artık dinamik nesneyi göstermiyor, s artık dinamik nesneyi gösteriyor

		cout << *s << endl;	

		delete s;						// delete etmek bizim sorumluluğumuzda

		return 0;
	}

	sınıfın reset üye fonksiyonu bizden yeni bir nesneyi parametre olarak alır. Eskisini delete eder. Artık nesne yeni dinamik nesneyi gösterir duruma gelir. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
	
		us.reset(new string("izmir"));

		cout << *us << endl;

		return 0;
	}

	reset fonksiyonuu default argümanla çağırırsak nesnin içerisindeki göstericiye null adres atanır. Tabii yine nesne daha önce gösterdiği dinamik nesneyi delete 
	edecektir. Örneğin:

	unique_ptr<string> us(new string("ankara"));

	us.reset();		// artık us bir nesneyi göstermiyor, eski alan delete edildi

	Nesneyi transfer etmek için release ile reset beraber kullanılmalıdır. Örneğin:

		#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us1(new string("ankara"));
		unique_ptr<string> us2;

		us2.reset(us1.release());		// transfer etmenin normal yöntemi

		cout << *us2 << endl;

		return 0;
	}

	Sınıfın get üye fonksiyonu sınıfın tuttuğu nesne adresini bize verir. get fonksiyonu sahipliği release gibi bırakmamaktadır. Dolayısıyla get kullanırken dikkat ediniz. 
	Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.get();		// us nesnenin adresini tutmaya devam ediyor 

		cout << *us << endl;

		return 0;
	}

	unique_ptr sınıfının kopya yapıcı fonksiyonu yoktur ancak taşıma yapıcı fonksiyonu vardır. Benzer biçimde sınıfın kopya atamam operatör fonksiyonu yoktur, 
	ancak taşıma atama operatör fonksiyonu vardır. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	unique_ptr<string> foo()
	{
		unique_ptr<string> us(new string("ankara"));

		return us;			// geçerli, çünkü sınıfın taşıma yapıcı fonksiyonu vardır
	}

	int main()
	{	
		unique_ptr<string> us(foo());

		cout << *us << endl;		// ankara
	
		us = unique_ptr<string>(new string("izmir"));		// geçerli, sınıfın taşıma atama operatör fonksiyonu var

		cout << *us << endl;		// izmir

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	uniqe_ptr sınıfının "deleter" denilen ikinci bir şablon parametresi daha vardır. Deleter nesneyi yok ederken çağrılacak fonksiyonu belirtir. Bu şablon parametresi
	default durumda delete operatörü ile silme yapan bir sınıfı argüman olarak almıştır. Programcı isterse silme işlemini kendi belirlediği bir fonksiyonla ya
	da bir sınıfla yapabilir. Tabii böyle bir sınıf yazılırken sınıfın fonksiyon çağırma operatör fonksiyonunun yazılmış olması gerekir. Bu konu izleyen bölümde 
	ele alınacaktır. Aşağıda deleter kullanımına ilişkin bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <memory>

using namespace std;

void foo(int *pi)
{
	cout << "foo called" << endl;

	delete pi;
}

int main()
{
	unique_ptr<int, void (*)(int *)> a(new int, foo);

	*a = 10;

	cout << *a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne sanki bir fonksiyonmuş gibi fonksiyon çağırma operatörleriyle çağrılma işlemine sokulabilir. Örneğin:

	Sample s;

	s(...);

	Bu durumda sınıfın "fonksiyon çağırma operatör fonksiyonu" denilen operatör fonksiyonu çalıştırılır. Fonksiyon çağırma operatör fonksiyonun geri dönüş değeri 
	ve parametreleri herhangi türden olabilir. Bu durumda örneğin:

	s(....)

	işleminin eşdeğeri:

	s.operator()(....)

	biçimindedir. 

	Bu biçimdeki bir sınıf nesnesinin sanki bir fonksiyon gibi kullanılmasına "fonksiyon nesneleri (function object)" ya da kısaca "functor" denilmektedir. 
	Fonksiyon nesneleri gerçekte bir fonksiyon değil sınıf olduğu için çağrılar arasında durumsal bilgileri tutabilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(const char *msg) : m_msg(msg)
	{}

	int operator()(int a, int b);
private:
	string m_msg;
};

int Sample::operator()(int a, int b)
{
	cout << m_msg << endl;

	return a + b;
}

int main()
{
	Sample s("this is a test");
	int result;

	result = s(10, 20);		// result s.opereator()(10, 20);
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon nesneleri C++ standart kütüphanesinde algoritmalar tarafından kullanılabilmektedir. Böylece bu algoritmalar durumsal bilgiyi tutabilir duruma 
	gelirler. Örneğin for_each fonksiyonu bir dizilimin her elemanı için bir fonksiyonun çağrılmasını sağlar. Dolayısıyla bir for_each fonksiyonuna çağrılam 
	özelliği olan bir fonksiyon nesnesini verebiliriz. Fonksiyon nesnesi de bu çağrılar arasında durumsal bir bilgi oluşturabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void foo(int a)
{
	cout << a * a << endl;
}

class Sample {
public:
	Sample()
	{
		m_total = 0;
	}

	void operator()(int a)
	{
		m_total += a;
	}
	int total() const { return m_total; }
private:
	int m_total;
};

int main()
{
	vector<int> v{1, 2, 3, 4, 5};
	Sample s;

	for_each(v.begin(), v.end(), foo);
	for_each(v.begin(), v.end(), s);

	cout << s.total() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ve delete operatörlerinde de bizim istediğimiz bir fonksiyonun çağrılmasını sağlayabiliriz. Böylece programcı tahsisat işlemlerinde araya girebilir. Ya da 
	tahsisat işlemlerinin kendi istediği gibi yapılmasını sağlayabilir.

	new operatör fonksiyonun paramtreik yapısı aşağıdaki gibi olmalıdır:

	void *operator new(size_t size);
	void *operator new[](size_t size);

	Fonksiyonun normal ve köşeli parantezli biçimleri olduğunda dikkat ednizi. delete işleminde çağrılacak operator delete fonksiyonun da parametrik 
	yapısı şöyle olmalıdır:

	void operator delete(void *ptr);
	void operator delete[](void *ptr);

	Aslında standart kütüphanede new ve delete işlemleri sırasında çağırlan operator new ve operator delete fonksiyonları bulunmaktadır. Eğer programcı kendisi 
	bu fonksiyonları yazarsa kütüphanedekiler değil de programcının yazdığı fonksiyonlar devreye girer. Eğer programcı bunları yazmasa kütüphanedekiler devreye girer.

	new ve delete operatörlerinin "placement" denilen verisyonları da vardır. placement versiyonlarda new operatörü bir tahsisat yapmaz. Yalnızca programcının verdiği bir adresi
	sınıfın yapıcı fonksiyonunu çağırmak için kullanmaktadır. placement new operatörlerinin ayrı bir gösteri gösterici parametresi daha vardır. Parametrik yapıları şöyledir:

	void *operator new(size_t size, void *ptr);
	void *operator new[](size_t size, void *ptr);

	Placement new operatörü tipik olarak zaten tahsis edilmiş bir alan için sınıfın yapıcı fonksiyonun çağrılması amacıyla kullanılır. Placement new operatörü 
	ile tahsis edilmiş olan alan için delete operatörü çağrılmamlıdır. Çünkü delete operatörü operator delete fonksiyonun çalıştırılmasına yol açar. 
	placement biçime aktarılan adresinin boşaltılması programcının sorumluluğunda olmalıdır Tabii programcı bir sınıf nesnesi söz konusu olduğunda bu nesne için
	yıkıcı fonksiyonun çağrılmasını isteyebilir. Bu durumda yıkıcı fonksiyon açıkça çağrılabilir. Örneğin:

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;s
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *s;
	char buf[sizeof(Sample)];

	s = new (buf)Sample(10, 20);
	cout << s->m_a << ", " << s->m_b << endl;

	s->~Sample();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Mademki aslında new işlemi ile tahsisatlar operator new fonksiyonlarıyla yapılmaktadır. O halde programcı operator new fonksiyonlrını tahsisat fonksiyonları olarak da
	doğrudan çağırabilir. Aynı durum operator delete için de geçerlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = static_cast<int *>(operator new[](sizeof(int) * 10));

	for (int i = 0; i < 10; ++i)
		pi[i] = i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << endl;

	operator delete[](pi);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir sınıf nesnesi için operator new fonksiyonuyla tahsisat yapılmış sonra bu tahsis edilen alan için placement new yoluyla yapıcı 
	fonksiyon çağrılmıştır. Burada yine yıkıcı fonksiyon programcının kendisi tarafından çağrılmaktadır. Tahsisat operator delete fonksiyonuyla free hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl; 
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *ps;

	ps = static_cast<Sample *>(operator new(sizeof Sample));

	ps = new (ps)Sample(10, 20);

	cout << ps->m_a << ", " << ps->m_b << endl;

	ps->~Sample();

	operator delete(ps);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizması (exception handling) özellikle nesne yönelimli programlama dillerinde karşılaşılan bir hata kontrol mekanizmasıdır. C gibi klasik prosedürel 
	dillerde hata kontrolleri programcı açısından yorucu olabilmektedir. Programcı başarısız olabilecek her fonksiyonun başarısını kontrol etmek durumunda kalır.
	İç içe fonksiyonlarda iç bir fonksiyonda hata olşuştuğunda programcının içerden dışa doğru başsrıszlıkla geri dönmesi gerekmeketdir. Bu da programın çok kontrollü bir 
	biçimde oluşturulmasına yol açmaktadır. Bu bakımdan da okunabilirliği azaltmaktadır. İşte exception mekanizması bu srunları çözmek amacıyla bulundurulmaktadır. 
	Exception mekanizmasının sağladığı avantajlar şunlardır:

	- Programın daha az kontrollü bir biçimde oluşturulması sağlamak ve okunabilirliği artırmak.
	- Kod ile hata ele alımını biribirinden ayırmak
	- Tam bir hata kontrolü sağlama
	- İç içe çağırmalarda kolay bir hata kontrolü sağlamak"
	- Bir hata oluştuğunda hatanın nedenini de iletmek.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türü başka bir türe (örneğin temel türlere) dönüştürülmek istenebilir. Bunun için "tür dönüştürme operatör fonksiyonları" kullanılmaktadır. Tür 
	dönüştürme operatör fonksiyonlarının genek biçimi şöyledir:

	[explicit] operator <tür>()

	Tür dönüştürme operatör fonksiyonlarında geri dönüş değerinin türü yazılmaz. Zaten operatör anahtar sözcüğünün yanındaki tür fonksiyonun geri dönüş 
	değerinin türü anlamına gelmektedir. C++11 ile birlikte explicit tür dönüştürme operatörü de dile eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta exception mekanizması için try, throw ve catch anahtar sözcükleri kullanılmaktadır. try anahtar sözcüğünü bir blok izelemek zorundadır. Buna "try bloğu"
	denir. try bloğu tek başına bulunmaz. try bloğunu bir ya da birden fazla catch bloğu izlemek zorundadır. Örneğin:

	try {
		// try bloğu
	}
	catch ([parametre bildirimi]) {
		//...
	}
	catch ([parametre bildiriiş]) {
		//...
	}
	catch ([parametre bildirimi]) {
		//...
	}

	catch parantezlerinin içerisinde "catch parametresi" denilen bir bildirim bulunur. catch parametresi bir tane olmak zorundadır. catch bölümü tek parametreye sahip 
	bir fonksiyon gibi de düşünülebilir. Bir try bloğunun aynı parametrik yapıya sahip olan birden fazla catch bölümü olamaz. Yani catch parametrelerinin 
	türlerinin farklı olması gerekir. catch parametrelerinde yalnıca tür de belirtilebilir. Örneğin:

	int main()
	{
		try {
			//...
		}
		catch (int) {
			//...

		}
		catch (long) {
			//...
		}

		return 0;
	}

	Program akış bakımından try bloğunun içerisindeyken bir exception oluşursa akış bir goto işlemi gibi tek hamlede try bloğunun uygun catch bloğuna 
	aktarılır. O catch bloğu çalıştırılır ve akış catch bloklarının sonundan devam eder. Yani catch blokları exception oluştuğunda hatanın ele alınacağı yerlerdir. 

	Exception'ı asıl oluşturan deyim throw deyimidir. throw deyiminin genel biçimi şöyledir:
	
	throw [ifade];

	Programın akışı throw deyimini gördüğünde akış en son girilen try bloğunun ifadesinin türü ile aynı türden olan catch bloğuna aktarılır. Bu işlem bir goto 
	gibi yapılmaktadır. Artık akış catch bloğundadır. Yalnızca o catch bloğu çalıştırılır. Diğer catch blokları atlanır ve akış catch bloklarının sonundan devam eder.
	throw ifadesinin değeri catch parametresine atanmaktadır. catch parametreleri herhangi bir türden olabilirse de genellikle uygun olan onların bir sınıf türünden 
	olmasıdır. Programın akışı catch bloğuna girdikten sonra hiç exception oluşmayabilir. Bu durumda akış try bloğundan çıkar, catch blokları atlanır ve akış 
	catch bloklarının sonundan devam eder. Yani catch blokları "exception oluşursa" devreye girmek üzere bulundurulur.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void tar(int a)
{
	cout << "tar begins..." << endl;

	if (a < 0)
		throw 10;

	cout << "tar ends..." << endl;
}

void bar(int a)
{
	cout << "bar begins..." << endl;

	tar(a);

	cout << "bar ends..." << endl;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	bar(a);

	cout << "foo ends..." << endl;

}

int main()
{
	cout << "main begins..." << endl;

	try {
		foo(-10);
	}
	catch (int a) {
		cout << "exception caught: int a = " << a << endl;

	}
	catch (long a) {
		cout << "exception caught: long a = " << a << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir exception fırlatıldığında bu exception'ı yakalayacak uygun türde bir catch bloğunun olması gerekir. Eğer böyle bir catch bloğu yoksa ya da programcı 
	bir try bloğu içerisinde bile değilse derleyici tarafından std::terminate isimli fonksiyon çağrılır. Bu terminate fonksiyonu da kendi içerisinde std::abort 
	isimli fonksiyonu çağırmaktadır. İşte abort fonksiyonu da programı sonlandırır. Programcı set_terminate fonksiyonu ile bu tür durumlarda kendi 
	fonksiyonunun çağrılmasını sağlayabilmektedir. 

	std::terminate --> std::abort

	Yani biz oluşan bir exception'ı yakalamazsak programmız sonlandırılmaktadır. 

	throw ifadesiyle catch poarametresinin türünün tam olarak uyuşması gerekir. Overload resolution kuralları burada işletilmemektedir. (Örneğin throw ifadesi 
	char türdense bu int parametreli bir catch bloğu tarafından yakalanamaz.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında throw işlemi temel türlerle değil sınıf türleriyle yapılır. Çünkü sınıflar bilgi tutabilirler. Üstelik de her sınıf farklı tür belirttiğine göre farklı
	sınıf türlerine ilişkin catch blokları bulundurulabilmektedir. Tipik olarak programcı throw işlemini yapmadan önce bir sınıf türünden nesne yaratır. Bu nesnenin
	içini oluşan problemlemli durumları betimleyen bilgilerle doldurur. Sonra bu sınıf ile throw eder. Bunu yakalayn kişi de oluşan exception hakkında bilgileri 
	bu nesneden elde eder. 

	Aşağıdaki örnekte InvalidArgument isimli bir exception sınıfı yazılmıştır. throw işlemş sırasında bu sınıf türünden bir nesne yaratıldığına ve throw işleminin 
	bu nesne yapıldığına dikkat ediniz. Exception yine InvalidArgument parametreli bir catchbloğu tarafından yakalanmıştırç Bu catch bloğu exception nesnesinin içerisindeki 
	bilgileri ekrana (stdout dosyasına) yazdırmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf ile throw işlemi yapılırken önemli bazı noktalar vardır. Bunlar üzerinde duralım:

	1) throw ifadesinin catch parametresine aktarılması doğrudan değil geçici bir nesne yoluyla yapılmaktadır. Örneğin:

	throw ifade;

	Burada önce ifadenin türünden geçici bir nesne yaratılır. Böylece ifade önce geçici bir nesneye atanır. Bu geçici nesnenin yaratılması ve atama işlemi 
	ilkdeğer verme işlemi gibi yapılmaktadır. Derleyicinin yarattığı bu geçici nesneye "exception nesnesi" de denilmektedir. Eğer ifade bir sınıf türündense 
	bu geçici nesne de aynı sınıf türünden olacaktır. Bu durumda geçici nesne için kopya yapıcı fonksiyonu ya da taşıma yapıcı fonksiyonu çağrılacaktır. 
	Tabii daha önce görmüş olduğumuz"copy elision" kuralları burada da geçerli olacaktır. Örneğin:

	ExceptionTest et;
	...

	throw et;

	Buradaki işlem aslında şununla eşdeğerdir:

	ExceptionTest temp = et;		// kopya yapıcı fonksiyon devreye girer.

	Tabii burada NRVO biçiminde zorunlu olmayan bir "copy elision" devreye girebilecektir. Yani aslında derleyici isterse buradaki et nesnesini zaten geçiçi nesne 
	gibi yaratıp hiç kopya yapıcı fonksiyonu çağırmayabilir. Ancak buradaki "copy elision" zorunlu değil isteğe bağlıdır. 

	Eğer throw ifadesi geçici bir sınıf nesnesi ise C++17 ile birlikte "copy elision" işleminin zorunlu olarak yapıldığını anımsayınız. Örneğin:

	throw ExceptionTest();		// C++17 ile birlikte geçici nesne için "copy elision" zorunlu

	Burada artık C++17 ile birliklte derleyici zorunlu bir biçimde ExceptionTest() işlemi ile geçici sınıf nesnesini zaten kendi alanında yaratıp 
	kopya yapıcı fonksiyonu hiç çağırmaz. 

	2) Derleyicinin oluşturduğu geçici nesne catch parametresine atanmaktadır. Bu atama işlemi de fonksiyon çağırma gibi yani ilkdeğer verme biçiminde yapılmaktadır. 
	Örneğin:

	ExceptionTest et;
	...

	throw et;
	//...
	catch (ExceptionTest e) {
		//...
	}

	Burada aslında şu biçimde işlemler yapılmaktadır:

	ExceptionTest temp = et;
	ExceptionTest e = et;

	Burada hiç "copy elision" yapaılmazsa catch parametresi için de kopya yapıcı fonksiyonu çalıştırılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	InvalidArgument ia("Value must not be negative", 1234);

	cout << "foo begins..." << endl;

	if (a < 0)
		throw ia;

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıf nesneleriyle throw işlemi sırasında kopya yapıcı fonksiyonun çalıştırılmasını elimine etmek için throw edilecek nesnenin geçici nesne biçiminde yaratlması 
	yoluna gidilebilir. Bu durumda C++17 ve sonrasında "copy elision" zorunlu olduğu için derleyicinin yaratacağı geçici nesne için kopya yapıcı fonksiyonu çağrılmayacaktır. 
	(Aslında programcının yarattığı geçici nesne doğrudan derleyicinin yaratacağı geçici exception nesnesi gibi olacaktır.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;

}

int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++ programcıları genellikle catch parametresini bir sınıf türünden referans biçiminde alırlar. Bu durumda hiç olmazsa catch parametresi için kopya 
	yapıcı fonksiyonu çalıştırılmaz. C++ standartlarında istisna olarak her ne kadar derleyicinin yarattığı exception nesnesi bir geçici nesne olsa da bunun 
	"sol taraf değeri (lvalue)" belirttiği söylenmiştir. Yani bu durumda catch parametresinin const bir sol taraf değeri referansı olması gerekmez. Ancak tabii
	genel olarak programcılar bu referansı const yaparlar. Burada derleyicinin yaratacağı geçici nesne catch parametresindeki referansın ömrü kadar olacaktır. Yani
	catch bloğu bittiğinde bu geçici nesne yok edilecektir. 

	Genellikle exeption'alrın ele alınması eğer throw ifadesi bir sınıf türndense bu biçimde yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument &ia) {			// bu referans istenirse const olmayabilir
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen programcılar fırlatacakları sınıf nesnesini heap'te new operatörü ile tahsis edip onunla throw işlemi yaparlar. Bu durumda tabii derleyicinin yaratacağı geçici
	exception nesnesi bir gösterici olur ve kopya yapıcı fonksiyonunun çağrılması söz konusu olmaz. Bu durumda catch parametrerisi de aynı sınıf türünden bir gösterici olmalıdır. 
	Ancak bu yakalama biçiminde nesnenin heap'ten delete edilemsi exception'ı yakalayan tarafından yapılmalıdır. Bu biçimde her ne kadar kopya yapıcı fonksiyonları 
	çağrılmıyorsa da new ve delete işlemi de göreli bir zaman kaybına yol açmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw new InvalidArgument("Value must not be negative", 1234);		

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument *pia) {			
		cout << *pia << endl;

		delete pia;				// delete etme sorumluluğu exception'ı yakalayan koda ait
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında programcının throw etmek için kendi exception sınıflarını yazmasına gerek kalmayabilmektedir. Çünkü C++'ın standart kütüphanesinde zaten çeşitli sorunlu durumlar
	için oluşturulmuş olan hazır exception sınıfları bulunmaktadır. Standart kütüphanedeki bu exception sınıflarının hepsi en tepedeki "exception" isimli bir sınıftan 
	türetilmiştir. Bu exception sınıfından temelde iki önemli türemiş kol ayrılmaktadır: logic_error ve runtime_error. logic_error sınıfı programdaki birtakım ön koşulların
	ihlal edilmesi durumu için düşünülmüştür. runtime_error ise programın çalışması sırasında karşılaşılan sorunlar için oluşturulmuştur. Bu logic_error ve runtime_error
	sınıflarından da sınıflar türetilmiştir. Örneğin invalid_argument isimli sınıf tipik olarak programcılar tarafından bir fonksiyonun argümanının yanlış bir biçimde 
	geçilmesi durumu için kullanılmaktadır. out_of_range ise belli bir aralıkta olması gereken değerin o aralıkta olmaması durumlarında kullanılmaktadır. 

	En tepedeki exception sınıfının what isimli sanal const char * türüyle geri dönen (yani bir yazının adresiyle geri dönen) bir üye fonksiyonu vardır. Bu sanal 
	fonksiyon türemiş sınıflarda override edilmiştir. exception sınıfından türetilmiş olan sınıfların hepsinin bir error yazısını parametre olarak alan bir yapıcı 
	fonksiyonu bulunmaktadır. Zaten bu what fonksiyonları da bu yapıcı fonksiyon ile verilen yazıyı bize geri vermektdir. 


	Aşağıdaki örnekte foo fonksiyonunun parametresi negatif olmamalıdır. foo fonksiyonunu yazan kişi işin başında bu parametreyi kontorl etmiş, eğer parametre negatif ise
	invalid_argument nesnesi ile hata mesajını da belirterek thwor işlemi yapmıştır. Fonksiyon çağrısında da exception ele alınmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must not be negative!");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart exception sınıfları aslında C++'ın kendi standart kütüphanesi tarafından da kullanılmaktadır. Örneğin new operatör tahsisatı yapamazsa bad_alloc isimli
	exception sınıfından türetilmiş olan bir sınıf nesnesi ile throw eder. Ya da örneğin string sınıfında string içeriisndeki belli indekste bulunan karaktere erişme 
	işlemi at fonksiyonuyla yapılıyorsa bu at fonksiyonu erişlen indeks geçersizse out_of_range türüyle throw etmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	char ch;

	try {
		ch = s.at(10);			// sınır kontrolü yapılıyor, sınır ihlalinde std::out_of_range ile throw edilmektedir. 
	}
	catch (const out_of_range &oor) {
		cout << oor.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Programcı C++'ın standart excepion sınıflarını hiç kullanmayıp kendi exception sınıflarını da yazabilir. Aslında Qt gibi, MFC gibi pek çok yaygın 
	sınıf kütüphanesi hiç C++'ın standart exception sınıflarını kullanmadan kendi exception sınıflarını tanımlayarak throw işlemini bunlarla yapmaktadır. 

	Tabii programcı C++'ın standart exception sınıflarını kullanırken o sınıflardan türetme yaparak da kendi exception sınıflarını oluşturabilir. Aşağıda örnekte
	logic_error sınıfınından NegativeERror isimli bir exception sınıfı türetilmiş ve kodda bu sınıf kullanılmıştır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

class NegativeError : logic_error {
public:
	NegativeError(const char *msg, int errcode) : logic_error(nullptr), m_msg(msg), m_errcode(errcode)
	{}

	const char *what() const noexcept override
	{
		string err("Error: " + m_msg + ", Error Code: " + to_string(m_errcode));

		return err.c_str();
	}
private:
	string m_msg;
	int m_errcode;

};

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw NegativeError("value must not be negative!", 123);

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const NegativeError &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıfa ve türemiş sınıfa ilişkin catch blokları birlikte bulundurulabilir. Bu durumda türemiş sınıfa ilişkin catch bloğunun taban sınıfa ilişkin catch 
	bloğunun yukarısında konumlandırılması zorunludur. Böylece türemiş sınıf türünden bir nesne ile throw işlemi yapıldığında bu türemiş sınıf parametreli catch bloğu 
	tarafından taban sınıf türünden bir nesne ile throw yapıldığında bu da taban sınıf türünden catch bloğu tarafından yakalanır. Örneğin B sınıfı A sınıfından türetilmiş olsum:

	try {
		//...
	}
	catch (B &r) {
		//...
	}
	catch (A &r) {
		//...
	}

	Burada catch bloklarının sırası böyle olmak zorundadır.Çünkü catch blokları yukarıdan aşağıya sırasıyla taranmaktadır. Eğer taban ısının catch bloğu yukarıya 
	yazılabilseydi tüm exception'ları bu catch bloğu yakalardı.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir kod parçasında çok değişik türlerle throw işlemi yapılabilmektedir. Bu durumda bu türlerin hepsi için catch bloklarının bulundurulması yorucu bir işlemdir. 
	İşte programcılar bu nedenle exception sınıflarını bir taban sınıftan türetilmiş sınıflar biçiminde oluşturlar ve yalnızca taban sınıfa ilişkin catch bloğu ile exception'ı yakalayabilirler. 

	Aşağıda bu duruma bir örnek verilmiştir. Standart exception sınıflarındaki what fonksiyonunun sanal bir fonksiyon olduğunu ve türemiş sınıflarda override 
	edildiğini anımsayınız. Dolayısıyla aslında çağrılan what fonksiyonları çokbiçimli mekanizmadan dolayı exception nesnesine ilişkin sınıfın fonksiyonu olacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int size)
{
	if (size < 0)
		throw invalid_argument("size must not be negative!");
	if (size > 100)
		throw range_error("parameter is too big");
	if (size == 0) 
		throw length_error("size must not be zero");

	cout << "success" << endl;
}

int main()
{
	int size;

	cout << "Bir değer giriniz:";
	cin >> size;

	try {
		foo(size);
	}
	catch (const exception &r) {
		cout << r.what() << endl;		// what sanal bir fonksiyon
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizmasında diğer bir catch bloğu da "ellipsis (...)" parametreli catch bloğudur. Bu catch bloğu tüm exception'ları yakalar (yani "catch all" 
	gibi bir anlamı vardır). Ancak eğer ellipsis parametreli catch bloğu yerleştirileckse catch bloklarının sonuna yerleştirilmelidir. Böylece eğer exception
	daha yukarıdaki catch blokları tarafından yakalanmamışsa kesinlikle ellipsis parametreli catch bloğu tarafından yakalanacaktır. Tabii exception ellipsis 
	parametreli catch bloğu tarafından yakalandığında biz artık excepion nesnesini elde edemeyiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a) 
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must be positive or zero");

	if (a > 100)
		throw range_error("parameter is too big");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(110);
	}
	
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}
	catch (...) {			// catch all
		cout << "another error occurred!" << endl;
	}
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta özel bir throw deyimi de yanında ifade olmadan throw; biçiminde kullanılan throw deyimidir. Buna "rethow" denilmektedir. Bu biçimdeki throw deyimleri ancak
	catch bloğu içerisinde kullanılabilir. Bu biçimdeki throw deyimleri "exception'ın orijinali hangi nesne ile fırlatılmışsa aynı nesne ile onu yeniden fırlatma" anlamına gelmektedir. Örneğin:

	try {
		foo(-10);
	}
	catch (exception &r) {
		//...
		throw;
	}

	Burada exception yakalandığında birtakım işlemler yapılıp rethow uygulanmıştır. Bu rethow işlemi orijinal exception nesnesi ne ise onunla yeniden throw etmek anlamına 
	gelir. Böylece exception bu try bloğunu akş bakımından içeren başka bir catch bloğu tarafındna yakalanabilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Akış bir fonksiyonda ilerlerken bir throw işlemi oluşursa akış tamamen başka bir yere aktarılabilmektedir. Bu durum o fonksiyon içeisinde yapılan tahsisatlar ve
	yaratılan sınıf nesneleri için önemlidir. Çünkü throw işlemi yapılmadan önce çeşitli sınıf nesneleri yaratılmış olabilir. Bu sınıf nesnelerinin yıkıcı fonksiyonlarında 
	çeşitli boşaltım işlemleri yapılmış olabilir. İşte bu olumsuzlukları ortadan kaldırmak için "stack unwinding" denilen bir mekanizma bulunmaktadır. Bir throw işlemi
	gerçekleştiğinde o zaman kadar yaratılmış olan yerel sınıf nesneleri için yıkıcı fonksiyonlar ters sırada çağrılmaktadır. Böylece kaynaklar throw işlemi sırasında 
	başarılı bir biçimde boşaltılmış olur. Tabii bu mekanizmasının derleyici tarafından sağlanmasının birtakım zamansal maaliyetleri vardır. Bu nedenle bazı kritik uygulamalarda 
	programcılar exception mekanizmasını hiç kullanmak istemeyebilirler. 

	throw işlemi oluştuğunda yalnızca try bloğuna girildikten sonra yaratılmı ve yapıcı fonksiyonu tam olarak çalıştırılmış nesneler için yıkıcı fonksiyonlar ters sırada 
	çalıştırılmaktadır. new ile dinamik bir biçimde yaratılmış nesneler yıkıcı fonksiyonlar çalıştırılmaz ve bu nesneler için delete işlemi otomatik olarak uygulanmaz. 
	Bu nesnelerin boşaltımından programcı sorumludur. Bir yapıcı fonksiyonun içerisinde throw işlemi uygulanırsa o zamana kadar yapıcı fonksiyonu tam olarak çalıştırılmış
	nesneler ve alt nesneler için yıkıcı fonksiyon çalıştırılmaktadır.

	Aşağıdaki örnek "stack unwinding" mekanizmasını açıklamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);
	Sample *ps;

	ps = new Sample(60);		// dikkat bellek sızıntısı oluşacak!

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    throw işlemi yapıldığında new ile dinamik biçimde yaratılmış sınıf nesneleri için yıkıcı fonksiyonların çağrılmadığına dikkat ediniz. O halde programcının throw öncesinde
	bu dinamik nesneleri delete etmesi gerekir. Ancak bunun takip edilmesi kolay değildir. İşte bu nedenden dolayı "smart pointer" sınıfları bellek sızıntısını engellemek
	amacıyla kullanılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <memory>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);

	unique_ptr<Sample> ps(new Sample(60));		

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta "exception specification" denilen özellik bir fonksiyonun hangi exception'larla dışarıya throw yapabileceğini belirtmek kullanılıyordu. Örneğin:
	
	void foo(int a) throw(std::invalid_argument)
	{
		//...
	}

	Buarada foo fonksiyonu yalnızca dışarıya invalid_argument sınıfı ile throw yapabilmektedir. Exception specification ilk standartlardan beri bulunan bir özellikse de 
	zamanla "faydasının zararından az olduğu" fikri belirginleşmiştir. Bu nedenle C++11'de "deprecated" yapılmış ve C++17'de de kaldırılmıştır. Exception specification
	Java'da yoğun biçimde kullanılmaktadır. C++11 ile birlikte exception specification özelliğinin çok kısıtlı bir biçimi olan noexcept belirleyicisi dile eklenmiştir. 
	noexcept belirleyicisi "fonksiyonun bir tür ile throw etmeyeceğini" anlatmaktadır. Tabii eğer fonksiyonda bu belirleyici yoksa bu durum "fonksiyonun herhangi bir türle
	throw edebileceği" anlamına gelir. noexcept belirleyicisi fonksiyonun parametre parantezinden sonraya yerleştirilir. Örneğin:

	void foo(int a) noexcept
	{
		//...
	}

	Eğer noexcept belirleyicisi kullanıldığı halde fonksiyonun dışına throw işlemi yapılırsa bu durumda derleyici tarafından std::unexpected isimli fonksiyon çağrılır. 
	Bı fonksiyon kendi içerisinde std::terminate fonksiyonunu bu da std::abort fonksiyonu çağıracaktır:

	unexpected --> terminate --> abort

	Yani kısaca biz noexcept ile verdiğimiz sözü tutmazsak programımız abort ile sonlandırılır. noexcept anahtar sözcüğü hem prototipte hem de
	tanımlama sırasında bulundurulmak zorundadır. Ancak overload bakımından fonksiyonun imzasını değiştirmez.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void bar(int a)
{
	if (a < 0)
		throw invalid_argument("parameter is invalid");
}

void foo(int a) noexcept
{
	bar(a);		// std::unexpected --> std::terminate --> std::abort
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	noexcept belirleyicisinde parantezler içerisinde true ve false sabitleri kullanılabilmektedir. Örneğin:

	void foo() noexcept(true);

	Buradaki true fonksiyonun hiçbir biçimde dışarıya exception fırlatmayacağı anlamına gelir. Zaten default durum da böyledir. Dolayısıyla aşağıdaki iki bildirim 
	eşdeğerdir:

	void foo() noexcept;
	void foo() noexcept(true);

	false ise fonksiyonun dışarıya exception throw edebileceğini belirtir. Dolayısıyla aşağıdaki iki bildirim de eşdeğerdir:

	void foo() noexcept(false);
	void foo();

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında fonksiyon içerisinde bir exception oluşursa akış throw işlemi ile birlikte fonksiyondan aniden çıkacaktır. Bu durumda fonksiyon içerisinde
	o ona kadar yapılmış olan tahsisatlar boşaltılamayabilir. Bu duruma fonksiyonun "exception güvenliliği (exception safety)" denilmektedir. Örneğin:

	try {
		foo();		// foo'da exception oluşursa sızıntı oluşur mu?
	}
	catch (exception &e) {
		//...
	}

	Bir fonksiyon için dört tür exception güvenliği söz konusu olabilir. Bunlar kötüden iyiye doğru aşağıdaki gibi sıralanabilirler:

	1) No Guarantee: Böyle fonksiyonlarda exception oluşursa bellek sızıntısı (memory leak) ya da kaynak sızıntısı (resource leak) oluşabilir. Şüphesiz böyle 
	fonksiyonların yazılmaması gerekir. Tabii bazen böyle fonksiyonların bir biçimde yazılması söz konusu olabilmektedir. Örneğin:

	void foo(int a)
	{
		int *pi, *pc;

		pi = new int[10];
		pc = new char[100];		// Tahsisat yapılamazsa std::bad_alloc excepton'ı oluşabilir

		// ...

		delete[] pi;
	}

	2) Basic Guarantee: Burada ilgili fonksiyon içerisinde bir exception oluştuğunda "bellek sızıntısı" ya da "kaynak sızıntısı" olmayacağı garanti edilir. Ancak
	bu bir üye fonksiyon ise ilgili sınıf nesnesinin durumu programcının fonksiyonu çağırmadan önceki durumuyla aynı olmayabilir. Fakat nesne "geçerli" ve "destruct"
	edilebilir bir biçimde bırakılmıştır. Örneğin:

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		//...
	}

	Burada eğer "basic guarantee" söz konusu ise foo fonksiyonunun içersinde exception oluşursa herhangi bir sızıntı olmamalıdır. Ayrıca buradaki s nesnesi 
	foo fonksiyonu çağrılmadan önceki durumunda olmayabilir ancak "destruct" edilebilir bir durumda olmalıdır. Yani "destructor" çağrıldığında nesne geri bırakım
	işlemlerini yapabilmelidir. Basic guarantee sağlayabilmek için programcı koduna dikkat etmelidir. Bir problem karşısında geri bırakımı yapıp rethow işlemi uygulayabilir. 
	Örneğin:

	void foo()
	{
		// kaynak tahsisatı yapılıyor olsun

		try {
			// exception'a yol açabilecek başka işlemler
		}
		catch (...) {
			// kaynaklar boşaltılıyor
			throw;
		}
		//...
	}

	Basic guarantee oluşturmak için dinamik bellek tahsisatlarında bellek sızıntısına karşı "smart pointer" sınıfları da kullanılabilir. Örneğin:

	void foo(int a)
	{
		//...

		unique_ptr<int> pi(new int[10]);
		unique_ptr<char> pi(new char[100]);		// artık burada exception oluşursa stack unwinding sırasında pi tahsisatı boşaltılacak
				
		// ...
	}

	3) Strong Guarantee: Burada bir üye fonksiyon çağrıldığında eğer üye fonksiyonun içerisinde exception oluşmuşsa akış fonksyondan çıktığında nesnenin durumu 
	(yani onun içerisindeki veri elemanlarının değerleri) bu üye fonksiyon çağrılmadan önceki değerlerdedir. Başka bir deyişle üye fonksiyonda exception oluşması
	nesne üzerinde hiçbir etki yaratmaz. Tabii sınızntı vs. gibi durumlar da oluşmaz. Örneğin.

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		s'in durumu foo'nun çağrılmadan önceki durumu ile tamamen aynıdır. 
		//...
	}

	Tabii "strong guarantee" oluşturmak hem zahmetli hem de zordur. C++'ın standart kütüphanesindeki pek çok sınıfın üye fonksiyonu "strong guarantee" oluşturmaktadır. Örneğin
	vektörde biz push_back yaptıpımızda bir exception oluşursa vector nesnemiz push_back yapmadan önceki durumla aynı durumda olur. Yani psuh_back fonksiyonu bize "strong guarantee"
	vermektedir. 

	4) No Throw Guarantee: Burada fonksiyon zaten dışarıya throw işlemi yapmayacağına ilişkin söz vermiştir. Dolayısıyla bir exception fırlatmayacaktır. O zaman 
	olabilecek en iyi durum budur. Böyle fonksiyonların programcılar tarafından noexcept belirleyicisi ile belirtilmesi iyi bir tekniktir. Örneğin:

	void foo() noexcept;

	Burada artık biz bu fonksiyonu zaten try-cath içerisinde çağırmak zorunda da değiliz. Çünkü fonksiyon zaten dışarıya throw işlemi yapmayacaktır. Dolaısıyla da bir 
	sızıntı söz konusu olmaz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önce yazmış olduğumuz String sınıfı aslında exception güvenliliği bakımından sorunluydu. O sınıfın atama operatör fonksiyonları herhangi bir exception
	garantisi vermiyordu. Ancak diğer fonksiyonlarda bir problem yoktu. Eski atama operatör fonksiyonları şöyle yazIlmıştı:

	String &String::operator =(const String &r)
	{
		if (this == &r)		/* nesne kendisine atanmış mı? */
			return *this;

		delete[] m_str;

		m_len = r.m_len;
		m_str = new char[m_len + 1];
		strcpy(m_str, r.m_str);

		return *this;
	}

	String &String::operator =(const char *str)
	{
		delete[] m_str;

		m_len = strlen(str);
		m_str = new char[m_len + 1];
		strcpy(m_str, str);

		return *this;
	}

	String &String::operator =(String &&r)
	{
		delete m_str;

		m_len = r.m_len;
		m_str = r.m_str;

		r.m_str = nullptr;

		return *this;
	}

	Bu fonksiyonlar yukarıdaki haliyle exception güveli değildir. Yani "basic guarantee" bile vermemektedir. Burada new işlemi başarısız olursa sızıntı oluşmaz ancak
	nesne kararlı bir durumda kalmamaktadır. "strong guarantee" nesnenin işlem öncesindeki durum ile aynı durumda olması anlamına gelmekteydi. Yukarıdaki atama operatör fonksiyonlarını
	"strong guarantee" verecek biçimde düzenlemenin en kolay yolu "copy and swap idiom" denilen kalıbın uygulanmasıdır. Bu kalıpta önce yerel bir nesne kopya yapıcı fonksiyonu ile
	yaratılır, sonra yerel nesne ile asıl nesnenin veri elemanları yer değiştirilir. Bunun için genellikle sınıfta swap isimli bir üye fonksiyon bulundurulur. Örneğin String 
	sınıfı için bu swap fonksiyonu şöyle olabilir:

	void String::swap(String &r) noexcept
	{
		std::swap(m_str, r.m_str);
		std::swap(m_len, r.m_len);
	}

	fonksiyonundaki içerisinde swap fonksiyonları standart kütüphenedeki template tabanlı swap fonksiyonlarıdır. ""copy  and swap idiom" aşağıdaki gibi uygulanabilir:

	String &String::operator =(const String &r)
	{
		String temp(r);		// exception safe

		swap(temp);
	
		return *this;
	}

	String &String::operator =(const char *str)
	{
		String temp(str);		// exception safe

		swap(temp);

		return *this;
	}

	String &String::operator =(String &&r) noexcept
	{
		swap(r);

		return *this;
	}

	Pekiyi bu fonksiyonlar neden "strong guarantee" vermektedir. Adım adım inceleyeim:

	1) Eğer yerel nesne üzerindeki kopya yapıcı fonksiyonunda exception oluşursa henüz asıl nesnede bir değişiklik yapılmadığı için "strong guarantee" bozulmaz.
	2) swap işlemi asıl nesneyle yerel nesnenin elemanlarını yer değiştirmektedir. Dolayısıyla swap zaten noexcept bir fonksiyondur. Yani "no throw guarantee" vermektedir. 
	3) return *this işleminde de artık exception oluşturacak bir durum yoktur. 

	Aşağıdaki kullanıma dikkat ediniz. 

	int main()
	{
		String s{"ankara"};
		String k;

		cout << s << endl;

		try {
			k = s;
		}
		catch (...) {
			//...
		}
		cout << k << endl;

		return 0;
	}

	Burada k = s işleminde bir exception oluşsa bile arık k'da hiçbir değişiklik olmayacaktır. Yani biz k'nın önceki hali ne ise onu öyle kullanmaya devam edebiliriz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Özetle programcı bir global fonksiyon ya da üye fonksiyon yazarken satır satır hangi noktalarda exception oluşabileceğini dikkate almalıdır. Mümkünse 
	fonksiyonlarınıza "strong guarantee" vermeye çalışın. Mümkün değilse ya da efektif değilse o zaman "basic guarantee" vermeye çalışın. Zaten throw etmeyecek 
	fonksiyonlarda mutlaka noexcept belirleyicisini kullanın.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı fonksiyonlar değişik türler için içi aynı olacak biçimde yeniden yazılmak zorundadır. Örneğin int bir dizinin en büyük elemanına geri dönen bir fonksiyon 
	yazmak isteyelim:

	int getmax(const int *pi, size_t size)
	{
		int max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Şimdi biz double bir diziin en büyük elemanını elde etmek istesek aynı fonksiyondan double için bir tane daha yazmak zorundayız:

	double getmax(const double *pi, size_t size)
	{
		double max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Görüldüğü gibi burada iki fonksiyonun içi tamamen ayndır. Yalnızca tür farklılığı yüzünden programcı yeniden aynı fonksiyondan yazmak zorunda kalmıştır. 
	Tabii aslında bazen tek bir fonksiyn farklı türlerele çalışabilir hale de getirilebilir. Ancak bu tür fonksiyonlar "kullanımı zor" ve "yavaş" olma eğilimindedir. Örneğin:

	void *getmax(const void *pi, size_t size, size_t width, int (*cmp)(const void *, const void *))
	{
		const void *max = pi;
		const const char *pc = reinterpret_cast<const char *>(pi);

		for (size_t i = 1; i < size; ++i)
			if (cmp(pc + (i * width), max) > 0)
				max = pc + (i * width);

		return const_cast<void *>(max);
	}

	İşte şablon (template) "içi aynı olan fakat parametrik türleri" farklı olan fonksiyonların ve sınıfların kullanılan her tür için yazılmasını 
	kolaylaştırmak amacıyla oluşturulmuş bir mekanizmadır. 

	Şablon mekanizmasının Java ve C# gibi dillerdeki mantıksal benzerine "generic" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şablon mekanizması ikiye ayrılmaktadır:

	1) Fonksiyon şablonları (function templates)
	2) Sınıf şablonları (class templates)

	Fonksiyon şablonları tek bir fonksiyonun şablon olarak yazılması anlamına gelir. Sınıf şablonları ise bir sınıfın hepsinin şablon olarak yazılması anlamına gelir. 
	Biz önce fonksiyon şablonları üzerinde sonra sınıf şablonları üzerinde duracağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyon şablonlarnda fonksiyon bildiriminde önce "şablon bildirim" yapılmak zorundadır. Şablon bildirimi template anahtar sözcüğünden sonr açısal parantezler 
	içerisinde şablon parametreleri belirtilerek yapılır. Şablon parametreleri aslında tür belirten parametrelerdir (tür belirtmeyen şablon parametreleri de olabilir). 
	Tür belirten şablon parametrelerinden önce "class" ya da "typename" anahtar sözcükleri getirilir. Bu iki anahtar sözcük arasında hiçbir farklılık ypktur. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Burada template parametresinin ismi T'dir. template parametreleri herhangi bir biçimde isimlendirilebilir. Ancak genellikle programcılar tek karakterli T, K
	gibi harfleri tercih etmektedir. Templatae parametrelerinden önce class anahtar sözcüğü yerine typename anahtar sözcüğü de kullanılabilirdi. Örneğin:

	template <typename T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Buradaki T template parametresi bir tür belirtmektedir. Yani programcı fonksiyonunu sanki T diye semblik bir türe dayalı olarak yazmaktadır. Bu T ismi tür belirten
	bir sözcük olarak fonksiyonun şablonunun her yerinde ekullanılabilir. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		T max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Artık bir fonksiyon şablonu yazıldığında bu fonksiyon şablonu çağrılınca derleyici çağrılma ifadeisndeki argümanların türlerine bakarak template parametresinin (örneğimizde T)
	hangi tür olması gerektiğini anlamaya çalışır. Template parametresinin türünü çağrılma ifadesine göre tespit edilmesi sürecine "template argument deduction" denilmektedir. 
	Derleyici bu tespiti yaptıktan sonra gerçekten bu şablona bakarak ilgili tür için fonksiyonu yazar. Derleyicinin şablona bakarak ilgili fonksiyonu türe dayalı oalrak yazmasına ise
	"template instantiation" denilmektedir. Biz "instantiation" sözcüğü yerine "template fonksiyonun açılması" deyieceğiz. Örneğin:

	int a[5] = {34, 23, 12, 67, 43};
	
	int result;
	
	result2 = getmax(a, 5);

	Burada derleyici getmax fonksiyonun birinci argümanınınint * türündeb olduğunu görür. Bu durumda T türünün int olması gerektiğini anlar ve template fonksiyonu bizim 
	için aşağıdaki gibi açar (instantiate eder):

	int getmax(const int *p, size_t size)
	{
		int max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Derleyici her farklı tür için bu açımı kendisi yapmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <class T>
T getmax(const T *p, size_t size)
{
	T max = p[0];

	for (size_t i = 1; i < size; ++i)
		if (max < p[i])
			max = p[i];

	return max;
}

int main()
{
	int a[5] = {34, 23, 12, 67, 43};
	double b[5] = {34.2, 45.4, 65.6, 21.3, 12.5};
	
	int result1;
	double result2;

	result1 = getmax(a, 5);
	cout << result1 << endl;

	result2 = getmax(b, 5);
	cout << result2 << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin iki nesnenin içerisindeki değeir yer değiştiren swap isimli bir fonksiyon yazılabilir. Zaten standart kütüphanede böyle bir fonksiyon vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

template <typename T>
void swap(T &a, T &b)
{
	T temp(a);

	a = b;
	b = temp;
}

int main()
{
	int a = 10, b = 20;
	double x = 12.3, y = 2.4;

	swap(a, b);
	std::cout << "a = " << a << ", b = " << b << std::endl;

	swap(x, y);
	std::cout << "x = " << x << ", y = " << y << std::endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir değerin mutlak değerine geri dönen bir fonksiyon template olarak yazılabilir 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon şablonları derleyici tarafından her derleme işleminde görülmelidir. Bu nedenle fonksiyon şablonları kütüphaneler içerisine yerleştirilemez. Onların 
	tipik olarak başlıkd osyalarına yerleştirilmesi uygun olur. Böylece derleyici derleme işlemi sırasında onların kodunu görecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi tamamen şablon esasına dayandırılmıştır. Orada pek çok hazır fonksiyon ve sınıf bulunmaktadır. Bu hazır fonksiyonlar ve sınıflar 
	"iteratör (iterator)" denilen bir kavram kullanılarak gerçekleştirilmiştir. İteratör "bir gösterici gibi davranan gerçek bir gösterici ya da sınıftır". 
	Standart kütüphanedeki fonksiyon şablonları bir dizi alacakları zaman onun başlangıç ve bitiş bitiş iteratörlerini bizden isterler. Başlangıç iteratörü dizinin ilk 
	elemanın adresidir. Ancak eğer bir sınıf söz konusuysa bu iteratör bir nesne durumunda olabilir. Bitiş iteratörü dizinin son elemanından sonraki elemanın adresidir. 
	Eğer biz C++'ın standart kütüphanesindeki fonksiyon şablonlarını dizi için kullanacaksak başlangıç iteratörünü dizinin başlangıç adresi olarak bitiş iteratörünü dizinin 
	son elemanından sonraki adres olarak vermeliyiz. Bu fonksiyonlar itertaörleri ilerleterek veri yapısının tüm elemanlarına erişirler. Örneğin <algorithm> başlık dosyasındaki
	copy isimli fonksiyon şablonu bizden bir dizinin ilk elemanın ve sondan bir sonraki elemanının adresini alarak oradaki tüm elemanları başka bir adresten itibaren kopyalar. 
	Bu fonksiyon aşağıdaki gibi yazılmıştır:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD 
{
	template<class InputIt, class OutputIt>
	OutputIt copy(InputIt first, InputIt last, OutputIt dest)
	{
		while (first != last) {
			*dest = *first;
			++first;
			++dest;
		}

		return dest;
	}
}

int main()
{
	int a[5] = {1, 2, 3, 4, 5};
	int b[5];

	CSD::copy(a, a + 5, b);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin standart kütüphanedeki find fonksiyonu türden bağımsız arama yapan genel bir fonksiyondur. Bizden dizinin ilk elemanının ve son elemanından sonraki elemanın adresini 
	ve aranacak değeri parametre olarak alır. Eğer değeri dizide bulursa bulduğu yerin adresiyle (iteratörüyle) geri döner. Bulamazsa son elemandan sonraki elemanın adresiyle 
	(yani end iteratörüyle) geri dönmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	double *result;

	result = find(a, a + 5, 9);

	if (result == a + 5)
		cout << "cannot find item" << endl;
	else
		cout << "found: " << *result << endl;


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin sort isimli fonksiyon şablonu yine bizden bir dizinin ilk elemanın ve son elemanından sonraki elemanın adresini alarak o diziyi sıraya dizmektedir. 
	Biz bu fonksion şablonu yoluyla aslında her türden diziyi sıraya dizebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	
	sort(a, a + 5);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon şablonu çağrılırken şablon türleri açısal parantezler içerisinde açıkça (explicit) da belirtilebilmektedir. Bu durumda şablon parametreleri 
	argümanlardan hareketle belirlenmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << a << endl;
}

int main()
{
	foo(10);			// T = int
	foo(1.2);			// T = double
	foo<double>(100);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Açısal parantezler içerisinde şablon parametrelerinin açıkça belirtilmesi bazen gerekebilmektedir. Örneğin fonksiyonun şablonunun şablon parametresine 
	ilişkin bir parametre değişknei olmayabilir. Bu durumda derleyici şablonm parametresini otomatik belirleyemez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo()
{
	T a();

	cout << a << endl;
}

int main()
{
	foo();			// error!
	foo<int>()

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bazen şablon parametresi fonksiyonun geri dönüş değerinde olabilir. Bu durumda da otomatik türs belirlemesi yapılamaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T foo()
{
	cout << "foo" << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>();
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı ilk n tane şablon parametresini açıkça belirtip geri kalanlarını derleyicinin tespit etmesini isteyebilir. 
	Aşağıdaki örnekte T şablon parametresi açıkça belirtilmiş ancak K şablon şablon parametresi derleyici tarafından belirlenmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K>
T foo(K a)
{
	cout << a << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>(12.3);		// T = int, K = double
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında şablon parametreleri default değerler de alabilmektedir. Eğer bir şablon parametresi otomatik belirlenemiyorsa verilen default değerler 
	kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K = int>
K foo(T a)
{
	cout << a << endl;

	return K();
}

int main()
{
	int result;

	result = foo(10.2);		// T = double, K = int
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir şablon fonksiyon ile aynı isimli normal fonksiyon bir arada bulunabilir. Bu durumda overload resolution işleminde normal fonksiyon eğer argüman türleri
	tam olarak uyum sağlıyorsa tercih edilmektedir. Ancak argüman türleri tam olarak uyum sağlamıyorsa fonksiyon şablonu tercih edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << "template function: " << a << endl;
}

void foo(int a)
{
	cout << "non-template function: " << a << endl;
}

int main()
{
	foo(12.3);			// şablon olan 
	foo(100);			// normal fonksiyon

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın tamamı da şablon olarak yazılabilir. Böyle sınıflara "sınıf şablonları (class templates)" denilmektedir. Sınıf şablonları yazılırken 
	yine bir şablon bildirimi ile başlanır. Sonra normal sınıf bildirimi ile devamö edilir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Şablon parametresi tür belirten bir sözcük olarak sınıf bildirimin her yerinde ve tüm üye fonksiyonlarda kullanılabilir. 

	Bir sınıf şablonu mutlaka şablon parametresi açısal parantezler içerisinde belirtilerek kullanılmak zorundadır. Sınıf şablonlarında fonksiyon şablonlarında 
	olduğu gibi "otomatik şablon parametresinin tespiti" yapılmamaktadır. Şablon parametresinin mutlaka açısal parantezler içerisinde belirtilmesi gerekmektedir. 
	Örneğin:

	Sample<int> s(10);

	Bir sınıf şablonunun üye fonksiyonları sınıf içerisinde inline olarak tanımlanabilir. Ancak bu üye fonksiyonlar sınıfın dışında tanımlanacaksa şablon bildirimi
	biçiminde tanımlanmalıdır. Çünkü şablon bir sınıfın üye fonksiyonları şablon fonksiyonlar gibidir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	Aslında sınıf şablonunun üye fonksiyonları dışarıda yazılırken şablon parametrelerinin isimlerinin uyuşması gerekmemektedir. Ancak bu uyuşumu sağlamak iyi bir tekniktir. 
	Yani aslında biz foo üye fonksiyonunu şöyle de tanımlayabilirdik:

	template <typename K>
	void Sample<K>::foo()
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(T val);
	void disp() const;
private:
	T m_val;
};

template <class T>
Sample<T>::Sample(T val)
{
	m_val = val;
}

template <typename T>
void Sample<T>::disp() const
{
	cout << m_val << endl;
}

int main()
{
	Sample<int> s(10);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonu aslında eğer o sınıf programda hiç kullanılmamışsa hiç "instantiate" edilmemektedir. (Biz "instantiate" sözcüğü yerine "açım", "açılma" 
	sözcüklerini de kullanıyoruz). Tabii bir sınıf şablonu açılırken aslında derleyici onun tüm üye fonksiyonlarını açmaz. Yalnızca kullanılan üye fonksiyonlarını 
	açar. 

	Aşağıdaki örnekte standart vector sınıfının birkaç fonksiyonu taklit edilmiştir. Tabii bu örnek orijinal vector sınıfının bir gerçekleştirimi değildir. 
	Orijinal vector sınıfında exception durumu için "strong guarantee" verilmektedir. Biz aşağıdaki örnekte herhangi bir exception garantisi vermiyoruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// myvector.hpp

#ifndef MYVECTOR_HPP_H
#define MYVECTOR_HPP_H

#include <cstddef>

const int DEF_CAPACITY = 4;

template <typename T>
class myvector {
public:
	using size_type = std::size_t;

	myvector()
	{
		m_vector = new T[DEF_CAPACITY];
		m_size = 0;
		m_capacity = DEF_CAPACITY;
	}
	~myvector()
	{
		delete[] m_vector;
	}
	void push_back(const T &r);
	size_type size() const { return m_size; }
	size_type capacity() const { return m_capacity; }
	T &operator[](size_t index)
	{
		return m_vector[index];
	}
	const T &operator[](size_t index) const
	{
		return m_vector[index];
	}
private:
	T *m_vector;
	size_type m_size;
	size_type m_capacity;
};

template <typename T>
void myvector<T>::push_back(const T &r)
{
	if (m_size == m_capacity) {
		T *new_vector = new T[m_capacity * 2];
		for (size_type i = 0; i < m_size; ++i)
			new_vector[i] = m_vector[i];
		delete[] m_vector;
		m_vector = new_vector;
		m_capacity *= 2;
	}

	m_vector[m_size++] = r;
}

#endif

// app.cpp

#include <iostream>
#include "myvector.hpp"

using namespace std;

int main()
{
	myvector<int> mv;

	for (myvector<int>::size_type i = 0; i < 10; ++i)
		mv.push_back(i);

	for (myvector<int>::size_type i = 0; i < mv.size(); ++i)
		cout << mv[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir sınıf şablonundan türetilebilir. Tabii bu durumda taban sınıf belirtilirken şablon parametresinin açısal parantezler içerisinde belirtilmesi gerekir. 
	örneğin:

	template <typename T>
	class A {
		//...
	};

	class B : public A<int> {
		//...
	};

	Burada B sınıfı A sınıfının int açılımından türetilmiştir. 

	Tabii bir sınıf şablonu normalk bir sınıftan da türetilebilir. Örneğin:

	class A {
		//...
	};

	template <typename T>
	class B : public A {
		//...
	};

	Bu duurmda B'nin her bir açılımı A'dan türetilmiş olmaktadır. Örneğin:

	B<int> x;
	B<double> y;
	...

	Bir sınıf şablonu başka bir sınıf şablonundan da türetilebilir. Örneğin:

	template <typename T>
	class A {
		//...
	};

	template <typename T>
	class B : public A<T> {
		//...
	};

	Burada B hangi tür ile açılırsa aslında o A'nın aynı türden açılımından türetilmiş olur. Örneğin:

	B<int> b;

	Burada B<int> sınıfı A<int> sınıfındna türetilmiştir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Normal bir sınıfın bir üye fonksiyonju bir fonksiyon şablonu olabilir. Sınıfın içerisindekli fonksiyon şablonlarına C++'ta "member template" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	template <typename T>
	void foo(T a);				// member template
};

template <typename T>
void Sample::foo(T a)
{
	//...
}

int main()
{
	Sample s;

	s.foo(100);		// T = int
	s.foo(12.3);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonun iye fonksiyonlarının zaten şablon fonksiyonlar gibi ele alındığını belirtmiştik. Ancak bir sınıf şablonunun belli üye fonksiyonları da
	ekstra biçimde şablon olabilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();

		template <typename K>
		vaid bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	template <typename T>
	template <typename K>
	void Sample<T>::bar(K a)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	void foo();

	template <typename K>
	void bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
	//...
};

template <typename T>
void Sample<T>::foo()
{
	//...
}

template <typename T>
template <typename K>
void Sample<T>::bar(K a)
{
	//...
}

int main()
{
	Sample<int> s;

	s.foo();
	s.bar(12.3);		// T = int, K = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir sınıf şablonunun özel bir tür için başka bir versiyonun yazılması istenebilir. Buna "özelleştirme (specialization)" denilmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	template <>
	class Sample<bool> {
		//...
	};

	Burada Sample sınıfının bool için özelleştirildiğini görüyorsunuz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T> 
class Sample {
public:
	void foo()
	{
		cout << "general template foo" << endl;
	}
};

template<>
class Sample<bool> {
public:
	void foo()
	{
		cout << "bool specialization foo" << endl;
	}
};

int main()
{
	Sample<int> s;
	Sample<bool> k;

	s.foo();
	k.foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonunun her farklı türdne açımı farklı bir tür belirtmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample<int> x;
	Sample<double> *y;

	y = &x;		// error! türler farklı

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Şablon fonksiyon ya da sınıf bildirimini gören derleyici hata kontrolünü iki aşamada yapmaktadır:

	1) Fonksiyon ta da sınıfı gördüğü aşamada. Burada henüz bir açım yapılmamıştır. Şablonb parametresi ne olursa olsun kodun geçerli olması gerekir. 
	örneğin aşağıdaki şablon bildiriminde daha açım yapılmadan derleyici error durumunu tespit edebilirr:

	template <typename T>
	void foo(T a)
	{
		xxxxxx		// böyle bir değişken yok! şablon parametresi ne olursa olsun burada bir error söz konusudr.
	}

	2) Açım (instantiation) sırasında. Şablonb parametrelerinin açım sırasında fonksiyon ya da sınıf şablonlarının koduna uygun olması gerekir. Örneğin iki değerin
	küçüğünü veren aşağıdaki gibi bir fonksiyon şablonu olsun:

	template <typename T>
	T minval(const T &a, const T &b)
	{
		if (a < b)
			return a;

		return b;
	}

	Burada bu fonksiyonu biz int türüyle açabiliriz. Ancak < operatör fonksiyonu olmayan bir sınıfla açmaya çalışsak açım sırasında error oluşacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T minval(const T &a, const T &b)
{
	if (a < b)
		return a;

	return b;
}

class Number {
public:
	Number() = default;
	Number(int a) : m_a(a)
	{}
	bool operator <(const Number &r) const
	{
		return m_a < r.m_a;
	}
	friend ostream &operator <<(ostream &os, const Number &n)
	{
		os << n.m_a;

		return os;
	}
private:
	int m_a;
};

int main()
{
	int x;

	x = minval(10, 20);
	cout << x << endl;

	Number y;
	Number a(10), b(20);

	y = minval(a, b);

	cout << y << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablocu her zaman kullanılırken açım türü belirtilerek kullanılmalıdır. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample s;			// error!
	Sample<int> k;		// geçerli

	Ancak istisna olarak bir sınıf şablonu sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde açım türü belirtilmeden kullanılabilir. Bu durumda
	açım türünün şablon türleri olduğu kabul edilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		Sample a;		// geçerli, Sample<T> ile eşdeğer.
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesi hep fonksiyon ve sınıf şablonlarından oluşmaktadır. Örneğin aslında string sınıfı diye bir sınıf yoktur. Sınııfn asıl hali, 
	string'in karakterlerinin hangi türle ifade edileceğini de belirten şablon basic_string<T> sınıfıdır. string ismi aslında aşağıdaki gibi bir typedef 
	ismidir:

	typedef basic_string<char> string;

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede veri yapılarını temsil eden bir grup sınıfa "nesne tutan sınıflar (container classes)" denilmektedir. Biz daha önce nesne tutan sınıf olarak 
	vector<T> sınıfını görmüştük. Diğer önemli bir nesne tutan sınıf da list<T> isimli sınıftır. list sınıfı "bağlı liste (linked list)" denilen veri yapısını 
	gerçekleştirmek için kullanılmaktadır. Bağlı listeler önceki elemanın sonraki elemanını, sonraki elemanın da önceki elemanını gösterdiği özel veri yapılarıdır. 
	Bağlı listenin elemanları bellekte ardışıl bulunmaz. Bağlı listelerde belli bir elemana erişmek için önceki elemanları da dolaşmak gerekir. 

	list<T> nesnesinin sonuna eleman eklemek için yine push_back fonksiyonu kullanılmaktadır. list nesnesinin elemanları aralık tabanlı for döngüleriyle dolaşılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    list nesnesinin elemanları iteratör yoluyla da dolaşılabilmektedir. Daha önceden de belirttiğimiz gibi "iteratör" bir gösterici gibi kullanılan nesnelerdir. 
	Nesnenin başlangıç iteratörü begin üye fonksiyonuyla son elemandan sonraki iteratörü end üye fonksiyonuyla elde edilmektedir. list sınıfının kullandığı iteratörün
	türü sınıf içerisinde list<T>::iterator typedef ismiyle temsil edilmektedir. iteratör yoluyla list nesnesinin dolaşılmasının tipik kalıbı şöyledir:

	for (list<T>::iterator iter = a.begin(); iter != a.end(); ++iter) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (list<int>::iterator iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	for (auto iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede özel algoritmik bir yapı ile elemanları tutan bir grup nesne tutan sınıf da vardır. Bunlara İngilizce "associative containers" denilmektedir.
	Bunların listesi şöyledir:

	map<Key, Value>
	set<T>
	multimap<Key, Value>
	multiset<T>
	unordered_map<Key, Value>
	unordered_set<T>
	unordered_multimap<Key, Value>
	unordered_multiset<Key>

	Bu sınıfların aslında başka default değer alan şablon parametreleri de vardır. 

	map sınıfı en fazla kullanılan "associative container" sınıftır. Sınıf ahanat değer çiftlerini tutar. Anahtar verildiğinde değeri hızlı bir biçimde verir. 
	Sınıf iteratör yoluyla dolaşıldığında sıralı bir biçimde dolaşılmaktadır. Tipik olarak "dengelenmiş ikili ağaç (balanced binary tree)" biçiminde gerçekleştirilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	string result;

	result = m[420];
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir map nesnesi iteratör yoluyla dolaşılırken anahtar-değer çiftleri pair isimli bir sınıf nesnesi olarak elde edilir. pair<T, K> iki şablon parametresine
	sahip bir sınıftır. Sınıfın first veri elemanı nesnein ilk elemanını, secod veri elemanı ise ikinci elemanını belirtmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	for (map<int, string>::iterator iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	for (auto iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Son yıllarda "lambda ifadeleri (lambda expressions)" pek çok programlama diline sokuldu. Aslında lambda ifadelerine benzer yapılar "fonksiyonel (functional)"
	programlama modeline sahip dillerde zaten uzun süredir kullanılıyordu. Ancak son yıllarda klasik programlama dilleri de fonksiyonel öğeleri 
	bünyesine katmaya çalışmıştır. Dolayısıyla bu lambda ifadeleri bu baağlamda pek çok programlama diline eklenmiştir. Lambda ifadeleri C++11 ile birlikte C++'a
	da eklenmiş durumdadır. 

	Lambda ifadelerinden amaç bir fonksiyonu hem tanımlayıp hem de aynı noktada kullanmaya olanak sağlamaktır. Dolayısıyla lambda fonksiyonlar ifadelerin içerisinde
	bulunabilirler. Lambda fonksiyonla bize şu iki avantajı sunmaktadır:

	1) Bir fonksiyonu o anda yazıp ifade içerisinde kullanmak kodu daha kısa ve öz gösterebilmektedir. Hem programcı için pratik bir kullanım sunarlar 
	hem de az tuşa basarak benzer işlemleri yapmayı sağlarlar. 

	2) Lambda fonksiyonlar bir çeşit "iç fonksiyon (nested function)" gibi kullanılabilmektedir. Dolayısıyla bir lambda fonksiyon içerisinde biz dış fonksiyonun yerel 
	değişkenlerini kullanabiliriz. 

	C++'ta lambda ifadelerinin genel biçimi şöyledir:

	<[[capture_listesi]]> [(parametre_listesi)] [-> <geri_dönüş_değerinin_türü] 
	{
		//...
	}

	Bir lambda ifadesi kullanıldığında derleyici aslında lambda ifadesi için bir sınıf oluşturmaktadır. Ancak oluşturduğu sınıfın ismini programcı bilmemektedir. 
	Lambda kodları bu sınıfın fonksiyon çağırma operatör fonksiyonu içerisine yerleştirilmektedir. Dolayısıyla programcı eğer lambda ifadesini bir yere 
	atayacaksa onun ürünü bilmediğine göre auto tür belirleyicisini kullanmalıdır. Örneğin:

	auto f = [] (int a) -> int { return a * a; };
	int result;

	result = foo(10);

	Aslında burada arka plana şunlar yapılmaktadır:

	class compiler_generated_name {
	public:
		int operator ()(int a)
		{
			return a * a;
		}
		//...
	};
	int result;

	auto f = compiler_generated_name();
	
	result = f(10);

	cout << result << endl;

	Yani aslında biz bir lambda ifadesi yazdığımızda bir sınıf oluşturmuş ve aynı zamanda o sınıf türünden bir nesne yaratmış oluruz. Sonra bu lambda 
	ifadesi çağrıldığında aslında sınıfın fonksiyon çağırma operatör fonksiyonu çalıştırılmış olur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi fonksiyon yerine lambda ifadeleri kullanmanın uygun olacağı yerler nelerdir? İşte büyük ölçüde lambda ifadeleri C++'ın standart kütüphanesindeki 
	"algoritma (algorithm)" denilen fonksiyonlarla birlikte kullanılmaktadır. Thread'ler gibi konularda da lambda ifadeleri kimi zaman kullanılabilmektedir. 
	C++'ın <algoritm> başlık dosyasında pek çok temel işlemi yapan şablon fonksiyonun bulunduğunu sçylemiştik. Bu şablon fonksiyonlar "iterator" denilen kavram kullanılarak 
	oluşturulmuştu. İteratör "gösterici gibi davranan" şeyler anlamına geliyordu. Yani iteratör gerçek bir gösterici olabilirdi ya da gösterici gibi davranan (yani * ve/veya
	-> operatör fonksiyonları bukunan) sınıf nesneleri olabilirdi. <algoritm> başlık dosyasındaki şablon fonksiyonlar bizden bir dizilimi başlangıç ve bitiş 
	iteratörleri yoluyla almaktadır. Bitiş iteratörler her zaman dizilimdeki son elemandan sonraki olmayan elemanı temsil etmektedir. C++'ın standart nesne 
	tutan sınıfları (container classes) bize başlangıç ve bitiş iteratörlerini begin ve end üye fonksiyonarıyla vermektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi for_each isimli şablon fonksiyon bir dizilimin her elemanı için bir fonksiyonu çağırıyordu. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

void foo(int a)
{
	cout << a *  a << " ";
}

int main()
{
	int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	for_each(a, a + 10, foo);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşte yukarıdaki örnekte kullandığımız fonksiyon lambda ifadesi olarak hemen yazılıp ifadenin içerisinde kullanılabilmektedir.   
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	for_each(a, a + 10, [](int a) {cout << a * a << " "; });

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Benzer biçimde örneğin üç parametreli sort fonksiyonunda yer değiştirme yapılıp yapılmayacağına yönelik fonksiyon lambda biçiminde yaızlabilir. Aşağıdaki 
	örnekte şehir isimleri alfabetik sıraya göre değil sözcük uzunluklarına göre sıraya dizilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> cities = {"ankara", "izmir", "adana", "gaziantep", "eskisehir", "van", "manisa"};

	sort(cities.begin(), cities.end(), [](const string &s1, const string &s2) { return s1.size() < s2.size(); });

	for (auto &city : cities)
		cout << city << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	<algorithm> başlık dosyasında find fonksiyonun yanı sıra find_if isimli bir fonksiyon da vardır. Bu fonksiyonun üçüncü parametresi bir fonksiyon almaktadır.
	Bu fonklsiyonun tel parametresi olamlıdır (unary predicate). Fonksiyon bool bir değere geri dönmelidir. Fonksiyon eğer elemanı bulmuşsa ture değerine bulamamışsa
	false değerine geri dönecek biçimde yazılmalıdır. Bu üçüncü fonksiyonu biz lambda ifadesi olarak girebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> cities = {"ankara", "izmir", "adana", "gaziantep", "eskisehir", "van", "manisa"};

	auto result = find_if(cities.begin(), cities.end(), [](const string &s)-> bool {return s.size() == 3; });

	if (result == cities.end())
		cout << "cannot find!" << endl;
	else
		cout << *result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer lambda fonksiyonun parametresi yoksa lambda ifadesi yaılırken parametre parantezleri parantezler hiç  kullanılmayabilir. örneğin:

	auto f = [] -> int { return 10; };

	cout << f() << endl;

	
	Yani yukarıdaki lambda ifadesi aşağıdaki ile eşdeğerdir:

	auto f = [] () -> int { return 10; };

	Lambda ifadeleride geri dönüş değeri de belirtilmeyebilir. Bu durumda geri dönüş değeri return ifadesinin değeir türünden olur. Örneğin:

	auto f = [] { return 10; };

	Burada geri dönüş değeri int türdendir. Tabii bu durumda lambda ifadesindeki tüm return deyimlerinin aldığı ifadelerin aynı türden olması gerekir. Örneğin:

	auto f = [](int a) { return a * a; }

	Burada a * a ifadesi int türden olduğuna göre geri dönüş değerinin türü belirtilmemiş olsa da int türden kabul edilmektedir. 

	Lambda ifadelerinde global değişkenler doğrudan klullanılabilir. Örneğin:

	#include <iostream>

	using namespace std;

	int a = 10;

	int main()
	{
		auto f = [] { return a * a; };

		cout << f() << endl;

		return 0;
	}

	Lambda ifadelerinde ifadenin yazıldığı fonksiyondaki yerel değişkenler de kullanılabilir. Ancak bu durumda ifanin yazıldığı fonksiyonun hangi yerel 
	değişkenlerinin kullanılacağı köşeli parantez içerisindeki "capture istesinde" aralarına ',' atomu konularak belirtilmelidir. 

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, b] { return a * b; };

		cout << f() << endl;

		return 0;
	}

	Capture listesindeki elemanalrın lambda ifadesi ile belirtilen sınıf nesnesine aktarımı lambda ifadesi görüldüğünde yapılmaktadır, fonksiyon çağrıldığında değil. 
	Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, b] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 200

		return 0;
	}

	Capture işlemi referans yoluyla da yapılabilir. Bu durumda capture değilen değişken isminin soluna & atomu getirilir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [a, &b] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 20

		return 0;
	}

	Bu örnekte a kopyalama yoluyla b ise referans yoluyla capture edilmiştir. Dolayısıyla lambda ifadesi içerisinde kullanılan b aslında adresi ile alınan nesneye 
	erişmek anlamındadır. 

	[=] sentaksı kopyalama yoluyla otomatik capture anlamına gelmektedir. Yani bu durumda derleyici lambda ifadesini inceler. eğer orada üst fonksiyonun 
	yerel değişkenleri kullanılmışsa o değişkenleri otomatik olarak capture eder. Bu capture işlemi lambda ifadesinin bulunduğu yerde kopyalaa yoluyla
	yapılmaktadır. Öreğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [=] { return a * b; };

		cout << f() << endl;		

		return 0;
	}

	Otomatik capture işleminin bir diğer yolu da [&] sentaksıdır. Bu durumda yine derleyici lambda ifadesini inceler. Bu ifadede üst fonksiyonun kullanılan değişkenlerini
	otomatik adres yoluyla capture eder. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20;

		auto f = [&] { return a * b; };

		a = 1, b = 2;

		cout << f() << endl;		// 2

		return 0;
	}

	Otomatik capture işleminin  diğer bir yolu [=, liste] ya da [&, liste] sentaksıdır. Burada listede belirtilen değişkenler sol tarafta belirtilen 
	kopyalama ya da adres aktarımının tersi olarak belirtilmek zorundadır ve onlar bu biçimde aktarılırlar. Örneğin:

	auto f = [&, b] { return a * b * c; };

	Burada b kopyalanarak capture edilmektedir. Ancak a ve c adres yoluyla capture edilmektedir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20, c = 30;

		auto f = [&, b] { return a * b * c; };

		a = 1, b = 2, c = 3;

		cout << f() << endl;		// 60

		return 0;
	}


	Ancak şöyle bir capture ifadesi oluşturulamaz:

	auto f = [&, &b] { return a * b * c; };			// error!

	Zaten tüm kullanlanlar otomatik adres yoluyla captue edileceğine göre b'nin de yine adres yoluyla capture edilmesinin bir anlamı yoktur. Aynı 
	sektaktik biçim otomatik = sentalsında da benzer biçimde uygulanmaktadır. Örneğin:

	auto f = [=, &b] { return a * b * c; };

	Burada a ve c kopyalanarak b ise adres yoluyla capture edilmektedir. Örneğin:

	#include <iostream>

	using namespace std;

	int main()
	{
		int a = 10, b = 20, c = 30;

		auto f = [=, &b] { return a * b * c; };

		a = 1, b = 2, c = 3;

		cout << f() << endl;		// 600

		return 0;
	}

	Tabii aşağıdaki capture listesi yine hatalıdır:

	auto f = [=, b] { return a * b * c; };		// error!

	Burada zaten b kopyalanarak capture edilmektedir. Onun ayrıca capture listesinde kopyalarak capture edileceğinin belirtilmesi anlamsızdır ve geçersizdir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Thread'ler konusu oldukça detaya sahip olan ayrı bir biçimde ele alınması gereken ir konudur. Thread'ler işletim sistemini çekirdekleri (kernels) tarafından 
	oluşturulan bir mekanizmadır. Dolayısıyşa farklı işletim sistemlerinde thread'ler konusunda o işletim sistemine özgü farklılıklar çsz konusudur. Bugün en önemli 
	iki platform Microsoft Windows ve UNIX/Linux platformudur. Bu iki işletim sistemi grubu biribirinden tamamen farklıdır. Dolayısıyla bu iki işletim sisteminin
	sunduğu sistem fonksiyonları da birbirlerinden farklıdır. Thread'ler konusu bu nedenle işletim sistemi bağımlı bir konudur. Bukonuyu işletim sistem sisteminden 
	bağımsız hale getirebilmek için yani "cross platform" bir biçimde ele alabilmek için çeşitli kütüphaneler kullanılabilmektedir. 

	Windows'ta aşağı seviyeli thread işlemleri Windows'un sistem fonksiyonlarını çağıran "Windows API fonksiyonlarıyla" gerçekleştirilmektedir. Benzer biçimde
	UNIX/Linux dünyasında thread işlemleri o sistemlerdeki sistem fonksiyonlarını çağıran POSIX fonksiyonlarıyla gerçekleştirilmektedir. Java ve .NET gibi ortamlar
	thread işlemleri için kendi thread sınıflarını bulundurmuşlardır. Bu thread sınıfları Windows ortamlarındda Windows'un API fonksiyonları kullanılarak UNIX/Linux ortamlarında 
	POSIX fonksiyonları kullanrak yazılmışlardır. Ancak bu kısım framework tarafından halledildiği için bu ortamlar cross platform thread işlemlerine olanak sağlamaktadır. 
	Yine bazı framework'ler kendi thread sınıflarına sahiptir ve onlar da cross platform thread işlemlerine olabak vermektedir. Örneğin Qt kütüphanesindeki QThread 
	sınıfı yine Windows sistemlerinde Windows'un API fonksiyonlarını çağıracak biçimde UNIX/Linux sistemlerinde POSIX fonksiyonlarını çağıracak biçimde cross-paltform 
	olarak yazılmıştır. 

	C standartlarında 2011 yılna kadar thread'ler hiç söz konusu edilmemiştir. C11 ile birlikte C'ye "optional" yalın bir thread kütüphanesi eklenmişse de bu kütüphane 
	Microsoft ve GNU ve cland derleyicileri tarafından desteklenmemektedir. C++'a thread kütüphanesi C++11 ile birlikte eklenmiştir. Dolayısıyla artık cross-platform 
	thread işlemleri C++'ın standart kütüphanesi yoluyla yapılır duruma gelmiştir. Şüphesiz C++'ın standart thread kütüphanesi de Windoes'ta Windows'un API fonksiyonları
	kullanılarak UNIX/Linux ve Mac sistemlerinde POSIX fonksiyonları kullaılarak yazılmış durumdadır. Ancak C++ programcısı thread'leri hep aynı biçimde kullanır. 
	İşletim sistemi farklılığı kütüphane tarafından gerçekleştirim sırasında kendi içerisinde halledilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşletim sistemlerinde çalışmakta olan programalara "proses (process)" denilmektedir. Proses çalışmakta olan programın bütün her şeyini anlatan bir kavramdır. 
	Yani onun yetki derecesini, çalışma dizininin, bellekteki yükleme adresini, açtığı dosyaları vs. Ancak prosesin akışlarına "thread" denilmektedir. Eskiden thread'ler 
	yoktu. Thread'ler 90 yılların ortalarına doğru işletim sistemlerine girmiştir. Microsoft'un ilk thread'li işletim sistemi Windows NT (1993)'dir. Sonra bunu 
	Windows 95 (1995) izlemiştir. UNIX/Linux dünyasına da thread'ler 90'lı yılların ortalarında girmiştir. 

	Thread'ler proseslerin bağımsız çizelgelenen akışlarıdır. Modern işletim sistemleri genellikle "zaman paylaşımlı (time sharing)" bir thread çizelgelemesi kullanmaktdır. 
	Yani işletim sistemi bir thread'i alır onu belli bir süre çalıştırır sonra onun çalışmasına ara verir. Diğer thread'i alır onu da belli bir süre çalıştırır. 
	Hep böyle thread'leir parça parça çalıştırıp durdurarak çalıştırmaktadır. Kullanıcı sanki programlarını "hep çalışıyormuş zanneder" aslında programlar hep çalışmamaktadır. 
	İşletim sistemleri onları zaman paylaşımlı bir biçimde çalıştırmaktadır. Bir thread'in parçalı çalışma süresine "quanta süresi (time quantum)" denilmektedir. 
	Thread'in quanta süresi çeşitli faktörlere bağlı olarak değişebilmekle birlikte Windows'ta tipik olarak 20 ms. UNIX/Linxu ve Mac sistemlerinde 60 ms. kadardır. 
	Çok işlemcili ya da çok çekirdekli sistemlerde prensip değişmez. İşletim sistemleri her işlemci ya da çekirdek için ayrı bir kuyruk oluşturur o kuyrukta yine
	zaman paylaşımlı bir çalışma uygular. Çok işlemci ya da çekirdeğin bulunduğu durumda işler bu işlemciler ve çekirdekler tarafından paylaşıldığı için 
	toplamda daha hızlı bir çalışma söz konusu olur. 

	Thread'in parçalı çalışma süresi dolduğunda thread akışı zorla işletim sistemi tarafından alınmaktadır. Bu zorla akışın alınmasına İngilizce "preemption" denilmetedir. 
	Bu tür işletim sistemlerine ise "preemptive" işletim sistemleri denir. Akışın quanta süresi dolduunda zorla alınması donanım kesmeleri yoluyla yapılmaktadır. 
	Artık işlemcilerde de işlemcisnin kendi içerisinde bu amaçla timer devreleri bulundurulmaktadır. 

	Bir proses çalışmaya tek bir thread'le başlar. Buna prosesin "ana thread'i (main thread)" denilmektedir. Örneğin C'de main'den giren akış ana thread akışıdır. 
	Diğer thread'ler programcı tarafından yaratılmaktadır. Tabii yukarıda da belirtildiği gibi aslında thread'lerin yaratılması işletim sisteminin sistem fonksiyonları ile 
	yapılmaktadır. Ancak bu sistem fonksiyonlarını çağıran çeşitli kütüphaneler ve arayüzler oluşturulmuştur. C++'ın thread ktüphanesi de neticede aslında i,şletim sisteminin
	sistem fonksiyonlarıı çağırmaktadır. Ancak yukarıda da sözünü ettiğimiz gibi C++'ın standart kütüphanesi bu bağlamda "portable" bir arayüz sunmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın thread kütüphanesindeki sınıfların ve fonksiyonların önemli bölümü <thread> başlık dosyası içerisidedir. Thread'ler thread isimli sınıf yoluyla yaratılmaktadır. 
	thread sınıfı türünden bir nesne yaratıldığında thread de yaratılmış olur. Thread nesnesi yaratılır yaratılmaz thread akışı da başlatılmaktadır. 
	Bir thread yaratıldığında thread akışı belli bir fonksiyondan başlatılmaktadır. İşte thread yaratılırken programcı thread akışının başlatılacağı fonksiyonu da 
	verir. Thread fonksiyonu herhangi bir prototipe sahip olabilir. Zaten threda sınıfı da fonksiyonları şablon olan bir sınıftır. thread sınıfının kendisi şablon sınıf değildir. 
	Ancak fonksiyonlarının bazıları şablon fonksiyonlardır. 

	Bir thread nesnes yaratıldıktan sonra mutlaka bu nesne ile join ya da detach üye fonksiyonlarının çağrılması gerekir. Eğer bu fonksiyonlar çağrılmazsa thread 
	nesnesi faaliyet alanını bitirdiğinde thread sınıfının yıkıcı fonksiyonu std::terminate fonksiyonunu çağırır. Bu fonksiyon da std::abort fonksiyonunu çağırarak 
	prosesi sonlandırır. 

	Aşağıda thread yaratma işlemine bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>

using namespace std;

void thread_proc()
{
	cout << "thread is running..." << endl;
}

int main()
{
	thread t(thread_proc);

	//...

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir therad akışı yaratılmış ve sonra hem main thread'te hem de yaralıan thread'te birer saniye beklenerek birlikte çalışma sağlanmışır. 
	Bir saniye beklemek için C++11 ile C++'a eklenen chrono kütüphanesinden (duration isimli sınıftan) faydalanılmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc()
{
	for (int i = 0; i < 10; ++i) {
		cout << "mythread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc);

	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	thread sınıfının yapıcı fonksiyonları şablon fonksiyon durumundadır. Dolayısıyşla programcı thread fonksiyonu olarak herhangi bir fonksiyonu geçirebilir. 
	Hatta örneğin fonksiyonu taklit eden (function object) yani fonksiyon çağırma operatör fonksiyonu bulunan bir sınıf nesnesini de bu bağlamda kullanabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

class MyThreadClass {
public:
	void operator ()()
	{
		for (int i = 0; i < 10; ++i) {
			cout << "mythread: " << i << endl;
			this_thread::sleep_for(milliseconds(1000));
		}
	}
};

int main()
{
	MyThreadClass mtc;
	thread t(mtc);
	
	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Thread akışının başlatılacağı fonksiyon parametreli olabilir. Bu durumda parametreler thread sınıfının yapıcı fonksiyonunda thread fonksiyonu belirtildikten snra bir liste biçiminde 
	beirtilir. Bunu sağlamak için C++11 ile birlikte "variadic template" konusu standartlara eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	for (int i = 0; i < 10; ++i) {
		cout << "main thread: " << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}

	t.join();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    join isimli üye fonksiyon thread akışı bitene kadar onu çağıran thread'i bloke ederek bekletir. Yani biz join fonksiyonunu çağırdığımızda eğer thread henüz bitmemişse bitene 
	kadar join içerisinde beklemiş oluruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	t.join();
	
	cout << "ok" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    detach fonksiyonu thread akışı ile nesne arasında ilişkiyi kesmektedir. Yani detach yaptığımızda thread akışı devam eder ancak thread nesnesi ile bu akışın bir ilgisi 
	kalmaz. Yani biz yaratttığımız thread akışının sahipliğini bırakmış oluruz. 

	Aşağıdaki kodda thread'in ekrana yazacağı yazılar görülmeeyecektir. Bunun nedenini sonraki kısımda ele alacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;

using namespace std::chrono;
void thread_proc(string name)
{
	for (int i = 0; i < 10; ++i) {
		cout << name <<':' << i << endl;
		this_thread::sleep_for(milliseconds(1000));
	}
}

int main()
{
	thread t(thread_proc, "my thread");

	t.detach();
	
	cout << "ok" << endl;

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

