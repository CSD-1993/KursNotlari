/*------------------------------------------------------------------------------------------------------------------------------------------

                                                C ve Sistem Programcıları Derneği

                                        Sistem Programlama ve İleri C Uygulamalar - I Kursu
                                                            2. Bölüm

                                                Sınıfta Yapılan Örnekler ve Özet Notlar
    
                                                        Eğitmen: Kaan ASLAN
                                                
                Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
                Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

                Aslan, K. (2025), "UNIX/Linux Sistem Programlama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                    C ve Sistem Programcıları Derneği, İstanbul.


                                (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                                    (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                                 Son Güncelleme: 18/08/2025 - Pazartesi
 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kurusumuzun bu bölümünde dikkatimizi veri yapıları ve algoritmalar konusuna yönelteceğiz. Bir sistem programcınının temel veri yapıları 
    ve algoritmalar konusunda belli düzeyde bilgi sahibi olması gerekmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aralarında fiziksel ya da mantıksal ilişki olan bir grup nesnenin oluşturduğu topluluğa "veri yapısı (data structure)" denilmektedir. 
    Veri yapısı denildiğinde tekil bir nesne değil belli bir düzen içerisinde bulunan bir grup nesne anlaşılmaktadır. Çok temel veri 
    yapıları programlama dillerinin sentaksı tarafından built-in biçimde desteklenmektedir. Örneğin C'de "diziler (arrrays)", "yapılar 
    (structures)", "birlikler (unions)" dilin sentaksı tarafından desteklenen built-in veri yapılarıdır. Ancak C tarafından doğrudan 
    desteklenen bu veri yapıları dış dünyadaki olayları modellemekte yetersiz kalmaktadır. Programcının dilin sentaksı ile doğrudan desteklenen veri yapılarını 
    kullanarak diğer veri yapılarını oluşturması gerekebilmektedir. 

    Nesne Yönelimli Programlama Dillerinde genellikle o dillerin kütüphanelerinde pek çok veri yapısı sınıflar biçiminde zaten hazır olarak 
    bulunudurlmaktadır. Örneğin C++'ın standart kütüphanesinde, C# (.NET) ve Java'nın temel kütüphanelerinde "kuyruk sistsmleri (queues)" gibi,
    "bağlı listeler (linked lists)" gibi "hash tabloları (hash tables)" gibi veri yapıları hazır bir biçimde bulunmaktadır. Halbuki C'de bu veri
    yapıları C'nin standart kütüphanesi tarafından desteklenmemektedir. Her ne kadar pek çok nesne yönelimli programlama dilinin kütüphanelerinde
    bu bölümde ele alacağımız veri yapıları zaten hazır bir biçimde bulunuyorsa da sistem programcısının bu veri yapılarını yazabilecek düzeyde 
    tanıması önemli olmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir problemi kesin çözüme götüren adımlar topluluğuna "algoritma (algorithm)" denilmektedir. Algoritma sözcüğü Fars bilim adamı Ebû Ca'fer 
    Muhammed bin Mûsâ el-Hârizmî'nin isminden hareketle (bazı yanlış anlaşılmalarla) uydurulmuş bir sözcüktür. Algoritmaların problemi kesin 
    çözüme götürmesi gerekir. Eğer söz konusu adımlar problemi kesin çözüme götürmüyor ancak iyi bir çözüm sunuyorsa buna "algoritma"
    yerine "sezgisel yöntemler (heuristic)" denilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi algoritmalar nasıl ifade edilmektedir? Örneğin "bir dizinin en büyük elemanını bulan algoritma" teknik olarak nasıl açıklanabilir?
    Algoritmaları cümlelerle sözel biçimde açıklamak hala kullanılan temel yöntemlerden biridir. Örneğin "dizini ilk elemanını en büyük kabul 
    edilip bir değişkende saklanır. Sonra diğer tüm elemanlar bir döngü içerisinde bu elemanla karşılaştırılır. Daha büyük eleman görülürse bu 
    değişkene yerleştirilir" gibi. Ancak sözel açıklama teknik anlamda belirsiz olabilmektedir. Sözükler yerine sembollerin kullanılması daha kesin 
    belirlemelerin yapılmasına olanak sağlamaktadır. İşte algoritmalar "pseude kodlar" yoluyla, "akış diyagramları" yoluyla ya da "belli bir 
    programlama dilinde yazılmış kodlar" yoluyla da ifade edilebilmektedir. Eskiden "pseudo kodlar" ve akış diyagramları daha çok kullanılırdı. 
    Artık algoritmanın ifadesi için mevcut programlama dillerinden biri seçilmektedir. Tabii her zaman sözel açıklama da sürece eşlik etmektedir. 
    
    Pekiyi algoritmaları ifade etmek için hangi programlama dili tercih edilmelidir? Çok yüksek seviyeli diller bu iş için uygun değildir. 
    Dil ne kadar alçak seviyeli olursa algoritmadaki inceliği o kadar iyi yansıtabilmektedir. Bu bakımdan C Programalama Dili tercihler arasında
    ön plandadır. Ancak son 20 yıldır algoritmaların ifade edilmesinde Java gibi, C# gibi nesne yönelimli diller de yoğun olarak kullanılmaktadır. 
    Python kanımızca algoritmaları ifade etmek için fazlaca yüksek seviyeli bir dildir. Ancak Python üzeirnden de algoritmaları anlatan kitaplar
    ve dokümanlar bulunmaktadır. Gerçekten de popüler algoritma kitaplarına bakıldığında "Algorithms in C" gibi, "Algorithms in Java" gibi, anlatımın 
    mevcut bir dil kullanılarak yapıldığı görülmektedir. Özete günümüzde algoritmalar hem sözel olarak hem de bir programlama dilinde yazılmış 
    kodlar biçiminde ifade edilmektedir. 

    Algoritmalar konusunda en bilindik kişi Donald Knuth isimli araştırmacıdır. Knuth'un ansiklopedik nitelikte üç ciltlik klasikleşmiş 
    "The Art of Compuer Programming" isimli kitabı vardır. Daha sonra Knuth bu seriye birkaç ince fasikül de eklemiştir. Knuth bu önemli 
    başvuru kitabında algoritmaları ifade etmek için kendisinin uydurduğu MIX isimli bir sembolik makine dili kullanmıştır. Daha sonra bu 
    MIX dilinin RMIX isimli RISC tabanlı biçimini de geliştirmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir problemi çözebilen pek çok alternatif algoritmalar söz konusu olabilmektedir. Bunların hangisinin daha iyi olduğunun belirlenmesi 
    gerekir. Tabii bunun için bir "iyilik ölçütü" tespit edilmelidir. Algoritmaları kıyaslamak için ölçüt ne olmalıdır? Kıyaslama için iki 
    önemli ölçüt "hız" ve "kaynak kullanımıdır". Ancak baskın ve default ölçüt hızdır. Yani genellikle hangi alternatif algoritma daha hızlı 
    sonuç veriyorsa o algoritma tercih edilmektedir. Tabii bazen kısıtlı kaynakların söz konusu olduğu durumlarda programcı hız yerine kaynak 
    kullanımı (tipik olarak bellek kullanımı)" ölçütünü de ön plana alabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    İki algoritmanın hızlarını kıyaslamak kolay bir işlem değildir. Çünkü algoritmada koşula dayalı işlemler yapılyor olabilr. Bu koşulların 
    sağlanması ya da sağlanmaması girdilere bağlı olabilir. Algoritmaların önemli bir bölümü dizi gibi veri yapıları üzerinde işlemler yapmaktadır.
    Bu durumda örneğin dizinin dağılımı hız üzerinde etkili olabilmektedir. 

    Algoritmaların hızlarını kıyaslamak için "simülasyon yöntemi" kullanılabilir. Bu yöntemde alternatif algoritmaların kodları yazılır. 
    Bu algoritmalar rastgele girdilerle çok fazla kez çalıştırılır, bir ortalama zaman hesaplanır. Simülasyon yöntemi bazen başvurulan yardımcı 
    yöntemlerden biridir. Ancak simülasyon yöntemini uygulamak oldukça zordur. Her algoritmayı simüle edecek kodun yazılması ve bunun çok kez 
    çalıştırılması zor bir süreçtir. Bunun yerine tamamen cebrik yöntemlerin kullanılması daha uygundur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                58. Ders 20/01/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmaların cebrik yöntemlerle hızlarının ve kaynak kullanımlarının analizine ilişkin sürece "algoritma analizi (analysis of algorithms)"
    denilmektedir. Pekiyi algoritma analizi nasıl yapılmaktadır? Bunun temel yolu algoritmanın çözümü için gereken işlem sayısının bulunmasıdır. 
    Tabii bu işlem sayısı girdi büyüklüğüne bağlı olarak parametrik bir biçimde hesaplanacaktır. Ancak yukarıda da belirttiğimiz gibi algortimadaki
    işlemlerin sayısı girdilere bağlı olarak da değişebilmektedir. (Tabii aslında her işlem aynı sürede yapılmayabilir. Örneğin pek çok işlemcide 
    çarpma işlemi toplama işlemine göre çok daha yavaş yapılmaktadır.) Örneğin bir dizi içerisinde var olduğunu bildiğimiz belli bir değerin kaç 
    işlemde bulunacağını hesaplamak isteyelim. Algoritma şöyle olsun:

    int a[N];

    for (int i = 0; i < N; ++i)
        if (a[i] == VAL)
            break;        /* bulundu */
                
    Burada işlem sayısına şu işlemler dahildir:

    int i = 0
    i < N
    ++i
    a[i] == VAL

    Ancak burada aranacak olan VAL değerinin dizinin kaçıncı elemanında olduğu diziye bağlıdır. Algoritmaya bağlı değildir. İşte bu tür durumlarda
    algoritma analiz edilirken tipik olarak iki durum için hesaplama yapılır:

    1) En kötü durum analizi (worst case analyisis)
    2) Ortalama durum analizi (average case analysis)

    En iyi durum analizi de söz konusu olabilirse de pratikte çok iyimser bir yaklaşım olduğu için uygulanmamaktadır. 

    Yukarıdaki sıralı aramamın en kötü durum analizini yapmaya çalışalım. En köü durumda eleman dizinin son elemanı olarak bulunur. Böylece
    en kötü durumdaki işlem sayısı 1 + 3N kadardır. Bu algoritmadaki ortalama işlem sayısı aranacak değerin 1'inci, 2'inci, 3'üncü, ... N'inci 
    indekslerde bulunması durumunun toplamının N'e bölünmesiyle elde edilebilir. Bunu matematiksel olarak şöyle yazabiliriz:

    1 + (3 * (1 + 2 + 3 + ... + N) / N)

    1'den N'e kadar sayıların toplamı N * (N + 1) olduğuna göre buradan şu değer elde edilir:

    1 + (3 * (N + 1) / 2)

    Tabii bu tür hesaplamalarda bizim sabit olmayan kısmın artışına bakmamız doğru olur. Buradaki 1 toplamı, 3 çarpımı ve 2'ye bölüm sabittir. 
    Bu tür durumlarda bizim için önemli olan bu N değerinin artması ile algoritmanın davranışıdır. 

    Algoritmalar dünyasında girdi büyüklüğüne (örneğin dizinin uzunluğuna) bağlı olarak algoritmada yapılan işlemlerin sayısını elde etmekte kullanılan 
    ifadelere "algoritmanın karmaşıklığı (complexity of algorithms)" denilmektedir. Yani algoritmanın karmaşıklığı girdi büyüklüüne bağlı 
    olarak algortimanın hızının betimlenmesi için kullanılan ifadelere denilmektedir. Örneğin yukarıdaki sıralaı aramanın karmaşıklığı 
    1 + (3 * (N + 1) / 2) olarak belirtilebilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir algoritmanın en kötü durum ve özellikle de ortalama durumdaki karmaşıklığının (yani girdiye dayalı olarak işlem sayısının) hesaplanması
    oldukça zor olabilmektedir. Bu nedenle genellikle karmaşıklık için kesin bir değer bulma yerine karmaşıklıkları kategorilere ayırıp karşılaştırma
    yoluna gidilmektedir. Bu tür kategorik karşılaştırmalar her ne kadar algoritmanın aldığı zaman konusunda ince bir değer vermese de onun 
    karakteri hakkında kısa sürece içerisinde önemli bir bilgi vermektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmaları kategorik olarak sınıflandırmak için "asimtotik notasyonlar" denilen özel notasyonlar kullanılmaktadır. Asimtotik notasyonlar
    aslında matematikte programlamanın dışında ele alınıp kullanılmış olan tekniklerdir. Başka bir deyişle asimtoto,k notasyonlar bir fonksiyonun 
    büyüme karakteristiği ile ilgili çalışmalardan kaynaklanmaktadır. Ancak bu konu algoritma analizinde önemli bir uygulama alanı bulmuştur. 

    Algoritma karmaşıklığında kullanılan asimtotik notasyonlar şunlardır:

    - Big O Notasyonu
    - Büyük Teta Notasyonu
    - Büyük Omega Notasyonu
    - Küçük o Notasyonu

    Ancak Big O notasyonu en çok kullanılan notasyondur. 

    Bu notasyonlar aslında bir grup fonksiyonu karakterize etmek için düşünülmüştür. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Big O notasyonu aşağıdaki gibi belirtilmektedir:

    f(x) = O(g(x))

    Burada f(x) ve g(x) iki fonksiyondur. Notasyondaki eşittir karakteri eleştirilmektedir. Buradaki eşittir karakteri aslında matematikteki 
    eşitliği anlatmamaktadır. Burada aslında "f(x) fonksiyonunun Big O notasyonuna göre g(x) kategorisinden olduğu" anlatılmaktadır. Örneğin:

    3x = O(X^2)
    5X^2 = O(X^2)

    Burada 3x ve 5X^2 fonksiyonları big O notasyonuna göre X^2 kategorisindendir.

    Big O notasyonunun matematiksel sembollerle biçimsel (formal) açıklaması biraz ayrıntılıdır. Bu açıklamalar için Ebook klasöründeki 
    "Algorithms and Complexity" kitabının Birinci bölümüne başvurabilirsiniz. Biz burada önce biçimsel olmayan açıklama yapacağız. Sonra
    biçimsel açıklama üzerinde duracağız.

    Big O notasyonunda kategori olarak O(gx(x)) ifadesiyle belirtilmiş olan fonksiyon ile üstel bakımdan aynı olan ve bundan küçük olan tüm 
    fonksiyonlar kstedilmektedir. Örneğin O(x^2) kategorisi üssü en fazla iki olan tüm fonksiyonları ve üssü bundan küçük olan tüm fonksiyonları
    belirtmektedir. Örneğin aşağıdaki fonksiyonların hepsi O(x^2) kategorisine sahiptir, dolayısıyla f(x) = O(x^2) biçiminde ifade edilebilir:

    f(x) = 100
    f(x) = 3x
    f(x) = 3x^2
    f(x) = 100x^2 + 80x +5
    f(x) = 2X^2 - 5x - 8

    Burada x^2'nin katsayısının bir önemi olmadığına dikkat ediniz. 

    Başka bir deyişle O(x^2) kategorisi k x^2 ve x^1 ve sabitin tüm toplamlarına ilişkin fonksiyonları belirtmektedir. Benzer biçimde 
    O(x) kategorisine ilişkin bazı fonksiyonlar şunlardır:

    f(x) = 3x
    f(x) 0 100x - 5
    f(x) = x - 1
    f(x) = 10

    Burada da x'in katsayısının bir önemi yoktur.

    Big O notasyonunda O(1) karmaşıklığına sahip (Burada 1 yerine başka bir sayıda kullanılabilir. Ancak en düşük sayı 1 olduğu için 1 tercih edilmektedir. 
    Yani O(5) ile O(1) aynı anlamdadır.) fonksiyonlardan bazıları şunlardır:

    f(x) = 123
    f(x) = 1234567
    f(x) = 1

    Big O notasyonunda g(x) fonksiyonundaki çarpanın önemli olmadığına dikkat ediniz. Örneğin O(x^2) kategorisi ile O(3x^2) kategorisi 
    arasında hiçbir farklılık yoktur. Benzer biçimde bunlarla O(5X^2 + 2) kategorisi arasında da bir farklılık yoktur.    Benzer biçimde 
    Bu nedenle kategoriler belirtilirken gereksiz biçimde g(x) fonksiyonunda çarpan ve toplam değerler belirtilmez. 

    Big O natsyonunun biçimsel açıklaması şöylşe yapılabilir: 

    f(x) = O(g(x)) (x → ∞) if ∃ C, x0 öyle ki |f(x)| < Cg(x) tüm x > x0 değerleri için

    Burada şu belirtilmektedir: f(x) = O(g(x)) olabilmesi için |f(x)| < Cg(x) eşitliğini sağlayabilecek bir C değerinin bulunması gerekir. 
    Örneğin 3x^2 + 5x + 2 = O(x^2) yazılabilir. Çünkü burada örneğin C = 5 gibi bir C değeri bulunabilir. Böylece 5X^2 belli bir x0 değerinde 
    sonra her zaman 3X^2 + 5x + 2 değerinden büyük kalacaktır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmaları kıyaslamak için iyiden kötüye doğru çeşitli Big O kategorileri kullanılmaktadır. Bu kategoriler şunlardır (Burada x yerine N
    gösterimini kullanacağız):

    O(1)                                    Sabit Karmaşıklık
    O(log log N)                            Çifte Logaritmik Karmaşıklık
    O(log N)                                Logaritmik Karmaşıklık
    O((log N)^c) c > 1 olmak üzere            Polylogaritmik Karmaşıklık
    O(N^c) c < 0 < 1 olmak üzere            Oransal Kuvvet Karmaşıklığı
    O(N)                                    Doğrusal Karmaşıklık
    O(N log N)                                N Log N karmaşıklığı
    O(N^2)                                    Karesel Karmaşıklık
    O(N^3)                                    Küpsel Karmaşıklık
    O(N^c)                                    Polinomsal Karmaşıklık
    O(c^N)    c > 1 olmak üzere                Üstel Karmaşıklık
    O(N!)                                    Faktöriyel Karmaşıklığı

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmaları Big O notasyonuna göre kategorik olarak karşılaştırmak kolaydır. Alternatif algoritmaların kategorileri belirlenir. 
    Hangi kategorinin diğerinden daha iyi olup olmadığına bakılır. Aynı kategoriye giren algoritmalar arasında bir farklılık söz konusu olsa da
    bu farklılık kategorik bir farklılık değildir. Biz aynı Big O kategorisindeki algoritmaları aynı karakterde kabul edebiliriz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir algoritmanın yukarıda belirttiğimiz Big O kategorisi nasıl tespit edilir? Algoritmanın girdisinin N olduğunu varsayalım. 
    Örneğin N bir dizinin uzunluğu olabilir. Bazı kategorilerin tespiti şöyle yapılabilir:

    - Tekil ifadeler içeren ve N değrine bağlı olmayan sabit uzunluklu döngüler içeren algoritmalar O(1) karmaşıklıktadır. Örneğin üçgenin 
    alanın hesaplanması, dikdörtgenin çevresinin hesaplanması, bir yılın artık yıl olup olmadığının tespit edilmesi gibi algoritmalar
    O(1) yani sabit karmaşıklıktadır. Sabit karmaşıklık en iyi karmaşıklık kategorisidir. Örneğin bir problemde "bunun için sabit karmaşıklığa
    sahip bir algoritma kullanın" ifadesi "N değerine dayalı döngü kullanmadan tekil ifadelerle çözümü bulun" anlamına gelmektedir. Örneğin
    dizinin bir elemanına erişilmesi sabit karmaşıklıklı bir işlemdir. 

    - Bir algoritmada bir döngü varsa ancak döngü N'in logaritması kadar dönüyorsa (tabii algoritma tekiş ilemler de içerebilir) bu algoritma 
    O(log N) karmaşıklıktadır. Örneğin "ikili arama (binary search)" algoritmasında N değeri arttıkça döngü log2 N kadar artmaktadır. 

    - Bir algoritma N'e dayalı tekil döngüler içeriyorsa ve tekil işlemler içeriyorsa bu algoritma O(N) karmaşıklıktadır. Bu tür karmaşıklıklara
    sözel olarak "doğrusal karmaşıklık" da denilmektedir. Örneğin "dizinin en büyük elemanının bulunması", "dizinin aritmetik ortalamasının 
    bulunması", "dizide bir elemanın bulunması" gibi algoritmalar O(N) karmaşıklıktadır. Sıralı bir dizi bulunyor olsun. Biz de bu sıralı dizide
    belli bir elemanı bulmak isteyelim. İkili arama (binary search) O(log N) karmaşıklıkta, sıralı arama O(N) karmaşıklıktadır. O halde ikili 
    arama sıralı aramdan daha iyidir.

    - O(N log N) karmaşıklıkta iç içe iki döngü bulunabilir. Dıştaki döngü N'e dayalı dönerken içteki dönü N'nin logaritmasına dayalı dönmektedir. 
    Tabii algoritma başka N'e dayalı döngüler ve tekil işlemler içerebilir. Uick Sort gibi, Heap sort gibi kaliteli sort algoritmaları 
    O(N log N) karmaşıklıktadır. 

    - N'e dayalı iç içe iki döngü varsa (tabii ayrık N'e dayalı döngüler ve tekil işlemler de olabilir) bu tür algoritmalar O(N^2) karmaşıklıktadır. 
    Örneğin "boubble sort", "selection sort" gibi algoritmalar O(N^2) karmaşıklıktadır. Bu karmaşıklığa "karesel karmaşıklık" da denilmektedir. 
    Bu durumda örneğin "selection sort" algoritması "quick sort" algoritmasından daha kötüdür.

    - N'e dayalı iç içe üç döngü varsa (tabii N'e dayalı iç içe döngüler, tekil döngüler ve tekil işlemler de olabilir) bu tür algoritmalar
    O(N^3) yani küpsel karmaşıklığa sahiptir. Örneğin tipik matris çarpımı küpsel karmaşıklığa sahiptir. Ancak karesel kamaşıklığa sahip 
    çözümleri de vardır. 

    - İç içe k tane döngü içerebilen tüm algoritmalara genel olarak "polinomsal karmaşıklıktaki (polynomial complexity) algortimalar" denilmektedir. 

    - Alt küme işlemlerine ilişkin algoritmalar tipik olarak O(c^n) yani üstel karmaşıklıktadır. Bir kümenin tüm alt kğmelerinin sayısının 2^n
    olduğunu anımsayınız. 

    - Bazı graf ptoblemleri O(N!) yani faktöriyelsel karmaşıklıktadır. Örneğin "gezgin satıcı problemi (traveling salesmen problem)" faktöriyelsel
    karmaşıklıktadır. Faktöriyelsel karmaşıklık en kötü karmaşıklık kategorisidir. 

    Üstel karmaşıklığa ve faktöriyelsel karmaşıklığa "polinomsal olmayan (nonpolynomial)" karmaşıklar denilmektedir. Polinomsal olmayan karmaşıklık 
    kısaca "NP karçaıklık" olarak da ifade edilmektedir. NP karmaşıklıktaki problemler bugünkü bilgisayarlarda bile binlerce sene zaman alabilecek 
    boyutlara gelebilmektedir. Pek çok NP algoritma için polinomsal karmaşıklığa sahip daha makul algoritmalar aranmaktadır. Ancak bu konuda
    önemli başarılar elde edilmemiştir. Pekiyi NP karmaşıklıktaki problemler için neler yapılabilir? İşte bu alanda "sezgisel yöntemler (heuristic)"
    denilen yöntemler kullanılmaktadır. Anımsanacağı gibi "sezgisel yöntemler (heuristic)" en iyi çözümü hedeflemeyen ancak tatmin edici bir çözümü 
    makul bir zaman içerisinde bulmayı sağlayan yöntemlerdir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritma analizinde en çok Big O notasyonu kullanılmaktadır. Big O notasyonu aslında bir üst sınır belirtmektedir. Algoritmalarda da
    üst sınır tespit etmek önemli bir konudur. 
    
    Büyük omega notasyonu Big O notasyonunun tersi gibidir. Yani bu notasyondan amaç alt sınır tespit etmektir. Örneğin Ω(x^2) kategorisi demek 
    x^2 den daha yüksek üslü polinomların kategorisi demektir. Örneğin Ω(x^2) kategorisine ilişkin bazı fonksiyonlar şunlardır:

    3x^3 + 4x = Ω(x^2) 
    3x^5 = Ω(x^2) 
    7x^5 + 6x^2 + 4x = Ω(x^2) 

    3x^2 gibi bir fonksiyonun Ω(x^2) kategorisinde olamayacağınz dikkat ediniz. Görüldüğü gibi Büyük omega notasyonu "alt sınır belirtmektedir".
    Yukarıda da belirttiğimiz gibi algoritmalarda alt sınır yerine üst sınır tespit etmek genel olarak daha önemlidir. 

    Büyük Teta notasyonu tam sınır belirtmek için kullanılmaktadır. Yani polinomun derecesi büyük teta ifadesinden büyük ya da küçük olamaz. 
    Ancak katsayılar farklı olabilir. Örneğin Θ(x^2) için aşağıdaki kategoriler geçerlidir:

    3x^2 = Θ(x^2)
    7x^2 + 4x = Θ(x^2)
    10x^2 + 5x + 2= Θ(x^2)

    Ancak aşağıdaki kategoriler Θ(x^2) için geçerli değildir:

    7x
    5x^3 
    7x^4 + 3X^2 + 2
    100
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    C'de "diziler", "yapılar" ve "birlikler" built-in veri yapılarıdır. Yani dilin sentaksı taarafından birnci elde desteklenmektedir. 
    Ancak bu veri yapıları bazı uygulamaları gerçekleştirmek için yetersiz kalmaktadır. İşte bu bölümde C'nin sentaksı tarafından doğrudan 
    desteklenmeyen ancak uygulamalarda sıkça karşılaşılan veri yapılarını inceleyeceğiz. Bu veri yapıları pek çok nesne yönelimli programlama
    dilinin temel kütüphanelerinde birer sınıf biçiminde bulunmaktadır. Yani eğer C++, Java ve C# fillerle çalışıyorsanız burada göreceğimiz
    veri yapıları zaten o dilelrin temel kütüphanlerinde hazır bir biçimde bulunmaktadır. Ancak ne olursa olsun bu veri yapılarının nasıl 
    çalıştığının ve nasıl gerçekleştirildiğinin sistem programcıları tarafından bilinmesi gerekmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Veri yapıları dünyasında bir süredir çok karşılaşılan terimlerden biri de "abstract data type" terimidir. Bu terimi Türkçe'ye "soyut veri 
    türü" biçiminde çevirebiliriz. Abstract data type denildiğinde Belli bir veri yapısını gerçekleştiren data ve fonksiyon grubu anlaşılmalıdır. 
    Burada "abstract" sözcüğü "soyutlama" yani "aytrıntıların göz ardı edilerek işlevlere dikkatin yöneltilmesi" anlamına gelmektedir. Abstract 
    data type denildiğinde bir veri yapısı üzerinde işlem yapan API arayüzü anlaşılır. Tipik olarak bu kavran nesne yönelimli programlama
    tekniğinde bir sınıf ve o sınıfın desteklediği arayüz biçiminde oluiturulmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan veri yapılarından biri "dinamk dizi (dynamic array)" denilen veri yapısıdır. Dinamik dizi "gerektiğinde büyütülen" dizi
    anlamına gelmektedir. Bu veri yapısını kullanan programcı veri yapısına bir eleman eklediğinde ekleme fonksiyonu eğer gerekiyorsa tahsis 
    etmiş olduğu diziyi büyütmektedir. Ancak veri yapısını kullanan kişi işin bu kısmıyla uğraşmamaktadır. Bu veri yapısı C++'ın standart 
    kütüphanesinde "vector" ismi ile C# ve Java ortamlarının temel kütüphanelerinde "ArrayList" ismiyle bulunmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Dinamik dizilerin gerçekleştirilmesinde önemli olan birkaç nokta vardır. Bunlardan en önemlisi dinamik dizi için ayrılan alan yetmediğinde
    dizinin ne kadar büyütüleceğidir. Diziyi birer birer büyütmek iyi bir fikir değildir. Çünkü dinamik tahsisatlar yavaş olma eğilimindedir. 
    Genellikle büyütme "eskisinin iki katı olacak" biçimde yapılmaktadır. Böylece büyütme (reallocation) dizi uzunluğuna göre logaritmik 
    karmaşıklıkta (yani O(log N) karmaşıklıkta) yapılmış olur. Gerçekleştirimde programcının o anda dinamk dizi içerisinde kaç elemanın bulunduğunu 
    ve o anda dizi için tahsis edilen elemanın kaç eleman uzunluğunda olduğunu tutması gerekir. Dizide var olan eleman sayısına "count" ya da
    "size" denilmektedir. Dizi için tahsis edilmiş olan eleman sayısına ise genellikle "capacity" debilmektedir. 
    
    Dinamik dizinin sonuna eleman eklerken eleman count (ya da size) ile belirtien indekse eklenir ve count değer bir artılır. count değeri 
    capacity değerine ulaştığında yeniden tahsisat (reallocation) yapılarak dinamik dizi büyütülmelidir. Dinamik dizilerde araya eleman da
    benzer biçimde eklenmektedir. Genel olarka dinamik dizilerin gerçekleştirimlerinde eleman silindiğinde kapasite azaltılması yapılmamaktadır.

    Dinamik dizilerin gerçekleştirilmesinde kullanıcılara sunulacak temel işlevler şunlardır:

    - Dinamik dizinin yaratılması
    - Dinamik dizinin yok edilmesi
    - Dinamik dizinin sonuna eleman eklenmesi
    - Araya elemanın insert edilmesi
    - Count ve capacity değerleriin dışarıya verilmesi
    - Elemanların get ve set edilmesi
    - Belli bir indeksteki elemanın silinmesi
    - Dizideki tüm elemanların silinmesi
    - Capacity değerinin büyütülmesi
    - Capacity değerinin count değerine çekilmesi

    Genel olarak dinamik büyütülen dizilerde bir elemanın silinmesi ya da tüm elemanların silinmesi capaciry değerinde bir değişiklik 
    yaratmamaktadır. Genellikle bu tür veri yapılarında capacity değerinin büyütülmesine izin verilir. Ancak küçültülmsine izin verilmez. 
    Ancak özel bir durum olarak capacity değeri count değerine çekilebilmektedir. 

    Aşağıdaki dinamik dizilerin gerçekleştirimine ilişkin bir örnek verilmiştir. Bu örnekte bazı küçük fonksiyonlar makro yerine static inline 
    fonksiyon biçiminde başlık dosyasının içerisinde tanımlanmıştır.

-------------------------------------------------------------------------------------------------------------------------------------------*/

/* dynamicarray.h */

#ifndef DYNAMICARRAY_H_
#define DYNAMICARRAY_H_

/* Symbolic Constants */

#define DARRAY_DEF_CAPACITY        8
#define DARRAY_FAILED            ((size_t)-1)

/* Type Declaratrions */

typedef int DATATYPE;

typedef struct tagDARRAY {
    DATATYPE *darray;
    size_t capacity;
    size_t count;
} DARRAY, *HDARRAY;

/* Function Prototypes */

HDARRAY create_darray(void);
void destroy_darray(HDARRAY hdarray);
size_t add_darray(HDARRAY hdarray, DATATYPE val);
size_t multiadd_darray(HDARRAY hdarray, const DATATYPE *vals, size_t size);
size_t addp_darray(HDARRAY hdarray, const DATATYPE *val);
size_t insert_darray(HDARRAY hdarray, size_t index, DATATYPE val);
size_t remove_darray(HDARRAY hdarray, size_t index);
size_t reserve_darray(HDARRAY hdarray, size_t newcapacity);

/* inine function definitions */

static inline size_t capacity_darray(HDARRAY hdarray)
{
    return hdarray->capacity;
}

static inline size_t count_darray(HDARRAY hdarray)
{
    return hdarray->count;
}

static inline DATATYPE get_darray(HDARRAY hdarray, size_t index)
{
    return hdarray->darray[index];
}

static inline void set_darray(HDARRAY hdarray, size_t index, DATATYPE val)
{
    hdarray->darray[index] = val;
}

static inline void setp_darray(HDARRAY hdarray, size_t index, const DATATYPE *val)
{
    hdarray->darray[index] = *val;
}

static inline void getp_darray(HDARRAY hdarray, size_t index, DATATYPE *val)
{
    *val = hdarray->darray[index];
}

static inline void clear_darray(HDARRAY hdarray)
{
    hdarray->count = 0;
}

#endif

/* dynamic.arry.c */

#include <stdio.h>
#include <stdlib.h>
#include "dynamicarray.h"

static int reallocate(HDARRAY hdarray, size_t newcapacity);

HDARRAY create_darray(void)
{
    HDARRAY hdarray;

    if ((hdarray = (HDARRAY)malloc(sizeof(DARRAY))) == NULL)
        return NULL;

    if ((hdarray->darray = (DATATYPE *)malloc(sizeof(DATATYPE) * DARRAY_DEF_CAPACITY)) == NULL) {
        free(hdarray);
        return NULL;
    }

    hdarray->capacity = DARRAY_DEF_CAPACITY;
    hdarray->count = 0;

    return hdarray;
}

void destroy_darray(HDARRAY hdarray)
{
    free(hdarray->darray);
    free(hdarray);
}

size_t add_darray(HDARRAY hdarray, DATATYPE val)
{
    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
        return DARRAY_FAILED;

    hdarray->darray[hdarray->count++] = val;

    return hdarray->count - 1;
}

size_t multiadd_darray(HDARRAY hdarray, const DATATYPE *vals, size_t size)
{
    if (hdarray->count + size > hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2 + size) == -1)
        return DARRAY_FAILED;

    memmove(hdarray->darray + hdarray->count, vals, sizeof(DATATYPE) * size);
    hdarray->count += size;

    return hdarray->count - 1;
}

size_t addp_darray(HDARRAY hdarray, const DATATYPE *val)
{
    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
        return DARRAY_FAILED;

    hdarray->darray[hdarray->count++] = *val;

    return hdarray->count - 1;
}

size_t insert_darray(HDARRAY hdarray, size_t index, DATATYPE val)
{
    if (index > hdarray->count)
        return DARRAY_FAILED;

    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
        return DARRAY_FAILED;

    memmove(hdarray->darray + index + 1, hdarray->darray + index, (hdarray->count - index) * sizeof(DATATYPE));
    hdarray->darray[index] = val;
    ++hdarray->count;

    return index;
}

size_t insertp_darray(HDARRAY hdarray, size_t index, const DATATYPE *val)
{
    if (index > hdarray->count)
        return DARRAY_FAILED;

    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
        return DARRAY_FAILED;

    memmove(hdarray->darray + index + 1, hdarray->darray + index, (hdarray->count - index) * sizeof(DATATYPE));
    hdarray->darray[index] = *val;
    ++hdarray->count;

    return index;
}

size_t remove_darray(HDARRAY hdarray, size_t index)
{
    if (index >= hdarray->count)
        return DARRAY_FAILED;
        
    memmove(hdarray->darray + index, hdarray->darray + index + 1, (hdarray->count - index - 1) * sizeof(DATATYPE));
    --hdarray->count;

    return index;
}

size_t reserve_darray(HDARRAY hdarray, size_t newcapacity)
{
    if (newcapacity <= hdarray->capacity)
        return 0;
    
    if (reallocate(hdarray, newcapacity) == -1)
        return 0;

    return newcapacity;
}

static int reallocate(HDARRAY hdarray, size_t newcapacity)
{
    DATATYPE *new_darray;

    if ((new_darray = (DATATYPE *)realloc(hdarray->darray, sizeof(DATATYPE) * newcapacity)) == NULL)
        return -1;

    hdarray->darray = new_darray;
    hdarray->capacity = newcapacity;

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                            60. Ders 27/01/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Veri yapıları dünyasında aralarında öncelik sonralık ilişkisi olan veri yapılarına "liste (list)" denilemektedir. Örneğin bu tanıma göre 
    diziler de "liste tarzı" veri yapılarıdır. Liste tarzı veri yapılarının en yaygın kullanılanlarında biri "bağlı liste (linked list)" 
    denilen veri yapısıdır. Önceki elemanının sonraki elemanın yerini gösterdiği dolayısıyla elemanların ardışıl olma zorunluluğunun ortadan 
    kaldırıldığı dizilere "bağlı liste" denilmektedir. Dizi elemanlarının bellekte fiziklsel olarak ardışıl biçimde bulunduğunu anımsayınız. 
    Bağlı listeler adeta "elemanları bellekte ardışıl olmayan diziler" gibi düşünülebilir. 

    Bağlı listelerin elemanlarına "düğüm (node)" denilmektedir. Biz de kursumuzda bağlı liste elemanlarına "düğüm" ya da "eleman" diyeceğiz. 
    Bağlı listelerde her düğüm hem elemanın değerini hem de sonraki düğümün yerini tutar. Böylece ilk düğümün yeri de biliniyorsa liste 
    elemanlarının hepsine bir döngü ile erişilebilmektedir. Örneğin:

    head ----> node ---> node ---> node ----> node (NULL)

    Burada head ilk düğümün yerini tutmaktadır. 

    Bağlı listelerin düğümleri tipik olarak yapı ile temsil edilmemktedir. Yapının elemanları düğüme ilişkin değerlerin yanı sıra sonraki
    düğümün adresini tutan bir göstericiden oluşur. Örneğin:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    Burada yapının val elemanı düğüm içerisinde tutulan değeri, next ise sonraki düğümün yerini tutmaktadır.

    Bağlı listelerde ilk düğümün yeri bir biçimde bir gösterici tutulmalıdır. Genellikle ilk düğünüm yerini tutan göstericiye 
    "head göstericisi (head pointer)" denilmektdir. Örneğin:

    NODE *head;  /* ilk elemanın yeri */

    Her ne kadar bağlı listelerde ilk düğümün yerini tutmak yeterliyse de listenin sonuna hızlı ekleme yapılabilmesi için genellikle son 
    düğümün yeri de tutulmaktadır. Son elemanın yerini tutan göstericiye de genellikle "tail göstericisi (tail pointer)" denilmektedir.
    
    NODE *head;  /* ilk elemanın yeri */
    NODE *tail;  /* son elemanın yeri */

    Tipik olarak bağlı listenin son düğümünün next göstericisinde NULL adres bulunur. Bu durum listenin sonuna gelindiğini belirtmektedir. 
    Bağlı listenin tüm elemanlarını gözden geçirmek basit döngüyle yapılabilir:

    NODE *node;
    ...

    node = head;
    while (node != NULL) {
        ...
        node = node->next;
    }

    Tabii bu dolaşımı for döngüsüyle de yapabiliriz:

    for (NODE *node = head; node != NULL; node = node->next) {
        ...
    }

    Her düğümün yalnızca sonraki düğümün değil aynı zamanda önceki düğümün de yerini tuttuğu bağlı listelere "çift bağlı listeler (double 
    linked list)" denilmektedir. Çift bağlı listelerde belli bir düğümün adresini biliyorsak yalnızca ileriye doğru değil, geriye doğru
    da gidebiliriz. Çift bağlı listelerin düğümleri de aşağıdaki gibi bir yapıyla temsil edilebilir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
        struct tagNODE *prev;
    } NODE;

    Çift bağlı listelerin bir düğümünün bellekte daha fazla yer kaplayacağına dikkat ediniz. Çift bağlı listelerin tek bağlı listelere göre 
    en önemli özelliği "adresi bilinen bir düğümün" silinebilmesidir. Tek bağlı listelerde bu durum mümkün değildir. Uygulamalarda buna çok 
    sık gereksinim duyulmaktadır. 

    Eğer bir bağlı listede son eleman ilk elemanı gösteriyorsa bu tür bağlı listelere de "döngüsel bağlı listeler (circular linkes lists)" 
    denilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bağlı listelere neden gereksinim duyulmaktadır? Diziler varken bağlı listelere gerek var mıdır? Dizilerle bağlı listeler arasındaki 
    farklılkları, benzerlikleri ve bağlı listelere neden gereksinim duyulduğunu birkaç madde ile açıklayabiliriz:

    1) Diziler ardışıl alana gereksinim duymaktadır. Ancak belleğin bölündüğü (fragmente olduğu) durumlarda bellekte yeteri kadar küçük boş 
    alanlar olduğu halde bunlar ardışıl olmadığı için dizi tahsisatı mümkün olamamaktadır. Bu tür durumlarda ardışıllık gereksinimi olmayan 
    bağlı listeler tercih edilebilmektedir. Özellikle heap gibi bir alanda çok sayıda dinamik diziler bellek kullanımı açısından verimsizliğe 
    yol açabilmektedir. Bu dinamik diziler zamanla büyüdükçe birbirini engeller hale gelebilmektedir. İşte uzunluğu baştan belli olmayan çok 
    sayıda dizinin oluşturulacağı durumlarda dinamik dizi yerine bağlı listeler daha uygun bir tercih haline gelmektedir. Dinamik dizilerde 
    dinamik dizinin büyütülmesi yavaş bir işlemdir. Çünkü büyütme sırasında bloklar yer değiştirebilmektedir. 

    2) Dizilerde araya eleman ekleme (insert etme) ve aradaki bir elemanı silme dizinin kaydırılmasına ("expand" ve "shrink" edilmesine) yol 
    açacağından yavaş bir işlemdir. Teknik olarak dizilerde araya eleman ekleme ve eleman silme O(N) karmaşıklıkta bir işlemdir. Halbuki bağlı 
    listelerde eğer düğümün yeri biliniyorsa bu işlem O(1) karmaşıklıkta (yani döngü olmadan tekil işlemlerle) yapılabilmektedir. O halde 
    araya eleman eklemenin ve aradan eleman silmenin çok yapıldığı sistemlerde diziler yerine bağlı listeler tercih edilebilmektedir. 

    3) Bağlı listelerde belli bir indeksteki elemana erişmek O(N) karmaşıklıkta bir işlemdir. Halbuki dizilerde elemana erişim O(1) karmaşıklıkta 
    yani çok hızlıdır. O halde belli bir indeks değeri ile elemana erişimin yoğun yapıldığı durumlarda bağlı listeler yerine diziler tercih 
    edilebilir. 

    4) Bağlı listeler toplamda bellekte daha fazla yer kaplama eğilimindedir. Çünkü bağlı listenin her düğümü sonraki (ve duruma göre önceki)
    düğünüm yerini de tutmaktadır. 

    O halde bağlı listeler tipik olarak şu durumlarda dizilere tercih edilmelidir:

    - Araya eleman eklemenin ve aradan eleman silmenin çok yapıldığı durumlarda
    - Uzunluğu baştan belli olmayan çok sayıda dizinin kullanıldığı durumlarda
    - İndeks yoluyla erişimin az yapıldığı durumlarda
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Soyut bir veri türü (abstract data type) olarak bağlı listeler üzerinde şu işlemlerin yapılması beklenmektedir:

    - Bağlı listenin başına ve sonuna eleman eklenmesi
    - Bağlı listenin dolaşılması ve belli bir indeksteki elemanın elde edilmesi
    - Adresi bilinen bir düğümün önüne ya da arkasına eleman insert edilmesi
    - Adresi bilinen bir düğümün silinmesi

    Aşağıda çift bağlı listelerin gerçekleştirilmesine ilişkin bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
    struct tagNODE *prev;
} NODE;

typedef struct tagLLIST {
    NODE *head;
    NODE *tail;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val);
void remove_node(HLLIST hllist, NODE *node);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *val);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head = hllist->tail = NULL;
    hllist->count = 0;

    return hllist;
}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (hllist->head != NULL)                     /* is list is empty? */
        hllist->tail->next = new_node;
    else
        hllist->head = new_node;

    new_node->prev = hllist->tail;
    new_node->next = NULL;

    hllist->tail = new_node;
    ++hllist->count;

    return new_node;
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (hllist->head != NULL)                     /* is list is empty? */
        hllist->tail->next = new_node;
    else
        hllist->head = new_node;

    new_node->prev = hllist->tail;
    new_node->next = NULL;

    hllist->tail = new_node;
    ++hllist->count;

    return new_node;
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    new_node->next = hllist->head;
    new_node->prev = NULL;

    if (hllist->head == NULL)
        hllist->tail = new_node;
    else
        hllist->head->prev = new_node;

    hllist->head = new_node;
    ++hllist->count;

    return new_node;
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    new_node->next = hllist->head;
    new_node->prev = NULL;

    if (hllist->head == NULL)
        hllist->tail = new_node;
    else
        hllist->head->prev = new_node;

    hllist->head = new_node;
    ++hllist->count;

    return new_node;
}

NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node != hllist->tail)
        node->next->prev = new_node;
    else
        hllist->tail = new_node;

    new_node->next = node->next;
    node->next = new_node;
    new_node->prev = node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node != hllist->tail)
        node->next->prev = new_node;
    else
        hllist->tail = new_node;

    new_node->next = node->next;
    node->next = new_node;
    new_node->prev = node;

    ++hllist->count;

    return new_node;
}

NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node != hllist->head)
        node->prev->next = new_node;
    else
        hllist->head = new_node;

    new_node->next = node;
    new_node->prev = node->prev;
    node->prev = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node != hllist->head)
        node->prev->next = new_node;
    else
        hllist->head = new_node;

    new_node->next = node;
    new_node->prev = node->prev;
    node->prev = new_node;

    ++hllist->count;

    return new_node;
}

void remove_node(HLLIST hllist, NODE *node)
{
    if (node == hllist->head)
        hllist->head = node->next;
    else
        node->prev->next = node->next;


    if (node == hllist->tail)
        hllist->tail = node->prev;
    else
        node->next->prev = node->prev;

    --hllist->count;

    free(node);
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head; node != NULL; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->tail; node != NULL; node = node->prev)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head = hllist->tail = NULL;
    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%d ", *val);
    fflush(stdout);

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

int main(void)
{
    HLLIST hllist;
    NODE *node, *pos_node;
    DATATYPE *val;

    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
        if (i == 9)
            pos_node = node;
    }

    walk_llist(hllist, NULL);

    remove_node(hllist, pos_node);

    walk_llist(hllist, NULL);

    if ((val = getp_item(hllist, 5)) == NULL) {
        fprintf(stderr, "invalid index!..\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", *val);

    clear_llist(hllist);

    for (int i = 0; i < 10; ++i) 
        if (add_tail(hllist, i) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }

    walk_llist(hllist, NULL);

    destroy_llist(hllist);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Çift bağlı liste gerçekleştiriminde handle alanında head ve tail göstericilerini ayrı ayrı tutmak yerine NODE nesnesi tutulursa özel 
    durumlar ortadan kaldırılabilir ve gerçekleştirim daha sade hale getirilebilir. Bu tasarımda ilk düğümün prev göstericisi ve son düğümün 
    next göstericisi handle alanındaki düğümü göstermelidir. Benzer biçimde handle alanındaki düğümün next göstericisi ilk düğümün yerini 
    prev göstericisi ise son düğümün yerini göstermelidir. 
    
    Tabii bu durumda handle alanında tutulan NODE nesnesinin val elemanı aslında listeye dahil olmadığı için kullanılmayacaktır. Dolayısıyla 
    bu eleman boşa yer kaplayacaktır. Ancak genellikle bu durum öncemsizdir. Bu tarzda gerçekleştirim programcılar tarafından daha fazla 
    tercih edilmektedir. Bu biçimdeki tasarımda handle alanı aşağıdaki gibi olacaktır:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
        struct tagNODE *prev;
    } NODE;

    typedef struct tagLLIST {
        NODE head;
        size_t count;
    } LLIST, *HLLIST;

    Başlangıç durumunda handle alanı içerisindeki düğümün next ve prev göstericilerinin kendisini göstermesi gerekir. Tabii dolaşım 
    yapılırken artık dolaşımın biteceği son düğümdeki NULL adresinden değil next göstericisinin handle alanı içerisindeki düğümün adresine
    eşit olmaması ile tespit edilebilecektir. 

    Aşağıda çift bağlı listelerde handle alanında düğüm tutma yoluyla özel durumların elimine edilmesine bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
    struct tagNODE *prev;
} NODE;

typedef struct tagLLIST {
    NODE head;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
void remove_node(HLLIST hllist, NODE *node);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *node);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head.next = &hllist->head;
    hllist->head.prev = &hllist->head;
    hllist->count = 0;

    return hllist;
}

NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    node->next->prev = new_node;
    new_node->next = node->next;
    node->next = new_node;
    new_node->prev = node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    node->next->prev = new_node;
    new_node->next = node->next;
    node->next = new_node;
    new_node->prev = node;

    ++hllist->count;

    return new_node;
}

NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    node->prev->next = new_node;
    new_node->next = node;
    new_node->prev = node->prev;
    node->prev = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    node->prev->next = new_node;
    new_node->next = node;
    new_node->prev = node->prev;
    node->prev = new_node;

    ++hllist->count;

    return new_node;
}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    return insert_prev(hllist, &hllist->head, val);
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    return insertp_prev(hllist, &hllist->head, val);
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, &hllist->head, val);
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, &hllist->head, val);
}

void remove_node(HLLIST hllist, NODE *node)
{
    node->prev->next = node->next;
    node->next->prev = node->prev;

    --hllist->count;

    free(node);
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head.next;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head.prev; node != &hllist->head; node = node->prev)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;

    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head.next = &hllist->head;
    hllist->head.prev = &hllist->head;

    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;

    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%d ", *val);
    fflush(stdout);

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

int main(void)
{
    HLLIST hllist;
    NODE *node, *pos_node;
    DATATYPE *val;

    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
        if (i == 0)
            pos_node = node;
    }

    walk_llist(hllist, NULL);

    remove_node(hllist, pos_node);

    walk_llist(hllist, NULL);

    if ((val = getp_item(hllist, 5)) == NULL) {
        fprintf(stderr, "invalid index!..\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", *val);

    clear_llist(hllist);

    for (int i = 0; i < 10; ++i) 
        if (add_tail(hllist, i) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }

    walk_llist(hllist, NULL);
    
    destroy_llist(hllist);
    
    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Tek bağlı listelerde her düğüm yalnızca sonraki düğümün adresini tutmaktadır. Dolayısıyla geriye doğru ilerleme mümkün olmaz. Tak bağlı
    listelerde adresini bildiğimiz düğümün yalnızca önüne eleman insert edebiliriz. Benzer biçimde adresini bildiğimiz düğümü silemeyiz. 
    Ancak adresini bildiğimiz düğümün önündeki düğümü silebiliriz. Bunun için oluşturulacak handle alanı şöyle olabilir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagLLIST {
        NODE *head;
        NODE *tail;
        size_t count;
    } LLIST, *HLLIST;

    Soyut bir veri türü olarak tek bağlı listelerde gerçekleştirilebilecek işlemler şunlar olabilir:

    - Listenin başına ve sonuna eleman eklenmesi
    - Listenin dolaşılması ve belli bir indeksteki elemanın elde edilmesi
    - Adresi bilinen bir düğümün önüne eleman insert edilmesi
    - Adresi bilinen bir düğümün önündeki elemanın silinmesi

    Aşağıdaki örnekte bir tek bağlı liste gerçekleştirimi verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE *head;
    NODE *tail;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
void remove_next(HLLIST hllist, NODE *node);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *val);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head = hllist->tail = NULL;
    hllist->count = 0;

    return hllist;
}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (hllist->tail != NULL)
        hllist->tail->next = new_node;
    else
        hllist->head = new_node;

    hllist->tail = new_node;
    new_node->next = NULL;

    ++hllist->count;

    return new_node;
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (hllist->tail != NULL)
        hllist->tail->next = new_node;
    else
        hllist->head = new_node;

    hllist->tail = new_node;
    new_node->next = NULL;

    ++hllist->count;

    return new_node;
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    new_node->next = hllist->head;
    if (hllist->head == NULL)
        hllist->tail = new_node;
    hllist->head = new_node;

    ++hllist->count;

    return new_node;
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    new_node->next = hllist->head;
    if (hllist->head == NULL)
        hllist->tail = new_node;
    hllist->head = new_node;

    ++hllist->count;

    return new_node;
}
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node == hllist->tail)
        hllist->tail = new_node;

    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node == hllist->tail)
        hllist->tail = new_node;

    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;
}

void remove_next(HLLIST hllist, NODE *node)
{
    NODE *next_node;

    if (node == hllist->tail)
        return;

    if (node->next == hllist->tail)
        hllist->tail = node;

    next_node = node->next;
    node->next = next_node->next;

    --hllist->count;

    free(next_node);
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head; node != NULL; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}
void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head;
    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head = hllist->tail = NULL;
    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head;
    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%d ", *val);
    fflush(stdout);

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

int main(void)
{
    HLLIST hllist;
    NODE *node, *pos_node;
    int *val;

    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
        if (i == 8)
            pos_node = node;
    }

    walk_llist(hllist, NULL);

    if ((val = getp_item(hllist, 5)) == NULL) {
        fprintf(stderr, "invalid index!..\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", *val);

    remove_next(hllist, pos_node);
        
    walk_llist(hllist, NULL);

    clear_llist(hllist);

    for (int i = 0; i < 10; ++i) 
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
    walk_llist(hllist, NULL);

    destroy_llist(hllist);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Tek bağlı listelerde de handle alanı içerisinde bir düğüm tutulursa özel durumlar elimine edilebilir. Ancak bunun sağlayacağı fayda çift 
    bağlı listelerdeki gibi olmayacaktır. Çünkü tek bağlı listelerde düğüm içerisinde yalnızca next göstericisi bulunduğu için tail göstericisinin
    ayrıca handle alanında tutulması gerekecektir. Burada da son düğümün next göstericisinin artık NULL adresi değil handle alanındaki düğümü 
    göstermesi gerekir. Tabii işin başında hem handle alanındaki düğümün next göstericisi hem de tail göstericisi handle alanındaki düğümün 
    kendisini göstermlidir. Bu tasarımda handla alanı aşağıdaki gibi oluşturuabilir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagLLIST {
        NODE head;
        NODE *tail;
        size_t count;
    } LLIST, *HLLIST;

    Yapının head elemanının bir gösterici olmadığına NODE nesnesi olduğuna dikkat ediniz. 

    Aşağıda bu tasarıma ilişkin bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE head;
    NODE *tail;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
void remove_next(HLLIST hllist, NODE *node);
void remove_head(HLLIST hllist);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *val);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head.next = &hllist->head;
    hllist->tail = &hllist->head;
    hllist->count = 0;

    return hllist;
}

NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;

}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, hllist->tail, val);
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, hllist->tail, val);
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, &hllist->head, val);
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, &hllist->head, val);
}

void remove_next(HLLIST hllist, NODE *node)
{
    NODE *next_node;

    if (node == hllist->tail)
        return;

    if (node->next == hllist->tail)
        hllist->tail = node;

    next_node = node->next;
    node->next = next_node->next;

    --hllist->count;

    free(next_node);
}

void remove_head(HLLIST hllist)
{
    remove_next(hllist, &hllist->head);
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head.next;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head.next = &hllist->head;
    hllist->tail = &hllist->head;
    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%d ", *val);
    fflush(stdout);

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

int main(void)
{
    HLLIST hllist;
    NODE *node, *pos_node;
    int *val;

    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
        if (i == 5)
            pos_node = node;
    }

    walk_llist(hllist, NULL);

    if ((val = getp_item(hllist, 5)) == NULL) {
        fprintf(stderr, "invalid index!..\n");
        exit(EXIT_FAILURE);
    }

    printf("%d\n", *val);

    remove_next(hllist, pos_node);

    walk_llist(hllist, NULL);

    remove_head(hllist);

    walk_llist(hllist, NULL);

    clear_llist(hllist);

    for (int i = 0; i < 10; ++i) 
        if ((node = add_tail(hllist, i)) == NULL) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }
    walk_llist(hllist, NULL);

    destroy_llist(hllist);
    
    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Tabii bağlı listenin tuttuğu elemanlar (yani DATATYPE türü) int yerine başka türlerden de olabilir. Eğer DATATYPE türü bir yapı ise 
    fonksiyonların p'li versiyonlarını kullanmak daha uygun olacaktır. Aşağıdaki tek bağlı liste örneğinde DATATYPE bir yapı biçiminde 
    oluşturulmuştur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef struct tagPERSON {
    char name[32];
    int no;
} PERSON;

typedef PERSON DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE head;
    NODE *tail;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
void remove_next(HLLIST hllist, NODE *node);
void remove_head(HLLIST hllist);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *node);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head.next = &hllist->head;
    hllist->tail = &hllist->head;
    hllist->count = 0;

    return hllist;
}

NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;

}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, hllist->tail, val);
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, hllist->tail, val);
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, &hllist->head, val);
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, &hllist->head, val);
}

void remove_next(HLLIST hllist, NODE *node)
{
    NODE *next_node;

    if (node == hllist->tail)
        return;

    if (node->next == hllist->tail)
        hllist->tail = node;

    next_node = node->next;
    node->next = next_node->next;

    --hllist->count;

    free(next_node);
}

void remove_head(HLLIST hllist)
{
    remove_next(hllist, &hllist->head);
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head.next;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head.next = &hllist->head;
     hllist->tail = &hllist->head;
    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }
    
    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%s, %d\n", val->name, val->no);
    fflush(stdout);

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "llist.h"

bool disp_person(PERSON *per);
void clear_stdin(void);

int main(void)
{
    HLLIST hllist;
    PERSON per;
    char *str;
    
    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        printf("Adi soyadi:");
        if (fgets(per.name, 32, stdin) == NULL)
            continue;
        if ((str = strchr(per.name, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(per.name, "quit"))
            break;
        printf("No:");
        scanf("%d", &per.no);
        clear_stdin();

        addp_tail(hllist, &per);
    }

    walk_llist(hllist, disp_person);
    
    destroy_llist(hllist);

    return 0;
}
bool disp_person(PERSON *per)
{
    printf("%s, %d\n", per->name, per->no);

    return true;
}


void clear_stdin(void)
{
    int ch;

    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Çok karşılaşılan diğer bir veri yapısı da "kuyruk (queue)" veri yapısıdır. Kuyruklar FIFO ve LIFO olmak üzere ikiye ayrılmaktadır. Ancak 
    kuyruk denildiğinde default olarak FIFO kuyruklar anlaşılmaktadır. 

    Kuyruk veri yapısında iki eylem vardır: Kuyruğua eleman yerleştirmek ve kuyruktan eleman almak. Kuyruğun arasına eleman insert etmenin bir 
    anlamı yoktur. Aradan eleman silmenin de bir anlamı yoktur. Kuyruklara yalnızca eleman yerleştirilip kuyruklardan yalnızca eleman alınmaktadır.
    FIFO kuyruk sistemine eleman yerleştirileceği zaman eleman her zaman sona yerleştirilmektedir. Bu kuyruk sisteminden eleman alınacağı 
    zaman eleman baştan alınmaktadır. 
    
    FIFO kuyruk sistemleri gerçek hayatta çokça karşımıza çıkmaktadır. Örneğin gerçek hayattaki kuyrukların çoğu bir FIFO kuyruk sistemidir. 
    Yemekhanede kuyruğun sonuna gireriz. Kuyruğun başındaki kişiye yemek verilir. Bu yönüyle FIFO kuyruk sistemi adil bir kuyruk sistemidir. 

    FIFO kuyruk sistemleri "bilgilerin sırası bozulmadan geçici olarak bekletileceği" durumlarda kullanılmaktadır. Yani tampon sistemleri 
    genellikle FIFO kuyruk sistemi biçiminde oluşturulmaktadır. Örneğin bir yerden bilgi geliyor olsun. Bu bilgiyi o anda işleyemiyor olalım. 
    O zaman gelen bilgiyi geçici süre bir FIFO kuyruk sisteminde tutabiliriz. Daha sonra oradan alarak geldiği sırada işleyebiliriz. Aslında 
    daha önce görmüş olduğumuz borularda bir FIFO kuyruk sistemi ile gerçekleştirilmektedir. Örneğin boruya br şey yazıldığında bu şeyler 
    borunun sonuna yazılır. Biz de boruyu okuduğumuzda başındakileri alırız. 

    Kuyruk sistemine eleman yerleştirmeye İngilizce genellikle "put" ya da "enqueue" işlemi denilmektedir. Kuyruktan eleman alamaya da İngilizce 
    genellikle "get" ya da "dequeue" işlemi denilmektedir. 

    Kuyruk sistemlerinin bir uzunlukları olabilir. Kuyruk dolduğunda artık kuyruğa put yapılamamaktadır. Benzer biçimde kuruk tamamen boşaldığında
    artık "get" yapılamamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                62. Ders 03/02/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    FIFO kuyruk sistemlerinin gerçekleştirilmesi için üç yöntem kullanılmaktadır:

    1) Dizi Kaydırması Yöntemi: Bu yöntem ilk akla gelen yöntemdir. Ancak diğer yöntemlerden bariz kötü olduğu için tercih edilmemektedir. 
    Bu yöntemde kuyruk için bir dizi yaratılır. Dizinin sonu (elemanların bittiği yer dizinin gerçek sonu değil) bir indeksle ya da gösterici 
    ile tutulur. Çrneğin:

    abcdexxxxxxxxxxxxx
         ^ 

    Burada a, b, c, d, e kuruktaki elemanları x'ler ise dizide henüz kullanılmayan boşi alanları belirtmektedir. Bu yöntemde kuyuğa eleman 
    ekleneceği zaman sona ekleme yapılır. Örneğin:

    abcdefxxxxxxxxxxxx
          ^ 

    Kuyruktan eleman alınacağı zaman eleman kuruğun başından alınır ve kuyruktaki elemanlar bir kaydırılır. Örneğin;

    bcdefxxxxxxxxxxxx
        ^ 

    Bu tasarımda kuyuğa eleman yerleştirmek O(1) karmaşıklıktayken kuyruktan eleman almak O(N) karmaşıklıktadır. 

    2) İndeks Kaydırması Yöntemi: En çok kullanılan yöntemlerden biridir. Bu yöntemde kuyruğun başı ve sonu iki indeks ya da gösterici ile 
    tutturulur. Kuruğun bgaşını gösteren indeks ya da göstericiye genellikle İngilizce "head" göstericisi, kuyrun sonunu gösteren indeks ya da 
    göstericiye de "tail" göstericisi denilmektedir. Örneğin:

    xxxxabcdefgxxxxxx
        ^(h)   ^(t)

    Eleman tail göstericisinin gösterdeiği yere yerleştirilir ve tail göstericisi 1 artırılır. Ancak eğer tail göstericisi dizinin sonuna 
    gelmişse yeniden başa geçirilir. Örneğin:

    xxxxabcdefghxxxxxxx
        ^(h)    ^(t)

    Eleman head göstericisinin gösteridği yerden alınır ve head göstericisi 1 artırılır. Tabii yine head göstericisi kuyruğun sonuna geldiğinde
    yeniden başa geçirilir. Bu yöntemde head ve tail göstericileri aynı yeri gösteriyorsa ya kuyruk tamamen doludur ya da kuyruk tamamen boştur.
    Genellikle kuyruktaki eleman sayısı da bir değişkenle tutulmaktadır. Kuyruğun tam dolu ya da tam boş olduğuna bu değişkene bakılarak karar 
    verilir. Bu yöntemde eleman ekleme de eleman alma da O(1) karmaşıklıkta yapılabilmektedir. 

    İndeks kaydırma yönteminde kuyruk dolduğunda tıpkı dinamik dizilerde olduğu gibi kuyruk büyütülebilir. Ancak kuyruğun büyütülüp büyütülmeyeceği 
    uygulamadan uygulamaya değişebilmektedir. 

    3) Bağlı Liste Yöntemi: Bu yöntemde bir bağlı liste oluşturulur. Eleman bağlı listenin sonuna eklenir ve başından alınır. Bağlı liste
    tek bağlı liste biçiminde oluşturulabilir. Bu yöntemde sanki eleman ekleme ve alma O(1) karmaşıklıkta yapılıyormuş gibi gözükse de 
    eğer elemanlar dinamik olarak tahsis edilip free edeilecekse genellikle bu işlemler O(N) karmaşıklıkta yapılmaktadır. (Tabii O(1) karmaşıklıkta
    çalışan tahsisat algoritmaları da vardır. Ancak Windows ve UNIX/Linux sistemlerindeki malloc v free algoritmaları O(N) karmaşıklıkta 
    gerçekleştirilmiştir. Bu yöntemin avantajı baştan kuyruk uzunluğunun belirli olmasına gerek kalmamasıdır.) 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağda indeks kaydırma yöntemiyle bir kuyruk sistemi oluşturulmuştur. Kuyruk bilgileri aşağdaki yapıyla temsil edilmiştir:
    
    typedef struct tagQUEUE {
        DATATYPE *queue;
        size_t head;
        size_t tail;
        size_t size;
        size_t count;
    } QUEUE, *HQUEUE;

    Handle alanı içerisinde kuyruk verilerinin bulunduğu dizi, head ve tail indeksleri, kuyruğun toplam uzunluğu ve kuyruktaki dolu elemanların
    sayısının tutulduuna dikkat ediniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* queue.h */

#ifndef QUEUE_H_
#define QUEUE_H_

#include <stddef.h>
#include <stdbool.h>

typedef int DATATYPE;

typedef struct tagQUEUE {
    DATATYPE *queue;
    size_t head;
    size_t tail;
    size_t size;
    size_t count;
} QUEUE, *HQUEUE;

/* Function Prototypes */

HQUEUE create_queue(size_t size);
bool put_queue(HQUEUE hqueue, DATATYPE val);
bool putp_queue(HQUEUE hqueue, const DATATYPE *val);
bool get_queue(HQUEUE hqueue, DATATYPE *val);
bool resize_queue(HQUEUE hqueue, size_t newsize);
void clear_queue(HQUEUE hqueue);
void destroy_queue(HQUEUE hqueue);

/* inline Function Definitions */

static inline bool isempty_queue(HQUEUE hqueue)
{
    return hqueue->count == 0;
}

static inline bool count_queue(HQUEUE hqueue)
{
    return hqueue->count;
}

#endif

/* queue.c */

#include <stdio.h>
#include <stdlib.h>
#include "queue.h"

HQUEUE create_queue(size_t size)
{
    HQUEUE hqueue;

    if ((hqueue = (HQUEUE)malloc(sizeof(QUEUE))) == NULL)
        return NULL;

    if ((hqueue->queue = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL) {
        free(hqueue);
        return NULL;
    }

    hqueue->head = hqueue->tail = 0;
    hqueue->size = size;
    hqueue->count = 0;

    return hqueue;
}

bool put_queue(HQUEUE hqueue, DATATYPE val)
{
    if (hqueue->count == hqueue->size)
        return false;

    hqueue->queue[hqueue->tail++] = val;
    hqueue->tail %= hqueue->size;
    ++hqueue->count;

    return true;
}

bool putp_queue(HQUEUE hqueue, const DATATYPE *val)
{
    if (hqueue->count == hqueue->size)
        return false;

    hqueue->queue[hqueue->tail++] = *val;
    hqueue->tail %= hqueue->size;
    ++hqueue->count;

    return true;
}

bool get_queue(HQUEUE hqueue, DATATYPE *val)
{
    if (hqueue->count == 0)
        return false;

    *val = hqueue->queue[hqueue->head++];
    hqueue->head %= hqueue->size;
    --hqueue->count;

    return true;
}

bool resize_queue(HQUEUE hqueue, size_t newsize)
{
    DATATYPE *new_queue;
    
    if (newsize <= hqueue->size)
        return false;

    if ((new_queue = (DATATYPE *)malloc(newsize * sizeof(DATATYPE))) == NULL)
        return false;

    for (size_t i = 0, head = hqueue->head; i < hqueue->size; ++i) {
        new_queue[i] = hqueue->queue[head++];
        head %= hqueue->size;
    }

    hqueue->head = 0;
    hqueue->tail = hqueue->count;
    hqueue->size = newsize;

    free(hqueue->queue);

    hqueue->queue = new_queue;

    return true;
}

void clear_queue(HQUEUE hqueue)
{
    hqueue->count = 0;
    hqueue->head = 0;
    hqueue->tail = 0;
}

void destroy_queue(HQUEUE hqueue)
{
    free(hqueue->queue);
    free(hqueue);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "queue.h"

int main(void)
{
    HQUEUE hqueue;
    DATATYPE val;

    if ((hqueue = create_queue(10)) == NULL) {
        fprintf(stderr, "cannot create queue!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 8; ++i)
        if (!put_queue(hqueue, i)) {
            fprintf(stderr, "cannot put queue!..\n");
            exit(EXIT_FAILURE);
        }

    for (int i = 0; i < 5; ++i)
        get_queue(hqueue, &val);

    if (!resize_queue(hqueue, 20)) {
        fprintf(stderr, "cannot resize queue!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 15; ++i)
        if (!put_queue(hqueue, i)) {
            fprintf(stderr, "cannot put queue!..\n");
            exit(EXIT_FAILURE);
        }

    while (!isempty_queue(hqueue)) {
        get_queue(hqueue, &val);
        printf("%d ", val);
        fflush(stdout);
    }

    destroy_queue(hqueue);
             
    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte FIFO kuyruk bağlı liste yöntemi gerçekleştirilmiştir. Bu örnekte handle alanı aşağıdaki gibi bir yapı ile temsil edilmiştir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagQUEUE {
        NODE *head;
        NODE *tail;
        size_t count;
    } QUEUE, *HQUEUE;

    Handle alanı içerisinde tek bağlı listenin head ve tail düğümleri ve kuyruktaki eleman sayısı tutulmuştur. Örneğimizde kuyruğa eleman 
    yerleştirirken bağlı listenin sonuna elemanı ekledik. Kuyruktan eleman alınırken de bağlı listenin başından elemanı aldık.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* queue.h */

#ifndef QUEUE_H_
#define QUEUE_H_

#include <stddef.h>
#include <stdbool.h>

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagQUEUE {
    NODE *head;
    NODE *tail;
    size_t count;
} QUEUE, *HQUEUE;

/* Function Prototypes */

HQUEUE create_queue(voids);
bool put_queue(HQUEUE hqueue, DATATYPE val);
bool putp_queue(HQUEUE hqueue, const DATATYPE *val);
bool get_queue(HQUEUE hqueue, DATATYPE *val);
void clear_queue(HQUEUE hqueue);
void destroy_queue(HQUEUE hqueue);

/* inline Function Definitions */

static inline bool isempty_queue(HQUEUE hqueue)
{
    return hqueue->count == 0;
}

static inline bool count_queue(HQUEUE hqueue)
{
    return hqueue->count;
}

#endif

/* queue.c */

#include <stdio.h>
#include <stdlib.h>
#include "queue.h"

HQUEUE create_queue(void)
{
    HQUEUE hqueue;

    if ((hqueue = (HQUEUE)malloc(sizeof(QUEUE))) == NULL)
        return NULL;

    hqueue->head = hqueue->tail = NULL;
    hqueue->count = 0;

    return hqueue;
}

bool put_queue(HQUEUE hqueue, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->val = val;
    new_node->next = NULL;

    if (hqueue->tail != NULL)
        hqueue->tail->next = new_node;
    else
        hqueue->head = new_node;

    hqueue->tail = new_node;
    ++hqueue->count;

    return true;
}

bool putp_queue(HQUEUE hqueue, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->val = *val;
    new_node->next = NULL;

    if (hqueue->tail != NULL)
        hqueue->tail->next = new_node;
    else
        hqueue->head = new_node;

    hqueue->tail = new_node;
    ++hqueue->count;

    return true;
}
 
bool get_queue(HQUEUE hqueue, DATATYPE *val)
{
    NODE *node;

    if (hqueue->head == NULL)
        return false;

    node = hqueue->head;
    *val = node->val;

    if (node->next == NULL)
        hqueue->tail = NULL;

    hqueue->head = node->next;

    --hqueue->count;

    free(node);

    return true;
}

void clear_queue(HQUEUE hqueue)
{
    NODE *node, *temp_node;

    node = hqueue->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hqueue->head = hqueue->tail = NULL;
    hqueue->count = 0;
}

void destroy_queue(HQUEUE hqueue)
{
    NODE *node, *temp_node;

    node = hqueue->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hqueue);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "queue.h"

int main(void)
{
    HQUEUE hqueue;
    DATATYPE val;

    if ((hqueue = create_queue(10)) == NULL) {
        fprintf(stderr, "cannot create queue!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 8; ++i)
        if (!put_queue(hqueue, i)) {
            fprintf(stderr, "cannot put queue!..\n");
            exit(EXIT_FAILURE);
        }

    for (int i = 0; i < 15; ++i)
        if (!put_queue(hqueue, i)) {
            fprintf(stderr, "cannot put queue!..\n");
            exit(EXIT_FAILURE);
        }

    while (!isempty_queue(hqueue)) {
        get_queue(hqueue, &val);
        printf("%d ", val);
        fflush(stdout);
    }

    destroy_queue(hqueue);
             
    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    LIFO (Last In First Out) kuyruk sistemlerine "Stack Veri Yapısı" da denilmektedir. Stack veri yapısında yine iki eylem vardır. Stack'e 
    eleman eklemek ve stack'ten eleman almak. Geleneksel olarak stack'e eleman yerleştirmeye "push" işlemi, stack'ten eleman almaya da "pop"
    işlemi denilmektedir. LIFO kuyruk sistemleri FIFO kuyruk sistemlerine göre daha seyrek kullanılmaktadır. Dış dünyada seyrek de olsa stack
    sistemleriyle karşılaşılmaktadır. Örneğin:

    - Tabaklar üst üste konulduğunda en üsttek ilk alınmaktadır.
    - Asansöre son binen çoğu kez ilk inmektedir.
    - Bazı oyun programlarında oyun kağıtları üst üste yere atıldığında oyuncular son atılan kağıdı yerden alabilmektedir. 

    Bilgisayar dünyasında da stack sistemleriyle karşılaşılmaktadır. Örneğin "undo mekanizması" stack veri yapısıyla gerçekleştirilmektedir. 
    Yani örneğin biz bir editörde birtakım şeyler yaptıktan sonra "Ctrl+Z" tuşlarına basarsak son yapılandna ilk yapılana doğru eylemler geri 
    alınmaktadır. Mikroişlemciler de stack sistemini fonksiyon çağrılarında ve yerel değişkenleri depolamada kullanmaktadır. Örneğin birkaç 
    fonksiyon peşi sıra çağrıldığında geri dönüşler son çağırmadan ilk çağırmaya doğru yapılmaktadır. Parsing algoritmalarında stack veri 
    yapısı yoğun olarak kullanılmaktadır. Örneğin RPN (Rverse Polish Notation) hesap makineleri stack veri yapısı kullanmaktadır. Stack bir bilgiyi
    ters yüz etmek için kullanılabilir. 

    Stack veri yapısı yine "dizi yoluyla" ya da "bağlı liste yoluyla" gerçekleştirilebilmektedir. Dizi gerçekleştiriminde belli uzunlukta 
    bir dizi yaratılır. Stack'in aktif noktası bir göstericiyle (ya da indeksle) belirlenir. Stack'in aktif noktasını tutan bu göstericiye
    geleneksel olarak "stack göstericisi (stack pointer)" denilmektedir. Başlangıçta stack boştur. Stack göstericisi dizinin soununu göstermektedir. 
    Örneğin:

            x
            x
            x
            x
            x
    SP -->

    Push işleminde stack göstericisi önce bir azaltılır. Sonra push edilecek değer göstericisinin gösterdiği yere yerleştirilir. Örneğin 
    a değerini yukarıdaki stack'e yerleştirelim:

            x
            x
            x
            x
            x
    SP ---> a
    
    Şimdi de b değerine stack'e push edelim:

            x
            x
            x
            x
    SP --->    b
            a
    
    Şmdi de c değerini push edelim:

            x
            x
            x
    SP --->    c
            b
            a
    
    Pop işleminde tam tersi yapılır. Yani Stack göstericisinin gösterdiği yerdne bilgi alınır ve stack göstericisi 1 ilerletilir. Örneğin yukarıdaki
    durumda pop işlemi yapalım:

            x
            x
            x
            c
    SP --->    b
            a
    
    Şimdi bir daha pop yapalım:

            x
            x
            x
            c
            b
    SP --->    a
    
    Eğer stack uzunluğundan daha fazla psuh işlemi yapılırsa (yani stack doluyken push işlemi yapılırsa) stack için ayrılan alanı yukarından 
    taşırmış oluruz. Bu duruma geleneksel olarak "stack'in yukarıdan taşması (stack overflow)" denilmektedir. eğer çok fazla pop işlemi yaparsak
    (yani boş bir stack'ta pop işlemi yaparsak) bu durumda stack için ayrılan diziyi aşağıdan taşırmış oluruz. Buna da geleneksel olarak 
    "stack underflow" denilmektedir. 

    Stack sistemleri tek bağlı listelerle de gerçekleştirilebilir. Bir bağlı listenin elemanlar önünne eklenip öününden alınırsa zaten 
    bu stack olur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda stack veri yapısının dizi kullanılarak gerçekleştirimine bir örnek verilmiştir. Bu örnekte stack veri yapısı (handle alanı) STACK 
    isimli bir yapı ile    temsil edilmiştir:

    typedef struct tagSTACK {
        DATATYPE *stack;
        DATATYPE *sp;
        size_t size;
        size_t count;
    } STACK, *HSTACK;

    Yapı içerisinde stack için kullanılacak dizinin başlangıç adresi, stack göstericinin durumu, stack dizinin uzunluğu ve stack'teki eleman
    sayısı tutulmuştur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* stack.h */

#ifndef STACK_H_
#define STACK_H_

#include <stddef.h>
#include <stdbool.h>

typedef int DATATYPE;

typedef struct tagSTACK {
    DATATYPE *stack;
    DATATYPE *sp;
    size_t size;
    size_t count;
} STACK, *HSTACK;

/* Function Prototypes */

HSTACK create_stack(size_t size);
bool push_stack(HSTACK hstack, DATATYPE val);
bool pushp_stack(HSTACK hstack, const DATATYPE *val);
bool pop_stack(HSTACK hstack, DATATYPE *val);
void clear_stack(HSTACK hstack);
void destroy_stack(HSTACK hstack);

/* inline Function Definitions */

static inline size_t count_stack(HSTACK hstack)
{
    return hstack->count;
}

static inline bool isempty_stack(HSTACK hstack)
{
    return hstack->count == 0;
}

#endif

/* stack.c */

#include <stdio.h>
#include <stdlib.h>
#include "stack.h"

HSTACK create_stack(size_t size)
{
    HSTACK hstack;

    if ((hstack = (HSTACK)malloc(sizeof(STACK))) == NULL)
        return NULL;

    if ((hstack->stack = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL) {
        free(hstack);
        return NULL;
    }

    hstack->sp = hstack->stack + size;
    hstack->size = size;
    hstack->count = 0;

    return hstack;
}

bool push_stack(HSTACK hstack, DATATYPE val)
{
    if (hstack->count >= hstack->size)
        return false;

    *--hstack->sp = val;
    ++hstack->count;

    return true;
}

bool pushp_stack(HSTACK hstack,const DATATYPE *val)
{
    if (hstack->count >= hstack->size)
        return false;

    *--hstack->sp = *val;
    ++hstack->count;

    return true;
}

bool pop_stack(HSTACK hstack, DATATYPE *val)
{
    if (hstack->count == 0)
        return false;

    *val = *hstack->sp++;
    --hstack->count;

    return true;
}

void clear_stack(HSTACK hstack)
{
    hstack->sp = hstack->stack + hstack->size;
    hstack->count = 0;
}

void destroy_stack(HSTACK hstack)
{
    free(hstack->stack);
    free(hstack);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "stack.h"

int main(void)
{
    HSTACK hstack;
    DATATYPE val;

    if ((hstack = create_stack(10)) == NULL) {
        fprintf(stderr, "cannot create stack!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i)
        if (!push_stack(hstack, i)) {
            fprintf(stderr, "cannot push stack!..\n");
            exit(EXIT_FAILURE);
        }

    while (!isempty_stack(hstack)) {
        pop_stack(hstack, &val);
        printf("%d ", val);
        fflush(stdout);
    }
    printf("\n");

    destroy_stack(hstack);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda stack veri yapısının tek bağlı liste ile gerçekleştirime ilişkin bir örnek verilmiştir. Burada NODE yapısı ve handle alanını temsil 
    eden STACK yapısı aşağıdaki gibi bildirilmiştir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagSTACK {
        NODE *head;
        size_t count;
    } STACK, *HSTACK;

    Bu gerçekleştirimde düğüm bağlı listenin önüne eklenip önünden alınmaktadır. Handle alanında tail göstericisinin tutulmasına gerek olmadığına
    dikkat ediniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* stack.h */

#ifndef STACK_H_
#define STACK_H_

#include <stddef.h>
#include <stdbool.h>

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagSTACK {
    NODE *head;
    size_t count;
} STACK, *HSTACK;

/* Function Prototypes */

HSTACK create_stack(void);
bool push_stack(HSTACK hstack, DATATYPE val);
bool pushp_stack(HSTACK hstack, const DATATYPE *val);
bool pop_stack(HSTACK hstack, DATATYPE *val);
void clear_stack(HSTACK hstack);
void destroy_stack(HSTACK hstack);

/* inline Function Definitions */

static inline size_t count_stack(HSTACK hstack)
{
    return hstack->count;
}

static inline bool isempty_stack(HSTACK hstack)
{
    return hstack->count == 0;
}

#endif

/* stack.c */

#include <stdio.h>
#include <stdlib.h>
#include "stack.h"

HSTACK create_stack(void)
{
    HSTACK hstack;

    if ((hstack = (HSTACK)malloc(sizeof(STACK))) == NULL)
        return NULL;

    hstack->head = NULL;
    hstack->count = 0;

    return hstack;
}

bool push_stack(HSTACK hstack, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->val = val;

    new_node->next = hstack->head;
    hstack->head = new_node;
    
    ++hstack->count;

    return true;
}

bool pushp_stack(HSTACK hstack,const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->val = *val;

    new_node->next = hstack->head;
    hstack->head = new_node;

    ++hstack->count;

    return true;
}

bool pop_stack(HSTACK hstack, DATATYPE *val)
{
    NODE *node;

    if (hstack->head == NULL)
        return false;

    node = hstack->head;
    hstack->head = node->next;
    *val = node->val;
    free(node);

    --hstack->count;

    return true;
}

void clear_stack(HSTACK hstack)
{
    NODE *node, *temp_node;

    node = hstack->head;
    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hstack->head = NULL;
    hstack->count = 0;
}

void destroy_stack(HSTACK hstack)
{
    NODE *node, *temp_node;

    node = hstack->head;
    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hstack);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "stack.h"

int main(void)
{
    HSTACK hstack;
    DATATYPE val;

    if ((hstack = create_stack()) == NULL) {
        fprintf(stderr, "cannot create stack!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i)
        if (!push_stack(hstack, i)) {
            fprintf(stderr, "cannot push stack!..\n");
            exit(EXIT_FAILURE);
        }

    while (!isempty_stack(hstack)) {
        pop_stack(hstack, &val);
        printf("%d ", val);
        fflush(stdout);
    }
    printf("\n");

    for (int i = 0; i < 10; ++i)
        if (!push_stack(hstack, i)) {
            fprintf(stderr, "cannot push stack!..\n");
            exit(EXIT_FAILURE);
        }

    while (!isempty_stack(hstack)) {
        pop_stack(hstack, &val);
        printf("%d ", val);
        fflush(stdout);
    }
    printf("\n");

    destroy_stack(hstack);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                        64. Ders   10/02/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Diğer önemli bir veri yapısı da "çift yönlü dinamik diziler (double-ended queue)" denilen veri yapılarıdır. Çift yönlü dinamik diziler
    normal dinamik dizilere benzemekle birlikte bunların başına ve sonuna eleman eklenmesi, baştan ve sondan eleman silinmesi O(1) karmaşıklıktadır. 
    (Halbuki normal dinamik dizilerde başa eleman eklenmesi ve baştaki elemanın silinmesi dizinin tümden kaydırılmasını gerektirdiği için 
    O(N) karmaşlıklıktadır.) 

    Çift yönlü dizmaik dizilere kısaca İngilizce "deque" de denilmektedir. Bu sözcük "deck" gibi okunmaktadır. Bazı yazarlar bu veri yapısının 
    kısa ismi için "dequeue" ismini kullanıyorsa da bu isim "kuyruktan veri almak" anlamına gelen sözcükle aynı olduğu karışıklığa yol açmaktadır. 
    Bu veri yaısının yaygın kısa ismi "deque" biçimindedir. 

    Çift yönlü dinamik dizilerde elemana erişim yine sabit karmaşıklıkta yapılmaktadır. Araya eleman insert edilmesi ve aradan eleman silinmesi
    O(N) karmaşıklıktadır. O halde bu veri yapısının en önemli özelliği başa eleman eklemenin ve baştaki elemanı silmenin çok hızlı olmasıdır. 

    Çift yönlü dinamik diziler pek çok kütüphanede (örneğin C++'ın Standart Kütüphanesinde) "kuyruk" ve "stack" veri yapısının gerçekleştiriminde 
    temel bir veri yapısı olarak kullanılmaktadır. Örneğin C++ Standart Kütüphanesinde FIFO kuyruk sistemi "bir deque'in sonuna eleman insert 
    edip başındaki elemanı almak" biçiminde gerçekleştirilmiştir. Bnezer biçimde "stack" veri yapısı da "deque'in başına eleman yerleştirip 
    başından, eleman almakla gerçekleştirilmiştir.

    Çift yönlü dinamik diziler tipik olarak üç biçimde gerçekleştirilmektedir. Bu gerçekleştirimlerin etkinliği birbirine yakındır. Özel durumlar
    dikkat alınarak hangi gerçekleştirimin tercih edileceğine karar verilebilir. 

    İndeks Kaydırma Yöntemi ile Gerçekleştirim: Burada bir kuyruk sistemi oluşturulur. Yine kuyruğun başı ve sonu birer gösterici ya da indeks 
    ile tutulur. Sona ekleme tail göstericisinin gösteriği yere, başa ekleme head göstericisinin gösterdiği yere yapılır. Diğer işlemler kuyruk 
    sistemlerindeki gerçekleştirim ile benzerdir. Kuyruk dolduğunda    yine normal dinamik dizilerde olduğu gibi iki kat artırım yoluna gidilir. 
    Başa ve sona eleman ekleme, baştaki ve sondaki elemanın silinmesi O(1) karmaşıklıkta gerçekleştirilebilir. Elemana O(1) karmaşıklıkta 
    erişilebilir. 

    Dinamik Dizi Yoluyla Gerçekleştirim: Bu gerçekleştirimde bir dinamik dizi oluşturulur. Başlangıçta head ve tail göstericileri bu dinamik 
    dizinin ortasında bir yeri gösterir. Sona eklemeler yine tail göstericisinin bulunduğu yere, başa eklemeler ise head göstericisinin bulunduğu
    yere yapılır. Yani eklemelerde tail sağa doğru, head sola doğru ilerler. Baştan eleman silinmesinde ise head sağa doğru, sondan eleman 
    silinmesinde ise tail sola doğru ilerleyecektir. head ve tail göstericileri iki uçtan herhangi birine eriştiğinde dizi büyütülecektir. 
    Bu gerçekleştirimde kullanılmayan boş alanların bulunma olasılığı artmaktadır. Bazen çift yönlü dinamik dizi yalnızca bir yöne ilerleyebilir. 
    Yani sona ekleme ve baştan silme işlemleri yoğun olabilir. Bu durumda head ve tail göstericileri dizinin sonlarına yakın bölgelerde konumlanabilirler.. 
    Ancak yeniden tahsisat yapıldığında bunlar yeni uygun konumlarına taşınabilirler. 

    Birden Fazla Dizinin Kullanılması Yöntemi: Bu gerçekleştirimde tek bir dizi değil belli uzunluklarda birden fazla dizi kullanılır. Örneğin
    her biri 64 byte uzunluğunda dizilerin kullanıldığını varsayalım. Bir dizi yetmeyince yeni bir 64 byte'lık dizi tahsis edilecektir. 
    Tabii bu dizilerin adreslerinin de bir yerde saklanması gerekir. Tipik olarak bu dizilerin adresleri dinamik bir gösterici dizisinde 
    saklanmaktadır. Tabii bu durumda bu dinamik gösterici dizisinin kaydırılması gerekecektir. Ancak bu dizi çok bütük olmazsa bu kaydırma
    önemli bir zamana yol açmayabilir. Bu gerçekleştirimde yine elemana erişim O(1) karmaşıklıkta tutulabilir. Başa ve sona eleman ekleme, 
    baştan ve sondan eleman silme yine O(1) karmaşıkıkta yapılabilir. Ancak eleman ekleme sırasında dizilerin adreslerini tutan dizide 
    kaydırmalar söz konusu olabilecektir. Bu nedenle eleman ekleme ve silme işlemi aslında tam O(1) karmaşıklıkta değil "amortized O(1)"
    karmaşıklıktadır. 

-------------------------------------------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    65.  Ders 11/02/2024 - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir deque gerçekleştirimine örnek verilmiştir. Bu gerçekleştirimde deque bir juruk sistemi gibi oluturulmuştur. Veri yaosının 
    bilgilerini tutan handle alanı şöyledir:

    typedef int DATATYPE;

    typedef struct tagDEQUE {
        DATATYPE *deque;
        size_t capacity;
        size_t count;
        size_t head;
        size_t tail;
    } DEQUE, *HDEQUE;

    Bu gerçekleştirimde deque için başlangıçta DEQUE_DEF_CAPACITY (8) elemanlık yer ayrılmaktadır. Deque dolunca öncekinin iki katı uzunluğunda
    yeni bir aalan tahsis edilmiş ve eski alandan yeni alana kopyalama yapılmıştır. Deque veri yapısında başa ve sona eleman eklemek, baştan 
    ve sondan eleman silmek O(1) karmaşıklıktadır. Ancak araya eleman insert etmek ya da aradan eleman silmek O(N) karmaşıklıktadır. Biz 
    aşağıdaki gerçekleştirimde araya eleman ekleme ve aradan eleman işlemini kuyruğun sonunu referans alarak kaydırma yoluyla yaptık. 
    Aslında insert ve remove pozisyonları hangi uca daha yakınsa kaydırma ona göre de yapılabilirdi. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* deque.h */

#ifndef DEQUE_H_
#define DEQUE_H_

#include <stddef.h>
#include <stdbool.h>

/* Symbolic Constants */

#define DEQUE_DEF_CAPACITY        8
#define DEQUE_FAILED            ((size_t)-1)
#define MIN(a, b)                ((a) < (b) ? (a) : (b))

/* Type Declerations */

typedef int DATATYPE;

typedef struct tagDEQUE {
    DATATYPE *deque;
    size_t capacity;
    size_t count;
    size_t head;
    size_t tail;
} DEQUE, *HDEQUE;

/* Function Prototypes */

HDEQUE create_deque(void);
size_t add_back_deque(HDEQUE hdeque, DATATYPE val);
size_t add_backp_deque(HDEQUE hdeque, const DATATYPE *val);
size_t add_front_deque(HDEQUE hdeque, DATATYPE val);
size_t add_frontp_deque(HDEQUE hdeque, const DATATYPE *val);
DATATYPE at_deque(HDEQUE hdeque, size_t index);
void atp_deque(HDEQUE hdeque, size_t index, DATATYPE *val);
DATATYPE pop_front_deque(HDEQUE hdeque);
void pop_frontp_deque(HDEQUE hdeque, DATATYPE *val);
size_t insert_deque(HDEQUE hdeque, size_t index, DATATYPE val);
size_t remove_deque(HDEQUE hdeque, size_t index);
DATATYPE *set_capacity_deque(HDEQUE hdeque, size_t new_capacity);
void clear_deque(HDEQUE hdeque);
void destroy_deque(HDEQUE hdeque);

/* inline Function Definitions */

static inline size_t count_deque(HDEQUE hdeque)
{
    return hdeque->count;
}

static inline size_t capacity_deque(HDEQUE hdeque)
{
    return hdeque->capacity;
}

#endif

/* deque.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "deque.h"

HDEQUE create_deque(void)
{
    HDEQUE hdeque;

    if ((hdeque = (HDEQUE)malloc(sizeof(DEQUE))) == NULL)
        return NULL;

    if ((hdeque->deque = (DATATYPE *)malloc(DEQUE_DEF_CAPACITY * sizeof(DATATYPE))) == NULL) {
        free(hdeque);
        return NULL;
    }

    hdeque->count = 0;
    hdeque->capacity = DEQUE_DEF_CAPACITY;

    hdeque->head = hdeque->tail = 0;

    return hdeque;
}

size_t add_back_deque(HDEQUE hdeque, DATATYPE val)
{
    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
        return DEQUE_FAILED;

    hdeque->deque[hdeque->tail++] = val;
    hdeque->tail %= hdeque->capacity;
    ++hdeque->count;

    return hdeque->count - 1;
}

size_t add_backp_deque(HDEQUE hdeque, const DATATYPE *val)
{
    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
        return DEQUE_FAILED;

    hdeque->deque[hdeque->tail++] = *val;
    hdeque->tail %= hdeque->capacity;
    ++hdeque->count;

    return hdeque->count - 1;
}

size_t add_front_deque(HDEQUE hdeque, DATATYPE val)
{
    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
        return DEQUE_FAILED;

    if (hdeque->head == 0)
        hdeque->head = hdeque->capacity - 1;
    else
        --hdeque->head;

    hdeque->deque[hdeque->head] = val;
    ++hdeque->count;

    return 0;
}

size_t add_frontp_deque(HDEQUE hdeque, const DATATYPE *val)
{
    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
        return DEQUE_FAILED;

    if (hdeque->head == 0)
        hdeque->head = hdeque->capacity - 1;
    else
        --hdeque->head;

    hdeque->deque[hdeque->head] = *val;
    ++hdeque->count;

    return 0;
}

DATATYPE *set_capacity_deque(HDEQUE hdeque, size_t new_capacity)
{
    size_t size1, size2;
    DATATYPE *new_deque;
    
    if ((new_deque = (DATATYPE *)malloc(new_capacity * sizeof(DATATYPE))) == NULL)
        return NULL;

    size1 = MIN(hdeque->capacity - hdeque->head, hdeque->count);
    size2 = hdeque->count - size1;

    memcpy(new_deque, &hdeque->deque[hdeque->head], size1 * sizeof(DATATYPE));
    if (size2 != 0)
        memcpy(new_deque + size1, hdeque->deque, size2 * sizeof(DATATYPE));

    free(hdeque->deque);
    hdeque->deque = new_deque;
    hdeque->capacity = new_capacity;
    hdeque->head = 0;
    hdeque->tail = hdeque->count;
    
    return new_deque;
}

DATATYPE at_deque(HDEQUE hdeque, size_t index)
{
    return hdeque->deque[(hdeque->head + index) % hdeque->capacity];
}

void atp_deque(HDEQUE hdeque, size_t index, DATATYPE *val)
{
    *val = hdeque->deque[(hdeque->head + index) % hdeque->capacity];
}

DATATYPE pop_front_deque(HDEQUE hdeque)
{
    size_t head;

    head = hdeque->head++;
    hdeque->head %= hdeque->capacity;

    return hdeque->deque[head];
}

void pop_frontp_deque(HDEQUE hdeque, DATATYPE *val)
{
    *val = hdeque->deque[hdeque->head++];
    hdeque->head %= hdeque->capacity;
}

size_t insert_deque(HDEQUE hdeque, size_t index, DATATYPE val)
{
    size_t k;

    if (index > hdeque->count)
        return DEQUE_FAILED;

    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
        return DEQUE_FAILED;

    k = hdeque->tail;
    for (size_t i = 0; i < hdeque->count - index; ++i) {
        if (k == 0) {
            k = hdeque->capacity - 1;
            hdeque->deque[0] = hdeque->deque[k];    
        }
        else { 
            hdeque->deque[k] = hdeque->deque[k - 1];
            --k;
        }
    }

    hdeque->deque[k] = val;
    hdeque->tail = (hdeque->tail + 1) % hdeque->capacity;

    ++hdeque->count;
    
    return index;
}

size_t remove_deque(HDEQUE hdeque, size_t index)
{
    size_t k;

    if (index >= hdeque->count)
        return DEQUE_FAILED;

    k = (hdeque->head + index) % hdeque->capacity;
    for (size_t i = 0; i < hdeque->count - index - 1; ++i) {
        if (k == hdeque->capacity - 1) {
            hdeque->deque[k] = hdeque->deque[0];
            k = 0;
        }
        else {
            hdeque->deque[k] = hdeque->deque[k + 1];
            ++k;
        }
    }

    hdeque->tail = (hdeque->tail + hdeque->capacity - 1) % hdeque->capacity;

    --hdeque->count;

    return index;
}

void clear_deque(HDEQUE hdeque)
{
    hdeque->head = hdeque->tail = 0;
    hdeque->count = 0;
}

void destroy_deque(HDEQUE hdeque)
{
    free(hdeque->deque);
    free(hdeque);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "deque.h"

void disp_deque(HDEQUE hdeque);

int main(void)
{
    HDEQUE hdeque;
    
    if ((hdeque = create_deque()) == NULL) {
        fprintf(stderr, "cannot create deque!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i)
        add_back_deque(hdeque, i);

    disp_deque(hdeque);

    remove_deque(hdeque, 1);
    
    disp_deque(hdeque);

    destroy_deque(hdeque);

    return 0;

}

void disp_deque(HDEQUE hdeque)
{
    DATATYPE val;

    for (int i = 0; i < count_deque(hdeque); ++i) {
        val = at_deque(hdeque, i);
        printf("%d ", val);
        fflush(stdout);
    }
    printf("\n");
    printf("head: %zd, tail: %zd, count: %zd, capacity: %zd\n", hdeque->head, hdeque->tail, count_deque(hdeque), capacity_deque(hdeque));
}


/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmalar ve veri yapıları konusunun en önemli alt konularından biri "arama (searching)" işlemleridir. Bir öğenin hızlı bir biçimde 
    bulunması bazı uygulamaların performasını önemli ölçüde etkileyebilmektedir. 

    Arama işlemleri doğrudan ana bellek (RAM) üzerinde ya da diskteki dosyalar üzerinde yapılabilir. Ana belek üzeirndeki aramalara "içsel aramalar
    (internal searches)" işlemleri denilmektedir. Diskteki dosyalar üzerinde yapılan aramalara ise "dışsal arama (external searches)" işlemleri
    denilmektedir. Örneğin bir dizideki elemanın aranması içsel aramaya örnektir. Ancak bir dosya üzerinde yapılan arama dışsal aramaya örnektir. 
    Veritabanı işlemlerini gerçekleştiren araçlar dışsal aramayı etkin bir biçimde yapmaya çalışırlar. Dışsal arama yöntemlerinde içsel arama
    yöntemlerinden farklı algoritmalar kullanılabilmektedir. Biz bu kurusumuzda "içsel arama yöntemleri" üzerinde duracağız. Dışsal arama 
    yöntemleri "Sistem Programlama ve İleri C Uygulamarı II" kursunda ele alınmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Elimizde liste tarzı bir veri yapısı varsa ilk akla gelen arama yöntemi "sıralı arama (sequential search)" denilen yöntemdir. Eğer listenin
    elemanları arasında hiçbir ilişki yoksa (yani elemanlar gelişi güzel biçimde sıralanmışsa) sıralı aramadan başka bir yol yoktur. Sıralı aramda
    listenin başından itibaren her elemana ilgili bulunana kadar bakılır. Eğer aranacak eleman liste içerisinde varsa buna "başarılı arama successful
    search" denilmektedir. Eğer aranacak eleman listede yoksa buna da "başrısız arama (unsuccessful search)" denilmektedir. 

    Başarılı sıralı aramada dizinin uzunluğu N olmak üzere ortalama (N + 1) / 2 karşılaştırma yapılmaktadır. Tabii en kötü durum senaryosunda 
    bu değer N olacaktır. Big O notasyonuna göre arama işlemi O(N) karmaşıklıktadır. O(N) karmaşıklık arama işlemleri için kötü bir karmaşıklıktır. 
    Örneğin 1000000 elamanın bulunduğu bir listede elemanın bulunması için ortalama 500000 karşılaştırma gerekmektedir. Ancak eleman sayısının çok 
    az olduğu listelerde (örneğin eleman sayısının 20'den az olduğu listelerde) en hızlı arama yöntemi yine de sıralı aramadır.     

    Aşağıda tipik bir sıralı arama işlemini yapan fonksiyon örneği verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;

DATATYPE *linear_search(const DATATYPE *array, size_t size, DATATYPE val)
{
    for (size_t i = 0; i < size; ++i)
        if (array[i] == val)
            return (DATATYPE *)&array[i];

    return NULL;
}

int main(void)
{
    DATATYPE array[10] = {4, 67, 34, 12, 45, 32, 98, 11, 9, 85};
    DATATYPE *val;

    if ((val = linear_search(array, 10, 98)) == NULL) {
        fprintf(stderr, "cannot find!..\n");
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *val);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında Knuth "The Art of Computer Programming" kitabının "The Sorting and Searching" isimli üçüncü cildinde sıralı arama sırasında 
    her defasında "dizi bitti mi karşılaştırmasını" elimine etmek için bir yöntem önermiştir. Bu yönteme göre aranacak değer önce dizinin
    sonuna yerleştirilir. Sonra gereksiz biçimde her yinelemede bu kontrol yapılmaz. Çünkü eleman en kötü olasılıkla dizinin sonuna gelindiğinde
    bulunmuş olacaktır. Tabii bunun için dizinin bir fazl uzunlukta açılmış olması gerekir. Aşağıda bu yöntem uygulanmıştır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;

DATATYPE *linear_search(DATATYPE *array, size_t size, DATATYPE val)
{
    size_t i;

    array[size] = val;

    for (i = 0;; ++i)
        if (array[i] == val)
            break;

    return i != size ? &array[i] : NULL;
}

int main(void)
{
    DATATYPE array[10 + 1] = {4, 67, 34, 12, 45, 32, 98, 11, 9, 85};
    DATATYPE *val;

    if ((val = linear_search(array, 10, 98)) == NULL) {
        fprintf(stderr, "cannot find!..\n");
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *val);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Eğer aramanın yapılacağı liste sıraya diziliyse ve O(1) karmaşıklıktakli erişime izin veriyorsa (yani başka bir deyişle arama sıralı bir 
    dizi üzerinde yapılacaksa) bu durumda "ikili arama (binary search)" denilen yöntem tercih edilmelidir. İkili arama yönteminde aralık 
    sürekli bir biçimde ikiye bölünerek daraltılır. İkili aramanın en kötü durumdaki karşılaştırma sayısı log2 N kadardır. (Yani örneğin 1 
    milyon eleman için 20 karşılaştırma). Big O notasyonuna göre en kötü durumdaki algoritma karçalıklığı O(log N) biçimindedir. 
    
    Bir diziyi önce sıraya dizip onun üzerinde ikili arama uygulamak çoğu kez uygun bir yöntem değildir. Çünkü sıraya dizmenin maliyeti sıralı 
    aramadan daha yüksektir. En iyi sıraya dizme algoritmaları O(N log N) karmaşıklıktadır. Tabii eğer dizi güncellenmeyecekse ve çok sayıda 
    arama yaapılacaksa bir kez O(N log N) maliyeti karşılanıp diğer aramalar O(log N) karmaşıklıkta yürütülebilir. 

    İkili arama yapılırken tipik olarak left ve right biçiminde iki çubuk alınır. Bunun orta noktası bulunur. Orat noktasındaki dizi elemanı 
    aranacak elemanla karşılaştırılır. Eğer aranacak eleman orat noktadaki elemandan büyükse soldaki çubuk, küçükse sağdaki çubuk orta noktanın 
    yanına çekilir. Başarısız aramda sağ çubuk sol çubuğun soluna gelmektedir. Burada çubukların ora noktasının şöyle bulunduğuna dikkat ediniz:

    mid = (left + right) / 2;

    Bu işlem aslında aşağıdakiyle eşdeğerdir:

    mid = left + (right - left) / 2;

-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;

DATATYPE *binary_search(const DATATYPE *array, size_t size, DATATYPE val)
{
    size_t left, right, mid;

    left = 0, right = size - 1;

    while (left <= right) {
        mid = (right + left) / 2;
        if (val > array[mid])
            left = mid + 1;
        else if (val < array[mid])
            right = mid - 1;
        else
            return (DATATYPE *)&array[mid];
    }

    return NULL;
}

int main(void)
{
    DATATYPE array[10] = {4, 11, 18, 24, 38, 43, 52, 68, 74, 89};
    DATATYPE *val;

    if ((val = binary_search(array, 10, 100)) == NULL) {
        fprintf(stderr, "cannot find!..\n");
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *val);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Eğer sıralı dizinin eleman sayısı bilinmiyorse (unbounded array) bu durumda önce elemanın bulunduğu bölge üstel bir biçimde (2 ile
    çarpılarak) belirlenir. Sonra o bölgede ikili arama uygulanabilir. Bu yönteme literatürde "üstel arama(exponential serach)" de denilmektedir. 
    Yukarıda da belirttiğimiz gibi üstel arama üst sınıfın bilinmediği sıralı dizilerde özellikle uygulanmaktadır. Sınırın bilindiği durumlarda
    doğrudan ikili aramaya geçilebilir. Örneğin:

    1 3 6 9 11 17 23 28 36 41 48 54 61 67 72 78 82 86 90 92 .....

    Böyle bir dizide bir sınır olmadığı için ikili armanın sağ çubuğunun yerini de eblirleyemeyiz. İşte onu belirleyebilmek için önce 1'den 
    başlatılan bir index sürekli iki ile çarpılarak ilerlenir. Örneğin:

    right = 1;
    while (array[right] < val && right < size)
        right *= 2;
    left = right / 2;

    Burada artık döngüden çıkıldığında aranacak eleman left ile right arasındadır. Bu noktada klasik ikili arama uygulaanabilir. Örneğin 
    yukarıdaki örnek dizide aranacak eleman 78 olsun. Önce 1'inci indeksteki elemana bakılır (3). Sonra 2'inci indeksteki elemana bakılır (6)
    Ondan sonra 4'üncü indeksteki sonra 8'inci (36) sonra 16'ıncı indeksteki (82) elemanlara bakılır. 16'ıncı indeksteki eleman artık aranan 
    eleman olan 78'den büyüktür. Döngü çıkılır ve dizinin 8'inci ve 16'ıncı indeksi arasında ikili arama uygulanır.

    Aşağıda üstel aramaya bir örnek verilmiştir. Her ne kadar bu arama yöntemi aslında sınırı bilinmeyen bir dizi için tercih ediliyorsa da 
    sıralı normal dizilerde de kullanılabilir. (Normal sıralı ve sınırlı dizilerde bu algoritmanın kullanılması gerçek anlamda bir fayda 
    sağlamamaktadır.)

-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;

DATATYPE *binary_search(const DATATYPE *array, size_t size, DATATYPE val)
{
    size_t left, right, mid;

    left = 0, right = size - 1;

    while (left <= right) {
        mid = (right + left) / 2;
        if (val > array[mid])
            left = mid + 1;
        else if (val < array[mid])
            right = mid - 1;
        else
            return (DATATYPE *)&array[mid];
    }

    return NULL;
}

DATATYPE *exponential_search(const DATATYPE *array, size_t size, DATATYPE val)
{
    size_t left, right;

    if (array[0] == val)
        return (DATATYPE *)&array[0];

    right = 1;
    while (right < size && val > array[right])
        right *= 2;

    if (right >= size)
        right = size - 1;

    left = right / 2;

    return binary_search(array + left, right - left + 1, val);
}

int main(void)
{
    DATATYPE array[] = {1, 3, 6, 9, 11, 17, 23, 28, 36, 41, 48, 54, 61, 67, 72, 78, 82, 86, 90, 92};
    DATATYPE *val;

    if ((val = exponential_search(array, sizeof(array) / sizeof(*array), 61)) == NULL) {
        fprintf(stderr, "cannot find!..\n");
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *val);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Sıralı dizilerde arama yapmak için kullanılan diğer bir yöntem de "enterpolasyon araması (interpolation search)" denilen yöntemdir. Bu 
    yöntem ikili arama gibidir ancak aralık orta noktadan değil daha uygun yerden daraltılmaya çalışılır. Örneğin elimizde bir sözlük olsun.
    Bu sözlükte y harfi ile başlayan biz sözcüğü aramak isteyelim. Aramayı sözlüğün ortasından mı yoksa sonlarına doğru bir noktadan mı 
    başlatırız? İşte ikili aramada arama orta noktalar temelinde yapılır. Ancak enterpolasyon aramasında arama orta nokta temelinde değil
    aranack anahtarla oranlı bir biçimde yapılmaktadır. Bu yöntemde de yine left ve right biçiminde iki çubuk alınır. Bu yöntemin ikili 
    aramadan farkı orta noktalar yerine otantılı npktalara bakılmasıdır. Örneğin aranacak değer val olsun. Aranak ye şu orantıyla tespit edilir:

    mid = left + ((right - left) /(array[right] - array[left]) * (val - array[left]))

    İfadedeki şu kısma dikkat ediniz:
    
    (right - left) / (array[right] - array[left])

    Burada yapılmak istenen şey dizi elemanlarındaki bir birim artımın kaç indeks artırımına karşı geldiğinin tespit edilmesidir. Bu tespit 
    edildikten sonra bu değer (val - array[left]) değeri ile çarpılmıştır. Böylece orta nokta değil orantılı bir nokta elde edilmiştir. 

    Pekiyi bu yöntem ikili aramadan daha mı iyidir? Eğer dizideki elemanların arasındaki artırım miktarı n,speten stabil ise yani düzgün 
    bir artırım söz konusu ise bu yöntem ikili aramadan daha hızlı bir aramaya yol açar. Ancak uç değerlerin olduğu durumda bu yöntemin performansı 
    çok düşmektedir. Örneğin:

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1000000

    Bu gibi durumlarda enterpolasyon araması O(N) karmaşıklığa kadar gerilemektedir. O halde sıralı dizinin elemanlarının genel artırımı 
    hakkında bir bilgi sahibi değilsek ikili aramayı tercih etmeliyiz. Ancak dizideki elemanlar nispeten birbirine yakın artırımlarla 
    ilerliyorsa ve dizide uç değerler yoksa bu ymntem daha iyi performans gösterebilmektedir. 

-------------------------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;

DATATYPE *interpolation_search(const DATATYPE *array, size_t size, DATATYPE val)
{
    size_t left, right, mid;

    left = 0, right = size;

    while (left <= right) {
        mid = left + ((right - left) / (array[right] - array[left]) * (val - array[left]));
        if (val > array[mid])
            left = mid + 1;
        else if (val < array[mid])
            right = mid - 1;
        else
            return (DATATYPE *)&array[mid];
    }

    return NULL;
}

int main(void)
{
    DATATYPE array[] = {1, 3, 6, 9, 11, 17, 23, 28, 36, 41, 48, 54, 61, 67, 72, 78, 82, 86, 90, 92};
    DATATYPE *val;

    if ((val = interpolation_search(array, sizeof(array) / sizeof(*array), 12)) == NULL) {
        fprintf(stderr, "cannot find!..\n");
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *val);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aramalar aslında anahtara göre yapılıp aramanın sonucunda o anahtara ilişkin değer elde edilir. Biz yukarıdaki örneklerde yalnızca 
    anahtarların bulunduğu dizide anahtar aradık. Dolayısıyla yukarıdaki örneklerde elde edebileceğimiz tek bilgi "anahtarın dizide var olup
    olmadığı" bilgisidir. Halbuki aramalarda önce anahtar-değer çiftleri veri yapısına yerleştirilir. Sonra anahtar verildiğinde onun değeri 
    elde edilir. Örneğin öğrencilerin bilgileri numaralarına göre aranabilir. Böylece aramayı yapacak kişi öğrencinin numarasını verir. 
    Arama sonucunda o numaralı öğrencinin bilgileri elde edilir. 

    Veri yapıları dünyasında "bir anahtar verildiğinde ona iliştirilmiş olan değerin elde edilmesini" sağlayan veri yapılarına "sözlük 
    (dictionary)" tarzı veri yapıları denilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                66. Ders 17/02/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Sözlük tarzı veri yapılarının en önemli özelliği anahtar verildiğinde değeri çok hızlı bir biçimde bulmasıdır. Anahtar ve değerlerin bir 
    dizide tutulması ve onların sıralı bir biçimde aranması çok yavaş bir yöntemdir. Bu tür durumlarda hızlı aramalar için "algoritmik arama
    yöntemleri" kullanılmaktadır. Algoritmik arama yötemlerinin en çok kullanılanları "hash tabloları (hash tables)" ve "arama ağaçları (search
    trees)" denilen yöntemlerdir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    İdeal bir anahtar-değer araması nasıl olabilir? Şüphesiz ideal durumda aramın O(1) karmaşıklıkta yapılması istenir. Anahtarın bir int 
    değer olduğunu ve kişinin numarasını belirttiğini düşünelim. Biz de numara verildiğinde o kişinin bilgilerini elde etmek isteyelim. Kişilerin
    bilgilerini PERSON isimli bir yapıyla temesil edebiliriz:

    struct PERSON {
        ....
    };

    Sonra da PERSON türünden büyük bir dizi açabiliriz:

    struct PERSON people[MAX_SIZE];

    Sonra da kişilerin numaralarını indeks yaparak bu diziye yerleştirebiliriz. Örneğin numarası 123 olan kişinin bilgileri diziye şöyle
    yerleştirilebilir:

    people[123] = person_info;

    Numarası 123 olan kişinin bilgilerini O(1) karmaşıklıkta çok hızlı bir biçimde aşağıdaki gibi elde edebiliriz:

    person_info = people[123];

    Bu yöntem ilk bakışta çok iyi bir yöntem gibi gözükse de genellikle kullanılabilir bir yöntem değildir. Çünkü burada anahtar int türdendir.
    Ancak anahtarlar farklı tür olabilir. Örneğin anahtar kişinin adı soyadı olabilir. Yazısal bir bilgi indeks belirtmemektedir. Bu yöntemin
    diğer bir sakıncası örneğin kişi numaralarının yüksek basamaklardan oluştuğu durumda o kadar büyük bir dizinin açılması gerekliliğidir. 
    Örrneğin kişinin TC numarasına göre onun bilgilerinin elde edileceği durumda TC numarası 11 digit bir sayıdır. Yani skalası 100 milyar 
    sınırındadır. 100 milyarlık bir yapı dizisini bu amaçla oluşturmak ya mümkün değildir, mümkün olsa da etkin değildir. Bu yönteme "indeskli
    arama index search" denilmektedir. Ancak çok özel durumlarda bu yöntem kullanılabilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Algoritmik aramalarda en çok kullanılan yöntemlerden biri "hash tabloları (hash tables)" denilen yöntemdir. Hash tabloları aslında yukarıda
    belirttiğimiz indeksli arama ile sıralı aramanın hibrit bir biçimidir. Yöntemde ismine "hash tablosu (hash table)" makul bir uzunlukta dizi 
    oluşturulur. Sonra anahtarlar ismine "hash fonksiyonu (hash function)" denilem bir fonksiyona sokularak dizi indeksine dönüştürülür. Sonra da
    dizinin o indeksteki elemanına başvurulur. Örneğinkişinin bilgilerini TC numaralarına göre saklayıp geri almak isteyelim. Hash tablomuzun 
    uzunluğu da 1000 olsun. Hash fonksiyonunun "1000'e bölümden elde edilen kalan" değerini veren fonksiyon olduğunu varsayalım. Bu durumda 
    örneğin 2566198712 TC kimlik numarasına sahip kişinin bilgileri hash tablosunun 712'inci indeksteki elemanında saklanabilir. 72484926820 
    TC kimlik numarasına sahip kişinin belgileri de dizinin 820'inci indeksteki elemanında saklanacktır. Ancak farklı kişilerin TC numaraları 
    hash fonksiyonuna sokuldupunda aynı değer elde edilebilir. Örneğin 6238517712 TC numarasına sahip kişi de dizinin 712'inci indeskteki 
    elemanına yerleşmek isteyecektir. İşte tablosu yönteminde bu duruma "çakışma durumu (collison)" denilmektedir. Hash tablosu yöntemi 
    çakışma durumunda izlenecek stratejiye göre değişik varyasyonlara sahiptir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Hash tabloları yönteminde çakışma durumunda bu sorunu çözmek için iki ana yöntem grubu kullanılmaktadır: Ayrı zincir oluşturma yöntemi
    (separate chaining) ve açık adresleme (open addresiing) yöntemi. Açık adresleme yöntemi de kendi aralarında "doğrusal yoklama (linear probing)",
    "karesel yoklama (quadratic probing)", "çift hash'leme (double hasing)" gibi alternatif alt yöntemlere ayrılmaktadır. Ayrı zincir oluşturma
    ve açık adresleme yöntemlerinin dışında başka çakışma çözümleme stratejileri de vardır. Ancak ağırlıklı olarak bu ikisi tercih edilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Ayrı zincir oluşturma yönteminde (separate chaining) hash tablosu aslında bir bağlıntı liste dizisi gibi oluşturulur. Yani hash tablosunun 
    her elemanı bağlı listenin ilk elemanını (head pointer) göstermektedir. Eklenecek anahtar hash fonksiyonuna sokulur ve bağlı listenin 
    hemen önüne (ya da duruma göre arkasına) eklenir. Eleman aranırken yine anahtar hash fonksiyonuna sokulur ve dizinin ilgili indeksindeki
    bağlı listede sıralı arama yapılır. 

    Hash tablolarına eleman insert etmek O(1) karmaşıklıktadır. Tabii burada kullanılacak hash fonksiyonu da önemlidir. Küçük dönüler içeren 
    hash fonksiyonları O(1) karmaşıklığı yükseltmemektedir. elemanın silinmesi de benzer biçimdedir. Eleman aramanın O(1) karmaşıklıkta 
    olabilmesi için bağlı listelerdeki zincir uzunluklarının kısa olması gerekir. 10 kadar eleman için en hızlı arama yöntemi sıralı aramdır.
    Bu koşulda sıralı aramanın O(1) karmaşıkta oludğu söylenebilir. O halde eğer zincirlerdeki oratalama eleman 10 civarında makul bir düzeyde
    tutulursa arama işleminin de O(1) karmaşıklıkta yapılabileceği söylenebilir. 

    Sözlük tarzı veri yapılarında genel olarak aynı anahtara ilişkin birden fazla anahtar-değer çifti veri yapısına yerleştirilememektedir. 
    Bazı kütüphanelerde buna izin verilebilmektedir. Eğer aynı anahtara ilişkin yeni bir değer insert edilmeye çalışılırsa eski değer yeni 
    değerle yer değiştirmektedir. Yani başka bir deyişle anahtarın değeri değişitirilmektedir. Bazı tasarımlar ise aynı anahtara ilişkin 
    insert yapmayı engellemektedir. Yani bu tasarımlarda yalnızca olmayan elemanı insert edebiliriz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi hash tablolarında kullanılacak iyi bir hash fonksiyonu nasıl olmalıdır? İyi bir hash fonksiyonunun "hızlı" olması gerekir. Çünkü 
    her türlü insert gibi arama gibi işlemlerde hash fonksiyonu kullanılacaktır. İyi bir hash fonksiyonunun "anahtarlar yanlı bile olsa" tabloya
    onları iyi bir biçimde yaydırması gerekir. Örneğin aslında sayısal anahtarlar için "bölümden elde edilen kalan" iyi bir hash fonksiyonu 
    değildir. Hash tablolarında tablonun asal sayı uzunluğunda olması hash fonksiyonlarının daha iyi yaydırmasına yardımcı olmaktadır. (Örneğin
    tablo uzunluğu için 100 yerine 101 değeri tercih edilmelidir.) Hash fonksiyonları "sayıyı indekse dönüştüren" ve "yazıyı indekse" dönüştüren
    fonksiyonlar biçiminde oluşturulabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Hash tablolarının büyütülmesi önemli bir zaman kaybına yol açabilmektedir. Çünkü tablodaki tüm elemanların yeni tablo uzunluğuna göre
    yeniden hash'lenip yeni tablodaki uygun slotlara yerleştirilmesi gerekmektedir. Pekiyi büyütme ne zaman yapılamalıdır? Tablodaki toplam 
    eleman sayısının tablo büyüklüğüne oranına "yükleme faktörü (load factor)" denilmektedir. Genellikle yükleme faktörü 0.75 gibi çok 
    küçük bir değerde tutulur. Ancak yukarıda da belirttiğimiz gibi zincirlerdeki ortalama eleman sayısı 10 civarında olduğunda hash 
    tabloları yine çok hızlı çalışmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda ayrı zincir oluşturma yöntemi (separate chaining) için bir örnek verilmiştir. Bu örnekte çift bağlı liste kullanılmıtır. Aslında 
    çift bağlı liste kullanılmasının bu örnekte bize bir faydası yoktur. Daha önceden de belirttiğimiz gibi çift bağlı listeler özellike düğüm 
    adresi verildiğinde hızlı silme yapmak için tercih edilmektedir. Örneğimizde düğüme dayalı silme yapılamamaktadır. Çünkü silinecek düğüm 
    eğer ilk düğümse tablonun güncellenmesi gerekir. Onun için de anahtarın bilinmesi gerekir. Tabii biz tabloda bağlı listelerin ilk düğümlerinin
    adreslerini tutmak yerine doğrudan bir düğüm de tutabilirdik. Bu durumda düğüme dayalı silmeyi yapabilirdik.

    Örneğimizde hash tablosunu eleman sayısı yükleme faktörüne eriştiğinde büyüttük. Default yükleme faktörünü 0.75 aldık. Yani örneğin 
    tablonun uzunluğu 100 olsun. Tablodaki eleman sayısı 75'e geldiğinde iki kat büyütme sağlanmaktadır. Tabii aslında yükleme faktörünü bu
    kadar düşük tutmayabiliriz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* htable.h */

#ifndef HTABLE_H_
#define HTABLE_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Decalarations */

typedef struct tagPERSON {
    char name[32];
    int city;
    int no;
} PERSON;

typedef struct tagNODE {
    char key[32];            
    PERSON value;
    struct tagNODE *next;
    struct tagNODE *prev;
} NODE;

typedef struct tagHTABLE {
    NODE **table;
    size_t tsize;
    size_t count;
    double lf;
} HTABLE, *HHTABLE;

/* Function Prototypes */

HHTABLE create_lf_ht(size_t tsize, double lf);
NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
PERSON *find_ht(HHTABLE hhtable, const char *key);
bool remove_ht(HHTABLE hhtable, const char *key);
bool resize_ht(HHTABLE hhtable, size_t new_size);
void clear_ht(HHTABLE hhtable);
void destroy_ht(HHTABLE hhtable);

/* inline Function Definitions */

static inline size_t count_ht(HHTABLE hhtable)
{
    return hhtable->count;
}

static inline size_t tsize_ht(HHTABLE hhtable)
{
    return hhtable->tsize;
}

static inline HHTABLE create_ht(size_t tsize)
{
    return create_lf_ht(tsize, 0.75);
}

#endif

/* htable.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "htable.h"

static size_t hash_func(const char *str, size_t tsize);

HHTABLE create_lf_ht(size_t tsize, double lf)
{
    HHTABLE hhtable;

    if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
        return NULL;

    if ((hhtable->table = (NODE **)malloc(tsize * sizeof(NODE *))) == NULL) {
        free(hhtable);
        return NULL;
    }
    for (size_t i = 0; i < tsize; ++i)
        hhtable->table[i] = NULL;

    hhtable->tsize = tsize;
    hhtable->count = 0 ;
    hhtable->lf = lf;

    return hhtable;
}

NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    NODE *new_node;
    size_t hash;
    
    hash = hash_func(key, hhtable->tsize);

    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key)) 
            return NULL;

    if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return NULL;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    
    strcpy(new_node->key, key);
    new_node->value = *value;

    new_node->next = hhtable->table[hash];
    hhtable->table[hash] = new_node;

    ++hhtable->count;

    return new_node;
}

NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    NODE *new_node;
    size_t hash;

    hash = hash_func(key, hhtable->tsize);

    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key)) {
            node->value = *value;
            return node;
        }

    if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return NULL;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    strcpy(new_node->key, key);
    new_node->value = *value;

    new_node->next = hhtable->table[hash];
    hhtable->table[hash] = new_node;

    ++hhtable->count;

    return new_node;
}

PERSON *find_ht(HHTABLE hhtable, const char *key)
{
    size_t hash;

    hash = hash_func(key, hhtable->tsize);
    
    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key))
            return &node->value;

    return NULL;
}

bool remove_ht(HHTABLE hhtable, const char *key)
{
    size_t hash;
    NODE *node, *prev_node;

    hash = hash_func(key, hhtable->tsize);

    prev_node = NULL;
    node = hhtable->table[hash];
    while (node != NULL) {
        if (!strcmp(key, node->key)) {
            if (hhtable->table[hash] == node) 
                hhtable->table[hash] = node->next;
            else
                prev_node->next = node->next;
            free(node);
            --hhtable->count;
            
            return true;
        }

        prev_node = node;
        node = node->next;
    }

    return false;
}

bool resize_ht(HHTABLE hhtable, size_t new_size)
{
    NODE **new_table;
    NODE *node, *temp_node;
    size_t hash;

    if (new_size <= hhtable->tsize)
        return false;

    if ((new_table = (NODE **)malloc(new_size * sizeof(NODE *))) == NULL)
        return false;

    for (size_t i = 0; i < new_size; ++i)
        new_table[i] = NULL;

    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            hash = hash_func(node->key, new_size);
            node->next = new_table[hash];
            new_table[hash] = node;
            node = temp_node;
        }
    }

    free(hhtable->table);
    hhtable->table = new_table;
    hhtable->tsize = new_size;

    return true;
}

void clear_ht(HHTABLE hhtable)
{
    NODE *node, *temp_node;
    
    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            free(node);
            node = temp_node;
        }
        hhtable->table[i] = NULL;
    }
    hhtable->count = 0;
}

void destroy_ht(HHTABLE hhtable)
{
    NODE *node, *temp_node;

    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            free(node);
            node = temp_node;
        }
    }

    free(hhtable);
}

static size_t hash_func(const char *str, size_t tsize)
{
    size_t hash = 0;

    while (*str != '\0') {
        hash = (13 * hash + *str) % tsize;
        ++str;
    }

    return hash;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "htable.h"

void get_random_record(char *key, PERSON *per);

int main(void)
{
    HHTABLE hhtable;
    char name[32];
    PERSON per;
    PERSON specific_per = {"Kaan Aslan", 34, 123456};
    PERSON *retper;

    srand((unsigned)time(NULL));

    if ((hhtable = create_ht(10)) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 1000; ++i) {

        if (i == 500) {
            if (insert_ht(hhtable, "Kaan Aslan", &specific_per) == NULL) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
        else  {
            get_random_record(name, &per);
            
            if (insert_ht(hhtable, name, &per) == NULL) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
    }
    
    if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
        printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
    else
        printf("cannot find key!..\n");
        
    strcpy(per.name, "Kaan Aslan");
    per.city = 35;
    per.no = 1000;

    if (update_ht(hhtable, "Kaan Aslan", &per) == NULL)
        printf("Update failed!..\n");

    if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
        printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
    else
        printf("cannot find key!..\n");

    printf("count: %zd\n", count_ht(hhtable));
    printf("tsize: %zd\n", tsize_ht(hhtable));

    destroy_ht(hhtable);

    return 0;
}

void get_random_record(char *key, PERSON *per)
{
    int i;

    for (i = 0; i < 31; ++i) 
        key[i] = per->name[i] = rand() % 26 + 'A';
    per->name[i] = key[i] = '\0';

    per->city = rand() % 81;
    per->no = rand() % 1000000;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneği tek bağlı liste kullanarak aşağıdaki gibi yeniden yazabiliriz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* htable.h */

#ifndef HTABLE_H_
#define HTABLE_H_

#include <stddef.h>
#include <stdbool.h>

#define HT_DEF_LOAD_FACTOR        0.75

/* Type Decalarations */

typedef struct tagPERSON {
    char name[32];
    int city;
    int no;
} PERSON;

typedef struct tagNODE {
    char key[32];            
    PERSON value;
    struct tagNODE *next;
} NODE;

typedef struct tagHTABLE {
    NODE **table;
    size_t tsize;
    size_t count;
    double lf;
} HTABLE, *HHTABLE;

/* Function Prototypes */

HHTABLE create_lf_ht(size_t tsize, double lf);
NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
PERSON *find_ht(HHTABLE hhtable, const char *key);
bool remove_ht(HHTABLE hhtable, const char *key);
bool resize_ht(HHTABLE hhtable, size_t new_size);
void clear_ht(HHTABLE hhtable);
void destroy_ht(HHTABLE hhtable);

/* inline Function Definitions */

static inline size_t count_ht(HHTABLE hhtable)
{
    return hhtable->count;
}

static inline size_t tsize_ht(HHTABLE hhtable)
{
    return hhtable->tsize;
}

static inline HHTABLE create_ht(size_t tsize)
{
    return create_lf_ht(tsize, HT_DEF_LOAD_FACTOR);
}

#endif

/* htable.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "htable.h"

static size_t hash_func(const char *str, size_t tsize);

HHTABLE create_lf_ht(size_t tsize, double lf)
{
    HHTABLE hhtable;

    if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
        return NULL;

    if ((hhtable->table = (NODE **)malloc(tsize * sizeof(NODE *))) == NULL) {
        free(hhtable);
        return NULL;
    }
    for (size_t i = 0; i < tsize; ++i)
        hhtable->table[i] = NULL;

    hhtable->tsize = tsize;
    hhtable->count = 0 ;
    hhtable->lf = lf;

    return hhtable;
}

NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    NODE *new_node;
    size_t hash;
    
    hash = hash_func(key, hhtable->tsize);

    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key)) 
            return NULL;

    if ((hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return NULL;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    
    strcpy(new_node->key, key);
    new_node->value = *value;

    new_node->next = hhtable->table[hash];
    hhtable->table[hash] = new_node;

    ++hhtable->count;

    return new_node;
}

NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    NODE *new_node;
    size_t hash;

    hash = hash_func(key, hhtable->tsize);

    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key)) {
            node->value = *value;
            return node;
        }

    if ((hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return NULL;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    strcpy(new_node->key, key);
    new_node->value = *value;

    new_node->next = hhtable->table[hash];
    hhtable->table[hash] = new_node;

    ++hhtable->count;

    return new_node;
}

PERSON *find_ht(HHTABLE hhtable, const char *key)
{
    size_t hash;

    hash = hash_func(key, hhtable->tsize);
    
    for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
        if (!strcmp(key, node->key))
            return &node->value;

    return NULL;
}

bool remove_ht(HHTABLE hhtable, const char *key)
{
    size_t hash;
    NODE *node, *prev_node;

    hash = hash_func(key, hhtable->tsize);

    prev_node = NULL;
    node = hhtable->table[hash];
    while (node != NULL) {
        if (!strcmp(key, node->key)) {
            if (hhtable->table[hash] == node) 
                hhtable->table[hash] = node->next;
            else
                prev_node->next = node->next;
            free(node);
            --hhtable->count;
            
            return true;
        }

        prev_node = node;
        node = node->next;
    }

    return false;
}

bool resize_ht(HHTABLE hhtable, size_t new_size)
{
    NODE **new_table;
    NODE *node, *temp_node;
    size_t hash;

    if (new_size <= hhtable->tsize)
        return false;

    if ((new_table = (NODE **)malloc(new_size * sizeof(NODE *))) == NULL)
        return false;

    for (size_t i = 0; i < new_size; ++i)
        new_table[i] = NULL;

    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            hash = hash_func(node->key, new_size);
            node->next = new_table[hash];
            new_table[hash] = node;
            node = temp_node;
        }
    }

    free(hhtable->table);
    hhtable->table = new_table;
    hhtable->tsize = new_size;

    return true;
}

void clear_ht(HHTABLE hhtable)
{
    NODE *node, *temp_node;
    
    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            free(node);
            node = temp_node;
        }
        hhtable->table[i] = NULL;
    }
    hhtable->count = 0;
}

void destroy_ht(HHTABLE hhtable)
{
    NODE *node, *temp_node;

    for (size_t i = 0; i < hhtable->tsize; ++i) {
        node = hhtable->table[i];
        while (node != NULL) {
            temp_node = node->next;
            free(node);
            node = temp_node;
        }
    }

    free(hhtable);
}

static size_t hash_func(const char *str, size_t tsize)
{
    size_t hash = 0;

    while (*str != '\0') {
        hash = (13 * hash + *str) % tsize;
        ++str;
    }

    return hash;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "htable.h"

void get_random_record(char *key, PERSON *per);

int main(void)
{
    HHTABLE hhtable;
    char name[32];
    PERSON per;
    PERSON specific_per = {"Kaan Aslan", 34, 123456};
    PERSON *retper;

    srand((unsigned)time(NULL));

    if ((hhtable = create_ht(10)) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 1000; ++i) {

        if (i == 500) {
            if (insert_ht(hhtable, "Kaan Aslan", &specific_per) == NULL) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
        else  {
            get_random_record(name, &per);
            
            if (insert_ht(hhtable, name, &per) == NULL) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
    }
    
    if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
        printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
    else
        printf("cannot find key!..\n");
        
    strcpy(per.name, "Kaan Aslan");
    per.city = 35;
    per.no = 1000;

    if (update_ht(hhtable, "Kaan Aslan", &per) == NULL)
        printf("Update failed!..\n");

    if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
        printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
    else
        printf("cannot find key!..\n");

    printf("count: %zd\n", count_ht(hhtable));
    printf("tsize: %zd\n", tsize_ht(hhtable));

    destroy_ht(hhtable);

    return 0;
}

void get_random_record(char *key, PERSON *per)
{
    int i;

    for (i = 0; i < 31; ++i) 
        key[i] = per->name[i] = rand() % 26 + 'A';
    per->name[i] = key[i] = '\0';

    per->city = rand() % 81;
    per->no = rand() % 1000000;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi hash tablolarının diğer bir gerçekleştirimi de "açık adresleme (open addressing)" denilen yöntem grubuydu. Açık adresleme
    "yoklama (probing)" biçimine göre çeşitli alt yöntemlere ayrılıyordu. Açık adreslemenin en yaygın ve basit biçimi "doğrusal yoklama 
    (linear probing)" denilen biçimidir. 

    Doğrusal yoklama (linear probing) oldukça basit bir fikre dayanmaktadır. Bu yöntemde yine hash tablosu oluşturulur. Ancak hash tablosunda 
    bağlı listelerin adresleri tutulmaz bizzat değerlerin kendisi tutulur. Tabloya eleman ekleneceği zaman yine anahtardan bir hash değeri 
    elde edilir. Doğrudan değer tablonun hash ile elde edilen indeksine yerleştirilir. Başka bir anahtar aynı hash değerini verdiğinde (yani
    çakışma durumu oluştuğunda) o indeksten itibaren boş yer bulunana kadar yan yana indekslere sırasıyla bakılır. Örneğin hash olarak 123
    değerini elde etmiş olalım. Tablonun 123'üncü elemanın dolu olduğunu düşünelim. Bu durumda 124'üncü elemanına bakarız. O da doluysa 125'inci
    elemanına bakarız. Ta ki boş bir indeks bulunana kadar. Değeri ilk boş indekse yerleştiririz. Tabii bu durumda nasıl başka bir değer 
    bizim indeksimize yerleşmişse biz de aslında başka bir değerin indeksine yerleşmiş oluruz. Ancak bizim yerleştiğimiz indeks için hash'e
    sahip olan değer de bizim yaptığımız gibi ilk boş yer bulunana kadar ilerleyecektir. Bu yöntemde arama işlemi de benzer biçimde yapılmaktadır.
    Yani aranacak elemanın hash değeri elde edilir. O indekse başvurulur. Değer o indekste değilse değer bulunana kadar ya da boş bir slot (bucket)
    görülene kadar yan yana diğer indekslere bakılır. 
    
    Anahtara dayalı eleman silme de benzer biçimde yapılmaktadır. Ancak eleman silindiğinde ilgili slotun (bucket) boşaltılması arama 
    işlemlerinde sorunlara yol açabilecektir. Burada yöntemlerden biri silinen elemanın slotunu boş yapmayıp silinmenin özel bir değerler
    belirtilmesidir. Örneğin her slot için bir status bayrağı tutulabilir. Bu status bayrağı ilgili slotun "dolu" olduğunu", "boş" olduğubnu
    ya da "silinmiş" olduğunu belirtebilir. Böylece arama sırasında "silinmiş" slotlar görüldüğünde durulmaz. İlk boş slot görüldüğünde 
    durulur. Tabii silinmiş slotlara yeni elemanlar eklenebilir. 

    Aşağıda "linear probing" yöntemine bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* htable.h */

#ifndef HASHTABLE_
#define HASHTABLE_

#include <stddef.h>
#include <stdbool.h>

/* Symbolic Constants */

#define HT_DEF_LOAD_FACTOR        0.75
#define HT_STATUS_EMPTY            0
#define HT_STATUS_INUSE            1
#define HT_STATUS_DELETED        2

/* Type Declarations */

typedef struct tagPERSON {
    char name[32];
    int city;
    int no;
} PERSON;

typedef struct tagBUCKET {
    int status;
    char key[32];
    PERSON value;
} BUCKET;

typedef struct tagHTABLE {
    BUCKET *ht;
    size_t tsize;
    size_t count;
    double lf;
} HTABLE, *HHTABLE;

/* Function Prototypes */

HHTABLE create_lf_ht(size_t tsize, double lf);
bool insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
bool update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
bool remove_ht(HHTABLE hhtable, const char *key);
void clear_ht(HHTABLE hhtable);
void destroy_ht(HHTABLE hhtable);
PERSON *find_ht(HHTABLE hhtable, const char *key);


bool resize_ht(HHTABLE hhtable, size_t new_size);

/* inline Function Definitions */

static inline size_t count_ht(HHTABLE hhtable)
{
    return hhtable->count;
}

static inline size_t tsize_ht(HHTABLE hhtable)
{
    return hhtable->tsize;
}

static inline HHTABLE create_ht(size_t tsize)
{
    return create_lf_ht(tsize, HT_DEF_LOAD_FACTOR);
}

#endif

/* htable.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hashtable.h"

static size_t hash_func(const char *str, size_t tsize);

HHTABLE create_lf_ht(size_t tsize, double lf)
{
    HHTABLE hhtable;

    if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
        return NULL;

    if ((hhtable->ht = (BUCKET *)malloc(tsize * sizeof(BUCKET))) == NULL) {
        free(hhtable);
        return NULL;
    }

    for (size_t i = 0; i < tsize; ++i)
        hhtable->ht[i].status = HT_STATUS_EMPTY;

    hhtable->tsize = tsize;
    hhtable->lf = lf;
    hhtable->count = 0;

    return hhtable;
}

bool insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    size_t index;

    if (hhtable->count >= hhtable->tsize)
        return false;

    if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return false;

    index = hash_func(key, hhtable->tsize);

    while (hhtable->ht[index].status != HT_STATUS_EMPTY) {
        if (!strcmp(hhtable->ht[index].key, key))
            return false;
        index = (index + 1) % hhtable->tsize;
    }

    strcpy(hhtable->ht[index].key, key);
    hhtable->ht[index].value = *value;
    hhtable->ht[index].status = HT_STATUS_INUSE;
    ++hhtable->count;

    return true;
}

bool update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
{
    size_t index;

    if (hhtable->count >= hhtable->tsize)
        return false;

    if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
        if (!resize_ht(hhtable, hhtable->tsize * 2))
            return false;

    index = hash_func(key, hhtable->tsize);

    while (hhtable->ht[index].status != HT_STATUS_EMPTY) {
        if (!strcmp(hhtable->ht[index].key, key)) {
            hhtable->ht[index].value = *value;
            return true;
        }
        index = (index + 1) % hhtable->tsize;
    }

    strcpy(hhtable->ht[index].key, key);
    hhtable->ht[index].value = *value;
    hhtable->ht[index].status = HT_STATUS_INUSE;
    ++hhtable->count;

    return true;
}

bool remove_ht(HHTABLE hhtable, const char *key)
{
    size_t index, hash;

    hash = index = hash_func(key, hhtable->tsize);

    do {
        if (hhtable->ht[index].status == HT_STATUS_EMPTY)
            break;

        if (hhtable->ht[index].status == HT_STATUS_INUSE && !strcmp(hhtable->ht[index].key, key)) {
            hhtable->ht[index].status = HT_STATUS_DELETED;
            --hhtable->count;
            return true;
        }
            
        index = (index + 1) % hhtable->tsize;
    } while (index != hash);

    return false;
}

PERSON *find_ht(HHTABLE hhtable, const char *key)
{
    size_t index, hash;

    hash = index = hash_func(key, hhtable->tsize);

    do {
        if (hhtable->ht[index].status == HT_STATUS_EMPTY)
            break;
        
        if (hhtable->ht[index].status == HT_STATUS_INUSE && !strcmp(hhtable->ht[index].key, key))
            return &hhtable->ht[index].value;

        index = (index + 1) % hhtable->tsize; 
    } while (index != hash);

    return NULL;
}

bool resize_ht(HHTABLE hhtable, size_t new_size)
{
    BUCKET *new_ht;
    size_t index;

    if (new_size <= hhtable->tsize)
        return false;

    if ((new_ht = (BUCKET *)malloc(new_size * sizeof(BUCKET))) == NULL)
        return false;

    for (size_t i = 0; i < new_size; ++i)
        new_ht[i].status = HT_STATUS_EMPTY;

    for (size_t i = 0; i < hhtable->tsize; ++i) {
        if (hhtable->ht[i].status == HT_STATUS_INUSE) {
            index = hash_func(hhtable->ht[i].key, new_size);

            while (new_ht[index].status != HT_STATUS_EMPTY)
                index = (index + 1) % new_size;
            new_ht[index] = hhtable->ht[i];
        }
    }

    free(hhtable->ht);
    hhtable->ht = new_ht;
    hhtable->tsize = new_size;

    return true;
}

void clear_ht(HHTABLE hhtable)
{
    for (size_t i = 0; i < hhtable->tsize; ++i)
        hhtable->ht[i].status = HT_STATUS_EMPTY;

    hhtable->count = 0;
}

void destroy_ht(HHTABLE hhtable)
{
    free(hhtable->ht);
    free(hhtable);
}

static size_t hash_func(const char *str, size_t tsize)
{
    size_t hash = 0;

    while (*str != '\0') {
        hash = (13 * hash + *str) % tsize;
        ++str;
    }

    return hash;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "hashtable.h"

void get_random_record(char *key, PERSON *per);

int main(void)
{
    HHTABLE hhtable;
    char name[32];
    PERSON per, *pper;
    PERSON specific_per = {"Kaan Aslan", 34, 123456};

    srand((unsigned)time(NULL));

    if ((hhtable = create_ht(10)) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 1000; ++i) {
        if (i == 500) {
            if (!insert_ht(hhtable, "Kaan Aslan", &specific_per)) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
        else  {
            get_random_record(name, &per);

            if (!insert_ht(hhtable, name, &per)) {
                fprintf(stderr, "cannot insert item!..\n");
                exit(EXIT_FAILURE);
            }
        }
    }

    if (remove_ht(hhtable, "Kaan Aslan"))
        printf("Item removed...\n");
    else
        printf("cannot remove item!..\n");

    if ((pper = find_ht(hhtable, "Kaan Aslan")) != NULL) 
        printf("Found: %s %d %d\n", pper->name, pper->city, pper->no);
    else 
        printf("cannot find record!..\n");

    destroy_ht(hhtable);

    return 0;
}

void get_random_record(char *key, PERSON *per)
{
    int i;

    for (i = 0; i < 31; ++i)
        key[i] = per->name[i] = rand() % 26 + 'A';
    per->name[i] = key[i] = '\0';

    per->city = rand() % 81;
    per->no = rand() % 1000000;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında hash tablolarının oluşturulmasında kullanılan "açık adresleme (open addresing)" yönteminde "linear probing" dışında başka yoklama
    yöntemleri de vardır. Örneğin "quadratic probing" yönteminde çakışma durumunda slotlara sırasıyla bakılmaz. İkinci derece bir polinom 
    yoluyla bakılır. Örneğin ekleme yapmaya çalışalım ve anahtara ilişkin hash değeri 20 olsun. 20 numaralı slot'tun dolu olduğunu düşünelim.
    Biz bu yöntemde 20 + 1, 20 + 2, 20 + 9, 20 + 16 gibi karesel değerlerle yoklama yaparız. 
    
    Çift hash'leme (double hasing) yönteminde ise önce bir hash fonksiyonu ile indeks elde edilir. Eğer çakışma olursa atlanacak miktar 
    ikinci bir hash fonksiyonuna başvurularak belirlenir. 

    Yukarıdaki yöntemlerin en çok tercih edilenleri "ayrı zincir oluşturma "separate chaining" ve "açık adresleme linear probing" yöntemleridir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Biz tek bağlı listelerde bir önceki düğümün sonraki düğümü göstermesini sağladık. Çift bağlı listelerde de bir düğüm hem önceki hem de 
    sonraki düğümü gösteriyordu. Pekiyi bir düğüm birden fazla düğümü gösterirse bu nasıl veri yapısı olur? İşte düğümlerin birden fazla
    düğümü göstermesi durumunda oluşan veri yapılarına "ağaç (tree)" ve "graf (graph)" denilmektedir. Biz önce ağaçları sonra grafları 
    inceleyeceğiz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Her ağacın bir kökü vardır. Kök kendisine gelinemeyen ancak kendisinden her düğüme erişilebilen özel bir düğümdir. Ağaçlarda kök düğümden
    her düğüme gitmenin yalnızca tek bir yolu vardır. Eğer bir düğüme birden fazla yoldan gidilebiliyorsa bu tür veri yapılarına "ağaç" değil
    "graf" denilmektedir. Ağaçlar konusunu iyi anlayabilmek için ağaç terminolojisini biliyor olmak gerekir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Ağaçlarda bir düğümden gidel sonraki düğümlere "o düğümün alt düğümleri (child nodes)" denilmektedir. Kök düğüm haricindeki her düğümün 
    tek bir "üst düğümü (parent node)" vardır. Zaten kök düğüm "üst düğümü olmayan dolayısıyla kendisine bir yerden gelinemeyen" tek düğümdür.
    Ağacın en altında artık başka bir düğüme gidilemeyen düğümlere "yaprak (leaf)" düğümler denilmektedir. Bir ağaçta bir düğümlerin maksimum 
    sahip olabileceği alt düğüm sayısı belirlenmiş olabilir. Bunun n olduğunu varsayalım. Böyle ağaçlara "'li ağaç" denilmektedir. Örneğin
    bir ağaçta her düğümün "en fazla düğümü" olabiliyorsa böyle ağaçlara "ikili ağaçlar (binary trees)", en fazla üç düğümü olabiliyorsa bunlara
    "üçlü ağaçlar (ternary tree)", en fazla n düğümü olabiliyorsa bunlara "n'li ağaçlar (n'ary tree)" denilmektedir. Uygulamada en fazla 
    karşılaşılan ağaçlar ikili ağaçardır. İkili ağaçlarda bir düğümün sıfır tane alt düğümü olabilir. Zaten bu durumda bu düğüm bir yaprak 
    durumundadır. Bir tane alt düğümü olabilir. Ya da en fazla ki tane alt düğümü olabilir.

    Ağaçlarda "her düğümün bir yükseliği (height)" vardır. Düğümün yüksekliği kök düğümden o düğüme gelirken kat edilen yol (edge) sayısı
    ile belirlenir. Kök düğüm yüksekliği 0'dır. Ağacın en yüksek düğümünün yüksekliğine "ağacın yüksekliği" de denilmektedir. 

    Bir ağaçta bütün yaprak düğümlerin yükseklikleri arasındaki fark belli bir değerden büyük değilse (bu değer 1, 2, 3 gibi olabilir) bu 
    ağaçlara "dengelenmiş ağaçlar (balanced trees)" denilmektedir. Örneğin bu farklılık 1 olarak tespit edilmişse bu durum yaprakların 
    yükseklikleri arasında en fazla 1 fark olacağı anlamına gelmektedir. 
    
    Bir N'li ağaçta ağacın en alt kademe dışında tüm kademelerindeki düğümlerinin tam olarak N tane alt düğümü varsa ve ağacın tüm 
    yaprakları aynı yüksekliğe sahipse böyle ağaçlara "tam dolu olan ağaçlar (full trees)" denilmektedir. 

    Bir N'li ağaç en son kademe (en alt kademe) dışında tam dolu ise ve son kademedeki düğümler solda soldan sağa toplanmışsa böyle ağaçlara 
    "tam ağaçlar (complete tree)" denilmektedir.     
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Uygulamada en fazla kullanılan ağaçlar ikili ağaçlardır. Yukarıda da belirttiğimiz gibi ikili ağaçlarda her düğümün en fazla iki alt 
    düğümü olabilmektedir. Bir ikili ağaca ilişkin düğüm aşağıdaki gibi bir yapıyla temsil edilebilir:

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *left;
        struct tagNODE *right;
    } NODE;

    Burada val elemanı düğüme iliştirilen bilgiyi belirtmektedir. left ve right elemanları alt düğümlerin yerlerini tutmaktadır. Eğer düğümün
    sol ya da sağ alt düğümü yoksa bu left ve right elemanları NULL adres içerebilir. Tabii ağacın kök düğümünün yerini de bir biçimde 
    tutmamız gerekir. Bu durumda ağacı temsil eden yapı da şöyle olabilir:

    typedef struct tagBTREE {
        NODE *root;
        size_t count;
    } BTREE, *HBTREE;

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Ağaçlar en çok "arama (search)" amaçlı kullanılmaktadır. Arama amacıyla kullanılan ağaçlara "arama ağaçları (search trees)" denilmektedir. 
    Arama ağaçları için en çok kullanılan ağaçlar ikili ağaçlardır. Bunlara "ikili arama ağaçları (binary search trees)" de denilmektedir.
    Arama ağaçları oluşturulurken bilgiler düğümlerin içerisine yerleştirilir. Tabii düğümler belli bir kurala göre ağaca eklenir. Arama işlemi
    bir anahtara göre yapılacağından arama ağaçlarındaki düğümlerin de "anahtar" ve "değer" çiftlerini tutaması gerekir. Örneğin:

    typedef struct tagNODE {
        KEY key;
        VALUE value;
        struct tagNODE *left;
        struct tagNODE *right;
    } NODE;

    Burada key arama için kullanılan anahtarı value ise arama sonucunda elde edilecek olan değeri belirtmektedir. Örneğin anahtar bir kişinin 
    numarasını belirtiyor olabilir değer de o kişinin bilgilerini belirtiyor olabilir:

    typedef struct tagNODE {
        int key;
        PERSON value;
        struct tagNODE *left;
        struct tagNODE *right;
    } NODE;
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir ikili arama ağacında eleman eklenirken ekleme noktası "küçükler sola büyükler sağa" olacak biçimde yapılmaktadır. Yani kök düğümden 
    girilir. Eklenecek anahtar düğümdeki anahtarla karşılaştırılır. Eklenecek anahtar düğümdeki anahtardan küçükse sola doğru, büyükse sağa
    doğru ilerlenir. Örneğin ağaca sırasıyla 40 60 25 16 52 8 değerleri eklenecek olsun. Ağaöç henüz boş olduğuna göre 40 değeri köke eklenir:

    40

    Sonra 60 değeri 40'dan büyük olduğu için 40'ın sağına eklenir:

    40
        60

    Sonra 25 değeri 40'tan küçük olduğu için 40'ın soluna eklenir:

         40
    25        60

    Sonra 16 değeri 40'tan küçük ve 25'ten küçük olduğu için 25'in soluna eklenir:

             40
        25        60
   16

   Sonra 52 değeri 40'tan büyük 60'tan küçük olduğuna göre 60'ın soluna eklenir:

                40
        25           60
   16           52   
   
   8 değeri 40'tan küçük, 25'ten küçük ve 16'dan küçük olduğuna göre 16'nın soluna eklenir:

                     40
            25           60
       16           52   
   8

    İkili ağaçlarda eleman arama benzer biçimde yapılmaktadır. Kök düğümden girilir aranan anahtar ile düğümdeki anahtar karşılaştırılır. 
    Eğer aranan anahtar düğümdeki anahtardan küçükse sola, büyükse sağa doğru ilerlenir. Yapraklara gelindiğinde yani daha fazla sola ya da 
    sağa gidilemediğinde arama sonlandırılır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    İkili arama ağacına eleman eklemenin en kötü durumdaki (worst case) karmaşıklığı O(N) biçimindedir. Dengelenmiş ağaçlarda ortalama 
    karmaşıklık O(log N) biçimindedir. Arama işlemleri de en kötü durumda O(N) dengelenmiş ağaçlarda O(log N) karmaşıklıktadır. Çünkü arama
    sırasında aslında tıpkı "ikili aramada (binary search)" olduğu gibi sürekli iki bölme yaaparak ilerlenmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Ağaçların dolaşılması özyinelemeli bir biçimde yapılabilir. İkili ağaçlar dört biçimde dolaşılabilmektedir:

    1) In-Order dolaşım
    2) Pre-Order dolaşım
    3) Post-Order dolaşım
    4) Breadt-First Dolaşım

    Buradaki "in", "pre" ve "post" sözcükleri alt düğümlere göre üst düğümün hangi sırada dolaşılacağını belirtmektedir. Bu dolaşımlar 
    soldan-sağa ya da sağdan sola yapılabilmektedir. 

    In-order soldan sağa dolaşım aşağıdaki temsili koddaki (pseudo code) gibi yapılmaktadır:

    void inorder_walk_lr(Node *node)
    {
        if (node->left != NULL)
            inorder_walk_lr(node->left);
        
        printf(node->val);

        if (node->right != NULL)
            inorder_walk_lr(node->right);
    }

    In-order soldan sağa dolaşım ağacın anahtara göre küçükten büyüğe doğru dolaşımını sağlamaktadır. In-order soldan sağa dolaşımda önce
    sol koldan ilerlenmeye çalışıldığına sonra ana düğümün ziyaret edildiğine, sonra da sağ koldan ilerlenmeye çalışıldığına dikkat ediniz. 
    In-order sağdan sola dolaşımda bunun tersi yapılmaktadır:

    void inorder_walk_rl(Node *node)
    {
        if (node->right != NULL)
            inorder_walk_rl(node->right);
            
        printf(node->val);

        if (node->left != NULL)
            inorder_walk_rl(node->left);
    }

    In-order sağdan sola dolaşım anahtara göre büyükten küçüğe bir dolaşıma yol açmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Post-order dolaşımda önce alt düğümler sonra da ana düğün ziyaret edilmektedir. Bu dolaşım da soldan sağa ya da sağdan sola yapılabilmektedir. 
    Temsili kodu aşağıdaki gibidir:

    void postorder_walk_lr(Node *node)
    {
        if (node->left != NULL)
            postorder_walk_lr(node->left);
        
        if (node->right != NULL)
            postorder_walk_lr(node->right);

        printf(node->val);
    }
                
    postoreder dolaşım sağdan sola da yapılabilir. Ancak genel olarak bu ikisi arasında programcıyı ilgilendirecek önemli bir farklılık yoktur. 
    Post-order dolaşım ikili ağaçtaki düğümleri free hale getirmek için gerekmektedir. Çünkü ikili ağaçtaki düğümleri free hale getirme işlemi
    önce alt düğümlerin sonra ana düğümün free hale getirilmesiyle gerçekleştirilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pre-order dolaşımda ise önce ana düğüm ziyaret edilir. Sonra alt düğümler ziyaret edilir. Tabii bu da soldan sağa ya da sağdan sola 
    yapılabilmektedir. Ancak dolsdan sağa dolaşımla sağdan sola dolaşım arasında programcıyı ilgilendiren önemli bir farklılık yoktur. 
    Pre-order soldan sağa dolaşımın temsili kodu şöyledir:

    void preorder_walk_lr(Node *node)
    {
        printf(node->val);
        
        if (node->left != NULL)
            preorder_walk_lr(node->left);
        
        if (node->right != NULL)
            preorder_walk_lr(node->right);
    }

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                            70. Ders 02/03/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------------------------------------------------------------------------------------------
    Kademe Kademe breadth-first dolaşım denilmektedir. Örneğin:

                           1
               2                       3
        4             5            6             7
     8     9     10    11    12   13       14   15   
         
    Buradaki numaralar breadt-first dolaşımın nasıl yapıldığını açıklamaktadır. Breadth-first dolaşım için bir kuyruk sistemine gereksinim 
    vardır. Algoritmada bir düğüm üzerinde işlem yapıldıktan sonra hemen onun alt düğümleri FIFO kuyruk sistemine atılır. İşlem yapılacak 
    düğümler kuyruk sisteminden çekilir. Dolaşımın temsili kodu şöyledir:

    put(root);
    while ((node = get()) != NULL) {
        process(node);
        if (node->left != NULL)
            put(node->left);
        if (node->right != NULL)
            put(node->right);
    }

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    İkili ağaçlarda en karmaşık işlemlerden biri belli bir düğümün silinmesidir. Bu işlemin karmaşık olmasının nedeni birden fazla özel duruma
    sahip olmasındadır. İkili ağaçta düğüm silerken özel durumlar şunlar olabilir:

    1) Silinecek düğüm bir yaprak düğüm ise tek yapılacak şey onun üst düğümünün ilgili göstericisini NULL yapmaktır.

    2) Silinecek düğümün tek bir alt düğümü varsa işlem yine kolaydır. Silinecek düğümün var olan düğümü silinecek düğümün yerine taşınır. 

    3) Silincek düğümün iki alt düğümünün de olması durumunda işlem biraz karmaşık hale gelmektedir. Bu durumda silinecek düğüm yerine geçecek 
    düğüm "ya sol kolun en büyük düğümü" ya da "sağ kolun en küçük düğümü" olabilir. Fakat bu durumda ağaçta birkaç güncellemenin yapılması 
    gerekmektedir. Silinecek düğümünyerine geçecek olan düğümün süt düğümünün ve silinecek düğümün üst düğümünün gencellenmesi gerekmektedir. 
    
    4) Silinecek düğümün kök düğüm olması durumunda ağacın kökünü gösteren göstericinin de güncellenmesi gerekmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda ikili arama ağacının gerçekleştirilmesine ilişkin bir örneek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* binarytree. h */

#ifndef BINARYTREE_H_
#define BINARYTREE_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declararions */

typedef struct tagPERSON {
    char name[32];
    int city;
} PERSON;


typedef struct tagNODE {
    int key;
    PERSON value;
    struct tagNODE *left;
    struct tagNODE *right;
} NODE;

typedef struct tagQNODE {
    struct tagQNODE *next;
    NODE *node;
} QNODE;

typedef struct tagBTREE {
    NODE *root;
    size_t count;
    QNODE *head;
    QNODE *tail;
} BTREE, *HBTREE;

/* Function Prototypes */

HBTREE create_bt(void);
bool insert_item_bt(HBTREE hbtree, int key, const PERSON *value);
bool insert_item_alternative_bt(HBTREE hbtree, int key, const PERSON *value);
bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
bool delete_bt(HBTREE hbtree, int key);
void clear_bt(HBTREE hbtree);
void destroy_bt(HBTREE hbtree);

/* inline Function Fefinitions */

static inline size_t count_bt(HBTREE hbtree)
{
    return hbtree->count;
}

#endif

/* binarytree.c */

#include <stdio.h>
#include <stdlib.h>
#include "binarytree.h"

static bool walk_inorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
static bool walk_inorder_rl_recur(NODE *node, bool (*proc)(int, PERSON *));
static bool walk_postorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
static bool walk_preorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
static void clear_recur(NODE *node);
static void create_queue(HBTREE hbtree);
static NODE *put_queue(HBTREE hbtree, NODE *node);
static NODE *get_queue(HBTREE hbtree);
static void destroy_queue(HBTREE hbtree);
static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3);

HBTREE create_bt(void)
{
    HBTREE hbtree;

    if ((hbtree = (HBTREE)malloc(sizeof(BTREE))) == NULL)
        return NULL;

    hbtree->root = NULL;
    hbtree->count = 0;

    return hbtree;
}

bool insert_item_bt(HBTREE hbtree, int key, const PERSON *value)
{
    NODE *new_node, *node, *parent_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->key = key;
    new_node->value = *value;
    new_node->left = NULL;
    new_node->right = NULL;
    
    if (hbtree->root == NULL) {
        hbtree->root = new_node;
        ++hbtree->count;
        return true;
    }
    node = hbtree->root;

    while (node != NULL) {
        parent_node = node;
        if (key < node->key)
            node = node->left;
        else if (key > node->key)
            node = node->right;
        else {
            node->value = *value;
            return true;
        }
    }

    if (key < parent_node->key)
        parent_node->left = new_node;
    else
        parent_node->right = new_node;

    ++hbtree->count;

    return true;
}

bool insert_item_alternative_bt(HBTREE hbtree, int key, const PERSON *value)
{
    NODE *new_node, *node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return false;
    new_node->key = key;
    new_node->value = *value;
    new_node->left = NULL;
    new_node->right = NULL;

    if (hbtree->root == NULL) {
        hbtree->root = new_node;
        ++hbtree->count;
        return true;
    }
    node = hbtree->root;

    while (node != NULL) {
        if (key < node->key)
            if (node->left == NULL) {
                node->left = new_node;
                break;
            }
            else
                node = node->left;
        else if (key > node->key) 
            if (node->right == NULL) {
                node->right = new_node;
                break;
            }
            else
                node = node->right;
        else {
            node->value = *value;
            return true;
        }
    }

    ++hbtree->count;

    return true;
}

bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
{
    if (hbtree->root != NULL)
        return walk_inorder_lr_recur(hbtree->root, proc);

    return true;
}

bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
{
    if (hbtree->root != NULL)
        return walk_inorder_rl_recur(hbtree->root, proc);

    return true;
}

bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
{
    if (hbtree->root != NULL)
        return walk_postorder_lr_recur(hbtree->root, proc);

    return true;
}

bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
{
    if (hbtree->root != NULL)
        return walk_preorder_lr_recur(hbtree->root, proc);

    return true;
}

void clear_bt(HBTREE hbtree)
{
    if (hbtree->root != NULL) {
        clear_recur(hbtree->root);
        hbtree->root = NULL;
        hbtree->count = 0;
    }
}

void destroy_bt(HBTREE hbtree)
{
    if (hbtree->root != NULL) 
        clear_recur(hbtree->root);

    free(hbtree);
}

bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
{
    NODE *node;
    bool result = true;

    create_queue(hbtree);
    put_queue(hbtree, hbtree->root);

    while ((node = get_queue(hbtree)) != NULL) {
        if (!proc(node->key, &node->value)) {
            result = false;
            break;
        }
        if (node->left != NULL)
            if (put_queue(hbtree, node->left) == NULL) {
                fprintf(stderr, "put_queue cannot allocate memory!..\n");
                result = false;
                break;
            }
        if (node->right != NULL)
            if (put_queue(hbtree, node->right) == NULL) {
                result = false;
                fprintf(stderr, "put_queue cannot allocate memory!..\n");
                break;
            }
    }

    destroy_queue(hbtree);

    return result;
}

bool delete_bt(HBTREE hbtree, int key)
{
    NODE *delete_node, *delete_parent_node, *replace_parent_node, *replace_node;

    delete_node= hbtree->root;
    delete_parent_node = NULL;

    while (delete_node != NULL) {
        if (delete_node->key == key)
            break;
        delete_parent_node = delete_node;
        if (key < delete_node->key)
            delete_node = delete_node->left;
        else if (key > delete_node->key )
            delete_node = delete_node->right;
    }

    if (delete_node == NULL)
        return false;

    if (delete_node->left == NULL)
        subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->right);
    else if (delete_node->right == NULL)
        subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->left);
    else {
        replace_parent_node = delete_node;
        replace_node = delete_node->right;
        while (replace_node->left!= NULL) {
            replace_parent_node = replace_node;
            replace_node= replace_node->left;
        }
        if (replace_parent_node != delete_node) {
            subtree_shift(hbtree, replace_parent_node, replace_node, replace_node->right);
            replace_node->right= delete_node->right;
        }
        subtree_shift(hbtree, delete_parent_node, delete_node, replace_node);
        replace_node->left = delete_node->left;
    }

    free(delete_node);
    --hbtree->count;

    return true;
}

static bool walk_inorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
{
    if (node->left != NULL)
        if (!walk_inorder_lr_recur(node->left, proc))
            return false;

    if(!proc(node->key, &node->value))
        return false;

    if (node->right != NULL)
        if (!walk_inorder_lr_recur(node->right, proc))
            return false;

    return true;
}

static bool walk_inorder_rl_recur(NODE *node, bool (*proc)(int, PERSON *))
{
    if (node->right != NULL)
        if (!walk_inorder_rl_recur(node->right, proc))
            return false;

    if (!proc(node->key, &node->value))
        return false;

    if (node->left != NULL)
        if (!walk_inorder_rl_recur(node->left, proc))
            return false;
    
    return true;
}

static bool walk_postorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
{
    if (node->left != NULL)
        if (!walk_postorder_lr_recur(node->left, proc))
            return false;

    if (node->right != NULL)
        if (!walk_postorder_lr_recur(node->right, proc))
            return false;

    if (!proc(node->key, &node->value))
        return false;

    return true;
}

static bool walk_preorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
{
    if (!proc(node->key, &node->value))
        return false;

    if (node->left != NULL)
        if (!walk_preorder_lr_recur(node->left, proc))
            return false;

    if (node->right != NULL)
        if (!walk_preorder_lr_recur(node->right, proc))
            return false;

    return true;
}

static void clear_recur(NODE *node)
{
    if (node->left != NULL)
        clear_recur(node->left);

    if (node->right != NULL)
        clear_recur(node->right);

    free(node);
}

static void create_queue(HBTREE hbtree)
{
    hbtree->head = NULL;
    hbtree->tail = NULL;
}

static NODE *put_queue(HBTREE hbtree, NODE *node)
{
    QNODE *new_qnode;

    if ((new_qnode = (QNODE *)malloc(sizeof(QNODE))) == NULL)
        return NULL;

    new_qnode->node = node;
    new_qnode->next = NULL;

    if (hbtree->tail != NULL)
        hbtree->tail->next = new_qnode;
    else
        hbtree->head = new_qnode;
    hbtree->tail = new_qnode;

    return node;
}

static NODE *get_queue(HBTREE hbtree)
{
    QNODE *qnode;
    NODE *rnode;

    if (hbtree->head == NULL)
        return NULL;
    qnode = hbtree->head;
    hbtree->head = qnode->next;
    if (hbtree->head == NULL)
        hbtree->tail = NULL;

    rnode = qnode->node;
    free(qnode);

    return rnode;
}

static void destroy_queue(HBTREE hbtree)
{
    QNODE *qnode, *temp_qnode;

    qnode = hbtree->head;

    while (qnode != NULL) {
        temp_qnode = qnode->next;
        free(qnode);
        qnode = temp_qnode;
    }
}

static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3)
{
    if (node1 == NULL)
        hbtree->root = node3;
    else if (node1->left == node2)
        node1->left = node3;
    else
        node1->right = node3;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "binarytree.h"

bool disp_node(int key, PERSON *value);

int main(void)
{
    HBTREE hbtree;
    PERSON per = {"Noname", 0};
    int keys[] = {70, 50, 34, 56, 19, 80, 67, 43, 27, 76, 79, 105, 82, 65, 0};

    if ((hbtree = create_bt()) == NULL) {
        fprintf(stderr, "cannot create binary tree!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; keys[i] != 0; ++i)
        if (!insert_item_alternative_bt(hbtree, keys[i], &per)) {
            fprintf(stderr, "cannot insert item: %d\n", keys[i]);
            exit(EXIT_FAILURE);
        }

    walk_inorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_inorder_rl_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_postorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_inorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_preorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_breadth_first_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    if (!delete_bt(hbtree, 70)) {
        fprintf(stderr, "cannot find item!...\n");
        exit(EXIT_FAILURE);
    }
    
    walk_breadth_first_bt(hbtree, disp_node);
    printf("\n------------------------------\n");

    printf("total item: %jd\n", count_bt(hbtree));

    destroy_bt(hbtree);

    return 0;
}

bool disp_node(int key, PERSON *value)
{
    printf("%d ", key);
    fflush(stdout);

    return true;;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örnekte "dengelenmemiş (unbalanced)"    arama ağacı oluşturduk. Dengelenmemiş ağaçlar bir arama performansını düşürebilmektedir.
    Dengelenmemiş ikili ağaçlarda eleman eklemenin ve aramanın "en kötü durum senaryosu (worst case)" O(N) karmaşıklığa kadar kötüleşmektedir. 
    Örneğin ağaca aşağıdaki gibi sıralı bilgilerin geldiğini düşünelim: 
    
    10, 20, 30, 40, 50, 60, 70, ...

    Bu durumda ikili arama ağacının bağlı listeden bir farkı kalmamaktadır. Bu nedenle uygulamalarda "dengelenmiş (balanced)" ağaçlar tercih
    edilmektedir. Dengelenmiş ağaçlarda ağaca her eleman eklendiğinde ve eleman silindiğinde ağacın dengede kalması sağlanmaktadır. 

    Pekiyi dengelenmiş ağaçlar nasıl oluşturulmaktadır? Dengeleme işlemi her eleman eklendiğinde ve silindiğinde O(1) karmaşıklıkta ya da 
    O(log N) karmaşıklıkta yapılan bir işlemdir. Böylece ağacın bir yandan uzamaıs engellenir. Ağacın tüm yapraklarının benzer yükseklikte 
    kalması sağlanır. Bunun sonucunda arama işlemi de en kütü durum senaryosunda O(log N) olacaktır. Dengeleme için çeşitli algoritmalar
    önerilmiştir. En önemli iki dengeleme algoritmasına AVL (Adelson-Velsky-Landis) ve "Red Black Tree" algoritması denilmektedir. 
    Bu iki algoritma arasında özel durumlara göre birinin lehine farlılıklar oluşabilmektedir. Uyglamada en çok kullanılan dengeleme algoritması 
    AVL algoritmasıdır. Bu dengeleme algoritmasının kullanıldığı arama ağaçlarına "AVL ağacı (AVL tree)" da denilmektedir. 

    Biz kursumunda ikili ağaçların dengelenmesi üzerinde durmayacağız. Bu konu ve diğer ağaç algoritmaları "Sistem Programalama ve İleri C 
    Uygulamaları-II" kursunun konusu içerisindedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi 3'lü, 4'lü 5'li gibi arama ağaçları nasıl oluşturulmaktadır? Bu tür arama ağaçlarına "B-Tree" denilmektedir. 2'den daha fazla alt
    düğüme sahip olan ağaçlar bellek üzerindeki aramalarda (internal search) tercih edilmemektedir. Bunlar tipik olarak veritabanı yönetim 
    sistemleri (DBMS) tarafından disk üzerindeki aramalarda (external search) kullanılmaktadır. Pekiyi örneğin 3'lü bir arama ağacı nasıl 
    organize edilmektedir. İşte bu tür durumlarda düğüm üzerinde tek değer değil birden fazla değer tutulur. Örneğin 3'lü bir amarama ağacında 
    göstericilerden biri a değerinden küçük olan düğümü, diğeri a ile b arasında olan düğümü diğeri de b'den büyük olan düğümü gösterir. 
    Böylece ağacın yükseklüği azaltılmış olur. Disk işlemlerinde her bir düğümden diğerine geçiş için bir disk okuması gerektiği için bu durum
    ilgili kayda daha hızlı erişilmesine olanak sağlamaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Çok kullanılan diğer bir ağaç türüne de "heap ağacı" ya da kısaca "heap" denilmektedir. Buradaki "heap" teriminin dinamik bellek yönetiminde
    geçen "heap" terimi ile bir ilgisi yoktur. Heap ağaçları "öncelik kuyruklarını (priority queues)" oluşturmak için kullanılmaktadır. 
    
    Öncelik kuyruklarında kuyruğa yerleştirilen her elemanın bir öncelik derecesi (numarası) vardır. Kuyruktan eleman alınacağı zaman baştaki
    ya da sondaki eleman değil öncelik numarası en yüksek olan eleman alınmaktadır. Örneğin kuyrukta şu elemanlar olsun:

    4  10  7  2  14  6  5

    Kuyruğun başının sol taraf olduğunu düşünelim. Yani kuyruğa son eklenen eleman 5, ilk eklenen eleman ise 4 olsun. Eğer bu kuyruk sistemi 
    FIFO olsaydı biz 4'ü alırdık. Kuyruk sistemi LIFO (stack) olsaydı biz kuyruktan 5'i alırdık. İşte eğer bir öncelik kuyruğu söz konusu ise
    biz kuyruktan 14'ü alırız. Çünkü en öncelikli eleman 14'tür. Bundan sonra yeniden kuyruktan eleman almak istesek bu kez 10'u alırız. 

    Öncelik kuyruklarından eleman alma bu haliyle O(N) karmaşıklıkta bir işlemdir. İşte heap ağaçları bu işlemi O(log N) karmaşıklığa düşürmek
    için kullanılmaktadır.

    Heap ağaçları "heap sort" denilen sıraya dizme algortimesının gerçekleştirilmesinde de kullanılmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Heap ağaçları tipik olarak ikili ağaç biçiminde karşımıza çıkmaktadır. Her ne kadar heap ağaçları 2'den fazla düğüme sahip olabilirse de 
    uygulamada 2'li heap ağaçları tercih edilmektedir. İkili heap ağaçlarına İngilizce "binary heap" de denilmektedir. Biz bu bağlamda "heap 
    ağacı" ya da "heap" dediğimizde "ikili heap ağaçları" anlaşılmalıdır. 

    Bir heap ağacının iki önemli karaktersitiği vardır:

    1) Heap ağaçları her zaman "tam ağaç (complete tree)" biçimindedir. Tam ağaçlarda yaprak düğümlerin dışında tüm düğümlerin 2 alt düğüme
    sahip olduğunu yaprakların ise en alt kademede soldan sağa bulunduğunu anımsayınız. 

    2) Heap ağacında bir düğümün tüm alt düğümleri o düğümden düşük ya da yüksek değerleri sahip olmak zorundadır. Eğer bir düğüm alt 
    düğümlerinden daha yüksek değere sahipse böyle heap ağaçlarına "max-heap", eğer bir düğüm alt düğümlerinden daha düşük değere sahipse 
    böyle heap ağaçlarına "min-heap" denilmektedir. Örneğin:

                        100
                50                  70
          30          40      60     35
     17       24   32 

     Bu örnekteki ağaç yukarıdaki iki kuralı karşıladığı için bir "max-heap" ağacıdır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Heap ağacına eleman eklenirken eleman önce "tam ağacı (complete tree)" bozmayacak biçimde en alta en soldaki boş yere eklenir. Sonra 
    eklenen eleman kuralı bozabileceği için üst düğümle karşılaştırılarak yer değiştirilir. Bu işlem kural bozulmayana kadar devam ettirilir. 
    Bu işleme İngilizce "heapify" da denilmektedir. Örneğin yukarıdaki ağaca 75 eklemek isteyelim. Önce eklemeyi en altta en sol boş pozisyona 
    yaparız:

                        100
                50                  70
          30          40      60     35
     17       24   32    75

     Sonra bu 75 değeri üst düğümle karşılatırılıp duruma yer göre yer değiştirilir:

                         100
                50                  70
          30          75      60     35
     17       24   32    40

     Bu işlem devam ettirlir:

                         100
                75                  70
          30          50      60     35
     17       24   32    40

     Artık kural korunmuştur ve ekleme süreci bitirilir. Heap ağacından eleman alınacağı zaman her zaman kökten eleman alınır. Örneğin yukarıdaki
     ağaçtan eleman alacaksak 100'ü alırız. Bu durumda 100'ün yerine geçecek eleman onun alt düğümlerinin büyük olanıdır:

                         75
                75                  70
          30          50      60     35
     17       24   32    40

     Tabii alt düğümün yerine onun alt düğümlerinden en büyük olan getirilir:

                        75
                75                  70
          30          50      60     35
     17       24   32    40

     Böyle devam edilir:

                         75
                50                  70
          30          75      60     35
     17       24   32    40

     Ta ki yapraklara iniline kadar:

                         75
                50                  70
          30          40      60     35
     17       24   32    75

     Alınan değer en aşağı indiğinde işleme son verilir ve tam ağaç bozulmayacak biçimde o eleman silinir. 

     Heap ağacına eleman eklemek en kötü durumda O(log N) karmaşıklıktadır. Eleman almak da aynı biçimdedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında heap ağaçlarında gerçekte ağaç oluşturulmamaktadır. Çünkü tam ağaçlar her zaman diziye dönüştürülebilmektedir. Bir heap ağacını
    diziye dönüştürürken dizinin 0'ıncı indisli elemanını kolaylık olsun diye boş bırakabiliriz. Diziye dönüştürme şu kurala göre yapımaktadır:
    Her zaman üst düğümün alt düğümleri üzet düğümün indeksinin iki katı ve iki katından bir fazla yerde bulunur. Aşağıdaki heap ağacına
    bakınız:

                        100
                50                  70
          30          40      60     35
     17       24   32    75

     Bu heap ağacının diziye dönüştürülmesi şöyle yapılacaktır:

     0   1    2   3   4    5   6    7   8   9  10  11 
     x  100  50  70   30  40   60  35  17  26  32  75 
     
     Burada örneğin 70 numaralı elemanın indeksi 3'tür. Bu durumda bu elemanın alt düğümleri 6 ve 7'inci indekstedir. İşte aslında heap 
     ağaçlarında hiç ağaç oluşturulmaz. Sanki ağaç oluşturulmuş gibi her şey dizi üzerinde yukarıdaki indeks kuralına uygun bir biçimde yapılır. 
 -------------------------------------------------------------------------------------------------------------------------------------------*/
 
/*------------------------------------------------------------------------------------------------------------------------------------------
        Aşağıda heap ağaçları ile öncelik kuyruklarının oluşturulmasına bir örnek verilmektedir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* hpqueue.h */

#ifndef PQUEUE_H_
#define PQUEUE_H_

#include <stddef.h>
#include <stdbool.h>

#define PQUEUE_DEF_CAPACITY        8

/* Type Declarartion */

typedef struct tagPERSON {
    char name[32];
} PERSON;

typedef PERSON VALUETYPE;

typedef struct tagHEAP_ITEM {
    int prio;
    VALUETYPE value;
} HEAP_ITEM;

typedef struct PQUEUE {
    HEAP_ITEM *hitems;
    size_t capacity;
    size_t count;
} PQUEUE, *HPQUEUE;

/* Function Prototypes */

HPQUEUE create_pq(void);
bool put_pq(HPQUEUE hpqueue, int prio, VALUETYPE *value);
bool get_pq(HPQUEUE hpqueue, int *prio, VALUETYPE *value);
bool resize_pq(HPQUEUE hpqueue, size_t new_capacity);
void destroy_pq(HPQUEUE hqueue);


/* inline Function Definitions */

static inline bool isempty_pq(HPQUEUE hpqueue)
{
    return hpqueue->count == 0;
}

static inline void clear_pq(HPQUEUE hpqueue)
{
    hpqueue->count = 0;
}

#endif

/* hpqueue.c */

#include <stdio.h>
#include <stdlib.h>
#include "pqueue.h"

HPQUEUE create_pq(void)
{
    HPQUEUE hpqueue;

    if ((hpqueue = (HPQUEUE)malloc(sizeof(PQUEUE))) == NULL)
        return NULL;

    if ((hpqueue->hitems = (HEAP_ITEM *)malloc(sizeof(HEAP_ITEM) * PQUEUE_DEF_CAPACITY)) == NULL) {
        free(hpqueue);
        return NULL;
    }
    hpqueue->capacity = PQUEUE_DEF_CAPACITY;
    hpqueue->count = 0;

    return hpqueue;
}


bool put_pq(HPQUEUE hpqueue, int prio, VALUETYPE *value)
{
    size_t index;

    if (hpqueue->count + 1 == hpqueue->capacity) 
        if (!resize_pq(hpqueue, hpqueue->capacity * 2))
            return false;

    index = hpqueue->count + 1;

    while (index > 1 && prio > hpqueue->hitems[index / 2].prio) {
        hpqueue->hitems[index] = hpqueue->hitems[index / 2];
        index /= 2;
    }
    hpqueue->hitems[index].prio = prio;
    hpqueue->hitems[index].value = *value;
    ++hpqueue->count;

    return true;
}

bool get_pq(HPQUEUE hpqueue, int *prio, VALUETYPE *value)
{
    size_t i, ci;

    if (hpqueue->count == 0)
        return false;

    *prio = hpqueue->hitems[1].prio;
    *value = hpqueue->hitems[1].value;

    i = 1;
    ci = 2;

    while (ci <= hpqueue->count) {
        if (ci + 1 < hpqueue->count && hpqueue->hitems[ci + 1].prio > hpqueue->hitems[ci].prio)
            ++ci;
        if (hpqueue->hitems[hpqueue->count].prio > hpqueue->hitems[ci].prio)
            break;
            
        hpqueue->hitems[i] = hpqueue->hitems[ci];
        i = ci;
        ci *= 2;
    }
    hpqueue->hitems[i] = hpqueue->hitems[hpqueue->count];
    --hpqueue->count;

    return true;
}

bool resize_pq(HPQUEUE hpqueue, size_t new_capacity)
{
    HEAP_ITEM *hitems;
    
    if (new_capacity <= hpqueue->capacity)
        return false;

    if ((hitems = (HEAP_ITEM *)realloc(hpqueue->hitems, new_capacity * sizeof(HEAP_ITEM))) == NULL)
        return false;

    hpqueue->hitems = hitems;
    hpqueue->capacity = new_capacity;

    return true;
}

void destroy_pq(HPQUEUE hpqueue)
{
    free(hpqueue->hitems);
    free(hpqueue);
}


/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "pqueue.h"

void disp_pq(HPQUEUE hpqueue)
{
    for (size_t i = 1; i <= hpqueue->count; ++i)
        printf("%d  ", hpqueue->hitems[i].prio);
    printf("\n");
}

int main(void)
{
    HPQUEUE hpqueue;
    int prios[] = {100, 85, 90, 60, 70, 10, 40, -1};
    VALUETYPE values[] = {{"Ali Serce"}, {"Sacit Bulut"}, {"Ayse Er"}, {"Necati Ergin"}, {"Guray Sonmez"},
        {"Ziya Taskent"}, {"Gencay Coskun"}};
    int prio;
    VALUETYPE value;

    if ((hpqueue = create_pq()) == NULL) {
        fprintf(stderr, "cannot create priority queue!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; prios[i] != -1; ++i)
        if (!put_pq(hpqueue, prios[i], &values[i])) {
            fprintf(stderr, "cannot add item!..\n");
            exit(EXIT_FAILURE);
        }

    disp_pq(hpqueue);

    while (!isempty_pq(hpqueue)) {
        if (!get_pq(hpqueue, &prio, &value)) {
            fprintf(stderr, "cannot get value!..\n");
            exit(EXIT_FAILURE);
        }
        printf("prio: %d, value: %s\n", prio, value.name);
        disp_pq(hpqueue);
        printf("----------------------\n");
    }

    destroy_pq(hpqueue);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Şimdiye kadar yaptığımız örneklerde ilgili veri yapılarının türleri baştan belirlenmiş durumdaydı. Her ne kadar bazı örneklerde biz
    veri yapısı içerisinde tutulacak dğerlerin türlerini DATATYPE, VALUETYPE gibisi isimlerle typedef ettiysek de bu durum bir genelleme 
    oluşturmamaktadır. Başka bir deyişle şimdiye kadar yaptığımız örneklerde veri yapılarımız toplamda tek bir türe ilişkin olabilmektedir. 
    Örneğin bağlı listeler için şu yapıları kullanmıştık:

    typedef int DATATYPE;

    typedef struct tagNODE {
        DATATYPE val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagLLIST {
        NODE head;
        NODE *tail;
        size_t count;
    } LLIST, *HLLIST;

    Burada biz birden fazla bağlı liste oluşturabilecek bir mekanizma sağlamıştık. Ancak tüm bağlı listelerimiz DATATYPE türünü tutmaktadır. 
    DATATYPE türü int olarak typedef edilldiğine göre biz ne kadar bağlı liste yaratırsak yaratalım hepsi int değerleri tutan bağlı listeler 
    olacaktır. Örneğin İkili arama ağaçları için şu yapıları kullanmıştık:

    typedef struct tagPERSON {
        char name[32];
        int city;
    } PERSON;

    typedef struct tagNODE {
        int key;
        PERSON value;
        struct tagNODE *left;
        struct tagNODE *right;
    } NODE;

    typedef struct tagBTREE {
        NODE *root;
        size_t count;
    } BTREE, *HBTREE;

    Burada da biz birden fazla bağlı liste oluşturabiliyorduk. Ancak bu bağlı listelerin hepsinin anahtarı int değerleri için PERSON türünden
    olmak zorundadır. Özetle şimdiye oluşturduğumuz veri yapıları "genel" değil belli bir tür için oluşturuldu. Şimdi biz ""türden bağımsız"
    yani her türle çalışabilecke veri yapılarının nasıl oluşturalacağı üzerinde duracağız. Böylelikle veri yapılarını her tür için çalışabilir
    hale getirebileceğiz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Türden bağımsız veri yapılarının oluşturulabilmesi için iki teknik kullanılabilir:

    1) void Gösterici Tekniği
    2) Gömme Tekniği

    void gösterici tekniği aslında etkin bir yöntem değildir. Bu yöntemin hem kullanımı zordur hem de bu yöntem diğerine göre yavaştır. 
    Bu nedenle programcılar gömme tekniğini tercih etmektedir. Örneğin Linux kaynak kodlarında veri yapılarında genellik sağlamak için hep
    bu teknik kullanılmıştır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    void gösterici tekniğinde veri yapısının tutacağı değerlerin türleri yerine onların adresleri ve uzunlukları kullanılır. Eğer karşılaştırma
    yapılmak istenirse callback fonksiyonlardan faydalanılmaktadır. Örneğin ikili arama ağacını bu teknikle gerçekleştirmek isteyelim. Biz 
    artık ağaç düğümlerinde tutulacak anahtar ve değerin türünü bilmek zorunda değiliz. Ancak onların uzunluklarını bilmek zorundayız. 
    Bunun için gereken yapı bildirimleri şöyle olabilir:
        
    typedef struct tagNODE {
        struct tagNODE *left;
        struct tagNODE *right;
        char key_value[];
    } NODE;

    typedef struct tagQNODE {
        struct tagQNODE *next;
        NODE *node;
    } QNODE;

    typedef struct tagBTREE {
        NODE *root;
        size_t count;
        QNODE *head;
        QNODE *tail;
        size_t key_size;
        size_t value_size;
        bool (*compare)(const void *, const void *);
    } BTREE, *HBTREE;

    Burada tagNODE yapısının son elemanına dikkat ediniz. Burada C99 ile birlikte C'ye eklenmiş olan "flexible array member" özelliği 
    kullanılmıştır. Bu özelliğe göre bir yapının son elemanı (başka elemanlarında bu yapılamaz) uzunluğu belirtilmemiş bir dizi olabilir. 
    Derleyici bu dizi için bir yer ayırmamaktadır. Bu diziden amaç ilgili yapı nesnesinin bellekteki bitim adresinin kolay bir biçimde tespit
    edilmesini sağlamaktır. Handle alanında (tagBTREE yapısı) anahtar ve değer olarak kullanılacak bilgilerin uzunluğunun ve bir karşılaştırma
    fonksiyonunun adresinin bulundurulduğna dikkat ediniz. Biz ikili arama ağacını yaratırken bu bilgileri vermek zorundayız. 

    Aşağıda void göstericiler kullanılarak türden bağımsız ikili arama ağacına bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* binarytree.h */

#ifndef BINARYTREE_H_
#define BINARYTREE_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declararions */

typedef struct tagNODE {
    struct tagNODE *left;
    struct tagNODE *right;
    char key_value[];
} NODE;

typedef struct tagQNODE {
    struct tagQNODE *next;
    NODE *node;
} QNODE;

typedef struct tagBTREE {
    NODE *root;
    size_t count;
    QNODE *head;
    QNODE *tail;
    size_t key_size;
    size_t value_size;
    int (*compare)(const void *, const void *);
} BTREE, *HBTREE;

/* Function Prototypes */

HBTREE create_bt(size_t key_size, size_t value_size, int (*compare)(const void *, const void *));
bool insert_item_bt(HBTREE hbtree, const void *key, const void *value);
bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
bool delete_bt(HBTREE hbtree, const void *key);
void clear_bt(HBTREE hbtree);
void destroy_bt(HBTREE hbtree);

/* inline Function Fefinitions */

static inline size_t count_bt(HBTREE hbtree)
{
    return hbtree->count;
}

#endif

/* binarytree.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "binarytree.h"

static bool walk_inorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
static bool walk_inorder_rl_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
static bool walk_postorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
static bool walk_preorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
static void create_queue(HBTREE hbtree);
static NODE *put_queue(HBTREE hbtree, NODE *node);
static NODE *get_queue(HBTREE hbtree);
static void destroy_queue(HBTREE hbtree);
static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3);
static void clear_recur(NODE *node);

HBTREE create_bt(size_t key_size, size_t value_size, int (*compare)(const void *, const void *))
{
    HBTREE hbtree;

    if ((hbtree = (HBTREE)malloc(sizeof(BTREE))) == NULL)
        return NULL;

    hbtree->root = NULL;
    hbtree->count = 0;
    hbtree->key_size = key_size;
    hbtree->value_size = value_size;
    hbtree->compare = compare;

    return hbtree;
}

bool insert_item_bt(HBTREE hbtree, const void *key, const void *value)
{
    NODE *new_node, *node, *parent_node = NULL;
    int result;

    if ((new_node = (NODE *)malloc(sizeof(NODE) + hbtree->key_size + hbtree->value_size)) == NULL)
        return false;
    memcpy(new_node->key_value, key, hbtree->key_size);
    memcpy(new_node->key_value + hbtree->key_size, value, hbtree->value_size);
    
    new_node->left = NULL;
    new_node->right = NULL;

    if (hbtree->root == NULL) {
        hbtree->root = new_node;
        ++hbtree->count;
        return true;
    }
    node = hbtree->root;

    while (node != NULL) {
        parent_node = node;
        result = hbtree->compare(key, node->key_value);

        if (result < 0)
            node = node->left;
        else if (result > 0)
            node = node->right;
        else {
            memcpy(node->key_value + hbtree->key_size, value, hbtree->value_size);
            return true;
        }
    }

    if (hbtree->compare(key, parent_node->key_value) <  0)
        parent_node->left = new_node;
    else
        parent_node->right = new_node;

    ++hbtree->count;

    return true;
}

bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
{
    if (hbtree->root != NULL)
        return walk_inorder_lr_recur(hbtree->root, hbtree->key_size, proc);

    return true;
}

bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
{
    if (hbtree->root != NULL)
        return walk_inorder_rl_recur(hbtree->root, hbtree->key_size, proc);

    return true;
}

bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
{
    if (hbtree->root != NULL)
        return walk_postorder_lr_recur(hbtree->root, hbtree->key_size, proc);

    return true;
}

bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
{
    if (hbtree->root != NULL)
        return walk_preorder_lr_recur(hbtree->root, hbtree->key_size, proc);

    return true;
}

static bool walk_preorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
{
    if (!proc(node->key_value, node->key_value + key_size))
        return false;

    if (node->left != NULL)
        if (!walk_preorder_lr_recur(node->left, key_size, proc))
            return false;

    if (node->right != NULL)
        if (!walk_preorder_lr_recur(node->right, key_size, proc))
            return false;
    
    return true;
}

bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
{
    NODE *node;
    bool result = true;

    create_queue(hbtree);
    put_queue(hbtree, hbtree->root);

    while ((node = get_queue(hbtree)) != NULL) {
        if (!proc(node->key_value, node->key_value + hbtree->key_size)) {
            result = false;
            break;
        }
        if (node->left != NULL)
            if (put_queue(hbtree, node->left) == NULL) {
                fprintf(stderr, "put_queue cannot allocate memory!..\n");
                result = false;
                break;
            }
        if (node->right != NULL)
            if (put_queue(hbtree, node->right) == NULL) {
                result = false;
                fprintf(stderr, "put_queue cannot allocate memory!..\n");
                break;
            }
    }

    destroy_queue(hbtree);

    return result;
}

static void create_queue(HBTREE hbtree)
{
    hbtree->head = NULL;
    hbtree->tail = NULL;
}

static NODE *put_queue(HBTREE hbtree, NODE *node)
{
    QNODE *new_qnode;

    if ((new_qnode = (QNODE *)malloc(sizeof(QNODE))) == NULL)
        return NULL;

    new_qnode->node = node;
    new_qnode->next = NULL;

    if (hbtree->tail != NULL)
        hbtree->tail->next = new_qnode;
    else
        hbtree->head = new_qnode;
    hbtree->tail = new_qnode;

    return node;
}

static NODE *get_queue(HBTREE hbtree)
{
    QNODE *qnode;
    NODE *rnode;

    if (hbtree->head == NULL)
        return NULL;
    qnode = hbtree->head;
    hbtree->head = qnode->next;
    if (hbtree->head == NULL)
        hbtree->tail = NULL;

    rnode = qnode->node;
    free(qnode);

    return rnode;
}

bool delete_bt(HBTREE hbtree, const void *key)
{
    NODE *delete_node, *delete_parent_node, *replace_parent_node, *replace_node;
    int result;

    delete_node = hbtree->root;
    delete_parent_node = NULL;

    while (delete_node != NULL) {
        result = hbtree->compare(key, delete_node->key_value);
        if (result == 0)
            break;
        delete_parent_node = delete_node;
        if (result < 0)
            delete_node = delete_node->left;
        else if (result > 0)
            delete_node = delete_node->right;
    }

    if (delete_node == NULL)
        return false;

    if (delete_node->left == NULL)
        subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->right);
    else if (delete_node->right == NULL)
        subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->left);
    else {
        replace_parent_node = delete_node;
        replace_node = delete_node->right;
        while (replace_node->left != NULL) {
            replace_parent_node = replace_node;
            replace_node = replace_node->left;
        }
        if (replace_parent_node != delete_node) {
            subtree_shift(hbtree, replace_parent_node, replace_node, replace_node->right);
            replace_node->right = delete_node->right;
        }
        subtree_shift(hbtree, delete_parent_node, delete_node, replace_node);
        replace_node->left = delete_node->left;
    }

    free(delete_node);
    --hbtree->count;

    return true;
}

void clear_bt(HBTREE hbtree)
{
    if (hbtree->root != NULL) {
        clear_recur(hbtree->root);
        hbtree->root = NULL;
        hbtree->count = 0;
    }
}

void destroy_bt(HBTREE hbtree)
{
    if (hbtree->root != NULL)
        clear_recur(hbtree->root);

    free(hbtree);
}

static bool walk_inorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
{
    if (node->left != NULL)
        if (!walk_inorder_lr_recur(node->left, key_size, proc))
            return false;

    if (!proc(node->key_value, node->key_value + key_size))
        return false;

    if (node->right != NULL)
        if (!walk_inorder_lr_recur(node->right, key_size, proc))
            return false;

    return true;
}

static bool walk_inorder_rl_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
{
    if (node->right != NULL)
        if (!walk_inorder_rl_recur(node->right, key_size, proc))
            return false;

    if (!proc(node->key_value, node->key_value + key_size))
        return false;

    if (node->left != NULL)
        if (!walk_inorder_rl_recur(node->left, key_size, proc))
            return false;
    return true;
}

static bool walk_postorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
{
    if (node->left != NULL)
        if (!walk_postorder_lr_recur(node->left, key_size, proc))
            return false;

    if (node->right != NULL)
        if (!walk_postorder_lr_recur(node->right, key_size, proc))
            return false;

    if (!proc(node->key_value, node->key_value + key_size))
        return false;

    return true;
}

static void destroy_queue(HBTREE hbtree)
{
    QNODE *qnode, *temp_qnode;

    qnode = hbtree->head;

    while (qnode != NULL) {
        temp_qnode = qnode->next;
        free(qnode);
        qnode = temp_qnode;
    }
}

static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3)
{
    if (node1 == NULL)
        hbtree->root = node3;
    else if (node1->left == node2)
        node1->left = node3;
    else
        node1->right = node3;
}


static void clear_recur(NODE *node)
{
    if (node->left != NULL)
        clear_recur(node->left);

    if (node->right != NULL)
        clear_recur(node->right);

    free(node);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "binarytree.h"

typedef struct tagPERSON {
    char name[32];
    int no;
} PERSON;

bool disp_node(const void *key, const void *value);
int comp_person(const void *key1, const void *key2);

int main(void)
{
    HBTREE hbtree;
    PERSON per = {"Noname", 0};
    int keys[] = {70, 50, 34, 56, 19, 80, 67, 43, 27, 76, 79, 105, 82, 65, 0};
    int del_key = 70;

    if ((hbtree = create_bt(sizeof(int), sizeof(PERSON), comp_person)) == NULL) {
        fprintf(stderr, "cannot create binary tree!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; keys[i] != 0; ++i)
        if (!insert_item_bt(hbtree, &keys[i], &per)) {
            fprintf(stderr, "cannot insert item: %d\n", keys[i]);
            exit(EXIT_FAILURE);
        }
    
    walk_inorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_inorder_rl_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_postorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_preorder_lr_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    walk_breadth_first_bt(hbtree, disp_node);
    printf("\n------------------------------\n");
    if (!delete_bt(hbtree, &del_key)) {
        fprintf(stderr, "cannot find item!...\n");
        exit(EXIT_FAILURE);
    }
    walk_breadth_first_bt(hbtree, disp_node);

    destroy_bt(hbtree);

    return 0;
}

bool disp_node(const void *key, const void *value)
{
    const int *ikey = (const int *)key;
    printf("%d ", *ikey);
    fflush(stdout);

    return true;
}

int comp_person(const void *key1, const void *key2)
{
    const int *ikey1 = (const int *)key1;
    const int *ikey2 = (const int *)key2;

    if (*ikey1 > *ikey2)
        return 1;

    if (*ikey1 < *ikey2)
        return -1;

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Genelleştirmede void gösterici tekniği yerine gömme tekniğinin tercih edildiğini belirtmiştik. Bu tekniği açıklamadna önce hazırlık 
    amacıyla C'ye ilişkin bir konunun üzerinde duracağız.
-------------------------------------------------------------------------------------------------------------------------------------------*/
 
/*------------------------------------------------------------------------------------------------------------------------------------------
    C'nin <stddef.h> içerisinde bildirilmiş olan offsetof makrosu yapının tür ismini ve yapıdaki bir eleman ismini parametre olarak alır, 
    o elemanın yapının başından itibaren kaçıncı offsette olduğunu verir. Örneğin:

    struct SAMPLE {
        int a;                    
        int b;
        char c[32];
        char d;
        int e;
    };
    size_t result;

    result = offsetof(struct SAMPLE, e);

    Burada yapının e elemanı yapı nesnesinin başından itibaren muhtemelen 44'üncü offset'indedir. Elemanların offset numaraları aşağıdaki 
    gibi olacaktır:

    struct SAMPLE {
        int a;                /* 0 */        
        int b;                /* 4 */
        char c[32];            /* 8 */
        char d;                /* 40 */
        int e;                /* 44 */
    };

    İşte offsetof makrosu bir yapı elemanının yapın nesnesnin kaçıncı offsetinde olduğunu elde etmek için kullanılmaktadır. offsetof makrosu
    size_t türündne bir değer vermektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

struct SAMPLE {
    int a;
    int b;
    char c[32];
    char d;
    int e;
};

int main(void)
{
    size_t result;

    result = offsetof(struct SAMPLE, e);
    printf("%zd\n", result);                    /* 44 */

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    offsetof makrosu tipik olarak aşağıdakine benzer bir biçimde yazılmaktadır:

    #define myoffsetof(type, member)        ((size_t)&((type *)0)->member)

    Burada 0 adresi önce ilgili yapı türünden adrese dönüştürülmüştür. (0 değerini herhangi türden bir adrese dönüştürürsek bu NULL adres 
    anlamına gelmemektedir. 0 dğeri void * türüne dönüştürülürse bu NULL ares anlamına gelmektedir.) Sonra yapının elemanına eriilip onun adresi
    alınmıştır. Bu durumda adresin sayısal bileşeni aslında ilgili eelemanın offset'i olacaktır. Nihayet bu değer son olarak size_t türüne 
    dönüştürülmüştür. Yukarıdaki 0 adresinden başlayan yapının elemanına erişip onun adresini alma işlemi C'de "tanımsız davranış" değildir.
    Çünkü burada standartlara göre gerçek bir erişim yapılmamaktadır. Yalnızca oranın adresi elde edilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#define myoffsetof(type, member)        ((size_t)&((type *)0)->member)

struct SAMPLE {
    int a;
    int b;
    char c[32];
    char d;
    int e;
};

int main(void)
{
    size_t result;

    result = myoffsetof(struct SAMPLE, e);
    printf("%zd\n", result);                    /* 44 */

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir yapı içerisindeki bir elemanın adresini, o elemanın ismini ve yapının türünü bildiğimizi varsayalım. Bu durumda elemanın adresine 
    ilişkin yapı nesnesinin başlangıç adresini veren container_of biçiminde bir makro yazabiliriz:

    #define container_of(ptr, type, member)            ((type *) ((char *) (ptr) - offsetof(type, member)))

    Makronun birinci parametresi nesne içerisindeki elemanın adresi, ikinci parametresi yapının tür ismi ve üçüncü parametresi de elemanın 
    ismini almaktadır. C standartlarında offsetof bir makro bulunmakla birlikte bu işi yapabilecek bir makro bulunmamaktadır. 
    Aşağıdaki container_of makrosunn kullanımına ilişkin bir örnek verilmektedir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

#define container_of(ptr, type, member)            ((type *) ((char *) (ptr) - offsetof(type, member)))

struct SAMPLE {
    int a;
    char b;
    int c;
    char d;
    double e;
    int f;
};

int main(void)
{
    struct SAMPLE s = { 10, 'x', 20, 'y', 12.4, 100 };
    double *pd = &s.e;
    struct SAMPLE *ps;

    ps = container_of(pd, struct SAMPLE, e);
    printf("%d, %f\n", ps->a, ps->e);

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Gömme yöntemiyle veri yapıları genelleştirilirken aslında veri yapıları adeta kendi çekirdek kısımlarından oluşturulur. Örneğin bir bağlı 
    listenin türden bağımsız bir biçimde bu teknikle oluşturulmak istendiğini düşünelim. Bağlı liste belli türdne bilgileri değil NODE isimli
    düğümleri birbirine bağlayacaktır. Ancak NODE isimli düğümler bağlı liste elemanlarının tutacağı nesneleri içermeyecektir. Örneğin:

    typedef struct tagNODE {
        struct tagNODE *next;
        struct tagNODE *prev;
    } NODE;

    Görüldüğü gibi burada NODE yapısı düğümğn tuttuğu bilgiyi içermemektedir. İşte bağlı liste bu biçimdeki düğümleri birbirine bağlamaktadır. 
    Örneğin:

    head_node <---> node <----> node <---> node <---> ....

    Pekiyi bağlı liste düğümleri yalnızca link tuttuğuna göre böyle bir bağlı listeninin nasıl bir faydası olabilir? İşte bu düğümler aslında 
    başka bir yapının içerisinde bir eleman olarak tutulacaktır. Örneğin:

    struct PERSON {
        char name[32];
        int no;
        NODE link;
    };

    Görüldüğü gibi PERSON yapısının bir elemanı bağlı listenin düğümündne oluşmaktadır. Yani biz aslında düğümlerdne bağlı liste oluşturmaktayız
    ancak bu düğümler de ilgili türden nesnelerin elemanı durumundadır. Nasıl olsa biz yapının bir elemanının adresini bildiğimizde o yapı 
    nesnesinin başlangıç adresini yukarıda gösterdiğimiz gibi container_of makrosu ile elde edebiliriz. 

    Bu yöntemde bir yapı nesnesi tek bir bağlı liste içerisinde bulunmak zorunda değildir. Örneğin Linux çekirdeğinde proses kontrol bloğu temsil 
    eden task_struct yapısı pek çok bağlı listede bulunmaktadır. Burada yapılacak şey yapı içerisinde birden fazla link elemanı tutmaktır. 
    Örneğin:

    struct PERSON {
        char name[32];
        int no;
        NODE link1;
        NODE link2;
    };
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir handle sistemi kullanılarak gömme tekniği ile türden bağımsız bağlı liste oluşturulmuştur. Burada yine bağlı listeler
    create_llist gibi bir fonksiyonla yaratılmaktadır. Gömme tekniğinde handle sisteminin kullanılması aşağı seviyeli çekirdek kodları için
    uygun bir yöntem olmayabilir. Ancak biz aşağıda önce handle sistemi ile gömme tekniğine örnek vereceğiz. Sonra handle sistemi olmadan
    aynı tekniği kullanacağız. Yukarıda da belirttiğimiz gibi aslında örneğin Linux, BSD, CSD gibi işletim sistemi kodlarında bu handle sistemi
    kullanılmamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef struct tagNODE {
    struct tagNODE *next;
    struct tagNODE *prev;
} NODE;

typedef struct tagLLIST {
    NODE head;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *insert_next(HLLIST hllist, NODE *node, NODE *new_node);
NODE *insert_prev(HLLIST hllist, NODE *node, NODE *new_node);
NODE *add_tail(HLLIST hllist, NODE *new_node);
NODE *add_head(HLLIST hllist, NODE *new_node);
void remove_node(HLLIST hllist, NODE *node);
NODE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(NODE *));
bool walk_llist_rev(HLLIST hllist, bool (*proc)(NODE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

static inline NODE *head_llist(HLLIST hllist)
{
    return hllist->head.next;
}

static inline NODE *tail__llist(HLLIST hllist)
{
    return hllist->head.prev;
}

/* Macro Definitions */

#define container_of(ptr, type, member)            ((type *) ((char *) (ptr) - offsetof(type, member)))

#define FOR_EACH(hllist, node)        for (node = (hllist)->head.next; node != &(hllist)->head; node = node->next)
#define FOR_EACH_REV(hllist, node)    for (node = (hllist)->head.prev; node != &(hllist)->head; node = node->prev)
#define FREE_LLIST(hllist, node)    for (NODE *tnode = (hllist)->head.next;  node = tnode, tnode = tnode->next, node != &(hllist)->head; )

#endif


/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head.next = &hllist->head;
    hllist->head.prev = &hllist->head;
    hllist->count = 0;

    return hllist;
}

NODE *insert_next(HLLIST hllist, NODE *node, NODE *new_node)
{
    node->next->prev = new_node;
    new_node->next = node->next;
    node->next = new_node;
    new_node->prev = node;

    ++hllist->count;

    return new_node;
}

NODE *insert_prev(HLLIST hllist, NODE *node, NODE *new_node)
{
    node->prev->next = new_node;
    new_node->next = node;
    new_node->prev = node->prev;
    node->prev = new_node;

    ++hllist->count;

    return new_node;
}

NODE *add_tail(HLLIST hllist, NODE *new_node)
{
    return insert_prev(hllist, &hllist->head, new_node);
}

NODE *add_head(HLLIST hllist, NODE *new_node)
{
    return insert_next(hllist, &hllist->head, new_node);
}

void remove_node(HLLIST hllist, NODE *node)
{
    node->prev->next = node->next;
    node->next->prev = node->prev;

    --hllist->count;
}

NODE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head.next;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return node;
}

bool walk_llist(HLLIST hllist, bool (*proc)(NODE *))
{
    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
        if (!proc(node)) 
            return false;

    return true;
}

bool walk_llist_rev(HLLIST hllist, bool (*proc)(NODE *))
{
    for (NODE *node = hllist->head.prev; node != &hllist->head; node = node->prev)
        if (!proc(node))
            return false;

    return true;
}

void clear_llist(HLLIST hllist)
{
    hllist->head.next = &hllist->head;
    hllist->head.prev = &hllist->head;

    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    free(hllist);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

typedef struct tagPERSON {
    char name[32];
    int no;
    NODE link;
} PERSON;

bool disp_person(NODE *node);

int main(void)
{
    HLLIST hllist;
    PERSON *per;
    NODE *node;
    
    if ((hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 100; ++i) {
        if ((per = (PERSON *)malloc(sizeof(PERSON))) == NULL) {
            fprintf(stderr, "ccano tallocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        per->no = i;
        per->name[0] = '\0';

        add_tail(hllist, &per->link);
    }

    walk_llist(hllist, disp_person);
    
    printf("\n--------------------\n");
    
    FOR_EACH (hllist, node) {
        per = container_of(node, PERSON, link);
        printf("%d ", per->no);
        fflush(stdout);
    }

    printf("\n--------------------\n");

    FOR_EACH_REV (hllist, node) {
        per = container_of(node, PERSON, link);
        printf("%d ", per->no);
        fflush(stdout);
    }

    FREE_LLIST(hllist, node) {
        per = container_of(node, PERSON, link);
        free(per);
    }

    return 0;
}

bool disp_person(NODE *node)
{
    PERSON *per;

    per = container_of(node, PERSON, link);
    printf("%d ", per->no);
    fflush(stdout);

    return true;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    En sık karşılaşılan veri yapılaran biri de "graph" denilebn veri yapısıdır. Bir graph düğümlerden ve kenarlardan oluşur. Düğümlere 
    İngilizce "vertex" ya da "node" denilmektedir. Düğüm arasındaki bağlantıyı temsil eden kenarlara da İngilizce "edge" denilmektedir. 
    Aslında düğümlerden Ve kenarlardan oluşan en genel veri yapısı "graph" veri yapısıdır. Ağaçlar aslında bir çeşit graph'tır. Belli bir 
    düğüm kök yapıldığında her düğüme bu kök düğümden yalnızca tek bir yol ile gelinen özel graph'lara "ağaç (tree)" denilmektedir. Yani 
    aslında her ağaç bir graph'tır, ancak her graph bir ağaç değildir. Dolayısıyla genel olarak graph'larda bir düğüme biren fazla yerden 
    gelinebilmektedir. Graph veri yapılarının pratikte pek çok uygulama alanı vardır. Graplar üzerinde yüzden fazla uygulaması olan problem 
    tanımlanmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Graph'lar konusunda çalışmadan önce temel graph terminolojisini bilmek gerekir. Tmel graph terminolojisi şöyledir:

    Yönlü ve Yönsüz Graflar (Directed and Undirected): Eğer düğümler arasındaki yollarda bir yön belirtiliyorsa bu tür graflara "yönlü graflar"
    denilmektedir. Düğümler arasındaki kenarlarda bir yön bilgisi yoksa bu tür graflara da "yönsüz graflar" denilmektedir. Aslında yönsüz 
    graflar iki yönlü graflar gibi de düşünülebilir. Örneğin kara yolları yönlü bir grafla, sosyal ağlar (hepsi değil) yönsüz bir grafla temsil
    edilebilir. 

    Döngüsel Olan (Cyclic) ve Döngüsel Olmayan (Acyclic) Graflar: Bir grafta bir düğümden başlanarak aynı düğüme gelebilmenin bir yolu varsa 
    bu tür graflara döngüsel graflar denilmektedir. Döngüsel graflarda her düğüm için kendine gelen bir yol olması gerekmez. Herhangi bir 
    düğümden kendisine gelen herhangi bir yol varsa bu grafı döngüsel graf yapmaktadır. Döngüsellik tipik olarak yönlü graflar için kullanılan 
    bir terimdir. İngilizce buna "directed acyclic grapg (DAG)" da denilmektedir. 

    Yol (Path): Bir grafta bir düğümden diğerine varabilmek için geçilen kenarların sırasıyla dizilimine "yol (path)" denilmektedir. 

    Tur (Cycle): Bir yolun ilk ve son düğümü aynıysa başka bir deyişle bir düğümden çıkılıp yeniden aynı düğüme gelen yola "tur" denilmektedir. 
    Tuların tüm düğümleri kapsaması gerekmez. 

    Bağlantılı Graflar (Connected Graphs): Her düğümle her düğüm arasında en az bir yolun olduğu yönsüz graflara "bağlantılı graflar (connected 
    graphs)" denilmektedir. Graflardaki düğümleri bilye, kenarları da bunları bağlayan ip olarak düşünürsek bağlantılı graflarda herhangi bir
    bilyeyi tutup yukarı kaldırdığımızda tüm bilyelerin kalkması gerekir. 

    Öz döngülü (self-loop) Graflar: Eğer graflarda kendindne kendine bir kenar tanımlanabiliyorsa böylesi graflara öz döngülü graflar (self-loop
    graphs) denilmektedir. Genellikle gragflar öz döngülü olmazlar. 
    
    Alt Graflar (Subgraphs): Bir grafın belli bir alt kümesine alt graph denilmektedir. 

    Tam Graflar (Complete Graphs): Bir yönsüz grafta her düğümden her düğüme bir kenar varsa bu tür graflara "tam graflar (complete graphs)"
    denilmektedir.    

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Graflarla çalışmak için öncelikle grafları veri yapısı olarak temsil etmek gerekir. Grafların temsil edilmesi için temel iki yöntem 
    kullanılmaktadır.

    1) Komşuluk Matrisi (Adjacency-Matrix) Yöntemi 
    2) Komşuluk Listeleri (Adjacency-Lists) Yöntemi

    Komşuluk matrisi yönteminde düğümlerden bir kare matris oluşturulur. Matrisin elemanları 0 ve 1'lerden oluşturulabilir. 0 ilgili iki
    düğüm arasında bir kenar olmadığını 1 ise olduğunu gösterebilir. Örneğin:

      A B C D
    A 0 1 0 1 
    B 0 0 1 1
    C 1 1 0 0
    D 0 1 1 0

    Burada örneğin C'den C'ye kenar yoktur, ancak C'den D'ye kenar vardır. Tabii eğer kenarlara bilgiler iliştirilecekse (örneğin bir yol uzunluğu 
    gibi) bu durumda matrisin elemanları birer gösterici olabilir. Kenar bilgileri bu göstericilerin gösterdiği yerdedir. İki düğüm arasında 
    yol yoksa matrisin ilgili elemanı NULL adres içerebilir. Yönsüz graflarda komşuluk matirisinin simetrik bir matris olması gerektiğine dikkat 
    ediniz. 

    Komşuluk listeleri yönteminde her düğümün bir listesi vardır. Bu liste o düğümden gidilebilecek düğümleri belirtir. Buradakli liste
    dinamik büyütülen bir dizi olabilir ya da bağlı liste olabilir. Yukarıdaki graf'ın komşuluk listeleri yoluyla temsili şöyle olacaktırÇ:

    A: B, C
    B: C, D
    C: A, B
    D: B, C

    BUrada eğer yollara bilgiler iliştirilecekse listenin elemanları birer gösterici olabilir ya da o bilgilerdne oluşan birer yapı da olabilir. 

    Pekiyi hangi temsil daha iyidir? Aslında iki yöntemin de avantajları ve dezavantajları bulunmaktadır. Komşul matrisi yönteminde kenara 
    iliştirilen bilgiye O(1) karmaşıklıkta erişilebilir. Komşuluk listeleri yönteminde sıralı arama gerekir. Eğer kenar sayısı çok fazla ise 
    bu yöntemde her düğüm için bir hash tablosu ya da ikili arama ağacı kullanılabilir. Uygulamada genellikle "komşuluk listeleri" yöntemi 
    tercih edilmektedir. 

    Bu temsillerde düğümlerin nasıl temsil edileceği de bir problemdir. Düğümlere isim verilirse ismin aranması uzun sürebilir. Bu durumda 
    en etkin yöntem düğümlere isim değil numara vermektir. Tabii numaradan isim elde edilebilir ya da isimden numara alde edilebilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Graflarlar üzerinde algoritmalar için değişik graf kütüphaneleri oluşturulmuştur. En yaygın kullanılan graf kütüphanesi C++'taki "Boost
    Graf Kütüphanesi (Boost Graph Library (BGL))" denilen kütüphanedir. Bu kütüphanede düğümler ve kenarlar sınıflarla temsil edilmiştir. Boost 
    Graf Kütüphanesi pek çok graf kütüphanesine de ilham kaynağı olmuştur. Benzer biçimde Java için, C# için Python için çeşitli graf kütüphaneleri
    geliştirilmiştir. C için yaygın kullanılan bir graf kütüphanesi bulunmamaktadır. Ancak incelemek için "igraph" kütüphanesi önerilebilir. 
    Kütüphanenin kaynak kodlarına aşağıdan erişebilirisiniz:

    https://igraph.org/
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi graf veri yapısı için iki yöntem kullanılmaktadır. Ancak ağırlıklı tercih "komşuluk listeleri" yöntemidir. 
    Bu yöntemin türden bağımsız uygulaması biraz zor olabilmektedir. Biz burada makul bir gerçekleştirim üzerinde duracağız. 

    Gerçekleştiririmizde DGRAPH nesnesi VERTEX nesnelerini, VERTEX nesneleri de EDGE nesnelerini tutacaktır. Komşuluk listeleri yönteminde 
    her vertex'in o vertex'ten gidilebilecek vertex'leri tuttuğunu belirtmiştik. Ancak biz burada bir vertex'ten gidilecek vertex'leri değil
    gidilecek vertex'lere ilişkin kenar nesnelerini tutacağız. DGRAPH yapısı şöyleolabilir:

    typedef struct tagDGRAPH{
        VERTEX **vertices;
        size_t count;
        size_t capacity;
    } DGRAPH;

    Görüldüğü gibi burada graf veri yapısı vertex'lerin kendilerini değil adreslerini tutmaktadır. Bunun nedeni bu dizi büyütüldüğünde 
    VERTEX nesnelerinin adreslerinin değişmemesinin sağlanmasıdır. Buradaki count bu gösterici dizisinin dolu olan eleman sayısını, capacity 
    ise gösterici dizisi için ayrılan kapasiteyi belirtmektedir. VERTEX yapısı aşağıdakai gibi olabilir:
        
    typedef struct tagVERTEX {
        EDGE **edges;
        size_t count;
        size_t capacity;

        /* VERTEX INFO */
        char name[32];
    } VERTEX;

    Görüldüğü gibi VERTEX nesneleri EDGE nesnelerinin adreslerini tutmaktadır. Yine bu dizinin dolu olan eleman sayısı count elemanı ile 
    dizi için tahsis edilen toplam alan ise capacity elemanı ile tutulmaktadır. Burada biz vertex'e bir isim verdik. İsterseniz burada 
    vertex'lere başka bilgiler de iliştirebilirsiniz. EDGE yapısı da şöyle olabilir:

    typedef struct tagEDGE {
        VERTEX *v1;
        VERTEX *v2;

        /* EDGE INFO */
        int length;
    } EDGE;

    Görüldüğü gibi bir EDGE nesnesi başlangıç ve bitiş VERTEX nesnelerinin adreslerini tutmaktadır. Burada EDGE nesnesine bir uzunluk bilgisi 
    iliştirilmiştir. Tabi başka bilgiler de iliştirilebilir. Bu tasarımda biz DGRAPH nesnesinin tuttuğu vertex'leri dinamik büyütülen bir 
    dizi ile, vertex'lerin tuttuğu kenarları da dinamik büyütülen bir dizi ile temsil ettik. Burada bağlı listeler ya da hash tabloları da 
    kullanılabilir. 

    Graf veri yapısını oluşturduktan sonra graflar üzerinde işlem yapan algoritmaların oluşturulması gerekir. Ancak çok çeşitli graf algoritmaları
    vardır. Biz kursumuzda yalnızca birkaç algoritma üzerinde duracağız. Bunlardan biri belli bir düğümden başlanarak grafın gidilebilen 
    tüm düğümlerinin dolaşılmasıdır. Tabii bu da özyinelemeli bir biçimde yapılmalıdır. Yani bir düğümden gidilebilen tüm düğümler için 
    fonksiyon kendini çağırmalıdır. Ancak graflarda düğümlere birden fazla yolla gelinebildiği için döngüsel bir sonsuz döngüye girmemek 
    gerekir. Bunu engellemenin tipik yolu her ziyaret edilen düğümün ziyaret edildiğini bir yerde tutmak ve eğer düğüm daha önce ziyaret 
    edilmişse onu yeniden ziyaret etmemektir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Graf veri yapısını kurduktan sonra graf üzerinde pek çok problemin çözümü yapılabilir. Literatürden yüzün üzerinde graf problemi 
    tanımlanmıştır. Graf problemlerinin en çok bilinenlerinden bazıları şunlardır:

    - Grafın dolaşılması
    - Grafta iki düğüm arasındaki tüm yolların (paths) elde edilmesi (shortest path problem)
    - Grafta iki düğüm arasında en kısa yolun elde edilmesi (path finding problem)
    - En küçük örten ağaç problemi (minimum spanning tree)
    - Gezgin satıcı problemi (travelling salesperson problem)
    - Maximum akış problemi (maximum flow problem)
    - Graf boyama problemi (graph coloring problem)
    - Graf çizdirme problemi (graph drawing problem)
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda graf veri yapısının oluşturulmasına ilişkin bir örnek verilmiştir. Buradaki veri yapılarını kullanarak yukarıdaki problemleri 
    çözecek algoritmaları deneyebilirsiniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* graph.h */

#ifndef GRAPH_H_
#define GRAPH_H_

#include <stddef.h>
#include <stdbool.h>

/* Symbolic Constants */

#define DEF_VERTEX_CAPACITY            4
#define DEF_EDGE_CAPACITY            4

#define MAX_CSV_LINE_LENGTH            1024

/* Type Declarations */

typedef struct tagEDGE {
    struct tagVERTEX *v1;
    struct tagVERTEX *v2;

    /* EDGE INFO */
    double length;
} EDGE;

typedef struct tagVERTEX {
    EDGE **edges;
    size_t count;
    size_t capacity;
    size_t index;
    
    /* VERTEX INFO */
    char name[32];

} VERTEX;

typedef struct tagDGRAPH{
    VERTEX **vertices;
    size_t count;
    size_t capacity;
    size_t ecount;
} DGRAPH, *HDGRAPH;

/* Function Prototypes */

HDGRAPH create_dgraph(void);
VERTEX *add_vertex(HDGRAPH hdgraph, VERTEX *vertex);
VERTEX *add_vertex_info(HDGRAPH hdgraph, const char *name);
EDGE *add_edge(HDGRAPH hdgraph, VERTEX *v1, VERTEX *v2, double length);
EDGE *add_edge_info(HDGRAPH hdgraph, const char *name1, const char *name2, double length);
DGRAPH *build_graph(const char *path);
bool traverse_depth_first_vertex(HDGRAPH hdgraph, VERTEX *vertex, bool (*proc)(VERTEX *));
bool traverse_depth_first_name(HDGRAPH hdgraph, const char *name, bool (*proc)(VERTEX *));
void clear_dgraph(HDGRAPH hdgraph);
void destroy_dgraph(HDGRAPH hdgraph);

/* inline Funcrion Definitions */

static inline size_t vertex_count(HDGRAPH hdgraph)
{
    return hdgraph->count;
}

#endif

/* graph.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "graph.h"

static VERTEX *find_vertex_name(HDGRAPH hdgraph, const char *name);
static EDGE *create_edge(VERTEX *v1, VERTEX *v2, double length);
static VERTEX *create_vertex(const char *name);
static bool traverse_depth_first_vertex_recur(VERTEX *vertex, int *visiteds, bool (*proc)(VERTEX *));

HDGRAPH create_dgraph(void)
{
    HDGRAPH hdgraph;

    if ((hdgraph = (HDGRAPH)malloc(sizeof(DGRAPH))) == NULL)
        return NULL;

    if ((hdgraph->vertices = (VERTEX **)malloc(DEF_VERTEX_CAPACITY * sizeof(VERTEX *))) == NULL) {
        free(hdgraph);
        return NULL;
    }
    hdgraph->count = 0;
    hdgraph->capacity = DEF_VERTEX_CAPACITY;
    hdgraph->ecount = 0;

    return hdgraph;
}

VERTEX *add_vertex(HDGRAPH hdgraph, VERTEX *vertex)
{
    VERTEX **new_vertices;

    if (find_vertex_name(hdgraph, vertex->name) != NULL)
        return NULL;

    if (hdgraph->count == hdgraph->capacity) {
        if ((new_vertices = realloc(hdgraph->vertices, hdgraph->capacity * sizeof(VERTEX *) * 2)) == NULL)
            return NULL;
        hdgraph->vertices = new_vertices;
        hdgraph->capacity *= 2;
    }
    vertex->index = hdgraph->count;
    hdgraph->vertices[hdgraph->count] = vertex;
    ++hdgraph->count;

    return vertex;
}

VERTEX *add_vertex_info(HDGRAPH hdgraph, const char *name)
{
    VERTEX *vertex;
    VERTEX **new_vertices;

    if (find_vertex_name(hdgraph, name) != NULL)
        return NULL;

    if ((vertex = create_vertex(name)) == NULL)
        return NULL;

    if (hdgraph->count == hdgraph->capacity) {
        if ((new_vertices = realloc(hdgraph->vertices, hdgraph->capacity * sizeof(VERTEX *) * 2)) == NULL)
            return NULL;
        hdgraph->vertices = new_vertices;
        hdgraph->capacity *= 2;
    }
    vertex->index = hdgraph->count;
    hdgraph->vertices[hdgraph->count] = vertex;
    ++hdgraph->count;

    return vertex;
}

EDGE *add_edge(HDGRAPH hdgraph, VERTEX *v1, VERTEX *v2, double length)
{
    EDGE *edge;
    EDGE **new_edges;

    if ((edge = create_edge(v1, v2, length)) == NULL)
        return NULL;

    if (v1->count == v1->capacity) {
        if ((new_edges = realloc(v1->edges, v1->capacity * 2 * sizeof(EDGE *))) == NULL) {
            free(edge);
            return NULL;
        }
        v1->capacity *= 2;
    }
    v1->edges[v1->count] = edge;
    ++v1->count;

    ++hdgraph->ecount;

    return edge;
}

EDGE *add_edge_info(HDGRAPH hdgraph, const char *name1, const char *name2, double length)
{
    VERTEX *v1, *v2;
    EDGE *edge;

    if ((v1 = find_vertex_name(hdgraph, name1)) == NULL) {
        if ((v1 = create_vertex(name1)) == NULL) 
            return NULL;
        if (add_vertex(hdgraph, v1) == NULL)
            goto EXIT1;
    }

    if ((v2 = find_vertex_name(hdgraph, name2)) == NULL) {
        if ((v2 = create_vertex(name2)) == NULL) 
            goto EXIT1;
        if (add_vertex(hdgraph, v2) == NULL)
            goto EXIT2;
    }

    if ((edge = add_edge(hdgraph, v1, v2, length)) == NULL) 
        goto EXIT2;

    return edge;

EXIT2:
    free(v2);
EXIT1:
    free(v1);

    return NULL;
}

DGRAPH *build_graph(const char *path)
{
    FILE *f;
    HDGRAPH hdgraph;
    char buf[MAX_CSV_LINE_LENGTH + 2];
    const char *name1, *name2, *length;
    char *str;

    if ((f = fopen(path, "r")) == NULL)
        goto EXIT1;

    if ((hdgraph = create_dgraph()) == NULL)
        goto EXIT2;

    while (fgets(buf, MAX_CSV_LINE_LENGTH + 2, f) != NULL) {
        if ((name1 = strtok(buf, ",\n")) == NULL)
            continue;
        if ((name2 = strtok(NULL, ",\n")) == NULL)
            goto EXIT3;
        if ((length = strtok(NULL, ",\n")) == NULL)
            goto EXIT3;
        if (strtok(NULL, ",\n") != NULL)
            goto EXIT3;
        if (add_edge_info(hdgraph, name1, name2, atof(length)) == NULL)
            goto EXIT3;
    }

    return hdgraph;

EXIT3:
    destroy_dgraph(hdgraph);
EXIT2:
    fclose(f);
EXIT1:
    return NULL;
}

bool traverse_depth_first_vertex(HDGRAPH hdgraph, VERTEX *vertex, bool (*proc)(VERTEX *))
{
    int *visiteds;
    bool result;

    if (!proc(vertex))
        return false;

    if ((visiteds = (int *)calloc(hdgraph->count, sizeof(int))) == NULL)
        return false;

    result = traverse_depth_first_vertex_recur(vertex, visiteds, proc);

    free(visiteds);

    return result;
}

bool traverse_depth_first_name(HDGRAPH hdgraph, const char *name, bool (*proc)(VERTEX *))
{
    VERTEX *vertex;

    if ((vertex = find_vertex_name(hdgraph, name)) == NULL)
        return false;

    return traverse_depth_first_vertex(hdgraph, vertex, proc);
}

void clear_dgraph(HDGRAPH hdgraph)
{
    for (size_t v = 0; v < hdgraph->count; ++v) {
        for (size_t e = 0; e < hdgraph->vertices[v]->count; ++e)
            free(hdgraph->vertices[v]->edges[e]);
        hdgraph->vertices[v]->count = 0;
        free(hdgraph->vertices[v]);
    }
    hdgraph->count = 0;
}

void destroy_dgraph(HDGRAPH hdgraph)
{
    for (size_t v = 0; v < hdgraph->count; ++v) {
        for (size_t e = 0; e < hdgraph->vertices[v]->count; ++e)
            free(hdgraph->vertices[v]->edges[e]);
        free(hdgraph->vertices[v]->edges);
    
    }
    free(hdgraph->vertices);
    free(hdgraph);
}

static VERTEX *create_vertex(const char *name)
{
    VERTEX *vertex;

    if ((vertex = (VERTEX *)malloc(sizeof(VERTEX))) == NULL)
        return NULL;

    if ((vertex->edges = (EDGE **)malloc(DEF_EDGE_CAPACITY * sizeof(EDGE *))) == NULL) {
        free(vertex);
        return NULL;
    }
    vertex->count = 0;
    vertex->capacity = DEF_EDGE_CAPACITY;
    strcpy(vertex->name, name);

    return vertex;
}

static VERTEX *find_vertex_name(HDGRAPH hdgraph, const char *name)
{
    for (size_t i = 0; i < hdgraph->count; ++i)
        if (!strcmp(name, hdgraph->vertices[i]->name))
            return hdgraph->vertices[i];

    return NULL;
}

static EDGE *create_edge(VERTEX *v1, VERTEX *v2, double length)
{
    EDGE *edge;

    if ((edge = (EDGE *)malloc(sizeof(EDGE))) == NULL)
        return NULL;

    edge->v1 = v1;
    edge->v2 = v2;
    edge->length = length;

    return edge;
}

static bool traverse_depth_first_vertex_recur(VERTEX *vertex, int *visiteds, bool (*proc)(VERTEX *))
{
    VERTEX *v;

    visiteds[vertex->index] = 1;
    for (size_t e = 0; e < vertex->count; ++e) {
        v = vertex->edges[e]->v2;
        if (visiteds[v->index])
            continue;
        if (!proc(v))
            return false;
        if (!traverse_depth_first_vertex_recur(v, visiteds, proc))
            return false;
    }

    return true;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "graph.h"

void err_exit(const char *msg);
bool disp_vertex(VERTEX *v);

int main(void)
{
    HDGRAPH hdgraph;

    if ((hdgraph = build_graph("graph.csv")) == NULL) {
        fprintf(stderr, "cannot build graph!..\n");
        exit(EXIT_FAILURE);
    }

    traverse_depth_first_name(hdgraph, "A", disp_vertex);

    destroy_dgraph(hdgraph);

    return 0;
}

void err_exit(const char *msg)
{
    fprintf(stderr, "%s\n", msg);

    exit(EXIT_FAILURE);
}

bool disp_vertex(VERTEX *v)
{
    printf("%s\n", v->name);

    return true;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Graph çizdirmek için en fazla kullanılan araç "graphviz" isimli programdır. Bu programda bir grafı çizdirmek için önce graf bir dosyada
    ismine "dot dili (dot language)" bir dilde betimlenir. Sonra "dot" isimli programa bu dosya girdi olarak verilir. Bu program da bu girdi 
    dosyasından hareketle istenilen formatta bir çıktı dosyası üretir. Tabii bunları yapabilmek için önce graphviz programını bilgisayarımıza
    kurmamız gerekir. Graphviz aşağıdaki bağlantıdan indirilebilir:

    https://graphviz.org/download/

    Graphviz'de bir graf çizmek için grafın türü belirtilerek blok oluşturulur. Sonra bloğun içerisinde grafın düğümleri ve kenarları belirtilir. 
    Örneğin:

    digraph G {
        size="30, 40!"
        A -> B 
        B -> D
        B -> C
        C -> A
        D -> C
        D -> E
        E -> D
        E -> F
        F -> C
        C -> F
        G -> F
        C -> G
        C -> E
        D -> H
        H -> I
        I -> D
    }

    Buradaki size ibaresi inch cinsinden grafin genişlik ve yülksekliğiniş belirtmektedir. Satırların yanlarına köşeli parantez içerisinde
    label eklenebilir. Bu durumda belirtilen yazılar kenarların yanlarında görüntülenir. Örneğin:

    digraph G {
       A -> B [label="10"]
       B -> D [label="7"]
       B -> C [label="15"]
       C -> A [label="5"]
       D -> C [label="20"]
       D -> E [label="18"]
       E -> D [label="18"]
       E -> F [label="19"]
       F -> C [label="16"]
       C -> F [label="16"]
       G -> F [label="11"]
       C -> G [label="25"]
       C -> E [label="12"]
       D -> H [label="11"]
       H -> I [label="9"]
       I -> D [label="20"]
    }

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    77. Ders 24/03/2024 - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Windows'ta CSV dosyasından hareketle bir ".dot" dosyasını programlama yoluyla oluşturulmuş sonra da "dot" programı 
    çalıştırılarak ".png" dosyası elde edilmiştir. Nihayet bu ".png" dosyası da yine programlama yoluyla görüntülenmiştir. Burada kullanılabielcek
    örnek "graph.csv" dosyası şöyledir:

    A,B,10
    B,D,7
    B,C,15
    C,A,5
    D,C,20
    D,E,18
    E,D,18
    E,F,19
    F,C,16
    C,F,16
    G,F,11
    C,G,25
    C,E,12
    D,H,11
    H,I,9
    I,D,20
    A,I,40
    I,J,11
    J,D,21
    D,A,17
    F,H,30
    G,J,40
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* graphmake.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <windows.h>

#define MAX_LINE_LEN        4096

void ExitSys(LPCSTR lpszMsg);

bool csv2dot(const char *path_csv, const char *path_dot)
{
    FILE *f_csv, *f_dot;
    char buf[MAX_LINE_LEN];
    char *name1, *name2, *length;
    bool retval = false;

    if ((f_csv = fopen(path_csv, "r")) == NULL)
        return false;

    if ((f_dot = fopen(path_dot, "w")) == NULL)
        goto EXIT1;

    if (fprintf(f_dot, "digraph G {\n") < 0)
        goto EXIT2;

    while (fgets(buf, MAX_LINE_LEN, f_csv) != NULL) {
        if ((name1 = strtok(buf, ",\n")) == NULL)
            continue;
        if ((name2 = strtok(NULL, ",\n")) == NULL)
            goto EXIT2;
        if ((length = strtok(NULL, ",\n")) == NULL)
            goto EXIT2;
        if (strtok(NULL, ",\n") != NULL)
            goto EXIT2;

        if (fprintf(f_dot, "\t%s -> %s [label=\"%s\"]\n", name1, name2, length) < 0)
            goto EXIT2;
    }

    if (fprintf(f_dot, "}\n") < 0)
        goto EXIT2;

    retval = true;

EXIT2:
    fclose(f_dot);
EXIT1:
    fclose(f_csv);

    return retval;
}

bool dot2png(const char *path_dot, char *path_png)
{
    char cmdline[4096];
    STARTUPINFO si = {sizeof(si)};
    PROCESS_INFORMATION pi;
    bool result;

    sprintf(cmdline, "dot -Tpng %s -o %s", path_dot, path_png);
    
    result = CreateProcess(NULL, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return result;
}

int main(void)
{
    HINSTANCE hResult;

    if (!csv2dot("graph.csv", "test.dot")) {
        fprintf(stderr, "cannot generate dot file!..\n");
        exit(EXIT_FAILURE);
    }

    if (!dot2png("test.dot", "test.png")) {
        fprintf(stderr, "cannot generate png file!..\n");
        exit(EXIT_FAILURE);
    }

    hResult = ShellExecute(NULL, "open", "test.png", NULL, NULL, SW_NORMAL);

    if ((INT_PTR)hResult < 32)
        ExitSys("ShellExecute");

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde thread kavramını göreceğiz. Çok thread'li çalışma modeli ve thread senkronizasyonu konularını ele alacağız. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir prosesin bağımsız olarak çizelgelenen farklı akışlarına "thread" denilmektedir. (Thread sözcüğü İngilizce "iplik" anlamına gelmektedir. 
    Akışlar ipliğe benzetilerek bu sözcük uydurulmuştur.) Proses kavramı çalışmakta olan programın tüm bilgilerini temsil eden bir kavramdır. 
    Thread'ler proseslerin akışlarını temsil etmektedir. Yani thread'ler proses'lerin bir unsurudur. Bir proses tek bir akışa (yani thread'e)
    sahip olabileceği gibi birden fazla akışa (yani thread'e) sahip olabilmektedir. Thread'ler 90'lı yılların ortalarında işletim sistemlerine 
    sokulmuştur. Bugün artık thread'ler programlamanın önemli konularından sayılmaktadır. Windows sistemi ilk kez Windows NT ile (1993) sonra da
    Windows 95 ile thread'li çalışma modeline sahip olmuştur. Benzer biçimde UNIX/Linux sistemlerine de yine 90'lı yılların ortalarında thread'ler
    eklenmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde prosesler çalışmaya tek bir thread'le başlamaktadır. Bu thread proses yaratılırken işletim sistemi tarafından yaratılmaktadır.
    Prosesin bu thread'ine "ana thread (main thread)" denilmektedir. Prosesin diğer thread'leri program çalışırken sistem fonksiyonlarıyla 
    ya da bunları çağıran kütüphane fonksiyonlarıyla yaratılmaktadır. Yani program tek bir thread'le çalışmaya başlamaktadır. Diğer thread'ler 
    programcı tarafından oluşturulmaktadır. Thread'ler tamamen işletim sisteminin kontrolü altında yaratılıp çalıştırılmaktadır. Dolayısıyla 
    Windows sistemlerinde thread'ler Windows API fonksiyonlaır ile, UNIX/Linux ve macOS sistemlerinde ise POSIX fonksiyonlaır ile yaratılıp 
    idare edilmektedir. Bazı programlama dillerinin standart kütüphanelerinde platform bağımzıs thread sınıfları ya da fonksiyonları bulunabilmektedir. 
    Tabii burada platform bağımsızlık kaynak kod temelindedir. Bu kütüphaneler aslında farklı sistemlerde o sistemlerin sistem fonksiyonlarını 
    çağırarak thread işlemlerinş yapmaktadır. Örneğin C++11 ile birlikte C++'a bir thread kütüphanesi eklenmiştir. Biz C++'ta threda işlemlerini
    hep aynı biçimde yapabiliriz. Ancak buradaki fonksiyonlar ve sınıflar Windows sistemlerinde Windows API fonksiyonları, UNIX/Linux sistemleridne
    POSIX fonksiyonları çağrılarak işlemlerini gerçekleştirmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi thread'lere neden gereksinim duyulmaktadır? Bunu birkaç maddeyle açıklayabiliriz:

    1) Thread'ler arkaplan işlemlerin yapılması için iyi araç oluşturmaktadır. Örneğin biz bir yandan bir şeyler yaparken arka planda da periyodik
    birtakım işlemleri yapmak isteyebiliriz. Thread'ler yokken bu tür işlemler çok zor yapılıyordu. Ancak thread'lerişletim sistemlerine 
    eklenenince bu işlemleri yapmak çok kolaylaştı. Tread'ler sayesinde biz normal işlemlerimizi yaparken bir thread oluşturup arkaplan işlemleri 
    o thread'e havale edebiliriz. 

    2) Thread'ler programları hızlandırmak amacıyla kullanılabilmektedir. Bir işi birden fazla kaışa yaptırmak hız kazancı sağlamaktadır. 
    Sistemimizde tek bir işlemci olsa bile bizim prosesimiz diğer proseslere göre daha fazla CPU zamanı kullanabilir hale gelebilmektedir. 

    3) Thread'ler blokeye yol açan durumlarda işlemlerin devam ettirilmesini sağlayabilmektedir. Çünkü işletim sistemleri thread temelinde 
    bloke uygulamaktadır. Örneğin prosesin bir thread'i bir kalvye okuması sırasında blokede beklerken diğer thread'leri çalışmaya devam 
    edecektir. Bu durum da prosesin başka işlemlere yanıt verebilmesini sağlamaktadır.

    4) Thread'ler paralel programlama için mecburen kullanılması gereken unsurlardır. Paralel programlama "birden fazla CPU ya da çekirdeğin
    olduğu durumda prosesin thread'lerinin farklı CPU ya da çekirdeklere atanarak aynı anda çalıştırıması" anlamına geşmektedir. Örneğin çok 
    büyük bir diziyi sıraya dizecek olalım. Makinemizde 10 tane çekirdek olsun. Biz bu işlemi tek bir thread'le yaparsak makinemizdeki 10 
    çekirdek olmasının avantajından faydalanamayız. Halbuki biz dizimizi 10 parçaya ayırıp 10 farklı thread'i farklı çekirdeklere atarsak
    bunlar paralel bir biçimde dizinin çeşitli parçalarını aynı anda sort edecektir. Sonra bunları birleştirirsek toplamda zamanı çok kısaltmış
    olabiliriz. 

    5) Thread'ler GUI programlama ortamlarında bir mesaj geldiğinde uzun süren işlemlerin yapılabilmesine olanak sağlamaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                78. Ders 30/03/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir proses çalışmaya tek bir thread ile başlar. Buna prosesin ana thread'i (main thread) denilmektedir. Bu ana thread C programlarında 
    tipik olarak akışın main fonksiyonundan girdiği thread'tir. Diğer thread'ler işletim sistem fonksiyonlarıyla yaratılmaktadır. Tabii Windows'ta 
    bu sistem fonksiyonlarını çağıran API fonksiyonları UNIX/Linux sistemlerinde de POSIX fonksiyonları bulunmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Modern işletim sisemlerinin çizelgeleyici (scheduler) alt sistemleri thread'leri çizelgelemektedir. Yani işletim sistemi hangi prosese 
    ilişkin olursa olsun sıradaki thread'i CPU'ya atar, onu belli süre çalıştırır. Sonra çalışmasına ara vererek sonraki thread'i CPU'ya atar. 
    Modern çok thread'li (multithreaded) işletim sistemlerinde prosesler değil thread'ler çizelgelenmektedir. Yukarıda da belirttiğimiz gibi 
    prosesin bir thread'i bloke olduğunda diğerleri çalışmaya devam edebilmektedir. Bir thread'in çalışmasına ara verilerek diğer bir thread'in
    kaldığı yerden çalışmasına devam ettirilmesi sürecine "bağlamsal geçiş (context switch)" denilmektedir. Bağlamsal geçiş sırasında önceki 
    thread ile sonraki thread aynı prosesin thread'leri olabildiği gibi farklı proseslerin thread'leri de olabilir. Çok işlemcili ya da çekirdekli 
    sistemlerde zaman paylaşımlı çalışma modeli değişmemektedir. Yalnızca servis veren birden fazla işlemci ya da çekirdek söz konusu olmaktadır. 
    Thread'lerin sıra beklediği kuyruk sistemine işletim sistemleri terminolojisinde "çalışma kuyruğu (run queue)" denilmektedir. Çok işlemcili 
    ya da çekirdekli sistemlerde çalışma kuyruğu bir tane olabilir ya da her işlemci ya da çekirdek için ayrı bir çalışma kuyruğu söz konusu 
    olabilir. Örneğin Linux bir ara O(1) çizelgelemesi adı altında toplamda bir tane çalışma kuyruğu oluşturuyordu. Hangi işlemci ya da çekirdekteki
    thread'in işi biterse o çalışma kuyruğundan o işlemci ya da çekirdeğe atama yapıyordu. Ancak daha sonra bu çizelgeleme algoritması yine 
    değiştirildi. Bugünkü çizelgeleme algoritmasında her işlemci ya da çekirdeğin ayrı bir çalışma kuyruğu bulunmaktadır. Tabii işletim sistemi
    bu tür durumlarda işlemci ya da çekirdeklerin çalışma kuyruklarını iş yükü bakımından dengelemeye çalışmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'lerin stack'leri birbirinden ayrılmıştır. Yerel değişkenlerin "stack" denilen alanda yaratıldığını anımsayınız. Thread'lerin 
    stack'leri biribirindne ayrıldığı için bir thread akışı bir fonksiyon üzerinde ilerlerken o fonksiyonun yerel değişkenleri o stack üzerinde 
    yaratılmaktadır. Diğer bir thread de aynı fonksiyon üzerinde ilerliyorsa o yerel değişkenlee de o thread'in stack'inde yaratılacaktır. Böylece
    iki thread aynı kod üzerinde ilerliyor olsa da aslında yerel değişkenlerin farklı kopyalarını kullanıyor olacaklardır. Başka bir deyişle 
    yerel değişkenlerin her thread için ayrı bir kopyası bulunmaktadır. Örneğin:

    void foo(void))
    {
        int a;

        a = 10;
        ...
        ++a;
        ...
        ++a;
        ...
    }

    İki farklı thread bu foo fonksiyonunda ilerliyor olsun. Burada aslında her thread'in ayrı bir a değişkeni vardır. Dolayısıyla thread'lerden
    biri bu a değişkenini değiştirdiğinde kendi thread'inin stack'indeki a değişkenini değiştirmiş olur. Bu değişiklikten diğer thread'in a 
    değişkeni etkilenmeyecektir. 

    Ancak global değişkenler tüm thread'ler tarafından ortak biçimde kullanılmaktadır. Başka bir deyişle ".data" ve ".bss" bölümleri thread'e 
    özgü değil prosese özgüdür. Örneğin bir thread bir global değişkeni değiştirdiğinde diğer thread o global değişkeni değişmiş görmektedir. 
    Benzer biçimde heap alanı da prosese özgüdür. Yani thread'leri ayrı heap'leri yoktur. Toplamda bir tane heap vardır. O da prosesin heap 
    alanıdır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir işin birden fazla akışa yaptırılması gerektiği durumlarda thread'ler proseslere göre çok daha etkin bir çözüm sunmaktadır. Çünkü 
    yaratılması proseslerin yaratılmasından daha hızlı yapılmakta ve thread'ler proseslere göre daha az sistem kaynağı harcamaktadır. Prosesler
    önceki konularda da gördüğümüz gibi proseslerarası haberleşme yöntemleri (IPC) denilen yöntemlerle haberleşmektedir. Oysa thread'ler 
    global nesneler yoluyla haberleşebilmektedir. Eskiden thread'ler yokken bir işin birden fazla akışa yaptırılması prosesler yoluyla 
    gerçekleştiriliyordu. Oysa thread'ler işletim sistemlerine girince artık bunun için thread'ler kullanılmaya başlanmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Artık günümüzde thread'ler ptogramlamanın temel unsurları durumuna gelmiştir. Pek çok programla dilinde thread'lerle kolay işlemler yapabilmek 
    için standart kütüpaheneler bulunmaktadır. Hatta bazı dillerde artık thread'ler dilin sentaksının da içine sokulmuştur. Eskiden işlemciler
    mega hertz düzeyinde çalışıyordu. Zamanla bunların hızları 1000 kat civarında artırıldı. Ancak artırmanın fiziksel bir sınırına da yaklaşıldı. 
    Artık hızlandırma işlemciyi bireysel olarak hızlandırmak yerine birden fazla işlemci (ya da çekirdek) kullanarak sağlanmaktadır. İşletim 
    sistemleri de işlemcilere ya da çekirdeklere thread'leri atamaktadır. İşletim sistemlerinin çizelgeleyici alt sistemlerinin atama birimleri 
    thread'lerdir. 

    Eskiden board'lara birden fazla işlemci takılabiliyordu. Ancak zamanla teknoloji gelişince birden fazla işlemci tek bir chip'e yerleştirilmeye
    başlandı. Tek bir chip içindeki farklı işlemcilere "çekirdek (core)" denilmeye başlandı.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi thread'ler işletim sistemlerinin sistem fonksiyonlarıyla yaratılmaktadır. Windows'ta bu sistem fonksiyonlarını 
    çağıran API fonksiyonları UNIX/Linux be macOS sistemlerinde de POSIX fonksiyonları vardır. Yüksek seviyeli programlama dillerinin kütüphanelerinde 
    buluan thread fonksiyonları da aslında bu fonksiyonlar kullanılarak yazılmıştır. Örneğin biz C# ya da Java'da thread yarattığımızda aslında 
    bu dillerin kütüphaneleri yaratımı Windows sistemlerinde Windows API fonksiyonlarını çağırarak UNIX/Linux ve macOS sistemlerinde de POSIX 
    fonksiyonlarını çağırarak yapmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde thread'ler CreateThread isimli API fonksiyonuyla yaratılmaktadır. Fonksiyonun prototipi şöyledir:
    
    HANDLE CreateThread(
          LPSECURITY_ATTRIBUTES   lpThreadAttributes,
          SIZE_T                  dwStackSize,
          LPTHREAD_START_ROUTINE  lpStartAddress,
          LPVOID lpParameter,
          DWORD                   dwCreationFlags,
          LPDWORD                 lpThreadId
    );

    Fonksiyonun birinci parametresi thread kernel nesnesinin güvenlik bilgilerini belirtmektedir. Bu parametre NULL geçilebilir. İkinci parametre
    yaratılacak thread'in stack miktarını byte olarak belirtmektedir. Bu parametre 0 geçilirse default stack uzunluğu çalıştırılabilir dosyada 
    (PE formatında) belirtilen uzunluk olarak alınır. Genel olarak default uzunluk 1MB'dir. Fonksiyonun üçüncü parametresi thread akıının 
    başlatılacağı fonksiyonun adresini almaktadır. Her thread bizim belirlediğimiz bir fonksiyondan çalışmaya başlar. LPTHREAD_START_ROUTINE
    aşağıdaki gibi typedef edilmiştir:

    typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);

    Görüldüğü gibi LPTHREAD_START_ROUTINE geri dönüş değeri DWORD, parametresi LPVOID (yani void *) türünden olan bir fonksiyon adresini 
    belirtmektedir. 32 bit Windows sistemlerinde "fonksiyon çağırma (calling convention)" biçimi __stdcall olmak zorundadır. Bu __stdcall 
    anahtar sözcüğü Microsoft'a özgü olan bir eklentidir (extension). __stdcall WINAPI olarak da define edişmiştir:

    #define WINAPI        __stdcall

    Bu çağırma biçimi Microsoft derleyicilerinde fonksiyon isminin solunda bulundurulmak zorundadır. Örnek bir thread fonksiyonu şöyle olabilir:

    DWORD WINAPI ThreadProc(LPVOID param)
    {
        ...
    }

    64 bit Windows sistemlerinde "çağırma biçimi (calling convention)" kaldırılmıştır. Bu nedenle bus sistemlerde __stdcall önişlemci komutlarıyla
    aşağıdaki gibi silinmiştir:

    #define __stdcall

    O halde Windows programımızı 32 bit ve 64 bit uyumlu yazmak istiyorsak bu çağırma biçimini fonksiyonun soluna yazabiliriz. Nasıl olsa 
    64 bit derlemede bu çağırma biçimi silinecektir. 

    CreateThread fonksiyonunun dördüncü parametresi thread fonksiyonuna geçirilecek olan parametreyi belirtmektedir. Thread'leryaratıldığında 
    akış başlatılacağı thread fonksiyonuna bu parametrede belirtilen değer aktarılmaktadır. Biz böyle bir parametre geçmek istemiyorsak 
    bu parametreyi NULL biçimde belirtebiliriz. Fonksiyonun beşinci parametresi tipik olarak 0 biçiminde ya da CREATE_SUSPENDED biçiminde 
    geçilir. Eğer bu parametre 0 geçilirse thread yaratılır yaratılmaz çalışmaya başlar. Eğer bu parametreye CREATE_SUSPENDED değeri geçilirse
    threda yaratılır ancak henüz çalışmaya başlamaz. Thread'i çalıştırmak için ResumeThread API fonksiyonu kullanılmalıdır. Fonksiyonun son 
    parametresi thread'in ID değerinin yerleştirileceği DWORD nesnesinin adresini almaktadır. Bu ID değeri bazı durumlarda gerekebilmektedir. 
    Eğer thread'in ID değeri alınmayacaksa bu parametreye NULL geçilebilir. CreateThread fonksiyonu başarı durumunda yaratılan thread'in handle 
    değerine, başarısızlık durumunda NULL adres değerine geri dönmektedir. Buradan elde edilen handle değeri diğer thread işlemlerinde kullanılmaktadır.
    Thread'in değeri thread işlemlerinde kullanılmaz. Handle değeri thread işlemlerinde kullanılmaktadır. Örneğin:

    HANDLE hThread;
    DWORD dwThreadId;
    
    DWORD __stdcall ThreadProc(LPVOID param);
    ...
    
    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");
    ...

    Thread fonksiyonu bittiğinde thread kaynaklarının önemli bir bölümü zaten boşaltılmaktadır. Ancak thread kernel nesnesinin tam olarak 
    boşaltımını sağlamak için CloseHandle fonksiyonu uygulanabilir. 

    Aşağıdaki örnekte bir thread yaratılmıştır. Hem ana threadhem de yaratılan thread çalışmaktadır. 

-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    for (int i = 0; i < 10; ++i) {
        printf("Main thread: %d\n", i);
        Sleep(1000);
    }

    CloseHandle(hThread);

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread: %d\n", i);
        Sleep(1000);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde thread işlemleri başı "pthread_" ila başlatılan POSIX fonksiyonlarıyla yapılmaktadır. Thread işlemleri için 
    kullanılan bu fonksiyonların oluşturduüu topluluğa "pthread kütüphanesi" de denilmektedir. Yukarıda da belirttiğimiz gibi bu kütüpahendeki
    tüm fonksiyonlar pthread_xxx biçiminde isimlendirilmiştir. Tüm thread fonksiyonlarının prototipleri <pthread.h> isimli başlık dosyasının 
    içerisindedir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde thread yaratmak için pthread_create isimli POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

     #include <pthread.h>

    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);

    Fonksiyonun birinci parametresi thread'in id'sinin yerleştirileceği pthread_t türünden nesnenin adresini almaktadır. Bu sistemlerde 
    thread'lerin yalnızca id'leri vardır. Thread işlemleri de id'lerle yapılmaktadır. pthread_t türü işletim sistemini yazanlar tarafından 
    herhangi bir olarak typedef edilebilmektedir. Linux sistemlerinde bu tür unsigned long olarak typedef edilmiştir. Ancak başka sistemlerde
    bir yapı biçiminde de typedef edilmiş olabilir. Fonksiyonun ikinci parametresi yaratılacak thread'e ilişkin bazı özelliklerin belirtildiği
    thread özellik nesnesinin adresinin almaktadır. Programcı thread özelliklerini bu nesne ile oluşturup bu nesnenin adresini fonksiyona 
    vermektedir. Ancak bu parametre NULL adres olarak da geçilebilir. Bu durumda thread default özelliklerle yaratılacaktır. Fonksiyonun üçüncü
    parametresi thread akışının başlatılacağı fonksiynun adresini belirtmektedir. Thread fonksiyonlarının geri dönüş değerlerinin void * türünden 
    parametrelerinin de void * türünden olması gerekir. Örneğin:

    void *thread_proc(void *param)
    {
        ....
    }

    Fonksiyonun son parametresi thread fonksiyonuna geçirilecek olan argümanı belirtmektedir. Tabii eğer thread fonksiyonuna bir parametre 
    geçirilmek istenmiyorsa bu parametre için NULL adres kullanılabilir. 

    pthread_create fonksiyonu başarı durumunda 0 değerine geri dönmektedir. Fonksiyon başarısızlık durumunda errno değişkeninin set etmez. 
    Başarısızlığı belirten errno değeri ile geri döner. Biz de bu değeri strerror fonksiyonu ile yazıya dönüştürüp yazdırabiliriz. Örneğin:

    pthread_t tid;
    int result;

    void *thread_proc(void *param);
    ...

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) {
        fprintf(stderr, "pthread_create: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }
    ...

    Tabii işlemleri kısaltmak için hata durumunu ele alan bir fonksiyon da yazabiliriz:

    void exit_sys_errno(const char *msg, int eno)
    {
        fprintf(stderr, "%s: %s\n", msg, strerror(eno));

        exit(EXIT_FAILURE);
    }

    pthread_create fonksiyonuyla yaratılmış olan thread'ler hemen çalışmaya başlamaktadır. Aşağıda UNIX/Linux sistemlerinde thread yaratmaya 
    bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }
    
    CloseHandle(hThread);

    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler çeşitli biçimlerde sonlanabilmektedir. Bir thread'in en doğal sonlanması thread fonksiyonunun bitmesi ile gerçekleşir. Hem
    Windows sistemlerinde hem de UNIX/Linux ve macOS sistemlerinde thread fonksiyonu bittiğinde thread'ler de otomatik olarak sonlanmaktadır. 
    Yukarıdaki örneklerimizde sonlanma bu biçimde doğal yolla gerçekleşmiştir. Tavsiye edilen sonlanma biçimi böyledir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir thread herhangi bir noktada Windows'ta ExitThread API fonksiyonu ile UNIX/Linux ve macOS sistemlerinde pthread_exit fonksiyonu ile
    sonlandırabilir. Bu fonksiyonları hangi thread akışı çağırırsa o thread sonlanmaktadır. exit fonksiyonunun tüm prosesi sonlandırdığına ancak 
    ExitThread ve pthread_exit fonksiyonlarının yalnızca tek bir thread'i sonlandırdığına dikkat ediniz. 

    Therad'lerin de tıpkı prosesler gibi exit kodları vardır. Windows sistemlerinde thread'lerin exit kodları DWORD değerle, UNIX/Linux ve macOS 
    sistemlerinde ise void * bir değerle temsil edilmektedir. Thread'in exit kodları thread sonlandığında ilgili prosesler tarafından alınıp 
    çeşitli amaçlarla kullanılabilmektedir. Ancak uygulamaların çoğunda bu exit kodunu kullanamaya gerek duyulmamaktadır. 

    Windows'taki ExitThread API fonksiyonunun prototipi şöyledir:

    void ExitThread(
        DWORD dwExitCode
    );

    Fonksiyon thread'in exit kodunu parametre olarak almaktadır. 

    Aşağıda Windows sistemlerinde ExitThread fonksiyonu ile thread'in sonlandırılmasına bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    for (int i = 0; i < 10; ++i) {
        printf("Main thread: %d\n", i);
        Sleep(1000);
    }

    CloseHandle(hThread);

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread: %d\n", i);
        if (i == 5)
            ExitThread(0);
        Sleep(1000);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux ve macOS sistemlerinde thread'i sonlandırmak için kullanılan pthread_exit fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    void pthread_exit(void *retval);

    Fonksiyon yine thread'in exit kodunu parametre olarka olmaktadır. Yukarıda da belirttiğimiz gibi bu sistemlerde thread'in exit kodu void * 
    temsil edilmektedir. 

    Aşağıda UNIX/Linux ve macOS sistemlerinde thread'in pthread_exit fonksiyonu ile sonlandırılmasına bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    CloseHandle(hThread);
    
    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        if (i == 5)
            pthread_exit(NULL);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir proses sonlandığında prosesin bütün thread'leri de sonlandırılmaktadır. Örneğin biz exit fonksiyonunu çağırdığımızda exit fonksiyonu 
    tüm prosesi sonlandıracağı için bütün thread'lerde sonlanacaktır. C' de main fonksiyonu bittiğinde exit fonksiyonu ile prosesin sonlandırıldığını
    anımsayınız. Bu durumda main fonksiyonu biterse prosesin tüm thread'leri de sonlanacaktır. Thread'ler konusuna yeni başlayan kişiler 
    bu hatayı çok sık yapmaktadır. Aşağıdaki örnekte main fonksiyonunda bir thread yaratılmış ancak main fonksiyonu hemen sonlanmıştır. Bu 
    durumda yaratılmış olan thread de tüm program da sonlanacaktır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    /* dikkat! main bitince yaratılmış olan thread de sonlandırılacaktır */
    
    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        if (i == 5)
            pthread_exit(NULL);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Threadler arasında Windows sistemlerinde ve UNIX/Linux sistemlerinde üstlük/altlık (parent/child) ilişkisi yoktur. Yani bir thread'i hangi 
    thread'in yarattığının genel olarak bir önemi yoktur. (Bu konuda bazı ayrıntılar bulunmaktadır.) Bir thread başka bir thread'i Windows 
    sistemlerinde TerminateThread API fonksiyonuyla o anda zorla sonlandırabilir. Bu tür sonlandırmalar tavsiye edilmemektedir. Çünkü bir 
    thread'in belli bir noktada (örneğin printf fonksiyonunun içerisinde) zorla sonlandırılması programın çökmesine yol açabilmektedir. 
    TerminateThread API fonksiyonunun prototipi şöyledir:

    BOOL TerminateThread(HANDLE hThread, DWORD  dwExitCode);
    
    Fonksiyonun birinci parametresi sonlandırılack thread'inb handle değerini almaktadır. İkinci parametre ise thread'in exit kodunu belirtmektedir.
    Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri dönmektedir.

    Aşağıdaki örnekte ana thread diğer thread'i zorla TerminateThread API fonksiyonuyla sonlandırmıştır. Burada tüm program bu zorla sonlandırmadan
    olumsuz etkilenebilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            if (!TerminateThread(hThread, 0))
                ExitSys("TerminateThread");
        printf("Main thread: %d\n", i);
        Sleep(1000);
    }

    CloseHandle(hThread);

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread: %d\n", i);
        Sleep(1000);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde de bir thread başka bir thread'i zorla pthread_cancel fonksiyonu ile sonlandırabilir. Ancak bu fonksiyon Windows 
    sistemlerindeki    TerminateThread fonksiyonu gibi çalışmamaktadır. UNIX/Linux sistemlerinde bir thread'e pthread_cancel fonksiyonu uygulanırsa 
    thread akışı ancak bazı POSIX fonksiyonlarında sonlandırılmaktadır. Dolayısıyla bu sistemlerde pthread_cancel fonksiyonu TerminateThread 
    fonksiyonuna göre daha güvenlidir. pthread_cancel uygulandığında thread akışının sonlandırılabileceği POSIX fonksiyonlarına İngilizce
    "cancellation points" denilmektedir. Bu fonksiyonarın listesi POSIX standartrlarında belirtilmiştir.

    pthread_cancel fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    Fonksiyon parametre olarak sonlandırılacak thread'in id değerini almaktadır. Başarı durumunda 0 değerine başarısızlık durumunda errno 
    değerine geri dönmektedir.

    Aşağıdaki örnekte ana thread'teki döngü 5 kez yibelendikten sonra diğer thread'i pthread_cancel fonksiyonu ile sonlandırmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
        sleep(1);
    }
    
    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        if (i == 5)
            pthread_exit(NULL);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte pthread_cancel fonksiyonu sonsuz döngüdeki thread'i sonlandıramayacaktır. Çünkü bu thread sonlandırma için gereken 
    POSIX fonksiyonlarına (cancellation points) girmemiştir. Thread'in sonlandırılıp sonlandırılmadığını başka bir terminalden ps komutunda -T 
    seçeneğini kullanarak görebilirsiniz. Komut şöyle uygulanabilir:

    $ ps -t /dev/pts/0 -T

    Burada /dev/pts/0 thread'li programın çalıştığı termşnali belirtmektedir. Bu terminal sizin denemenizde farklı olabilir. Bu terminali 
    tty komutu ile öğrenebilirisniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_errno(const char *msg, int result);

int main(int argc, char *argv[])
{
    pthread_t tid;
    int result;
    int i;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_errno("pthread_create", result);

    for (i = 0; i < 10; ++i) {
        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_errno("pthread_cancel", result);

        printf("main thread: %d\n", i);
        sleep(1);
    }
    printf("press ENTER to exit..\n");
    getchar();

    return 0;
}

void *thread_proc(void *param)
{
    for (;;)
        ;

    return NULL;
}

void exit_errno(const char *msg, int result)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(result));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'lerin stack'leri birbirlerinden ayrılmıştır. Bu nedenle farklı thread akışları aynı fonksiyon üzerinde ilerlerken o fonksiyondaki
    yerel değişkenlerin ve parametre değişkenlerinin farklı kopyalarını kullanıyor durumda olurlar. Aşağıdaki Windows örneğinde ana thread 
    ve yaratılan thread aynı Foo fonksiyonunu çağırmıştır. Ancak Foo içerisindeki i nesnesi iki threda için de farklı i nesneleridir. Bu örneği
    i yerel değişkenini global değişken yaparak da çalışırınız. İki çalıştırma arasındaki farkı gözlemleyiniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void Foo(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    Foo("main thread");

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    Foo("other thread");

    return 0;
}

int i = 0;

void Foo(LPCSTR pszName)
{
    while (i < 10) {
        printf("%s: %d\n", pszName, i);
        Sleep(1000);
        ++i;
    }
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir thread'in sonlanmasının blokede beklenmesi sıkça gerekebilmektedir. Örneğin ana thread bir thread yaratıp belli bir noktada thread 
    sonlanana kadar beklemek isteyebilir. 

    Windows sistemlerinde thread sonlanana kadar bekleme yapmak için WaitForSingleObject ve WaitForMultipleObjects isimli API fonksiyonları 
    bulunmaktadır. Bu fonksiyonlar yalnızca thread'leri beklemek için değil diğer kernel senkronizasyon nesnelerini de beklemek için 
    kullanılmaktadır. Yani bu fonksiyonlar genel bir bekleme amacıyla tasarlanmıştır. Biz bu fonksiyonların kernel senkronizasyon nesneleriyle 
    nasıl kullanılacağını ilerleyen paragraflarda göreceğiz. Ancak burada yalnızca bu fonksiyonların thread'leri beklemek için nasıl kullanılacağı
    üzerinde duracağız.WaitForSingleObject fonksiyonun prototipi şöyledir:

    DWORD WaitForSingleObject(
        HANDLE hHandle,
        DWORD  dwMilliseconds
    );

    Yukarıda da belirttiğimiz gibi WaitForSingleObject fonksiyonu genel bir fonksiyondur. Bu fonksiyon bir senkronizasyon nesnesi kapalı 
    (nonsignaled) olduğu sürece bekleme yapar. Senktronizasyon nesnesi açık duruma (signaled) geçtiğinde bekleme sonlanır. Her senkronizasyon 
    nesnesinin hangi durumda kapalı hangi durumda açık olduğu ayrıca öğrenilmelidir. İşte thread'ler de bir senkronizasyon nesnesi gibi 
    kullanılabilmektedir. Thread senkronizasyon nesnesi thread devam ettiği sürece kapalı durumdadır. Thread sonlanınca açık duruma geçer. 
    O halde bu fonksiyon thread bitene kadar bekleme sağlamaktadır. Fonksiyonun ikinci parametresi milisaniye cinsinden "zaman aşımı (timeout)" 
    belirtmektedir. Eğer nesne burada belirtilen zaman aşımı dolana kadar açık hale gelmezse en fazla bu zaman aşıma kadar bekleme yapılmaktadır. 
    Bu parametre için INFINITE özel değeri girilirse zaman aşımı kullanılmaz. NEsne açık duruma geçene kadar bekleme yapılır. 
    
    WaitForSingleObject fonksiyonu başarısızlık durumunda WAIT_FAILED değeri ile geri dönmektedir. Bunun dışında diğer geri dönüş değerleri
    şunlardan biri olabilir:

    WAIT_OBJECT_0: Nesne açık duruma geçiği için fonksiyon sonlanmıştır. Bu en normal durumdur. 
    WAIT_TIMEOUT: Zaman aşımı nedenyiyle fonksiyon sonlanmıştır.
    WAIT_ABONDONED: Mutex'in beklendiği durumda mutex'in sahipliğini alan thread'in sonlanması nedeniyle fonksiyon sonlanmıştır. Bu duruma
    "abondoned mutex" denilmektedir. 

    WaitForSingleObject fonksyionu çağrıldığında zaten nesne açık durumdaysa (signaled) fonksiyon hiç bekleme yapmaz, WAIT_OBJECT_0 değeri ile
    hemen geri döner. 
    
    Bu durumda bir thread sonlanana kadar bekleme yapmak şöyle sağlanabilir:

    if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) 
        ExitSys("WaitForSingleObject")

-------------------------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void Foo(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    printf("main thread waits at WaitForSingleObject...\n");

    if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
        ExitSys("WaitForSingleObject");

    CloseHandle(hThread);

    printf("main thread continues...\n");

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread: %d\n", i);
        Sleep(1000);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    WaitForMultipleObjects fonksiyonu birden fazla senkronizasyon nesnesini beklemek için kullanılmaktadır. Örneğin biz 10 thread yaratmış 
    olalım. Bunların hepsi sonlanana kadar bekleme yapmak isteyelim. Bunun bir yolu WaitForSingleObject fonksiyonunu 10 kez çağırmaktır. 
    Diğer bir yolu ise bir kez WaitForMultipleObject fonksiyonunu kullanmaktır. 

    WaitForMultipleObjects fonksiyonunun prototipi şöyledir:

    DWORD WaitForMultipleObjects(
        DWORD        nCount,
        const HANDLE *lpHandles,
        BOOL         bWaitAll,
        DWORD        dwMilliseconds
    );

    Fonksiyonun birinci parametresi kaç senkronizasyon nesnesinin bekleneceğini belirtmektedir. (Yani bu parametre ikinci parametredeki dizinin
    uzunluğunu belirtir.) İkinci parametre beklenecek senkronizasyon nesnelerinin hhandle değerlerinin bulundurğu dizinin adresini almaktadır. 
    Üçüncü parametre tek bir nesnenin mi yoksa bütün nesnelerin mi açık duruma geçince beklemenin sonlandırılacağını belirtir. Eğer bu parametre
    TRUE geçilirse tüm nesneler açık duruma geçene kadar bekleme yapılır. Eğer bu parametre FALSE geçilirse en az bir nesne açık duruma geçene 
    kadar bekleme yapılır. Son parametre yine zaman aşımı belirtmektedir. Bu parametre INFINITE geçilebilir. 

    WaitForMultiplrObjects fonksiyonu başarısız olursa WAIT_FAILED değerine geri dönmektedir. Eğer fonksiyon zaman aşımı dolayısıyla sonlanmışsa 
    yine WAIT_TIMEOUT değerine geri döner. Eğer fonksiyonun üçüncü parametresi TRUE geçilirse tüm senkronizasyon nesneleri açıldığında fonksiyon 
    WAIT_OBJECT_0 değerinden WAIT_OBJECT_0  + nCunt değerine kadar herhangi bir değerle geri dönebilir. Eğer fonksiyonun üçüncü parametresi 
    FALSE geçilirse fonksiyon hangi senkronizasyon nesnesi açık duruma geçtiyse ona ilişkin WAIT_OBJET_0 + n değerine geri döner. Burada 
    n açık duruma geçen nesnenin dizideki indeksini belirtmektedir. Bu durumda birden fazla nesne açık duruma geçerse fonksiyon en düşük 
    indeksle geri dönmektedir.

    Aşağıdaki örnekte 10 thread yaratılmış ve 10 thread'in sonlanması WaitForMultipleObjects fonksiyonu ile beklenmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define NTHREADS        10

DWORD __stdcall ThreadProc(LPVOID param);
void Foo(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadIds[NTHREADS];
    HANDLE hThreads[NTHREADS];
    char szName[64];
    char *pszName;

    printf("main thread begins...\n");

    for (int i = 0; i < NTHREADS; ++i) {
        sprintf(szName, "Thread %d", i);
        if ((pszName = strdup(szName)) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        if ((hThreads[i] = CreateThread(NULL, 0, ThreadProc, pszName, 0, &dwThreadIds[i])) == NULL)
            ExitSys("CreateThread");
    }

    printf("main thread waits at WaitForSingleObject...\n");

    if (WaitForMultipleObjects(NTHREADS, hThreads, TRUE, INFINITE) == WAIT_FAILED)
        ExitSys("WaitForMultipkeObjects");

    for (int i = 0; i < NTHREADS; ++i)
        CloseHandle(hThreads[i]);

    printf("main thread continues...\n");

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    const char *pszName = (const char *)param;

    for (int i = 0; i < 10; ++i) {
        printf("%s: %d\n", pszName, i);
        Sleep(1000);
    }

    free(pszName);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'lerin de exit kodları vardır. Windows'ta thread'lerin exit kodları GetExitCodeThread fonksiyonu ile, UNIX/Linux sistemlerinde 
    sonraki paragrafta göreceğimiz pthread_join fonksiyonu ile elde edilmeketdir. Tabii sonlanmamış bir thread'in exit kodunun elde edilmeye 
    çalışılması anlamsızdır. Therad'lerin exit kodları thread fonksiyonlarının geri dönüş değerleridir. Windows'ta thread'lerin exit kodları 
    DWORD bir değerken UNIX/Linux sistemlerinde void * türünden bir değerdir. Anımsanacağı gibi thread'lerde üstlük-altlık (parent-child) 
    durumu yoktur. Bir thread'in exit kodu herhangi bir thread tarafındna alınabilir. 
    
    Windows'ta GetExitCodeThread fonksiyonunun protoipi şöyledir:

    BOOL GetExitCodeThread(
        HANDLE  hThread,
        LPDWORD lpExitCode
    );

    Foksiyonun birinci parametresi exit kodu elde edilecek thread'in HANDLE değerini belirtir. İkinci parametre exit kodunun yerleştirileceği 
    DWORD nesnenin adresini almaktadır. Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri döner.  
    Aşağıdaki örnekte Windows'ta yaratılan bir thread'in exit kodu elde eidlmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc(LPVOID param);
void Foo(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwThreadId;
    HANDLE hThread;
    DWORD dwExitCode;

    printf("main thread begins...\n");

    if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread");

    printf("main thread waits at WaitForSingleObject...\n");

    if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
        ExitSys("WaitForSingleObject");

    if (!GetExitCodeThread(hThread, &dwExitCode))
        ExitSys("GetExitCodeThread");

    CloseHandle(hThread);

    printf("Exit Code: %u\n", dwExitCode);

    return 0;
}

DWORD __stdcall ThreadProc(LPVOID param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread: %d\n", i);
        Sleep(1000);
    }

    return 123;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde thread'lerin sonlanmasının beklenmesi ve exit kodlarının alınması pthread_join fonksiyonuyla sağlanmaktadır. 
    Yani fonksiyon hem bekleme yapıp hem de exit kodu almaktadır. Fonksyonunun prototipi şöyledir:

     #include <pthread.h>

     int pthread_join(pthread_t thread, void **retval);

     Fonksiyonun birinci parametresi beklemecek thread'in id değerini belirtmektedir. İkinci parametre exit kodunun yerleştirileceği void 
     göstericinin adresini belirtmektedir. Eğer ikinci parametre NULL geçilirse thread'in birmesi beklenir ancak exit kodu çağıran fonksiyona 
     iletilmez. Fonksiyon baları durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir.

     Aşağıdaki örnekte main fonksiyonu içerisinde (yani ana thread'te) bir thread yaratılmış e thread'in sonlanması pthread_join fonksiyonuyla
     beklenmiştir. Bu örnekte exit kodu bir tamsayı olduğu halde sanki bir adresmiş gibi oluşturulmuştur. Yine exit kod göstericinin içerisinden 
     alınarak int tüürne dönüştürülüp kullanılmıştır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    void *exit_code;

    printf("main begins...\n");

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    printf("main thread waits at pthread_join...\n");
    if ((result = pthread_join(tid, &exit_code)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("Exit code: %d\n", (int)exit_code);
    
    return 0;
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return (void *)123;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde "zombie proses" kavramı vardı. Pekiyi zombie thread kavramı da var mıdır? Aslında bu sistemlerde işletim sistemi
    tıpkı proseslerde olduğu gibi therad'in ezit kodu alınmamışsa belli bir sistem kaynağını serbest bırakmadan bekletmektedir. Yani zombie
    thread kavramı zombie proses kavramı gibi bu sistemlerde söz konsudur. Ancak zombie thread'ler zombie prosesler kadar probleme yol açma
    potansiyelinde değildir. Fakat yine pthread_join fonksiyonuyla zombie thread'lerin oluşması engellenmelidir. Eğer programcı thread'in exit 
    kodu ile ilgilenmiyorsa thread biter bitmez kaynakalrın boşaltılmasını işletim sisteminden isteyebilir. Bunun için pthread_detach fonksiyonu
    kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_detach(pthread_t thread);

    Fonksiyon parametre olarak thread'in id değerini alır, başarı drumunda sıfır değerine, başarısızlık durumunda errno değerine geri döner.
    Tabii detach moda sokulmuş thread'ler artık pthread_join fonksiyonuyla beklenemezler. Eğer bunlar beklenmeye çaışılırsa ptherad_join 
    fonksiyonu başarısız olmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler konusunun en önemli alt konusu thread senkronizasyonudur. Bir grup thread birlikte bir işi gerçekleştirirken kimi zaman 
    birbirlerini beklemesi, birbirleriyle koordineli bir biçimde çalışması gerekmektedir. İşte işletim sistemlerinde bunu sağlamaya yönelik 
    mekanizmalara ""thread senkronizasyonu" denilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread senkronizasyonunun önemi basit örnekle anlaşılabilir. Thread'lerin aynı global nesneleri kullandığını belirtmiştik.     İki thread
    aynı global değişkeni bir döngü içerisinde bir milyon kere artırıyor olsun. Bu global değişkenin değerinin iki milyon olması beklenir. 
    Ancak senkronizasyon problemi yüzünden muhtemelen iki milyon olamayacaktır. Aşağıda bu örnek Unix/Linux sistemleri için oluşturulmuştur.
    Programın farklı çalıştırılmalarında elde edilen bazı değerler şunlardır:

    $ ./sample
    1140644
    $ ./sample
    1175870
    $ ./sample
    1900343
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki program Windows sistemlerinde de aşağıdaki gibi yazılabilir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

int g_count;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;
    
    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    printf("%d\n", g_count);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000000; ++i)
        ++g_count;

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000000; ++i)
        ++g_count;

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread senkronizasyon problemleri tipik olarak birden fazla thread'in ortak bir kaynak üzerinde çalıştığı durumda ortaya çıkmaktadır. 
    Thread'lerden biri bu ortak kaynak üzerinde yazma (gemel olarka güncelleme) yaptığı bir durumda bu işlemler sırasında thread'ler arası 
    geçiş oluşursa ve başka bir thread de bu kararsız durumda kalmış kaynağı kullanırsa ya da o da bu kaynağa yazma yaparsa diğer thread 
    kaldığı yerden çalışmasına devam ettiğinde sorun oluşacaktır. Burada kaynak (resource) demekle ortak kullanılan bir nesne kastedilmektedir.
    Bu nesne global bir değişken olabileceği gibi dış dünyadaki gerçek bir donanımsal aygıt olabilir. 

    Örneğin iki thread dış dünyadaki bir makineyi sırasıyla 1, 2, 3, 4, 5 konumlarına sokarak kullanıyor olsun. Bu kodu aşağıdaki gibi temsil
    edelim:

    ...
    <Makineyi 1'inci konuma sok>
    <Makineyi 2'inci konuma sok>
    <Makineyi 3'üncü konuma sok>
    <Makineyi 4'üncü konuma sok>
    <Makineyi 5'inci konuma sok>
    ...

    Şimdi thread'lerden biri aşağıdaki noktada threadler arası geçiş (context switch) oluşup kesilmiş olsun:

    ...
    <Makineyi 1'inci konuma sok>
    <Makineyi 2'inci konuma sok>
    <Makineyi 3'üncü konuma sok>
    ----> Bu noktada "context switch" olsun
    <Makineyi 4'üncü konuma sok>
    <Makineyi 5'inci konuma sok>
    ...

    Başka bir thread aynı makineyi kullanmak istesin ve başından sonuna kadar kesilmeden makineyi konumlara sokarak kullansın. Makine şimdi 
    beşinci konumdadır. Şimdi daha önce kesilen thread kaldığı noktadn çalışmaya devam etsin. Bu thread makineyi 3'üncü konumda sanmaktadır. 
    Halbuki makine şu anda 5'inci konumdadır. Muhtemelen beklenmedik sorunlar oluşacaktır. 

    Şimdi de yukarıdaki sayaç örneğinin neden düzgün çalışmadığını açıklayalım. Bu örnekte iki thread de ++g_count ile global değişkeni 1 
    artırmaktadır. Ancak derleyiciler bu ++g_count işlemini tipik olarak üç makine komutuyla yapmaktadır:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Önce g_count CPU yazmacına çekilmiştir. Sonra bu yazmaç değer 1 artırılmıştır. Sonra da artırılmış değer yeniden g_count nesnesine 
    yerleştirilmiştir. Şimdi tam aşağıdaki noktada tesadüfen bir thread'ler arası geçişin oluştuğunu varsayalım:

    MOV reg, g_count
    ----> Bu noktada "context switch" olsun
    INC reg
    MOV g_count, reg

    Bu noktada g_cunt değerinin 1250305 olduğunu varsayalım. Şimdi diğer thread kesilmedne bir quanta çalışıp g_count değerini örneğin 
    1756340'a getirmiş olsun. Önceki thread kalan noktadan çalışmaya devam ettiğinde yazmaçta 1250305 değeri olacaktır. Bunu 1 artırdığında 
    1250306 elde edilir. Bu değeri yeniden g_count nesnesine yerleştrecek ve g_count'taki değeri bozacaktır. 

    Thread'ler arası geçiş bir makine komutu çalışırken oluşmaz, iki makine komutu arasında oluşabilir. Ancak hangi makine komutunda bu 
    geçişin oluşacağu "quanta" durumuna bağlıdır. Dolayısıyla bir thread herhangi bir makine komutunda kesilebilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Başından sonuna kadar tek bir thread akışı tarafından çalıştırılması gereken kod bloklarına "kritik kod blokları (critical sections)"
    denilmektedir. Kritik kod bloklarına bir thread girdiğinde thread'ler arası geçiş (context switch) oluşabilir. Ancak diğer thread'ler
    bu bloğa girmek istediğinde daha girmiş olan thread'in buradan çıkmasını beklerler. Böylece başından sonuna kadar tek bir threda akışı 
    tarafından kritik kodlar çalıştırılmış olur. Yukarıdaki örneklerimizde g_count nesnesinin artırılması bir kritik koddur. Örneğin:

    ...
    MOV reg, g_count
    INC reg
    MOV g_count, reg
    ...

    Bu üç makine komutu bir kritik kod oluşturmaktadır. Yani thread bu kodları çalıştırırken kesilebilir ancak başka bir thread diğeri 
    çıkana kadar bu kritik koda girmez. Tabii kritik kod oluşturmanın diğer bir yolu geçici süre thread'ler arası geçişi engellemek olabilir. 
    Ancak bu yöntemin user mode'tan uygulanması mümkün değildir. Yukarıdaki makine örneğimizde de makineyi kullanan kod kritik bir koddur:

    ...
    <Makineyi 1'inci konuma sok>
    <Makineyi 2'inci konuma sok>
    <Makineyi 3'üncü konuma sok>
    <Makineyi 4'üncü konuma sok>
    <Makineyi 5'inci konuma sok>
    ...

    Bir thread bu kritik koda girdiğinde arada kesilse bile başka thread bu thread kritik koddan çıkana kadar kritik koda girmemelidir. 

    Senkronizasyon bağlamında bir grup makine komutunun sanki tek bir makine komutuymuş gibi kesilmeden çalıştırılmasına "atomiklik (atomicity)"
    denilmektedir. Yani "bir işlemin atomik bir biçimde yapılması" demek "kesilmeden başka bir deyişle thread'ler arası geçiş oluşmadan" 
    yapılması demektir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kritik kodların oluşturulabilmesi işletim sistemi tarafından sağlanan özel sistem fonksiyonları ya da bunları kullanan kütüphane 
    fonksiyonlarıyla sağlanabilmektedir. Kritik kodlar manuel biçimde işletim sisteminin desteği olmadan ya da özel birtakım yööntemler 
    kullanılmadan oluşturulamaz. Örneğin aşağıdaki gibi bir kritik kod oluşturma mümkün değildir:

    int g_flag = 0;
    ...

    while (g_flag == 1) 
        ;
    g_flag = 1;
    ......
    ......    <KRİTİK KOS>
    ......
    g_falg = 0;

    Buradaki kodun iki önemli problemi vardır:

    1) Burada tam while döngüsünden çıkılmışken ancak g_flag = 1 işlemi yapılmadan thread'ler arası geçiş oluşabilir:

    while (g_flag == 1) 
        ;
    ----> Dikkat tan bu noktada "context switch" olabilir
    g_flag = 1;
    ......
    ......    <KRİTİK KOS>
    ......
    g_falg = 0;

    Bu durumda g_flag 0 konumunda kalmıştır ancak thread kritik koda girmiştir. Yani bir thread de bu thread de kritik kodda ilerleyebilir. 

    2) Burada bekleme "meşgul bir döngüyle (busy loop)" yapılmaktadır. Yani bekleme yapılırken gereksiz biçimde CPU zamanı harcanmaktadır. 

    İşet bu tür kodlar özel birtakım mekanizmaalr olmadan oluşturulamamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kritik kodlar tek bir blok biçiminde olmayabilir. Birden fazla yere yayılmış olarak bulunabilirler. Örneğin global bir bağlı listeye 
    thread'lerden biri ekleme yaparken diğer bir thread ekleme de silme de hatta dolaşma da yapmamı gerekir. Burada bağlı listeye ekleme 
    yapan, bağlı listeden silme yapan ve bağlı listeyi dolaşan kodlar kritik kodlardır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta kritik kod oluşturmak için en yalın ve hızlı yöntem CRITICAL_SECTION isimli nesneyi kullanmaktır. Bu nesne ile kritik kodlar
    şöyle oluşturulmaktadır:

    1) Önce global bir değişken biçiminde CRITICAL_SECTION türünden bir nesne yaratılır. CRITICAL_SECTION typedef edilmiş bir yapı türünü 
    belirtmektedir. Ancak programcının bu yapının içeriğini bilmesine gerek yoktur. Örneğin:

    CRITICAL_SECTION g_cs;

    2) Yaratılan bu nesneye initializeCriticalSection API fonksiyonuyla ilkdeğerleri verilir. Fonksiyonun prototipi şöyledir:

    void InitializeCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
    );

    Fonksiyon CRITICAL_SECTION nesneninin adresini parametre olarak almaktadır. Bu ilkdeğer verme işlemi henüz thread'ler yaratılmadan 
    yapılabilir. Örneğin:

    InitializeCriticalSection(&g_cs);

    3) Kritik kod EnterCriticalSection ve LeaveCriticalSection API fonksiyonları arasına alınır. Örneğin:

    EnterCriticalSection(&g_cs);
    ...
    ...    <KRİTİK KOD>
    ...
    LeaveCriticalSection(&g_cs);

    Fonksiyonların prototipleri şöyledir:

    void EnterCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
    );

    void LeaveCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
    );

    Her iki fonksiyon da CRITICAL_SECTION nesnesinin adresini almaktadır. Bir thread EnterCriticalSection fonksiyonundan girdiğinde 
    LeaveCriticalSection fonksiyonunu çağırana kaadar nesneyi kilitlemiş olur. Böylece başka bir thread EnterCriticalSection fonksiyonundan
    geçiş yapma istediğinde bloke olur. Ta ki önceki thread LeaveCriticalSection fonksiyonunu çağırana kadar. CRITICAL_SECTION nesnesinin
    bir kilit gibi davrandığına dikkat ediniz. Bir thread bu fonksiyondan geçtiğinde nesne kilitlenmekte başka thread'ler kritik koda girememektedir.
    LeaveCriticalSection kritik kodun kilidini açmaktadır. 

    Bir thread EnterCriticalSection fonksiyonundan geçerek nesneyi kilitlemiş olsun. Bu sırada birden fazla thread nesne kilitli olduğu için 
    EnterCriticalSection fonksiyonunda bekliyor olsun. İlk thread kritik koddan çıktığında EnterCriticalSection fonskiyonunda bloke olmuş olan
    hangi thread kritik koda girecektir? En adil durumun ilk gelen thread'in girmesi olduğunu düşünebilirsiniz. Ancak Windows sistemleri 
    çeşitli nedenlerden dolayı bunun garantisini vermemektedir. 

    4) Kullanım bittikten sonra CRITICAL_SECTION nesnesi DeleteCriticalSection fonksiyonu ile yok edilmeldir. Örneğin:

    DeleteCriticalSection(&g_cs);

    Fonksiyonun prototipi şöyledir:

    VOID DeleteCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection   
    );
 
    Fonksiyon yine CRITICAL_SECTION    nesnesinin adresini almaktradır. 

    Kritik kod bloğu birden fazla yere yayılmış olarak bulunabilir. Önemli olan Bu fonksiyonlarda kullanılan nesnedir. Aynı nesne aynı kilidi 
    temsil etmektedir. Örneğin:

    void insert_item(...)
    {
        ...
        EnterCriticalSection(&g_s);
        ....
        ....    <bağlı listeye eleman insert ediyor>
        ....
        LeaveCriticalSection(&g_s);
        ...
    }

    void delete_item(...)
    {
        ...
        EnterCriticalSection(&g_s);
        ....
        ....    <bağlı listeden eleman siliyor>
        ....
        LeaveCriticalSection(&g_s);
        ...
    }

    Burada bir thread eleman insert ederken diğer thread elemanı silemeyecektir, bir thread eleman silerken diğer thread eleman insert 
    edemeyecektir. Çünkü bu iki kritik kod aynı nesneyi yani kilidi kullanmaktadır. Dolayısıyla aslında aynı kritik kodun değişik parçalarıdır. 

    Aşağıda daha önce yapmış olduğumuz sayaç artırma örneğini CRITICAL_SECTION nensnesi kullanarak düzeltiyoruz:
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

int g_count;
CRITICAL_SECTION g_cs;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    InitializeCriticalSection(&g_cs);

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    printf("%d\n", g_count);

    DeleteCriticalSection(&g_cs);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000000; ++i) {
        EnterCriticalSection(&g_cs);
        ++g_count;
        LeaveCriticalSection(&g_cs);
    }

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000000; ++i) {
        EnterCriticalSection(&g_cs);
        ++g_count;
        LeaveCriticalSection(&g_cs);
    }


    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aağıdaki örnekte iki thread aynı makineyi sırasıyla 1, 2, 3, 4 ve 5 numaralı konumlara sokmaktadır. Kritik kod bloğu sayesinde thread'lerden 
    biri kritik koda girdiğinde diğeri kiritk koda girmemektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void UseMachine(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

CRITICAL_SECTION g_cs;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    InitializeCriticalSection(&g_cs);

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    DeleteCriticalSection(&g_cs);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 10; ++i) 
        UseMachine("Therad-1");

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 10; ++i) 
        UseMachine("Thread-2");
    
    return 0;
}

void UseMachine(LPCSTR pszName)
{
    EnterCriticalSection(&g_cs);
    printf("-------------------\n");
    printf("%s: 1. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 2. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 3. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 4. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 5. Step\n", pszName);
    Sleep(rand() % 500);
    LeaveCriticalSection(&g_cs);
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin iki thread aynı global bağlı listeye ekleme yapacak olsun. Eğer işlemler senkronize edilmezse program çökebilir ya da tanımsız 
    davranışlar oluşabilir. Aşağıda buna bir örnek verilmiştir. Örneği kritk kodları kaldırarak da test ediniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "llist.h"

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

CRITICAL_SECTION g_cs;
HLLIST g_hllist;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    InitializeCriticalSection(&g_cs);

    if ((g_hllist = create_llist()) == NULL) {
        fprintf(stderr, "cannot create linked list!..\n");
        exit(EXIT_FAILURE);
    }

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    DeleteCriticalSection(&g_cs);

    printf("%zd\n", count_llist(g_hllist));

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    for (int i = 0; i < 1000000; ++i) {
        EnterCriticalSection(&g_cs);
        if (add_tail(g_hllist, i) == NULL) {
            fprintf(stderr, "cannot add item..\n");
            exit(EXIT_FAILURE);
        }
        LeaveCriticalSection(&g_cs);
    }

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    for (int i = 0; i < 1000000; ++i) {
        EnterCriticalSection(&g_cs);
        if (add_tail(g_hllist, i) == NULL) {
            fprintf(stderr, "cannot add item..\n");
            exit(EXIT_FAILURE);
        }
        LeaveCriticalSection(&g_cs);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* llist.h */

/* llist.h */

#ifndef LLIST_H_
#define LLIST_H_

#include <stddef.h>
#include <stdbool.h>

/* Type Declarations  */

typedef int DATATYPE;

typedef struct tagNODE {
    DATATYPE val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE head;
    NODE *tail;
    size_t count;
} LLIST, *HLLIST;

/* Function Prototypes */

HLLIST create_llist(void);
NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
NODE *add_tail(HLLIST hllist, DATATYPE val);
NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
NODE *add_head(HLLIST hllist, DATATYPE val);
NODE *addp_head(HLLIST hllist, const DATATYPE *val);
void remove_next(HLLIST hllist, NODE *node);
void remove_head(HLLIST hllist);
DATATYPE *getp_item(HLLIST hllist, size_t index);
bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
void clear_llist(HLLIST hllist);
void destroy_llist(HLLIST hllist);

/* inline Function Definitions */

static inline size_t count_llist(HLLIST hllist)
{
    return hllist->count;
}

#endif

/* llist.c */

/* llist.c */

#include <stdio.h>
#include <stdlib.h>
#include "llist.h"

/* static Functions Prototypes */

static bool disp(DATATYPE *val);

/* Function Definitions */

HLLIST create_llist(void)
{
    HLLIST hllist;

    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
        return NULL;

    hllist->head.next = &hllist->head;
    hllist->tail = &hllist->head;
    hllist->count = 0;

    return hllist;
}

NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;
}

NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
{
    NODE *new_node;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;
    new_node->val = *val;

    if (node == hllist->tail)
        hllist->tail = new_node;
    new_node->next = node->next;
    node->next = new_node;

    ++hllist->count;

    return new_node;

}

NODE *add_tail(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, hllist->tail, val);
}

NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, hllist->tail, val);
}

NODE *add_head(HLLIST hllist, DATATYPE val)
{
    return insert_next(hllist, &hllist->head, val);
}

NODE *addp_head(HLLIST hllist, const DATATYPE *val)
{
    return insertp_next(hllist, &hllist->head, val);
}

void remove_next(HLLIST hllist, NODE *node)
{
    NODE *next_node;

    if (node == hllist->tail)
        return;

    if (node->next == hllist->tail)
        hllist->tail = node;

    next_node = node->next;
    node->next = next_node->next;

    --hllist->count;

    free(next_node);
}

void remove_head(HLLIST hllist)
{
    remove_next(hllist, &hllist->head);
}

DATATYPE *getp_item(HLLIST hllist, size_t index)
{
    NODE *node;

    if (index >= hllist->count)
        return NULL;

    node = hllist->head.next;
    for (size_t i = 0; i < index; ++i)
        node = node->next;

    return &node->val;
}

bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
{
    bool retval = true;
    bool def_flag = false;

    if (proc == NULL) {
        proc = disp;
        def_flag = true;
    }

    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
        if (!proc(&node->val)) {
            retval = false;
            break;
        }

    if (def_flag)
        putchar('\n');

    return retval;
}

void clear_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    hllist->head.next = &hllist->head;
    hllist->tail = &hllist->head;
    hllist->count = 0;
}

void destroy_llist(HLLIST hllist)
{
    NODE *node, *temp_node;

    node = hllist->head.next;
    while (node != &hllist->head) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(hllist);
}

static bool disp(DATATYPE *val)
{
    printf("%d ", *val);
    fflush(stdout);

    return true;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda C++'ta birden fazla thread'in "vector" isimli dinamik diziye ekleme yapmasına ilişkin benzer bir örnek verilmiştir. Bu örneği de 
    krtik kodları kaldırarak ve muhafaza ederek ayrı ayrı test ediniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <vector>

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

CRITICAL_SECTION g_cs;
std::vector<int> g_v;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;
    int i;

    srand(time(NULL));

    InitializeCriticalSection(&g_cs);

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    DeleteCriticalSection(&g_cs);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000; ++i) {
        EnterCriticalSection(&g_cs);
        g_v.push_back(i);
        LeaveCriticalSection(&g_cs);
    }

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000; ++i) {
        EnterCriticalSection(&g_cs);
        g_v.push_back(i);
        LeaveCriticalSection(&g_cs);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmak için kullanılan diğer bir senkronizasyon mekanizması da "mutex (mutual exclusion)" denilen mekanizmadır. Mutex 
    nesneleri pek çok işletim sisteminde benzer bir biçimde bulunmaktadır. Örneğin CRITICAL_SECTION nesnesi Windows sistemlerine özgü olduğu 
    halde mutex nesneleri hem Windows, hem UNIX/Linux hem de macOS sistemlerinde benzer biçimde bulunmaktadır. 

    Mutex nesnelerinin thread temelinde bir "sahipliği (ownership)" vardır. Bir mutex nesnesinin sahipliğini bir thread almış ise o thread 
    o mutex nesnesini kilitlemiştir. Başka bir thread mutex nesnesinin sahipliğine almaya çalışırsa diğer thread sahipliği bırakana kadar
    blokede bekler. Mutex nesnesinin sahipliğini nesnenin sahipliğin almış olan thread bırakabilmektedir. Eğer bir thread bir mutex nesnesinin
    sahipliğini almışken onu bırakmadan sonlanırsa böyle mutex nesnelerine "terkedilmiş mutex nesneleri (abondened mutexes)" denilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta mutex nesneleri hem aynı prosesin thread'leri arasında hem de farklı proseslerin thread'leri arasında senkronizasyon amacıyla
    kullanılabilmektedir. Windows sistemlerinde aynı prosesin thread'leri arasında kritik kod oluşturmak için CRITICAL_SECTION nesneleri mutex 
    nesnelerinden daha hızlı çalışmaktadır. 

    Windows'ta mutex nesneleri şöyle kullanılmaktadır:

    1) Önce mutex nesnesi CreateMutex isimli API fonksiyonuyla yaratılır. Tabii bu yaratım henüz thread'ler yaratılmadan önce yapılabilir. 
    CreateMutex fonksiyonun prototipi şöyledir:

    HANDLE CreateMutex(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        BOOL                  bInitialOwner,
        LPCTSTR               lpName
    );

    Fonksiyonun birinci parametresi mutex nesnesinin güvenlik bilgilerini belirlemek için kullanılmaktadır. Bu parametre NULL geçilebilir. 
    (Windows'ta mutex nesneleri birer kernel nesnesidir. Tüm kernel nesnelerinin SECURITY_ATTRIBUTES türünden bir güvenlik parametresi vardır.
    Bu konu oldukça karmaşık bir konu olduğu için "Windows Sistem Programlama" kursunda ele alınmaktadır.) Fonksiyonun ikinci parametresi TRUE 
    geçilirse mutex nesnesini yaratan thread aynı zamanda sahipliğinde alır (yani aynı zamanda mutex nesnesini kilitler.) Bu parametre tipik 
    olarak FALSE biçiminde geçilmektedir. Fonksiyonun son  parametresi mutex nesnesi farklı prosesler tarafından kullanılacaksa nesneyi temsil 
    eden ismi belirtmektedir. Bu isim programcı tarafından herhangi bir biçimde verilebilir. Eğer aynı prosesin thread'leri arasında senkronizasyon
    yapılacaksa bu parametre NULL geçilmelidir. Fonksiyon başarı durumunda yaratılan mutex nesnesinin handle değerine başarısızlık durumunda 
    NULL adrese geri dönmektedir. 
    
    Eğer aynı prosesin thread'leri arasında senkronizasyon yapılacaksa bu durumda CreateMutex fonksiyonundan elde edilen handle değeri global 
    bir değişkene atanmalıdır. Böylece bu global değişken farklı thread'lerden kullanılabilecektir. 
    
    Örneğin:

    HANDLE g_hMutex;
    ...

    if ((g_hMutex = CreateMutex(NULL, FALSE, NULL)) == NULL)
        ExitSys("CreateMutex");

    2) Kritik kod aşağıdaki gibi WaitForSingleObject (ya da WaitForMultipleObjects) ve ReleseMutex API fonksiyonları arasına yerleştirilmektedir.

    WaitForSingleObject(g_hMutex, INFINITE);
    ...
    ... KRİTİK KOD
    ...
    ReleaseMutex(g_hMutex);

    WaitForSingleObject fonksiyonunu daha önce görmüştük. Bu fonksiyon (ve WaitForMultipleObjects fonksiyonu) senkronizasyon nesnelerini 
    beklemek için kullanılan genel bir fonksiyondu. Eğer WaitForSingleObejct fonksiyonu ile bir mutex nesnesi bekleniyorsa fonksiyon nesnenin
    sahipliğini başka bir thread almamışsa nesnenin sahipliğini alarak kritik koda girişi sağlar. Eğer nesnenin sahipliği başka bir thread 
    tarafından alınmışsa WaitForSingleObject fonksiyonu nesnenin sahipliğini almış olan thread bu sahipliği bırakana kadar blokede beklemektedir. 
    Böylece aynı anda tek bir thread'in kritik koda girişine izin verilmektedir. Eğer nesnenin sahipliğini almış olan thread sahipliğini 
    bırakmadan sonlanırsa bu durumda WaitForSingleObject fonksiyonu "kilitlenme (deadlock)" oluşmasını engellemek için WAIT_ABANDONED özel değeri 
    ile geri dönmektedir. 
    
    ReleaseMutex fonksiyonu mutex nesnesinin sahipliğini bırakmak için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    BOOL ReleaseMutex(
        HANDLE hMutex
    );

    Fonksiyon mutex nesnesinin handle değerini parametre olarak alır ve nesnenin sahipliğini bırakır. Başarı durumunda sıfır dışı bir değere,
    başarısızlık durumunda sıfır değerine geri dönmektedir. 

    3) Mutex nesnesinin kullanımı bittikten sonra nesne CloseHandle fonksiyonu ile yok edilebilir. (Anımsanacağı gibi Windows'te ismine 
    "kernel nesneleri (kernel objects)" denilen tüm nesneler ortak biçimde CloseHandle fonksiyonuyla kapatılmaktadır. 

    Aşağıda Windows'ta mutex nesneleri ile kritik kod oluşturulmasına bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void UseMachine(LPCSTR pszName);
void ExitSys(LPCSTR lpszMsg);

HANDLE g_hMutex;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_hMutex = CreateMutex(NULL, FALSE, NULL)) == NULL)
        ExitSys("CreateMutex");

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    CloseHandle(g_hMutex);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 10; ++i)
        UseMachine("Therad-1");

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 10; ++i)
        UseMachine("Thread-2");

    return 0;
}

void UseMachine(LPCSTR pszName)
{
    WaitForSingleObject(g_hMutex, INFINITE);

    printf("-------------------\n");
    printf("%s: 1. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 2. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 3. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 4. Step\n", pszName);
    Sleep(rand() % 500);
    printf("%s: 5. Step\n", pszName);
    Sleep(rand() % 500);
    
    ReleaseMutex(g_hMutex);
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta mutex nesneleri farklı proseslerin thread'lerini senkronize etmek için de kullanılabilmektedir. Bunun için CreateMutex 
    fonksiyonunun üçüncü (son) parametresine mutex nesnesi için bir isim girilir. İki farklı proses CreateMutex fonksiyonunda mutex nesnlerine
    aynı isimleri verirse bu durumda iki farklı mutex yaratılmamakta aynı mutex nesnesi üzerinde çalışılmaktadır. Başka bir deyişle CreateMutex 
    fonksiyonu son parametresiyle belirtilen isimde daha önce bir mutex nesnesi yaratılmışsa yeni bir mutex nesnesi yaratmaz. Zaten yaratılmış olan
    mutex nesnesi açmış olur. Böylece iki proses de aynı isimle CreateMutex fonksiyonunu çağırdığında yalnızca bunlardan biri mutex nesnesini
    yaratacak diğer yaratılmış olan nesneyi açacaktır. Tabii mutex nesnesine verilen isme dikkat edilmelidir. Eğer sistemde o isimli bir mutex
    nesnesi zaten başkaları tarafından yaratılmışsa böyle bir yaratım yapılmayacaktır. 

    Pekiyi farklı proseslerin thread'lerinin senkronize edilmesi neden gerekebilir? İşte prosesler kendi aralarında "paylaşılan bellek alanlarıyla"
    ortak veriler üzerinde işlem yapıyor olabilirler. Bu durumda bu paylaşılan bellek alanındaki verilerin prosesler arası çalışan senkronizasyon
    nesneleriyle senkronize edilmesi gerekebilmektedir. 

    Windows sistemlerinde mutex nesneleri "özyinelemeli (recursive)" davranışa sahiptir. Bir mutex nesnesinin özyinelemeli olması demek mutex
    nesnesinin thread tarafından sahipliği alındığında aynı thread'in yeniden aynı mutex nesnesinin sahipliğini bloke olmadan alabilmesi demektir. 
    Örneğin:

    void foo(void)
    {
        ...
        WaitForSingleObject(g_hMutex, INFINITE);
        ...
        bar();
        ...
        ReleaseMutex(g_hMutex);
        ...
    }

    void bar(void)
    {
        ...
        WaitForSingleObject(g_hMutex, INFINITE);
        ...
        ...
        ...
        ReleaseMutex(g_hMutex);
        ...
    }
    
    Burada programcının foo fonksiyonunu çağırdığını varsayalım. foo fonksiyonu Mutex'in sahipliğini aldıktan sonra bar fonksiyonunu çağırdığında
    aynı thread aynı mutex'in sahipliğini ikinci kez almaktadır. İşte Windows'ta bu durumda bir sorun oluşmamaktadır. Ancak thread mutex'in 
    sahipliğini ne kadar almışsa ReleaseMutex ile o kadar bırakmalıdır. 

    Aşağıdaki örnekte iki proses paylaşılan bellek alanı oluşturup oradaki bir sayacı belli miktar artırmaktadır. Senkronizasyon yapılmaığı 
    durumda bu sayaç değeri yanlış çıkacaktır. Senkronizasyon yapıldığında sayacın artırılması seri hale getirildiği için sorun oluşmayacaktır. 

-------------------------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define SHARED_MEMORY_NAME        "MySharedMemory"
#define MUTEX_NAME                "MyMutexObject"

void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    HANDLE hFileMapping;
    HANDLE hMutex;
    long long *pCount;

    if ((hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, SHARED_MEMORY_NAME)) == NULL)
        ExitSys("CreateFileMapping");

    if ((pCount = (long long *) MapViewOfFile(hFileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 4096)) == NULL)
        ExitSys("MapViewOfFile");

    if ((hMutex = CreateMutex(NULL, FALSE, MUTEX_NAME)) == NULL)
        ExitSys("CreateMutex");

    for (long long i = 0; i < 10000000; ++i) {
        WaitForSingleObject(hMutex, INFINITE);
        ++*pCount;
        ReleaseMutex(hMutex);
    }

    printf("Press ENTER to continue...\n");
    getchar();

    printf("%lld\n", *pCount);

    UnmapViewOfFile(pCount);
    CloseHandle(hFileMapping);

    getchar();

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define SHARED_MEMORY_NAME        "MySharedMemory"
#define MUTEX_NAME                "MyMutexObject"

void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    HANDLE hFileMapping;
    HANDLE hMutex;
    long long *pCount;

    if ((hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, SHARED_MEMORY_NAME)) == NULL)
        ExitSys("CreateFileMapping");

    if ((pCount = (long long *)MapViewOfFile(hFileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 4096)) == NULL)
        ExitSys("MapViewOfFile");

    if ((hMutex = CreateMutex(NULL, FALSE, MUTEX_NAME)) == NULL)
        ExitSys("CreateMutex");

    for (long long i = 0; i < 10000000; ++i) {
        WaitForSingleObject(hMutex, INFINITE);
        ++*pCount;
        ReleaseMutex(hMutex);
    }
    UnmapViewOfFile(pCount);
    CloseHandle(hFileMapping);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi UNIX/Linux sistemlerinde Windows'taki gibi bir CRITICAL_SECTION nesnesi yoktur. Kritik kod oluşturmak için 
    mutex nesneleri kullanılmaktadır. UNIX/Linux sistemlerinde mutex nesneleri aynı prosesin thread'leri arasındaki senkronizasyon için 
    tasarlandığından dolayı Windows'taki mutex nesnelerine göre daha hızlıdır. Ancak istenirse biraz zor olsa da UNIX/Linux sistemlerindeki
    mutex nesneleri prosesler arasında da kullanılabilir. 

    UNIX/Linux sistemlerinde mutex nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Henüz thread'ler yaratılmadan pthread_mutex_init fonksiyonu ile mutex nesnesi yaraılır. Fonksiyonun prototiği şöyledir:

    #include <pthread.h>

    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

    Fonksiyonun birinci parametresi pthread_mutex_t türünden bir nesnenin adresini almaktadır. Fonksiyon bu nesneye bazı ilkdeğeri vermektedir. 
    Buna mutex nesnesi diyebiliriz. pthread_mutex_t bir yapı biçiminde typedef edilmiştir. Programcı aynı prosesin thread'leri arasında 
    senkronizasyon uygulamak için bu nesneyi global düzeyde ranımlamalıdır. Fonksiyonun ikinci parametresi yaparılacak mutex nesnesinin bazı
    özelliklerini belirlemek için kullanılmaktadır. Bu parametre NULL geçilebilir. Bu durumda mutex nesnesi default özelliklerle yaratılacaktır. 
    Biz bu kursta mutex nesnelerinin özellikleri üzerinde durmayacağız. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri dönmektedir. Örneğin:

    pthread_mutex_t g_mutex;
    ...
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    Mutex nesnelerine pthread_mutex_init yerine doğrudan PTHREAD_MUTEX_INITIALIZER makrosuyla da ilkdeğer verilebilmektedir. Örneğin:

    pthread_mutex_t g_mutex = PTHERAD_MUTEX_INIALIZER;
    
    2) Kritik kod pthread_muutex_lock ve pthread_mutex_unlock çağrıları arasında yerleştirilir:

    pthread_mutex_lock(&g_mutex);
    ...
    ... KRİTİK KOD
    ...
    pthread_mutex_unlock(&g_mutex);

    Bir thread pthread_mutex_lock fonksiyonuna girdiğinde eğer mutex'in sahipliği başka bir thread tarafından alınmışsa o thread sahipliği 
    bırakana kadar fonksiyon blokede bekler. Eğer mutex nesnesinin sahipli alınmamışsa pthread_mutex_lock nensnenin sahipliğini alarak 
    kritik koda giriş yapar. Nesnenin sahipliği pthread_mutex_unlock fnksiyonuyla bırakılmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);

    Fonksiyonlar mutex nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri 
    dönerler. 

    3) Mutex ile çalışma bittikten sonra mutex nesnesi pthread_mutex_destroy fonksiyonuyla yok edilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_destroy(pthread_mutex_t *mutex);

    Fonksiyon mutex nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri döner. 
    Aslında pek çok kütüphanede bu fonksiyon bir şey yapmamaktadır. Ancak başka gerçekleştirimlerde bu fonksiyon birtakım kaynakları boşaltıyor
    olabilir. 

    Aşağıda UNIX/Linux sistemlerinde mutex kullanımına bir örnek verilmiştir. Yine örnekte global bir sayaç değişkeni alınmıştır. İki thread 
    de bu sayacı artırmaktadır. Ancak artırım sırasında mutex koruması uygulanmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;
int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_muex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);
        ++g_count;
        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);
        ++g_count;
        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha önce yapmış olduğumuz makine örneğininin UNIX/Linux sistemleriyle mutex nesneleriyle gerçekleştirimini veriyoruz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);
void use_machine(const char *name);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    srand(time(NULL));

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void use_machine(const char *name)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("-------------------\n");
    printf("%s: 1. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 2. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 3. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 4. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 5. Step\n", name);
    usleep(rand() % 300000);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 10; ++i) 
        use_machine("Thread-1");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 10; ++i) 
        use_machine("Thread-2");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde mutex nesneleri default durumda özyinelemeli değildir. Bu sistemlerde mutex nesnelerin özyinelemeli yapmak için
    önce pthread_mutexattr_t türünden bir nesne oluşturulur. Sonra bu nesne pthread_mutexattr_init fonksiyonuyla ilkdeğerlenir. Sonra da 
    pthread_mutexattr_settype fonksiyonu ile PTHREAD_MUTEX_RECURSIVE parametresi kullanılarak mutex özelliği özyinelemeli olarak set edilir.
    Nihayet bu attribute nesnesi pthread_mutex_create fonksiyonunda kullanılır. Sonunda da bu attribute nesnesi pthread_mutexattr_destroy 
    fonksiyonuyla yok edilir.Buradaki fonksiyonların prototipleri şöyledir:

    #include <pthread.h>
    
    int pthread_mutexattr_init(pthread_mutexattr_t *attr);
    int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
    
    Bu fonksiyonların birinci parametreleri mutex attribute nesnesinin adresini almaktadır. Fonksiyonlar başarı durumunda sıfır değerine 
    başarısızlık durumunda errno değerine geri dönmektedir. 
    
    Örneğin:

    pthread_mutex_t g_mutex;
    ...
    pthread_mutexattr_t mattr;
    ...

    if ((result = pthread_mutexattr_init(&mattr))  != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE)) != 0)
        exit_sys_errno("pthread_mutexattr_settype", result);

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);
    
    Mutex attribute nesnesinin yalnızca mutex nesnesinin yaratılması sırasında kullanıldığına dikkat ediniz. 

    Tabii UNIX/Linux sistemlerinde de özyinelemeli mutex'lerin kilidini açmak için pthread_mutex_lock işlemi kadar pthread_mutex_unlock
    işleminin yapılması gerekmektedir. 

    Aşağıda buna yönelik bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);
void do_machine(const char *name);
void use_machine(const char *name);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    pthread_mutexattr_t mattr;

    srand(time(NULL));

    if ((result = pthread_mutexattr_init(&mattr))  != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE)) != 0)
        exit_sys_errno("pthread_mutexattr_settype", result);

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void do_machine(const char *name)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);
    
    use_machine(name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
}

void use_machine(const char *name)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);
    
    printf("-------------------\n");
    printf("%s: 1. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 2. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 3. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 4. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 5. Step\n", name);
    usleep(rand() % 300000);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 10; ++i) 
        do_machine("Thread-1");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 10; ++i) 
        do_machine("Thread-2");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde mutex nesnesini prosesler arasında kullanabilmek için mutex nesnesinin  paylaşılan bellek alanında yaratılması 
    gerekir. (Yani bizim pthread_mutex_t türünden nesnseyi paylaşılan bellek alanında yaratmamız gerekir.) Böylece iki proses de aynı mutex
    nesnesini görecektir. Ancak ayrıca mutex'in prosesler arası kullanımını mümkün hale getirmek için mutex attribute nesnesinde 
    pthread_mutexattr_setpshared fonksiyonu ile belirleme yapmak gerekir. Bu fonksiyonun prototipi şöyledir:

    int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 

    Fonksiyonun birinci parametresi mutex attribute nesnesinin adresini almaktadır. İkinci parametre için PTHREAD_PROCESS_SHARED değeri 
    proseslerarası paylaşım yapılabileceğini, PTHREAD_PROCESS_PRIVATE değeri ise proseslerarası paylaşım yapılamayacağını belirtmektedir. 
    Fonksiyon başarı durumunda sıfır değerine başarısızlık durumunda errno değerine geri dönmektedir. 
    
    Aşağıdaki örnekte prog1 programı önce paylaşılan bellek alanını ve mutex nesnesini oluşturmuştur. prog2 ise paylaşılan bellek alanındaki 
    mutex nesnesini kullanmıştır. Paylaşılan bellek alanının başı aşağıdaki gibi bir yapı ile temsilk edilmiştir:

    struct SHARED_OBJECT {
        pthread_mutex_t mutex;
        long long count;
    };

    Aşağıdaki örnekte önce prog1 programını çalıştırmalısınız. Çünkü bu örnekte paylaşılan bellek alanını ve mutex nesnesini prog1 programı 
    yaratmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <pthread.h>

void exit_sys(const char* msg);
void exit_sys_errno(const char *msg, int eno);

struct SHARED_OBJECT {
    pthread_mutex_t mutex;
    long long count;
};

int main(void)
{
    int fdshm;
    int result;
    void *shmaddr;
    pthread_mutexattr_t mattr;
    struct SHARED_OBJECT *so;

    if ((fdshm = shm_open("/sample_shared_memory_name", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, 4096) == -1)
        exit_sys("ftruncate");
    
    if ((shmaddr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED)
        exit_sys("mmap");

    so = (struct SHARED_OBJECT*)shmaddr;
    so->count = 0;

    if ((result = pthread_mutexattr_init(&mattr))  != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_mutexattr_setpshared", result);

    if ((result = pthread_mutex_init(&so->mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    for (long long int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&so->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        ++so->count;

        if ((result = pthread_mutex_unlock(&so->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 
    }
   
    printf("Press ENTER to continue...\n");
    getchar();

    printf("%lld\n", so->count);

    if ((result = pthread_mutex_destroy(&so->mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    if (munmap(shmaddr, 4096) == -1)
        exit_sys("munmap");

    close(fdshm);

    if (shm_unlink("/sample_shared_memory_name") == -1)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <pthread.h>

void exit_sys(const char* msg);
void exit_sys_errno(const char *msg, int eno);

struct SHARED_OBJECT {
    pthread_mutex_t mutex;
    long long int count;
};

int main(void)
{
    int fdshm;
    int result;
    void *shmaddr;
    struct SHARED_OBJECT *so;
    
    if ((fdshm = shm_open("/sample_shared_memory_name", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
        exit_sys("shm_open");

    if ((shmaddr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED)
        exit_sys("mmap");

    so = (struct SHARED_OBJECT*)shmaddr;
    
    for (long long int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&so->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        ++so->count;

        if ((result = pthread_mutex_unlock(&so->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result);
    }
    
    if (munmap(shmaddr, 4096) == -1)
        exit_sys("munmap");

    close(fdshm);

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    83.  Ders 27/04/2024  - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Diğer çok kullanılan bir senkronizasyon nesneleri de "semaphore" denilen nesnelerdir. (Semaphore trafikteki dur-geç lambalarına denilmektedir.
    eskiden trafik ışıkları yokken onun yerine insanların manuel idare ettiği bayraklar kullanılıyormuş.) Semapore'lar sayaçlı senkronizasyon 
    nesneleridir. Bir kritk koda en fazla N tane thread'in (akışın) girmesini sağlamak için kullanılmaktadır. Daha önce görmüş olduğumuz mutex 
    nesneleri ve Windows'taki CRITCAL_SECTION nesneleri kritik koda yalnızca tek bir akışın girmesini sağlamaktadır. Semaphore'lar bilgisayar 
    bilimlerinin öncülerinden Edsger Dijkstra ("edsger daystra" gibi okunuyor) tarafından bulunmuştur. 

    Bir kritik koda birden fazla akışın girmesinin anlamı nedir? Normalde kritik koda giren iki akış bile ortak kullanılan kaynakları bozabilir. 
    İşte semaphore'lar özellikle "kaynak paylaşımını sağlamak" için kullanılmaktadır. Örneğin elimizde 3 makine olsun. Biz de bu 3 makineyi 10 
    thread'e paylaştırmak isteyelim. Yani thread'ler makineyi talep etsin, eğer bir makine boştaysa o makine ilgili thread'e atansın. Ancak tüm 
    makineler doluysa makine talep eden thread makinelerden biri boşaltılana kadar CPU zamanı harcamadan blokede beklesin. İşte bu tür problemler 
    tipik olarak semaphore nesneleriyle çözülmektedir. 

    Semaphore nesnelerinin bir sayacı vardır. Kritik koda her giren thread eğer sayaç 0'dan büyükse sayacı 1 eksiltir. Eğer sayaç 0 ise blokede
    sayacın 0'dan büyük olmasını bekler. Örneğin başlangıçtaki semaphore sayacı 3 olsun. Bir thread kritik koda girdiğinde semaphore sayacı 2 
    olacaktır. Diğer bir thread kritik koda girdiğinde semaphore sayacı 1 olacaktır. Diğer bir thread kritik koda girdiğinde ise semaphore sayacı 
    0 olacaktır. Artık gelen thread'ler kritik koda giremeyip blokede bekleyecektir. Artık kritik kodun içerisinde 3 tane thread vardır. Şimdi 
    bir thread kritik koddan çıkıyor olsun. Thread kritik koddan çıkarken semaphore sayacı 1 artırılır. Böylece semaphore sayacı 1 olur. Kritik 
    kodda şu anda 2 thread vardır. İşte semaphore sayacı artık 0'dan büyük olduğu için bekleyen thread'lerden biri de kritik koda girgirer. 
    Böylece semaphore sayacı yeniden 0 olur. Şimdi kritik kod içerisinde yine 3 thread vardır. Başlangıçtaki semaphore sayacı kaç ise kritik 
    kodun içerisinde "en fazla" o kadar thread bulunacaktır.

    Bşlangıçtaki semaphore sayacı 1 ise kritik koda en fazla 1 thread girebilir. Bu tür semaphore'lara "ikili semaphore'lar (binary semaphores)"
    denilmektedir. İkili semaphore'lar mutex nesnelerine benzese de onlardan önemli bir farklılığa sahiptir. Mutex nesnelerinin sahipliğini 
    (yani kilidini) ancak sahipliğini almış olan thread bırakabilir. Ancak semaphore sayaçları başka thread'ler tarafından artırılabilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde semaphore nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Önce semaphore nesnesi CreateSemaphore API fonksiyonuyla yaratılır. CreateSemaphore API fonksiyonunun prototipi şöyledir:

    HANDLE CreateSemaphore(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG    lInitialCount,
        LONG    lMaximumCount,
        LPCSTR    lpName
    );

    Fonksiyonun birinci parametresi semaphore nesnesinin güvenlik bilgilerini belirtir. Bu parametre NULL adres geçilebilir. İkinci parametre 
    semaphore sayacının başlangıçtaki sayaç değerini belirtir. Üçüncü parametre semaphore sayacının erişebileceği maksimum sayaç değeridir. 
    Genellikle ikinci ve üçüncü parametreye aynı değer girilmektedir. Son parametre semaphore nesnesinin proseslerarası kullanımdaki ismini
    belirtmektedir. Eğer semaphore nesnesi aynı prosesin thread'leri arasında kullanılacaksa bu parametreye NULL adres geçilebilir. Fonksiyon 
    başarı durumunda semaphore nesnesinin handle değerine başarısızlık durumunda NULL adrese geri dönmektedir. 

    Semaphore nesnesi aynı prosesin thread'leri arasında kullanılacaksa CreateSemaphore fonksiyonunun geri dönüş değeri (yani nesnenin handle değeri) 
    global bir değişkende tutulmalıdır. Örneğin:

    HANDLE g_hSemaphore;
    ...

    if ((g_hSemaphore = CreateSemaphore(NULL, 1, 1, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    2) Kritik kod aşağıdaki gibi oluşturulmaktadır:

    WaitForSingleObject(g_hSemaphore, INFINITE);
    ...
    ... KRİTİK KOD
    ...
    ReleaseSemaphore(g_hSemahore, 1, NULL);

    Burada akış WaitForSingleObject fonksiyonuna geldiğinde eğer semaphore sayacı 0'dan büyükse bloke olunmadan kritik koda girilir. Ancak 
    semaphore sayacı atomik bir biçimde 1 eksiltilir. Eğer semaphore sayacı 0 ise WaitForSingleObject bloke oluşturarak thread'i bekletir. 
    ReleaseSemaphore fonksiyonu semaphore sayacını ikinci parametresinde belirtilen miktar kadar (genellikle 1) artırmaktadır. 
    ReleaseSemaphore fonksiyonun prototipi şöyledir:

    BOOL ReleaseSemaphore(
        HANDLE hSemaphore,
        LONG   lReleaseCount,
        LPLONG lpPreviousCount
    );

    Fonksiyonun birinci parametresi semaphore nesnesinin handle değerini almaktadır. İkinci parametre artırım değerini belirtmektedir. (Bu
    değer hemen her zaman 1 olur) son parametre semaphore sayacının önceki değerinin yerleştirileceği nesnenin adresini almaktadır. Bu parametre
    NULL adres biçiminde geçilirse önceki sayaç değeri yerleştirilmez. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda sıfır dışı 
    bir değere geri dönmektedir. Örneğin:

    for (int i = 0; i < 1000000; ++i) {
        WaitForSingleObject(g_hSemaphore, INFINITE);
        ...
        ...
        ...
        ReleaseSemaphore(g_hSemaphore, 1, NULL);
    }

    3) Semaphore kullanımı bittiğinde semaphore nesnesi diğer kernel nesnelerinde oluduğu gibi CloseHandle fonksiyonu ile yok edilmelidir. 
    Örneğin:

    CloseHandle(g_hSemaphore);

    Aşağıdaki daha önce yaptığımız mutex örneği semaphore nesneleriyle gerçekleştirilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

HANDLE g_hSemaphore;
int g_count;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_hSemaphore = CreateSemaphore(NULL, 1, 1, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(g_hSemaphore);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    printf("%d\n", g_count);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    for (int i = 0; i < 1000000; ++i) {
        WaitForSingleObject(g_hSemaphore, INFINITE);
        ++g_count;
        ReleaseSemaphore(g_hSemaphore, 1, NULL);
    }

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    for (int i = 0; i < 1000000; ++i) {
        WaitForSingleObject(g_hSemaphore, INFINITE);
        ++g_count;
        ReleaseSemaphore(g_hSemaphore, 1, NULL);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde tıpkı paylaşılan bellek alanlarında olduğu gibi semaphore'lar için de iki ayrı arayüz fonksiyon grubu bulunmaktadır. 
    Eskiden beri var olan klasik semaphore fonksiyonlarına "Sistem 5 semaphore'ları" denilmektedir. Bu semaphore fonksiyonlarının kullanımı 
    oldukça zordur. 90'lı yılların ortalarında UNIX/Linux sistemlerinde "POSIX semaphore'ları" da denilen modern semaphore fonksiyonları 
    eklenmiştir. Artık programcılar genellikle bu POSIX semaphore fonksiyonlarını tercih etmektedir. Tabii her iki fonksiyon grubu da aslında 
    POSIX standartlarında yer almaktadır. Ancak "POSIX semaphore fonksiyonları" denildiğinde daha sonra tasarlanmış olan modern semaphore 
    fonksiyonları kastedilmektedir. Klasik Sistem 5 semaphore'ları proseslerarası kullanım için tasarlanmıştır. Halbuki modern POSIX semaphore'ları 
    hem aynı prosesin thread'leri arasında hem de farklı proseslerin thread'leri arasında kullanılabilmektedir. 

    Biz kursumuzda modern POSIX semaphore fonksiyonlarını göreceğiz. Eski tipi "Sistem 5 Semaphore" fonksiyonları "UNIX/Linux Sistem Programlama" 
    kurslarında ele alınmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    POSIX semaphore fonksiyonları aşağıdaki adımlardan geçilerek kullanılmaktadır:

    1) POSIX semapore nesneleri sem_t türüyle temsil edilmektedir. sem_t bir yapıyı belirten typedef ismidir. Eğer semaphore nesnesi aynı 
    prosesin thread'leri arasında kullanılacaksa sem_t türünden global bir nesne tanımlanır ve bu nesneye sem_init fonksiyonu ile ilkdeğerleri 
    verilir. sem_init fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_init(sem_t *sem, int pshared, unsigned int value);

    Fonksiyonun birinci parametresi sem_t türünden nesnenin adresini almaktadır. Fonksiyonun ikinci parametresi bu nesnenin prosesler arasında
    paylaşılıp paylaşılmayacağını belirtmektedir. Eğer nesne prosesler arasında paylaşılacaksa bu parametreye sıfır dışı bir değer, paylaşılmayacaksa
    sıfır değeri geçilmelidir. Ancak zaten proseslerarası kullanım için başka bir fonksiyon bulunduğundan genellikle bu parametre sıfır geçilir. 
    Fonlsiyonun üçüncü parametresi semaphore sayacının başlangıç değerini belirtmektedir. Yani bu değer kritik koda en fazla kaç akışın gireceğini
    belirtir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri dönmektedir. Fonksiyon errno değerini set etmektedir. 
    (Diğer thread fonksiyonlarının errno değerini set etmediğini bizzat errno değerine geri döndüğünü anımsayınız.)

    Eğer semaphore nesnesi prosesler arasında kullanılacaksa bu durumda sem_t nesnesi sem_open fonksiyonu ile elde edilmelidir. Bu fonksiyon 
    üzerinde daha sonra durulacaktır. 

    2) Kritik kod sem_wait ve sem_post çağrıları arasına yerleştirilir:

    sem_wait(&g_sem);
    ...
    ... <KRİTİK KOD>
    ...
    sem_post(&g_sem);

    Akış sem_wait fonksiyonuna geldiğinde eğer semaphore sayacı 0 ise sem_wait blokeye yol açar ve semaphore sayacı 0'dan büyük olana kadar 
    bekler. Eğer semaphore sayacı 0'dan büyükse akış sem_wait fonksiyonundan geçer ancak semaphore sayacı 1 eksiltilir. sem_post fonksiyonu 
    semaphore sayacını 1 artırmaktadır. Bu fonksiyonların prototipleri şöyledir:

    #include <semaphore.h>

    int sem_wait(sem_t *sem);
    int sem_post(sem_t *sem);
    
    Fonksiyonlar semaphore nesnelerinin adresini parametre olarak almakta, başarı durumunda sıfır değerine başarısızlık durumunda -1 değerine 
    geri dönmektedirler. Yine başarısızlık durumunda errno değişkeni set edilmektedir. 

    3) Semaphore nesnesinin kullanımı bittikten sonra nesne sem_destroy fonksiyonu ile yok edilmelidir. Fonksiyonun prototipi şöyledir:

    #include <semaphore.h>

    int sem_destroy(sem_t *sem);

    Fonksiyon semaphore nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner.
    Başarısızlık durumunda errno değişkeni set edilmektedir. Eğer semaphore nesnesi proseslerarası kullanım için sem_open fonksiyonuyla 
    yaratılmışsa nesnenin yok edilmesi sem_close fonksiyonu ile yapılmalıdır. 

    Aşağıda daha önce yapmış olduğumuz global değişkeninin iki thread tarafından artırılması binary POSIX semaphore'larıyla sağlanmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys(const char* msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem;
int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if (sem_init(&g_sem, 0, 1) == -1)
        exit_sys("sem_init");
        
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem) == -1)
        exit_sys("sem_destroy");

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");
        
        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_post");
    }

    return NULL;
}

void *thread_proc2(void *param) 
{
     for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");
        
        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_post");
    }

    return NULL;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha önce yapmış olduğumuz makine konumlandırma örneği POSIX semaphore nesneleriyle gerçekleştirilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

void *thread_proc1(void* param);
void *thread_proc2(void* param);
void do_machine(const char* name);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem;

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    srand(time(NULL));

    if (sem_init(&g_sem, 0, 1) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    sem_destroy(&g_sem);

    return 0;
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 10; ++i)
        do_machine("thread-1");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 10; ++i)
        do_machine("thread-2");

    return NULL;
}

void do_machine(const char *name)
{
    if (sem_wait(&g_sem) == -1)
        exit_sys("sem_wait");

    printf("---------------\n");
    printf("1) %s\n", name);
    usleep(rand() % 300000);
    printf("2) %s\n", name);
    usleep(rand() % 300000);
    printf("3) %s\n", name);
    usleep(rand() % 300000);
    printf("4) %s\n", name);
    usleep(rand() % 300000);
    printf("5) %s\n", name);
    usleep(rand() % 300000);

    if (sem_post(&g_sem) == -1)
        exit_sys("sem_post");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici Problemi (Producer-Consumer Problem) gerçek hayatta en sık karşılaşılan senkronizasyon problemlerinden biridir. Bu problemde
    thread'lerden biri (üretici thread) bir döngü içerisinde bir değer üretir ve onu paylaşılan bellek alanına yerleştirir. Diğer thread de 
    (tüketici thread) bir döngü içerisinde onu oradan alıp kullanır. Burada şöyle bir sorun vardır: Üretici thread henüz tüketici thread eski 
    değeri almdan paylaşılan alana yeni değeri yerleştirirse eski değer ezilir. Benzer biçimde tüketici thread de üretici thread paylaşılan alana 
    yeni bir değer koymadan paylaşılan alandan değeri alırsa eski değeri yeniden almış olur. O halde iki thread'in bu işi düzgün yapabilmesi için 
    uygun biçimde senkronize edilmesi gerekmektedir. Öyle ki üretici thread tüketici thread eski değeri almadan paylaşılan alana yeni değeri 
    yerleştirmemeli, tüketici thread de üretici thread paylaşılan alana yeni bir değer yerleştirmeden eski değeri yeniden almamalıdır. 

    Üretici-Tüketici probleminde aslında üretici thread'ler ve tüketici thread'ler birden fazla olabilmektedir. Örneğin üç thread üretici iki 
    thread tüketici olabilir. Ancak problemin en basit halinde tek üretici ve tek tüketici vardır. 

    Pekiyi üretici-tüketici probleminde neden üretici thread elde ettiği değeri kendisi işlemiyor da onu tüketici thread'e pas edip onun 
    işlemesini sağlıyor? İşte bunun en açık nedeni hız kazancı sağlamaktır. Tek bir thread bu işi yaptığında önce değeri elde edip işleyecek
    ve sonra yeni değeri elde edip işleyecektir. Ancak thread'lerden biri değeri elde ederken diğeri onu işlerse işlemler toplamda daha hızlı
    yürütülmüş olur. 

    Üretici-Tüketici probleminde paylaşılan alan tek bir değeri içerecek biçimde olmayabilir. Bu alan bir kuyruk sistemi biçiminde de olabilir. 
    Böylece üretici ve tüketici birbirlerini daha az bekler. Uygulamada genellikle paylaşılan alan bir kuyruk sistemi biçiminde olarak organize 
    edilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici problemleri tipik olarak semaphore nesneleriyle çözülmektedir. Problemin çözümü için iki semaphore nesnesi yatatılır. 
    Semaphore'lardan biri üretici semaphore'u diğeri ise tüketici semaphore'u olur. Başlangıçta üretici semaphore'u 1'e tüketici semaphore'u 
    ise 0'a kurulur:

    sem_t g_sem_producer;
    sem_t g_sem_consumer;
    ...

    sem_init(&g_sem_producer, 0, 1);
    sem_init(&g_sem_consumer, 0, 0);

    Üretici ve tüketici döngülerinin temsili biçimi şöyledir:

    ÜRETİCİ
    -------

    for (;;) {
        <değeri elde ediliyor>
        sem_wait(&g_sem_producer);
        <değer paylaşılan alana yerleştiriliyor>
        sem_post(&g_sem_consumer);
        
    }

    TÜKETİCİ
    --------

    for (;;) {
        sem_wait(&g_sem_consumer);
        <değer paylaşılan alandan alınıyor>
        sem_post(&g_sem_producer);
        <değer kullanılıyor>
    }

    Burada üretici semaphore'unun başlangıçtaki sayaç değeri 1 olduğu için üretici sem_wait fonksiyonundan geçip elde ettiği değeri paylaşılan
    alana bırakacaktır. Bu sırada tüketici semaphore'unun başlangıç değeri 0 olduğu için tüketici sem_wait fonksiyonunda bekleyecektir. 
    Üretici thread'in tüketicinin semaphore sayacını, tüketici thread'in ise üreticinin semaphore sayacını 1 artırdığına dikkat ediniz. 
    Böylece üretici tüketiciyi tüketici de üreticiyi sem_wait fonksiyonundan geçirmektedir. Bunu tbir tahteravalliye benzetebilirsiniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aaşğıda uNIX/Linux sistemlerinde üretici-tüketici probleminin POSIX semaphore nesneleriyle çözümüne bir örnek verilmiştir. Bu örnekte 
    üretici thread 0'dan 100'a kadar sayıları rastgele beklemelerle paylaşılan alana yerleştirmekte tüketici thread de bunları rastgele 
    beklemelerle almaktadır. Örneği senkronizasyonu kaldırarak çalıştırıp nasıl bir durum oluştuğunu gözleyiniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

void *thread_proc_producer(void* param);
void *thread_proc_consumer(void* param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem_producer;
sem_t g_sem_consumer;

int g_shared;

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    srand(time(NULL));

    if (sem_init(&g_sem_producer, 0, 1) == -1)
        exit_sys("sem_init");

    if (sem_init(&g_sem_consumer, 0, 0) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_proc_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    sem_destroy(&g_sem_producer);
    sem_destroy(&g_sem_consumer);

    return 0;
}

void *thread_proc_producer(void *param)
{
    int val;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);
        
        if (sem_wait(&g_sem_producer) == -1)
            exit_sys("sem_wait");
        g_shared = val;
        if (sem_post(&g_sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_proc_consumer(void *param)
{
    int val;

    for (;;) {
        if (sem_wait(&g_sem_consumer) == -1)
            exit_sys("sem_wait");
        val = g_shared;
        if (sem_post(&g_sem_producer) == -1)
            exit_sys("sem_post");

        printf("%d ", val);
        fflush(stdout);
        usleep(rand() % 300000);
        if (val == 99)
            break;

    }
    putchar('\n');

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde üretici-tüketici probleminin semaphore nesneleriyle çözümüne ilişkin bir örnek aşağıda verilmiştir. Bu örnek yukarıda
    verdiğimiz UNIX/Linux örneğinin Windows eşdeğeri gibidir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProducer(LPVOID lpvParam);
DWORD __stdcall ThreadConsumer(LPVOID lpvParam);

HANDLE g_hSemProducer;
HANDLE g_hSemConsumer;

int g_shared;

int main(void)
{
    HANDLE hThreadProducer, hThreadConsumer;
    DWORD dwThreadIDProducer, dwThreadIDConsumer;

    srand(time(NULL));

    if ((g_hSemProducer = CreateSemaphore(NULL, 1, 1, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    if ((g_hSemConsumer = CreateSemaphore(NULL, 0, 1, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    if ((hThreadProducer = CreateThread(NULL, 0, ThreadProducer, NULL, 0, &dwThreadIDProducer)) == NULL)
        ExitSys("CreateThread");

    if ((hThreadConsumer = CreateThread(NULL, 0, ThreadConsumer, NULL, 0, &dwThreadIDConsumer)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThreadProducer, INFINITE);
    WaitForSingleObject(hThreadConsumer, INFINITE);

    CloseHandle(hThreadProducer);
    CloseHandle(hThreadConsumer);

    CloseHandle(g_hSemProducer);
    CloseHandle(g_hSemConsumer);

    return 0;
}

DWORD __stdcall ThreadProducer(LPVOID lpvParam)
{
    int val;

    val = 0;
    for (;;) {
        Sleep(rand() % 300);

        WaitForSingleObject(g_hSemProducer, INFINITE);
        g_shared = val;
        ReleaseSemaphore(g_hSemConsumer, 1, NULL);
        
        if (val == 99)
            break;
        ++val;
    }
    
    return 0;
}

DWORD __stdcall ThreadConsumer(LPVOID lpvParam)
{
    int val;

    for (;;) {
        WaitForSingleObject(g_hSemConsumer, INFINITE);
        val = g_shared;
        ReleaseSemaphore(g_hSemProducer, 1, NULL);

        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
        Sleep(rand() % 300);
    }
    putchar('\n');

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğmiz gibi üretici-tüketici probleminde paylaşılan alan bir kuyruk sistemi olursa üretici ve tüketicinin birbirlerini
    bekleme olasılıkları azaltılmış olur. Çünkü bu durumda üretici yalnızca "kuyruk tamamen doluyken", tüketici ise yalnızca "kuyruk tamamen 
    boşken" bekleyecektir. 

    Üretici-Tüketici probleminin kuyruklu versiyonunda üretici semaphore sayacının başlangıçta kuyruk uzunluğuna kurulması gerekmektedir. 
    (Yani tüketici hiç çalışmasa üretici tüm kuyruğu doldurup bekleyecektir.)

    Aşağıda UNIX/Linux sistemlerinde üretici-tüketici probleminin kuyruklu versiyonuna bir örnek verilmiştir. Burada kuyruğun eşzamanlı 
    erişimler için senkronize edilmesine gerek yoktur. Çünkü aslında işleyiş dikkatle incelendiğinde iki thread'in aynı nesnelere eş zamanlı
    erişmediği görülecektir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

#define QUEUE_BUFFER_SIZE       10

void *thread_proc_producer(void* param);
void *thread_proc_consumer(void* param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem_producer;
sem_t g_sem_consumer;

int g_qbuf[QUEUE_BUFFER_SIZE];
int g_head;
int g_tail;

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    srand(time(NULL));

    if (sem_init(&g_sem_producer, 0, QUEUE_BUFFER_SIZE) == -1)
        exit_sys("sem_init");

    if (sem_init(&g_sem_consumer, 0, 0) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_proc_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    sem_destroy(&g_sem_producer);
    sem_destroy(&g_sem_consumer);

    return 0;
}

void *thread_proc_producer(void *param)
{
    int val;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);
        
        if (sem_wait(&g_sem_producer) == -1)
            exit_sys("sem_wait");
        
        g_qbuf[g_tail++] = val;
        g_tail = g_tail % QUEUE_BUFFER_SIZE;        /* burası kritik kodun dışına alınabilir */

        if (sem_post(&g_sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_proc_consumer(void *param)
{
    int val;

    for (;;) {
        if (sem_wait(&g_sem_consumer) == -1)
            exit_sys("sem_wait");
        
        val = g_qbuf[g_head++];
        g_head = g_head % QUEUE_BUFFER_SIZE;    /* burası kritik kodun dışına alınabilir */

        if (sem_post(&g_sem_producer) == -1)
            exit_sys("sem_post");

        printf("%d ", val);
        fflush(stdout);
        usleep(rand() % 300000);
        if (val == 99)
            break;

    }
    putchar('\n');

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda Windows sistemlerinde üretici-tüketici probleminin kuyruklu versiyonuna bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

#define QUEUE_BUFFER_SIZE        10

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProducer(LPVOID lpvParam);
DWORD __stdcall ThreadConsumer(LPVOID lpvParam);

HANDLE g_hSemProducer;
HANDLE g_hSemConsumer;

int g_queueBuf[QUEUE_BUFFER_SIZE];
size_t g_head;
size_t g_tail;

int main(void)
{
    HANDLE hThreadProducer, hThreadConsumer;
    DWORD dwThreadIDProducer, dwThreadIDConsumer;

    srand(time(NULL));

    if ((g_hSemProducer = CreateSemaphore(NULL, QUEUE_BUFFER_SIZE, QUEUE_BUFFER_SIZE, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    if ((g_hSemConsumer = CreateSemaphore(NULL, 0, QUEUE_BUFFER_SIZE, NULL)) == NULL)
        ExitSys("CreateSemaphore");

    if ((hThreadProducer = CreateThread(NULL, 0, ThreadProducer, NULL, 0, &dwThreadIDProducer)) == NULL)
        ExitSys("CreateThread");

    if ((hThreadConsumer = CreateThread(NULL, 0, ThreadConsumer, NULL, 0, &dwThreadIDConsumer)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThreadProducer, INFINITE);
    WaitForSingleObject(hThreadConsumer, INFINITE);

    CloseHandle(hThreadProducer);
    CloseHandle(hThreadConsumer);

    CloseHandle(g_hSemProducer);
    CloseHandle(g_hSemConsumer);

    return 0;
}

DWORD __stdcall ThreadProducer(LPVOID lpvParam)
{
    int val;

    val = 0;
    for (;;) {
        Sleep(rand() % 300);

        WaitForSingleObject(g_hSemProducer, INFINITE);
        
        g_queueBuf[g_tail++] = val;
        g_tail = g_tail % QUEUE_BUFFER_SIZE;

        ReleaseSemaphore(g_hSemConsumer, 1, NULL);
        
        if (val == 99)
            break;
        ++val;
    }
    
    return 0;
}

DWORD __stdcall ThreadConsumer(LPVOID lpvParam)
{
    int val;

    for (;;) {
        WaitForSingleObject(g_hSemConsumer, INFINITE);

        val = g_queueBuf[g_head++];
        g_head = g_head % QUEUE_BUFFER_SIZE;
        
        ReleaseSemaphore(g_hSemProducer, 1, NULL);

        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
        Sleep(rand() % 300);
    }
    putchar('\n');

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    84.  Ders 28/04/2024  - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Konunun başında da belirttiğimiz gibi UNIX/Linux sistemlerinde semaphore nesneleri isim verilerek de prosesler arasında kullanılabilmektedir. 
    Bunun için sem_open fonksiyonu ile iki prosesin de ortak bir isimde anlaşarak semaphore nesnesini açması gerekmektedir. sem_open fonksiyonunun
    prototipi şöyledir:

    #include <semaphore.h>

    sem_t *sem_open(const char *name, int oflag, ...);

    Fonksiyon ya iki parametreyle ya da dört parametreyle kullanılmaktadır. Eğer fonksiyon dört parametreyle kullanılacaksa parametrik yapı
    aşağıdaki gibi olmalıdır:

    sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);

    Fonksiyonun birinci parametresi prosesler arasında paylaşımı sağlamak için belirlenen ismi belirtmektedir. POSIX standartlarına göre bu 
    ismin "kök dizindeki bir dosya ismi gibi" oluşturulması gerekmektedir. (Burada bir dosya yaratılmamaktadır. Kök dizindeki dosya yalnızca 
    bir temsildir.) Fonksiyonun ikinci parametresi yaratım bayraklarını belirtmektedir. Bu ikinci parametre üç değerden biri olarak geçilmelidir:

    O_CREAT
    O_CREAT|O_EXCL
    0

    O_CREAT bayrağı yine "nesne yaratılmamışsa yarat, nesne yaratılmışsa yaratılanı kullan" anlamına gelmektedir. O_CREAT ile O_EXCL birlikte 
    kullanılırsa bu durumda "nesne zaten yaratılmış ise" fonksiyon baaşarısız olmaktadır. Bu parametreye 0 değeri geçilirse "yaratılmış olan
    semaphore nesnesi" kullanılmak üzere açılmaktadır. Eğer fonksiyonun ikinci parametresinde O_CREAT kullanılmışsa ve nesne daha önce yaratılmamışsa
    bu durumda fonksiyon üçünüc ve dördüncü parametreleri kullanmaktadır. Diğer durumlarda bu parametreleri kullanmamaktadır. Başka bir deyişle
    üçüncü ve dördüncü parametreler nesne ilk kez yaratılırken kullanılmaktadır. Semaphore nesnelerinde açış bayraklarında O_RDONLY, O_WRONLY
    ve O_RDWR kullanılması POSIX standartlarında "belirsiz (unspecified)" bırakılmıştır. Ancak Linux sistemlerinde bu bayrakların etkileri vardır. 
    Bu konu "UNIX Linux Sistem Programlama" kurslarında ele alınmaktadır.

    sem_open fonksiyonu ile yaratılan isimli POSIX semaphore nesnesi yine paylaşılan bellek alanlarında olduğu gibi sistem reboot edilene 
    kadar yaşamaya devam etmektedir (kernel persistent). Bu nesneyi reboot etmeden silmek için sem_unlik fonksiyonu kullanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <semaphore.h>

    int sem_unlink(const char *name);

    Fonksiyon isimli semaphore nesnesinin ismini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri 
    döner. 

    Bu fonksiyonları kullanırken "librt" ve "libpthread" kütüphanelerini link aşamasına dahil etmelisiniz. Derleme aşağıdaki gibi yapılmalıdr:

    gcc -Wall -o sample sample.c -lrt -lpthread
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda UNIX/Linux sistemlerinde üretici-tüketici probleminin proseslerarası kullanımına bir örnek verilmiştir. Bu örnekte "producer" ve
    "consumer" isimli iki program vardır. producer programı üretici, consumer programı ise tüketici programdır. Programlarda bir tane paylaşılan 
    bellek alanı iki tane de proseslerarası kullanılabilen isimli semaphore nesnesi oluşturulmuştur. Buradaki programların hangisinin önce 
    çalıştırıdığının bir önemi yoktur. Çünkü ilk çalıştırılan program nesneleri yaratmakta sonra çalıştırılan program yaratılmış olanları 
    açmaktadır. Her iki programda da nesneler yok edilmeye çalışılmıştır. Ancak bu nesneleri diğer program yok etmişse bu durum normal karşılanıp 
    bir hata rapor edilmemiştir. Örneğimizde kuyruk sistemi paylaşılan bellek alanında oluşturulmuştur. Programları aşağıdaki gibi derleyebilirsiniz:

    $ gcc -o producer producer.c -lrt -lpthread
    $ gcc  -o consumer consumer.c -lrt -lpthread 

    Programları farklı terminallerden çalıştırmalısınız.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <pthread.h>
#include <semaphore.h>

#define SHARED_MEM_NAME            "/sample_shared_memory_name"
#define SEM_PRODUCER_NAME        "/sample_mutex_producer_name"
#define SEM_CONSUMER_NAME        "/sample_mutex_consumer_name"

#define QUEUE_BUFFER_SIZE   10

void exit_sys(const char* msg);
void exit_sys_errno(const char *msg, int eno);

struct SHARED_OBJECT {
    int qbuf[QUEUE_BUFFER_SIZE];
    size_t head;
    size_t tail;
};

int main(void)
{
    int fdshm;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    void *shmaddr;
    struct SHARED_OBJECT *so;
    int val;
    
    srand(time(NULL));

    if ((fdshm = shm_open(SHARED_MEM_NAME, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, 4096) == -1) {
        perror("ftruncate");
        goto EXIT1;
    }
    
    if ((shmaddr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED) {
        perror("mmap");
        goto EXIT2;
    }

    if ((sem_producer = sem_open(SEM_PRODUCER_NAME, O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, QUEUE_BUFFER_SIZE)) == NULL) {
        perror("sem_open");
        goto EXIT3;
    }

    if ((sem_consumer = sem_open(SEM_CONSUMER_NAME, O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, 0)) == NULL) {
        perror("sem_open");
        goto EXIT4;
    }

    so = (struct SHARED_OBJECT *)shmaddr;
    so->head = 0;
    so->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);
        if (sem_wait(sem_producer) == -1) {
            perror("sem_wait");
            goto EXIT5;
        }
        so->qbuf[so->tail++] = val;
        if (sem_post(sem_consumer) == -1) {
            perror("sem_wait");
            goto EXIT5;
        }
        
        so->tail = so->tail % QUEUE_BUFFER_SIZE;
        if (val == 99)
            break;
        ++val;
    }
    
EXIT5:
    sem_destroy(sem_consumer);
    if (sem_unlink(SEM_CONSUMER_NAME) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");
EXIT4:
    sem_destroy(sem_producer);
    if (sem_unlink(SEM_PRODUCER_NAME) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");
EXIT3:
    if (munmap(shmaddr, 4096) == -1)
        exit_sys("munmap");
EXIT2:
    close(fdshm);
EXIT1:
    if (shm_unlink(SHARED_MEM_NAME) == -1 && errno != ENOENT)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>
#include <pthread.h>
#include <semaphore.h>

#define SHARED_MEM_NAME            "/sample_shared_memory_name"
#define SEM_PRODUCER_NAME        "/sample_mutex_producer_name"
#define SEM_CONSUMER_NAME        "/sample_mutex_consumer_name"

#define QUEUE_BUFFER_SIZE   10

void exit_sys(const char* msg);
void exit_sys_errno(const char *msg, int eno);

struct SHARED_OBJECT {
    int qbuf[QUEUE_BUFFER_SIZE];
    size_t head;
    size_t tail;
};

int main(void)
{
    int fdshm;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    void *shmaddr;
    struct SHARED_OBJECT *so;
    int val;
    
    srand(time(NULL));

    if ((fdshm = shm_open(SHARED_MEM_NAME, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
        exit_sys("shm_open");

    if (ftruncate(fdshm, 4096) == -1) {
        perror("ftruncate");
        goto EXIT1;
    }
    
    if ((shmaddr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fdshm, 0)) == MAP_FAILED) {
        perror("mmap");
        goto EXIT2;
    }

    if ((sem_producer = sem_open(SEM_PRODUCER_NAME, O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, QUEUE_BUFFER_SIZE)) == NULL) {
        perror("sem_open");
        goto EXIT3;
    }

    if ((sem_consumer = sem_open(SEM_CONSUMER_NAME, O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, 0)) == NULL) {
        perror("sem_open");
        goto EXIT4;
    }

    so = (struct SHARED_OBJECT *)shmaddr;

    for (;;) {
        if (sem_wait(sem_consumer) == -1) {
            perror("sem_wait");
            goto EXIT5;
        }
        val = so->qbuf[so->head++];
        if (sem_post(sem_producer) == -1) {
            perror("sem_wait");
            goto EXIT5;
        }
        
        so->head = so->head % QUEUE_BUFFER_SIZE;
        
        usleep(rand() % 300000);
        printf("%d ", val);
        fflush(stdout);

        if (val == 99)
            break;
    }
    putchar('\n');
    
EXIT5:
    sem_destroy(sem_consumer);
    if (sem_unlink(SEM_CONSUMER_NAME) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");
EXIT4:
    sem_destroy(sem_producer);
    if (sem_unlink(SEM_PRODUCER_NAME) == -1 && errno != ENOENT)
        exit_sys("sem_unlink");
EXIT3:
    if (munmap(shmaddr, 4096) == -1)
        exit_sys("munmap");
EXIT2:
    close(fdshm);
EXIT1:
    if (shm_unlink(SHARED_MEM_NAME) == -1 && errno != ENOENT)
        exit_sys("shm_unlink");

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde de proseslerarası üretici-tüketici problemi benzer biçimde gerçekleştirilmektedir. Aşağıda buna ilişkin bir örnek
    verilmiştir. Bu örnekte de yine "producer" ve "consumer" isimli iki program vardır. Bu örneği yukarıuda verdiğimiz UNIX/Linux sistemlerindeki
    örneğin Windows karşılığı olarak düşünebilirsiniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define FILE_MAPPING_NAME            "ProducerConsumerSharedMemoryName"
#define PRODUCER_SEMAPHORE_NAME        "ProducerSemaphoreName"
#define CONSUMER_SEMAPHORE_NAME        "ConsumerSemaphoreName"

#define QUEUE_BUFFER_SIZE            10

void ExitSys(LPCSTR lpszMsg);

struct SHARED_OBJECT {
    int qbuf[QUEUE_BUFFER_SIZE];
    size_t head;
    size_t tail;
};

int main(void)
{
    HANDLE hFileMapping;
    HANDLE hSemProducer;
    HANDLE hSemConsumer;
    int val;

    struct SHARED_OBJECT *sharedObject;

    if ((hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, FILE_MAPPING_NAME)) == NULL)
        ExitSys("CreateFileMapping");

    if ((sharedObject = (struct SHARED_OBJECT *)MapViewOfFile(hFileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0)) == NULL)
        ExitSys("MapViewOfFile");

    if ((hSemProducer = CreateSemaphore(NULL, QUEUE_BUFFER_SIZE, QUEUE_BUFFER_SIZE, PRODUCER_SEMAPHORE_NAME)) == NULL)
        ExitSys("CreateSemaphore");

    if ((hSemConsumer = CreateSemaphore(NULL, QUEUE_BUFFER_SIZE, QUEUE_BUFFER_SIZE, CONSUMER_SEMAPHORE_NAME)) == NULL)
        ExitSys("CreateSemaphore");


    val = 0;
    for (;;) {
        Sleep(rand() % 300);
        
        WaitForSingleObject(hSemProducer, INFINITE);
        sharedObject->qbuf[sharedObject->tail++] = val;
        ReleaseSemaphore(hSemConsumer, 1, NULL);

        sharedObject->tail = sharedObject->tail % QUEUE_BUFFER_SIZE;
        if (val == 99)
            break;
        ++val;
    }

    CloseHandle(hSemProducer);
    CloseHandle(hSemConsumer);

    UnmapViewOfFile(sharedObject);
    CloseHandle(hFileMapping);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define FILE_MAPPING_NAME            "ProducerConsumerSharedMemoryName"
#define PRODUCER_SEMAPHORE_NAME        "ProducerSemaphoreName"
#define CONSUMER_SEMAPHORE_NAME        "ConsumerSemaphoreName"

#define QUEUE_BUFFER_SIZE            10

void ExitSys(LPCSTR lpszMsg);

struct SHARED_OBJECT {
    int qbuf[QUEUE_BUFFER_SIZE];
    size_t head;
    size_t tail;
};

int main(void)
{
    HANDLE hFileMapping;
    HANDLE hSemProducer;
    HANDLE hSemConsumer;
    struct SHARED_OBJECT *sharedObject;
    int val;

    if ((hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 4096, FILE_MAPPING_NAME)) == NULL)
        ExitSys("CreateFileMapping");

    if ((sharedObject = (struct SHARED_OBJECT *)MapViewOfFile(hFileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0)) == NULL)
        ExitSys("MapViewOfFile");

    if ((hSemProducer = CreateSemaphore(NULL, QUEUE_BUFFER_SIZE, QUEUE_BUFFER_SIZE, PRODUCER_SEMAPHORE_NAME)) == NULL)
        ExitSys("CreateSemaphore");

    if ((hSemConsumer = CreateSemaphore(NULL, 0, QUEUE_BUFFER_SIZE, CONSUMER_SEMAPHORE_NAME)) == NULL)
        ExitSys("CreateSemaphore");

    for (;;) {
        WaitForSingleObject(hSemConsumer, INFINITE);
        val = sharedObject->qbuf[sharedObject->head++];
        ReleaseSemaphore(hSemProducer, 1, NULL);

        sharedObject->head = sharedObject->head % QUEUE_BUFFER_SIZE;
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
        Sleep(rand() % 300);
    }
    putchar('\n');

    CloseHandle(hSemProducer);
    CloseHandle(hSemConsumer);

    UnmapViewOfFile(sharedObject);
    CloseHandle(hFileMapping);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();
    LPSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde "event senkronizasyon nesnesi" denilen önemli bir senkronizasyon nesnesi daha vardır. Bu senkronizasyon nesnesinin
    UNIX/Linux sistemlerinde tam bir karşılığı yoktur. Ancak UNIX/Linux sistemlerindeki "koşul değişkenleri (conditioned variable)" işlev olarak
    Windows'taki event senkronizasyon nesnelerinin görevini de yapabilmektedir. 

    Windows'taki event senkronizasyon nesneleri belli bir thread akışının başka bir thread bir işlemi bitirene kadar bir noktada bekletilmesi 
    amacıyla kullanılmaktadır. Örneğin bir thread global bir diziyi sıraya dizecek olsun. Ancak bu dizi başka bir thread tarafından oluşturulacak 
    olsun. Thread'ler asenkron çalıştığına göre sıraya dizme işlemini yapacak thread sıraya dizmenin yapıldığı noktaya geldiğinide diğer 
    thread'in diziyi oluşturmuş olması gerekmektedir. Eğer diğer thread diziyi oluşturmamışsa sıraya dizmeyi yapacak thread o noktada beklemeli 
    diğer thread diziyi oluşturduktan sonra bu işe başlamalıdır. 

    Thread'in bir noktada bekletilmesi semaphore nesneleriyle de kısmen yapılabilir. Örneğin sayacı 0 olan bir semaphore blokeye yol açacağı 
    için thread'i bekletebilir. Diğer thread de semaphore sayacını artırarak onu oradan kurtarabilir. Ancak semaphore'lar event nesnelerinin 
    sağladığı bazı durumları sağlayamamaktadır. Örneğin diğer thread bekleyen thread'in çalışmasına devam etmesini istediğinde artık aynı 
    senkronizasyon nesnesinde thread'in beklememesi gerekebilir. Semaphore'lar bunu doğrudan sağlaymamaktadır. Ya da örneğin diğerini beklemekten
    kurtaran thread bunu birden fazla kez yaptığında semaphore'lar sayaçlı olduğu için diğer thread'in bekletilmesini sağlayamayabilirler. 

    Windows sistemlerindeki event senkronizasyon nesnesi aşağıdaki adımlardan geçilerek kullanılmaktadır:

    1) Event senkronizasyon nesnesi CreateEvent API fonksiyonuyla yaratılır. Fonksiyonun prototipi şöyledir:

    HANDLE CreateEvent(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        BOOL                  bManualReset,
        BOOL                  bInitialState,
        LPCSTR                lpName
    );

    Fonksiyonun birinci parametresi kernel nesnesinin güvenlik bilgilerini belirtmektedir. Bu parametre NULL geçilebilir. Fonksiyonun ikinci 
    parametresi event nesnesinin "manuel mi otomatik mi" olduğunu belirtmektedir. Eğer bu parametreye TRUE girilirse nesne manuel olur, FALSE
    girilirse otomatik olur. Event nesnesi manuel ise SetEvent yapıldığında nesne açık (signaled) durumda kalır. Nesne otomatik ise SetEvent
    yapıldığında geçiş sağlanınca nesne yeniden otomatik olarak kapalı duruma getirilir. Bunun anlamı izleyen paragraflarda daha iyi anlaşılacaktır. 
    Fonksiyonun üçüncü parametresi nesnenin başlangıçta açık mı (signaled) yoksa kapalı mı  (nonsignaled) olacağını belirtmektedir. Bu parametre 
    TRUE girilirse nesne başlangıçta açık, FALSE girilirse kapalı durumda olur. Genellikle event nesnesi yaratılıken kapalı bir biçimde yaratılmaktadır. 
    Fonksiyonun son parametresi nesnenin proseslerarası kullanılması için gerekli olan ismini belirtmektedir. Eğer nesne aynı prosesin thread'leri
    arasında kullanılacaksa bu parametre NULL adres biçiminde geçilebilir. Fonksiyon başarı durumunda event nesnesinin handle değerine, başarısızlık 
    durumunda NULL adrese geri dönemktedir. Örneğin:

    HANDLE g_hEvent;
    ...

    if ((g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        Exitrys("CreateEvent");

    2) Event nesnesi yine diğer kernel senkronizasyon nesnelerinde olduğu gibi WaitForSingleObject ve WaitForMultipleObjects fonksiyonlarıyla 
    yapılmaktadır. WaitForSingleObject fonksiyonu eğer event nesnesi kapalıysa blokeye yol açar, eğer nesne açık durumdaysa geçiş yapar. 
    Yani akış WaitForSingleObject fonksiyonunda beklemeden hemen fonksiyondan çıkarak devam eder. 

    3) Event nesnesini açık duruma geçirmek için SetEvent API fonksiyonu kullanılır. SetEvent fonksiyonunun prototipi şöyledir:

    BOOL SetEvent(
      HANDLE hEvent
    );

    Fonksiyon event nesnesinin handle değerini parametre olarak alır ve nesneyi açık duruma geçirir. Artık nesne kapalı olduğundan dolayı 
    bekleyen thread WaitForSingleObject fonksiyonundan çıkar. Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır 
    değerine geri dönmektedir. Örneğin:

    SetEvent(g_hEvent);

    Nesne SetEvent fonksiyonu ile açık duruma geçirildiktin sonra WaitForSingleObject fonksiyonunda bekleyen thread blokeden çıkar. İşte eğer 
    nesne otomatik ise bu durumda WaitForSİngleObject fonksiyonundan çıkılırken nesne otomatik olarak yeniden kapalı duruma geçmektedir. 
    Eğer nesne manuel durumdaysa WaitForSingleObject fonksiyonu sonlandığında nesne hala açık durumda olmaya devam eder. Event nesnelerini 
    kapalı duruma geçirmek için ResetEvent API fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    BOOL ResetEvent(
        HANDLE hEvent
    );
    
    Fonksiyon event nesnesinin handle değerini parametre olarak alır, başarı durumunda sıfır değerine başarısızlık durumunda sıfır dışı bir 
    değere geri döner. 

    WaitForSingleObject (ya da WaitForMultipleObjects) fonksiyonu ile birden fazla thread otomatik moddaki event nesnesini bekliyorsa, bu
    event nesnesi açık duruma geçtiğinde yalnızca tek bir thread'in blokesi çözülür. Çünkü event nesnesi otomatik durumda olduğu için 
    WaitForSingleObject fonksiyonundan çıkılır çıkılmaz nesne atomik bir biçimde kapalı duruma geçirilecektir. Tabii eğer event nesnesi 
    manuel modda ise SetEvent yapıldığında event nesnesini bekleyen thread'lerin blokesi çözülecektir.

    Aşağıda event senkronizasyon nesnesinin kullanımına bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

void ExitSys(LPCSTR lpszMsg);

HANDLE g_hEvent;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
        ExitSys("CreateEvent");

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    printf("Press ENTER to set event...\n");
    getchar();
    SetEvent(g_hEvent);


    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    printf("Thread1 running...\n");
    printf("waiting for the event object...\n");

    WaitForSingleObject(g_hEvent, INFINITE);
    printf("Ok, thread1 resumes...\n");

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    printf("Thread2 running...\n");
    printf("waiting for the event object...\n");

    WaitForSingleObject(g_hEvent, INFINITE);
    printf("Ok, thread2 resumes...\n");
    
    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Sık karşılaşılan diğer bir senkronizasyon nesnesi de "okuma-yazma kilitleri (reder-writer lock)" denilen nesnelerdir. Önce bu nesnelere 
    neden gereksinim duyulduğunu açıklayalım. Bir kaynak üzerinde bir grup thread'in "okuma" bir grup thread'in de "yazma" eyleminde bulunduğunu
    düşünelim. Burada "okuma" eylemi demekle "kaynakta değişiklik yaratmayan", yazma eylemi demekle de "kaynakta değişiklik yaratan" eylemleri 
    kastediyoruz. Örneğin global bir bağlı liste söz konusu olsun. Thread'lern bazıları bu bağlı liste üzerinde "arama" işlemi yaparken bazıları 
    da bu bağlı liste üzerinde insert işlemi yapıyor olsunlar. Burada arama işlemi okuma eylemini, insert işlemi ise yazma eylemini temsil 
    etmektedir. Birden fazla thread'in aynı anda bağlı listede arama yapmasının sakıncası yoktur. Ancak bir thread bağlı listede insert işlemi 
    yaparken başka thread'lerin o işlem bitene kadar arama işlemi ya da insert işlemi yapmaması gerekir. Benzer biçimde bir thread bağlı liste 
    üzerinde arama işlemi yaparken başka bir thread'in insert işlemi de yapmaması gerekir. İki thread için buradaki olası durumları şöyle ifade 
    edebiliriz:

    Thread1                Thread2            Ne Yapılmalı?
    -------------------------------------------------------
    Okuma                Okuma            İzin Verilmeli
    Okuma                Yazma            Senkronize Edilmeli
    Yazma                Okuma            Senkronize Edilmeli
    Yazma                Yzma            Senkronize Edilmeli

    O halde buradan çıkan sonuç şudur:

    1) Bir thread yazma yaparken yazma ve okuma yapacak thread'ler bu yazma olayının bitmesini beklemelidir. 
    2) Bir thread okuma yaparken yazma yapacak thread'ler bu okuma işlminin bitmesini beklemelidir. 
    3) Bir thread okuma yaparken, okuma yapacak diğer thread'ler eş zamanlı olarak bu işlemi yapabilirler.

    Okuma-yazma kilitleri Windows sistemlerinde de UNIX/Linux sistemlerinde de var olan senkronizasyon nesnelerindendir. Biz burada önce Windows
    sistemlerindeki okuma-yazma kilitlerini daha sonra UNIX/Linux sistemlerindeki okuma-yazma kilitlerini göreceğiz. 

    Pekiyi reader-writer lock yerine yukarıdaki işlem mutex nesneleri ile yapılamaz mı? Eğer yukarıdaki problem mutex nesneleriyle çözülmeye
    çalışılırsa bu durumda mecburen okuma sırasında da kilitleme yapılır. Dolayısıyla gereksiz bir biçimde okuma yapmak isteyen birden fazla
    thread birbirlerini beklemek zorunda kalır. Aşağıdaki temsili (pseudo) kodu inceleyiniz:

    pthread_mutex_t g_mutex;
    ...

    read()
    {
        pthread_mutex_lock(&g_mutex);
        ...
        pthread_mutex_unlock(&g_mutex);
    }

    write()
    {
        pthread_mutex_lock(&g_mutex);
        ...
        pthread_mutex_unlock(&g_mutex);
    }

    Burada görüldüğü gibi bireden fazla read işlemi birlikte yapılamamaktadır. 

    Reader-writer lock nesneleri aslında taban (base) senkronizasyon nesnelerinden değildir. Bunlar mutex ve koşul değişkenleri (condition 
    variable) kullanılarak gerçekleştirilebilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde okuma-yazma kilitleri şöyle kullanılmaktadır:

    1) Okuma-yazma kilit nesneleri SRWLOCK türüyle temsil edilmektedir. Önce global düzeyde SRWLOCK türünden bir nesne yaratılır. Bu nesneye 
    InitializeSRWLock fonksiyonu ile ilkdeğerleri verilir. Fonksiyonun prototipi şöyledir:

    void InitializeSRWLock(
        PSRWLOCK SRWLock
    );

    Fonksiyon SRWLOCK nesnesinin başlangıç adresini parametre olarak almaktadır. Örneğin:

    SWRLOCK g_srwLock;
    ...
    InitializeSRWLock(&g_srwLock);

    2) Okuma amaçlı kritik kod şöyle oluşturulmaktadır:

    AcquireSRWLockShared(&g_srwLock);
    ...
    ... <KRİTİK KOD>
    ...
    ReleaseSRWLockShared(&g_srwLock)

    Burada okuma amaçlı kilidin alınması AcquireSRWLockShared fonksiyonu ile yapılmaktadır. Fonksiyon eğer kilit başka bir thread tarafından 
    yazma amaçlı olarak alındıysa blokeye yol açmaktadır. Ancak kilit başka bir thread tarafından okuma amaçlı alındıysa blokeye yol açmadan 
    kritik koda geçişi sağlamaktadır. Okuma amaçlı kritik koddan çıkılırken kilit ReleaseSRWLockShared fonksiyonu ile serbest bırakılmalıdır. 

    Yazma Amaçlı kritik kod da şöyle oluşturulmaktadır:

    AcquireSRWLockExclusive(&g_srwLock);
    ...
    ... <KRİTİK KOD>
    ...
    ReleaseSRWLockExclusive(g_srwLock)

    Eğer kilit başka bir thread tarafından okuma amaçlı ya da yazma amaçlı olarak alınmışsa AcquireSRWLockExclusive fonksiyonu blokede bekler. 
    Eğer kilit okuma ya da yazma amaçlı hiçbir thread tarafından alınmadıysa kritik koda geçiş yapılır. Yazma amaçlı kritik koddan çıkılırken 
    kilit ReleaseSRWLockExclusive fonksiyonu ile serbest bırakılmalıdır.  

    Fonksiyonların prototipileri şöyledir:

    void AcquireSRWLockShared(
        PSRWLOCK SRWLock
    );

    void ReleaseSRWLockShared(
        PSRWLOCK SRWLock
    );

    void AcquireSRWLockExclusive(
        PSRWLOCK SRWLock
    );

    void ReleaseSRWLockExclusive(
        PSRWLOCK SRWLock
    );

    Fonksiyonlar SRWLOCK nesnelerinin adreslerini parametre olarak almaktadır. 

    Windows'ta reader-writer lock nesnelerinin serbest bırakılması gibi bir durum söz konusu değildir. Bunlar zaten bir kaynak tutmamaktadır.

    Aşağıda Windows sistemlerinde reader-write lock nesnelerinin kullanımına ilişkin bir örnek verilmiştir. Bu örnekte belli sayıda thread
    yaratılıp bunların rastgele read-write işlemleri yapması sağlanmıştır. Ekrandaki çıktı incelendiğinde write işlemi başladığında bitene 
    kadar başka hiç read ya da write işleminin yapılmadığı görülecektir. Ancak read işlemleri birlikte yapılabilmektedir. Programın ekran 
    çıktısının bir kısmının örnek bir görüntüsü şöyledir.

    ...
    Thread-1 thread begins writing...
    Thread-1 thread ends writing...
    Thread-3 thread begins reading...
    Thread-3 thread ends reading...
    Thread-6 thread begins writing...
    Thread-6 thread ends writing...
    Thread-2 thread begins reading...
    Thread-7 thread begins reading...
    Thread-7 thread ends reading...
    Thread-2 thread ends reading...
    ...

    Burada örneğin Thread-2 ve Thread-7'nin read işlemine birlikte girdiği görülmektedir. Ancak bir write işlemi başladığında o write işlemi 
    bitene kadar read ya da write yapılamamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

#define NTHREADS            10

DWORD __stdcall ThreadProc(LPVOID lpvParam);
void Read(const char *pszThreadName);
void Write(const char *pszThreadName);
void ExitSys(LPCSTR lpszMsg);

SRWLOCK g_srwLock;

int main(void)
{
    HANDLE hThreads[NTHREADS];
    DWORD dwThreadIds[NTHREADS];
    char szThreadName[32];
    char *pszThreadName;

    srand(time(NULL));

    InitializeSRWLock(&g_srwLock);

    for (int i = 0; i < NTHREADS; ++i) {
        sprintf(szThreadName, "Thread-%d", i + 1);
        if ((pszThreadName = strdup(szThreadName)) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }

        if ((hThreads[i] = CreateThread(NULL, 0, ThreadProc, pszThreadName, 0, &dwThreadIds[i])) == NULL)
            ExitSys("CreateThread");
    }
    
    if (WaitForMultipleObjects(NTHREADS, hThreads, TRUE, INFINITE) == WAIT_FAILED)
        ExitSys("CreateThread");
    
    for (int i = 0; i < NTHREADS; ++i)
        CloseHandle(hThreads[i]);
    
    return 0;
}

DWORD __stdcall ThreadProc(LPVOID lpvParam)
{
    const char *pszThreadName = (LPCTSTR)lpvParam;

    for (int i = 0; i < 10; ++i) {
        Sleep(rand() % 100);
        if (rand() % 2 == 0)
            Read(pszThreadName);
        else
            Write(pszThreadName);
    }

    free(lpvParam);

    return 0;
}

void Read(const char *pszThreadName)
{
    AcquireSRWLockShared(&g_srwLock);
    printf("%s thread begins reading...\n", pszThreadName);
    Sleep(rand() % 300);
    printf("%s thread ends reading...\n", pszThreadName);
    ReleaseSRWLockShared(&g_srwLock);
}

void Write(const char *pszThreadName)
{
    AcquireSRWLockExclusive(&g_srwLock);
    printf("%s thread begins writing...\n", pszThreadName);
    Sleep(rand() % 300);
    printf("%s thread ends writing...\n", pszThreadName);
    ReleaseSRWLockExclusive(&g_srwLock);
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde de okuma-yazma kilitlerinin temel kullanım biçimi benzerdir. İşlemler şöyle yürütülmektedir:

    1) Okuma yazma kilitleri pthread_rwlock_t türüyle temsil edilmektedir. Programcı bu türden global bir nesne tanımlar. Nesneye ilkdeğer 
    vermenin iki yolu vardır. Birincisi statik düzeyde PTHREAD_RWLOCK_INITIALIZER isimli maroyu kullanmaktadır. Örneğin:

    #include <pthread.h>

    pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;

    İkincisi ise pthread_rwlock_init fonksiyonunu kullanmaktır. Örneğin:

    pthread_rwlock_t g_rwlock;
    ...
    int pthread_rwlock_init(&g_rwlock);

    pthread_rwlock_init fonksiyonunun prototipi şöyledir:

    int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);

    Fonksiyonun birinci parametresi ilkdeğer verilecek pthread_rwlock_t nesnesinin adresini almaktadır. İkinci parametre reader-writer lock
    nesnesinin özelliklerinin belirtildiği pthread_rwlockattr_t türünden nesnenin adresini almaktadır. İkinci parametre NULL geçilebilir. Bu 
    durumda nesne default özelliklerle yaratılmaktadır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    2) Okuma amaçlı kritik kod şöyle oluşturulmaktadır:

    pthread_rwlock_rdlock(&g_rwlock);
    ...
    ... <KRİTİK KOD>
    ...
    pthread_rwlock_unlock(&g_rwlock);

    Yazma amaçlı kritik kod ise şöyle oluşturulmaktadır:

    pthread_rwlock_wrlock(&g_rwlock);
    ...
    ... <KRİTİK KOD>
    ...
    pthread_rwlock_unlock(&g_rwlock);

    Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

    Fonksiyonlar pthread_rwlock_t türünden nesnenin adresini almaktadır. Genel çalışma biçimi yukarıda Windows sistemlerinde açıkladığımız
    gibidir. Burada Windows sistemlerinden farklı olarak unlock işlemi için tek fonksiyon bulunmaktadır. Yani kilit okuma amaçlı da alınsa,
    yazma amaçlı da alınsa kilidin bırakılması pthread_rwlock_unlock fonksiyonu ile yapılmaktadır. Fonksiyonlar başarı durumunda 0 değerine
    başarısızlık durumunda errno değerine geri dönmektedir. 

    3) Programcı reader-writer lock nesnesi ile işini bitirsikten sonra pthread_rwlock_destroy fonksiyonu ile nesneyi yok edilmelidir. Fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

    Fonksiyon yine pthread_rwlock_t nesnesinin adresini parametre olarak alır, başarı durumunda sıfır değerine başrısızlık durumunda ise 
    errno değerine geri döner. 

    Aşağıda UNIX/Linux sistemlerinde reader-writer lock nesnelerinin kullanımına örnek verilmiştir. Bu örnek aslında yukarıda Windows 
    sistemeri için yaptiğimız örneğin UNIX/linux versiyonu gibidir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

#define NTHREADS        10

void *thread_proc(void *param);
void read_proc(const char *ptname);
void write_proc(const char *ptname);
void exit_sys_errno(const char *msg, int eno);

pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;

int main(void)
{
    pthread_t tids[NTHREADS];
    char tname[32], *ptname;
    int result;
    
    srand(time(NULL));

    for (int i = 0; i < NTHREADS; ++i) {
         sprintf(tname, "Thread-%d", i + 1);
        if ((ptname = strdup(tname)) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        if ((result = pthread_create(&tids[i], NULL, thread_proc, ptname)) != 0) 
            exit_sys_errno("pthread_create", result);
    }

    for (int i = 0; i < NTHREADS; ++i)
        pthread_join(tids[i], NULL);

    if ((result = pthread_rwlock_destroy(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_destroy", result);
        
    return 0;
}

void *thread_proc(void *param)
{
    const char *ptname = (const char *)param;

   for (int i = 0; i < 10; ++i) {
        usleep(rand() % 100000);
        if (rand() % 2 == 0)
            read_proc(ptname);
        else
            write_proc(ptname);
   }

    return NULL;
}

void read_proc(const char *ptname)
{
    int result;

    if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
        exit_sys_errno("pthread_rwlock_rdlock", result);

    printf("%s thread begins reading...\n", ptname);
    usleep(rand() % 300000);
    printf("%s thread ends reading...\n", ptname);

    if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
        exit_sys_errno("pthread_rwlock_unlock", result);
}

void write_proc(const char *ptname)
{
    int result;

    if ((result = pthread_rwlock_wrlock(&g_rwlock)) != 0)
        exit_sys_errno("pthread_rwlock_wrlock", result);

    printf("%s thread begins writing...\n", ptname);
    usleep(rand() % 300000);
    printf("%s thread ends writing...\n", ptname);

    if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
        exit_sys_errno("pthread_rwlock_unlock", result);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde ismine "koşul değişkenleri (condition variables)" denilen önemli bir senkronizasyon nesnesi vardır. Koşul 
    değişkenleri eskiden Windows sistemlerinde yoktu. Ancak belli bir zamandan sonra Windows sistemlerine de sokuldu. Windows'ta event nesneleri 
    olduğu için koşul değişkenleri yerine bu nesneler onların görevlerini tam olmasa da yaklaşık olarak yerine getirebiliyordu Ancak yukarıda 
    da belirttiğimiz gibi daha sonraları Windows sistemlerine de koşul değişkenleri eklenmiştir. 

    Koşul değişkenlerinin amacı bir koşul sağlanmadığı sürece thread'i blokede bekletmek, koşul sağlanınca thread'in blokesini çözmektir. 
    Ancak koşul değişkenlerinin kullanılması ve çalışma biçiminin anlaşılması şimdiye kadar gördüğümüz senkronizasyon nesnelerine göre
    daha zordur.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde koşul değişkenleri tipik olarak aşağıdaki adımlardan geçilerek kullanılmaktadır:
    
    1) UNIX/Linux sistemlerinde koşul değişkenleri tek başlarına kullanılmamaktadır. Mutex nesneleri ile birlikte kullanılmaktadır. Koşul 
    değişkenleri pthread_cond_t türüyle temsil edilmektedir. Programcı koşul değişkenlerini yine global düzeyde bir mutex ile birlikte 
    tanımlar. Koşul değişkenlerine ilkdeğer verilmesi statik düzeyde PTHREAD_COND_INITIALIZER makrosuyle yapılabilir. Örneğin:

    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;
    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

    Kooşul değişkenlerine ilkdeğer vermek için pthread_cond_init fonksiyonu da kullanılabilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

    Fonksiyonun birinci parametresi pthread_cond_t nesnesini adresini, ikinci parametresi koşul değişkeninin özelliklerin belirtildiği 
    pthread_condattr_t nesnesinin adresini almaktadır. Biz bu kursta koşul değişkenlerinin özelliklerini ele almayacağız. Bu ikinci parametreyi 
    NULL olarak geçebilirsiniz. Bu durumda koşul değişkenleri default özelliklerle yaratılmaktadır. Zaten PTHREAD_COND_INITIALIZER makrosu da 
    koşul değişkenlerini default özelliklerle yaratmaktadır. Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda errno değerine 
    geri dönmektedir. 

    2) Koşul değişkenleri ile koşul sağlanana kadar bekleme yapmak için pthread_cond_wait isimli fonksiyon kullanılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

    Fonksiyonun birinci parametresi koşul değişkeninin adresini, ikinci parametresi mutex nesnesinin adresini almaktadır. Fonksiyon başarı 
    durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. Örneğin:

    pthread_cond_wait(&g_cond, &g_mutex);

    Ancak koşul sağlanana kadar bekleme böyle yapılmamaktadır. Belli bir kalıba uygun biçimde bu fonksiyon çağrılmalıdır. Koşul değişkenini
    bekleme kalıbı aşağıdaki gibidir:

    pthread_mutex_lock(&g_mutex);
    while (koşul_sağlanmadığı_sürece)
        pthread_cond_wait(&g_cond, &g_mutex);
    pthread_mutex_unlock(&g_mutex);

    Burada dikkat edilmesi gereken durumlar şunlardır: pthread_cond_wait bir döngü içerisinde çağrılmalıdır. Döngünün aşağıdaki gibi oluşturulduğuna
    dikkat ediniz:

    while (koşul_sağlanmadığı_sürece)
        pthread_cond_wait(&g_cond, &g_mutex);

    Burada döngünün içerisindeki koşul "koşulun sağlanmadığı sürece uykuda kalınmasına ilişkin" koşuldur. Yani bu koşul sağlanmadığı zaman 
    thread uyandırılacaktır. Örneğin:

    while (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);

    Burada g_flag değişkeni sıfır olduğu sürece thread blokede bekleyecektir. Yani blokenin çözülmesi için g_flag değişkeninin 0'dan farkllı
    bir değerde olması gerekmektedir. 

    Yukarıdaki kalıptaki diğer önemli bir nokta da koşul döngüsüne girmeden mutex nesnesinin sahipliğinin alındığı ve çıkışta da sahipliğin 
    bırakıldığıdır. Yukarıdaki kalıbın ne anlama geldiği izleyen paragraflarda açıklanacaktır. 

    3) Koşul değişkenini bekleyen thread'i uyandırmak için iki POSIX fonksiyonu bulunmaktadır: pthread_cond_signal ve pthread_cond_broadcast.
    pthread_cond_signal fonksiyonu koşul değişkeninde bekleyen tek bir thread'i uyandırma amacındadır. pthread_cond_broadcast ise koşul 
    değişkeninde bekleyen tüm thread'leri uyandırma amacındadır. pthread_cond_signal fonksiyonu aslında tek bir thread'i uyandırmak istemektedir. 
    Ancak işletim sistemlerinde bu durum her zaman mümkün olamadığı için istemeden birden fazla thread de uyandırılabilmektedir. Bu duruma 
    "yanlış uyanma (spurious wakeup)" denilmektedir. Bu iki uyandırma biçimini şu örneğe benzetebiliriz: Bir odada 10 kişi uyuyor olsun. Siz de
    yalnızca Ahmet'i uyandırmak isteyin. Ancak yaptığınız gürültüden istemeden Mehmet ve Selami de uyanmış olabilir. İşte Mehmet ve Selami'nin 
    uyanması "yanlış uyanma (spurious wakeup)" durumudur. Ancak siz bir megafonla bağırarak odadaki herkesi de uyandırabilirsiniz. Bu işlem 
    pthread_cond_broadcast işlemine benzemektedir. Şimdi siz "yanlışlıkla uyandırma (spurious wakeup)" gibi bir sürecin nasıl olup da yüksek 
    teknoloji gereken işletim sistemlerinde söz konusu olabildiğini merak edebilirsiniz. İşte işletim sistemlerinin etkin tasarımında mecburen böylesi 
    durumlar oluşabilmektedir. pthread_cond_signal fonksiyonunun koşul değişkeninde bekleyen bir thread'i değil "en az bir thread'i" uyandırdığına 
    dikkat ediniz. Ayrıca yanlış uyandırmanın yalnızca pthread_cond_signal yoluyla değil başka nedenlerden dolayı da oluşabileceğini belirtmek 
    istiyoruz. 

    Koşul değişkeninde bekleyen bir thread'in pthread_cond_signal ya da pthread_cond_broadcast fonksiyonu ile uyandırılması koşulun sağlandığı
    anlamına gelmemektedir. Uyanan thread'ler koşulu test etmeli, koşul sağlanmıyorsa yeniden uykuya dalacak biçimde hareket etmelidir. 
    O halde pthread_cond_signal ya da pthread_cond_broadcast uygulanmadan önce bu fonksiyonları uygulayan kitarafın koşulun sağlanmasına yol 
    açması gerekir. Aşağıdaki beklemeye dikkat ediniz:

    pthread_mutex_lock(&g_mutex);
    while (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);
    pthread_mutex_unlock(&g_mutex);

    Burada diğer bir thread g_flag değişkenini değiştrmeden pthread_cond_signal ya da pthread_cond_broadcast uygularsa thrad uyandırılıp 
    pthread_cond_wait fonksiyonundan çıksa bile koşul sağlanmadığından dolayı yeniden uykuya dalacaktır. Tipik olarak programcı pthread_cond_signal
    ya da pthread_cond_broadcast uygulamadan önce mutex nesnesinin sahipliğini almalı koşulu kritik kod içerisinde oluşturmalı, bu fonksiyonları
    çağırdıktan sonra mutex nesnesinin sahipliğini bırakmalıdır. Yani tipik uygulama şöyle olmalıdır:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_cond_broadcast(&g_cond);
    pthread_mutex_unlock(&g_mutex);

    pthread_cond_signal ve pthread_cond_broadcast fonksiyonlarının prototipleri şöyledir:

    #include <pthread.h>

    int pthread_cond_signal(pthread_cond_t *cond);
    int pthread_cond_broadcast(pthread_cond_t *cond);
    
    Fonksiyonlar koşul değişken nesnesinin adresini paranetre olarak almakta, başarı durumunda 0 değerine, başarısızlık durumunda errno değerine
    geri dönmektedirler. 

    4) Koşul değişkeninin ve mutex nesnesinin kullanımı bittiğinde bunlar pthread_cond_destroy ve pthread_mutex_destroy fonksiyonuyla 
    yok edilmelidir. pthread_cond_destroy fonksiyonunun prototipi şöyledir:

     #include <pthread.h>

    int pthread_cond_destroy(pthread_cond_t *cond);

    Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. Aslında genel olarak pthread_cond_destroy 
    ve pthread_mutex_destroy fonksiyonları pek çok kütüphanede bir şey yapmamaktadır. Ancak yine de bu fonksiyonların uyumluluk bakımından 
    çağrılması gerekir. 

    Aşağıda koşul değişkenlerinin kullanımına tipik bir örnek verilmiştir. Örneğimizde iki thread g_flag değişkeninin sıfır dışı bir değer
    olmasını beklemektedir. Ana thread'te g_flag değişkeni 1 değerine set edilip pthread_broadcast işlemi uygulandığında bekleyen iki thread 
    de uyanmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

int g_flag = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    printf("press ENTER to continue...\n");
    getchar();

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    g_flag = 1;
    if ((result = pthread_cond_broadcast(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_broadcast", result);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lunock", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_cond_destroy(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    printf("thread-1 is waiting at the condition variable..\n");

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    while (g_flag == 0)
        if ((result = pthread_cond_wait(&g_cond, &g_mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("ok, thread-1 resumes...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    printf("thread-2 is waiting at the condition variable..\n");

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    while (g_flag == 0)
        if ((result = pthread_cond_wait(&g_cond, &g_mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("ok, thread-2 resumes...\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de koşul değişkenlerini kullanmak için belirttiğimiz kalıpların ne anlam ifade ettiği üzerinde duracağız. Bekleme işleminin mutex
    nesnesinin sahipliği alınarak yapılması gerektiğini belirtmiştik. Örneğin:

    pthread_mutex_lock(&g_mutex);
    while (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);
    pthread_mutex_unlock(&g_mutex);

    Burada önce mutex nesnesinin sahipliğinin alındığını görüyorsunuz. pthread_cond_wait fonksiyonu uykuya dalmadan önce atomik bir biçimde 
    mutex nesnesinin sahipliğini bırakmaktadır. Şimdi aşağıdaki koda bakalım:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_mutex_unlock(&g_mutex);
    
    pthread_cond_broadcast(&g_cond);

    Burada pthread_cond_broadcast uygulandığında bu koşul değişkeninde bekleyen tüm thread'ler uyanacaktır. İşte pthread_cond_wait fonksiyonu 
    uykuya dalmadan önce mutex nesnesinin sahipliğini nasıl bırakıyorsa uyanırken de sahipliği alarak uyanmaktadır. Böylece thread uyandığında 
    koşul eğer sağlanıyorsa döngüden çıkıp yine mutex'i sahipliği bırakacaktır. Şimdi yukarıdaki kodda g_flag değerinin zaten 1 olduğunu 
    düşünelim. Bu durumda mutex nesnesinin sahipliği alınacak g_flag == 1 olduğu için de döngüye girilmeyecektir. Böylece mutex nesnesinin sahipliği 
    bırakılacaktır. 
    
    Pekiyi neden yukarıdaki kalıpta bir döngü kullanılmıştır. Neden döngü yerine if deyimi kullanılmamıştır? İşte bunun nedeni "yalancı uyanma 
    (spurious wakeup)" yüzündendir. Döngü yerine aşağıdaki gibi bir if deyiminin olduğunu varsayalım:

    pthread_mutex_lock(&g_mutex);
    if (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);
    pthread_mutex_unlock(&g_mutex);

    Burada yanlış uyandırma oluştuğunda eğer koşul sağlanmıyorsa thread'in yeniden uykuya dalması gerekir. Bunun için de bir döngünün kullanılması 
    gerekmektedir. Şimdi programcının koşul değişkeninde bekleyen thread'lerden yalnızca birini çözmek istediğini düşünelim. Aşağıdaki kalıp 
    bunu yapamayacaktır:

    pthread_mutex_lock(&g_mutex);
    while (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);
    pthread_mutex_unlock(&g_mutex);

    Burada diğer tarafın pthread_cond_signal uyguladığını kabul edelim. Bu durumda 2 thread'in de uyandırıldığını düşünelim. Bu iki thread de 
    mutex nesnesinin sahipliğini almaya çalışacak ancak yalnızca biri alacaktır. Dolayısıyla diğeri bu mutex nesnesini bekleyecektir. Ancak
    mutex nesnesinin sahipliğini almış olan thread onu bıraktığında bu kez diğer thread mutex nesnesinin sahipliğini alarak koşul değişkeninden 
    çıkacaktır. O halde programcının mutex kontrolünde yeniden koşul değişkenini eski haline getirmesi gerekmektedir. Örneğin:

    pthread_mutex_lock(&g_mutex);
    while (g_flag == 0)
        pthread_cond_wait(&g_cond, &g_mutex);
    g_flag = 0;
    pthread_mutex_unlock(&g_mutex);

    pthread_cond_signal ya da pthread_cond_broadcast uygulayan tarafın koşul değişkenlerini aşağıdaki gibi mutex kontrolü içerisinde değiştirmesi
    aslında mutlak anlamda gerekmemektedir:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_cond_broadcast(&g_cond);
    pthread_mutex_unlock(&g_mutex);

    Ancak koşulların birden fazla ğeğişkene bağlı olduğu durumda önce mutex kontrolü ile kritik kod içerisinde koşulların ayarlanması 
    gerekebilmektedir. C'deki aslında basit bir atama işlemi bile çok thread'li ortamda senkronizasyon sorunlarına yol açabilmektedir. 

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde durum değişkenleri daha çok aynı prosesin thread'leri arasında kullanılıyor olsa da aslında prosesler arasında 
    da kullanılabilmektedir. Tabii bu durumda koşul değişkeninin ve mutex nesnesinin paylaşılan bellek alanı üzerinde yaratılması ve yaratım 
    sırasında da attribute nesneleri ile prosesler arası kullanım durumunun set edilmesi gerekmektedir. Bu işlem mutex nesnelerindekine benzer 
    biçimde yapılmaktadır:

    pthread_cond_t g_cond;
    ...
    pthread_condattr_t attr;

    pthread_condattr_init(&attr);
    pthread_condattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&g_cond, &attr);
    pthread_condattr_destroy(&attr);

-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Daha önce de belirttiğimiz gibi belli bir zamandan sonra Windows sistemlerine de durum değişkenleri eklenmiştir. Windows sistemlerindeki 
    durum değişkenleri mutex nesneleriyle değil CRITICAL_SECTION ve Read/Write Lock nesneleriyle kullanılabilmektedir. Genel kullanım biçimi 
    UNIX/Linux sistemlerindekine çok benzemektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir thread'in çalışmasına ara verilmesi preemptive bir biçimde donanım kesmeleri yoluyla yapılmaktadır. İşlemci bir makine komutunu 
    çalıştırırken kesme oluşsa bile makine komutunun çalışması bitmeden kesme konumuna geçmez. Yani iki komut arasında kesmeleri işleme sokmaktadır. 
    Thread'ler dünyasında bir işlemin "atomik (atomic)" yapılması "kesilmeden yapılması" anlamına gelmektedir. O halde makine komutları atomiktir. 
    Aşağıdaki işleme bakınız:

    ++g_count;

    Böyle bir kod genellikle derleyiciler tarafından tek bir makine komutuyla değil birkaç makine komutuyla yapılmaktadır. Örneğin Intel 
    işlemcilerinde bu işlem için derleyici aşağıdaki gibi üç makine komutu üretebilmektedir:

    MOV EAX, g_count
    INC    EAX
    MOV g_count, EAX

    İşte komutlar arasında thread'ler arası geçiş (context switch) oluşursa daha önce ele aldığımız senkronizasyon sorunları oluşacaktır. 
    Aslında ++g_count işlemi bazı işlemcilerde tek bir makine komutuyla da yapılabilmektedir. Örneğin bu işlem Intel işlemcilerinde aşağıdaki 
    gibi tek bir makine komutuyla da yapılabilmektedir: 

    INC g_count

    Makine komutları atomik olduğuna göre bu işlem çok thread'li ortamlarda tamamen güvenli midir? İşte makine komutları arasında thread'ler
    arası geçiş oluşmamakla birlikte  çok işlemcili ya da çok çekirdekli sistemlerde başka bir sorun da ortaya çıkmaktadır. İşlemcilerin 
    bazılarında birden fazla çekirdek aynı bellek adresine erişirken oradaki bilgiyi bozabilmektedir. Bunun donanımsal olarak nasıl gerçekleştiği 
    üzerinde burada durmayacağız. Böyle bir olasılık düşük olsa da maalesef yine de bulunmaktadır. Yine bir çekirdek bir bellek adresine 
    bir değer yazarken diğer bir çekirdek oradan değer okumak istediğinde okuyan taraf önceki ya da sonraki değeri değil bozuk bir değeri de 
    okuyabilmektedir. Bu durumda maalesef tek bir değişken bile iki thread arasında anlık kullanılacak olsa yine de bu işlemin senkronize
    edilmesi gerekmektedir. Ancak bir tek değişkene bir değer atamak için mutex gibi bir senkronizasyon nesnesini kullanmak performansı 
    düşürmektedir. Aslında işlemcileri tasarlayanlar bunun çaresini de düşünmüşlerdir. Bir makine komutunun diğer çekirdekleri ya da işlemcileri 
    o komutluk durdurarak yalnızca o komutu çalıştıran işlemci ya da çekirdeğin belleğe erişmesi sağlanabilmektedir. Örneğin Intel işlemcilerinde 
    bir makine komutunun başına LOCK öneki getirilirse işlemci o komutu diğer işlemcileri durdurarak çalıştırmaktadır:

    LOCK INC g_count

    Bu işlem artık Intel işlemcilerinde çok çekirdekli sistemlerde de sorunu çözecektir. Tabii buradaki LOCK öneki performansı da düşürmektedir. 
    Derleyicinin her komutta bu öneki kullanması kodun yavaş çalışmasına yol açacaktır. Pekyi biz C programcısı olarak derleyicinin böyle 
    bir kod üretmesini nasıl sağlayabiliriz?
/*------------------------------------------------------------------------------------------------------------------------------------------

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde diğer işlemcileri bir komutluk durdurarak bellek işlemi yapabilmek için tasarlanmış başı Interlocked ile başlayan 
    InterlockedXXX biçiminde API fonksiyonları vardır. Tabii bu fonksiyonların içi sembolik makine dilinde yazılmıştır. Önemli birkaç Interlocked 
    fonksiyonlarının prototiplerini aşağıda veriyoruz:

    LONG InterlockedIncrement(LONG volatile *Addend);
    LONG InterlockedAdd(LONG volatile *Addend, LONG Value);
    LONG InterlockedDecrement(LONG volatile *Addend);
    LONG InterlockedExchange(LONG volatile *Target, LONG Value);

    Aslında çok fazla Interlocked fonksiyon bulunmaktadır. Bunların listesi için aşağıdaki MSDN dokümanlarına başvurabilirsiniz:
    
    https://learn.microsoft.com/en-us/windows/win32/sync/synchronization-functions
    
    Yukarıdaki fonksiyonlar long türden nesnelerin adreslerini parametre olarak almaktadır. Interlocked fonksiyonlarının genellikle tek bir 
    makine komutuyla yapılabilecek işlemler için bulundurulduğuna dikkat ediniz. 

    Aşağıdaki örnekte iki thread de aynı global değişkeni bir milyon kez artırmıştır. Ancak bu işlemi yukarıda görmüş olduğumuz InterllockedIncrement 
    fonksiyonuyla yapmıştır. Bu fonksiyon bir nesneyi atomik olarak tek bir makine komutuyla diğer işlemcileri durdurarak artırmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

long g_count;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    printf("%ld\n", g_count);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    long i;

    for (i = 0; i < 1000000; ++i)
        InterlockedIncrement(&g_count);

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    long i;

    for (i = 0; i < 1000000; ++i)
        InterlockedIncrement(&g_count);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Derleyiciler tarafından doğrudan tanınan çağrılması için prototipe gereksinim duyulmayan ve genellikle derleyicilerin CALL makine komutu
    yerine inline fonksiyon gibi açım yaptığı özel fonksiyonlara "built-in" ya da "intrinsic" fonksiyon denilmektedir. C derleyicilerinin bir 
    bölümü bazı standart C fonksiyonlarını ve kendilerine özgü bazı eklenti (extension) fonksiyonları bu biçimde ele almaktadır. Microsoft C 
    derleyicilerinde, gcc ve clang derleyicilerinde "built-in" ya da "intrinsic" fonksiyonlar bulunmaktadır. Microsoft C derleyicilerinin 
    "intrinsic" fonksiyon listesine aşağıdaki bağlantıdan ulaşabilirsiniz:

    https://learn.microsoft.com/en-us/cpp/intrinsics/compiler-intrinsics?view=msvc-170

    gcc Derleyicilerinin built-in fonksiyonlarına da aşağıdaki bağlantılardan ulaşabilirsiniz:

    https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html
    https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html

    gcc'de bazı built-in fonksiyonlar atomik işlemler için bulundurulmuştur. Bunları Microsoft'un InterlockedXXX fonksiyonlarına benzetebilirsiniz. 
    Ancak gcc'de önceleri bu atomic built-in fonksiyonlar __sync_xxx biçiminde isimlendirilmişti. Sonra C++'a <atomic> kütüphanesi eklenince 
    C++ kütüphanesi de kullanabilsin diye bu eski __sync_xxx isimli fonksiyonlar yerine bunların "memory model" parametresi alan __atomic_xxx 
    versiyonları oluşturuldu. Artık yeni programların __atomic_xxx biçimindeki bu yeni fonksiyonları kullanması tavsiye edilmektedir. Her iki 
    fonksiyon grubunun dokümanlarına ilişkin bağlantıları aşağıda veriyoruz:

    https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/_005f_005fatomic-Builtins.html
    https://gcc.gnu.org/onlinedocs/gcc-4.1.0/gcc/Atomic-Builtins.html

    __atomic_xxx fonksiyonlarındaki "memory model" parametresi __ATOMIC_SEQ_CST olarak girilebilir. Biz burada bu memory model  parametresinin 
    ne anlam ifade ettiği üzerinde durmayacağız. 

    Örneğin bir nesneyi atomic bir biçimde 1 artırmak isteyelim. Hiç mutex kullanmadan bunu gcc derleyicilerinde şöyle yapabiliriz:

    __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    Bir değişkene yalnızca değer atamak için aşağıdaki atomic fonksiyon kullanılabilir:

    void __atomic_store_n(type *ptr, type val, int memmodel);
    void __atomic_store(type *ptr, type *val, int memmodel);

    Benzer biçimde bir nesnenin içerisindeki değeri almak için de aşağıdaki atomic fonksiyonlar kullanılabilir:

    void __atomic_load_n (type *ptr, int memmodel);
    void __atomic_load (type *ptr, type *ret, int memmodel);

    Aşağıdaki örnekte iki thread aynı global değişkeni artırmaktadır. Biz daha önce bu örneği çeşitli senkronizasyon nesneleriyle zaten 
    yapmıştık. Burada hiç senkronizasyon nesnesi kullanmadan gcc'nin atomic built-in fonksiyonlarıyla aynı şeyi yapıyoruz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* atomic.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT        100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < MAX_COUNT; ++i)
        __atomic_fetch_add(&g_count, 1, __ATOMIC_SEQ_CST);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    C11 ile birlikte C'ye isteğe bağlı olarak _Atomic biçiminde bir tür belirleyicisi ve niteleyicisi de eklenmiştir. _Atomic ile tanımlanan 
    nesneler için derleyiciler atomik işlem yapacak biçimde kod üretmektedir. Tabii bu _Atomic belirleyicisi atomic yapılamayack işlemlerde
    bir etki göstermemektedir. Bir C11 derleyicisinin _Atomic belirleyicisini destekleyip desteklemediği __STDC_NO_ATOMICS__  makrosuna
    bakılarak belirlenebilir. Microsoft C derleyicileri henüz _Atomic belirleyicisini desteklememektedir. Ancak gcc derleyicileri belli bir 
    sürümden sonra bu belirleyiciyi desteklemektedir. Ayrıca C11 ile birlikte <atomic.h> başlık dosyasında aşağıdaki gibi tür makroları da 
    bulundurulmuştur:

    atomic_bool            _Atomic _Bool
    atomic_char            _Atomic char
    atomic_schar        _Atomic signed char
    atomic_uchar        _Atomic unsigned char
    atomic_short        _Atomic short
    atomic_ushort        _Atomic unsigned short
    atomic_int            _Atomic int
    atomic_uint            _Atomic unsigned int
    atomic_long            _Atomic long
    atomic_ulong        _Atomic unsigned long
    atomic_llong        _Atomic long long
    ...

    Bunların tam listesi için standartlara başvurabilirsiniz. Yine C++11 ile birlikte atomik işlem yapan fonksiyonlar da isteğe bağlı olarak 
    standart hale getirilmiştir. Bunların bazılarını aşağıda veriyoruz:

    atomic_store
    atomic_store_explicit 
    atomic_load
    atomic_load_explicit
    atomic_exchange
    atomic_exchange_explicit
    atomic_compare_exchange_strong
    atomic_compare_exchange_strong_explicit
    atomic_compare_exchange_weak
    atomic_compare_exchange_weak_explicit
    atomic_fetch_add
    atomic_fetch_add_explicit
    atomic_fetch_sub
    atomic_fetch_sub_explicit

    Aşağıdaki örnekte g_count global değişkeni _Atomic ile tanımlandığı için zaten ++g_count işlemi derleyici tarafından atomik bir biçimde 
    yapılacaktır. Başka bir deyişle derleyici bu değişken işleme sokulurken onu tek bir makine komutuyla ve lock işlemi ile işleme sokmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

_Atomic int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    srand(time(NULL));
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta C'nin _Atomic belirleyicisi yoktur. (Genel olarak C++ Programlama Dili C Programlama Dilini kapsıyor olsa da bu kapsama mükemmel 
    düzeyde değildir. C++'ta atomik işlemler <atomic> başlık dosyasında bildirilen std::atomic<T> isimli sınıf şabşlonuyla yapılmaktadır. 
    Bu sınıfın operatör fonksiyonları gerçekten çok işlemcili sistemler için atomik işlemler yapmaktadır. Dolayısıyla yukarıdaki işlemlerin 
    C++'taki eşdeğerleri aşağıdaki gibi oluşturulabilir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>
#include <cstdlib>
#include <atomic>
#include <windows.h>

using namespace std;

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

atomic<int> g_count;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    printf("%ld\n", (int)g_count);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    long i;

    for (i = 0; i < 1000000; ++i)
        ++g_count;

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    long i;

    for (i = 0; i < 1000000; ++i)
        ++g_count;

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon farklı thread'lerden aynı anda çağrıldığında herhangi bir sorun oluşmuyorsa o fonksiyon thread güvenlidir. Yani "thread 
    güvenlilik (thread safety)" birden fazla thread tarafından aynı anda çağrılan fonksiyonların sorun çıkartmaması anlamına gelmektedir. 
    Pekiyi thread güvenliliği bozan faktörler nelerdir? İşte eğer fonksiyon bir "statik data" kullanıyorsa (yani global bir nesneyi ya da 
    static yerel bir nesneyi kullanıyorsa) o fonksiyon thread güvenli olamaz. Çünkü global değişkenlerin ve static yerel değişkenlerin 
    toplamda tek bir kopyası vardır. Thread akışları aynı fonksiyonda ilerlerken aynı kopya üzerinde işlem yaptıklarından dolayı bir anomali 
    oluşabilecektir. Örneğin:

    void foo(void)
    {
        static int a = 0;
        
        ++a;
        ...
        ++a
        ...
        ++a;
        ...
    }

    Burada bu foo fonksiyonu farklı thread'lerden aynı anda çağrıldığında bu farklı thread'ler static nesnenin aynı kopyasını kullanacağından 
    dolayı bir bozulma oluşacaktır. static yerel nesnelerin stack'te değil "data" ya da "bss" alanlarında yaratıldığını anımsayınız.
    Aynı durum global nesne kullanan fonksiyonlar için de geçerlidir. Yukarıda da belirttiğimiz gibi "thread güvenlilik (thread safety)" 
    bir fonksiyonun farklı thread'ler tarafından aynı anda çağrıldığında sorun oluşmaması anlamına gelmektedir. Thread güvenliliği bozan 
    en faktör "static data" kullanımıdır. Yani programın static yerel ya da global nesneleri kullanmasıdır. Örneğin:

    char *myitoa(int a)
    {
        static char buf[32];

        sprintf(buf, "%d", a);

        return buf;
    }

    Burada myitoa thread güvenli değildir. Çünkü bu fonksiyon birden fazla thread tarafından aynı anda (iç içe geçecek biçimde) çağrılırsa
    sorun oluşacaktır. Çünkü iki çağrının kullandığı yerel nesne aynı nesnedir. 

    Pekiyi fonksiyonu "thread güvensiz" yapan şey nedir? Eğer bir fonksiyon statik veri kullanıyorsa (yani static yerel nesneler ya da global 
    nesneler) fonksiyon thread güvenli olmaz. Ortak kaynakları kullanan fonksiyonlar thread güvenli değildir. Mademki fonksiyonu thread güvenli 
    olmaktan çıkartan faktör fonksiyonun statik veri kullanmasıdır. O halde biz fonksiyonu static data kullanmaktan çıkartırsak thread güvenli 
    hale getirmiş oluruz. Örneğin:

    char *myitoa_tsafe(char *buf, int a)
    {
        sprintf(str, "%d", a);

        return buf;
    }

    Burada myitoa fonksiyonu artık static yerel bir dizinin adresiyle geri dönmemektedir. Ona geçirilen adresle geri dönmektedir. Örnek 
    bir kullanım şöyle olabilir:
        
    char s[100];

    myitoa_tsafe(s, 123456)

    Burada myitoa_tsafe fonksiyonu artık farklı thread'ler tarafından aynı anda çağrılsa bile bir sorun oluşmayacaktır. (Tabii burada s dizisinin 
    yerel bir dizi olduğunu kabul ediyoruz.)
-------------------------------------------------------------------------------------------------------------------------------------------*/
 
/*------------------------------------------------------------------------------------------------------------------------------------------
    C'nin de bazı standartc fonksiyonları static yerel nesne ya da dizi kullanmaktadır. Dolayısıyla bu fonksiyonlar thread güvenli değildir. 
    Örneğin localtime fonksiyonu thread güvenli değildir. local time fonksiyonunun parametrik yapısını anımsayınız:

    struct tm *localtime(const time_t *timep);

    Burada localtime fonksiyonu struct tm türünden static yerel bir nesnenin adresiyle geri dönmektedir. 

    struct tm *localtime(const time_t *timep)
    {
        static struct tm lt;
        ....

        return &lt;
    }

    Görüldüğü gibi fonksiyon aslında bize bir adres vermektedir, ancak bu adres static yerel bir nesnenin adresidir. Dolayısıyla onun tek 
    bir kopyası vardır. Biz bu fonksiyonu farklı thread'lerden aynı anda çağırırsak aslında aynı nesne üzerinde işlem yapılacağı için bu 
    nesnenin içeriği bozulacaktır. Benzer biçimde ctime fonksiyonu da static yerel bir dizinin adresiyle dönmektedir. Bu fonksiyon da
    thread güvenli değildir. Benzer biçimde rassal sayı üretmekte kullanılan rand fonksiyonu da global bir nesne (tohum nesnesi) kullanmaktadır. 
    Dolayısıyla bu fonksiyon da thread güvenli değildir. Aşağıda C'de thread güvenli olmama potansiyelinde olan standart C fonksiyonlarının 
    listesini veriyoruz:

    strtok
    strerror
    ctime
    gmtime
    localtime
    asctime
    rand
    srand
    tmpnam
    tempnam
    setlocal
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi thread güvenli olmayan bir fonksiyonu nasıl thread güvenli hale getiririz? İlk yapılacak şey şüphesiz fonksiyonun static data 
    (statik yerel ya da global nesneleri kastediyoruz) kullanmasını engellemektir. Static data kullanan programlar thread güvenli olamazlar. 
    Bu durumda fonksiyonu thread güvenli hale getirmek için yapılacak şey onun static data kullanmasını engellemektir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi C'nin standart kütüphanesindeki bazı fonksiyonlar thread güvenli doğaya sahip değilse ne yapabiliriz?  Bu fonksiyonlar izleyen 
    paragraflarda ele alacağımız gibi "thread'e özgü global alanlar" oluşturularak kütüphaleri yazanlar tarafından thread güvenli hale 
    getirilebilirler. Çalıştığınız C derleyicisinin standart kütüphanesinin thrad güvenli olup olmadığını öğrenmelisiniz. 

    C'nin 2011 versiyonuna kadar (C11) C standartlarında thread lafı edilmemişti. Ancak ilk kez C11'de thread kavramı standartlara sokuldu ve
    isteğe bağlı (optional) bir thread kütüphanesi de standartla eklendir. Ancak bu standartlar da yukarıda belirttiğimiz fonksiyonların 
    thread güvenli olup olmadığı konusunda bir açıklama yapmamıştır. Yani özet olarak bir C derleyicisindeki yukarıdakine benzer standart 
    C fonksşyonları thread gğvenli olabilir ya da olmayabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Microsoft 2005 yılına kadar standart C kütüphanesinin thread güvenli olan ve thread güvenli olmayan iki farklı versiyonunu bulundurmaktaydı. 
    Ancak 2005'ten itibaren tek bir standart C kütüphanesi bulundurmaya başlamıştır. O da thread güvenli kütüphanedir. 
    
    POSIX sistemlerinde static data kullanan sorunlu standart C fonksiyonlarının hepsinin xxxxx_r isimli thread güvenli bir versiyonu da 
    bulundurulmuştur. Bu versiyonlar genel olarak static data kullanmak yerine ekstra bir parametre ile static data için kullanılacak alanı 
    fonksiyonu çağırandan istemeketdir. Örneğin localtime ve localtime_r fonksiyonlarının prototipleri şöyledir:

    struct tm *localtime(const time_t *timep);
    struct tm *localtime_r(const time_t *timep, struct tm *result);

    localtime_r fonksiyonu static yerel nesne kullanmamakta parametre olarak alınan struct tm nesnesine yerleştirme yapmaktadır. Tabii 
    fonksiyon parametresiyle aldığı nesnenin adresine geri dönmektedir. Örneğin rand ve rand_r fonksiyonlarının prototipleri şöyledir:

    int rand(void);
    int rand_r(unsigned int *seedp);

    rand_r fonksiyonunun global tohum değişkeni kullanmadığına tohum değişkenini parametre olarak aldığına dikkat ediniz. 

    Aşağıdaki örnekte ctime fonksiyonun thread güvenli versiyonu olan ctime_r fonksiyonu kullanılmıştır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

void *thread_proc1(void* param);
void *thread_proc2(void* param);
void foo(void);
void exit_errno(const char* msg, int result);

int main(void)
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_errno("pthread_create", result);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    return 0;
}

void foo(void)
{
    time_t t;
    char s[64];

    t = time(NULL);
    ctime_r(&t, s);

    printf("%s", s);
}

void *thread_proc1(void *param)
{
    foo();

    return NULL;
}

void *thread_proc2(void *param)
{
    foo();

    return NULL;
}

void exit_errno(const char *msg, int result)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(result));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    C'nin standart FILE stream işlemlerinin thread güvenli olup olmadığı hakkında da bir şey söylenmemiştir. Ancak hem Microsoft C kütüphanesi 
    hem de GNU C kütüphanesi FILE stream işlemlerini thread güveli biçimde yapmaktadır. Yani iki ayrı thread global bir stream nesnesi üzerinde 
    işlem yapıyorsa kullanılan tampon bu fonskiyonlar tarafından kritik kodlarla zaten korunmuş durumdadır. İç içe geçme durumu oluşmamaktadır. 
    Benzer biçimde C++'ın <iostream> kürüphanesi de    aynı dosya üzerinde işlem yapılırken bile thread güvenlidir. Ancak standartlar bunu garanti 
    etmemktedir. 

    Aşağıda Windows sistemlerinde iki thread eş zamanlı olarak aynı dosyaya yazma yapaktadır. Dosya tamponunun her açılan dosya için ayrı 
    bir biçimde oluşturulduğunu anımsayınız. Eğer Windows'ta dosya nesneleri thread güvenli olmasaydı bu yazma işlemlerinde iç içe geçme 
    olabilirdi. Buradaki örnekte "test.txt" dosyasının içini inceleyiniz. İç içe geçmenin olmadığını göreceksiniz. Örneğin:

    ...
    thread-1
    Thread-1
    Thread-1
    Thread-1
    Thread-1
    Thread-2
    Thread-2
    Thread-2
    Thread-2
    Thread-2
    Thread-2
    Thread-1
    Thread-1
    Thread-1
    Thread-1
    Thread-1
    Thread-1
    Thread-1
    ...
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

FILE *g_f;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_f = fopen("test.txt", "w")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000; ++i)
        fprintf(g_f, "Thread-1\n");

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    int i;

    for (i = 0; i < 1000; ++i)
        fprintf(g_f, "Thread-2\n");

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi GNU C Kütüphanesindeki stream işlemleri de thread güvenlidir. Yukarıda vermiş olduğumuz örneğin UNIX/Linux
    karşılığı da aşağıdaki gibidir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

FILE *g_f;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((g_f = fopen("test.txt", "w")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 10000; ++i)
        fprintf(g_f, "Thread-1\n");

    return NULL;
}

void *thread_proc2(void *param)
{
       int i;

    for (i = 0; i < 10000; ++i)
        fprintf(g_f, "Thread-2\n");
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın iostream kütüphanesi de genel olarak Microsoft ve UNIX/Linux sistemlerinde thread güvenli yazılmıştır. Ancak standartlar bağlamında 
    bunun için bir garanti bulunmamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <fstream>
#include <thread>

using namespace std;

fstream g_f;

void thread_proc1()
{
    for (int i = 0; i < 1000; ++i)
        g_f << "thread-1 running...\n";
}

void thread_proc2()
{
    for (int i = 0; i < 1000; ++i)
        g_f << "Thread-2 running...\n";
}

int main(void)
{
    g_f.open("test.txt", ios::out);

    thread t1(thread_proc1);
    thread t2(thread_proc2);

    t1.join();
    t2.join();

    g_f.close();

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Windows sistemlerindeki ReadFile ve WriteFile API fonksiyonları, UNIX/Linux sistemlerindeki read ve 
    write POSIX fonksiyonları işletim sisteminin sistem fonksiyonlarını doğrudan çağırmaktadır. İşletim sisteminin sistem fonksiyonaları da 
    okuma ve yazma bağlamında sistem genelinde atomiktir. Bunun anlamı şudur: Biz iki farklı thread'ten ya da prosesten aynı dosyaya, dosyanın 
    aynı yerine aynı anda yazma ya da okuma yapsak bile iç içe geçme asla oluşmaz. Bu durum kernel tarafından senkronize edilmektedir. Örneğin 
    thread ya da proseslerden biri tam bir dosyanın    belli bir offset'ine WriteFile ya da write fonksiyonuyla 100 byte yazıyor olsun. Tam o 
    sırada da aynı offset'ten başka bir thread ya da proses 100 byte okuyaacak olsun. Bu durumda okuyan taraf ya 100 yazılmadan önceki 100 
    byte'ı okur ya da diğerinin yazdığı 100 byte'ı okur. Ancak asla yarısı eski 100    byte'tan yarısı diğerinin yazdığı 100 byte'tan oluşan bir 
    100 byte okumaz. Benzer biçimde iki thread ya da proses WriteFile ya da write ile aynı dosyanın aynı offset'ine    yazıyor olsalar bile 
    iç içe geçme oluşmamaktadır. Nihai durumda ya birinin ya da diğerinin tam yazdığı şeyler dosyada gözükür. Tabii birden fazla read ya da 
    write işlemi sırasında bu işlemler iç içe geçebilir. Örneğin:

    thread-1
    --------
    write(...)
    write(...)

    thread-2
    ---------
    write(...)
    write(...)

    Burada write çapırmaları atomşktir. Ancak thread!in iki write çağrısı arasına thread2'nin write çağrıları gerebilir.
-------------------------------------------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------------------------------------------------------------------------------------------
    C++'da C++11 ile birlikte standart bir thread kütüphanesi oluşturulmuştur. Tabii aslında bu kütüphane Windows sistemlerinde Windows API
    fonksiyonlarını, UNIX/Linux sistemlerinde POSIX'in pthread fonksiyonalrını kullanmaktadır. Yalnızca arayüz standart hale getirilmiştir. 

    Aşağıda C++'da thread yaratımına bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <thread>

using namespace std;

class Sample {
public:
    Sample(const char *name) : m_name(name)
    {}
    void operator()()
    {
        cout << m_name + "\n";
    }
private:
    string m_name;
};

void thread_proc1()
{
    cout << "thread-1 running...\n";
}

void thread_proc2()
{
    cout << "thread-2 running...\n";;
}

int main(void)
{
    Sample s1("thread-1"), s2("thread-2");

    thread t1(s1);
    thread t2(s2);
    thread t3(thread_proc1);
    thread t4(thread_proc1);

    t1.join();
    t2.join();
    t3.join();
    t4.join();

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Genel olarak C++'ın sınıfları aynı nesne üzerinde okuma konusunda thread güvenli ancak yazma konusunda thread güvenli değildir. Fakat 
    farklı nesneler üzerinde okuma ve yazma işlemleri thread güvenlidir. Bunların standartlarda bu anlamda thread güvenli versionları yoktur.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'e özgü global değişkenler olabilir mi? Yani örneğin iki thread akışı bir global değişkeni kullanırken aslında bunlar farklı global 
    değişkenler olabilir mi? İşte işletim sistemleri uzun süredir bunu sağlamak için mekanizmalar bulundurmaktadır. Windows sistemlerinde 
    thread'e özgü global değişken oluşturma mekanizmasına "Thread Local Storage (TLS)", UNIX/Linux sistemlerinde ise "Thread Specific Data
    (TSD)" denilmektedir. Hatta C11 ile birlikte C standartlarına _Thread_local isimli, C++11 ile C++ standartlarına thread_local isimli 
    yer belirleyici (storage class specifier) anahtar sözcükler sokulmuştur. Yani artık C ve C++'ta işletim sisteminin API fonksiyonlarını
    ve POSIX fonksiyonlarını kullanmadan da thread'e özgü global dğeişkenler kullanılabilmektedir. Örneğin:

    _Thread_local int g_tl;

    Burada aslında bir g_tl nesnesi yoktur. Yaratılmış olan ve yaratılacak olan tüm thread'lerin birbirinden ayrı birer g_tl nesneleri vardır. 

    Aşağıdaki örnekte C11 ile C'e sokulan _Thread_local belirleyicisi kullanılarak bir global değişken oluşturulmuştur. Bu global değişkenin 
    her thread için ayrı bir kopyası bulunmaktadır. Aşağıdaki örnekte bu durum görülmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void Foo(const char *str);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

 _Thread_local int g_tl;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    Foo("Main Thread");        /* Main Thread: 0 */

    return 0;
}

void Foo(const char *str)
{
    printf("%s: %d\n", str, g_tl);
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    g_tl = 10;

    Sleep(5000);
    Foo("Thread1");                /* THread: 10 */
    
    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    g_tl = 20;
    Foo("Thread2");                /* Thread2: 20 */

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında thread'e özgü global alanlar işletim sisteminin desteğiyle oluşturulmaktadır. C ve C++ derleyicileri 
    de arka planda aslında izleyen paragraflarda ele alacağımız gibi işletim sisteminin bu mekanizmalarını kullanarak thread'e özgü global
    değişkenler oluşturabilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta her thread için işletim sistemi TLS adı altında slotlardan oluşan bir dizi ayırmaktadır. Slotların indeksleri DWORD türüyle
    temsil edilmektedir. Belli bir slot indeksi her thread'te ayrı bir alan belirtir. 
    
    Windows'ta TLS (Thread Local Storage) kullanımı şu adımlardan geçilerek sağlanmaktadır:

    1) Önce henüz thread'ler yaratılmadan TlsAlloc API fonksiyonuyla bir TLS slotu yaratılır. TlsAlloc fonksiyonunun prototipi şöyledir:

    DWORD TlsAlloc(void);

    Fonksiyon parametre almamaktadır. Geri dönüş değeri olarak TLS alanında bir slot indeksi vermektedir. Bu slot indeksi yaratılmış olan ve 
    yaratılacak olan her thread için kullanılabilir ve farklı bir alan belirtmektedir. Programcı tipik olarak bu slot indeksini global 
    nesnede saklar. Fonksiyon başarısızlık durumunda TLS_OUT_OF_INDEXES özel değerine geri dönmektedir. Windows sistemlerinde toplam 1086
    slot bulunmaktadır. Örneğin:

    DWORD g_slot;
    ...

    if ((g_slot = TlsAlloc()) == TLS_OUT_OF_INDEXES)
        ExitSys("TlsAlloc");

    2) Artık her thread aynı slot indeksini kullanarak slota bir adres yerleştirebilir. Slot indeksleri aynı olsa da aslında bu slotlar 
    farklı thread'lerde olduğu için her thread kendi slotunu kullanıyor olacaktır. Slota adres yerleştiren TlsSetValue fonksiyonunun prototipi
    şöyledir:

    BOOL TlsSetValue(
        DWORD  dwTlsIndex,
        LPVOID lpTlsValue
    );
    
    Fonksiyonun birinci parametresi TLS slot indeksini, ikinci parametresi ise slota yerleştirilecek adres belirtmektedir. Fonksiyon başarı 
    durumunda sıfır dışı bir değer başarısızlık durumunda 0 değerine geri dönmektedir. Biz aslında malloc ile tahsisat yapıp slota tahsis 
    ettiğimiz alanın adresini yerleştirebiliriz. Böylece tek bir slot ile istediğimiz kadar thread'e özgü global nesne oluşturmuş oluruz. 
    Örneğin:

    struct THREAD_LOCAL_DATA {
        int a;
        int b;
        ibt c;
    };

    struct THREAD_LOCAL_DATA *tld;
    ...

    if ((tld = (struct THREAD_LOCAL_DATA *)malloc(sizeof(struct THREAD_LOCAL_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }
    tld->a = 10;
    tld->b = 20;
    tld->c = 30;

    if (!TlsSetValue(g_slot, tld))
        ExitSys("TlsSetValue");

    3) Değer TLS slotundan geri almak için TLSGetValue fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    LPVOID TlsGetValue(
        DWORD dwTlsIndex
    );

    Fonsiyon TLS slot indeksini parametre olarak alır ve oraya set edilmiş adresi geri dönüş değeri olarak verir. Fonksiyon başarısızlık 
    durumunda NULL adrese geri dönmektedir. Tabii yaratılmamış bir slot adresi geçmedikten sonra fonksiyonun başarısız olma olasılığı yoktur. 
    Dolayısyla fonksiyonun geri dönüş değerini kontrol etmeyebilirsiniz. Örneğin:

    struct THREAD_LOCAL_DATA *tld;
    ...

    if ((tld = (struct THREAD_LOCAL_DATA *)TlsGetValue(g_slot)) == NULL)
        ExitSys("TlsGetValue");

    Ancak gerçekten solota NULL adres de yerleştirilebilir. Bu durumda fonksiyon NULL adrese geri döndüğünde GetLastError değerine bakılmalıdır. 
    Eğer GetLastError ERROR_SUCESS değerindeyse işlem başarılıdır ve gerçekten slota yerleştirilen NULL adres geri alınmıştır. Ancak GetLastError 
    başka bir değer geri döndürürse işlemin başarısız olduğu sonucu çıkartılmalıdır.  

    4) Slot kullanımı bittikten sonra slotun TlsFree fonksiyonu ile serbest hale getirilmesi gerekir. TlsFree fonksiyonunun prototipi şöyledir:

    BOOL TlsFree(
        DWORD dwTlsIndex
    );

    Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri dönmektedir. Tabii her şey doğrıu yapılmışsa
    fonksiyonun başarısız olma olsaılığı da yoktur. 

    Aşağıda bir örnek verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void Foo(const char *str);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

DWORD g_slot;

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_slot = TlsAlloc()) == TLS_OUT_OF_INDEXES)
        ExitSys("TlsAlloc");

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    Foo("Main Thread");

    TlsFree(g_slot);

    return 0;
}

void Foo(const char *str)
{
    int *pVal;

    if ((pVal = (int *)TlsGetValue(g_slot)) == NULL && GetLastError() != ERROR_SUCCESS)
        ExitSys("TlsGetValue");

    printf("%d\n", (int)pVal);
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    if (!TlsSetValue(g_slot, (LPVOID)10))        /* g_tl = 10 */
        ExitSys("TlsSetValue");

    Sleep(5000);
    Foo("Thread1");
    
    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    if (!TlsSetValue(g_slot, (LPVOID)20))        /* g_tl = 20 */
        ExitSys("TlsSetValue");

    Foo("Thread2");

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                89. Ders 18/05/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar TlsSetValue ile slota yalnızca bir adres yerleştirebiliyorsak da aslında dinamik tahsisat yapıp bu alanın adresini slota 
    yerleştirebiliriz. Böylece istediğimiz kadar çok bilgiyi thread'e özgü biçimde kullanabiliriz. Örneğin:

    struct THREAD_DATA {
        int a;
        int b;
        int c;
    };
    ...
    struct THREAD_DATA *td;

    td = (struct THREAD_DATA *)malloc(sizeof(struct THREAD_DATA));
    td->a = 10;
    td->b = 20;
    td->c = 30;

    TlsSetValue(g_slot, td);

    Aşağıda bu yöntemle birden fazla bilginin slota yerleştirilmesine ilişkin bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void Foo(const char *str);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg);

DWORD g_slot;

struct THREAD_DATA {
    int a;
    int b;
    int c;
};

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if ((g_slot = TlsAlloc()) == TLS_OUT_OF_INDEXES)
        ExitSys("TlsAlloc");

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    Foo("Main Thread");

    TlsFree(g_slot);

    return 0;
}

void Foo(const char *str)
{
    struct THREAD_DATA* td;

    if ((td = (struct THREAD_DATA *)TlsGetValue(g_slot)) == NULL && GetLastError() != ERROR_SUCCESS)
        ExitSys("TlsGetValue");

    printf("%s: %d, %d, %d\n", str, td->a, td->b, td->c);
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    struct THREAD_DATA* td;

    if ((td = (struct THREAD_DATA*)malloc(sizeof(struct THREAD_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }
    td->a = 10;
    td->b = 20;
    td->c = 30;

    if (!TlsSetValue(g_slot, td))        
        ExitSys("TlsSetValue");

    Sleep(5000);
    Foo("Thread1");

    free(td);
    
    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    struct THREAD_DATA* td;

    if ((td = (struct THREAD_DATA*)malloc(sizeof(struct THREAD_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }
    td->a = 100;
    td->b = 200;
    td->c = 300;

    if (!TlsSetValue(g_slot, td))
        ExitSys("TlsSetValue");

    Foo("Thread2");

    free(td);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Standart C kütüphanesi fonksiyonların parametrik yapılarını değiştirmeden nasıl thread güvenli hale getirilir? İşte böyle bir faaliyette 
    bazı fonksiyonlar statik nesneleri kullanmak yerine TLS içerisindeki nesneleri kullanmalıdır. Aşağıdaki örnekte bu işlemin mantıksal olarak
    nasıl yapılabileceği gösterilmiştir. Bu örnekte thread güvenli kütüphane için programın başında ve sonunda, her thread'in başında ve sonunda 
    init ve exit fonksiyonlarının çağrılması gerekmektedir. Aslında bu çağrılar programcıdan gizlenebilir. Şöyle ki: Eğer dinamik kütüphane söz
    konusuysa dinamik kütüphanenin bazı fonksiyonları bu tür durumlarda otomatik olarak çağrılmaktadır. İşte programcı da bu kodları aslında 
    kendi kütüphanesinin içerine alabilmektedir. Ancak statik kütüphanelerde böyle bir callback mekanizması yoktur. Microsoft bunun için standart 
    C kütüphanesinin statik versiyonunu yazarken mecburen sarma thread fonksiyonları kullanmıştır. _beginthreadex fonksiyonu statik standart C 
    kütüphanesi kullanılacaksa thread yaratmak için tercih edilmelidir. Bu fonksiyon aslında arka planda CreateThread API fonksiyonunu zaten 
    çağırmaktadır. Ancak threda yaratılmadan önce ve thread sonlanırken aşağıdaki kodda bulunan init ve exit gibi fonksiyonlar bu sarma fonksiyon 
    tarafından çağrılır. Benzer biçimde eğer Microsoft sistemlerinde statik kütüphane kullanılıyorsa thread sonlanırken _endthreadex fonksiyonu 
    çağrılmalıdır. Dinamik kütüphanelerde bu sarma fonksiyonların kullanılmasına gerek yoktur. Ayrıca gcc derleyicilerinde standart C
    fonksiyonlarının thread güvenli olmadığını bunların thread güvenli versiyonlarının farklı parametrik yapılarla statik nesne kullanmayack 
    biçimde xxxxx_r ismiyle yazıldığını anımsayınız. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* cstdlib.h */

#ifndef CSTDLIB_H_
#define CSTDLIB_H_

#include <stddef.h>

/* Type Definitions */

typedef struct tagCSTDLIB_STATIC_DATA {
    char *strtok_pos;
    size_t rand_next;
} CSTDLIB_STATIC_DATA;

/* Function Prototypes */

int init_cstdlib(void);
void exit_cstdlib(void);
int init_csdlib_thread(void);
int exit_csdlib_thread(void);
char *csd_strtok(char *str, const char *delim);
void csd_srand(size_t seed);
int csd_rand(void);

#endif

/* cstdlib.c */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "cstdlib.h"

static DWORD g_cstdSlot;

int init_cstdlib(void)
{
    CSTDLIB_STATIC_DATA *clib;

    if ((g_cstdSlot = TlsAlloc()) == TLS_OUT_OF_INDEXES)
        return 0;

    return 1;
}

int init_csdlib_thread(void)
{
    CSTDLIB_STATIC_DATA *clib;

    if ((clib = (CSTDLIB_STATIC_DATA *)malloc(sizeof(CSTDLIB_STATIC_DATA))) == NULL) {
        TlsFree(g_cstdSlot);
        return 0;
    }

    clib->rand_next = 1;

    if (!TlsSetValue(g_cstdSlot, clib))
        return 0;
}

int exit_csdlib_thread(void)
{
    CSTDLIB_STATIC_DATA *clib;

    if ((clib = (CSTDLIB_STATIC_DATA *)malloc(sizeof(CSTDLIB_STATIC_DATA))) == NULL) {
        TlsFree(g_cstdSlot);
        return 0;
    }

    free(clib);
}

void exit_cstdlib(void)
{
    TlsFree(g_cstdSlot);
}

char *csd_strtok(char *str, const char *delim)
{
    CSTDLIB_STATIC_DATA *clib;
    char *beg;

    if ((clib = TlsGetValue(g_cstdSlot)) == NULL)
        return NULL;

    if (str != NULL)
        clib->strtok_pos = str;

    while (*clib->strtok_pos != '\0' && strchr(delim, *clib->strtok_pos) != NULL)
        ++clib->strtok_pos;
    if (*clib->strtok_pos == '\0')
        return NULL;
    beg = clib->strtok_pos;
    while (*clib->strtok_pos != '\0' && strchr(delim, *clib->strtok_pos) == NULL)
        ++clib->strtok_pos;
    if (*clib->strtok_pos != '\0')
        *clib->strtok_pos++ = '\0';

    return beg;
}

void csd_srand(size_t seed)
{
    CSTDLIB_STATIC_DATA *clib;

    if ((clib = TlsGetValue(g_cstdSlot)) == NULL)
        return NULL;

    clib->rand_next = seed;
}

int csd_rand(void)
{
    CSTDLIB_STATIC_DATA *clib;

    if ((clib = TlsGetValue(g_cstdSlot)) == NULL)
        return NULL;

    clib->rand_next = clib->rand_next * 1103515245 + 12345;

    return (unsigned int)(clib->rand_next / 65536) % 32768;
}

/* Sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include "cstdlib.h"

void ExitSys(LPCSTR lpszMsg);
DWORD __stdcall ThreadProc1(LPVOID lpvParam);
DWORD __stdcall ThreadProc2(LPVOID lpvParam);

int main(void)
{
    HANDLE hThread1, hThread2;
    DWORD dwThreadID1, dwThreadID2;

    if (!init_cstdlib()) {
        fprintf(stderr, "cannot initialize CSD Standard C Library!..\n");
        exit(EXIT_FAILURE);
    }

    if ((hThread1 = CreateThread(NULL, 0, ThreadProc1, NULL, 0, &dwThreadID1)) == NULL)
        ExitSys("CreateThread");

    if ((hThread2 = CreateThread(NULL, 0, ThreadProc2, NULL, 0, &dwThreadID2)) == NULL)
        ExitSys("CreateThread");

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    exit_cstdlib();

    return 0;
}

DWORD __stdcall ThreadProc1(LPVOID lpvParam)
{
    char s[] = "ali, veli, selami, ayşe, fatma";
    char *str;
    int i, val;

    if (!init_csdlib_thread()) {
        fprintf(stderr, "CSDLib initialization failed!..\n");
        exit(EXIT_FAILURE);
    }

    for (str = csd_strtok(s, ", "); str != NULL; str = csd_strtok(NULL, ", "))
        printf("threadproc1 --> %s\n", str);

    for (i = 0; i < 10; ++i) {
        val = csd_rand();
        printf("threadproc1_rand --> %d\n", val);
    }

    exit_csdlib_thread();

    return 0;
}

DWORD __stdcall ThreadProc2(LPVOID lpvParam)
{
    char s[] = "adana, izmir, balikesir, muğla";
    char *str;
    int i, val;

    if (!init_csdlib_thread()) {
        fprintf(stderr, "CSDLib initialization failed!..\n");
        exit(EXIT_FAILURE);
    }

    for (str = csd_strtok(s, ", "); str != NULL; str = csd_strtok(NULL, ", "))
        printf("threadproc2 --> %s\n", str);

    for (i = 0; i < 10; ++i) {
        val = csd_rand();
        printf("threadproc2_rand --> %d\n", val);
    }

    exit_csdlib_thread();

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde thread'e özgü statik alanlara "Thread Specific Data (TSD)" denilmektedir. Genel kullanım biçimi Windows 
    sistemlerindekilere    oldukça benzemektedir. Sırasıyla şunlar yapılmalıdır:

    1) Önce pthread_key_create fonksiyonu ile TSD için bir slot yaratılır. pthread_key_create fonksiyonunu işlev olarak TlsAlloc fonksiyonuna
    benzetebiliriz. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));

    Fonksiyonun birinci parametresi slot anahtarının yerleştirileceği pthread_key_t türünden nesnenin adresini almaktadır. Fonksiyon slot anahtar
    bilgisini bu nesnenin içerisine yerleştirmektedir. Tipik olarak programcı bu türden global bir nesne tanımlar. Onun adresini fonksiyona geçirir. 
    Fonksiyonun ikinci parametresi thread sonlandığında çağrılacak callback fonksiyonun adresini almaktadır. Bu parametre NULL geçilebilir. 
    Bu durumda sonlanma sırasında fonksiyon çağrılmaz. Fonksiyon başarı durumunda sıfır değerine başarısızlık durumunda errno değerine geri dönmektedir.
    
    2) TSD slotuna yerleştirme yapmak için pthread_setspecific slottan değer almak için ise pthread_getspecific fonksiyonları kullanılmaktadır.
    Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_setspecific(pthread_key_t key, const void *value);
    void *pthread_getspecific(pthread_key_t key);

    pthread_setspecific fonksiyonunun birinci parametresi slotu belirten pthread_key_t türünden nesneyi ikinci parametresi ise o slota yerleştirilecek 
    adresi almaktadır. pthread_getspecific fonksiyonu da slota yerleştirilmiş olan adres değerini vermektedir.Bu fonksiyonları Windows'taki 
    TlsSetValue ve TlsGetValue fonksiyonlarına benzetebiliriz. pthread_setspecific fonksiyonu başarı durumunda 0 değerine başarısızlık durumunda 
    ise errno değerine geri dönmektedir. pthread_getspecific fonksiyonu başarısızlık durumunda NULL adrese geri dönmektedir. 

    3) Kullanım bittikten sonra elde edilen slot pthread_key_delete fonksiyonu ile isteme iade edilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_key_delete(pthread_key_t key);

    Fonksiyon slota ilişkin pthread_key_t türünden nesneyi parametre olarak alır. Başarı durumunda sıfır değerine, başarısızlık durumunda 
    errno değerine geri döner.

    pthread_key_create fonksiyonunun ikinci parametresine geçirilecek destructor fonksiyonunun parametrik yapısı şöyle olmalıdır:

    void destructor(void *value);

    Fonksiyona TSD alanına yerleştirilmiş olan slottaki adres parametre olarak geirilmektedir. Tipik olarak programcılar bu fonksiyonda 
    dinamik tahsis edilen alanları free hale getirirler.

    Aşağıda UNIX/Linux sistemlerinde TSD kullanımına ilişkin bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void foo(const char *str);
void destructor(void *value);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

struct THREAD_DATA {
    int a;
    int b;
    int c;
};

pthread_key_t g_tsdkey;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_key_create(&g_tsdkey, destructor)) != 0)
        exit_sys_errno("pthread_key_create", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_key_delete(g_tsdkey)) != 0)
        exit_sys_errno("pthread_key_delete", result);

    return 0;
}

void foo(const char *str)
{
    struct THREAD_DATA *td;

    if ((td = (struct THREAD_DATA *)pthread_getspecific(g_tsdkey)) == NULL) {
        fprintf(stderr, "cannot get key value!..\n");
        exit(EXIT_FAILURE);
    }

    printf("%s: %d, %d, %d\n", str, td->a, td->b, td->c);
}

void destructor(void *value)
{   
    free(value);
}

void *thread_proc1(void *param)
{
    struct THREAD_DATA* td;
    int result;

    if ((td = (struct THREAD_DATA*)malloc(sizeof(struct THREAD_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }
    td->a = 10;
    td->b = 20;
    td->c = 30;

    if ((result = pthread_setspecific(g_tsdkey, td)) != 0)
         exit_sys_errno("pthread_setspecific", result);

    sleep(5);
    foo("Thread1");

    return NULL;
}

void *thread_proc2(void *param)
{
    struct THREAD_DATA* td;
    int result;

    if ((td = (struct THREAD_DATA*)malloc(sizeof(struct THREAD_DATA))) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }
    td->a = 100;
    td->b = 200;
    td->c = 300;
  
     if ((result = pthread_setspecific(g_tsdkey, td)) != 0)
         exit_sys_errno("pthread_setspecific", result);

    foo("Thread2");

    return NULL;
}


void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                90. Ders 25/05/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bugün işletim sistemlerinde en çok kullanılan çizelgeleme tekniği öncelik dereceleri dikkate alınarak uygulanan "döngüsel çizelgeleme 
    (round robin scheduling)" denilen tekniktir. Döngüsel çizelgelemede her thread sırasıyla çalıştırılmaktadır. Ancak bu sistemin işletim 
    sistemine özgü ayrıntıları vardır. Döngüsel çizelgelemede işletim sistemi thread'lere öncelik derecelerini de dikkate alarak quanta 
    süreleri atar. Quanta süresini dolduran thread'lerin quanta süreleri yeniden doldurulmadan önce çalışma kuyruğundaki tüm thread'lerin 
    quanta sürelerinin bitmesi beklenmektedir. Tabii bir thread çalışmaya başladığında bloke olabileceği için quanta süresini sonuna kadar
    kullanamayabilmektedir. İşletim sistemi her thread'in quanta süresinden harcağı zamanı tutmaktadır. Örneğin işletim sisteminin her thread'e 
    60 ms. quanta süresi verdiğini düşünelim. O anda da çalışma kuyruğunda(run queue) aşağıdaki thread'ler bulunuyor olsun:

    T1 (40 ms)
    T2 (0 ms)        ==> quanta süresi bitti
    T3 (10 ms)
    T4 (25 ms)

    Burada T2 thread'inin ona atanan 60 ms'lik quanta süresinin dolduğunu varsayalım. İşletim sistemi T2 thread'ine hemen 60 ms quanta 
    doldurmayacaktır. Önce çalışma kuyruğundaki tüm thread'lerin kullandığı quanta sürelerinin 0'a düşmesini bekleyecek sonra hepsini 
    birlikte 60 ms ile dolduracaktır. Pekiyi bu durumda bloke olup bekleme kuyruğunda beklemekte olan thread'lerin quantda süreleri ne 
    olacaktır. Örneğin T5 thread'inin bloke beklediğini ve kalan quanta süresinin 30 ms. olduğunu varsayalım. Çalışma kuyruğundaki tüm 
    thread'lerin quanta süreleri sıfıra geldiğinde onlara 60 ms. quanta doldurulurken blokede bekleyen threa'2lere doldurma yapılacak mıdır?
    İşte işletim sistemleri genellikle blokede bekleyen thread'lere de doldurma yapmaktadır. Çünkü onlar uyandıklarında diğerleriyle eşit hakka 
    sahip olacak biçimde daha fazla çalıştırılmalıdırlar. Ancak tabii blokede uzun süre bekleyen thread'lerin quanta'larının sürekli doldurulması
    da anomali yaratabilmektedir. Bunun için işletim sistemleri blokede bekleyen thread'ler için maksimum bir üst sınır da belirleyebilmektedir. 

    Pekiyi çalışma kuyruğundaki tüm thread'lerin quanta süreleri 0'a düştüğünde tüm thread'ler aynı quanta değeri ile mi doldurulmaktadır? İşte
    bu konuda işletim sistemleri arasında farklılıklar vardır. Windows'ta genel olarak aynı quanta süresi doldurulmaktadır. Ancak Linux sistemlerinde
    SCHED_OTHER çizelgeleme politikasında her thread'e o threadin önceliği ile orantılı quanta süreleri doldurulmaktadır. Yani Linux sistemlerinde
    bir thread'in önceliğini artırdığımızda onun diğerlerine göre daha fazla quanta süresi kullanmaısnı sağlayabiliriz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'li işletim sistemlerinde thread'lerin zaman paylaşımlı biçimde çizelgelendiğini belirtmiştik. Ancak bu sistemlerde sisteme bağlı 
    olarak thread'lere öncelik dereceleri atanabilmektedir. Böylece yksek öncelikli thread'lerin CPU'dan daha fazla zaman alması sağlanabilmektedir. 
    Thread öncelikleri konusu yukarıda da belirttiğimiz gibi işletim sistemine özgü farklılıklar içermektedir. Biz burada önce Windows sistemlerindeki
    durumu sonra da UNIX/Linux sistemlerindeki durumu kabaca ele alacağız. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinin kullandığı thread izelgeeleme algoritmasına "öncelik sınıflarıyla döngüsel çizelgeleme (priority class based round 
    robin scheduling )" denilmektedir. Windows'ta her thread'in [0, 31] arasında bir öncelik derecesi vardır. Şimdiye kadar yaratmış olduğumuz
    thread'lerin default öncelik dereceleri 8'dir. 

    Windows'ta thread'ler şöyle çizelgelenmektedir: Önce en yüksek önceliğe sahip thread'lerden bir grup oluşturulur. Sanki diğer thread'ler
    hiç yokmuş gibi yalnızca bu thread'ler zaman paylaşımlı biçimde çalıştırılır. Bu thread'ler sonlanırsa ya da bloke olursa bu kez daha 
    düşük öncelikli en yüksek grup aynı biçimde kendi aralarında izelgelenir. Bu yöntemde düşük öncelikli thread'lerin çalışabilmesi için
    yüksek öncelikli thread'lerin sonlanması ya da bloke olması gerekmektedir. Yüksek öncelikli bir thread'in blokesi çözüldüğünde işletim 
    sistemi düşük öncelikli thread'in çalışmasına ara vererek yeniden bu yüksek öncelikli thread grubunu çizelgelemektedir. Örneğin sistemde 
    aşağıdaki öncelikte thread'ler bulunuyor olsun:

    T1 -> 12
    T2 -> 12
    T3 -> 10
    T4 -> 9
    T5 -> 9
    T6 -> 8
    T7 -> 8
    T8 -> 8

    Burada sistem sanki diğer thread'ler yokmuş gibi T1 ve T2 thread'lerini kendi aralarında zaman paylaşımlı olarak çalıştırmaktadır. 
    Bu thread'ler sonlanırsa ya da bloke olursa T3 thread'i çalışma imlanı bulacaktır. T3 thread'i de sonlanırsa ya da bloke olursa bu durumda
    T4 thread'i, o da sonlanırsa ya da bloke olursa T5, T6, T7 ve T8 thread'leri kendi aralarında zaman paylaşımlı olarak çizelgelenecektir. 
    Görüldüğü gibi bu sistemde düşük öncelikli bir thread'in çalışanilmesi için yüksek öncelikli thread'lerin bloke olması ya da sonlanması 
    gerekmektedir. 

    Windows'un çizelgeleme algoritması kabaca yukarıdaki gibi olsa da aslında oludukça ayrıntılar içermektedir. Çok işlemcili ya da çok çekirdekli
    sistemlerde eeğer boşta işlemci ya da çekirdek varsa işletim sistemi daha düşük öncelikli sınıfları da bu işlemci ya da çekirdeklere 
    atayabilmektedir. 

    Windows'ta bir thread'in [0, 31] arasındaki öncelik derecesi iki değerin toplamıyla elde edilmektedir: Prosesin Öncelik Sınıfı + Thread'in 
    Göreli Öncelik Derecesi. Prosesin öncelik sınıfı bir taban değer belirtir. Thread'in göreli önceliği de bu taban değere toplanır. Prosesin
    öncelik sınıflarının taban değerleri şöyledir:

    NORMAL_PRIORITY_CLASS            (8 default)
    ABOVE_NORMAL_PRIORITY_CLASS        (10)
    BELOW_NORMAL_PRIORITY_CLASS        (6)
    HIGH_PRIORITY_CLASS                (13)
    REALTIME_PRIORITY_CLASS            (24)
    IDLE_PRIORITY_CLASS                (4)

    Thread'in göreli öncelik dereceleri de şöyledir:

    THREAD_PRIORITY_NORMAL            (0 default)
    THREAD_PRIORITY_IDLE            (Öncelik sınıfına göre değişmektedir)
    THREAD_PRIORITY_LOWEST            (-2)
    THREAD_PRIORITY_BELOW_NORMAL    (-1)
    THREAD_PRIORITY_ABOVE_NORMAL    (+1)
    THREAD_PRIORITY_HIGHEST            (+2)
    THREAD_PRIORITY_TIME_CRITICAL    (Öncelik sınıfına göre değişmektedir)

    Herhangi bir öncelik oluşturmak için bu ikşi ayarlamadın da yapıması gerekir. Tabii aynı değeri veren birden fazla kombinasyon olabilir. 
    Default durumda prosesin öncelik sınıfı NORMAL_PRIORITY_CLASS, thread'in göreli önceliği THREAD_PRIORITY_NORMAL biçimdedir. Bu durumda 
    thread'in öncelik derecesi 8 + 0 = 8 biçimindedir. Örneğin thread önceliğini 15 yapmak isteyelim. Bunun birkaç yolu olabilir:

    IDLE_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL
    BELOW_NORMAL_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL
    NORMAL_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL
    ABOVE_NORMAL_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL
    HIGH_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL
    HIGH_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL

    Thread'in önceliğini 31'e çekmek isteyelim. Bunun tek yolu şöyleidr:

    REALTIME_PRIORITY_CLASS + THREAD_PRIORITY_TIME_CRITICAL

    Thread önceliklerinin belirlenmesine ilişkin Microsoft dokğmanlarına aşağıdaki bağlantıdan erişebilirsiniz:

    https://learn.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Prosesin öncelik sınıfı GetPriorityClass API fonksiyonuyla alınıp SetPriorityClass API fınksiyonuyla set edilebilir. Fonksiyonarın 
    prototipleri şöyledir:

    DWORD GetPriorityClass(
        HANDLE hProcess
    );

    BOOL SetPriorityClass(
        HANDLE hProcess,
        DWORD  dwPriorityClass
    );

    Fonksiyonların birinci parametreleri öncelik sınıfı değiştirilecek prosesin HANDLE değerini belirtmektedir. GetPriorityClass API fonksiyonu
    prosesin öncelik sınıfına geri dönmektedir. SetPriorityClass API fonksiyonu ise prosesin öncelik sınıfını ikinci parametresiyle belirtilen 
    sınıf haline getirmektedir. GetPriorityClass fonksiyonu başarısız olamamaktadır. SetPriorityClass fonksiyonu ise başarı durumunda sıfır dışı 
    bir değere başarsızlık durumunda sıfır değerine geri dönmektedir. Anımsanacağı gibi o anda çalışmakta olan prosesin handle değeri 
    GetCurrentProcess API fonksiyonuyla elde edilmektedir. 

    Biz bir prosesin öncelik sınıfını istediğimiz gibi değiştirebilir miyiz? Windows'ta karmaşık bir güvenlik mekanizması vardır. Bu kursta 
    bu konuya girmeyeceğiz. Ancak bu tür uygulamalarda programı "Run As Administrator" seçeneği ile çalıştırmalısınız.

    Aşağıdaki örnekte prosesin öncelik değiştirilmiş ve yazdırılmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

LPCSTR GetPriorityClassName(DWORD dwPriority);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwPriorityClass;

    if ((dwPriorityClass = GetPriorityClass(GetCurrentProcess())) == 0)
        ExitSys("GetPriorityClass");

    puts(GetPriorityClassName(dwPriorityClass));

    if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
        ExitSys("SetPriorityClass");

    if ((dwPriorityClass = GetPriorityClass(GetCurrentProcess())) == 0)
        ExitSys("GetPriorityClass");

    puts(GetPriorityClassName(dwPriorityClass));

    return 0;
}

LPCSTR GetPriorityClassName(DWORD dwPriority)
{
    const char *pszName = "NONE";

    switch (dwPriority) {
        case ABOVE_NORMAL_PRIORITY_CLASS:
            pszName = "ABOVE_NORMAL_PRIORITY_CLASS";
            break;
        case BELOW_NORMAL_PRIORITY_CLASS:
            pszName = "BELOW_NORMAL_PRIORITY_CLASS";
            break;
        case HIGH_PRIORITY_CLASS:
            pszName = "HIGH_PRIORITY_CLASS";
            break;
        case IDLE_PRIORITY_CLASS:
            pszName = "IDLE_PRIORITY_CLASS";
            break;
        case NORMAL_PRIORITY_CLASS:
            pszName = "NORMAL_PRIORITY_CLASS";
            break;
        case REALTIME_PRIORITY_CLASS:
            pszName = "REALTIME_PRIORITY_CLASS";
            break;
    }

    return pszName;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Thread'in göreli önceliğini almak ve set etmek için GetThreadPriorty ve SetThreadPriority API fonksiyonları kullanılmaktadır. Fonksiyonların
    prototipleri şöyledir:

    int GetThreadPriority(
        HANDLE hThread
    );

    BOOL SetThreadPriority(
        HANDLE hThread,
        int    nPriority
    );

    Fonksiyonların birinci parametreleri göreli önceliği alınacak ya da dğeiştirilecek thread'in HANDLE değerini almaktadır. SetThreadPriority 
    fonksiyonunun ikinci parametresi thread'in göreli önceliğini belirtmektedir. GetThreadPriority fonksiyonu başarısız olamaz, thread'in 
    göreli önceliği ile geri dönmektedir. SetThreadPriority fonksiyonu başarı durumunda sıfır dışı bir değere başarısızlık durumunda sıfır 
    değerine geri dönmektedir. O anda çalışmakta olan thread'in HANDLE değeri GetCurrentThread API fonksiyonu ile elde edilebilmektedir.

    Aşağıda thread'in göreli öncelik derecesi alınıp set edilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

LPCSTR GetThreadPriorityName(int threadPriority);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    int threadPriority;

    if ((threadPriority = GetThreadPriority(GetCurrentThread())) == THREAD_PRIORITY_ERROR_RETURN)
        ExitSys("GetPriorityClass");

    puts(GetThreadPriorityName(threadPriority));

    if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
        ExitSys("SetThreadPriority");

    if ((threadPriority = GetThreadPriority(GetCurrentThread())) == THREAD_PRIORITY_ERROR_RETURN)
        ExitSys("GetPriorityClass");

    puts(GetThreadPriorityName(threadPriority));

    return 0;
}

LPCSTR GetThreadPriorityName(int threadPriority)
{
    const char *pszName = "NONE";

    switch (threadPriority) {
        case THREAD_PRIORITY_ABOVE_NORMAL:
            pszName = "THREAD_PRIORITY_ABOVE_NORMAL";
            break;
        case THREAD_PRIORITY_BELOW_NORMAL:
            pszName = "THREAD_PRIORITY_BELOW_NORMAL";
            break;
        case THREAD_PRIORITY_HIGHEST:
            pszName = "THREAD_PRIORITY_HIGHEST";
            break;
        case THREAD_PRIORITY_IDLE:
            pszName = "THREAD_PRIORITY_IDLE";
            break;
        case THREAD_PRIORITY_LOWEST:
            pszName = "THREAD_PRIORITY_LOWEST";
            break;
        case THREAD_PRIORITY_NORMAL:
            pszName = "THREAD_PRIORITY_NORMAL";
            break;
        case THREAD_PRIORITY_TIME_CRITICAL:
            pszName = "THREAD_PRIORITY_TIME_CRITICAL";
            break;
    }

    return pszName;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıcdaki örnekte proesin ana thread'i maksimum öncelik olan 31 önceliğe çekilmek istenmiştir. Programı "Arun As Administrator" ile 
    çalıştırınız.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

LPCSTR GetPriorityClassName(DWORD dwPriority);
LPCSTR GetThreadPriorityName(int threadPriority);
void ExitSys(LPCSTR lpszMsg);

int main(void)
{
    DWORD dwPriorityClass;
    int threadPriority;
    
    if ((dwPriorityClass = GetPriorityClass(GetCurrentProcess())) == 0)
        ExitSys("GetPriorityClass");

    puts(GetPriorityClassName(dwPriorityClass));
    
    if ((threadPriority = GetThreadPriority(GetCurrentThread())) == THREAD_PRIORITY_ERROR_RETURN)
        ExitSys("GetPriorityClass");

    puts(GetThreadPriorityName(threadPriority));

    printf("-----------------------\n");

    if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
        ExitSys("SetPriorityClass");

    if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
        ExitSys("SetThreadPriority");

    if ((dwPriorityClass = GetPriorityClass(GetCurrentProcess())) == 0)
        ExitSys("GetPriorityClass");

    puts(GetPriorityClassName(dwPriorityClass));

    if ((threadPriority = GetThreadPriority(GetCurrentThread())) == THREAD_PRIORITY_ERROR_RETURN)
        ExitSys("GetPriorityClass");

    puts(GetThreadPriorityName(threadPriority));

    getchar();PCSTR GetPriorityClassName(DWORD dwPriority)
{
    const char *pszName = "NONE";

    switch (dwPriority) {
    case ABOVE_NORMAL_PRIORITY_CLASS:    pszName = "ABOVE_NORMAL_PRIORITY_CLASS";
        brezName = "BELOW_NORMAL_PRIORITY_CLASS";
        break;
    case HIGH_PRIORITY_CLASS:
        pszName = "HIGH_PRIORITY_CLASS";
        break;
    case IDLE_PRIORITY_CLASS:
        pszName = "IDLE_PRIORITY_CLASS";
        break;
    case NORMAL_PRIORITY_CLASS:
        pszName = "NORMAL_PRIORITY_CLASS";
        break;
    case REALTIME_PRIORITY_CLASS:
        pszName = "REALTIME_PRIORITY_CLASS";
        break;
    }

    return pszName;
}

LPCSTR GetThreadPriorityName(int threadPriority)
{
    const char *pszName = "NONE";

    switch (threadPriority) {
        case THREAD_PRIORITY_ABOVE_NORMAL:
            pszName = "THREAD_PRIORITY_ABOVE_NORMAL";
            break;
        case THREAD_PRIORITY_BELOW_NORMAL:
            pszName = "THREAD_PRIORITY_BELOW_NORMAL";
            break;
        case THREAD_PRIORITY_HIGHEST:
            pszName = "THREAD_PRIORITY_HIGHEST";
            break;
        case THREAD_PRIORITY_IDLE:
            pszName = "THREAD_PRIORITY_IDLE";
            break;
        case THREAD_PRIORITY_LOWEST:
            pszName = "THREAD_PRIORITY_LOWEST";
            break;
        case THREAD_PRIORITY_NORMAL:
            pszName = "THREAD_PRIORITY_NORMAL";
            break;
        case THREAD_PRIORITY_TIME_CRITICAL:
            pszName = "THREAD_PRIORITY_TIME_CRITICAL";
            break;
    }

    return pszName;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her thread'in belirlenmiş olan bir "çizelgeleme politikası (scheduling policy)" vardır. POSIX standartlarına 
    göre şu çizelgeleme politikaları bulunmaktadır:

    SCHED_FIFO
    SCHED_RR
    SCHED_OTHER
    SCHED_SPORADIC

    SCHED_SPORADIC politikasının desteklenesi isteğe bağlı bırakılmıştır. SCHED_FIFO ve SCHED_RR politikalarıba "gerçek zamanlı (real time)"
    çizelgeleme politikalrı denilmektedir. SCHED_OTHER politikasının ayrıntılarına girilmemiş ve bu belirleme işletim sistemini yazanların 
    isteğine bırakılmıştır. Default çizelgeleme politikasının ne olacağı POSIX standartlarında açıkça belirtilmemiştir. O da işletim sistemini
    yazanların isteğine bırakılmıştır. Linux ve pek çok UNIX türevi sistemdeki default çizelgeleme politikası SCHED_OTHER biçimindedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre SCHED_OTHER thread'lerin bir dinamik öncelik derecesi vardır. Dinamik öncelik [0, 39] arasındadır. Default dinamik 
    öncelik 20'dir. Dinamik öncelikte yüksek değer düşük öncelik, düşük değer yüksek öncelik belirtmektedir. Linux sistemlerinde thread'lere 
    quanta doldurulurken her thread'e o thread'in dinamik önceliği ile orantılı bir quanta süresi atanmaktadır. Yani dinamik önceliği yüksek 
    olan thread'lere daha fazla quanta süresi, dinamik önceliği düşük thread'lere daha az quanta süresi atanmaktadır. Böylece programcı thread'in 
    diğer thread'lere göre daha fazla CPU zamanı almasını istiyorsa thread'inin dinamik önceliğini yükseltmektedir. Dinamik öncelikle quanta 
    süresi arasındaki ilişki sistemden sisteme hatta aynı sistemde versiyona bile değişiklik österebilmektedir. Örneğin eskiden Linux sistemlerinde 
    dinamik önceliğin etkisi nispeten azdı daha sonra bu etki yükseltilmiştir. 

    Eskiden UNIX/Linux sistemlerinde thread kavramı yoktu. O zamanlarda thread'ler yerine proseslerin dinamik önceliği vardı. Sonra thread'ler 
    sistemlere eklenince thread'lerin de dinamik öncelikleri oluşturuldu. Ancak eski POSIX fonksiyonları da muhafaze edildi. POSIX standartlarına 
    göre bir prosesin dinamik önceliğ değiştirildiğinde prosesin tüm thread'lerinin dinamik önceliği değiştirilmiş olmalıdır. Ancak Linux 
    sistemleri bu kurala uymamaktadır. Linux sistemlerinde prosesin dinamik önceliği değiştirildiğinde bundan yalnızca prosesin ana thread'i 
    etkilenmektedir. (Halbuki POSIX standartlarında o anda yaratılmış olan ve daha sonra yaratılacak olan tüm thread'lerin dinamik önceliğinin
    değişmesi gerekmektedir.)

    Dinamik önceliği değiştirmede en çok kullanılan fonksiyon nice isimli POSIX fonksiyonudur. nice fonksiyonu prosesin dinamik önceliğini 
    değiştirmektedir. (Linux sistemlerinde bu durum tüm thread2lerin değil ana thread'in dinamik önceliğinin değiştirilmesine yol açmaktadır.)
    nice fonksiyonun protoripi şöyledir:

    #include <unistd.h>

    int nice(int inc);

    nice fonksiyonu prosesin dinamik önceliğini o anki dinamik öncelikten parametresi belirtilen miktarda yükseltir ya da alçaltır. Ancak 
    parametrenin anlamı terstir. Yani pozitif değerler "düşürme", negatif değerler "yükseltme" anlamına gelmektedir. Fonksiyon parametre olarak 
    [-20, +19] arasında bir değer almaktadır. Böylelikle biz bu fonksiyona argüman olarak 19 değerini verirsek dinamik öncelik en düşük değeri 
    belirten 39 olur, -20 verirsek dinamik öncelik en yükske değeri belirten 0 olur. Fonksiyon başarı durumunda yeni nice değerine başarısızlık 
    durumunda -1 değerine geri dönmektedir. nice fonksiyonu ile sıradan prosesler önceliklerini düşürebilirler (pozitif parametre) ancak 
    yükseltemezler (negatif parametre). Yükseltme işlemi için prosesin uygun önceliğe sahip olması (örneğin root olması, yani sudo ile çalıştırılması) 
    gerekmektedir. Prosesin nice değeri getpriority POSIX fonksiyonyla elde edilebilmektedir. 

    nice fonksiyonun prosesin dinamik önceliğini değiştirdiğini belirtmiştik. Yalnızca belli bir thread'in dinamik önceliğini değiştirmek için 
    pthread_schedsetparam fonksiyonu kullanılmaktadır. Bu kodudaki ayrıntılar UNIX/Linux sistem programlama kurslarında ele alınmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi SCHED_FIFO ve SCHED_RR çizelgeleme politikalarına "gerçek zamanlı çizelgeleme politikaları" denilmektedir. 
    UNIX/Linux sistemlerinde çalışma kuyruğunda (yani bloke olmamış) SCHED_FIFO ya da SCHED_RR thread'ler varsa hiçbir zaman SCHED_OTHER 
    thread çizelgelenmemektedir. Tabii çok işlemcili ya da çekirdekli sistemlerde SCHED_FIFO ya da SCHED_RR thread'ler CPU'ya atabndıktan sonra
    çalışma kuyruğunda artık hiç SCHED_FIFO ya da SCHED_RR thread yoksa SCHED_OTHER thread'ler diğer işlemci ya da çekirdeklerde çizelgelenebilmektedir. 
    Yani SCHED_FIFO ve SCHED_RR thread'lerin SCHED_OTHER thread'lere tam bir üstünlüğü vardır. Pekiyi SCHED_FIFO ve SCHED_RR thread'lerin kendi 
    aralarındaki durum nasıldır? 

    SCHED_FIFO ve ve SCHED_RR thread'lerin de birer önceliği vardır. (Bu öncelik SCHED_OTHER thread'lerin dinamik önceliğinden farklıdır.)
    Linux sistemlerinde SCHED_FIFO ve SCHED_RR thread'lerin öncelik derecesi 1 ile 99 arasındadır. Burada Yüksek değer yüksek öncelik belirtmektedir. 
    Ancak POSIX standartları bu 1 ve 99 değerlerinin sistemden sisteme değişebileceğini o sistemdeki değerlerin sched_get_priority_min ve 
    sched_get_priority_max fonksiyonlarıyla elde edilmesi gerektiğini belirtmektedir. 

    Çalışma kuyruğunda yalnızca SCHED_FIFO ve SCHED_RR thread'lerin olduğunu varsayalım. (Zaten SCHED_OTHER thread'ler olsa bile çizelgelenmeyecektir.)
    Çizelgeleme algoritması şöyledir:

    1) Çizelgeleyici kuyruktaki en yüksek önceliğe sahip olanlar arasında önde bulunan SCHED_FIFO ya da SCHED_RR thread'i CPU'ya atar. Eğer 
    atanan thread SCHED_FIFO ise bloke olana kadar sürekli çalıştrılır. Yani SCHED_FIFO bir thread bloke olmadıktan sonra CPU'yu bırakmamaktadır.
    Ancak atanan CPU'ya atanan thread SCHED_RR ise bir quanta çalıştırılıp kuyruğun sonuna alınır. 
    
    2) SCHED_FIFO thread bloke olursa bu durumda kuyrukta en yüksek öncelikte ve önde olan ilk SCHED_FIFO ya da SCHED_RR thread CPU'ya atanır. 
    
    3) Bloke olmuş olan bir thread'in blokesi çözüldüğünde eğer o anda çalışmakta olan thread'ten daha yüksek öncelikliyse o anda çalışmakta 
    olan thread'in çalışması kesilir ve blokesi çözülen thred çalıştırılır. Tabii bu yeni thread SCHED_FIFO ise sürekli çalıştırılacak, SCHED_RR 
    ise    bir quanta çalıştırılıp sona alınacaktır. Eğer blokesi çözülmüş olan thread o anda çalışmakta olan thread'le eşit öncelikli ya da ondan 
    daha düşük öncelikli ise kuyruğun sonuna alınmaktadır. Blokesi çözülmüş yüksek öncelikli thread tarafından kesilen thread eğer SCHED_FIFO 
    thread'se kuyruğun önüne yerleştirilir. SCHED_RR thread'se kuyruğun sonuna alınır.

    Bu çizelgeleme sisteminde şu durumlara dikkat ediniz.

    - Bu sistemde çalışma kuyruğundaki bütün geçek zamanlı zamanlı thread'lerin SCHED_RR olduğunu varsayalım. Bu durumdaki çizelgeleme Windows'taki
    çizelgelemeye çok benzer durumdadır Yani en yüksek öncelikteki thread'ler kendi aralarında döngülsel çizelgelenecektir. 

    - CPU'ya atanmış olan SCHED_FIFO thread'in CPU'yu bırakması ancak daha yüksek öncelikli SCHED_FIFO ya da SCHED_RR thread'in uykudan
    uyanmasıyla ya da yüksek öncelikli yeni bir thread'in yaratılmasıyla ya da o thread'ın bloke olmasıyla mümkündür. SCHED_FIFO politikası 
    bu sistemlerde "sürekli çalışan tüm CPU'yu tek başına kullanan thread'lerin oluşturulması" amacıyla bulundurulmuştur. Yüksek öncelikli 
    SCHED_FIFO thread'ler diğer thread'lerin çalışmasını engelleyebilmektedir.
    
    Aşağıdaki örnekte gerçek zamanlı çizelgeleme politikalarına ilişkin öncelik derecelerinin en düşük ve en yüksek değeri sched_get_priority_min
    ve sched_get_priority_max fonksiyonları ile elde edilip yazdırılmıştır. SCHED_OTHER politikası için bu fonksiyonlar 0 değerini geri 
    döndürmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

#define QUEUE_SIZE        10

void *thread_producer(void *param);
void *thread_consumer(void *param);

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem_producer;
sem_t g_sem_consumer;

int g_queue[QUEUE_SIZE];
size_t g_head;
size_t g_tail;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if (sem_init(&g_sem_producer, 0, QUEUE_SIZE) == -1)
        exit_sys("sem_init");

    if (sem_init(&g_sem_consumer, 0, 0) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem_consumer) == -1)
        exit_sys("sem_destroy");

    if (sem_destroy(&g_sem_producer) == -1)
        exit_sys("sem_destroy");

    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if (sem_wait(&g_sem_producer) == -1)
            exit_sys("sem_wait");

        g_queue[g_tail] = val;
        g_tail = (g_tail + 1) % QUEUE_SIZE;
        
        if (sem_post(&g_sem_consumer) == -1)
            exit_sys("sem_post");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        if (sem_wait(&g_sem_consumer) == -1)
            exit_sys("sem_wait");

        val = g_queue[g_head];
        g_head = (g_head + 1) % QUEUE_SIZE;

        if (sem_post(&g_sem_producer) == -1)
            exit_sys("sem_post");

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                91. Ders 26/05/2024 - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir prosesin ya da thread'in çizelgeleme politikası ve gerçek zamanlı thread'lerin öncelikleri nasıl belirlenmektedir? Bir prosesin
    çizelgeleme politikası sched_setscheduler fonksiyonuyla set edilip sched_getcheduler fonksiyonu ile alınabilmektedir. Bu POSIX fonksiyonları 
    Linux sistemlerinde doğrudan ilgili sistem fonksiyonlarını çağırmaktadır. Fonksiyonların prototipileri şöyledir:

    #include <sched.h>

    int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);
    int sched_getscheduler(pid_t pid);

    Fonksiyonların birinci parametreleri prosesin id değerini belirtmektedir. Bu parametre 0 girilirse fonksiyonları çağıran proses için 
    işlem yapılmaktadır. sched_setscheduler fonksiyonun ikinci parametresi çizelgeleme politikasını üçüncü paarametresi ise gerçek zamanlı 
    çizelgeleme politikalarına ilişkin öncelik derecesini belirtmektedir. Vu üçüncü parametrede SCHED_OTHER için öncelik belirtilememektedir. 
    Bu parametre yalnızca SCHED_FIFO ve SCHED_RR için anlamlıdır. Fonksiyon başarı durumunda eski çizelgeleme politikasına başarısızlık 
    durumunda -1 değerine geri dönmektedir. sched_getscheduler fonksiyonu da başarı durumunda çizelgeleme politikasına, başarısızlık durumunda -1
    değerine geri dönmektedir. 

    Prosesin çizelgeleme politikasını değiştirebilmek için sched_setscheduler fonksiyonunu çağıran prosesin uygun önceliğe sahip olması 
    gerekir. 

    Aşağıdaki programda proses kendi çizelgeleme politikasını SCHED_FIFO yapıp önceliğini de Linux'taki maksimum öncelik olan 99 yapmıştır. 
    Tabii programı sudo ile çalıştırmalısınız.
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void* thread_proc(void* param);
void exit_errno(const char* msg, int result);

int main(void)
{
    int result;
    pthread_t tid;;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_errno("pthread_create", result);

    pthread_join(tid, NULL);

    return 0;
}

void* thread_proc(void* param)
{
    struct sched_param sparam;
    int result;
    long i;

    sparam.sched_priority = 99;

    if ((result = pthread_setschedparam(pthread_self(), SCHED_FIFO, &sparam)) != 0)
        exit_errno("pthread_setschedparam", result);

    for (i = 0; i < 1000000000; ++i)
        ;

    return NULL;
}

void exit_errno(const char* msg, int result)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(result));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi POSIX standartlarına göre aslında prosesin çizelgeleme politikası ya da öncelik dereceleri değiştirildiğinde
    bundan prosesin tüm thread'leri etkilenmektedir. Ancak Linux'ta bundan yalnızca prosesin ana thread'i etkilenmektedir. Ancak biz belli bir
    thread'imizin de diğerlerin bağımsız olarak çizelgeleme politikasını değiştirip elde edebiliriz. Bunlar için pthread_setschedparam ve 
    pthread_getschedparam fonksiyonları kullanılmaktadır:

    #include <pthread.h>

    int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param);
    int pthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param);

    Fonksiyonlar sched_setscheduler ve sched_getscheduler fonksiyonları gibi çalışmaktadır. Yalnızca proses id yerine thread id değerini
    parametre olarak almaktadır. Diğer thread fonksiyonlarında olduğu gibi bu fonksiyonlar da başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri dönemektedir. 

    Aşağıdaki örnekte bir thread'in çizelgeleme politikası ve önceliği değiştirilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void* thread_proc(void* param);
void exit_errno(const char* msg, int result);

int main(void)
{
    int result;
    pthread_t tid;;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_errno("pthread_create", result);

    pthread_join(tid, NULL);

    return 0;
}

void* thread_proc(void* param)
{
    struct sched_param sparam;
    int result;
    
    sparam.sched_priority = 99;

    if ((result = pthread_setschedparam(pthread_self(), SCHED_FIFO, &sparam)) != 0)
        exit_errno("pthread_setschedparam", result);

    for (long i = 0; i < 1000000000; ++i)
        ;

    return NULL;
}

void exit_errno(const char* msg, int result)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(result));

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kütüphane (library) kavramı genel olarak "kullanıma hazır halde bulunan fonksiyonlar ve sınıfların oluşturduğu" topluluklar için kullanılan 
    bir terimdir. Ancak aşağı seviyeli dünyada kütüphane ""içerisinde derlenmiş bir biçimde fonksiyonların (ve sınıfların) bulunduğu dosyalara 
    denilmektedir. 
    
    Kütüphaneler statik ve dinamik olmak üzere ikiye ayrılmaktadır. Statik kütüphanelerin Windows sistemlerinde uzantıları ".lib"", UNIX/Linux 
    ve macOS sistemlerindeki uzantıları ".a" biçimindedir. Dinamik kütüphanelerin ise Windows sistemlerindeki uzantıları ".dll", UNIX/Linux 
    ve macOS sistemlerindeki uzantıları ise ".so" biçimindedir. ".lib" uzantısı "library" sözcüğünde, ".a" uzantısı "archive" sözcüğünden, 
    "dll" uzantısı "dynamic link library" sözcüklerinden ve ".so" uzantısı da "shared object" sözüklerinden kısaltılmıştır. 

    Kütüphane konusunun aslında aşağı seviyeli oldukça ayrıntıları vardır. Biz bu kursumuzda temel düzeyde bu kavramlar üzerinde uygulamalı 
    bilgiler edineceğiz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Derleyicilerin ürettiği dosyalara "amaç dosyalar (object files)" ya da "yeniden yüklemebilen dosyalar (relocatable object files)" denilmektedir.
    Bağlayıcılar bir grup amaç dosyayı (object files) girdi olarak alıp çeşitli kütüphanelere de başvurarak çalıştırılabilir doysalar 
    oluşturmaktadır. Bu sayede programlar farklı ekipler tarafından parça parça yazılıp bağlama aşamasında birleştirilebilmektedir. Örneğin 
    tipik bir C projesi şöyle derlenip oluşturulmaktadır:

    a1.c ----> Derleyici ----> a1.obj    ----> \
    a2.c ----> Derleyici ----> a2.obj    ---->  \
    a3.c ----> Derleyici ----> a3.obj    ---->    ===>    Bağlayıcı   ------> Çalıştırılabilir Dosya
    a4.c ----> Derleyici ----> a4.obj    ---->  /      /
    a5.c ----> Derleyici ----> a5.obj    ----> /      /
                                                    Kütüphane Dosyaları    


    Amaç dosyaların Windows sistemlerindeki uzantıları ".obj" biçiminde UNIX/Linux ve nacOS sistemlerindeki uzantıları ise ".o" biçimindedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bağlayıcı tam olarak ne yapmaktadır? Farklı amaç dosyaları birleştirmek basit bir işlem değildir. Örneğin iki kaynak dosyadan oluşan 
    bir program söz konusu olsun:

    /* a1.c */

    extern int g_x;
    void foo(void);

    int main(void)
    {
        g_x = 10;

        foo();        CALL adres

        return 0;
    }

    /* a2.c */

    int g_x;

    void foo(void)
    {
        printf("foo\n");
    }

    Proje oluşturan bu "a1.c" ve "a2.c" dosyalarının birbirinden habersiz bağımsız bir biçimde derlendiğine dikkat ediniz. "a1.c" programı 
    derlendiğinde foo fonksiyonu o dosya yoktur. g_x global değişkeni de o dosyada yoktur. Pekiyi oradaki makine komutları nasıl üretilmektedir? 
    İşte derleyiciler bu yüt durumlarda makine kodlarının ilgili kısımlarını boş bırakıp bağlayıcının orayı doldurmasını istemektedir. 
    Bu işleme "relocation" denilmektedir. "a1.c" dosyası içerisindeki fonksiyon çağrısına dikkat ediniz:

    foo();

    Bir fonksiyonun çağrılabilmesi için CALL makine komutu kullanılmaktadır. CALL makine komutu da operand olarak çağrılacak fonksiyonu adresini
    almaktadır. Örneğin:

    CALL <adres>

    Oysa derleyici derleme aşamasında foo fonksiyonunu görmediği için onun adresini bilememktedir. İşte derleyici bağlayıcıdan "foo fonksiyonun 
    yerini bulunup ilgili adresin düzeltilmesini" talep etmektedir. Bu relocation bilgileri amaç dosyanın içerisinde bulunmaktadır. Yani 
    bağlayıcı yalnızca amaç dosyaları birleştirmemekte aynı zamanda çeşitli makine komutlarını da düzeltmektedir. Pekiyi yukarıdaki örnekte
    foo fonksiyonunu bağlayıcı nerelrde arayacaktır? Bağlayıcılar öncelikle fonksiyonları ve global nesneleri kendilerine girdi olarak verilmiş
    olan kütğphane amaç dosyalarda aramaktadır. Onlar amaç dosyalarda bulunamazsa bağlayıcılar programcının belirlediği kütüphane dosyalarına 
    da bakmaktadır. 

    Standart C fonksiyonları, Windows API fonksiyonları, POSIX fonksiyonları çeşitli kütüphane dosyalarının içerisindedir. Bunlar bağlama 
    aşamasında bağlayıcı tarafından ele alınmaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Statik kütüphane dosyaları "amaç dosyaları tutan kap" gibidir. Yani statik kütüphane dosyalarının içerisinde fonksiyonlar ya da sınıflar 
    değil amaç dosyalar bulunmaktadır. Yani örneğin biz bir grup fonksiyonu statik kütüphaneye yerleştirmek istesek önce onları bir C dosyasının 
    içerisine yazarız. Sonra dosyayı derleyip amaç dosya oluştururuz. Bu amaç dosyayı da statik kütüphane içerisine yerleştiririz. Microsoft
    C derleyicilerinde dosyayı yalnızca derlemek için "/c" seçeneği, gcc ve clang derleyicilerinde ise "-c" seçeneği kullanılmaktadır. Örneğin

    cl /c myutil.c
    gcc -c myutil.c
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Microsoft Windows sistemlerinde statik kütüphane dosyaları özel bir formata sahiptir. Bunu oluşturmak için Microsoft "lib.exe" isimli 
    yardımcı bir program bulundurmuştur. "lib.exe" programı Microsoft C derleyicisi kurulduğunda (tabii Visual Studio IDE'si de kurulduğunda)
    otomatik olarak kurulmaktadır. 
        
    lib.exe programının en önemli birkaç kullanımı şöyledir:

    lib /OUT:myutil.lib a.obj b.obj

    Burada "myutil.lib" dosyası yeniden yaratılır ve onun içerisine "a.obj" ve "b.obj" dosyaları eklenir. Eğer bu dosya varsa içerği sıfırlanarak
    yeniden oluşturulmaktadır.

    lib myutil.lib c.obj

    Burada "myutil.lib" "dosyasının var olması gerekir. Onun içerisinde eğer "c.obj" dosyası yoksa eklenir varsa dosya değiştirilir. 

    lib /LIST myutil.lib

    Burada "myutil.lib" içerisindeki amaç dosyalar görüntülenir. 

    lib /REMOVE:a.obj myutil.lib

    Burada "myutil.lib" içerisinden "a.obj" dosyası silinir. 

    lib /EXTRACT:a.obj myutil.lib 

    Burada "myutil.lib" içerisindeki "a.obj" dosyası dışarıda "a.obj" "olarak save edilir. Fakat kütüphanenin içeriisinden silinmez.
    "lib.exe" hakkında ayrıntılı açıklamalar için aşağıdaki MSDN bağlantısından faydalanabilirsiniz:

    https://learn.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170
        
    Aşağıdaki örnekte "a.c" ve "b.c" dosyaları aşağıdaki gibi derlenip "myutil.lib" isimli bir statik kütüphane dosyası oluşturulmuştur:

    cl /c a.c
    cl /c b.c
    lib /OUT:mmyutil.lib a.obj b.obj
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>

int g_x;

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* b.c */

#include <stdio.h>

int g_y;

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir kütüphanedeki fonksiyonlar çağrılabilmesi için çağrılan kaynak dosyada o fonksiyonların prototipilerinin bulundurulması gerekir. Benzer
    biçimde kütüphane içerisindeki global değişkenlerin kullanılabilmesi için de o global değişkenlerin extern bildirimlerinin bulundurulması 
    gerekir. Her kütüphane için o kütüphanedeki bildirimleri barındıran bir başlık dosyasının bulundurulması iyi bir tekniktir. Örneğin:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    /* Function Prototypes */

    double add(double a, double b);
    double sub(double a, double b);
    double multiply(double a, double b);
    double divide(double a, double b);
    void foo(void);
    void bar(void);

    /* extern Declarations */

    extern int g_x;
    extern int g_y;

    #endif

    Böylece bu kütüphaneyi kullanacak kişiler bu başlık dosyasını include ederek bütün kütüphane ile ilgili bildirimleri bulundurmuş olurlar. 
    Eğer kütüphane çok fazla öğeden oluşyorsa tek bir başlık dosyası önişlemci (preprocessor) zamanını uzatabilir. Bu durumda bir tane değil
    birden çok başlık dosyası bulundurulabilir. Örneğin aslında standart C fonksiyonlarının hepsi tek bir kütüphane içerisindedir. Ancak 
    onlara ilişkin bildirimler çeşitli başlık dosyalarına yaydırılmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bağlayıcılar onlara verilen amaç dosyalar dışında ayrıca temel bazı kütüphanelere otomatik olarak bakmaktadır. Microsoft'un bağlayıcı 
    programı olan "link.exe" hiç belirtilmese bile standart C fonksiyonlarının bulunduğu, Windows API fonksiyonlarının bulunduğu kütüphanelere
    zaten bakmaktadır. Ancak programcı bağlayıcının kendi kütüphanelerine de bakmasını istiyorsa bunu bağlayıcıya komut satırından söylemelidir. 
    
    Anımsanacağı gibi Microsoft'un Cve C++ derleyicisi olan "cl.exe" programı "/c" seçeneği belirtilmezse derleme sonrasında "link.exe" 
    bağlayıcısını kendisi çalıştırmaktadır. İşte biz de "cl.exe" programının komut satırında derlenecek kaynak dosyalardan sonra uzantısı ".lib"
    olan kütüphane dosyalarını belirtirsek "link.exe" bağlayıcısı o kütüphane dosyalarına da bağlama aşamasında bakmaktadır. Örneğin:

    cl app.c myutil.lib

    Burada "app.c" programı derlenerek "app.obj" dosyası oluşturulacak sonra bağlama aşamasında "myutil.lib" dosyasına da bakılacaktır. 
    Oluşturulacak çalıştırılabilir dosyanın ismi ilk kaynak dosyanın ismi olarak (örneğimizde "app.exe") alınacaktır. Tabii istenirse "cl.exe"
    komut satırında /Fe:<dosya_ismi> argümanı ile çalıştırılabilir dosyaya arzu edilen bir isim de verilebilmektedir. Örneğin:

    cl /Fe:project.exe app.c myutil.lib

    Tabii istersek derleyici ve bağlayıcıyı ayrı ayrı da çalıştırabiliriz. Örneğin:

    cl /c app.c
    link app.obj myutil.lib

    Burada yine default olarak "link.exe" programı ilk amaç dosyanın ismini çalıştırılabilir dosyaya vermektedir. Ancak çalıştırılabilen 
    dosyanın ismi /OUT:<isim> seçeneği ile de bağlayıcıya verilebilmektedir. Örneğin:

    cl /c app.c
    link /OUT:project.exe app.obj myutil.lib

    Aşağıdak örnekte "a.c" ve "b.c" dosyalarından "myutil.lib" statik kütüphanesi oluiştuurulmuş ve bu statik kütüphane de "app.c" programından 
    kullanılmıştır. İşlemleri komut satırından aşağıdaki sırada yapabilirsiniz:

    cl -c a.c
    cl -c b.c
    lib /OUT:myutil.lib a.obj b.obj
    cl app.c myutil.lib
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>

int g_x;

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* b.c */

#include <stdio.h>

int g_y;

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/* myutil.h */

#ifndef MYUTIL_H_
#define MYUTIL_H_

/* Function Prototypes */

double add(double a, double b);
double sub(double a, double b);
double multiply(double a, double b);
double divide(double a, double b);
void foo(void);
void bar(void);

/* extern declarations */

extern int g_x;
extern int g_y;

#endif

/* app.c*/

#include <stdio.h>
#include "myutil.h"

int main(void)
{
    double result;

    result = add(10, 20);
    printf("%f\n", result);

    result = sub(10, 20);
    printf("%f\n", result);

    result = multiply(10, 20);
    printf("%f\n", result);

    result = divide(10, 20);
    printf("%f\n", result);

    foo();
    bar();

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir statik kütüphaneden bir fonksiyon çağrıldığında bağlayıcı çağrılmış olan fonksiyonun statik kütüphane içerisindeki hangi amaç dosyada
    olduğunu belirleri, o amaç dosyayı çalıştırılabilen dosyaya ekler. Böylece statik kütüphane kullanan bir program çalıştırılırken artık 
    o statik kütüphaneye gereksinim duyulmaz. Şu noktalara dikkat ediniz:

    - Statik kütüphane içerisinde bir fonksiyon bile çağırsak bağlayıcı onun bulunduğu amaç dosyanın tamamını çalıştırılabilen dosyaya yazmaktadır. 
    Amaç dosya içerisindeki tek bir fonksiyonun çalıştırılabilen dosyaya yazılması mümkün değildir. 

    - Statik kütüphane kullanımında statik kütüphane içerisidnen çağrılan fonksiyonlar nihayetinde çalıştırılabilen dosyanın içerisine yazıldığı 
    için aynı fonksiyonları kullanan farklı programlar aynı fonksiyon kodlarını çalıştırılabilen dosya içerisinde barındırmış olacaklardır. 
    Bu da çalıştırılabilen dosyaların diskte daha fazla yer kaplamasına yol açmaktadır.

    - Statik bağlanmış fonksiyonları kullanan farklı programlar birlikte çalıştırıldığında işletim sistemi mecburen onların ortak kullandığı 
    fonksiyonları tekrar belleğe yüklemektedir. Bu da yalnızca disk kullanımı bakımından değil ana bellek yönetini bakımından da etkin olmayan
    bir durum oluşturmaktadır. 

    - Statik kütüphanelerin en önemli avantajı onları kullanan programların konuşlandırılmasının (deployment) kolay olmasıdır. Tek yapılacak 
    şey tek bir çalıştırılabilir dosyanın hedef makineye taşınmasıdır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    92. Ders 01/06/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında C ve C++ IDE'lerinde de hiç komut satırı işlemi yapmadan statik kütüphane oluşturulabilmektedir. Örneğin Visual Studio IDE'sinde
    yeni boş bir bir proje oluşturulduktan sonra proje seçeneklerinden "Configuration Type" "Application" yerine "Static library" seçilirse 
    proje build edildiğinde statik kütüphane dosyası oluşturulmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Visual Studio derleyicisi default durumda standart C kütüphanesinin dinamik versiyonunu kullanmaktadır. Eğer projenizde standart C 
    kütüphanesinin statik versyionunu kullanmak istiyorsanız komut satırında "/MT" seçeneği eklenmelidir. Aynı işlem proje seçeneklerinde 
    "C-C++/Code Generation/Runtime Library" sekmesinden de ayarlanabilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Visual Studio IDE'sinde (diğer IDE'lerde de benzer) bir projede başka bir statik kütüphanenin içerisindeki fonksiyonları çağırmak istediğimizi
    düşünelim. Pekiyi bu statik kütüphaneye IDE içerisinden nasıl referans ederiz? İşte kullanılacak ek kütüphanelere bağlayıcının bakmasını 
    sağlamak için Visual Studio IDE'sinde proje seçeneklerinden "Linker/Input/Additional Dependencies" edit alanına kütüphanenin ismi eklenmelidir. 
    (Bu alandaki kütüphane isimleri ';' karakterleriyle birbirinden ayrılmaktadır.) Burada kütüphane yalnızca ismi girilebilir. Bir yol ifadesi 
    girilmez. Eğer kütüphane özel bazı dizinlerde ya da projenin çalışma dizininde değilse ayrıca kütüphanenin bulunduğu dizin "Linker/General
    /Additional Library Directories" edit alanına girilmelidir. Burada dizinler mutlak ya da göreli biçimde girilebilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde statik kütüphane dosyalarını oluşturmak ve onlarla ilgili işlem yapmak için "ar" isimli program kullanılmaktadır. 
    UNIX/Linux sistemlerindeki "ar" programı aslında Microsoft sistemlerindeki "LIB.EXE" programının karşılığı olarak düşünülebilir. Bu "ar" 
    programının birkaç önemli komut satırı argümanı vardır. Bu program çok eskiden tasarlandığı için seçenekler '-' karakteri ile değil'-' 
    karakteri olmadan doğrudan belirtilmektedir. "r" komut satırı argümanı ("replace" sözcüğünden geliyor) amaç dosyaları kütüphaneye eklemek 
    için kullanılmaktadır. Bu seçenekte kütüphane dosyası yoksa aynı zamanda yaratılmaktadır. Kullan ım şöyledir:

    ar r <kütüphane_dosyasının_ismi> <.o dosyaları>

    Eğer eklenecek amaç dosya zaten kütüphanenin içerisinde varsa o değiştirilmektedir. Örneğin:

    $ gcc -c a.c
    $ gcc -c b.c 
    $ ar r libmyutil.a a.o
    $ ar r libmyutil.a b.o

    "t" seçeneği kütüphane içerisindeki amaç dosyaları görüntülemektedir. Kullanımı şöyledir:

    ar t <kütüphane_dosyasının_ismi> 

    Örneğin:

    $ ar t libmyutil.a
    a.o
    b.o

    "d" seçeneği ("delete" sözcüğünden geliyor) kütüphane içerisindeki bir amaç dosyayı kütüphaneden silmek için kullanılmaktadır. Kullanımı
    şöyledir:

    ar d <kütüphane_dosyasnın_ismi> <.o dosyaları>

    Örneğin:

    $ ar t libmyutil.a
    a.o
    b.o
    $ ar d libmyutil.a a.o
    $ ar t libmyutil.a
    b.o

    "x" seçeneği ("extract" sözcüğünden geliyor) kütüphane içerisindeki bir amaç dosyayı kütüphaneden silmeden dışarıya save etmekte kullanılmaktadır.
    Kullanımı şöyledir:

    ar x <kütüphane_dosyasının_ismi> <.o dosyaları>

    Örneğin:

    $ ar x libmyutil.a a.o

    UNIX/Linux sistemlerinde geleneksel olarak kütüphane dosyaları "lib" öneki başlatılarak isimlendirilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistelerinde bir statik kütüphaneye başvuru işlemi gcc komut satırında ".a" dosyasının belirtilmesi yoluyla yapılabilmektedir. 
    Örneğin:

    $ gcc -o app app.c libmyutil.a

    Burada gcc programı ".a" uzantılı dosyaları "ld" bağlayıcısını çalıştırırken ona gendermektedir. Tabii aynı işlem iki parça halinde şöyle 
    de yapılabilirdi:

    $ gcc -c app.c
    $ gcc -o app app.o libmyutil.a
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi standart C fonksiyonları ve POSIX fonksiyonları "libc" isimli bir kütüphanede bulunmaktadır. Bu 
    kütüphanenin static ve dinamik biçimleri vardır. Default durumda bu kütüphanenin dinamik versiyonu kullanılmaktadır. Ancak komut satırında
    "-static" seçeneği ile bu kütüphanenin statik versiyonunun kullanılması sağlanabilir. "-static" komut satırı seçeneği "tüm kütüphanelerin 
    statik versiyonlarının" kullanılacağı anlamına gelmektedir. (Yani biz "-static" seçeneğini beelirttikten sonra başka bir dinamik kütüphaneyi 
    de bağlama aşamasında kullanamayız.) Örneğin:
    
    $ gcc -o app app.c -static
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde kütüphane dosyası başka bir dizindeyse bu durumda o dosyaya referans ederken yol ifadesi kullanılabilir. 
    Öneğin:

    $ gcc -o app app.c xxx/libmyutil.a

    Eğer kütüphanenin ismi "lib" öneki ile başlatılmışsa kütüphaneye referans etme (yani kütüphanenin bağlayıcı tarafından işleme sokulmasını sağlama)
    "-l" seçeneği ile yapılabilmektedir. Ancak bu "-l" seçeneğinde kütüphanenin başındaki "lib" öneki ve ".a" ya da ".so" sonekleri kullanılmamaktadır. 
    Örneğin:

    4 gcc -o app app.c -lmyutil

    Burada bağlama işlemine "libmyutil.a" dosyası sokulacaktır. Ancak "-l" seçeneği ile kütüphane bu biçimde belirtildiğinde bu kütüphane "/lib" ve
    "/usr/lib" dizinlerinde aranmaktadır. Yani bu durumda buradaki "libmyutil.a" dosyasının bu dizinlerden birine çekilmesi gerekir. Ancak "-l" 
    seçeneğine ek olarak "-L" seçeneği ile ek arama dizi belirtilebilmektedir. Örneğin:

    $ gcc -o app app.c -lmyutil -L/home/kaan

    Burada "libmyutil.a" dosaysı yukarıda belirttiğmiz dizinlerin yanı sıra "/home/kaan" dizininde de aranacaktır. Tabii biz "-L" seçeneğinde
    o anda bulunulan dizini "." ile de belirtebiliriz. Örneğin:

    $ gcc -o app app.c -lmyutil -L.

    Örneğin daha önceden de kullandığımız thread kürüphanesi aslında "libpthread.a" ve "libpthread.so" isimli dosyalardır. Biz de bu ktüphaneiyi 
    bağlama aşamasında şöyle devreye sokuyorduk:

    $ gcc -o app app.c -lpthread
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphaneler statik kütüphanelerden oldukça farklıdır. Windows'ta dinamik kütüphanelerin uzantısı ".dll", UNIX/Linux sistemlerinde
    ".so" biçimindedir. ".dll" uzantısı "dynamic link library" sözcüklerinden ".so" uzantısı ise "shared object" sözcüklerinden kısaltılmıştır. 
    Bir program dinamik kütüphaneden bir fonksiyon çağırdığında bağlayıcı o fonksiyonun kodunu dinamik kütüphaneden çekip çalıştırılabilen dosyaya 
    yazmaz. Bağlayıcı bunun yerine çalıştırılabilen dosyaya "falanca dinamik kütüphaneden filanca fonksiyonlar çağrıldı" biçiminde bir bilgi 
    yazmaktadır. Dinamik kütüphane kullanan bir program çalıştırılmak istendiğinde ise işletim sistemi bu programla birlikte bu programın kullandığı
    dinamik kütüphaneleri prosesin sanal bellek alanına bütünsel bir biçimde yükler. Program çalışırken akış fonksiyonun çağrılma noktasına 
    geldiğinde bellekte dinamik kütüphanenin yüklü olduğu alana atlayarak fonksiyonu çalıştırır. 

    Dinamik kütüphane kullanımının şu avantajları vardır:

    1) Dinamik kütüphane kullanan programlar diskte daha az yer kaplarlar. 
    
    2) Dinamik kütüphane kullanan programlarda dinamik kütüphane içerisindeki fonksiyonlarda değişiklikler yapıldığında çalıştırılabilen 
    programın yeniden derlenmesine ve link edilmesine gerek kalmaz. 

    3) Farklı proseslerin aynı dinamik kütüphaneyi kullanması durumunda bu dinamik kütüphane fiziksel RAM'e tekrar tekrar yüklenmemektedir. 
    Bu da aslında toplamda daha iyi bir RAM optimizasyonu sağlamaktadır.

    Ancak dinamik kütüphane kullanan programlar başka bir makineye konuşlandırılırken (deploy edilirken) yalnızca çalıştırılabilen dosya değil
    onun kullandığı bütün dinamik kütüphaneler de o makineye çekilmek zorundadır. Ayni artık program tek bir çalıştırılabilen dosyadan 
    oluşmamaktadır. O dosyanın kullandığı dinamik kütüphaneler de programın bir parçası durumundadır. Dinamik kütüphane kullanımının şu 
    dezavantajları söz konusu olabilmektedir:

    1) Dinamik kütüphane kullanan programların hedef makineye konuşlandırılması daha zahmetlidir.

    2) Dinamik kütüphane kullanan programların yüklenmesi daha uzun zaman alma eğilimindedir. 

    3) Dinamik kütüphane kullanan programlar prosesin sanal bellek alanında daha fazla yer kaplamaktadır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Microsoft Windows sistemlerinde bir DLL oluşturmak için tek yapılacak şey link aşamasında "/DL"L seçeneğini kullanmaktır. Örneğin a.c ve 
    b.c dosyalarını derleyerek bunlardan DLL yapmak isteyelim. Bu işlemi parça paça şöyle gerçekleştirebiliriz:

    cl /c a.c
    cl /c b.c
    link /DLL a.obj b.obj

    Buradan ilk dosyanın ismine ilişkin "a.dll" dosyası elde edilecektir. Tabii "/DL"L seçeneği kullanılmasaydı default durumda bu dosyalardan 
    ".exe" dosyası oluşturulmaya çalıştırılacaktı. Tabii bu durumda bir main fonksiyonun buluması gerekecekti. Hedef dosyanın ismi "/OUT" seçeneği
    ile belirlenebilmektedir. Örneğin:

    cl /c a.c
    cl /c b.c
    link /OUT:myutil.dll /DLL a.obj b.obj
    
    Burada "myutil.dll" dosyası oluşturulacaktır. Yukarıdaki işlem aslında tek hamlede "cl" programının komut satırında "/LD" seçeneği kullanılarak 
    aşağıda gibi de yapılabilmektedir:

    cl /LD a.c b.c 

    Burada ilk dosyanın ismine ilişkin DLL dosyası (yani "a.dll" dosyası) oluşturulacaktır. Ancak dinamik kütüphaneye istediğimiz ismi vermek 
    istiyorsak "cl" komut satırında "/Fe" kullanılması gerekir. "/OUT" seöeneği bir bağlayıcı seçeneğidir. "/Fe" seçeneği ise bir "cl" derleyicisinin
    seçeneğidir. (Başka bir deyişle biz "cl" derleyicisini "/Fe" seçeneği ile çalıştırdığımızda aslında "cl" derleyicisi "link" isimli bağlayıcıyı
    "/OUT" seçeneği ile çalıştırmaktadır.) Örneğin:

    cl /Fe:myutil.dll /LD a.c b.c

    Bura artık "myutil.dll" isimli dosya oluşturulacaktır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Teknik anlamda Microsoft Windows sistemlerinde ".EXE" dosyası ile ".DLL" dosyası arasında format bakımından farklılık yoktur. He iki dosya 
    da "PE (Portable Executable)" dosya formaına ilişkindir. ".EXE" doaysının ".DLL" dosyasından tek farkı bir "entry point" yani main fonksiyonuna 
    sahip olmasıdır. Bir DLL içerisinde main fonksiyonunun olması o DLL dosyasını EXE dosya yapmaz. DLL dosyasının içerisindeki main fonksiyonu 
    sıradan bir fonksiyon gibi DLL'in içerisinde bulunur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta bir DLL içerisindeki fonksiyonun ya da global nesnenin dışarıdan kullanılabilmesi için o fonksiyonun ya da global nesnenin adresinin 
    PE formatının "export tablosu" denilen bir yerinde bulunması gerekir. İşte DLL içerisindeki bir global nesnenin ya da fonksiyonun adresinin 
    export tablosuna yazılması için Micrososft derleyicilerine özgü __declspec(dllexport) belirleyicisinin kullanılması gerekmektedir. Aksi takdirde
    o fonksiyonlar ve nesneler başka bir modülden (yani başka bir DLL ya da EXE programdan) kullanılamazlar. Aşağıdaki örnekte DLL içerisinde 
    foo ve g_a dışarıdan kullanılbilir ancak bar g_b dışarıdan kullanılmaz. Tabii bu bar ve g_b DLL'in kendi içeriisndeki fonksiyonlardan 
    kullanılabilir. Örneğin:

    #include <stdio.h>

    __declspec(dllexport) int g_y;

    __declspec(dllexport) void foo(void)
    {
        printf("foo\n");
    }

    void bar(void)
    {
        printf("bar\n");
    }

    Buarada g_y global değişkeni ve foo fonksiyonu dışarıdan (örneğin bir exe dosya tarafından) kullanılabilir. Ancak bar fonksiyonu dışarıdan 
    kullanılamaz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                93. Ders 02/06/2024 - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında C++'taki sınıf (class) kavramı yapay ve mantıksal bir kavramdır. Aşağı seviyeli dünyada sınıf diye bir kavram yoktur. Aslında C++'ta 
    sınıflardaki üye fonksiyonlar global fonksiyonlar gibi derlenirler. Dolayısıyla C++'ta bir sınıfı DLL'e yerleştirmek için yine üye fonksiyonların 
    önünde hangi üye fonksiyonlar dışarıdan kullanılacaksa __declspec(dllexport) bildirimlerinin yapılması gerekir. Örneğin:

    class Sample {
    public:
        __declspec(dllexport) Sample(int a);
        __declspec(dllexport) void foo() const;
        __declspec(dllexport) void disp() const;
        void bar() const;
    private:
        int m_a;
    };

    Bu örnekte sınıfın "yapıcı fonksiyonu (constructor)" foo ve disp fonksiyonları dışarıdan kullanılabilir. Ancak bar fonksiyonu dışarıdan 
    kullanılamaz. __declspec(dllexport) belirleyicisi tanımlama sırasında kullanılmak zorunda değildir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
    __declspec(dllexport) Sample(int a);
    __declspec(dllexport) void foo() const;
    __declspec(dllexport) void disp() const;
    void bar() const;
private:
    int m_a;
};

Sample::Sample(int a)
{
    m_a = a;
}

void Sample::foo() const
{
    cout << "foo" << endl;
}

void Sample::disp() const
{
    cout << m_a << endl;
}

void Sample::bar() const
{
    cout << "bar" << endl;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın bütün üye fonksiyonlarının dışarıdan kullanılması isteniyorsa Windows sistemlerinde __declspec(dllexport) belirleyicisi class
    anahtar sözcüğü ile sınıf ismi arasına getirilebilir. Örneğin:

    class __declspec(dllexport) Sample {
    public:
        Sample(int a);
        void foo() const;
        void disp() const;
        void bar() const;
    private:
        int m_a;
    };

    Burada sınıfın bütün üye fonksiyonları dışarıdan kullanılabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class __declspec(dllexport) Sample {
public:
    Sample(int a);
    void foo() const;
    void disp() const;
    void bar() const;
private:
    int m_a;
};

Sample::Sample(int a)
{
    m_a = a;
}

void Sample::foo() const
{
    cout << "foo" << endl;
}

void Sample::disp() const
{
    cout << m_a << endl;
}

void Sample::bar() const
{
    cout << "bar" << endl;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta bir DLL içerisindeki fonksiyonlar dışarıdan kullanılırken yalnızca prototip yazılması aslında yeterlidir. Benzer biçimde 
    bir DLL içerisindeki global nesneler dışarıdan kullanılırken yalnızca extern bildirimi yeterlidir. Ancak ilgili fonksiyonun    ve global 
    nesnenin DLL içerisinde olduğu derleyiciye bildirilirse derleyici daha etkin kod üretebilmektedir. (Bu konudaki ayrıntılar "Windows Sistem 
    Programlama    Kursu" içerisinde ele alınmaktadır.) İşte derleyiciye ilgili fonksiyonun ya da global nesnenin bir DLL içeirisinde olduğunu 
    anlatabilmek için fonksiyonun prototipinin önüne __declspec(dllimport) belirleyicisi getirilir. Örneğin:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    /* Function Prototypes */

    __declspec(dllimport) double add(double a, double b);
    __declspec(dllimport) double sub(double a, double b);
    __declspec(dllimport) double multiply(double a, double b);
    __declspec(dllimport) double divide(double a, double b);
    __declspec(dllimport) void foo(void);

    /* extern declarations */

    __declspec(dllimport) extern int g_x;
    __declspec(dllimport) extern int g_y;

    #endif

    Burada DLL içerisindeki fonksiyonların prototiplerinin başına __declspec(dllimport) belirleyicisi getirilmiştir. 

    Ancak DLL içerisinden export edilmiş fonksiyonlar ve global nesneler kullanılırken ayrıca bağlama aşamasında bağlayıcının hangi DLL'den
    hangi sembollerin kullanıldığını bilmesi gerekir. İşte DLL kullanan programlar derlenirken bağlama aşamsında "DLL'in import kütüphanesi"
    denilen bir kütüphanenin de bulundurulması gerekmektedir. DLL'in import kütüphanesi DLL yaratılırken bağlayıcı tarafından zaten 
    yaratılmaktadır. Örneğin:

    cl /Fe:myutil.dll /LD a.c b.c

    Burada biz "myutil.dll" isimli dinamik kütüphaneyi yaratmak istemekteyiz. İşte bu kütüphane yaratılırken aynı zamanda DLL'in import 
    kütüphanesi de yaratılmaktadır. DLL'in import kütüphanesinin uzantısı ".lib" biçimindedir. Yukarıdaki derleme işleminin sonucunda aynı 
    zamanda "myutil.lib" isimli DLL'in import kütüphanesi de oluşturulmaktadır. Her ne kadar import kütüphanelerinin uzantıları da ".lib" 
    biçiminde olsa da bu dosyalar statik kütüphane dosyaları değildir. Bu dosya içerisinde yalnızca "DLL içerisindeki fonksiyonlara ilişkin 
    bazı bilgiler" vardır. İşte bu dosya dinamik kütüphaneyi kullanan program bağlanırken bağlama aşamasında kulanılmalıdır. Örneğin:

    cl app.c myutil.lib

    Windows'ta bir DLL'i kullanabilmek için yalnızca DLL dosyası değil aynı zamanda o DLL'in import kütüphanesinin de elimizde bulunuyor olması 
    gerekir. DLL'in import kütüphanesi yalnızca bağlama aşamasında kullanılmaktadır. Programın hedef makineye konuşlandırılması sırasında import 
    kütüphanesinin hedef makineye kopyalanmasına gerek yoktur. 

    Aşağıdaki örnekte "a.c" ve "b.c" dosyalarından "myutil.dll" dosyası oluşturulmuştur. Sonra bu DLL'i kullanan "app.c" programı derlenerek 
    çalıştırılmıştır. Bu işlemleri komut satırında şöyle yapabilirsiniz:

    cl /OUT:myutil.dll /LD a.c b.c
    cl app.c myutil.lib
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* app.c */

#include <stdio.h>

__declspec(dllexport) int g_x;

__declspec(dllexport) double add(double a, double b)
{
    return a + b;
}

__declspec(dllexport) double sub(double a, double b)
{
    return a - b;
}

__declspec(dllexport) double multiply(double a, double b)
{
    return a * b;
}

__declspec(dllexport) double divide(double a, double b)
{
    return a / b;
}

/* b.c */

#include <stdio.h>

__declspec(dllexport) int g_y;

__declspec(dllexport) void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/* app.c */

#ifndef MYUTIL_H_
#define MYUTIL_H_

/* Function Prototypes */

__declspec(dllimport) double add(double a, double b);
__declspec(dllimport) double sub(double a, double b);
__declspec(dllimport) double multiply(double a, double b);
__declspec(dllimport) double divide(double a, double b);
__declspec(dllimport) void foo(void);

/* extern declarations */

__declspec(dllimport) extern int g_x;
__declspec(dllimport) extern int g_y;

#endif

/* app.c */

#include <stdio.h>
#include "myutil.h"

int main(void)
{
    double result;

    result = add(10, 20);
    printf("%f\n", result);

    result = sub(10, 20);
    printf("%f\n", result);

    result = multiply(10, 20);
    printf("%f\n", result);

    result = divide(10, 20);
    printf("%f\n", result);

    foo();
 
    return 0;
}


/*------------------------------------------------------------------------------------------------------------------------------------------
    Kütüphaneler için birer başlık dosyası oluşturmanın iyi bir teknik olduğunu belirtmiştik. Bu başlık dosyası hem kütüphane derlenirken hem de 
    kütüphane kullanılırken include edilir. Pekiyi bu başlık dosyasının içerisinde fonksiyon prototiplerinin önünde __declspec(dllexport) belirleyicisi 
    mi yoksa __declspec(dllimport) belirleyicisi mi bulunmalıdır? İşte kütüphanenin kendisi derlenirken __declspec(dllexport) belirleyicisi 
    kütüphaneyi kullanan kodlar derlenirken __declspec(dllimport) belirleyicisi bulunmalıdır. Bu işlem basit bir sembolik sabite dayalı olarak 
    gerçekleştirilebilir. Örneğin:

    #ifdef DLLBUILD
        #define DLLSPEC        __declspec(dllexport)
    #else
        #define DLLSPEC        __declspec(dllimport)
    #endif 

    Burada DLLBUILD isimli sembolik sabit define edilmişse DLLSPEC makrosu yerine __declspec(dllexport) belirleyicisi define edilmemişse
    DLLSPEC makrosu yerine __declspec(dllimport) belirleyicisi yerleştirilecektir. Bu durumda fonksiyon prototipleri şöyle belirtilebilir:

    DLLSPEC double add(double a, double b);
    DLLSPEC double sub(double a, double b);
    DLLSPEC double multiply(double a, double b);
    DLLSPEC double divide(double a, double b);
    DLLSPEC void foo(void);

    İşte eğer DLL'in kendisi oluşturulacaksa bu başlık dosyasının include edildiği yerin başına DLLBUILD sembolik sabiti define edilir, eğer
    DLL kullanılacaksa bu sembolik sabit define edilmez. Böylece tek bir başlık dosyası hem DLL'deki dosyalar tarafından hem de o DLL'i kullanan
    dosyalar tarafından include edilebilir. 

    Aşağıda buna bir örnek verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* myutil.h */

#ifndef MYUTIL_H_
#define MYUTIL_H_

#ifdef DLLBUILD
    #define DLLSPEC        __declspec(dllexport)
#else
    #define DLLSPEC        __declspec(dllimport)
#endif 

/* Function Prototypes */

DLLSPEC double add(double a, double b);
DLLSPEC double sub(double a, double b);
DLLSPEC double multiply(double a, double b);
DLLSPEC double divide(double a, double b);
DLLSPEC void foo(void);

/* extern declarations */

DLLSPEC extern int g_x;
DLLSPEC extern int g_y;

#endif

/* a.c */

#define DLLBUILD

#include <stdio.h>
#include "myutil.h"

int g_x;

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* b.c */

#define DLLBUILD 

#include <stdio.h>
#include "myutil.h"

int g_y;

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/* app.c */

#include <stdio.h>
#include "myutil.h"

int main(void)
{
    double result;

    result = add(10, 20);
    printf("%f\n", result);

    result = sub(10, 20);
    printf("%f\n", result);

    result = multiply(10, 20);
    printf("%f\n", result);

    result = divide(10, 20);
    printf("%f\n", result);

    foo();
 
    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir DLL'i kullanan bir program çalıştırılmak istendiğinde işletim sistemi o programın kullandığı DLL'i sırasıyla belirli bazı dizinlerde
    aramaktadır. Çalıştırılabilen dosyanın içerisine kullanılan DLL'in yalnızca ismi yazılmaktadır. Onun bulunduğu yer yazılmamaktadır. Windows'ta
    çalıştırılabilen dosyanın kullandığı DLL'ler sırasıyla şu dizinlerde aranmaktadır:
    
    1) Çalıştırılabilen program dosyasının bulunduğu dizin
    2) Windows\System32 dizini
    3) Window\System dizini
    4) Windows dizininin kendisi
    5) Programı çalıştırmak isteyen prosesin (yani CreateProcess uygulayan prosesin) çalışma dizini
    6) PATH çevre değişkeni ile belirtilen dizinlerde sırasıyla 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphaneler Windows sistemlerinde IDE'lerle daha kolay yaratılabilirler. Visual Studio IDE'sinde proje oluşturulurken proje türü
    olarak "Dynamic Link Library" seçilirse bu proje build edildiğinde DLL dosyası elde edilecektir. Ancak bu proje seçeneği projeye içinde 
    yalnızca DllMain fonksiyonu bulunan bir C++ dosyası barındırmaktadır. Tabii boş olarak da bir DLL projesi oluşturulabilir. Bunun için 
    boş bir console projesi yaratılır. İçerisine kaynak dosyalar yerleştirilir. Sonra proje ayarlarından "General/Build Type" seçeneği "Application"
    yerine "Dynamic Link Library" olarak seçilir. Artık proje build edildiğinde EXE dosyası yerine DLL dosyası dosyası oluşturulacaktır. 
    Tabii DLL'in import kütüphanesi de aynı dizinde yaratılmış olacaktır.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphane oluşturmak için önce dinamik kütüphane oluşturulacak ".c" dosyaları "position indepenedent code"
    tekniği ile derlenmelidir. "Position Independent Code" ilgili dinamik kütüphanenin yüklenme yerinden bağımsız çalışabilmesini sağşamaktadır. 
    Windows bu tekniği tercih etmemiştir. Windows'un yükleyicisi "relocation" işlemi ile DLL'leri farklı yerlere yükleyebilmektedir. Position
    Independent Code tekniği ile derlenmiş olan dosyalar "-shared" bağlama seçeneği ile bağlanırsa dinamik kütüphane oluşturulabilmektedir. 
    UNIX/Linux sistemlerinde kütüphane içerisindeki global sembollerin hepsi otomatik olarak export edilmektedir. Dolayısıyla bu sistemlerde 
    Windows sistemlerinde olduğu gibi __declspec(dllexport) ve __declspec(dllimport) biçiminde bildirimler yoktur. Tabii bu konuda da bazı 
    ayrıntılar bulunmaktadır.

    gcc ve clang derleyicilerinde bir dosyanın "konumdan bağımsız" biçimde derlenmesi için "-fPIC" seçeneğinin kullanılması gerekir. Örneğin:

    $ gcc -c -fPIC a.C
    $ gcc -c -fPIC b.C

    Burada "a.o" ve "b.o" dosyaları oluşturulacktır. Ayrıca yukarıda da belirttiğimiz Bağlama işleminde "-shared" seçeneğinin kullanılması 
    gerekmektedir. Örneğin:

    $ gcc -o libmyutil.so -shared a.o b.o

    Aslında bu iki işlem tek hamlede de aşağıdaki gibi yapılabilir:

    $ gcc -o libmyutil.so -shared -fPIC a.c b.c

    Yine UNIX/Linux sistemlerinde dinamik kütüphane dosyaları başına "lib" öneki getirilerek isimlendirilmelidir. 

    Aşağıda dinamik kütüphaneyi oluşturan "a.c" ve "b.c" dosyaları verilmiştir. Dinamik kütüphaneyi yukarıda belirttiğimiz biçimde oluşturmayı
    deneyiniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>

int g_x;

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* b.c */

#include <stdio.h>

int g_y;

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde "dinamik kütüphanelerin import kütüphanesi" denilen kütüphaneleri yoktur. Dinamik kütüphane kullanan programlar 
    doğrudan bu dinamik kütüphane dosyasının kendisini bağlama aşamasında kullanmaktadır. Örneğin "app.c" programı "libmyutil.so" dinamik 
    kütüphanesini kullanıyor olsun. Bu "app.c" programının derlenmesi şöyle yapılmaktadır:

    gcc -o app app.c libmyutil.so

    Aşağıdaki "app.c" programını bu biçimde derleyiniz.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* myutil.h */

#ifndef MYUTIL_H_
#define MYUTIL_H_

/* Function Prototypes */

double add(double a, double b);
double sub(double a, double b);
double multiply(double a, double b);
double divide(double a, double b);
void foo(void);
void bar(void);

/* extern declarations */

extern int g_x;
extern int g_y;

#endif

/* app.c */

#include <stdio.h>
#include "myutil.h"

int main(void)
{
    double result;

    result = add(10, 20);
    printf("%f\n", result);

    result = sub(10, 20);
    printf("%f\n", result);

    result = multiply(10, 20);
    printf("%f\n", result);

    result = divide(10, 20);
    printf("%f\n", result);

    foo();
    bar();

    return 0;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde yine çalıştırılabilen dosyanın içerisine yalnızca dinamik kullanılan dinamik kütüphanelerin isimleri yazılmaktadır. 
    Dinamik kütüphaneler yine bu sistemlerde de belli yerlerde aranmaktadır. Ancak bu sistemlerde dinamik kütüphaneler çalıştırılabilen dosyanın 
    bulunduğu dizinde ya da onu çalıştıran prosesin çalışma dizininde aranmamaktadır. Bu nedenle örneğin Linux sistemlerinde dinamik kütüphane 
    kullanan bir programla dinamik kütüphanenin kendisi aynı dizinde bulunuyor olsa bile program çalıştırıldığında dinamik kütüphane bulunamayacaktır. 
    
    UNIX/Linux sistemlerinde dinamik kütüphanelerin aranma prosedürlerine ilişkin bazıı ayrıntılar vardır. Biz burada bu ayrıntılar üzerinde 
    durmayacağız. Ancak kabaca arama için üç önemli adımı şöyle belirtebiliriz:

    1) Programı çalıştıran (yani exec yapan) prosesin LD_LIBRARY_PATH çevre değişkeni ile belirtilen dizinlerinde tek tek arama yapılmaktadır.
    Bu eçvre değişkeninin değeri ':' karakterleriyle ayrılan dizinler biçiminde olabilir. Örneğin:

    $ export LD_LIBRARY_PATH=/home/kaan:/home/kaan/Study:.

    Burada dinamik kütüphaneler sırasıyla "/home/kaan" dizininde, "/home/kaan/Study" dizininde ve o anda exec yapan prosesin çalışma dizininde 
    aranacaktır. Tabii kabuk üzerinde çalıtırmayı aşağıdaki gibi de yapabiliriz:

    $ LD_LIBRARY_PATH=. ./app

    2) Çalıştırılacak programın ".dynamic" bölümünde DT_RUNPATH özelliği varsa oradaki dizinde aranmaktadır. 

    3) "/lib" ve "/usr/lib" dizinlerine bakılır. Bazı 64 bit Linux dağıtımlarında "/lib64" ve "/usr/lib64" dizinlerine de bakılmaktadır. 

    Eğer bu sistemlerde oluşturduğumuz dinamik kütüphaneler başka programlar tarafından da kullanılıyorsa onun yerleştirilmesi gereken en doğal 
    "/usr/lib" dizinidir. "/lib" dizini daha aşağı seviyeli işletim sistemi tarafıdan kullanılan dinamik kütüphanelere ayrılmıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                    94. Ders 08/06/2024  - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphaneler programın çalışma zamanı sırasında programcının istediği bir noktada programcı tarafından da yüklenebilmektedir. 
    Bu duruma "dinamik kütüphanelerin dinamik yüklenmesi" denilmektedir. Dinamik yükleme özelliği hem Windows sistemlerinde hem de UNIX/Linux 
    ve macOS sistemlerinde bulunmaktadır. Biz önce Windows sistemlerinde sonra da UNIX/linux sistemlerinde bunun yapılacağını göreceğiz. macOS
    sistemlerinde işlemler tamamen UNIX/Linux sistemlerinde olduğu gibi yapılmaktadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde dinamik kütüphanelerin dinamaik biçimde yüklenerek kullanılması sırasıyla şu aşamalardan geçilerek yapılmaktadır:

    1) Önce LoadLibrary API fonksiyonuyla DLLprosesin sanal bellek alanına yüklenir. LoadLibrary API fonksiyonunun prototipi şöyledir.
    şöyledir:

    HMODULE LoadLibraryA(
        LPCSTR lpLibFileName
    );
    
    Fonksiyon yüklenecek olan DLL'in yol ifadesini parametre olaraj almaktadır. Eğer yol ifadesinde en az bir '\' karakteri varsa DLL yalnızca 
    o dizinde aranmaktadır. Eğer yol ifadesinde hiçbir '\' karakteri yoksa bu durumda DLL daha önce açıkladığımız gibi bazı dizinlerde sırasıyla
    aranır. Bu fonksiyon dinamik kütüphaneyi yükleyerek yüklenen sanal bellek adresine geri dönmektedir. Geri dönüş değeri HMODULE türündendir. 
    Bu tür de aslında void * olarak typedef edilmiştir. Fonksiyon başarısızlık durumunda NULL adrese geri dönmektedir. Örneğin:

    HMODULE hModule;

    if ((hModule = LoadLibrary("MyUtil.dll")) == NULL)
        ExitSys("LoadLibrary");

    2) DLL içerisinden çağrılacak fonksiyonun ya da kullanılacak global değişkenin adresi GetProcAddress fonksiyonuyla elde edilir. Fonksiyonun
    prototipi şöyledir:

    FARPROC GetProcAddress(
          HMODULE hModule,
          LPCSTR  lpProcName
    );
    
    Fonksiyonun birinci parametresi LoadLibrary fonksiyonundan elde edilen modül yükleme adresini, ikinci parametresi ise adresi elde edlecek 
    fonksiyonun ya da global değişkenin ismini almaktadır. Fonksiyon başarı durumunda ilgili fonksiyonun ya da global değişkenin adresine 
    başarısızlık durumunda NULL adrese gerei dönmektedir. Fonksiyonun geri dönüş değeri olan FARPROC 32 bit Windows sistemlerinde aşağıdaki 
    typedef edilmiştir:

    typedef int (WINAPI *FARPROC)();

    64 bit Windows sistemlerinde ise şöyle typedef edilmiştir:

    typedef INT_PTR (WINAPI *FARPROC)();

    Bu geri dönüş değeri genel bir tür biçiminde bulundurulmuştur. Uygun fonksiyon türüne dönüştürrülmelidir. Örneğin:

    
    typedef double (*PROCADDR)(double, double);
    ...
    PROCADDR padd;

    if ((padd = (PROCADDR)GetProcAddress(hModule, "add")) == NULL)
        ExitSys("GetProcAddress");

    GetProcAddress fonksiyonunda bir noktaya dikkat edilmesi gerekir. Derleyiciler C'deki değişken isimlerini amaç dosyaya dekore ederek 
    yazabilmektedir. Bizim GetProcAddress fonksiyonunda bu dekore edilmiş isimleri kullanmamız gerekmektedir. Microsoft C derleyicilerinde 
    cdecl çağırma biçiminde sembollerin başına '_' karakteri getirerek bir dekorasyon uygulamamaktadır. Fakat Microsoft bağlayıcıları sembolleri 
    DLL'in export tablosuna yazarken bu baştaki '_' karakterlerini atmaktadır. C++'ta farklı parametrik yapılara ilişkin aynı isimli fonksiyonlar 
    bulunabileceği için C++ derleyicilerinin hepsi meecburen bir isim dekorasyonu uygulamaktadır. İşte programcının export sembol isimlerin emin 
    olabilmesi için dumpbin programı ile DLL dosyasının export tablosuna bakabilir. Örneğin:

    C:\Dropbox\Shared\Kurslar\SysProg-1\Src\Libraries\Dynamic>DUMPBIN /EXPORTS myutil.dll
    Microsoft (R) COFF/PE Dumper Version 14.39.33523.0
    Copyright (C) Microsoft Corporation.  All rights reserved.

    Dump of file myutil.dll

    File Type: DLL

    Section contains the following exports for myutil.dll

        00000000 characteristics
        FFFFFFFF time date stamp
            0.00 version
            1 ordinal base
            7 number of functions
            7 number of names

        ordinal hint RVA      name

            1    0 00001000 add
            2    1 00001060 divide
            3    2 00001080 foo
            4    3 0001B39C g_x
            5    4 0001B398 g_y
            6    5 00001040 multiply
            7    6 00001020 sub

    Summary

            2000 .data
            7000 .rdata
            1000 .reloc
        12000 .text

    Ancak eğer biz bir C++ dosyasını derleyip ondan dinmaik kütüphane yapmış olsaydık sembol isimleri oldukça farklılaşacaktı. Örneğin:

        C:\Dropbox\Shared\Kurslar\SysProg-1\Src\Libraries\Dynamic>DUMPBIN /EXPORTS myutilcpp.dll
    Microsoft (R) COFF/PE Dumper Version 14.39.33523.0
    Copyright (C) Microsoft Corporation.  All rights reserved.


    Dump of file myutilcpp.dll

    File Type: DLL

    Section contains the following exports for myutilcpp.dll

        00000000 characteristics
        FFFFFFFF time date stamp
            0.00 version
            1 ordinal base
            7 number of functions
            7 number of names

        ordinal hint RVA      name

            1    0 00001000 ?add@@YANNN@Z
            2    1 00001060 ?divide@@YANNN@Z
            3    2 00001080 ?foo@@YAXXZ
            4    3 0001A968 ?g_x@@3HA
            5    4 0001A96C ?g_y@@3HA
            6    5 00001040 ?multiply@@YANNN@Z
            7    6 00001020 ?sub@@YANNN@Z

    Summary

            2000 .data
            7000 .rdata
            1000 .reloc
        12000 .text

    3) Artık adresi elde edilmiş olan fonksiyon çağrılabilir, global değişken kullanılabilir. Örneğin:

    result = padd(10, 20);

    4) Dinamik kütüphanenin kullanımı bittikten sonra kütüphane FreeLibrary API fonksiyonu ile prosesin adres alanından boşaltılabilir. 
    FreeLibrary fonksiyonunun prototipi şöyledir:

    BOOL FreeLibrary(
        HMODULE hLibModule
    );

    Fonksiyon modülün yüklenme adresini parametre olarak alır, başarı durumunda sıfır dışı bir değere başarısızlık durumunda sıfır değerine
    geri döner. Tabii proses sonlaadığında bütün dinamik kütüphaneler zaten adres alanından boşaltılmaktadır. 

    Aşağıda Windows sistemlerinde dinamik kütüphanenin dinamik yüklenmesine ilişkin bir örnek verilmiştir. Bu örnekteki "myutil.dll" dosyasının 
    proje dizininde bulunduğundan emin olunuz. DLL'in derlenmesini komut satırından şöyle yapabilirsiniz.

    cl /Fe:myutil.dll a.c b.c /LD
-------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void ExitSys(LPCSTR lpszMsg);

typedef double (*PROCADDR)(double, double);

int main(void)
{
    HMODULE hModule;
    PROCADDR padd, psub, pmultiply, pdivide;
    double result;
        
    if ((hModule = LoadLibrary("myutilcpp.dll")) == NULL)
        ExitSys("LoadLibrary");

    if ((padd = (PROCADDR)GetProcAddress(hModule, "?add@@YANNN@Z")) == NULL)
        ExitSys("GetProcAddress");

    result = padd(10, 20);
    printf("%f\n", result);

    if ((psub = (PROCADDR)GetProcAddress(hModule, "sub")) == NULL)
        ExitSys("GetProcAddress");

    result = psub(10, 20);
    printf("%f\n", result);

    if ((pmultiply = (PROCADDR)GetProcAddress(hModule, "multiply")) == NULL)
        ExitSys("GetProcAddress");

    result = pmultiply(10, 20);
    printf("%f\n", result);

    if ((pdivide = (PROCADDR)GetProcAddress(hModule, "divide")) == NULL)
        ExitSys("GetProcAddress");

    result = pdivide(10, 20);
    printf("%f\n", result);

    FreeLibrary(hModule);

    return 0;
}

void ExitSys(LPCSTR lpszMsg)
{
    DWORD dwLastErr = GetLastError();
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* myutil.h */

#ifndef MYUTIL_H_
#define MYUTIL_H_

#ifdef DLLBUILD
    #define DLLSPEC        __declspec(dllexport)
#else
    #define DLLSPEC        __declspec(dllimport)
#endif 

/* Function Prototypes */

DLLSPEC double add(double a, double b);
DLLSPEC double sub(double a, double b);
DLLSPEC double multiply(double a, double b);
DLLSPEC double divide(double a, double b);

/* extern declarations */

DLLSPEC extern int g_x;

#endif

/* a.c */

#define DLLBUILD

#include <stdio.h>
#include "myutil.h"

int g_x;

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin UNIX/Linux sistemlerinde dinamik yüklenmesi aslında Windows sistemlerindekine benzemektedir. İşlemler sırasıyla 
    şöyle yürütülür:
    
    1) Önce dinamik kütüphane ldopen fonksiyonuyla adres alanına yüklenir. Bu fonksiyonu Windows sistemlerindeki LoadLibrary fonksiyonuna 
    benzetebilirsiniz. Bu fonksiyon yine dinamik kütüphanenin bellekteki yükleme adresine geri dönmektedir. Fonksiyonun prototipi şöyledir:

    #include <dlfcn.h>

    void *dlopen(const char *filename, int flags);

    Fonksiyonun birinci parametresi yüklenecek dinamik kütüphane dosyasının yol ifadesini belirtmektedir. Burada yol ifadesinde hiçbir '/' 
    karakteri kullanılmazsa dosya yukarıda belirtilen dizinlerde sırasıyla aranmaktadır. Ancak buradaki yol ifadesinde en az bir '/' kullanılırsa 
    dosya yalnızca o yol ifadesinde belirtilen dizinde aranır. İkinci parametre sembol çözümlemesinin ne zaman yapılacağına ilişkin bayraklardan 
    oluşmaktadır. Bu parametre RTLD_LAZY ya da RTLD_NOW değerlerinden biri biçiminde girilebilir. RTLD_LAZY sembol çözümlemesinin başvuru (yani 
    fonksiyonun çağrılması ya da global değişkenin kullanılması sırasında) sırasında yapılacağını RTLD_NOW ise yükleme sırasında yapılacağını 
    belirtmektedir. Diğer bayraklar için dokümanalara başvurulabilir. Fonksiyon başarı durumunda yükleme adresine, başarısızlık durumunda NULL 
    adrese geri döner. Başarısızlık nedeni için errno değişkeni set edilmez. Başarısızlık nedeni yazısal olarak dlerror fonksiyonuyla elde 
    edilmelidir. dlerror fonksiyonun prototipi şöyledir:

    char *dlerror(void);

    Fonksiyon statik bir biçimde tahsis edilmiş olan hata yazısının adresine geri dönmektedir. Örneğin:

    void *soaddr;
    ...

    if ((soaddr = dlopen("./libmyutil.so", RTLD_LAZY)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    Tıpkı Windows sistemlerinde olduğu gibi dlopen fonksiyonu dinamik kütüphanenin yol ifadesi belirtilirken eğer hiç '/' karakteri kullanılmazsa 
    bu durumda dosya Linux sistemlerindeki yukarıda belirttiğimiz dizinlerde aranmaktadır. (Linux sistemlerinde arama sırasında çalışma dizinine 
    bakılmadığını anımsayınız). Eğer yol ifadesinde en az bir tane '/' karakteri kullanılmışsa dosya belirtilen yol ifadesinde aranmaktadır. 

    2) dlsym fonksiyonuyla dinamik kütüpahane içerisindeki herhangi bir fonksiyon ya da nesnenin adresi elde edilebilmektedir. dlsym fonksiyonun 
    prototipi şöyledir:

     #include <dlfcn.h>
    
    void *dlsym(void *handle, const char *symbol);

    Fonksiyonun birinci parametresi dlopen fonksiyonundan elde edilen adresi, ikinci parametresi ise adresi elde edilecek fonksiyon ya da global 
    nesnenin ismini belirtmektedir. Fonksiyon başarı dıurumunda ilgili nesnenin adresine başarısızlık durumunda NULL adrese geri dönmektedir. 
    Yine başarısızlık nedeni dlerror fonksiyonuyla elde edilmelidir. C'de data adreslerinden fonksiyon adreslerine, fonksiyon adreslerinden data 
    adreslerine tür dönüştürme operatör ile bile dönüştürmenin geçerli olmadığına dikkat ediniz. (Ancak derleyicilerin çoğu buna izin vermektedir.) 
    Anımsayanacağınız gibi void * türü bir data adresi kabul edilmektedir. Örneğin:

    typedef double (*PROCADDR)(double);
    ...
    PROCADDR padd;
    ...

    if ((*(void **)&padd = dlsym(soaddr, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    dlsym fonksiyonunu Windows sistemlerindeki GeProcAddress fonksiyonuna benzetebilirsiniz. 

    3) Artık adresi elde edilmiş olan fonksiyon çağrılabilir, global değişken kullanılabilir. 

    4) Dinamik kütüphanenin kullanımı bittiğinde kütüphane dlclose fonksiyonuyla boşaltılır. Fonksiyonun prototipi şöyledir:

    #include <dlfcn.h>

     int dlclose(void *handle);

    Fonksiyon parametre olarak dinamik kütüphanenin yükleme adres,n, alıp onu adres alanından yok etmektedir. Fonksiyon başarı durumunda sıfır
    değrine başarısızlık durumunda sıfır dışı bir değere geri dönemektedir. Yine başarısızlığın nedeni dlerror fonksiyonuyla yazdırılabilir. 
    Örneğin:

    dlclose(soaddr);

    Bütün bu fonksiyonlar "libdl.so" kütüphanesi içerisinde bulunmaktadır. Bu nedenle derleme yaparken komut satırında "-ldl" argümanını 
    bulundurunuz.

    Örnek bir kullanım aşağıda verilmiştir. Derlemeleri aşağıdaki gibi yapabilirsiniz:

    $ gcc -fPIC -o libmyutil.so libmyutil.c -shared
    $ gcc -o app app.c -ldl
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

void exit_sys(const char *msg);

typedef double (*PROCADDR)(double, double);

int main(void)
{
    void *soaddr;
    PROCADDR padd, psub, pmultiply, pdivide;
    double result;
    
    if ((soaddr = dlopen("./libmyutil.so", RTLD_LAZY)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&padd = dlsym(soaddr, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = padd(10, 20);
    printf("%f\n", result);

    if ((*(void **)&psub = dlsym(soaddr, "sub")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = psub(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pmultiply = dlsym(soaddr, "multiply")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = pmultiply(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pdivide = dlsym(soaddr, "divide")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = pdivide(10, 20);
    printf("%f\n", result);
    

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* libmyutil.c */

#include <stdio.h>

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde IP prokol ailesi ile ağa bağlı birimler arasında haberleşmelerin nasıl yapıldığı üzerinde duracağız. Bu bağlamda
    TCP ve UDP protokollerini inceleyeceğiz ve bu protokolleri kullanarak soket arayüzü ile temel programların nasıl yazıldığnı açıklayacağız.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Farklı makinelerin prosesleri arasında haberleşme (yani bir ağ içerisinde haberleşme), aynı makinenin prosesleri arasındaki haberleşmeye 
    göre daha karmaşık unsurlar içermektedir. Çünkü burada ilgili işletim sisteminin dışında pek çok belirlemelerin önceden yapılmış olması 
    gerekir. İşte ağ haberleşmesinde önceden belirlenmiş kurallar topluluğuna "protokol" denilmektedir. Ağ haberleşmesi için tarihsel süreç 
    içerisinde pek çok protokol ailesi gerçekletirilmiştir. Bunların bazıları büyük şirketlerin kontrolü altındadır ve hala kullanılmaktadır. 
    Ancak açık bir protokol ailesi olan "IP protokol ailesi" günümüzde farklı makinelerin prosesleri arasındaki haberleşmede hemen her zaman 
    tercih edilen protokol ailesidir. 

    Protokol ailesi (protocol family) denildiğinde birbirleriyle ilişkili bir grup protokol anlaşılmaktadır. Bir protokol ailesinin pek çok 
    protokolü başka protokollerin üzerine konumlandırılmış olabilmektedir. Böylece protokol aileleri katmanlı (layered) bir yapıya sahip 
    olmuştur. Üst seviye bir protokol alt seviye protokolün "zaten var olduğu fikriyle" o alt seviye protokol kullanılarak oluşturulmaktadır. 
    Bu katmanlı yapıyı prosedürel programlama tekniğinde "zaten var olan bir fonksiyonu kullanarak daha yüksek seviyeli bir fonksiyon yazmaya" 
    benzetebiliriz. 

    Ağ haberleşmesi için katmanlı bir protokol yapısının kavramsal olarak nasıl oluşturulması gerektiğine yönelik ISO tarafından 80'li yılların 
    başlarında "OSI Model (Open System Interconnection Model)" isimli bir referans dokümanı oluşturulmuştur. OSI model bir gerçekleştirim değildir. 
    Kavramsal bir referans dokümanıdır. Ancak bu referans dokümanı pek çok çalışma için bir zemin oluşturmuştur. OSI referans modeline göre bir 
    protokol ailesinde tipik olarak 7 katman bulunmalıdır. Bu katmanlar aşağıdaki gibi birbirlerini üzerine oturtulmuştur:

    Uygulama Katmanı (Application Layer)
    Sunum Katmanı (Presentation Layer)
    Oturum Katmanı (Session Layer)
    Aktarım Katmanı (Transort Layer)
    Network Katmanı (Network Layer)
    Veri Bağlantı Katmanı (Data Link Layer)
    Fiziksel Katman (Physical Layer)

    - En aşağı seviyeli elektriksel tanımlamaların yapıldığı katmana "fiziksel katman (physical layer)" denilmektedir. (Örneğin kabloların, 
    konnektörlerin özellikleri, akım, gerilim belirlemeleri vs. gibi.) Yani bu katman iletişim için gereken fiziksel ortamı betimlemektedir. 

    - Veri bağlantı katmanı (data link layer) artık bilgisayarlar arasında fiziksel bir adreslemenin yapıldığı ve bilgilerin paketlere ayrılarak 
    gönderilip alındığı bir ortam tanımlarlar. Yani bu katmanda bilgilerin gönderildiği ortam değil, gönderilme biçimi ve fiziksel adresleme 
    tanımlanmaktadır. Ağ üzerinde her birimin donanımsal olarak tanınabilen fiziksel bir adresinin olması gerekir. Örneğin bugün kullandığımız 
    Ethernet kartları "Ethernet Protocolü (IEEE 802.11)" denilen bir protokole uygun tasarlanmıştır. Bu ethernet protokolü OSI'nin fiziksel 
    ve veri bağlantı katmanına karşılık gelmektedir. Ethernet protokolünde yerel ağa bağlı olan her birimin ismine "MAC adresi" denilen 6 
    byte'lık fiziksel bir adresi vardır. Ethernet protokolünde MAC adresini bildiğimiz ağa bağlı bir birime bilgi gönderebiliriz. Bilgiler 
    "paket anahtarlaması packet switching)" denilen teknikle gönderilip alınmaktadır. Bu teknikte byte'lar bir paket adı altında bir araya 
    getirilir sonra ilgili fiziksel katmanla seri bir biçimde gönderilir. Bugün kullandığımız yerel ağlarda aslında bilgi bir birimden diğerine 
    değil hub'lar yoluyla ağa bağlı olan tüm birimleregönderilmektedir. Ancak bunlardan yalnızca biri gelen bilgiyi sahiplenmektedir. Bugün 
    kablosuz haberleşmede kullanılan "IEEE 802.11" protokolü de tıpkı Ethernet protokolü gibi hem bir fiziksel katman hem de veri bağlantı
     katmanı tanımlamaktadır.

     Fiziksel katman ve veri katmanı oluşturulduğunda artık biz yerel ağda bir birimden diğerine paket adı altında bir grup byte'ı gönderip 
     alabilir duruma gelmekteyiz. 

    - Ağ Katmanı (network layer) artık "internetworking" yapmak için gerekli kuralları tanımlamaktadır. "Internetworking" terimi "network'lerden 
    oluşan network'ler" anlamına gelir. Aynı fiziksel ortamda bulunan ağlara "Yerel Ağlar (Local Area Networks)" denilmektedir. Bu yerel 
    ağlar "router" denilen aygıtlarla birbirlerine bağlanmaktadır. Böylece "internetworking" ortamı oluşturulmaktadır. Tabii böyle bir ortamda 
    artık ağa bağlı birimler için fiziksel adresler kullanılamaz. Bu ortamlarda ağa bağlı birimlere mantıksal bir adreslerin atanması gerekmektedir. 
    İşte "network katmanı" internetworking ortamı içerisinde bir birimden diğerine bir paket bilginin gönderilmesi için gereken tanımlamaları içermektedir. 
    Ağ katmanı bu nedenle en önemli katmandır. Ağ katmanında artık fiziksel adresleme değil, mantıksal adresleme sistemi kullanılmaktadır. Ayrıca 
    bilgilerin paketlere ayrılarak router'lardan dolaşıp hedefe varması için rotalama mekanizması da bu katmanda tanımlanmaktadır. Yani elimizde 
    yalnızca ağ katmanı ve onun aşağısındaki katmanlar varsa biz artık "internetworking" ortamında belli bir kaynaktan belli bir hedefe paketler 
    yollayıp alabiliriz. 

    - Aktarım katmanı (transport layer) network katmanının üzerindedir. Aktarım katmanında artık kaynak ile hedef arasında mantıksal bir bağlantı 
    oluşturulabilmekte ve veri aktarımı daha güvenli olarak yapılabilmektedir. Aynı zamanda aktarım katmanı "multiplex" bir kaynak-hedef yapısı 
    da oluşturmaktadır. Bu sayede bilgiler hedefteki spesifik bir programa gönderilebilmektedir. Bu işleme "port numaralandırması" da denilmektedir.
    Bu durumda aktarım katmanında tipik şu işlemlere yönelik belirlemeler bulunmaktadır:

        - Bağlantnın nasıl yapılacağına ilişkin belirlemeler
        - Ağ katmanından gelen paketlerin stream tabanlı organizasyonuna ilşkin belirlemeler
        - Veri aktarımını güvenli hale getirmek için akış kontrolüne ilişkin belirlemeler
        - Gönderilen bilgilerin hedefte ayrıştıtılmasını sağlayan protokol port numaralandırmasına ilişkin belirlemeler

    - Oturum katmanı (session) katmanı pek çok protokol ailesinde yoktur. Görevi oturum açma kapama gibi yüksek seviyeli bazı  belirlemeleri 
    yapmaktır. Örneğin bu katmanda bir grup kullanıcıyı bir araya getiren oturumların nasıl açılacağına ve nasıl kapatılacağına ilişkin 
    belirlemeler bulunmaktadır. IP protokol ailesinde OSI'de belirtilen biçimde bir oturum katmanı yoktur. 

    - Sunum katmanı (presentation layer) verilerin sıkıştırılması, şifrelenmesi gibi tanımlamalar içermektedir. Yine bu katman IP protokol ailesinde
    OSI'de belirtildiği biçimde bulunmamaktadır. 

    - Nihayet protokol ailesini kullanarak yazılmış olan tüm  kullanan bütün programlar aslında uygulama katmanını oluşturmaktadır. Yani ağ 
    ortamında haberleşen her program zaten kendi içerisinde açık ya da gizli bir protokol oluşturmuş durumdadır. Örneğin IP protokol ailesindeki 
    somut işleri yapmakta kullanılan Telnet, SSH, HTTP, POP3, FTP gibi protokoller uygulama katmanı protokolleridir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bugün farklı makinelerin prosesleri arasında en çok kullanılan protokol ailesi IP (Internet Protocol) denilen protokol ailesidir. IP 
    protokol ailesi temel ve yardımcı pek çok protokolden oluşmaktadır. Aileye ismini veren ailenin ağ katmanı (network layer) protokolü olan 
    IP protoküdür. Pekiyi pekiyi IP ailesi neden bu kadar popüler olmuştur? Bunun en büyük nedeni 1983 yılında hepimizin katıldığı Internet'in 
    (I'nin büyük yazıldığına dikkat ediniz) bu aileyi kullanmaya başlamasıdır. Böylece IP ailesini kullanarak yazdığımız programlar hem aynı 
    bilgisayarda hem yerel ağımızdaki bilgisayarlarda hem de Internet'te çalışabilmektedir. Aynı zamanda IP ailesinin açık bir (yani bir şirketin 
    malı değil) protokol olması da cazibeyi çok artırmıştır.

    IP ailesi 70'li yıllarda Vint Cerf ve Bob Kahn tarafından geliştirilmiştir. IP ismi Internet Protocol'den gelmektedir. Burada internet 
    "internetworking" anlamında kullanılmıştır. Cerf ve Kahn 1974 yılında önce TCP protokolü üzerinde sonra da IP protokolü üzerinde çalışmışlar 
    ve bu protokollerin ilk versiyonlarını oluşturmuşlardır.

    Bugün hepimizin bağlandığı büyük ağa "Internet" denilmektedir. Bu ağ ilk kez 1969 yılında Amerika'da Amerikan Savunma Bakanlığı'nın 
    bir soğuk savaş projesi biçiminde başlatıldı. O zamana kadar yalnızca kısıtlı ölçüde yerel ağlar vardı. 1969 yılında ilk kez bir 
    "WAN (Wide Area Network)" oluşturuldu. Bu proje Amerikan Savunma Bakanlığı'nın DARPA isimli araştırma kurumu tarafından başlatılmıştır 
    ve projeye "ARPA.NET" ismi verilmiştir. Daha sonra bu ağa Amerika'daki çeşitli devlet kurumları ve üniversiteler katıldı. Sonra 
    ağ Avrupa'ya sıçradı. 1983 yılında bu ağ NCP protokolünden IP protokol ailesine geçiş yaptı. Bundan sonra artık APRA.NET ismi 
    yerine "Internet" ismi kullanılmaya başlandı. (Internet sözcüğü I herfi küçük harfle yazılırsa "internetworking" anlamında büyük 
    harfle yazılırsa bugün katıldığımız dev ağ anlamında kullanılmaktadır.) Biz de IP ailesini kullanarak kendi "internetworking" ortamımızı
    oluşturabiliriz. Örneğin bir şirket hiç Internet'e bağlanmadan kendi internet'ini oluşturabilir. Buna eskiden "intranet" denirdi. IP
    protokol ailesi herkesin kendi internet'ini oluşturabilmesi için bütün gerekli protokolleri barındırmaktadır. Tabii sinerji bakımından 
    herkes zaten var olan ve "Internet" denilen bu dev ağa bağlanmayı tercih etmektedir.

    IP protokol ailesi 4 katmanlı bir ailedir. Bu ailede "fiziksel ve veri bağlantı katmanı" bir arada düşünülebilir. Bugün bunlar 
    Ethernet ve Wireless protokolleri biçiminde kullanılmaktadır. IP ailesinin ağ katmanı aileye ismini veren IP protokolünden oluşmaktadır. 
    Aktarım katmanı ise TCP ve UDP protokollerinden oluşur. Nihayet TCP üzerine oturtulmuş olan HTTP, TELNET, SSH, POP3, IMAP gibi pek 
    çok protokol ailenin uygulama katmanını oluşturmaktadır. Tabii IP protokol ailesinde bu hiyerarşik yapıyla ilgili olmayan irili ufaklı pek 
    çok protokol de bulunmaktadır.

    +---------------------+-------------------------------+
    |  Application Layer  |   HTTP, SSH, POP3, IMAP, ...  |
    +---------------------+---------------+---------------+
    |    Transport Layer  |      TCP      |      UDP      |
    +---------------------+---------------+---------------+
    |     Network Layer   |               IP              |
    +---------------------+-------------------------------+
    |  Physical/Data Link |           Ethernet            |
    |       Layer         |           Wireless            |
    +---------------------+-------------------------------+

    IP protokolü tek başına kullanılırsa ancak ağa bağlı bir birimden diğerine bir paket gönderip alma işini yapar. Bu nedenle bu protokolün 
    tek başına kullanılması çok seyrektir. Uygulamada genellikle "aktarım (transport) katmanına" ilişkin TCP ve UDP ptotokolleri kullanılmaktadır. 
    IP ailesinin uygulama katmanındaki HTTP, SSH, POP3, IMAP, FTP gibi önemli protokollerinin hepsi TCP protokolü üzerine oturtulmuştur. 
    Ailede genellikle TCP protokolü kullanıldığı için buna kısaca "TCP/IP" de denilmektedir. 

    IP protokolü ailenin en önemli ve taban protokolüdür. IP protokolünde ağa bağlı olan ve kendisine IP adresiyle erişilebilen her birime 
    "host" denilmektedir. IP protokolü bir host'tan diğerine bir paket (buna IP paketi denilmektedir) bilginin gönderimine ilişkin tanımlamaları 
    içermektedir. IP protokolünde her host'un ismine "IP adresi" denilen mantıksal bir adresi vardır. Paketler belli bir IP adresinden diğerine 
    gönderilmektedir. IP protokolünün iki önemli versiyonu vardır: IPv4 ve IPv6. Bugün her iki versiyon da aynı anda kullanılmaktadır. IPv4'te 
    IP adresleri 4 byte uzunluktadır. (Protokolün tasarlandığı 70'li yıllarda 4 byte adres alanı çok geniş sanılmaktaydı). IPv6'da ise IP 
    adresleri 16 byte uzunluğundadır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    TCP bağlantılı (connection-oriented), UDP bağlantısız (connectionless) bir protokoldür. Buradaki bağlantı IP paketleriyle yapılan
    mantıksal bir bağlantıdır. Bağlantı sırasında gönderici ve alıcı birbirlerini tanır ve haberleşme boyunca haberleşmenin güvenliği için 
    birbirleriyle konuşabilirler. Bağlantılı protokol "client-server" tarzı bir haberleşmeyi akla getirmektedir. Bu nedenle TCP/IP denildiğinde
    akla "client-server" haberleşme gelmektedir. TCP modelinde client önce server'a bağlanır. Sonra iletişim güvenli bir biçimde karşılıklı
    konuşmalarla sürdürürlür. Tabii TCP bunu yaparken IP paketlerini yani IP protokolünü kullanmaktadır. UDP protokolü bağlantısızdır. Yani
    UDP protokolünde bizim bir host'a UDP paketi gönderebilmemiz için bir bağlantı kurmamıza gerek kalmaz. Örneğin biz televizyon yayını UDP
    modeline benzemektedir. Verici görüntüyü yollar ancak alıcının alıp almadığıyla ilgilenmez. Vericinin görüntüyü yollaması için alıcıyla 
    bağlantı kurması gerekmemektedir. 

    TCP "stream tabanlı", UDP ise "datagram (paket) tabanlı" bir protokoldür. Stream tabanlı protokol demek tamamen boru haberleşmesinde 
    olduğu gibi gönderen tarafın bilgilerinin bir kuyruk sistemi eşliğinde oluşturulması ve alıcının istediği kadar byte'ı parça parça 
    okuyabilmesi demektir. Datagram tabanlı haberleşme demek ise tamamen mesaj kuyruklarında olduğu gibi bilginin paket paket iletilmesi 
    demektir. Yani datagram haberleşmede alıcı taraf gönderen tarafın tüm paketini tek hamlede almak zorundadır. Stream tabanlı haberleşmenin 
    oluşturulabilmesi için IP paketlerine bir numara verilmesi ve bunların hedefte birleştirilmesi gerekmektedir. Örneğin biz bir host'tan
    diğerine 10K'lık bir bilgi gönderelim. TCP'de bu bilgi IP paketlerine ayrılıp numaralandırılır. Bunlar hedefte birleştirilir ve sanki
    10000 byte'lık ardışıl bir bilgiymiş gibi gösterilir. Halbuki UDP'de paketler birbirinden bağımsızdır. Dolayısıyla bunların hedefte 
    birleştirilmesi zorunlu değildir. IP protokolünde bir host birtakım paketleri diğer host'a gönderdiğinde alıcı taraf bunları aynı sırada 
    almayabilir. Bu özelliğinden dolayı TCP, ailenin en çok kullanılan aktarım (transport) katmanı protokolüdür.

    TCP güvenilir (reliable), UDP güvenilir olmayan (unreliable) bir protokoldür. TCP'de mantıksal bir bağlantı oluşturulduğu için yolda kaybolan 
    paketlerin telafi edilmesi mümkündür. Alıcı taraf gönderenin bilgilerini eksiksiz ve bozulmadan aldığını bilir. Aynı zamanda TCP'de "bir akış 
    kontrolü (flow control)" de uygulanmaktadır. Akış kontrolü sayesinde alıcı taraf tampon taşması durumuna karşı gönderici tarafı durdurabilmektedir. 
    Halbuki UDP'de böyle bir mekanizma yoktur. Gönderen taraf alıcının bilgiyi alıp almadığını bilmez. 

    Tüm bunlar eşliğinde IP ailesinin en çok kullanılan aktarım (transport) katmanının neden TCP olduğunu anlayabilirsiniz. Uygulama katmanındaki
    protokoller hep TCP kullanmaktadır. 

    Yukarıda da belirttiğimiz gibi IP protokol ailesinde ağa bağlı olan birimlere "host" denilmektedir. Host bir bilgisayar olmak zorunda değildir. 
    İşte bu protokol ailesinde her host'un mantıksal bir adresi vardır. Bu adrese IP adresi denilmektedir. IP adresi IPv4'te 4 byte uzunlukta, 
    IPv6'da 16 byte uzunluktadır. Ancak bir host'ta farklı programlar farklı host'larla haberleşiyor olabilir. İşte aynı host'a gönderilen IP 
    paketlerinin o host'ta ayrıştırılması için "protokol port numarası" diye isimlendirilen içsel bir numara uydurulmuştur. Port numarası bir 
    şirketin içerisinde çalışanların dahili numarası gibi düşünülebilir. Port numaraları IPv4'te ve IPv6'da 2 byte'la ifade edilmektedir. İlk 
    1024 port numarası IP ailesinin uygulama katmanındaki protokoller için ayrılmıştır. Bunlara İngilizce "well known ports" denilmektedir. Bu 
    nedenle programcıların port numaralarını 1024'ten büyük olacak biçimde seçmeleri gerekir. Bir host TCP ya da UDP kullanarak bir bilgi 
    gönderecekse bilginin gönderileceği host'un IP numarasını ve bilginin orada kime gönderileceğini  anlatan port numarasını belirtmek zorundadır. 
    IP numarası ve port numarası çiftine "IP End Point" de denilmektedir. Bilgiyi almak isteyen program kendisinin hangi portla ilgilendiğini de 
    belirtmek durumundadır. Örneğin biz bir host'ta çalışacak bir TCP/IP ya da UDP/IP program yazmak istiyorsak o host'un belli bir port numarasına
     gelen bilgilerle ilgileniriz. Port numarası kavramının IP protokolünde olmadığına TCP ve UDP protokollerinde bulunduğuna dikkat ediniz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    TCP ve UDP protokollerinin IP protokolü üzerine oturdulduğunu belirtmiştik. Bu ne anlama gelmektedir? Biz TCP ile belli bir IP numarası 
    ve port numarası (end point) belirterek bir grup byte'ı göndermiş olalım. Aslında bu byte topluluğu bir TCP paketi oluşturularak bir IP 
    paketi biçiminde yola çıkarılmaktadır. Şöyle ki: IP paketlerinin yapısı şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+
    |         IP Data         |
    +-------------------------+

    Burada IP Header'da söz konusu IP paketinin hedefe ulaştırılabilmesi için gerekli bilgiler bulunur. Gönderilecek asıl bilgi bu  paketin 
    "IP Data" kısmındadır. İşte bir TCP paketi aslında bir IP paketi olarak IP paketinin "IP Data" kısmına gömülerek gönderilmektedir. 
    Bu durumda TCP paketinin genel görünümü şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+   <---+
    |        TCP Header       |       |
    +-------------------------+     IP Data
    |         TCP Data        |       |
    +-------------------------+   <---+

    TCP paketinin de bir header ve data alanı olduğuna ancak paketin tamamının IP paketinin data alanında yolculuk ettirildiğine dikkat ediniz. 
    Yani TCP paketinin header ve data kısmı aslında IP paketinin data kısmı gibi oluşturulmaktadır. Böylece yolculuk eden paket aslında bir 
    TCP paketi değil IP paketidir. TCP bilgileri bu IP paketinin data kısmında bulunmaktadır. 
    
    IPv4 başlık uzunluğu 20 byte'dır. IPv4 paket başlık alanları aşağıdaki verilmiştir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------+----------------------+-----------------------------------------------+             ^
    |  Version  |    IHL    |    Type of Service   |                  Total Length                 |  (4 bytes)  |
    | (4 bits)  | (4 bits)  |       (8 bits)       |                   (16 bits)                   |             |
    +-----------+-----------+----------------------+-----------+-----------------------------------+             |
    |                 Identification               |   Flags   |           Fragment Offset         |  (4 bytes)  |
    |                   (16 bits)                  |  (3 bits) |              (13 bits)            |             |
    +-----------------------+----------------------+-----------+-----------------------------------+             |
    |   Time to Live (TTL)  |       Protocol       |                 Header Checksum               |  (4 bytes)  |  20 bytes
    |       (8 bits)        |       (8 bits)       |                    (16 bits)                  |             |
    +-----------------------+----------------------+-----------------------------------------------+             |
    |                                  Source IP Address (32 bits)                                 |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             |
    |                               Destination IP Address (32 bits)                               |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             v
    |                            Segment (L4 protocol (TCP/UDP) + Data)                            |
    +----------------------------------------------------------------------------------------------+

    TCP header'ı 20 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |
    |                                        Sequence Number                                       |  (4 bytes)  |
    |                                          (32 bits)                                           |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                    Acknowledgement Number                                    |  (4 bytes)  |
    |                                          (32 bits)                                           |             |  20 bytes
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |Header Len.|    Reserved    |   Control Bits  |                  Window Size                  |  (4 bytes)  |
    |  (4 bits) |    (6 bits)    |     (6 bits)    |                   (16 bits)                   |             |
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |                   Checksum                   |                     Urgent                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                           Options                                            |
    |                                        (0 or 32 bits)                                        |
    +----------------------------------------------------------------------------------------------+
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                 Header Length                |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

/*------------------------------------------------------------------------------------------------------------------------------------------
      IP haberleşmesi (yani paketlerin, oluşturulması, gönderilmesi alınması vs.) işletim sistemlerinin çekirdekleri tarafından yapılmaktadır. 
    Tabii User mode programlar için sistem çağrılarını yapan API fonksiyonlarına ve kütüphanelerine gereksinim vardır. İşte bunların en yaygın 
    kullanılanı "soket kütüphanesi" denilen kütüphanedir. Bu kütüphane ilk kez 1983 yılında BSD 4.2'de gerçekleştirilmiştir ve pek çok UNIX 
    türevi sistem bu kütüphaneyi aynı biçimde benimsemiştir. Sonra bu kütüphane POSIX standartlarına da dahil edilmiştir. Microsoft Windows 
    sistemleri için kendi soket kütüphanesini oluşturmuştur. Buna "Windows Socket API (WSA)" denilmektedir. Ancak Microsoft aynı zamanda klasik
    BSD soket arayüzünü de desteklemektedir. Yani biz Windows sistemlerinde hem başı WSAXXX ile başlayan Windows'a özgü soket fonksiyonlarını 
    hem de klasik Berkeley soket fonksiyonlarını kullanabilmekteyiz. Böylece UNIX/Linux sistemlerinde yazdığımız soket programlarını küçük 
    değişikliklerle Windows sistemlerine taşıyabilmekteyiz. 

    Berkeley soket kütüphanesi yalnızca IP protokol ailesi için tasarlanmış bir kütüphane değildir. Bütün protokollerin ortak kütüphanesidir. Bu 
    nedenle kütüphanedeki fonksiyonlar daha genel biçimde tasarlanmıştır.  

    Biz soket fonksiyonlarını kullanırken aslında arka planda işlemler TCP/IP ve UDP/IP protokollerine uygun bir biçimde gerçekleştirilmektedir. 
    Örneğin biz send soket fonksiyonu ile bir bilgiyi göndermek istediğimizde aslında bu fonksiyon arka planda bir TCP paketi dolayısıyla da bir 
    IP paketi oluşturarak protokole uygun bir biçimde bu bilgiyi göndermektedir. Soket kütüphanesinin yalnızca bir API arayüzü olduğuna dikkat 
    ediniz. 

    Yukarıda da belirttiğimiz gibi Berkeley soket kütüphanesi POSIX tarafından desteklenmektedir. Yani burada göreceğimiz soket fonksiyonları 
    aynı zamanda birer POSIX fonksiyonudur. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                    96. Ders 16/06/2024 - Pazar
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir TCP/IP uygulamasında iki ayrı program yazılır: "TCP Server Program" ve "TCP Client Program". Biz önce TCP server programın 
    daha sonra da TCP client programın yazımı üzerinde duracağız. Tabii TCP server programın üzerinde dururken zaten bazı ortak 
    soket fonksiyonlarını da göreceğiz. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir TCP server program tipik olarak aşağıdaki soket API'lerinin sırayla çağrılmasıyla gerçekleştirilmektedir:

    (Windows'ta WSAStartup --->)  socket ---> bind ---> listen ---> accept ---> send/recv (ya da UNIC/Linux'ta read/write)
    ---> shutdown ---> close (Windows'ta closesocket) (---> Windows'ta WSACleanup)

    Buradan da gördüğünüz gibi her ne kadar Windows UNIX tarzı Bekeley soket kütüphanesini destekliyorsa da şu küçük 
    farklılıklara sahiptir:

    1) Windows'ta soket sistemini başlatmak ve sonlandırmak için WSAStartup ve WSACleanup API fonksiyonları kullanılmaktadır.
    
    2) Windows'ta soket nesnesini yok etmek için close yerine closesocket API fonksiyonu bulunmaktadır. 
    
    3) Windows'ta bazı istisnalar dışında bir soket fonksiyonu başarısız olduğunda başarısızlığın nedeni GetLastError fonksiyonuyla değil 
    WSAGetLastError fonksiyonuyla elde edilmektedir. Bu nedenle Windows örneğimizde hataları rapor etmek için ExitSys fonksiyonunu aşağıdaki 
    biçimde tanımlayacağız:

    void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
    {
        LPTSTR lpszErr;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
            fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
            LocalFree(lpszErr);
        }

        exit(EXIT_FAILURE);
    }

    4) Windows'ta soket kütüphanesi API fonksiyonlarının bulunduğu kütüphaneler içerisinde değildir. Bu nedenle link amasında soket API'lerinin 
    bulunduğu dinamik kütüphanenin import kütüphanesi ("Ws2_32.lib") linker ayarlarında belirtilmelidir. 

    5) Windows sistemlerinde soket fonksiyonlarının protoipleri <winsock2.h> dosyası içerisindedir. Halbuki UNIX/Linux sistemlerinde fonksiyonların
    prototipleri farklı başlık dosyalarında bulunabilmektedir. Eğer <windows.h> dosyası da include edilecekse önce <winsock2.h> dosyası sonra 
    <windows.h> dosyası include edilmelidir.
    
    Windows'ta soket sistemini başlatmak için WSAStartup fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <winsock2.h>

    int WSAStartup(
        WORD      wVersionRequired,
        LPWSADATA lpWSAData
    );

    Fonksiyonun birinci parametresi talep edilen soket kütüphanesinin versiyonunu belirtmektedir. Buradaki WORD değer iki ayrı byte'ın birleşiminden 
    oluşmaktadır. MAKEWORD(high, low) makrosu ile bu parametre için argüman oluşturulabilir. Windows soket kütüphanesinin son versiyonu 2.2 versiyonudur. 
    Dolayısıyla bu parametre için argümanı MAKEWORD(2, 2) biçiminde geçebiliriz. Eğer talep edilen versiyon yüksekse bu durum hataya yol açmamakta 
    talep edilenden küçük olan en yüksek versiyon kullanıma hazır hale getirilmektedir. Fonksiyonun ikinci parametresi WSADATA isimli bir yapı 
    nesnesinin adresini almaktadır. Fonksiyon bu yapıya bazı bilgiler yerleştirmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda 
    hata kodunun kendisine geri dönmektedir. (Yani bu fonksiyon için WSAGetLastError çağrısına gerek yoktur.) Fonksiyon tipik olarak şöyle kullanılır:

    WSADATA wsaData;
    int result;
    ...

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", result);

    Windows'ta WSACleaanup fonksiyonun prototipi ise şöyledir:

    #include <winsock2.h>

    int WSACleanup(void);

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda SOCKET_ERROR özel değerine (bu değer genellikle -1 olarak define edilmektedir) 
    geri dönmektedir. Hatanın nedeni için WSAGetLastError fonksiyonuna başvurulmalıdır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Haberleşme için öncelikle bir soket nesnesinin yaratılması gerekmektedir. Bu işlem socket isimli fonksiyonla yapılmaktadır. socket fonksiyonu 
    bir soket nesnesi (handle alanı) yaratır ve bize handle değeri verir. Windows sistemlerinde socket fonksiyonunun geri döndürdüğü handle 
    değeri SOCKET isimli bir türdendir. Ancak UNIX/Linux sistemlerinde bir dosya betimleyicisi biçimindedir. Yani UNIX/Linux sistemlerinde 
    socket nesneleri tamamen bir dosya gibi kullanılmaktadır.  Windows sistemlerinde socket fonksiyonunun prototipi şöyledir:

    #include <winsock2.h>

    SOCKET socket(
        int af,
        int type,
        int protocol
    );
        
    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);

    Fonksiyonların parametreleri her iki sistemde de aynıdır. Yukarıda da gördüğünüz gibi tek fark Windows sistemlerinde soketin handle değerinin 
    SOCKET türüyle UNIX/Linux sistemlerinde ise int türüyle temsil edilmesidir. 

    socket fonksiyonunun birinci parametresi kullanılacak protokol ailesini belirtir. Bu parametre AF_XXX (Address Family) biçimindeki sembolik 
    sabitlerden biri olarak girilir. IPv4 için bu parametreye AF_INET, IPv6 için AF_INET6 girilmelidir. UNIX domain soketler için bu parametre 
    AF_UNIX olarak girilmelidir.

    Fonksiyonun ikinci parametresi kullanılacak protokolün stream tabanlı mı yoksa datagram tabanlı mı olacağını belirtmektedir. Stream soketler 
    için SOCK_STREAM, datagram soketler için SOCK_DGRAM kullanılmalıdır. Ancak başka soket türleri de vardır. TCP protokolünde bu parametre 
    SOCK_STREAM biçiminde UDP protokülünde ise bu parametre SOCK_DGRAM biçiminde girilmelidir. 

    Fonksiyonun üçüncü parametresi aktarım (transport) katmanındaki protokolü belirtmektedir. Ancak zaten ikinci parametreden aktarım protokolü 
    anlaşılıyorsa üçüncü parametre 0 olarak geçilebilmektedir. Örneğin IP protokol ailesinde üçüncü parametreye gerek duyulmamaktadır. Çünkü ikinci 
    parametredeki SOCK_STREAM zaten TCP'yi, SOCK_DGRAM ise zaten UDP'yi anlatmaktadır. Fakat yine de bu parametreye istenirse IP ailesi için 
    IPPROTO_TCP ya da IPPROTO_UDP girilebilir. (Bu sembolik sabitler UNIX/Linux sistemlerinde <netinet/in.h> içerisindedir.) 

    socket fonksiyonu başarı durumunda Windows'ta soket handle değerine UNIX/Linux sistemlerinde ise soket betimeleyicisine geri dönemktedir. 
    Fonksiyon başarısızlık durumunda Windows'ta SOCKT_ERROR değerine UNIX/Linux sistemlerinde ise -1 değerine geri dönmektedir. Windows sistemlerindeki
    SOCKET_ERROR sembolik sabiti de zaten -1 biçiminde define edilmiştir. Ancak Windows sistemlerinde SOCKET_ERROR sembolik sabitinin kullanılması 
    gerekir. 
    
    Örneğin Windows sistemlerinde socket nesnesi şöyle yaratılabilir:

    SOCKET serverSock;
    ...

    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
        ExitSys("socket", WSAGetLastError());

    Aynı işlem UNIX/Linux sistemlerinde şöyle yapılabilir:

    int server_sock;
    ...

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Server program soketi yarattıktan sonra onu bağlamalıdır (bind etmelidir). bind işlemi sırasında server'ın hangi portu dinleyeceği ve 
    hangi network arayüzünden (kartından) gelen bağlantı isteklerini kabul edeceği belirlenir. Ancak bind fonksiyonu dinleme işlemini başlatmaz. 
    Yalnızca soket nesnesine bu bilgileri yerleştirir. Fonksiyonun Windows sistemlerindeki prototipi şöyledir:

    #include <winsock2.h>

    int bind(
          SOCKET         s,
        const sockaddr *addr,
          int            namelen
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    int bind(int socket, const struct sockaddr *addr, socklen_t addrlen);

    Görüldüğü gibi fonksiyonların iki sistemde de prototipi aynıdır. Ancak Windows sistemlerinde soket nesnesi SOCKET türüyle temsil edilmektedir.
    Biz kursumuzda anlatımı kolaylaştırmak için her iki sistemde de socket handle değerine soket betimelyicisi diyeceğiz. 

    bind fonksiyonunun birinci parametresi yaratılmış olan soket betimleyicisini belirtir. İkinci parametre her ne kadar sockaddr isimli bir yapı 
    türünden gösterici ise de de aslında her protokol için ayrı bir yapı nesnesinin adresini almaktadır. Yani sockaddr yapısı burada genelliği 
    (void gösterici gibi) temsil etmek için kullanılmıştır. IPv4 için kullanılacak yapı sockaddr_in, IPv6 için sockaddr_in6 ve örneğin UNIX 
    domain soketler için ise sockaddr_un biçiminde olmalıdır. Üçüncü parametre, ikinci parametredeki yapının uzunluğu olarak 
    girilmelidir. 

    sockaddr_in yapısı UNIX/Linux sistemlerinde <netinet/in.h> dosyası içerisindedir. Windows sistemlerinde bu yapı şöyle bildirilmiştir:
    
    #include <winsock2.h>

    typedef struct sockaddr_in {
        short          sin_family;
        u_short        sin_port;
        struct in_addr sin_addr;
        char           sin_zero[8];
    } SOCKADDR_IN, *PSOCKADDR_IN, *LPSOCKADDR_IN;
    
    UNIX/Linux sistemlerinde ise bu yapı şöyle bildirilmiştir:

    #include <netinet/in.h>

    struct sockaddr_in {
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct in_addr  sin_addr;
    };

    Yapı elemanlarının türleri için iki sistemde farklı typedef isimleri kullanılmış olasa da elemanlar aynı anlamdadır. Yapının sin_family 
    elemanına protokol ailesini belirten AF_XXX değeri girilmelidir. Bu eleman tipik olarak short biçimde bildirilmiştir. Yapının sin_port 
    elemanı her iki sistemde de unsigned short türdendir. Server programın hangi portu dinleyeceği bu elemanla belirlenmektedir. Yapının 
    sin_addr elemanı IP numarası belirten bir elemandır. Bu eleman in_addr isimli bir yapı türündendir. Bu yapı Windows sistemlerinde şöyle 
    bildirilmiştir:

    struct in_addr {
        union {
            struct {
            u_char s_b1;
            u_char s_b2;
            u_char s_b3;
            u_char s_b4;
            } S_un_b;
            struct {
            u_short s_w1;
            u_short s_w2;
            } S_un_w;
            u_long S_addr;
        } S_un;
    };

    #define s_addr S_un.S_addr    
    
    UNIX/Linux sistemlerinde ise in_addr yapısı <netint/in.h> dosyası içerisinde şöyle bildirilmiştir:

    #include <netinet/in.h>

    struct in_addr {
        in_addr_t s_addr;
    };
    
    Aslında her iki sistemde de yapının s_addr elemanı IPV4 için 4 byte'lık işaretsiz tamsayı türü belirtmektedir. İşte bu 4 byte'lık işaretsiz
    tamsayı türü IPV4 için IP adresini belirtmektedir. Eğer buradaki IP adresi INADDR_ANY biçiminde geçilirse bu durum "herhangi bir network 
    kartından gelen bağlantı isteklerinin kabul edileceği" anlamına gelmektedir. 

    Yukarıda da belirttiğimiz gibi IP ailesinde tüm sayısal değerler "big endian" formatıyla belirtilmek zorundadır. Bu ailede 
    "network byte ordering" denildiğinde "big endian" format anlaşılır. Oysa makinelerin belli bir bölümü (örneğin Intel ve default ARM) 
    "little endian" kullanmaktadır. İşte elimizdeki makinenin endian'lığı ne olursa olsun onu big endian formata dönüştüren htons 
    (host to network byte ordering short) ve htonl (host to network byte ordering long) isimli iki fonksiyon vardır. Bu işlemlerin tersini 
    yapan da ntohs (network byte ordering to host short) ve ntohl (network byte ordering to host long) fonksiyonları da bulunmaktadır. 
    Fonksiyonların Windows sistemlerindeki prototipleri şöyledir:

    #include <winsock2.h>

    u_short htons(
          u_short hostshort
    );

    u_long htonl(
          u_long hostlong
    );

    u_short ntohs(
          u_short netshort
    );

    u_long ntohl(
          u_long netlong
    );

    Fonksiyonların UNIX/Linux sistemlerindeki prototipleri şöyledir:

    #include <arpa/inet.h>

    uint32_t htonl(uint32_t hostlong);
    uint16_t htons(uint16_t hostshort);
    uint32_t ntohl(uint32_t netlong);
    uint16_t ntohs(uint16_t netshort);

    Bu durumda sockaddr_in yapısı her iki sistemde de tipik olarak şöyle doldurulabilir:

    struct sockaddr_in sinaddr;

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(SERVER_PORT);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind fonksiyonu başarı durumunda sıfır değerine, başarısızlık durumunda Windows sistemlerinde SOCKET_ERROR değerine, UNIX/Linux sistemlerinde 
    ise -1 değerine geri dönmektedir. Örneğin Windows sistemlerinde fonksiyon şöyle çağrılabilir:

    if (bind(serverSock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    UNIX/Linux sistemlerinde de çağrı şöyle olabilir:

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    server program bind işleminden sonra soketi aktif dinleme konumuna sokmak için listen fonkiyonunu çağırmalıdır. Fonksiyonun Windows 
    sistemlerindeki prototipi şöyledir:

    #include <windows.h>

    int listen(
          SOCKET s,
          int backlog
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    int listen(int socket, int backlog);

    Fonksiyonun birinci parametresi soket betimleyicisini, ikinci parametresi kuyruk uzunluğunu belirtir. listen işlemi blokeye yol açmamaktadır. 
    İşletim sistemi listen işleminden sonra ilgili porta gelen bağlantı isteklerini uygulama için oluşturduğu bir bağlantı kuyruğuna yerleştirmektedir. 
    Kuyruk uzunluğunu yüksek tutmak meşgul server'larda bağlantı isteklerinin kaçırılmamasını sağlayabilir. Linux'ta default durumda verilebilecek 
    en yüksek değer 128'dir. Ancak "/proc/sys/net/core/somaxconn" dosyasındaki değer değiştirilerek bu default uzunluk artırılabilir. Fonksiyon 
    başarı durumunda 0 değerine, başarısızlık durumunda Windows sistelerinde SOCKET_ERROR değerine, UNIX/Linux sistemlerinde ise -1 değerine 
    geri dönmektedir. Örneğin Windows sistemlerinde fonksiyon şöyle çağrılabilir:

    if (listen(serverSock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    UNIX/Linux sistemlerinde de çağrı şöyle yapılabilir:

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    Bu fonksiyon işletim sistemlerinin "firewall mekanizması" tarafından denetlenebilmektedir. Eğer çalıştığınız sistemde söz konusu port 
    firewall tarafından kapatılmışsa bunu açmanız gerekir. (Windows sistemlerinde listen fonksiyonu bir pop pencere çıkartarak uyarı mesajı 
    görüntülemektedir.)

    Yukarıda da belirttiğimiz gibi listen fonksiyonu herhangi bir blokeye yol açmaz. Bu fonksiyon çağrıldıktan sonra işletim sistemi ilgili 
    porta gelecek bağlantı isteklerini prosese özgü bir bağlantı kuyruğuna yerleştirmektedir. Bu bağlantı kuyruğundan bağlantı isteklerini 
    alarak bağlantısıyı sağlayan asıl fonksiyon accept fonksiyonudur.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
                                                97. Ders 22/06/2024 - Cumartesi
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    accept fonksiyonu bağlantı kuyruğuna bakar. Eğer kuyrukta bir bağlantı isteği varsa onu alır ve hemen geri döner. Eğer orada bir bağlantı 
    isteği yoksa default durumda blokede bekler. Ancak accept fonksiyonu blokesiz modda da kullanılabilmektedir. Fonksiyonun Windows 
    sistemlerindeki prototipi şöyledir:

    #include <winsock2.h>

    SOCKET accept(
        SOCKET   s,
        struct sockaddr *addr,
        int *addrlen
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    int accept(int socket, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonların birinci parametreleri dinleme soketinin dosya betimleyicisini almaktadır. İkinci parametre bağlanılan client'a ilişkin bilgilerin 
    yerleştirileceği sockaddr_in yapısının adresini almaktadır. Bu parametre yine genel bir sockaddr yapısı türünden gösterici ile temsil edilmiştir. 
    Bizim bu parametre için IPv4'te sockaddr_in türünden, IPv6'da sockaddr_in6 türünden bir yapı nesnesinin adresini argüman olarak vermemiz gerekir. 
    sockaddr_in yapısının üç elemanı olduğunu anımsayınız. Biz bu parametre sayesinde bağlanan client programın IP adresini ve client makinedeki 
    port numarasını elde edebilmekteyiz. Client program server programa bağlanırken bir IP adresi ve port numarası belirtir. Ancak kendisinin de bir 
    IP adresi ve port numarası vardır. Client'ın port numarası kendi makinesindeki (host'undaki) port numarasıdır. Client'ın IP adresine ve oradaki 
    port numarasına "remote end point" de denilmektedir. Örneğin 178.231.152.127 IP adresinden bir client programın 52310 port'u ile server'ın bulunduğu 
    176.234.135.196 adresi ve 55555 numaralı portuna bağlandığını varsayalım. Burada remote endpoint "178.231.152.127:52310" biçiminde ifade edilmektedir. 
    İşte biz accept fonksiyonunun ikinci parametresinden client hakkında bu bilgileri almaktayız.

    Client (178.231.152.127:52310) ---> Server (176.234.135.196:55555)

    accept fonksiyonunun üçüncü parametresi yine ikinci parametredeki yapının (yani sockaddr_in yapısının) byte uzunluğunu belirtmektedir. Ancak bu 
    parametre bir adres olarak alınmaktadır. Yani programcı Windows'ta int türünden UNIX(Linux sistemlerinde socklen_t türünden bir nesne tanımlamalı, 
    bu nesneye bu sizeof değerini yerleştirmeli ve nesnenin adresini de fonksiyonun üçüncü parametresine geçirmelidir. Fonksiyon bağlanılan client'a 
    ilişkin soket bilgilerinin byte uzunluğunu yine bu adrese yerleştirmektedir. Tabii IP protokol ailesinde her iki taraf da aynı yapıyı kullanıyorsa 
    fonksiyon çıkışında bu sizeof değerinde bir değişiklik olmayacaktır. Ancak tasarım genel yapıldığı için böyle bir yola gidilmiştir.

    accept fonksiyonu başarı durumunda bağlanılan client'a ilişkin yeni bir soket betimleyicisine geri dönmektedir. Artık bağlanılan client ile bu 
    soket yoluyla konuşulacaktır. accept fonksiyonu başarısızlık durumunda Windows sistemlerinde SOCKET_ERROR değerine UNIC/Linux sistemlerinde ise -1 
    değeri ile geri dönmektedir. Örneğin Windows sistemlerine accpet fonksiyonu şöyle kullanılabilir:

    struct sockaddr_in sin_client;
    int sin_len;
    SOCKET serverSock;
    ...

    sin_len = sizeof(sin_client);
    if ((clientSock = accept(serverSock, (struct sockaddr *)&sin_client, &sin_len)) == SOCKET_ERROR) 
        ExitSys("accept", WSAGetLastError());

    UNIX/Linux sistemlerinde de fonksiyon şöyle kullanılabilir:

    struct sockaddr_in sin_client;
    socklen_t sin_len;
    int client_sock;
    ...

    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    Server tarafta temelde iki soket bulunmaktadır. Birincisi bind, listen, accept işlemini yapmakta kullanılan sokettir. Bu sokete TCP/IP 
    terminolojisinde ""pasif soket (passive socket)" ya da "dinleme soketi (listening socket)" denilmektedir. İkinci soket ise client ile 
    konuşmakta kullanılan accept fonksiyonunun geri döndürdüğü sokettir. Buna da "aktif soket (active socket)" denilmektedir. Tabii server 
    program birden fazla client ile konuşacaksa accept fonksiyonunu bir kez değil, çok kez uygulamalıdır. Her accept o anda bağlanılan client 
    ile konuşmakta kullanılabilecek yeni bir soket vermektedir. bind, listen işlemleri bir kez yapılmaktadır. Halbuki accept işlemi her client 
    bağlantısı için ayrıca uygulanmalıdır.

    accept fonksiyonu default durumda blokeli modda çalışmaktadır. Eğer accept çağrıldığında o anda bağlantı kuyruğunda hiç bir client isteği 
    yoksa accept fonksiyonu blokeye yol açmaktadır. Eğer accept çağrıldığında zaten bağlantı kuyruğunda bağlantı için bekleyen client varsa 
    accept bloke olmadan bağlantıyı gerçekleştirir ve geri döner.

    accept fonksiyonu ile elde edilen client bilgilerindeki IP adresini ve port numaraları "big endian" formatında yani "network byte ordering" 
    formatındadır. Bunları sayısal olarak görüntülemek için ntohl ve ntohs fonksiyonlarının kullanılması gerekir. Tabii izleyen paragrafta ele 
    alacağımız gibi aslında IP adresleri genellikle "noktalı desimal format (dotted decimal format)" denilen bir format ile yazı biçiminde 
    görüntülenmektedir.
    
    IPV4 adresini alarak noktalı desimal formata dönüştüren inet_ntoa isimli bir fonksiyon vardır. Fonksiyonun prototipi her iki sistemde de 
    şöyledir:

    #include <winsock2.h>
    #include <arpa/inet.h>

    char *inet_ntoa(struct in_addr in);

    Fonksiyon parametre olarak sockaddr_in yapısının içerisindeki IP adresinin bulunduğu in_addr yapısını (adresini değil) parametre olarak 
    alır ve noktalı desimal format yazısının adresiyle geri döner. Bu durumda accept işlemindne elde edilen client bilgileri aşağıdaki gibi 
    ekrana yazdırabilir:

    printf("waiting for client...\n");
    sin_len = sizeof(sin_client);
    if ((clientSock = accept(serverSock, (struct sockaddr *)&sin_client, &sin_len)) == SOCKET_ERROR) 
        ExitSys("accept", WSAGetLastError());

    printf("Connected %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    inet_nto fonksiyonunun tersini yapan inet_aton isimli bir fonksiyon da bulunmaktadır. Bu fonksiyon noktalı desimal formattaki ip adresini
    in_addr yapısınn içerisine yerleştirmektedir. Bu fonksiyon Windows sistemlerinde yoktur. Yalonızca UNIX/Linux sistemlerinde bulunmaktadır:

    #include <arpa/inet.h>

    int inet_aton(const char *cp, struct in_addr *inp);

    Fonksiyonun birinci parametresi noktalı desimal formattaki ip adresini almaktadır. İkinci paranetresi ise ip adresinin yerleştirileceği 
    in_addr yapısının adresini almaktadır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda ise -1 değerine geri dönmektedir. 
    
    inet_ntoa ve inet_aton fonksiyonlarının inet_ntop ve inet_pton isimli versiyonları da vardır. Aslında artık inet_ntoa ve inet_aton fonksiyonları
    "deprecated" yapılmıştır. Ancak inet_ntop ve inet_pton fonksiyonlarının kullanımı biraz zordur. Biz kursumuzda "deprecated" olmasına karşın 
    kolaylığı nedeniyle inet_ntoa ve inet_aton fonksiyonlarını kullanacağız. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda Windows ve UNIX/Linux sistemlerinde geldiğimiz noktaya kadar server programların kodları bir bütün olarak verilmiştir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* Windows ""server.c" */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <windows.h>

#define PORT_NO            55555

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    int result; 
    SOCKET serverSock, clientSock;
    struct sockaddr_in sinServer, sinClient;
    int sin_len;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", result);

    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
        ExitSys("socket", WSAGetLastError());

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(PORT_NO);
    sinServer.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(serverSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(serverSock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("waiting for client...\n");
    sin_len = sizeof(sinClient);
    if ((clientSock = accept(serverSock, (struct sockaddr *)&sinClient, &sin_len)) == SOCKET_ERROR) 
        ExitSys("accept", WSAGetLastError());

    printf("Connected %s:%d\n", inet_ntoa(sinClient.sin_addr), ntohs(sinClient.sin_port));
    
    WSACleanup();

    printf("Ok\n");

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* UNIX/Linux "server.c" */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT_NO     55555

void exit_sys(const char* msg);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)    
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(PORT_NO);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
         exit_sys("listen");

    printf("waiting for client..\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");
    printf("Client connected %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
    TCP client program, server programa bağlanabilmek için tipik bazı adımları uygulamak zorundadır. Bu adımlar sırasında çağrılacak fonksiyonlar 
    şunlardır:

    (Windows'ta WSAStartup) ---> socket ---> bind (isteğe bağlı) ---> gethostbyname (isteğe bağlı) ---> connect ---> send/recv (ya da read/write)
    ---> shutdown ---> close (Windows'ta closesocket) (---> Windows'ta WSACleanup)

    Client taraf önce yine socket fonksiyonuyla bir soket yaratır. Soketin bind edilmesi gerekmez. Zaten genellikle client taraf soketi bind etmez. 
    Eğer client taraf belli bir port'tan bağlanmak istiyorsa bu durumda bind işlemini uygulayabilir. Eğer client bind işlemi yapmazsa zaten işletim 
    sistemi connect işlemi sırasında sokete boş bir port numarasını atamaktadır. İşletim sisteminin bind edilmemiş client programa connect işlemi 
    sırasında atadığı bu port numarasına İngilizce "ephemeral port (ömrü kısa olan port)"" denilmektedir. Seyrek olarak bazı server programlar 
    client için belli bir remote port numarası talep edebilmektedir. Bu durumda client'ın bu remote port'a sahip olabilmesi için bind işlemini 
    uygulaması gerekir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------
    Client bağlantı için server'ın IP adresini ve port numarasını bilmek zorundadır. IP adreslerinin akılda tutulması zordur. Bu nedenle IP 
    adresleri ile eşleşen "host isimleri" oluşturulmuştur. Ancak IP protokol ailesi host isimleriyle değil, IP numaralarıyla çalışmaktadır. 
    İşte host isimleriyle IP numaralarını eşleştiren ismine DNS (Domain Name Server) denilen özel server'lar bulunmaktadır. Bu server'lar 
    IP protokol ailesindeki DNS isimli bir protokol ile çalışmaktadır. Dolayısıyla client programın elinde IP adresi yerine host ismi varsa 
    DNS işlemi yaparak o host ismine karşı gelen IP numarasını elde etmesi gerekir. DNS server'lar dağıtık biçimde bulunmaktadır. Bir kayıt
    bir DNS server'da yoksa başka bir DNS server'a referans edilmektedir.

    DNS server'larda host isimleriyle IP numaraları bire bir karşılık gelmemektedir. Belli bir host ismine birden fazla IP numarası eşleştirilmiş 
    olabileceği gibi belli bir IP numarasına da birden fazla host ismi eşleştirilmiş olabilmektedir.

    DNS işlemleri yapan iki geleneksel fonksiyon vardır: gethostbyname ve gethostbyaddr. Bu fonksiyonların kullanımları kolaydır. Ancak bu 
    fonksiyonlar artık "deprecated" yapılmış ve POSIX standartlarından da silinmiştir. Bunların yerine getnameinfo ve getaddrinfo fonksiyonları 
    oluşturulmuştur. Bu fonksiyonlar POSIX standartlarında bulunmaktadır. Biz kursumuzda artık "deprecated" hale getirilmiş "gethostbyname"
    ve "gethostbyaddress" kullanmayacağız. Bunun yerine "getaddrinfo" fonksiyonunu açıklayıp onu kullanacağız. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------
    getaddrinfo isimli fonksiyon inet_addr ve gethosybyname fonksiyonlarının IPv6'yı da içerecek biçimde genişletilmiş bir biçimidir. Yani 
    getaddrinfo hem noktalı desimal formatı nümerik adrese dönüştürür hem de eğer geçersiz bir noktalı desimal format söz konusuysa (bu durumda 
    server isimsel olarak girilmiş olabilir) DNS işlemi yaparak ilgili host'un IP adresini elde eder. Maalesef fonksiyon biraz karışık tasarlanmıştır. 
    Fonksiyonun Windows sistemlerindeki prototipi şöyledir:

    #include <ws2tcpip.h>

    INT getaddrinfo(
        PCSTR                pNodeName,
        PCSTR                pServiceName,
        const ADDRINFOA        *pHints,
        PADDRINFOA            *ppResult
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <netdb.h>

    int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);

    Aslında her iki sistemde de typedef isimleri farklı olmasına karşın fonksiyon aynı biçimde kullanılmaktadır. Fonksiyonun birinci parametresi 
    "noktalı desimal formatlı IP adresi" ya da "host ismini" belirtmektedir. İkinci parametre NULL geçilebilir ya da buraya port numarası girilebilir. 
    Ancak bu parametreye port numarası girilecekse yazısal biçimde girilmelidir. Fonksiyon bu port numarasını htons yaparak "big endian" formata 
    dönüştürüp bize verecektir. Bu parametreye aynı zamanda IP ailesinin uygulama katmanına ilişkin spesifik bir protokolün ismi de girilebilmektedir 
    (Örneğin "http" gibi, "ftp" gibi). Bu durumda bu protokollerin port numaraları bilindiği için sanki o port numaraları girilmiş gibi işlem 
    yapılır. Eğer bu parametreye NULL girilirse bize port olarak 0 verilecektir. Port numarasını biz yerleştiriyorsak bu parametreye NULL girebiliriz. 
    Fonksiyonun üçüncü parametresi nasıl bir adres istediğimizi anlatan filtreleme seçeneklerini belirtir. Bu parametre addrinfo isimli bir yapı 
    türündendir. Bu yapının yalnızca ilk dört elemanı programcı tarafından girilebilmektedir. Ancak POSIX standartları bu yapının elemanlarının 
    sıfırlanmasını öngörmektedir (buradaki sıfırlanmak terimi normal türdeki elemanlar için 0 değerini, göstericiler için NULL adres değerini 
    belirtmektedir). addrinfo yapısı şöyledir:

    struct addrinfo {
        int              ai_flags;
        int              ai_family;
        int              ai_socktype;
        int              ai_protocol;
        socklen_t        ai_addrlen;
        struct sockaddr *ai_addr;
        char            *ai_canonname;
        struct addrinfo *ai_next;
    };

    Yapının ai_flags elemanı pek çok bayrak değeri alabilmektedir. Bu değer 0 olarak da geçilebilir. Yapının ai_family elemanı AF_INET girilirse 
    host'a ilişkin IPv4 adresleri, AF_INET6 girilirse host'a ilişkin IPv6 adresleri, AF_UNSPEC girilirse hem IPv4 hem de IPv6 adresleri elde edilir. 
    Yapının ai_socktype elemanı 0 girilebilir ya da SOCK_STREAM veya SOCK_DGRAM girilebilir. Fonksiyonun ayrıntılı açıklaması için dokümanlara başvurunuz. 
    Bu parametre NULL adres de girilebilir. Bu durumda ilgili host'a ilişkin tüm adresler elde edilir. 

    getaddrinfo fonksiyonunun son parametresine bir bağlı listenin ilk elemanını gösteren adres yerleştirilmektedir. Buradaki bağlı listenin bağ 
    elemanı addrinfo yapısının ai_next elemanıdır. Bu bağlı listenin boşaltımı freeaddrinfo fonksiyonu tarafından yapılmaktadır. 

    getaddrinfo fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda doğrudan hata koduna geri döner. Bu hata kodları Windows şistemlerinde
    WSAGetLastError fonksiyonuyla elde ettiğimiz hata kodlarıdır. Ancak UNIX/Linux sistemlerinde bu hata kodları errno kodları değildir. Bu hata kodlarının
    UNIX/Linux sistemlerinde gai_strerror fonksiyonuyla yazıya dönüştürülmesi gerekir. 

    Bağlı listenin düğümlerini free hale getirmek için freeaddrinfo fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <netdb.h>

    void freeaddrinfo(struct addrinfo *ai);

    Fonksiyon getaddrinfo fonksiyonunun verdiği bağlı listenin ilk düğümünün (head pointer) adresini parametre olarak alır ve tüm bağlı listeyi boşaltır. 
    gai_strerror fonksiyonunun prototipi de şöyledir:

    #include <netdb.h>

    const char *gai_strerror(int ecode);

    getaddrinfo fonksiyonunun client programda tipik kullanımı aşağıda verilmiştir.

    Bu fonksiyon bize connect için gereken sockaddr_in ya da sockadd_in6 yapı nesnelerini kendisi oluşturup sockaddr türünden bir adres gibi vermektedir. 
    Örneğin biz "microsoft.com" host isminin bütün IPV4 AIP adreslerini aşağıdaki gibi elde edebiliriz:

    struct addrinfo *ainfoHead, *ainfo;
    struct sockaddr_in *sinHost;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    ...

    if ((result = getaddrinfo(HOST_NAME, "55555", &hints, &ainfoHead)) != 0)
        ExitSys("bind", result);

    for (ainfo = ainfoHead; ainfo != NULL; ainfo = ainfo->ai_next) {
        sinHost = (struct sockaddr_in *)ainfo->ai_addr;
        printf("%s\n", inet_ntoa(sinHost->sin_addr));
    }

    freeaddrinfo(ainfoHead);

    Programcı host isminden elde ettiği tüm IP numaralarını bağlantı için deneyebilir. 
  
    getaddrinfo fonksiyonunun tersini yapan getnameinfo isminde bir fonksiyon da sonraları soket kütüphanesine eklenmiştir. Fonksiyon temel 
    olarak ilgili host'un IP adresini alıp bize aynı biçimde host isimlerini vermektedir. Biz burada bu fonksiyonu açıklamayacağız.

    Eğer elimizde zaten server'ın IP adresi noktalı desimal formatta varsa biz getaddrinfo fonksiyonunu kullanmak yerine inet_addr ile de bu 
    noktalı desimal formatı IP adresine dönüştürebiliriz. Ancak genel olarak getaadrinfo fonksiyonu daha genel ve daha yeteneklidir. Bu 
    fonksiyonun kullanılması tavsiye edilebilir. inet_addr fonksiyonunun Windows sistemlerindeki prototipi şöyledir:

    #include <winsock2.h>

    unsigned long inet_addr(const char *cp);

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <arpa/inet.h>

    in_addr_t inet_addr(const char *cp);

    Fonksiyonlar noktasıl desimal formattaki IP adresini 4 byte'lık IPV4 adresine dönüştürmektedir. Fonksiyon başarısızlık durumunda Windows
    sistemlerinde INADDR_NONE değerine, UNIX/Linux sistemlrinde ise -1 değerine geri dönmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------
    Artık client program connect fonksiyonuyla TCP bağlantısını sağlayabilir. connect fonksiyonunun Windows sistemlerindeki prototipi şöyledir:

    #include <winsock2.h>

    int WSAAPI connect(
        SOCKET         s,
        const sockaddr *name,    
        int            namelen
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    int connect(int socket, const struct sockaddr *address, socklen_t address_len);

    Fonksiyonun birinci parametresi soket betimleyicisini belirtir. İkinci parametre bağlanılacak server'a ilişkin sockaddr_in
    yapı nesnesinin adresini belirtmektedir. Fonksiyonun üçüncü parametresi, ikinci parametredeki yapının uzunluğunu almaktadır. 
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri dönmektedir. 

    Eğer connect fonksiyonu çağrıldığında server program çalışmıyorsa ya da server programın bağlantı kuyruğu doluysa connect
    belli bir zaman aşımı süresi kadar bekler ve sonra başarısız olur ve errno değeri ECONNREFUSED ("Connection refused") ile
    set edilir. Örneğin:

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    Aşağıda örnektlerde bağlantı için gereken minimum client program verilmiştir. Burada henüz görmediğimiz işlemleri hiç uygulamadık.
    Client programda bind işlemini yorum satırı içerisine aldık. Yukarıda da belirttiğimiz gibi eğer client program bind işlemi yapmazsa 
    (ki genellikle yapmaz) bu durumda işletim sistemi client program için o programın çalıştığı makinede boş bir port numarası atamaktadır.
    Ayrıca biz bu örneklerde inet_addr fonksiyonunun nasıl kullanılacağını da yorum satırları içerisinde gösterdik.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* Windows "client.c" */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

#define PORT_NO                "55555"
#define HOST_NAME            "127.0.0.1"

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    int result;
    SOCKET clientSock;
    struct addrinfo *ainfoHead, *ainfo;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    
    if ((result = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", result);

    if ((clientSock = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
        ExitSys("socket", WSAGetLastError());
    
    /*
    {
        #define CLIENT_PORT_NO        50000

        struct sockaddr_in sinClient;

        sinClient.sin_family = AF_INET;
        sinClient.sin_port = htons(CLIENT_PORT_NO);
        sinClient.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(clientSock, (struct sockaddr *)&sinClient, sizeof(sinClient)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */
    
        
    if ((result = getaddrinfo(HOST_NAME, PORT_NO, &hints, &ainfoHead)) != 0)
        ExitSys("getaddrinfo", result);

    for (ainfo = ainfoHead; ainfo != NULL; ainfo = ainfo->ai_next) 
        if (connect(clientSock, ainfo->ai_addr, sizeof(struct sockaddr_in)) == 0)
            break;

    if (ainfo == NULL)
        ExitSys("connect", WSAGetLastError());

    freeaddrinfo(ainfoHead);
    
    /*
    {
        struct sockaddr_in sinServer;

        sinServer.sin_family = AF_INET;
        sinServer.sin_port = htons(55555);
        if ((sinServer.sin_addr.s_addr = inet_addr(HOST_NAME)) == INADDR_NONE)
            ExitSys("inet_addr", WSAGetLastError());
        if (connect(clientSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
            ExitSys("connect", WSAGetLastError());
    }
    */
    
    printf("connected...\n");

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Unix/Linux "client.c" */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>

#define PORT_NO         "55555"
#define HOST_NAME        "127.0.0.1"

void exit_sys(const char* msg);

int main(void)
{
    int client_sock;
    struct addrinfo *ainfo_head, *ainfo;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    int result;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)    
        exit_sys("socket");

    /*
    {
        #define CLIENT_PORT_NO        50000

        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(CLIENT_PORT_NO);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }
    */

    if ((result = getaddrinfo(HOST_NAME, PORT_NO, &hints, &ainfo_head)) != 0)
        exit_sys("getaddrinfo");

    for (ainfo = ainfo_head; ainfo != NULL; ainfo = ainfo->ai_next) 
        if (connect(client_sock, ainfo->ai_addr, sizeof(struct sockaddr_in)) == 0)
            break;

    if (ainfo == NULL)
        exit_sys("connect");

    freeaddrinfo(ainfo_head);
    /*
    {
        struct sockaddr_in sin_server;

        sin_server.sin_family = AF_INET;
        sin_server.sin_port = htons(55555);
        if ((sin_server.sin_addr.s_addr = inet_addr(HOST_NAME)) == -1)
            exit_sys("inet_addr");
        if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
            exit_sys("connect");
    }
    */

    printf("connected...\n");

    return 0;
}

void exit_sys(const char* msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-------------------------------------------------------------------------------------------------------------------------------------------
    Bağlantı sağlandıktan sonra artık gönderme ve alma işlemleri yapılabilir. Soketten karşı tarafa byte göndermek için send karşı taraftan 
    byte okumak için recv fonksiyonları kullanılmaktadır. UNIX/Linux sistemlerinde soketler de dosya gibi betimleyici oldukları için bu 
    sistemlerde send yerine write, recv yerine read POSIX fonksiyonları da kullanılabilir. TCP full duplex bir haberleşme sunmaktadır. Yani 
    client ve server programlar aynı soket ile hem bilgi gönderip hem de bilgi alabilmektedir.

    recv fonksiyonunun Windows sistemlerindeki prototipi şöyledir:

    #include <winsock2.h>

    int recv(
        SOCKET s,
        char   *buf,
        int    len,
        int    flags
    );

    UNIX/linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    ssize_t recv(int socket, void *buffer, size_t length, int flags);

    Fonksiyonların birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre alınacak bilginin yerleştirileceği dizinin 
    adresini almaktadır. Üçüncü parametre ise okunmak istenen byte sayısını belirtmektedir.  Fonksiyonun son parametresi aşağıdaki üç sembolik 
    sabitin bit OR işlemine sokulmasıyla oluşturulabilir:

    MSG_PEEK
    MSG_OOB
    MSG_WAITALL

    Biz şimdilik bu değerlerin anlamlarını açıklamayacağız. Ancak MSG_PEEK değeri bilginin network tamponundan alındıktan sonra oradan atılmayacağını 
    belirtmektedir. Bu parametre 0 da geçilebilir. Zaten recv fonksiyonunun read fonksiyonundan tek farkı bu son parametredir. Bu son parametrenin 
    0 geçilmesiyle read kullanılması arasında hiçbir farklılık yoktur.

    recv fonksiyonu blokeli modda (default durum blokeli moddur) tıpkı borularda olduğu gibi eğer hazırda en az 1 byte varsa okuyabildiği kadar 
    bilgiyi okur ve okuyabildiği byte sayısına geri döner. Eğer o anda network tamponunda hiç byte yoksa recv fonksiyonu en az 1 byte okuyana 
    kadar blokede bekler. (Yani başka bir deyişle recv tıpkı borularda olduğu gibi eğer okunacak bir şey yoksa blokede bekler, ancak okunacak 
    en az 1 byte varsa okuyabildiğini okur ve beklemeden geri döner.)

    recv fonksiyonu başarı durumunda okunabilen byte sayısına, başarısızlık durumunda Windows sistemlerinde SOCKET_ERROR, UNIX/Linux sistemlerinde
    -1 değerine geri dönmektedir. Eğer karşı taraf soketi (peer socket) kapatmışsa bu durumda tıpkı borularda olduğu gibi recv fonksiyonu 0 
    ile geri dönmektedir. Soketlerle boruların kullanımlarının birbirlerine çok benzediğine dikkat ediniz.

    Soketten bilgi göndermek için send ya da UNIX/Linux sistemleribde write fonksiyonu kullanılmaktadır. send fonksiyonunun Windows sistemlerindeki
    prototipi şöyledir:
    
    #include <winsock2.h>

    int send(
        SOCKET     s,
        const char *buf,
        int        len,
        int        flags
    );

    UNIX/Linux sistemlerindeki prototipi ise şöyledir:

    #include <sys/socket.h>

    ssize_t send(int socket, const void *buffer, size_t length, int flags);

    Fonksiyoların birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre gönderilecek bilgilerin bulunduğu dizinin adresini 
    belirtir. Üçüncü parametre ise gönderilecek byte miktarını belirtmektedir. Son parametre aşağıdaki sembolik sabitlerin bit düzeyinde OR işlemine 
    sokulmasıyla oluşturulabilir:

    MSG_EOR
    MSG_OOB
    MSG_NOSIGNAL

    Bu parametre 0 da geçilebilir. Biz şimdilik bu bayraklar üzerinde durmayacağız.

    send fonksiyonu bilgileri karşı tarafa o anda göndermez. Onu önce network tamponuna yerleştirir. İşletim sistemi o tampondan TCP (dolayısıyla 
    IP) paketleri oluşturarak mesajı göndermektedir. Yani send fonksiyonu geri döndüğünde bilgiler network tamponuna yazılmıştır, ancak henüz 
    karşı tarafa gönderilmemiş olabilir. Pekiyi o anda network tamponu doluysa ne olacaktır? İşte UNIX/Linux sistemlerinde send fonksiyonu, 
    gönderilecek bilginin tamamı network tamponuna aktarılana kadar blokede beklemektedir. Ancak bu konuda işletim sistemleri arasında farklılıklar 
    olabilmektedir. Örneğin Windows sistemlerinde send fonksiyonu eğer network tamponununda gönderilmek istenen kadar yer yoksa ancak en az 
    bir byte'lık boş bir yer varsa tampona yazabildiği kadar byte'ı yazıp hemen geri dönmektedir. Diğer UNIX/Linux sistemleri arasında da 
    send fonksiyonunun davranışı bakımından bu yönde farklılıklar olabilmektedir. Ancak POSIX standartları blokeli modda tüm bilginin network 
    tamponuna yazılana kadar send fonksiyonunun bloke olacağını belirtmektedir. Linux çekirdeği de buna uygun biçimde çalışmaktadır. 

    send fonksiyonu network tamponuna yazılan byte sayısı ile geri dönmektedir. Blokeli modda bu değer UNIX/Linux sistemlerinde yazılmak istenen 
    değerle aynı olur. Ancak Windows sistemlerinde daha az olabilmektedir. send fonksiyonu Windows'ta başarısızlık durumunda SOCKET_ERROR değeri 
    ile UNIX/Linux sistemlerinde ise -1 değeri ile geri döner.Tıpkı borularda olduğu gibi UNIX/Linux sistemlerinde send fonksiyonunda da eğer 
    karşı taraf soketi kapatmışsa send fonksiyonu default durumda SIGPIPE sinyalinin oluşmasına yol açmaktadır. Eğer bu sinyalin oluşturulması 
    istenmiyorsa bu durumda send fonksiyonunun son parametresi (flags) MSG_NOSIGNAL olarak geçilmelidir. Bu durumda karşı taraf soketi kapatmışsa 
    send fonksiyonu başarısız olur ve errno değeri EPIPE olarak set edilir. send fonksiyonunun soketlerdeki davranışının borulardaki davranışa 
    çok benzediğine dikkat ediniz. 

    send fonksiyonunun son parametresi 0 geçildiğinde bu fonksiyonun davranışı tamamen write fonksiyonunda olduğu gibidir. 
------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki iskelet bir TCP/IP client-server uygulama verilmiştir. Burada client klavyeden birtakım yazılar girer. Bunu server'a gönderir. 
    Server da bu yazının tersini client'a geri yollamaktadır. Client "exit" yazdığında her iki taraf da işlemini sonlandırmaktadır.
------------------------------------------------------------------------------------------------------------------------------------------*/

/* Server.c */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET serverSock, clientSock;
    struct sockaddr_in sinServer, sinClient;
    int addrLen;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)     /* third parameter IPPROTO_TCP */
        ExitSys("socket", WSAGetLastError());

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);
    sinServer.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(serverSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(serverSock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("Waiting for client connection....\n");

    addrLen = sizeof(sinClient);
    
    if ((clientSock = accept(serverSock, (struct sockaddr *)&sinClient, &addrLen)) == INVALID_SOCKET)
        ExitSys("accept", WSAGetLastError());

    printf("Connected: %s:%d\n", inet_ntoa(sinClient.sin_addr), ntohs(sinClient.sin_port));

    for (;;) {
        if ((result = recv(clientSock, buf, BUFFER_SIZE - 1, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());
        if (result == 0)
            break;

        buf[result] = '\0';
        if (!strcmp(buf, "exit"))
            break;
        printf("%d bytes received: %s\n", result, buf);
        _strrev(buf);
        if (send(clientSock, buf, strlen(buf), 0) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());
    }
    
    shutdown(clientSock, SD_BOTH);
    closesocket(clientSock);
    closesocket(serverSock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1" 

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET clientSock;
    struct sockaddr_in sinServer;
    struct hostent *hostEnt;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((clientSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());
    /*
    {
        struct sockaddr_in sinClient;

        sinClient.sin_family = AF_INET;
        sinClient.sin_port = htons(CLIENT_PORTNO);
        sinClient.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(clientSock, (struct sockaddr *)&sinClient, sizeof(sinClient)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);

    sinServer.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sinServer.sin_addr.s_addr == INADDR_NONE) {
        if ((hostEnt = gethostbyname(SERVER_NAME)) == NULL) 
            ExitSys("gethostbyname", WSAGetLastError());

        memcpy(&sinServer.sin_addr.s_addr, hostEnt->h_addr_list[0], hostEnt->h_length);
    }
    if (connect(clientSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    printf("Connected...\n");
    for (;;) {
        printf("Text:");
    
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
    
        if (send(clientSock, buf, strlen(buf), 0) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());

        if (!strcmp(buf, "exit"))
            break;

        if ((result = recv(clientSock, buf, BUFFER_SIZE - 1, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());
        if (result == 0)
            break;

        buf[result] = '\0';

        printf("%d bytes received: %s\n", result, buf);
    }

    shutdown(clientSock, SD_BOTH);
    closesocket(clientSock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iskelet client/server programın UNIX/Linux sistemlerindeki eşdeğeri aşağıdaki verilmiştir.
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void exit_sys(const char *msg);
void reverse_str(char *str);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t addrlen;
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);
    
    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for client connection....\n");

    addrlen = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &addrlen)) == -1)
        exit_sys("accept");
        
    printf("Connected: %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "exit"))
            break;
        printf("%d bytes received: %s\n", result, buf);
        reverse_str(buf);
        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("recv");
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);
    close(server_sock);

    return 0;
}

void reverse_str(char *str)
{
    size_t len, i;
    char temp;

    for (len = 0; str[len] != '\0'; ++len)
        ;

    for (i = 0; i < len / 2; ++i) {
        temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1" 

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hostent;
    char *str;
    char buf[BUFFER_SIZE];
    int result;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    struct sockaddr_in sin_client;

    sin_client.sin_family = AF_INET;
    sin_client.sin_port = htons(CLIENT_PORTNO);
    sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
        exit_sys("socket");
    */

       sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    
    sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sin_server.sin_addr.s_addr == INADDR_NONE) {
        if ((hostent = gethostbyname(SERVER_NAME)) == NULL) 
            exit_sys("gethostbyname");  

        memcpy(&sin_server.sin_addr.s_addr, hostent->h_addr_list[0], hostent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("gethostbyname");

    printf("Connected...\n");

    for (;;) {
        printf("Text:");
    
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
    
        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");

        if (!strcmp(buf, "exit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';

        printf("%d bytes received: %s\n", result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Windows'ta çok client'lı server uygulaması. Bu örnekte thread modeli kullanılmıştır. Server her client bağlantısında bir thread yaratmış ve 
    o thread'in bağlanılan client konuşmasını sağlamıştır. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* Server.c */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);
DWORD __stdcall ClientThreadProc(LPVOID lpParam);

struct CLIENT_INFO {
    SOCKET sock;
    char addr[16];
    int port;
};

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET serverSock, clientSock;
    struct sockaddr_in sinServer, sinClient;
    int addrLen;
    HANDLE hThread;
    DWORD dwThreadId;
    struct CLIENT_INFO *ci;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)     /* third parameter IPPROTO_TCP */
        ExitSys("socket", WSAGetLastError());

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);
    sinServer.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(serverSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(serverSock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("Waiting for client connection....\n");
    for (;;) {
        addrLen = sizeof(sinClient);
        if ((clientSock = accept(serverSock, (struct sockaddr *)&sinClient, &addrLen)) == INVALID_SOCKET)
            ExitSys("accept", WSAGetLastError());

        if ((ci = (struct CLIENT_INFO *)malloc(sizeof(struct CLIENT_INFO))) == NULL) {
            fprintf(stderr, "Cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        ci->sock = clientSock;
        strcpy(ci->addr, inet_ntoa(sinClient.sin_addr));
        ci->port = ntohs(sinClient.sin_port);

        printf("Connected: %s:%d\n", ci->addr, ci->port);

        if ((hThread = CreateThread(NULL, 0, ClientThreadProc, ci, 0, &dwThreadId)) == NULL)
            ExitSys("CreateThread", WSAGetLastError());

        CloseHandle(hThread);
    }
    
    closesocket(serverSock);

    WSACleanup();

    return 0;
}

DWORD __stdcall ClientThreadProc(LPVOID lpParam)
{
    struct CLIENT_INFO *ci = (struct CLIENT_INFO *)lpParam;
    int result;
    char buf[BUFFER_SIZE];
    
    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE - 1, 0)) == SOCKET_ERROR)
            goto FAILED;
        if (result == 0)
            break;

        buf[result] = '\0';
        if (!strcmp(buf, "exit"))
            break;
        printf("%d bytes received from %s:%d => \"%s\"\n", result, ci->addr, ci->port, buf);
        _strrev(buf);
        if (send(ci->sock, buf, strlen(buf), 0) == SOCKET_ERROR)
            goto FAILED;
    }
FAILED:
    printf("Client %s:%d exits...\n", ci->addr, ci->port);

    shutdown(ci->sock, SD_BOTH);
    closesocket(ci->sock);
    free(ci);

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1"

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET clientSock;
    struct sockaddr_in sinServer;
    struct hostent *hostEnt;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((clientSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());
    /*
    {
        struct sockaddr_in sinClient;

        sinClient.sin_family = AF_INET;
        sinClient.sin_port = htons(CLIENT_PORTNO);
        sinClient.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(clientSock, (struct sockaddr *)&sinClient, sizeof(sinClient)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);

    sinServer.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sinServer.sin_addr.s_addr == INADDR_NONE) {
        if ((hostEnt = gethostbyname(SERVER_NAME)) == NULL) 
            ExitSys("gethostbyname", WSAGetLastError());

        memcpy(&sinServer.sin_addr.s_addr, hostEnt->h_addr_list[0], hostEnt->h_length);
    }
    if (connect(clientSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    printf("Connected...\n");
    for (;;) {
        printf("Text:");
    
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
    
        if (send(clientSock, buf, strlen(buf), 0) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());

        if (!strcmp(buf, "exit"))
            break;

        if ((result = recv(clientSock, buf, BUFFER_SIZE - 1, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());

        if (result == 0)
            break;

        buf[result] = '\0';

        printf("%d bytes received: %s\n", result, buf);
    }

    shutdown(clientSock, SD_BOTH);
    closesocket(clientSock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programın UNIX/Linux sistemlerindeki karşılığı
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

struct CLIENT_INFO {
    int sock;
    char addr[16];
    int port;
};

void exit_sys(const char *msg);
void *client_thread_proc(void *param);
void reverse_str(char *str);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t addrlen;
    struct CLIENT_INFO *ci;
    pthread_t tid;
    int result;
    
    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);
    
    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for client connection....\n");

    for (;;) {
        addrlen = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &addrlen)) == -1)
            exit_sys("accept");

        if ((ci = (struct CLIENT_INFO *)malloc(sizeof(struct CLIENT_INFO))) == NULL) {
            fprintf(stderr, "Cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        ci->sock = client_sock;
        strcpy(ci->addr, inet_ntoa(sin_client.sin_addr));
        ci->port = ntohs(sin_client.sin_port);

        printf("Connected: %s:%d\n", ci->addr, ci->port);

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }
    
    shutdown(server_sock, SHUT_RDWR);
    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    struct CLIENT_INFO *ci = (struct CLIENT_INFO *)param;
    int result;
    char buf[BUFFER_SIZE];
    
    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            goto FAILED;
        if (result == 0)
            break;

        buf[result] = '\0';
        if (!strcmp(buf, "exit"))
            break;
        printf("%d bytes received from %s:%d => \"%s\"\n", result, ci->addr, ci->port, buf);
        reverse_str(buf);
        if (send(ci->sock, buf, strlen(buf), 0) == -1)
            goto FAILED;
    }
FAILED:
    printf("Client %s:%d exits...\n", ci->addr, ci->port);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);
    free(ci);

    return NULL;
}

void reverse_str(char *str)
{
    size_t len, i;
    char temp;

    for (len = 0; str[len] != '\0'; ++len)
        ;

    for (i = 0; i < len / 2; ++i) {
        temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1"  

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hostent;
    char *str;
    char buf[BUFFER_SIZE];
    int result;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    struct sockaddr_in sin_client;

    sin_client.sin_family = AF_INET;
    sin_client.sin_port = htons(CLIENT_PORTNO);
    sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
        exit_sys("socket");
    */

       sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    
    sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sin_server.sin_addr.s_addr == INADDR_NONE) {
        if ((hostent = gethostbyname(SERVER_NAME)) == NULL) 
            exit_sys("gethostbyname");  

        memcpy(&sin_server.sin_addr.s_addr, hostent->h_addr_list[0], hostent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("gethostbyname");

    printf("Connected...\n");

    for (;;) {
        printf("Text:");
    
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
    
        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");

        if (!strcmp(buf, "exit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';

        printf("%d bytes received: %s\n", result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında UNIX/Linux sistemlerinde her client bağlantısında o client ile yeni bir proses yaratılıp o prosesin konuşması da sağlanabilir. Yani server
    client ile bağlantı yaptığında fork yapar. Sonra alt proseste client ile konuşur. Bu tür uygulamalarda hortlak (zombie) oluşumun engellenmesi gerekir. 
    Aşağıdaki kodda sigaction fonksiyonuyla hortlak proses oluşması engellenmiştir. Tabii fork modeli aslında thread modeline göre daha kötü bir modeldir. 
    Ancak daha pratiktir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* fork-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void exit_sys(const char *msg);
void client_proc(int sock, const char *addr, int port);
void reverse_str(char *str);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t addrlen;
    pid_t pid;
    char *addr;
    int port;
    struct sigaction act;
    
    act.sa_handler = SIG_IGN;
    act.sa_flags = SA_NOCLDWAIT;
    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");
    
    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);
    
    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for client connection....\n");

    for (;;) {
        addrlen = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &addrlen)) == -1)
            exit_sys("accept");

        addr = inet_ntoa(sin_client.sin_addr);
        port = ntohs(sin_client.sin_port);
        printf("Connected: %s:%d\n", addr, port);

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            client_proc(client_sock, addr, port);
            exit(EXIT_SUCCESS);
        }
    }
    
    shutdown(server_sock, SHUT_RDWR);
    close(server_sock);

    return 0;
}

void client_proc(int sock, const char *addr, int port)
{
    int result;
    char buf[BUFFER_SIZE];
    
    for (;;) {
        if ((result = recv(sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            goto FAILED;
        if (result == 0)
            break;

        buf[result] = '\0';
        if (!strcmp(buf, "exit"))
            break;
        printf("%d bytes received from %s:%d => \"%s\"\n", result, addr, port, buf);
        reverse_str(buf);
        if (send(sock, buf, strlen(buf), 0) == -1)
            goto FAILED;
    }
FAILED:
    printf("Client %s:%d exits...\n", addr, port);

    shutdown(sock, SHUT_RDWR);
    close(sock);
}

void reverse_str(char *str)
{
    size_t len, i;
    char temp;

    for (len = 0; str[len] != '\0'; ++len)
        ;

    for (i = 0; i < len / 2; ++i) {
        temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1"  

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hostent;
    char *str;
    char buf[BUFFER_SIZE];
    int result;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    struct sockaddr_in sin_client;

    sin_client.sin_family = AF_INET;
    sin_client.sin_port = htons(CLIENT_PORTNO);
    sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
        exit_sys("socket");
    */

       sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    
    sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sin_server.sin_addr.s_addr == INADDR_NONE) {
        if ((hostent = gethostbyname(SERVER_NAME)) == NULL) 
            exit_sys("gethostbyname");  

        memcpy(&sin_server.sin_addr.s_addr, hostent->h_addr_list[0], hostent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("gethostbyname");

    printf("Connected...\n");

    for (;;) {
        printf("Text:");
    
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
    
        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");

        if (!strcmp(buf, "exit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE - 1, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';

        printf("%d bytes received: %s\n", result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Şüphesiz TCP/IP uygulamalarında client ve server programların hangi dille ve hangi işletim sisteminde yazıldığının bir önemi yoktur. Önemli olan 
    bizim programımızda uyguladığımız "uygulama katmanı protokolüne" uygunluktur. 

    Aşağıdaki örnekte yukarıdaki programın client kısmının C# karşılığı verilmiştir. Bu tür dillerde kendi içerisindkei sınıflar yoluyla pek çok işlem
    arka planda otomatik yapılabilmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

using System;
using System.Net.Sockets;
using System.Text;

namespace CSD
{
    class App
    {
        public const int SERVER_PORTNO = 55000;
        
        public static void Main()
        {
            try
            {
                TcpClient tcpClient = new TcpClient("127.0.0.1", SERVER_PORTNO);
                string text;
                byte[] buf;
                int result;

                for (; ; )
                {
                    Console.Write("Text:");
                    text = Console.ReadLine();
                    if (text == "exit")
                        break;
                    buf = Encoding.UTF8.GetBytes(text);
                    tcpClient.Client.Send(buf);

                    buf = new byte[1024];
                    result = tcpClient.Client.Receive(buf);
                    text = Encoding.UTF8.GetString(buf, 0, result);
                    Console.WriteLine(text);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
    }
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Bir soketten garantili biçimde n byte okumak ve sokete garantili biçimde n byte yamakiçin aşağıdaki gibi iki fonksiyon kullanılabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

int ReadSocket(SOCKET sock, char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = recv(sock, buf + count, left, 0)) == SOCKET_ERROR)
            return SOCKET_ERROR;
        if (result == 0)
            break;
        left -= result;
        count += result;
    }

    return count;
}

int WriteSocket(SOCKET sock, const char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = send(sock, buf + count, left, 0)) == SOCKET_ERROR)
            return SOCKET_ERROR;
        if (result == 0)
            break;
        left -= result;
        count += result;
    }

    return count;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Garantili n byte okumak için UNIX/Linux sistemlerinde aşağdaki gibi bir fonksiyon yazılabilir. Bu sistemlerde blokeli modda zaten send fonksiyonu
    tüm bilgi network tampouna yazılana kadar bloke oluşturmaktadır. Windows sistemleri (Winsock) bunun garantisini vermemektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

int read_socket(int sock, char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = recv(sock, buf + count, left, 0)) == -1)
            return -1;
        if (result == 0)
            break;
        
        left -= result;
        count += result;
    }

    return count;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Text tabanlı mesajlaşmada bir taraf diğerine sonu \n ile biten ya da \r\n ile biten bir satırlık yazı gönderir. Karşı taraf bu yazıyı parse eder
    ve gerekeni yapar. Ancak soketten bir satırlık bilginin okunması o kadar kolay değildir. Soketten karakter karakter okuma yapmak kötü bir tekniktir. 
    Onun yerine bir grup byte bir tampona yerleştirilip o tampondan '\n' ya da '\r\n' görünene kadar ilerlenir. Aşağıda Effective TCP/IP kitabında da
    benzeri bulunan soketten bir satır okuyan bir fonksiyon örneği verilmiştir. Bu fonksiyon karşı taraf bir satır okunmadan soketi kapatmışsa 0 değerine geri döner. 
    Normal durumda satırdaki byte sayısına geri dönmektedir. Soket hatasında ise fonksiyon -1 değerine geri dönmektedir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

int ReadLineSocket(SOCKET sock, char *buf, int size)
{
    char *bufx = buf;
    static char *bp;
    static int count = 0;
    static char b[2048];
    char ch;

    while (--size > 0) {
        if (--count <= 0) {
            count = recv(sock, b, sizeof(b), 0);
            if (count == SOCKET_ERROR)
                return SOCKET_ERROR;
            if (count == 0)
                return 0;
            bp = b;
        }
        ch = *bp++;
        *buf++ = ch;
        if (ch == '\n') {
            *buf = '\0';
            return buf - bufx;
        }
    }

    return SOCKET_ERROR;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukardaki fonksiyonun UNIX/Linux sistemlerindeki karşılığı olan fonksiyon şöyle yazılabilir:
-------------------------------------------------------------------------------------------------------------------------------------------*/

int readline_socket(int sock, char *buf, int size)
{
    char *bufx = buf;
    static char *bp;
    static int count = 0;
    static char b[2048];
    char ch;

    while (--size > 0) {
        if (--count <= 0) {
            count = recv(sock, b, sizeof(b), 0);
            if (count == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = b;
        }
        ch = *bp++;
        *buf++ = ch;
        if (ch == '\n') {
            *buf = '\0';
            return buf - bufx;
        }
    }

    return -1;
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yazısal biçimde komutlar alarak dört işlem yapan örnek bir client/server TCP uygulaması aşaüıda verilmiştir. Uygulamada server için 
    thread modeli, kullanılmıştır. Yani her client bağlandıkça server bir thread yaratır ve client ile o thread konuşur. Buradaki uygulama katmanı protokolü şöyledir:

    - Client server'a fiziksel olarak bağlandıktan sonra mantıksal bağlantı oluşturmak için ona LOGIN komutunu gönderir. Komutun genel biçimi şöyledir:

    LOGIN user_name password\n

    Server kendisine kayıtlı olan kullanıcıları gözden geçirip bu istedği kabul eder ya da etmez. Eğer server bağlantı isteğini kabul ederse client'a
    LOGIN_ACCEPTED mesajı göndermktedir. Bu mesaj şöyledir:

    LOGIN_ACCEPTED\n

    Bundan sonra client server'a aşağıdaki komutları gönderir:

    ADD op1 ope\n
    SUB op1 op2\n
    MUL op1 op2\n
    DIV op1 op2\n

    Server'da bu hesaplamaları yaparak client'a sonucu RESULT mesajı ile göndermektedir:

    RESULT result\n

    Eğer client server'a uygun bir komnut göndermezse server client'a ERROR mesajı ile yanıt vermektedir:

    ERROR mesaj\n

    Client server'a gönderdiği her mesaj için server da client'a bir mesaj göndermektedir. İletişim yine el sıkışmayla sonlandırılmaktadır. Bunun için
    client server'a LOGOUT komutunu gönderir. Server kabul ederse client'a LOGOUT_ACCEPTED mesajıyla yanıt verir. Artık ikiş taraf soketlerini kapatarak
    iletişimi sonlandırırlar.

-------------------------------------------------------------------------------------------------------------------------------------------*/

/* Server.c */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                2048
#define MAX_PARAMS                32    

typedef struct tagCLIENT_REQUEST {
    char buf[BUFFER_SIZE];
    char *params[MAX_PARAMS + 1];
    int nparams;
} CLIENT_REQUEST;

typedef struct tagCLIENT_INFO {
    SOCKET sock;
    char addr[16];
    int port;
} CLIENT_INFO;

typedef struct tagUSER_INFO {
    char *userName;
    char *password;
} USER_INFO;

enum COMMANDS {
    LOGIN_COMMAND,
    ADD_COMMAND,
    SUB_COMMAND, 
    MUL_COMMAND, 
    DIV_COMMAND,
    LOGOUT_COMMAND,
};

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);
DWORD __stdcall ClientThreadProc(LPVOID lpParam);
int ReadLineSocket(SOCKET sock, char *buf, int size);
int WriteSocket(SOCKET sock, const char *buf, int size);
void ParseCommand(char *buf, CLIENT_REQUEST *clientRequest);
BOOL ProcessCommand(const CLIENT_INFO *clientInfo, const CLIENT_REQUEST *clientRequest);

BOOL LoginCommandProc(const CLIENT_REQUEST *clientRequest, char *buf);
void OpCommandProc(const CLIENT_REQUEST *clientRequest, int commandCode, char *buf);
void LogoutCommandProc(const CLIENT_REQUEST *clientRequest, char *buf);

USER_INFO g_users[] = {
    {"student", "12345"},
    {"kaan", "xxxxx"},
    {NULL, NULL}
};

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET serverSock, clientSock;
    struct sockaddr_in sinServer, sinClient;
    int addrLen;
    HANDLE hThread;
    DWORD dwThreadId;
    CLIENT_INFO *clientInfo;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((serverSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)     /* third parameter IPPROTO_TCP */
        ExitSys("socket", WSAGetLastError());

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);
    sinServer.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(serverSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(serverSock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("Waiting for client connection....\n");
    for (;;) {
        addrLen = sizeof(sinClient);
        if ((clientSock = accept(serverSock, (struct sockaddr *)&sinClient, &addrLen)) == INVALID_SOCKET)
            ExitSys("accept", WSAGetLastError());

        if ((clientInfo = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "Cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        clientInfo->sock = clientSock;
        strcpy(clientInfo->addr, inet_ntoa(sinClient.sin_addr));
        clientInfo->port = ntohs(sinClient.sin_port);

        printf("Connected client %s:%d\n", clientInfo->addr, clientInfo->port);

        if ((hThread = CreateThread(NULL, 0, ClientThreadProc, clientInfo, 0, &dwThreadId)) == NULL)
            ExitSys("CreateThread", WSAGetLastError());

        CloseHandle(hThread);
    }
    
    closesocket(serverSock);

    WSACleanup();

    return 0;
}

DWORD __stdcall ClientThreadProc(LPVOID lpParam)
{
    CLIENT_INFO *clientInfo = (CLIENT_INFO *)lpParam;
    char buf[BUFFER_SIZE];
    int result;
    CLIENT_REQUEST clientRequest;
    
    for (;;) {
        if ((result = ReadLineSocket(clientInfo->sock, buf, BUFFER_SIZE)) == SOCKET_ERROR) {
            fprintf(stderr, "Error: ReadLineSocket, ClientConnection is closing...\n");
            break;
        }
    
        if (result == 0)
            break;
        printf("Client request: %s", buf);
        ParseCommand(buf, &clientRequest);
        if (!ProcessCommand(clientInfo, &clientRequest))
            break;
    }

    shutdown(clientInfo->sock, SD_BOTH);
    closesocket(clientInfo->sock);
    free(clientInfo);

    return 0;
}

int ReadLineSocket(SOCKET sock, char *buf, int size)
{
    char *bufx = buf;
    static char *bp;
    static int count = 0;
    static char b[2048];
    char ch;

    while (--size > 0) {
        if (--count <= 0) {
            count = recv(sock, b, sizeof(b), 0);
            if (count == SOCKET_ERROR)
                return SOCKET_ERROR;
            if (count == 0)
                return 0;
            bp = b;
        }
        ch = *bp++;
        *buf++ = ch;
        if (ch == '\n') {
            *buf = '\0';
            return (int)(buf - bufx);
        }
    }

    return SOCKET_ERROR;
}

int WriteSocket(SOCKET sock, const char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = send(sock, buf + count, left, 0)) == SOCKET_ERROR)
            return SOCKET_ERROR;
        if (result == 0)
            break;
        left -= result;
        count += result;
    }

    return count;
}

void ParseCommand(char *buf, CLIENT_REQUEST *clientRequest)
{
    char *str;
    int count;

    strcpy(clientRequest->buf, buf);
    for (count = 0, str = strtok(buf, " \t\n"); str != NULL && count < MAX_PARAMS; str = strtok(NULL, " \t\n"), ++count)
        clientRequest->params[count] = str;
    clientRequest->nparams = count;
}

BOOL ProcessCommand(const CLIENT_INFO *clientInfo, const CLIENT_REQUEST *clientRequest)
{
    static char *clientRequests[] = { "LOGIN", "ADD", "SUB", "MUL", "DIV", "LOGOUT", NULL};
    int i;
    int result;
    char buf[BUFFER_SIZE];
    BOOL retVal = TRUE;

    if (clientRequest->nparams == 0) {
        sprintf(buf, "ERROR Empty command\n", clientRequest->params[0]);
        if ((result = WriteSocket(clientInfo->sock, buf, (int)strlen(buf))) == SOCKET_ERROR)
            fprintf(stderr, "Error: WriteSocket\n");
        return retVal;
    }

    for (i = 0; clientRequests[i] != NULL; ++i)
        if (!strcmp(clientRequests[i], clientRequest->params[0]))
            break;

    if (clientRequests[i] == NULL) {
        sprintf(buf, "ERROR Command not found \"%s\"\n", clientRequest->params[0]);
        if ((result = WriteSocket(clientInfo->sock, buf, (int)strlen(buf))) == SOCKET_ERROR)
            fprintf(stderr, "Error: WriteSocket\n");
        return retVal;
    }
        
    switch (i) {
        case LOGIN_COMMAND:
            if (!LoginCommandProc(clientRequest, buf)) {
                retVal = FALSE;
                break;
            }
        break;
        case ADD_COMMAND:
            OpCommandProc(clientRequest, ADD_COMMAND, buf);
            break;
        case SUB_COMMAND:
            OpCommandProc(clientRequest, SUB_COMMAND, buf);
            break;
        case MUL_COMMAND:
            OpCommandProc(clientRequest, MUL_COMMAND, buf);
            break;
        case DIV_COMMAND:
            OpCommandProc(clientRequest, DIV_COMMAND, buf);
            break;
        case LOGOUT_COMMAND:
            LogoutCommandProc(clientRequest, buf);
            retVal = FALSE;
            break;
    }    
    if ((result = WriteSocket(clientInfo->sock, buf, (int)strlen(buf))) == SOCKET_ERROR) {
        fprintf(stderr, "Error: WriteSocket\n");
        retVal = FALSE;
    }

    return retVal;
}

void OpCommandProc(const CLIENT_REQUEST *clientRequest, int commandCode, char *buf)
{
    double op1, op2, opResult;
    
    if (clientRequest->nparams == 3)
        if (sscanf(clientRequest->params[1], "%lf", &op1) == 1)
            if (sscanf(clientRequest->params[2], "%lf", &op2) == 1) {
                switch (commandCode) {
                    case ADD_COMMAND:
                        opResult = op1 + op2;
                        break;
                    case SUB_COMMAND:
                        opResult = op1 - op2;
                        break;
                    case MUL_COMMAND:
                        opResult = op1 * op2;
                        break;
                    case DIV_COMMAND:
                        opResult = op1 / op2;
                        break;
                }
                sprintf(buf, "RESULT %f\n", opResult);
            }
            else
                sprintf(buf, "ERROR Invalid command operand\n");
        else
            sprintf(buf, "ERROR Invalid command operand\n");
    else
        sprintf(buf, "ERROR Invalid command operand\n");
}

BOOL LoginCommandProc(const CLIENT_REQUEST *clientRequest, char *buf)
{
    int i;

    for (i = 0; g_users[i].userName != NULL; ++i) {
        if (!strcmp(g_users[i].userName, clientRequest->params[1]) && !strcmp(g_users[i].password, clientRequest->params[2])) {
            sprintf(buf, "LOGIN_ACCEPTED\n");
            return TRUE;
        }
    }
    sprintf(buf, "ERROR Invalid user name or password\n");
    
    return FALSE;    
}

void LogoutCommandProc(const CLIENT_REQUEST *clientRequest, char *buf)
{
    if (clientRequest->nparams == 1) 
        sprintf(buf, "LOGOUT_ACCEPTED Logout Accepted\n");
    else
        sprintf(buf, "ERROR Invalid command operand\n");
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define CLIENT_PORTNO            62000
#define SERVER_NAME                "185.86.155.34"
#define BUFFER_SIZE                2048
#define MAX_USER_NAME            32
#define MAX_PASSWORD            32

typedef struct tagSERVER_RESPONSE {
    char *command;
    char *text;
} SERVER_RESPONSE;

enum COMMANDS {
    LOGIN_ACCEPTED_COMMAND,
    RESULT_COMMAND,
    ERROR_COMMAND,
    LOGOUT_ACCEPTED_COMMAND,
};

int ReadLineSocket(SOCKET sock, char *buf, int size);
int WriteSocket(SOCKET sock, const char *buf, int size);
BOOL LoginProc(SOCKET clientSock, char *buf, SERVER_RESPONSE *serverResponse);
void ParseCommand(char *buf, SERVER_RESPONSE *serverResponse);
BOOL ProcessCommand(const SERVER_RESPONSE *serverResponse);
void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET clientSock;
    struct sockaddr_in sinServer;
    struct hostent *hostEnt;
    char buf[BUFFER_SIZE];
    int result;
    SERVER_RESPONSE serverResponse;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((clientSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());
    /*
    {
        struct sockaddr_in sinClient;

        sinClient.sin_family = AF_INET;
        sinClient.sin_port = htons(CLIENT_PORTNO);
        sinClient.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(clientSock, (struct sockaddr *)&sinClient, sizeof(sinClient)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);

    sinServer.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sinServer.sin_addr.s_addr == INADDR_NONE) {
        if ((hostEnt = gethostbyname(SERVER_NAME)) == NULL) 
            ExitSys("gethostbyname", WSAGetLastError());

        memcpy(&sinServer.sin_addr.s_addr, hostEnt->h_addr_list[0], hostEnt->h_length);
    }
    if (connect(clientSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    printf("Connected...\n");

    if (!LoginProc(clientSock, buf, &serverResponse))
        goto FAILED;

    printf("Client connected...\n");

    for (;;) {
        printf("Calculator>");
        fflush(stdout);
        fgets(buf, BUFFER_SIZE, stdin);
        if ((result = WriteSocket(clientSock, buf, (int)strlen(buf))) == SOCKET_ERROR)
            ExitSys("WriteSocket", WSAGetLastError());
        if (result == 0)
            break;
        if ((result = ReadLineSocket(clientSock, buf, BUFFER_SIZE)) == SOCKET_ERROR)
            ExitSys("ReadLineSocket", WSAGetLastError());
        if (result == 0)
            break;

        ParseCommand(buf, &serverResponse);
        if (!ProcessCommand(&serverResponse))
            break;
    }
FAILED:
    shutdown(clientSock, SD_BOTH);
    closesocket(clientSock);

    WSACleanup();

    return 0;
}

int ReadLineSocket(SOCKET sock, char *buf, int size)
{
    char *bufx = buf;
    static char *bp;
    static int count = 0;
    static char b[2048];
    char ch;

    while (--size > 0) {
        if (--count <= 0) {
            count = recv(sock, b, sizeof(b), 0);
            if (count == SOCKET_ERROR)
                return SOCKET_ERROR;
            if (count == 0)
                return 0;
            bp = b;
        }
        ch = *bp++;
        *buf++ = ch;
        if (ch == '\n') {
            *buf = '\0';
            return (int) (buf - bufx);
        }
    }

    return SOCKET_ERROR;
}

int WriteSocket(SOCKET sock, const char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = send(sock, buf + count, left, 0)) == SOCKET_ERROR)
            return SOCKET_ERROR;
        if (result == 0)
            break;
        left -= result;
        count += result;
    }

    return count;
}

BOOL LoginProc(SOCKET clientSock, char *buf, SERVER_RESPONSE *serverResponse)
{
    char userName[MAX_USER_NAME];
    char password[MAX_PASSWORD];
    
    int result;
    char *str;

    printf("User name:");
    fgets(userName, MAX_USER_NAME, stdin);
    if ((str = strchr(userName, '\n')) != NULL)
        *str = '\0';
    printf("Password:");
    fgets(password, MAX_PASSWORD, stdin);
    if ((str = strchr(password, '\n')) != NULL)
        *str = '\0';

    sprintf(buf, "LOGIN %s %s\n", userName, password);

    if ((result = WriteSocket(clientSock, buf, (int)strlen(buf))) == SOCKET_ERROR || result == 0) {
        fprintf(stderr, "Error WriteSocket!..\n");
        return FALSE;
    }

    /* buffer problem */
    if ((result = ReadLineSocket(clientSock, buf, BUFFER_SIZE)) == SOCKET_ERROR || result == 0) {
        fprintf(stderr, "Error ReadLineSocket!..\n");
        return FALSE;
    }
    
    ParseCommand(buf, serverResponse);

    if (strcmp(serverResponse->command, "LOGIN_ACCEPTED") != 0) {
        printf("%s\n", serverResponse->text);
        return FALSE;
    }

    return TRUE;
}

void ParseCommand(char *buf, SERVER_RESPONSE *serverResponse)
{
    char *str = buf;

    str = buf;
    serverResponse->command = str;

    while (*buf != ' ' && *buf != '\n')
        ++buf;
    if (*buf == '\n') {
        *buf = '\0';
        serverResponse->text = NULL;
        return;
    }
    *buf++ = '\0';
    
    str = buf;
    while (*buf != '\n')
        ++buf;
    *buf = '\0';
    serverResponse->text = str;
}

BOOL ProcessCommand(const SERVER_RESPONSE *serverResponse)
{
    static char *serverCommands[] = { "LOGIN_ACCEPTED", "RESULT", "ERROR", "LOGOUT_ACCEPTED", NULL};
    int i;
    BOOL retVal = TRUE;

    for (i = 0; serverCommands[i] != NULL; ++i)
        if (!strcmp(serverCommands[i], serverResponse->command))
            break;

    switch (i) {
        case RESULT_COMMAND:
        case ERROR_COMMAND:
            printf("%s\n", serverResponse->text);
            break;
        case LOGOUT_ACCEPTED_COMMAND:
            printf("%s\n", serverResponse->text);
            retVal = FALSE;
            break;
        default:
            printf("Unknown server command: %s\n", serverResponse->text);
    }

    return retVal;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Aslında IP ailesinin uygulama katmanındaki protokollerin büyük çoğunluğu aslında yazısal kıomutlarla yukarıdakşi örnekte olduğu gibi
    haberleşme yapmaktadır. Örneğin POP3 protokolünde çnce client server'a kendini aşaüıdaki komut ile tanıtır:

    USER user_name\r\n
    PASS password\r\n

    Sonra client server'daki posta kutusundaki postalar hakkında bilgiyi LIST komutuyla elde eder. Her postanın bir indeks numarası vardır. Client
    RETR komutuyla indeks numarasını belirterek server'dan posta kutusundaki belli bir postayı istemektedir. Belli bir postayı silmek için client 
    server'a DELE komutunu gönderir. Tüm komutlar yazısal olarak sonu CR/LF ile bitecek biçimde gönderilmktedir. Server her komut için client'a bir 
    yanıt göndermektedir. Olumlu yanıtlar için +OK, olumsuz yanıtlar için -ERR mesaj komutları kullanılmaktadır. Protokolün detayları için RFC-1939
    dokümanına başvurabilirsiniz. 

    Aşağıdaki örnekte komut satırından girilen komutlar POP3 server'a gönderilip oradaki yanıtlar alınarak ekrana yazdırılmıştır. Bıu işlemi telnet 
    denilen hazır programla da yapabilirsiniz. 

-------------------------------------------------------------------------------------------------------------------------------------------*/

/* pop3.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_PORTNO            110
#define BUFFER_SIZE                2048
#define SERVER_NAME                "mail.csystem.org"

int ReadLineSocket(SOCKET sock, char *buf, int size);
int WriteSocket(SOCKET sock, const char *buf, int size);
DWORD __stdcall Pop3ReadThreadProc(LPVOID lpvParam);
void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET clientSock;
    struct sockaddr_in sinServer;
    struct hostent *hostEnt;
    char buf[BUFFER_SIZE + 1];
    int result;
    char *str;
    HANDLE hThread;
    DWORD dwThreadId;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((clientSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());
    /*
    {
        struct sockaddr_in sinClient;

        sinClient.sin_family = AF_INET;
        sinClient.sin_port = htons(CLIENT_PORTNO);
        sinClient.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(clientSock, (struct sockaddr *)&sinClient, sizeof(sinClient)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);

    sinServer.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sinServer.sin_addr.s_addr == INADDR_NONE) {
        if ((hostEnt = gethostbyname(SERVER_NAME)) == NULL)
            ExitSys("gethostbyname", WSAGetLastError());

        memcpy(&sinServer.sin_addr.s_addr, hostEnt->h_addr_list[0], hostEnt->h_length);
    }
    if (connect(clientSock, (struct sockaddr *)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    if ((hThread = CreateThread(NULL, 0, Pop3ReadThreadProc, (LPVOID)clientSock, 0, &dwThreadId)) == NULL)
        ExitSys("CreateThread", GetLastError());

    for (;;) {
        Sleep(500);

        printf("POP3>");
        fflush(stdout);
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        strcat(buf, "\r\n");
        if ((result = WriteSocket(clientSock, buf, (int)strlen(buf))) == SOCKET_ERROR)
            ExitSys("WriteSocket", WSAGetLastError());
        if (result == 0) {
            printf("Other side closed connection...\n");
            break;
        }
        if (!strcmp(buf, "QUIT\r\n"))
            break;

    }
    shutdown(clientSock, SD_BOTH);
    closesocket(clientSock);
    CloseHandle(hThread);

    WSACleanup();

    return 0;
}

int ReadLineSocket(SOCKET sock, char *buf, int size)
{
    char *bufx = buf;
    static char *bp;
    static int count = 0;
    static char b[2048];
    char ch;

    while (--size > 0) {
        if (--count <= 0) {
            count = recv(sock, b, sizeof(b), 0);
            if (count == SOCKET_ERROR)
                return SOCKET_ERROR;
            if (count == 0)
                return 0;
            bp = b;
        }
        ch = *bp++;
        *buf++ = ch;
        if (ch == '\n') {
            buf[-2] = '\0';
            return (int)(buf - bufx);
        }
    }

    return SOCKET_ERROR;
}

int WriteSocket(SOCKET sock, const char *buf, int size)
{
    int left, count;
    int result;

    left = size;
    count = 0;

    while (left > 0) {
        if ((result = send(sock, buf + count, left, 0)) == SOCKET_ERROR)
            return SOCKET_ERROR;
        if (result == 0)
            break;
        left -= result;
        count += result;
    }

    return count;
}

DWORD __stdcall Pop3ReadThreadProc(LPVOID lpvParam)
{
    char buf[BUFFER_SIZE + 1];
    int result;
    SOCKET sock = (SOCKET)lpvParam;

    for (;;) {
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());
        buf[result] = '\0';
        printf("%s", buf);
    }

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    UDP bağlantısız (connectionless), datagram tabanlı, güvenli olmayan hızlı bir protokoldür. Aslında IP protokolünün kendisine çok benzemektedir. 
    Bilgileri paket halinde gönderir. Hiç bağlantı yapmadan bilgi gönderimşi ve alımı mümkündür. Server taraf soketi yarattıktan sonra yine bind eder. 
    Sonra da döngü içerisinde recvfrom fonksiyonu ile datagram paketlerini okur. Clieng taraf bilgi alımı yapmayacaksa bind uygulamaz. Doğrudan
    soketi yaratıp sendto fonksiyonu ile gönderimi yapar. Genellikle UDP'de alan tarafa server, gönderen tarafa client denilmektedir. Ancak client ve 
    server rolleri bu protokolde çok belli değildir. Bir server'a hiç bağlantı yapmadan pek çok cliengt bilgi gönderebilir. recvfrom fonksiyonu
    datagram paketini alırken aynı zamanda onun kişmden geldiğini de elde etmektedir. 

    Aşağıdaki programda tipik bir UDP server örneği verilmiştir.  

-------------------------------------------------------------------------------------------------------------------------------------------*/

/* Server.c */

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET serverSock;
    struct sockaddr_in sinServer, sinClient;
    int addrLen;
    char buf[BUFFER_SIZE + 1];
    int result;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((serverSock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)     /* third parameter IPPROTO_UDP */
        ExitSys("socket", WSAGetLastError());

    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);
    sinServer.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(serverSock, (struct sockaddr*)&sinServer, sizeof(sinServer)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    printf("Waiting for messages...\n");
    for (;;) {
        addrLen = sizeof(sinClient);
        if ((result = recvfrom(serverSock, buf, BUFFER_SIZE, 0, (struct sockaddr*)&sinClient, &addrLen)) == SOCKET_ERROR)
            ExitSys("recvfrom", GetLastError());
        buf[result] = '\0';
        printf("%d bytes received from %s:%d \"%s\"\n", result, inet_ntoa(sinClient.sin_addr), ntohs(sinClient.sin_port), buf);
    }

    closesocket(serverSock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* Client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1" 

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr);

int main(void)
{
    WSADATA wsaData;
    DWORD dwResult;
    SOCKET clientSock;
    struct sockaddr_in sinServer;
    struct hostent *hostEnt;
    char buf[BUFFER_SIZE];
    char *str;

    if ((dwResult = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
        ExitSys("WSAStartup", dwResult);

    if ((clientSock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());
    
    sinServer.sin_family = AF_INET;
    sinServer.sin_port = htons(SERVER_PORTNO);

    sinServer.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sinServer.sin_addr.s_addr == INADDR_NONE) {
        if ((hostEnt = gethostbyname(SERVER_NAME)) == NULL)
            ExitSys("gethostbyname", WSAGetLastError());

        memcpy(&sinServer.sin_addr.s_addr, hostEnt->h_addr_list[0], hostEnt->h_length);
    }

    for (;;) {
        printf("Text:");

        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "exit"))
            break;

        if (sendto(clientSock, buf, (int)strlen(buf), 0, (struct sockaddr *) &sinServer, sizeof(sinServer)) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());
    }
    closesocket(clientSock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastErr)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programın UNIX/Linux sistemlerindeki karşılığı aşağıdaki gibi oluşturulabilir. 
-------------------------------------------------------------------------------------------------------------------------------------------*/

/* udp-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024

void exit_sys(const char *msg);

int main(void)
{
    int server_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t addrlen;
    char buf[BUFFER_SIZE + 1];
    int result;

    if ((server_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);
    
    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    printf("Waiting for messages...\n");
    for (;;) {
        addrlen = sizeof(sin_server);
        if ((result = recvfrom(server_sock, buf, BUFFER_SIZE, 0, (struct sockaddr*)&sin_client, &addrlen)) == -1)
            exit_sys("recvfrom");
        buf[result] = '\0';
        printf("%d bytes received from %s:%d \"%s\"\n", result, inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port), buf);
    }

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* udp-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_PORTNO            55000
#define BUFFER_SIZE                1024
#define SERVER_NAME                "127.0.0.1" 

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hoste;
    char buf[BUFFER_SIZE];
    char *str;

    if ((client_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");
    
    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORTNO);

    sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME);
    if (sin_server.sin_addr.s_addr == INADDR_NONE) {
        if ((hoste = gethostbyname(SERVER_NAME)) == NULL)
            exit_sys("gethostbyname");

        memcpy(&sin_server.sin_addr.s_addr, hoste->h_addr_list[0], hoste->h_length);
    }

    for (;;) {
        printf("Text:");

        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "exit"))
            break;

        if (sendto(client_sock, buf, (int)strlen(buf), 0, (struct sockaddr *) &sin_server, sizeof(sin_server)) == -1)
            exit_sys("sendto");
    }
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde dosya sistemlerini belli bir derinlikte inceleyeceğiz. Dosya sistemlerini ele almadan önce bilgisayar
    sistemlerindeki disk sistemleri hakkında bazı temel bilgilerin edinilmesi gerekmektedir. Eskiden diskler yerine teyp bantları
    kullanılıyordu. Teyp bantları sıralı erişim sağlıyordu. Sonra manyetik diskler kullanılmaya başlandı. Kişisel bilgisayarlardaki
    manyetik disklere "hard disk" de deniyordu. Bugünlerde artık hard diskler de teknoloji dışı kalmaya başlamıştır. Bugün disk 
    sistemleri için artık flash bellekler (EEPROM bellekler) kullanılmaktadır. Yani SSD (Solid State Disk) diye isimlendirilen 
    bu disk sistemlerinin artık mekanik bir parçası yoktur. Bunlar tamamen yarı iletken teknolojisiyle üretilmiş entegre 
    devrelerdir. Disk sisteminin türü ne olursa olsun bu disk sistemini yöneten ondan sorumlu bir denetleyici birim bulunmaktadır. 
    Buna "disk denetleyicisi (disk controller)" denilmektedir. Kernel mode aygıt sürücüler bu disk denetleyicisini programlayarak
    transferleri gerçekleştirmektedir. Bugünkü disk sistemlerini şekilsel olarak aşağıdaki gibi düşünebiliriz:

    +-------------+       +------------------+       +--------------+       +-----------+
    | Disk Birimi | <---> | Disk Denetleyici | <---> | Aygıt Sürücü | <---> | User Mode |
    +-------------+       +------------------+       +--------------+       +-----------+
                                                            |
                                                            |
                                                     +------------+
                                                     | Disk Cache |
                                                     +------------+

    Örneğin biz user mode'da bir diskten bir sektör okumak istediğimizde bu işlemi yapan blok aygıt sürücüsünden istekte 
    bulunuruz. Blok aygıt sürücüleri disk denetleyicilerini programlar, disk denetleyicileri disk birimine erişir ve transfer
    gerçekleşir. Disk transferleri CPU aracılığıyla değil, "DMA (Direct Memory Access)" denilen özel denetleyicilerle sağlanmaktadır. 
    Yani aygıt sürücü hem disk denetleyicisini hem de DMA'yı programlar ve transfer yapılana kadar bekler. Bu sırada işletim sistemi 
    zaman alacak bu işlemi meşgul bir döngüde beklemez. O anda istekte bulunan thread'i bekleme kuyruğuna yerleştirerek sıradaki
    thread'i çizelgeler.

    İşletim sistemlerinde diskten transfer işlemi yapan blok aygıt sürücüleri ismine "disk cache" ya da "buffer cache" ya da
    "page cache" denilen bir cache sistemi kullanmaktadır. Tabii cache sistemi aslında çekirdek tarafından organize edilmiştir. 
    Blok aygıt sürücüsünden bir sektörlük bilgi okunmak istediğinde aygıt sürücü önce bu cache sistemine bakar. Eğer istenen 
    sektör bu cache sisteminde varsa hiç bekleme yapmadan oradan alıp talep eden thread'e verir. Eğer sektör cache'te yoksa
    blok aygıt sürücüsü disk denetleyicisini ve DMA denetleyicisini programlayarak sektörü önce cache'e transfer eder. Oradan
    talep eden thread'e verir. Bu amaçla kullanılan cache'lerde cache algoritması (cache replacement algorithm) genel olarak 
    LRU(Least Recently Used) algoritmasıdır. Yani son zamanlarda erişilen yerler mümkün olduğunca cache'te tutulmaktadır. İşletim 
    sistemlerinin dosya sistemleri arka planda bu blok aygıt sürücülerini kullanmaktadır. Dolayısıyla tüm dosya işlemleri aslında 
    bu cache sistemi ile gerçekleşmektedir. Yani örneğin bugünkü modern işletim sistemlerinde ne zaman bir dosya işlemi yapılsa o 
    dosyanın okunan ya da yazılan kısmı disk cache içerisine çekilmektedir. Aynı dosya üzerinde bir işlem yapıldığında zaten o 
    dosyanın diskteki blokları cache'te olduğu için gerçek anlamda bir disk işlemi yapılmayacaktır.

    Pekiyi aygıt sürücü bir sektörü yazmak isterse ne olmaktadır? İşte yazma işlemleri de doğrudan değil cache yoluyla 
    yapılmaktadır. Yani sektör önce disk cache'e yazılır. Sonra çizelgelenir ve işletim sisteminin bir kernel thread'i 
    yoluyla belli periyotlarda diske transfer edilir. User mode'dan çeşitli thread'lerin diskten okumalar yaptığını düşünelim.
    Önce bu talepler işletim sistemi tarafından kuyruklanır, çizelgelenir sonra etkin bir biçimde transfer gerçekleştirilir. 
    İşletim sistemlerinin bu kısmına "IO çizelgeleyicisi (IO scheduler)" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün artık SSD (yani elektronik devre biçiminde) diskler yaygın olarak kullanılıyorsa da bir dönem öncesine kadar 
    manyetik tabanlı "hard diskler" yoğun kullanılıyordu. Burada bu hard disklerin genel yapısı üzerinde bazı açıklamalar da
    yapmak istiyoruz.

    Hard disklerde bir eksene monte edilmiş birden fazla yüzey vardır. Bu yüzeylere "platter" denilmektedir. Bir platter'da 
    iki yüz bulunur. Her yüz bir disk kafası ile okunmaktadır. Örneğin bir hard diskte 4 platter varsa toplam 8 tane yüz
    ve 8 tane kafa bulunur. Bilgiler tıpkı eski plaklarda olduğu gibi yuvarlak yollara yazılıp okunmaktadır. Bunlara "track"
    denilmektedir. Dolayısıyla bir track'e bilginin yazılıp okunması için öncelikle kafanın o track hizasına konumlandırılması 
    gerekmektedir. Tabii okuma yazma işlemi disk dönerken yapılmaktadır. Bu durumda manyetik tabanlı bu hard disklerde bir 
    sektörün transfer edilmesi için üç zaman unsuru vardır:

    1) Disk kafasının ilgili track hizasına konumlandırılması için gereken zaman (seek time).
    2) Diskin dönerek kafa hizasına gelmesi için gereken zaman (rotation delay).
    3) Transfer zamanı (transfer time)

    Buradaki en önemli zaman kaybı disk kafasının konumlandırılması sırasındaki kayıptır. Ortalama bir disk 6000 RPM hızında 
    dönmektedir. Yani bir dakikada 6000 tur atmaktadır. İkinci önemli zaman kaybı ilgi sektörün track kafa hizasına gelmesi 
    için harcanan zamandır. Nihayet en hızlı gerçekleşen işlem transfer işlemidir.

    İşletim sistemlerinin eski hard disklerde uyguladığı en önemli optimizasyon işlemi kafa hareketinin azaltılması üzerinedir. 
    Eğer dosyayı oluşturan sektörler birbirine yakınsa daha az kafa hareketi oluşur ve toplam transfer zamanı azaltılmış olur. 
    Tabii dosya sistemlerinde dosyanın parçaları zamanla birbirinden uzaklaşabilmektedir. Bunları birbirine yaklaştıran
    genellikle "defrag" biçiminde isimlendirilen yardımcı programlar vardır.

    Tabii artık şimdilerde kullandığımız SSD disklerde hiçbir mekanik unsur yoktur. Bunlar tamamen flash EPROM teknolojisi ile
    yani yarı iletken teknolojisiyle entegre devre biçiminde üretilmektedir. Bunlar rastgele erişimlidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diskten transfer edilecek en küçük birime sektör denilmektedir. Bir sektör genel olarak 512 byte uzunluğundadır. 
    Örneğin biz bir diskteki 1 byte'ı değiştirmek istesek önce onun içinde bulunduğu sektörü belleğe okuyup değişikliği 
    bellekte yapıp o sektörü yeniden diske yazarız. Disklere byte düzeyinde değil, sektör düzeyinde erişilmektedir.

    Diskteki her sektöre ilk sektör 0 olmak üzere bir numara verilmiştir. Disk denetleyicileri bu numarayla çalışmaktadır. 
    Eskiden disklerdeki koordinat sistemi daha farklıydı. Daha sonra teknoloji geliştikçe sektörün yerini belirlemek için 
    tek bir sayı kullanılmaya başlandı. Bu geçiş sırasında kullanılan bu sisteme LBA (Logical Block Addressing) deniliyordu. 
    Artık ister hard diskler olsun isterse SSD'ler olsun tıpkı bellekte her byte'ın bir numarası olduğu gibi her sektörün de 
    bir sektör numarası vardır. Transferler bu sektör numarasıyla yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında "dosya (file)" kavramı mantıksal bir kavramdır. Diskteki fiziksel birimler sektör denilen birimlerdir. Yani diskler
    dosyalardan oluşmaz sektörlerden oluşur. Dosya bir isim altında bir grup sektörü organize etmek için uydurulmuş bir 
    kavramdır. Aslında dosyanın içindekiler diskte ardışıl sektörlerde olmak zorunda değildir. Kullanıcı için dosya sanki 
    ardışıl byte'lardan oluşan bir topluluk gibidir. Ancak bu bir aldatmacadır. Dosyadaki byte'lar herhangi bir biçimde ardışıl 
    olmak zorunda değildir. Örneğin elimizde 100K'lık bir dosya olsun. Aslında bu 100K'lık dosya diskte 200 sektör içerisindedir. 
    Peki bu dosyanın parçaları hangi 200 sektör içerisindedir? İşte bir biçimde bu bilgiler de disk üzerinde tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk sistemleriyle ilgili programcıların ilk bilmesi gereken işlemler bir sektörün okunmasının ve yazılmasının nasıl 
    yapılacağıdır. Yukarıda bu işlemleri yapan yazılımsal birimin blok aygıt sürücüleri olduğunu belirtmiştik. Aygıt sürücülerin 
    de birer dosya gibi açılıp kullanıldığını biliyoruz. O halde sektör transferi için bizim hangi aygıt sürücüyü kullanacağımızı
    bilmemiz gerekir. UNIX/Linux sistemlerinde bilindiği gibi tüm temel aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini 
    içerisindedir.

    Bir Linux sisteminde "lsblk" komutu ile disklere ilişkin blok aygıt sürücülerinin listesini elde edebilirsiniz. Örneğin:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sr0     11:0    1 1024M  0 rom

    Linux sistemlerinde disklere ilişkin blok aygıt sürücüleri diskin türüne göre farklı biçimlerde isimlendirilmektedir. 
    Örneğin hard diskler ve SSD diskler tipik olarak "sda", "sdb", "sdc" biçiminde isimlendirilmektedir. Micro SD kartlar
    ise genellikle "mmcblk0", mmcblk1", "mmcblk2" gibi isimlendirilmektedir. Örneğin burada "sda" (Solid Disk a) ismi hard
    diski bir bütün olarak ele alan aygıt dosyasının ismidir. Disk, disk bölümlerinden oluşmaktadır. Bu disk bölümlerini sanki 
    ayrı disklermiş gibi ele alan aygıt dosyaları da "sda1", "sda2", "sda3" biçimindedir. Burada "disk bölümü (disk partition)" 
    terimini biraz açmak istiyoruz.

    Bir diskin bağımsız birden fazla diskmiş gibi kullanılabilmesi için disk mantıksal bölümlere ayrılmaktadır. Bu bölümlere
    "disk bölümleri (disk partitions)" denilmektedir. Bir disk bölümü diskin belli bir sektöründen başlar belli bir sektör 
    uzunluğu kadar devam eder. Disk bölümlerinin hangi sektörden başladığı ve hangi uzunlukta olduğu diskin başındaki bir 
    tabloda tutulmaktadır. Bu tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. Disk bölümleme tablosu 
    eskiden diskin ilk sektöründe tutuluyordu. Sonra UEFI BIOS'larla birlikte eski sistemle uyumlu olacak biçimde yeni 
    disk bölümleme tablo formatı geliştirildi. Bunlara "GUID Disk Bölümleme Tablosu (GUID Partition Table)" denilmektedir. 
    Örneğin 3 disk bölümüne sahip bir diskin mantıksal organizasyonu şöyledir:

    Disk Bölümleme Tablosu
    Birinci Disk Bölümü
    İkinci Disk Bölümü
    Üçüncü Disk Bölümü

    İşte "lsblk" yaptığımız Linux sisteminde biz "/dev/sda" aygıt dosyasını açarsak tüm diski tek parça olarak ele alırız. 
    Eğer "/dev/sda1" aygıt dosyasını açarsak sanki Birinci Disk Bölümü ayrı diskmiş gibi yalnızca o bölümü ele alabiliriz. 
    Örneğin "/dev/sda2" aygıt dosyasından okuyacağımız 0 numaralı sektör aslında İkinci Disk Bölümünün ilk sektörüdür. 
    Tabii bu sektör "/dev/sda" aygıt dosyasındaki 0 numaralı sektör değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir diskten bir sektör okumak için yapılacak tek şey ilgili aygıt sürücüyü open fonksiyonuyla açmak 
    dosya göstericisini konumlandırıp read fonksiyonu ile okuma yapmaktır. Biz yukarıda bir diskten okunup yazılabilen en 
    küçük birimin bir sektör olduğunu (512 byte) söylemiştik. Her ne kadar donanımsal olarak bir diskten okunabilecek ya da 
    diske yazılabilecek en küçük birim bir sektör olsa da aslında işletim sistemleri transferleri sektör olarak değil blok 
    blok yapmaktadır. Bir blok ardışıl n tane sektöre denilmektedir. Örneğin Linux işletim sisteminin disk cache sistemi 
    aslında 4K büyüklüğünde bloklara sahiptir. 4K'nın aynı zamanda sayfa büyüklüğü olduğunu anımsayınız. Dolayısıyla biz 
    Linux'ta aslında disk ile bellek arasında en az 4K'lık transferler yapmaktayız. O halde işletim sisteminin dosya sistemi
    ve diske doğrudan erişen sistem programcıları, Linux sistemlerinde diskten birer sektör okuyup yazmak yerine 4K'lık blokları 
    okuyup yazarsa sistemle daha uyumlu çalışmış olur.

    Pekiyi biz ilgili disk aygıt sürücüsünü açıp read fonksiyonu ile yalnızca 10 byte okumak istersek ne olur? İşte bu durumda 
    blok aygıt sürücüsü gerçek anlamda o 10 byte'ın içinde bulunduğu 4K'lık bir kısmı diskten okur onu cache'e yerleştirir 
    ve bize onun yalnızca 10 byte'ını verir. Aynı byte'ları ikinci kez okumak istersek gerçek anlamda bir disk okuması 
    yapılmayacak RAM'de saklanmış olan cache'in içerisindeki bilgiler bize verilecektir. Aşağıda diski bir bütün olarak gören 
    "/dev/sda" aygıt sürücüsü açılıp onun ilk sektörü okunmuş ve içeriği HEX olarak ekrana (stdout dosyasına) yazdırılmıştır. 
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Bu aygıt sürücüyü temsil eden aygıt dosyasına ancak root kullanıcısı 
    erişebilmektedir. Bu dosyaların erişim haklarına dikkat ediniz:

    $ ls /dev/sda* -l
    brw-rw---- 1 root disk 8, 0 Ağu 29 14:56 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ağu 29 14:56 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ağu 29 14:56 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ağu 29 14:56 /dev/sda3

    Bu durumda programınızı sudo ile çalıştırmalısınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    unsigned char buf[512];

    if ((fd = open("/dev/sda", O_RDONLY)) == -1)
        exit_sys("open");

    if (read(fd, buf, 512) == -1)
        exit_sys("read");

    for (int i = 0; i < 512; ++i)
        printf("%02x%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya sistemi (file system) denildiğinde ne anlaşılmaktadır? Bir dosya sisteminin iki yönü vardır: Bellek ve disk. 
    Dosya sisteminin bellek tarafı işletim sisteminin açık dosyalar için kernel alanında yaptığı organizasyonla (dosya betimleyici 
    tablosu, dosya nesnesi vs.) ilgilidir. Disk tarafı ise diskteki organizasyonla ilgilidir. Biz kursumuzda bellek tarafındaki
    organizasyonun temellerini gördük. Şimdi bu bölümde disk üzerindeki organizasyonu ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kavramını diskte oluşturmak için farklı dosya sistemleri tarafından farklı disk organizasyonları kullanılmaktadır. 
    Bugün kullanılan çok sayıda dosya sistemi vardır. Bu sistemlerin her birinin disk organizasyonu diğerinden az çok farklıdır. 
    Ancak bazı dosya sistemlerinin disk organizasyonları birbirine çok benzemektedir. Bunlar adeta bir aile oluşturmaktadır. 
    Örneğin Microsoft'un FAT dosya sistemleri, Linux'un ext dosya sistemleri kendi aralarında birbirine oldukça benzemektedir.

    Microsoft'un dünyanın ilk kişisel bilgisayarlarında kullandığı dosya sistemlerine aile olarak FAT (File Allocation Table) 
    denilmektedir. Bu FAT dosya sistemlerinin kendi içerisinde FAT12, FAT16 ve FAT32 biçiminde varyasyonları vardır. Microsoft 
    daha sonra yine FAT tabanlı ancak çok daha gelişmiş NTFS denilen bir dosya sistemi gerçekleştirmiştir. Bugün Windows 
    sistemlerinde genel olarak NTFS (New Technology File Systems) dosya sistemleri kullanılmaktadır. Ancak Microsoft hala 
    FAT tabanlı dosya sistemlerini de desteklemektedir. Linux sistemlerinde "EXT (Extended File System)" ismi verilen 
    "i-node tabanlı" dosya sistemleri kullanılmaktadır. Bu EXT dosya sistemlerinin EXT2, EXT3, EXT4 biçiminde varyasyonları 
    vardır. Bugünkü Linux sistemlerinde en çok EXT4 dosya sistemi kullanılmaktadır. Apple firması yine i-node tabanlı HFS 
    (Hierarchical File System), HFS+ (Hierarchical File System Plus) ve APFS (Apple File System) isimli dosya sistemlerini 
    kullanmaktadır. Bunlar da aile olarak birbirlerine çok benzemektedir. Bugünkü macOS sistemlerinde genellikle HFS+ 
    ya da APFS dosya sistemleri kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                22/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi UNIX/Linux sistemlerinde Windows sistemlerinde olduğu gibi "sürücü (drive)" kavramı yoktur. Dosya sisteminde
    tek bir "kök dizin (root directory)" vardır. Eğer biz bir dosya sistemine erişmek istiyorsak önce onu belli bir dizinin
    üzerine "mount" ederiz. Artık o dosya sisteminin kökü mount ettiğimiz dizin üzerinde bulunur. Örneğin bir flash belleği 
    USB yuvasına taktığımızda Windows'ta o flash bellek bir sürücü olarak gözükmektedir. Ancak Linux sistemlerinde o flash 
    bellek belli bir dizinin altında gözükür. Yani o dizine mount işlemi yapılmaktadır. Bir dosya sistemi bir dizine mount 
    edildiğinde artık o dizin ve onun altındaki dizin ağacı görünmez olur. Onun yerine mount ettiğimiz blok aygıtındaki dosya
    sisteminin kökü görünür.

    Mount işlemi Linux sistemlerinde aslında bir sistem fonksiyonuyla yapılmaktadır. Bu sistem fonksiyonu "libc" kütüphanesinde
    "mount" ismiyle bulunmaktadır. mount fonksiyonunun prototipi şöyledir:

    #include <sys/mount.h>

    int mount(const char *source, const char *target, const char *filesystemtype, 
        unsigned long mountflags, const void *data);

    Fonksiyonun birinci parametresi blok aygıt dosyasının yol ifadesini, ikinci parametre mount dizinini (mount point)
    belirtmektedir. Üçüncü parametre dosya sisteminin türünü almaktadır. Dördüncü parametre mount bayraklarını belirtmektedir. 
    Bu parametre 0 geçilebilir. Son parametre ise dosya sistemi için gerekebilecek ekstra verileri belirtmektedir. Bu parametre 
    de NULL adres geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Dosya
    sisteminin türünün otomatik tespit eden bazı özel fonksiyonlar bulunmaktadır. Örneğin "libmount" kütüphanesi içerisindeki 
    statfs fonksiyonuyla ya da "libblkid" kütüphanesi içerisindeki fonksiyonlarla bunu sağlayabilirsiniz.

    Tabii bu fonksiyonu çağırabilmek için prosesimizin etkin kullanıcı id'sinin 0 olması ya da prosesimizin uygun önceliğe 
    (appropriate privilege) sahip olması gerekir. mount fonksiyonu POSIX standartlarında yoktur. Çünkü işletim sisteminin
    gerçekleştirimine oldukça bağlı bir fonksiyondur. Tabii kullanıcılar mount işlemini bu sistem fonksiyonu yoluyla değil, 
    "mount" isimli kabuk komutuyla yapmaktadır. mount işlemi için elimizde bir blok aygıt sürücüsüne ilişkin aygıt dosyasının
    bulunuyor olması gerekir. Ancak blok aygıt sürücüleri mount edilebilmektedir. Tabii ilgili blok aygıt sürücüsünün sektörleri 
    içerisinde bir dosya sisteminin bulunuyor olması gerekir. mount isimli kabuk komutunun tipik kullanımı şöyledir:

    sudo mount <blok_aygıt_dosyası> <mount_edilecek_dizin>

    Mount edilecek dizine genel olarak İngilizce "mount point" de denilmektedir. Örneğin bilgisayarımıza bir SD kart okuyucu 
    bağlamış olalım. lsblk yaptığımızda şöyle bir görüntüyle karşılaştığımızı varsayalım:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sdb      8:16   1    0B  0 disk
    sdc      8:32   1 14,8G  0 disk
    ├─sdc1   8:33   1   60M  0 part /media/kaan/72FA-ACF3
    └─sdc2   8:34   1 14,8G  0 part /media/kaan/fa57bb30-99ca-4966-8249-6b0c6c4f4d8d
    sdd      8:48   1    0B  0 disk
    sr0     11:0    1 1024M  0 rom

    Burada taktığımız SD kart "sdc" ismiyle gözükmektedir. "/dev/sdc" aygıt dosyası SD kartı bir bütün olarak görmektedir. 
    Bu SD kartın içerisinde iki farklı disk bölümünün oluşturulduğu görülmektedir. Bu disk bölümlerine ilişkin aygıt dosyaları 
    da "/dev/sdc1" ve "/dev/sdc2" dosyalarıdır. Biz "/dev/sdc" aygıtını mount edemeyiz. Çünkü bu aygıt, diski bir bütün olarak 
    görmektedir. Oysa "/dev/sdc1" ve "/dev/sdc2" aygıtlarının içerisinde daha önceden oluşturulmuş olan dosya sistemleri vardır. 
    Biz bu aygıtları mount edebiliriz. Mount işlemi için sistem yöneticisinin bir dizin oluşturması gerekir. Mount işlemleri 
    için Linux sistemlerinde kök dizinin altında bir "mnt" dizini oluşturulmuş durumdadır. Yani mount edilecek dizini bu dizinin 
    altında yaratabilirsiniz. Tabii böyle bir zorunluluk yoktur. Biz bulunduğumuz dizinde boş bir dizin yaratıp bu dizini 
    mount point olarak kullanabiliriz. Örneğin:

    $ sudo mount /dev/sdc1 mydisk

    mount komutu ilgili blok aygıtındaki dosya sistemini otomatik olarak tespit etmeye çalışır. Genellikle bu tespit otomatik 
    yapılabilmektedir. Ancak bazı özel aygıtlar ve dosya sistemleri için bu belirlemenin açıkça yapılması gerekebilir. Bunun 
    için mount komutunda "-t <dosya_sisteminin_türü> seçeneği kullanılır. Örneğin:

    $ sudo mount -t vfat /dev/sdc1 mydisk

    Burada -t seçeneğine argümanı olarak aşağıdaki gibi dosya sistemleri kullanılabilir:

    ext2
    ext3
    ext4
    ntfs
    vfat
    tmpfs
    xfs
    ...

    Dosya sisteminin otomatik belirlenmesi mount sistem fonksiyonu tarafından yapılmaktadır. mount komutu birtakım işlemlerle
    bunu sağlamaktadır.

    Mount edilmiş olan bir blok aygıtının mount işlemi umount isimli sistem fonksiyonuyla kaldırılabilir. Fonksiyonun prototipi 
    şöyledir:

    #include <sys/mount.h>

    int umount(const char *target);

    Fonksiyon mount dizinini parametre olarak almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri 
    döner. Artık umount yapıldıktan sonra mount point dizinin içeriğine yeniden erişilebilmektedir. Unmount işlemi de yine komut 
    satırından "umount" komutuyla yapılabilmektedir. Komutun genel biçimi şöyledir:

    $ sudo umount <mount_dizini ya da blok_aygıt_dosyası>

    Örneğin:

    $ sudo umount mydisk

    Pek çok UNIX türevi sistemde olduğu gibi Linux sistemlerinde de "otomatik mount" mekanizması bulunmaktadır. Sistem boot
    edildiğinde konfigürasyon dosyalarından hareketle otomatik mount işlemleri yapılabilmektedir. USB aygıtları genel olarak 
    zaten otomatik mount işlemi oluşturmaktadır. "systemd" init sisteminde "mount unit" dosyaları ile otomatik mount işlemleri
    yönetilebilmektedir. Klasik "system5" init sistemlerinde çekirdek yüklendikten sonra "/etc/fstab" dosyasında otomatik 
    mount edilecek blok aygıtları belirtilebilmektedir. "/etc/fstab" dosyasına "systemd" tarafından da açılış sırasında 
    bakılmaktadır.

    Aşağıda mount sistem fonksiyonu çağrılarak mount işlemi yapan bir örnek verilmiştir. Programı aşağıdakine benzer biçimde 
    çalıştırabilirsiniz:

    $ sudo ./mymount /dev/sdc1 mydisk vfat
---------------------------------------------------------------------------------------------------------------------------*/

/* mymount.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mount.h>

void exit_sys(const char *msg);

/* mymount <device> <mount_point> <filesystem_type> */

int main(int argc, char *argv[])
{
    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (mount(argv[1], argv[2], argv[3], 0, NULL) == -1)
        exit_sys("mount");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir dosyayı sanki blok aygıtı gibi gösteren hazır aygıt sürücüler bulunmaktadır. Bunlara "loop" aygıt 
    sürücüleri denilmektedir. Bu aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini içerisinde "loopN" ismiyle (burada N bir 
    sayı belirtiyor) bulunmaktadır. Örneğin:

    $ ls -l /dev/loop*
    brw-rw---- 1 root disk  7,   0 Haz  4 22:31 /dev/loop0
    brw-rw---- 1 root disk  7,   1 Haz  4 22:31 /dev/loop1
    brw-rw---- 1 root disk  7,   2 Haz  4 22:31 /dev/loop2
    brw-rw---- 1 root disk  7,   3 Haz  4 22:31 /dev/loop3
    brw-rw---- 1 root disk  7,   4 Haz  4 22:31 /dev/loop4
    brw-rw---- 1 root disk  7,   5 Haz  4 22:31 /dev/loop5
    brw-rw---- 1 root disk  7,   6 Haz  4 22:31 /dev/loop6
    brw-rw---- 1 root disk  7,   7 Haz  4 22:31 /dev/loop7
    crw-rw---- 1 root disk 10, 237 Haz  4 22:31 /dev/loop-control

    Bir dosyayı blok aygıt sürücüsü biçiminde kullanabilmek için önce "losetup" programı ile bir hazırlık işleminin yapılması 
    gerekir. Hazırlık işleminde "loop" aygıt sürücüsüne ilişkin aygıt dosyası ve blok aygıt sürücüsü olarak gösterilecek dosya 
    belirtilir. Bu işlemin sudo ile yapılması gerekmektedir. Örneğin:

    $ sudo losetup /dev/loop0 mydisk.dat

    Tabii bizim burada "mydisk.dat" isimli bir dosyaya sahip olmamız gerekir. İçi 0'larla dolu 100 MB'lik böyle bir dosyayı
    dd komutuyla aşağıdaki gibi oluşturabiliriz:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada artık "/dev/loop0" aygıt dosyası adeta bir disk gibi kullanılabilir hale gelmiştir. Biz bu "/dev/loop0" dosyasını 
    kullandığımızda bu işlemlerden aslında "mydisk.dat" dosyası etkilenecektir.

    Sıfırdan bir diske ya da bir disk bölümüne bir dosya sistemi yerleştirebilmek için onun formatlanması gerekir. UNIX/Linux
    sistemlerinde formatlama için "mkfs.xxx" isimli programlar bulundurulmuştur. Örneğin aygıtta FAT dosya sistemi oluşturmak 
    için "mkfs.fat" programı, ext4 dosya sistemi oluşturmak için "mkfs.ext4" programı kullanılmaktadır. Örneğin biz yukarıda
    oluşturmuş olduğumuz "/dev/loop" aygıtını ext2 dosya sistemi ile aşağıdaki gibi formatlayabiliriz:

    $ sudo mkfs.ext2 /dev/loop0

    Burada işlemden aslında "mydisk.dat" dosyası etkilenmektedir. Artık formatladığımız aygıta ilişkin dosya sistemini aşağıdaki 
    gibi mount edebiliriz:

    $ mkdir mydisk
    $ sudo mount /dev/loop0 mydisk

    Loop aygıtının dosya ile bağlantısını kesmek için "losetup" programı "-d" seçeneği ile çalıştırılır. Tabii önce aygıtın 
    kullanımdan düşürülmesi gerekir:

    $ sudo umount mydisk
    $ sudo losetup -d /dev/loop0

    Eğer loop aygıt sürücüsünün bir dosyayı onun belli bir offset'inden itibaren kullanmasını istiyorsak losetup programında
    "-o (ya da "--offset") seçeneğini kullanmalıyız. Örneğin bir disk imajının içerisindeki Linux dosya sisteminin disk imajının 
    8192'inci sektöründen başladığını varsayalım. "dev/loop0" aygıt sürücüsünün bu imaj dosyasını bu offset'ten itibaren 
    kullanmasını şöyle sağlayabiliriz:

    $ sudo losetup -o 4194304 /dev/loop0 am335x-debian-11.7-iot-armhf-2023-09-02-4gb.img

    512 * 8192 = 4194304 olduğuna dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                27/09/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda önce FAT dosya sisteminden bahsedeceğiz sonra UNIX/Linux sistemlerindeki i-node tabanlı EXT dosya sistemleri
    üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemi Microsof tarafından DOS işletim sistemi için geliştirilmiştir. Ancak bu dosya sistemi hala kullanılmaktadır. 
    FAT dosya sistemi o zamanlar teknolojisiyle tasarlanmıştır. Dolayısıyla modern dosya sistemlerinde bulunan bazı özellikler 
    bu dosya sisteminde bulunmamaktadır. FAT dosya sistemi kendi aralarında FAT12, FAT16 ve FAT32 olmak üzere üç gruba ayrılmaktadır.
    Bu sistemlerin arasındaki en önemli fark dosya sistemi içerisindeki FAT (File Allocation Table) denilen tablodaki elemanların
    uzunluklarıdır. FAT12'de FAT elemanları 12 bit, FAT16'da 16 bit ve ve FAT32'de 32 bittir. Microsoft, Windows sistemlerine
    geçtiğinde bu FAT sistemini biraz revize etmiştir. Buna da VFAT denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir disk ya da disk bölümü (Disk Partition) FAT dosya sistemiyle formatlandığında disk bölümünde dört mantıksal bölüm 
    oluşturulmaktadır:

    1) Boot Sektör
    2) FAT Bölümü
    3) Root Dir Bölümü
    4) Data Bölümü

    Bir dosya sisteminin içi boş bir biçimde kullanıma hazır hale getirilmesi sürecine formatlama denilmektedir. Formatlama 
    sırasında ilgili disk ya da disk bölümünde ilgili dosya sistemi için meta data alanlar oluşturulmaktadır.

    Windows'ta ilgili disk ya da disk bölümünü FAT dosya sistemiyle formatlamak için "Bilgisayar Yönetimi / Disk Yönetimi" 
    kısmından ilgili disk bölümü seçilir ve farenin sağ tuşuna basılarak formatlama yapılır. Benzer biçimde formatlama 
    "Bilgisayarım (My Computer)" açılarak orada ilgili disk bölümünün üzerine sağa tıklanarak da yapılabilmektedir.

    Linux sistemlerinde bir blok aygıt sürücüsü ya da doğrudan bir dosya "mkfs.fat" programıyla formatlanabilir. Biz yukarıda 
    da belirttiğimiz gibi bir dosyayı sanki disk gibi kullanacağız. Örneğin "dd" programıyla 50MB'lik içi sıfırlarla dolu 
    bir dosya oluşturalım:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada 512 * 100000 byte'lık (yaklaşık 50 MB) içi sıfırlarla dolu bir dosya oluşturulmuştur. Bu dosyayı "/dev/loop0" 
    blok aygıt sürücüsü biçiminde kullanılabilmesi şöyle sağlanabilir:

    $ sudo losetup /dev/loop0 mydisk.dat

    Şimdi artık "mkfs.fat" programı ile formatlamayı yapabiliriz. Yukarıda FAT'in FAT12, FAT16 ve FAT32 olmak üzere üç 
    türünün olduğunu belirtmiştik. FAT türü "mkfs.fat" programında -F12, -F16 ya da -F32 seçenekleriyle belirtilmektedir. 
    Örneğin biz blok aygıtımızı FAT16 biçiminde şöyle formatlayabiliriz:

    $ sudo mkfs.fat -F16 /dev/loop0

    Aslında "mkfs.xxx" programları blok aygıt dosyası yerine normal bir dosya üzerinde de formatlama yapabilmektedir. Tabii 
    biz kursumuzda bir blok aygıtı oluşturup onu mount edeceğiz. Şimdi biz FAT16 olarak formatladığımız "/dev/loop0" blok 
    aygıtını mount edebiliriz. Tabii bunun için önce bir "mount dizininin (mount point)" oluşturulması gerekmektedir:

    $ mkdir fat16
    $ sudo mount /dev/loop0 fat16

    Artık fat16 dizini oluşturduğumuz FAT dosya sisteminin kök dizinidir. Ancak bu dosya sisteminin tüm bilgileri "mydisk.dat"
    dosyasında bulundurulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemiyle formatlanmış olan bir diskin ya da disk bölümünün ilk sektörüne "Boot Sector" denilmektedir. Dolayısıyla 
    boot sektör ilgili diskin ya da disk bölümünün mantıksal 0 numaralı sektöründedir. Boot sektör isminden de anlaşılacağı 
    gibi 512 byte uzunluğundadır. Bu sektörün iç organizasyonu şöyledir:

    Jmp Kodu | BPB (BIOS Parameter Block) | DOS Yükleyici Programı | 55 AA

    Boot sektörün hemen başında Intel Mimarisinde BPB bölümünü atlayarak DOS işletim sistemini yükleyen yükleyici program 
    için bir jmp komutu bulunmaktadır. Bugün artık DOS işletim sistemi kullanılmadığı için buradaki jmp kodun ve yükleyici 
    programın bir işlevi kalmamıştır. Ancak BPB alanı eskiden olduğu yerdedir ve dosya sistemi hakkında kritik bilgiler bu 
    bölümde tutulmaktadır. Sektörün başındaki Jmp Code tipik olarak "EB 3C 90" makine komutundan oluşmaktadır. Bazı kaynaklar 
    bu jmp kodu da BPB alanına dahil etmektedir. Eğer dosya sisteminde yüklenecek bir DOS işletim sistemi yoksa buradaki 
    yükleyici program yerine format programı buraya ekrana mesaj çıkartan küçük program kodu yerleştirmektedir. Aşağıda 
    "mkfs.fat" programı ile FAT16 biçiminde formatlanan FAT dosya sisteminin boot sektör içeriği görülmektedir:

    $ hexdump -C mydisk.dat -n 512 -v

    00000000  eb 3c 90 6d 6b 66 73 2e  66 61 74 00 02 04 04 00  |.<.mkfs.fat.....|
    00000010  02 00 02 00 00 f8 64 00  20 00 08 00 00 00 00 00  |......d. .......|
    00000020  a0 86 01 00 80 01 29 fa  0b 93 c5 4e 4f 20 4e 41  |......)....NO NA|
    00000030  4d 45 20 20 20 20 46 41  54 31 36 20 20 20 0e 1f  |ME    FAT16   ..|
    00000040  be 5b 7c ac 22 c0 74 0b  56 b4 0e bb 07 00 cd 10  |.[|.".t.V.......|
    00000050  5e eb f0 32 e4 cd 16 cd  19 eb fe 54 68 69 73 20  |^..2.......This |
    00000060  69 73 20 6e 6f 74 20 61  20 62 6f 6f 74 61 62 6c  |is not a bootabl|
    00000070  65 20 64 69 73 6b 2e 20  20 50 6c 65 61 73 65 20  |e disk.  Please |
    00000080  69 6e 73 65 72 74 20 61  20 62 6f 6f 74 61 62 6c  |insert a bootabl|
    00000090  65 20 66 6c 6f 70 70 79  20 61 6e 64 0d 0a 70 72  |e floppy and..pr|
    000000a0  65 73 73 20 61 6e 79 20  6b 65 79 20 74 6f 20 74  |ess any key to t|
    000000b0  72 79 20 61 67 61 69 6e  20 2e 2e 2e 20 0d 0a 00  |ry again ... ...|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Burada yükleyici programın DOS olmaması durumunda ekrana yazdırdığı mesaj görülmektedir. Tabii bu mesajın çıkması için
    bu diskin ya da disk bölümünün aktif disk ya da aktif disk bölümü olması gerekir. Yani bu diskten ya da disk bölümünde 
    boot etme girişimi olmadıktan sonra bu mesaj görülmeyecektir.

    FAT dosya sisteminin en önemli meta data bilgileri boot sektörün hemen başındaki BPB (Bios Parameter Block) alanında 
    tutulmaktadır. Bu bölümün bozulması durumunda dosya sistemine erişim mümkün olamamaktadır. Başka bir deyişle bu dosya 
    sisteminin bozulmasını sağlamak için tek yapılacak şey bu BPB alanındaki byte'ları sıfırlamaktır. Tabii zamanla FAT dosya
    sistemindeki diğer bölümleri inceleyerek bozulmuş olan BPB alanını onaran yardımcı araçlar da çeşitli kişiler ve kurumlar 
    tarafından geliştirilmiştir.

    Boot sektörün sonunda "55 AA" değeri bulunmaktadır. Bu bir sihirli sayı (magic number) olarak bulundurulmaktadır. Bazı 
    programlar ve bazı boot loader'lar kontrolü boot sektöre bırakmadan önce bu sihirli sayıyı kontrol edebilmektedir. Böylece
    rastgele bozulmalarda bu sihirli sayı da bozulacağı için yetersiz olsa da basit bir kontrol mekanizması oluşturulabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                29/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                06/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde en önemli kısım şüphesiz "BPB (BIOS Parameter Block)" denilen kısımdır. BPB hemen boot sektörün 
    başındadır ve FAT dosya sisteminin diğer bölümleri hakkında kritik bilgiler içermektedir. Tabii BPB bölümü 1980'lerin 
    anlayışıyla tasarlanmıştır. Bu tasarımda hatalar DOS'un çeşitli versiyonlarında geçmişe doğru uyumu koruyarak giderilmeye
    çalışılmıştır. Biz burada önce FAT12 ve FAT16 sistemlerinde kullanılan BPB bloğunun içeriğini tek tek ele alacağız. FAT32
    ile birlikte BPB bloğuna eklemeler de yapılmıştır. FAT32 BPB formatını daha sonra ele alacağız.

    Aşağıda FAT12 ve FAT16 sistemlerindeki BPB bloğunun formatı açıklanmaktadır. Tablodaki Offset sütunu Hex olarak ilgili 
    alanın Boot sektörün başından itibaren kaçıncı byte'tan başladığını belirtmektedir.

    Offset (Hex)        Uzunluk             Anlamı
    00                  3 Byte              Jmp Kodu
    03                  8 Byte              OEM Yorum Alanı
    0B                  WORD                Sektördeki Byte Sayısı
    0C                  BYTE                Cluster'daki Sektör Sayısı
    0E                  WORD                Ayrılmış Sektörlerin Sayısı
    10                  BYTE                FAT Kopyalarının Sayısı
    11                  WORD                Kök Dizinlerindeki Girişlerin Sayısı
    13                  WORD                Toplam Sektör Sayısı (Eski)
    15                  BYTE                Ortam Belirleyicisi (Media Descriptor)
    16                  WORD                FAT'in Bir Kopyasındaki Sektör Sayısı
    18                  WORD                Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor)
    1A                  WORD                Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor)
    1C                  DWORD               Saklı Sektörlerin Sayısı
    20                  DWORD               Yeni Toplam Sektör Sayısı
    24                  3 Byte              Reserved
    27                  DWORD               Volüm Seri Numarası
    2B                  11 Byte             Volüm İsmi

    - Jump Kodu: Yukarıda da belirttiğimiz gibi BPB bloğunu geçerek yükleyici programa atlayan makine komutlarından oluşmaktadır. 
    Boot loader programlar akışı buradan boot sektöre devretmektedir. Dolayısıyla BPB alanının atlanması gerekmektedir. Burada
    bazen Intel short jump bazen de near jump komutları bulunur. Tipik içerik "EB 3C 90" biçimindedir.

    - OEM Yorum Alanı: Formatlama programının kendine özgü yazdığı 8 byte'lık küçük yazıdır. Buraya eskiden DOS işletim sisteminin 
    versiyon numarası yazılıyordu. Örneğin Windows bu BPB alanın yeni biçiminin tanındığı en eski sistem olan "MSDOS5.0" 
    yazısını buraya yerleştirmektedir. Ancak buraya yerleştirilen yazı herhangi bir biçimde kullanılmamaktadır.

    - Sektördeki Byte Sayısı: Bir sektörde kaç byte olduğu bilgisi burada tutulmaktadır. Tabii bu değer hemen her zaman 512'dir.
    Yani Little Endian formatta hex olarak burada "00 02" değerlerini görmemiz gerekir.

    - Cluster'daki Sektör Sayısı: Dosyaların parçaları disk üzerinde ardışıl bir biçimde konumlandırılmak zorunda değildir. 
    FAT dosya sisteminde bir dosyanın hangi parçasının diskte nerede konumlandırıldığı FAT (File Allocation Table) denilen 
    bir bölümde saklanmaktadır. Eğer bir dosya çok fazla parçaya ayrılırsa hem disk üzerinde daha çok yayılmış olur hem de FAT
    bölümünde bu dosyanın parçalarının yerini tutmak için gereken alan büyür. Bu nedenle dosyaların parçaları sektörlere değil,
    cluster denilen birimlere bölünmüştür. Bir cluster ardışıl n tane sektörün oluşturduğu topluluktur. Örneğin bir cluster'ın
    4 sektör olması demek 4 sektörden oluşması (yani 2K) demektir. Şimdi elimizde 10,000 byte uzunluğunda bir dosya olsun. Bir 
    cluster'ın 1 sektör olduğunu düşünelim. Bu durumda bu 10,000 byte'lık dosya toplamda 10000 / 512 = 19.53125 yani 20 cluster
    yer kaplayacaktır. FAT bölümünde bu 20 cluster 20 elemanlık yer kaplayacaktır. Şimdi bir cluster'ın 4 sektörden oluştuğunu 
    düşünelim. Bu durumda 10,000 byte'lık dosya 10000 / 2048 = 4.8828125 yani 5 cluster yer kaplayacaktır. Bu dosyanın yerini 
    tutmak için FAT bölümünde 5 eleman yeterli olacaktır. Görüldüğü gibi cluster bir dosyanın bir parçasını tutabilen en düşük
    tahsisat birimidir. Halbuki sektör diskten transfer edilecek en küçük birimdir. Sektör yerine dosya sisteminin cluster kavramını
    kullanmasının iki nedeni vardır. Birincisi cluster ardışıl sektörlerden oluştuğu için dosyanın parçaları diskte daha az
    yayılmış olur. İkincisi de dosyanın parçalarının yerlerini tutmak için daha az alan gerekmektedir.

    Pekiyi bir cluster kaç sektörden oluşmalıdır? Eğer bir cluster çok fazla sayıda sektörden oluşursa dosyanın son parçasında 
    kullanılmayan alan (buna "içsel bölünme (internal fragmentation)" da denilmektedir) fazlalaşır diskin kullanım kapasitesi 
    azalmaya başlar. Örneğin bir cluster'ın 32 sektörden (16K) oluştuğunu varsayalım. Bu durumda 1 byte'lık bir dosya bile 
    16K yer kaplayacaktır. Çünkü dosya sisteminin minimum tahsisat birimi 16K'dır. Örneğin bir sistemde 100 tane 1 byte'lık 
    dosyanın diskte kapladığı alanla 1 tane 100 byte'lık dosyanın diskte kapladığı alan kıyaslandığında 100 tane 1 byte'lık 
    dosyanın diskte çok daha fazla yer kapladığı görülecektir. İşte UNIX/Linux sistemlerinde dosyaları tek bir dosyada peşi 
    sıra birleştiren ve bunların yerlerini dosyanın başındaki bir başlık kısmında tutan "tar" isimli bir yardımcı program 
    bulunmaktadır. "tar" programının bir sıkıştırma yapmadığına diskteki kaplanan alanı azaltmak için yalnızca dosyaları 
    uç uca eklediğine dikkat ediniz. Tabii genellikle dosyalar tar'landıktan sonra ayrıca sıkıştırılabilir. Bu sistemlerdeki 
    "tar.gz" gibi dosya uzantıları tar'landıktan sonra zip'lenmiş olan dosyaları belirtmektedir. Pekiyi o halde bir cluster'ın
    kaç sektör olacağına nasıl karar verilmektedir? İşte sezgisel olarak disk hacmi büyüdükçe kaybedilen alanların önemi 
    azalacağı için cluster'ın çok sektörden oluşturulması, disk hacmi azaldıkça az sektörden oluşturulması yoluna gidilmektedir. 
    Format programları bu değerin kullanıcı tarafından belirlenmesine olanak sağlamakla birlikte default değer de önermektedir. 
    Linux'taki "mkfs.fat" programında ise cluster boyutu "-s" seçeneği ile belirlenmektedir. Örneğin:

    $ sudo mkfs.fat -F16 -s 2 /dev/loop0

    Burada bir cluster 2 sektörden oluşturulmuştur.

    İşte BPB bloğunun "0C" offset'inde bir cluster'ın kaç sektörden oluştuğu bilgisi yer almaktadır. İşletim sistemi dosyaların 
    parçalarına erişirken hep bu bilgiyi kullanmaktadır. (Burada değeri disk editörü ile değiştirsek dosya sistemi tamamen 
    saçmalayacaktır.) Yukarıdaki örnek boot sektörde bir cluster 4 sektörden (yani 4K = 2048 byte'tan) oluşmaktadır.

    Ayrılmış Sektörlerin Sayısı: Burada boot sektörü izleyen FAT bölümünün kaçıncı sektörden başladığı bilgisi yer almaktadır. 
    Tabii buradaki orijin FAT disk bölümünün başıdır. Yani boot sektör 0'ıncı sektörde olmak üzere FAT bölümünün kaçıncı sektörden
    başladığını belirtmektedir. Pekiyi neden boot sektör ile FAT arasında boşluk bırakmak gerekebilir? İşte hard disklerde 
    işletim sistemi FAT bölümünü ilk silindire hizalamak isteyebilir. Eğer özel uygulamalarda boot sektör yükleyici programı
    uzunsa yükleyicinin diğer parçaları da burada bulunabilmektedir. Yukarıdaki örnek FAT bölümünün boot sektöründe bu byte'lar
    "04 00" biçimindedir. Little Endian formatta bu değer 4'tür. O halde bu dosya sisteminde FAT bölümü 4'üncü sektörden 
    başlamaktadır.

    FAT Kopyalarının Sayısı: FAT bölümü izleyen paragraflarda da görüleceği gibi FAT dosya sisteminin önemli bir meta-data 
    alanıdır. Bu nedenle bu bölümün backup amaçlı birden fazla kopyasının bulundurulması uygun görülmüştür. Tipik olarak bu 
    alanda 2 değeri bulunur. Yani FAT bölümünün toplamda iki kopyası vardır. FAT bölümünün kopyaları hemen birbirinin peşi 
    sıra dizilmiştir. Yani bir kopyanın bittiği yerde diğeri başlamaktadır.

    Kök Dizinlerindeki Girişlerin Sayısı: FAT dosya sistemindeki bölümlerin dizilimin şöyle olduğunu belirtmiştik:

    Boot Sektör
    FAT ve Kopyaları
    Root Dir Bölümü
    Data Bölümü

    İşletim sisteminin tüm bölümlerin hangi sektörden başladığını ve kaç sektör uzunlukta olduğunu bilmesi gerekir. İşte 
    "Root Dir" bölümü dizin girişlerinden oluşmaktadır. Bir dizin girişi 32 byte uzunluğundadır. Burada toplam kaç giriş 
    olduğu belirtilmektedir. Dolayısıyla "Root Dir" bölümünün sektör uzunluğu buradaki sayının 32'ye bölümü ile hesaplanır. 
    Bizim oluşturduğumuz örnek FAT16 disk bölümünde burada "0x0200" (512) değeri bulunmaktadır. Bu durumda Root Dir bölümünün
    sektör uzunluğu 512 / 32 = 16'dır.

    Toplam Sektör Sayısı (Eski): Bu alanda disk bölümündeki toplam sektör sayısı bulundurulmaktadır. Ancak BPB formatının 
    tasarlandığı 1980'lerin başında henüz hard diskler çok yeniydi ve teknolojinin bu kadar hızlı gelişeceği düşünülmemişti.
    Dolayısıyla toplam sektör sayısı için 2 byte'lık yer o zamanlar için yeterli gibiydi. Toplam sektör sayısı için ayrılan 
    2 byte'lık yerde yazılabilecek maksimum değer 65535'tir. Bu değeri 512 ile çarparsak 33MB'lık bir alan söz konusu olur. 
    Gerçekten de o devirlerde diskler 33MB'den daha yukarıda formatlanamıyordu. DOS 4.01'e kadar 33MB bir üst sınırdı. Ancak 
    DOS 4.01 ile birlikte bu toplam sektör sayısı geçmişe doğru uyum korunarak 4 byte yükseltildi. Dolayısıyla DOS 4.01 ve 
    sonrasında artık disk bölümünün toplam kapasitesi 2^32 * 2^9 = 2TB'ye yükselmiş oldu. 4 byte'tan oluşan yeni toplam sektör
    sayısı alanı boot sektörün "0x20" offset'inde bulunmaktadır. Dosya sistemleri toplam sektör sayısı için önce "0x13" offset'inde 
    bulunan bu alana başvurmaktadır. Eğer bu alanda 0 yoksa bu alandaki bilgiyi, eğer bu alanda 0 varsa "0x20" offset'inden çekilen 
    DWORD bilgiyi dikkate almaktadır.

    - Ortam Belirleyicisi (Media Descriptor): Bu alanda dosya sisteminin konuşlandığı medyanın türünün ne olduğu bilgisi bulunmaktadır. 
    Aslında artık böyle bir bilgi işletim sistemleri tarafından kullanılmamaktadır. Buradaki 1 byte'ın yaygın değerleri şunlardır:

    0xF0: 1.44 Floppy Disk
    0xF8: Hard disk

    Bu alanda artık hep F8 byte'ı bulunmaktadır.

    FAT'in Bir Kopyasındaki Sektör Sayısı: Bu alanda FAT'in bir kopyasının kaç sektör uzunluğunda olduğu bilgisi bulunmaktadır.
    FAT'in default olarak 2 kopyasının olduğunu anımsayınız.

    Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor): Bu alanda diskin bir yüzeyinde kaç sektör dilimi olduğu 
    bilgisi yer almaktadır. Eskiden sektörlerin koordinatları "yüzey numarası, track numarası ve sektör dilimi numarası"
    ile belirtiliyordu. Uzunca bir süredir artık bu sistem terk edilmiştir. Dolayısıyla bu alana başvurulmamaktadır.

    Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor): Burada diskte toplam kaç yüzey (kafa) olduğu bilgisi yer 
    alıyordu. Ancak yine koordinat sistemi uzunca bir süre önce değiştirildiği için bu alan artık kullanılmamaktadır.

    Saklı Sektörlerin Sayısı: Bu alanda FAT dosya sisteminin diskin toplamda kaçıncı sektöründen başladığı bilgisi yer 
    almaktadır. Bu bilgi aynı zamanda Disk Bölümleme Tablosu (Disk Partition Table) içerisinde de yer almaktadır. İşletim 
    sistemleri bu iki değeri karşılaştırıp BPB bloğunun bozuk olup olmadığı konusunda bir karar da verebilmektedir.

    Yeni Toplam Sektör Sayısı: "0x13" offset'indeki WORD olarak bulundurulan eski "toplam sektör sayısı" bilgisinin DWORD olarak
    yenilenmiş biçimi bu alanda tutulmaktadır.

    Volüm Seri Numarası: Bir disk bölümü FAT dosya sistemi ile formatlandığında oraya rastgele üretilmiş olan bir "volüm seri 
    numarası" atanmaktadır. Bu volüm seri numarası eskiden floppy disket zamanlarında disketin değişip değişmediğini anlamak 
    için kullanılıyordu. Bugünlerde artık bu alan herhangi bir amaçla kullanılmamaktadır. Ancak sistem programcısı bu seri 
    numarasından başka amaçlar için faydalanabilir.

    Volüm İsmi: Her volüm formatlanırken ona bir isim verilmektedir. Bu isim o zamanki dosya isimlendirme kuralı gereği 
    8 + 3 = 11 karakterden oluşmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            11/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemine ilişkin bir uygulama yazabilmek için yapılacak ilk şey boot sektörü okuyup buradaki BPB bilgilerini 
    bir yapı nesnesinin içerisine yerleştirmektir. Bu bilgilerden hareketle bizim FAT dosya sistemine ilişkin meta data 
    alanlarının ilgili disk bölümünün kaçıncı sektöründen başlayıp kaç sektör uzunluğunda olduğunu elde etmemiz gerekir. Çünkü
    dosya sistemi ile ilgili işlemlerin hepsinde bu bilgilere gereksinim duyulacaktır. Bu bilgilerin yerleştirileceği yapı 
    şöyle olabilir:

    typedef struct tagBPB {
        uint16_t fatlen;        /* Number of sectors in FAT (A) */
        uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
        uint16_t nfats;            /* Number of copies of FAT (A) */
        uint32_t tsects;        /* Total sector (A) */
        uint16_t bps;            /* Byte per sector(A) */
        uint16_t spc;            /* Sector per cluster(A) */
        uint16_t rsects;        /* Reserved sectors(A) */
        uint8_t mdes;            /* Media descriptor byte(A) */
        uint16_t spt;            /* Sector per track(A) */
        uint16_t rootents;        /* Root entry (A) */
        uint16_t nheads;        /* Number of heads (A) */
        uint16_t hsects;        /* Number of hidden sector( A) */
        uint16_t tph;            /* Track per head (NA) */
        uint16_t fatloc;        /* FAT directory location (NA) */
        uint16_t rootloc;        /* Root directory location (NA) */
        uint16_t dataloc;        /* First data sector location (NA) */
        uint32_t datalen;        /* Number of sectors in Data (NA) */
        uint32_t serial;        /* Volume Serial Number (A) */
        char vname[12];            /* Volume Name (A) */
    } BPB;

    Burada (A) ile belirtilen elemanlar zaten BPB içerisinde olan (available) elemanlardır. NA (not available) ile belirtilen 
    elemanlar BPB içerisinde yoktur. Dört işlemle hesaplanarak değeri oluşturulacaktır. Linux'ta boot sektör'ü okuyarak oradaki
    BPB bilgilerini yukarıdaki gibi bir yapıya yerleştiren örnek bir program aşağıda verilmiştir. Derlemeyi şöyle yapabilirsiniz:

    $ gcc -o app fatsys.c app.c

    Programı FAT dosya sistemine ilişkin blok aygıt dosyasının yol ifadesini vererek sudo ile çalıştırabilirsiniz. Örneğin:

    $ sudo ./app /dev/loop0

    Aşağıdakine benzer bir çıktı elde edilecektir:

    Byte per sector: 512
    Sector per cluster: 4
    Number of reserved sectors: 4
    Number of FAT copies: 100
    Number of sectors in Root Dir: 32
    Number of FAT copies: 2
    Number of sectors in volume: 100000
    Media Descriptor: F8
    Number of Root Dir entries: 200
    Number of hidden sectors: 0
    FAT location: 4
    Root Dir location: 204
    Data location: 236
    Volume Serial Number: BC7B-4578
    Volume Name: FAT16
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    BPB bpb;
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

     if ((fd = open(argv[1], O_RDWR)) == -1)
        return -1;

    if (read_bpb(fd, &bpb) == -1)
        exit_sys("read_bpb");

    printf("Byte per sector: %d\n", bpb.bps);
    printf("Sector per cluster: %d\n", bpb.spc);
    printf("Number of reserved sectors: %d\n", bpb.rsects);
    printf("Number of FAT copies: %d\n", bpb.fatlen);
    printf("Number of sectors in Root Dir: %d\n", bpb.rootlen);
    printf("Number of FAT copies: %d\n", bpb.nfats);
    printf("Number of sectors in volume: %u\n", bpb.tsects);
    printf("Media Descriptor: %02X\n", bpb.mdes);
    printf("Number of Root Dir entries: %02X\n", bpb.rootents);
    printf("Number of hidden sectors: %d\n", bpb.hsects);
    printf("FAT location: %d\n", bpb.fatloc);
    printf("Root Dir location: %d\n", bpb.rootloc);
    printf("Data location: %d\n", bpb.dataloc);
    printf("Number of sectors in Data: %d\n", bpb.datalen);
    printf("Volume Serial Number: %04X-%04X\n", bpb.serial >> 16, 0xFFFF & bpb.serial);
    printf("Volume Name: %s\n", bpb.vname);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örnekte FAT dosya sistemine ilişkin tüm önemli alanların yerlerine ve uzunluklarına ilişkin bilgileri 
    elde ederek bir yapıya yerleştirdik. Artık şu bilgilere sahibiz:

    - FAT bölümünün yeri ve uzunluğu (yapının fatloc ve fatlen elemanları)
    - Root DIR bölümünün yeri ve uzunluğu (yapının rootloc ve rootlen elemanları)
    - Data bölümünün yeri ve uzunluğu (yapının dataloc ve datalen elemanları)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            13/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi yukarıdaki yapıp biraz daha geliştirelim. Bunun için dosya sistemini temsil eden aşağıdaki gibi bir yapı oluşturabiliriz:

    typedef struct tagFATSYS {
        int fd;             /* Volume file descriptor */
        BPB bpb;            /* BPB info */
        uint32_t fatoff;    /* Offset of FAT */
        uint32_t rootoff;   /* Offset of root directory */
        uint32_t dataoff;   /* Offset of DATA */
        uint32_t clulen;    /* Cluster length as bytes */
        /* ... */
    } FATSYS;

    Dosya işlemi yaparken dosya sisteminin belirli bölümlerine konumlandırma yapacağımız için onların offset'lerini de FATSYS 
    yapısının içerisine yerleştireceğiz.

    Dosya sistemini açan ve kapatan aşağıdaki fonksiyonlar oluşturabiliriz:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fd = open(path, O_RDWR)) == -1)
            return NULL;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if (read_bpb(fd, &fatsys->bpb) == -1) {
            free(fatsys);
            return NULL;
        }

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        return fatsys;
    }


    int close_fatsys(FATSYS *fatsys)
    {
        if (close(fatsys->fd) == -1)
            return -1;

        free(fatsys);

        return 0;
    }

    Kullanım şöyle olabilir:

    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    Aşağıda bu değişliklerin yapıldığı kodlar verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */


FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde dosya sistemindeki "Data Bölümü" dosya içeriklerinin tutulduğu bölümdür. İşletim sistemi bu bölümün
    sektörlerden değil cluster'lardan oluştuğunu varsaymaktadır. Anımsanacağı gibi "cluster" bir dosyanın parçası olabilecek 
    en küçük tahsisat birimidir ve ardışıl n sektörden olulmaktadır. Buradaki n değeri 2'nin bir kuvvetidir (yani 1, 2, 4, 
    8, ... biçiminde). İşte volümün Data bölümündeki her cluster'a 2'den başlanarak (0 ve 1 reserved bırakılmıştır) bir 
    cluster numarası karşı getirilmiştir. Örneğin bir cluster'ın 4 sektörden oluştuğunu düşünelim. Bu durumda Data bölümünün 
    ilk 4 sektörü 2 numaralı cluster, sonraki 4 sektörü 3 numaralı cluster, sonraki 4 sektörü 4 numaralı cluster biçiminde 
    numaralanmaktadır.

    Bizim FAT dosya sistemi üzerinde ilk yapmaya çalışacağımız alt seviye işlemlerden biri belli bir numaralı cluster'ı okuyup 
    yazan fonksiyonları gerçekleştirmektir. Bu fonksiyonların prototipleri şöyle olabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
    int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

    Data bölümünün ilk cluster'ının 2 numaralı cluster olduğunu 0, 1 cluster'larının kullanılmadığını anımsayınız. Bu 
    fonksiyonlar basit biçimde şöyle yazılabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return read(fatsys->fd, buf, fatsys->clulen);
    }

    int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return write(fatsys->fd, buf, fatsys->clulen);
    }

    Aşağıda fonksiyonun kullanımına ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fstsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        close(fd);
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if (read_cluster(fatsys, 2, buf) == -1)
        exit_sys("read_cluster");

    for (int i = 0; i < fatsys->clulen; ++i)
        printf("%02X%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde her dosya cluster'lara bölünerek Data bölümündeki cluster'larda tutulmaktadır. Dosyanın parçaları
    ardışıl cluster'larda olmak zorunda değildir. Örneğin bir cluster'ın 4 sektör olduğu bir volümde 10000 byte uzunluğunda 
    bir dosya söz konusu olsun. Bir cluster'ın bıyutu 4 * 512 = 2048 byte'tır. O halde bu dosya 5 cluster yer kaplayacaktır. 
    Ancak son cluster'da kullanılmayan bir miktar boş alan da kalacaktır. İşte örneğin bu dosyanın cluster numaraları aşağıdaki
    gibi olabilir:

    2 8 14 15 21

    Görüldüğü gibi dosyanın parçaları ardışıl cluster'larda olmak zorunda değildir. Tabi işletim sistemi genellikle dosyanın 
    parçalarını mümkün olduğu kadar ardışıl cluster'larda saklama çalışır. Ancak bu durum mümkün olmayabilir. Belli bir süre 
    sonra artık dosyaların parçalarını birbirinden uzaklaşmaya başlayabilir. İşte FAT dosya sisteminde hangi dosyanın hangi 
    parçalarının Data bölümünün hangi cluster'larında olduğunun saklandığı meta data alana FAT (File Allocation Table) denilmektedir.

    FAT bölümü FAT elemanlarından oluşur. FAT'lar 12 bit 16 bit ve 32 bit olmak üzere üçe ayrılmaktadır. 12 bit FAT'lerde 
    FAT elemanları 12 bit, 16 bit FAT'lerde FAT elemanları 16 bit ve 32 bit FAT'lerde FAT elemanları 32 bit uzunluğundadır. 
    İlk iki cluster kullanılmadığı için FAT'in ilk elemanı da kullanılmaktadır.

    FAT bağlı listelerden oluşan bir meta data alanıdır. Her dosyanın ilk cluster'ının nerede olduğu dizin girişinde tutulmaktadır. 
    Sonra her FAT elemanı dosyanın ğparçasının hangi cluster'da olduğu bilgisini tıtar. Volümde toplan N tane cluster varsa
    FAT bölümünde de toplam N tane FAT elemanı vardır. FAT bölümünde her bir dosya için ayrı bir bağlı liste bulunmaktadır. 
    Bir dosyanın ilk cluster'ı biliniyorsa sonraki tüm cluster'ları bu bağlı liste izlenerek elde edilebilmektedir. Bağlı 
    listenin organizasyonu şu biçimdedir: Dosyanın ilk cluster'ının yerinin 8 olduğunu varsayalım. Şimdi FAT'in 8'inci 
    elemanına gidildiğinde orada 14 yazıyor olsun. 14 numaralı elemanına gittiğimizde orada 18 yazdığını düşünelim. 18 elemana 
    gittiğimizde orada 22 yadığını düşünelim. Nihayet 22 numaralı elemana gittiğimizde orada FFFF biçiminde özel bir değerin 
    yazdığını varsayalım. Bu durumu şekilsel olarak şöyle gösterebiliriz:

    8 ----> 14 ----> 18 ----> 22 (FFFF)

    Bu durumda bu dosyanın cluster'ları sırasıyla 8 14 18 22 numaralı cluster'lardır. Burada FFFF değeri EOF anlamına özel bir 
    cluster numarasıdır. Yani FAT'teki her FAT elemanı dosyanın sonraki parçasının hangi cluster'da olduğunu belirtmektedir. 
    Böylece işletim sistemi dosyanın ilk cluster numarasını biliyorsa bu zinciri takip ederek onun bütün cluster'larını elde 
    edebilir.

    Örneğin 1 cluster'ın 4 sektör olduğu bir FAT16 sisteminde 19459 byte'lık bir dosya toplam 10 cluster yer kaplamaktadır. 
    Biz bu dosyanın ilk cluster numarasının 4 olduğunu biliyoruz. Aşağıdaki örnek FAT bölümünde bu dosyanın tüm cluster'larının 
    numaraları bağlı liste izlenerek elde edilebilecektir:

    00000800  f8 ff ff ff 00 00 ff ff  05 00 06 00 07 00 08 00  |................|
    00000810  09 00 0a 00 0b 00 0c 00  0d 00 ff ff 00 00 00 00  |................|
    00000820  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000840  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Bu byte'lar bir FAT16 sisteminin FAT bölümüne ilişkin olduğuna göre her bir FAT elemanı 2 byte yer kaplayacaktır. Burada 
    FAT elemanlarının hex karşılıkları şöyledir (Little Endian notasyon kullanıldığına dikkat ediniz):

    0        1      2      3      4      5      6      7      8      9      10     11     12     13
    <FFF8> <FFFF> <0000> <FFFF> <0005> <0006> <0007> <0008> <0009> <000A> <000B> <000C> <000D> <FFFF>

    Burada FAT elemanlarının umaralarını desimal sistemde elemanların yukarısına yazdık. Söz konusu dosyanın ilk cluster 
    numarasının 4 olduğunu bildiğimizi varsayıyoruz. 4 numaralı FAT elemanında 5 (0005) yazmaktadır. O halde dosyanın sonraki 
    cluster numarası 5'tir. 5 numaralı FAT elemanında 6 (0006) yazmaktadır. 6 numaralı FAT elemanında 7 (0007), 7 numaralı FAT 
    elemanında 8 (0008), 8 numaralı FAT elemanında 9 (0009), 9 numaralı FAT elemanında 10 (000A), 10 numaralı FAT elemanında 11 
    (000B), 11 numaralı FAT elemanında 12 (0000D), 12 numaralı FAT elemanında 13 (000D), 13 FAT elemanında da özel değer olan 
    65535 (FFFF) bulunmaktadır. Bu özel değer zinicirin sonuna gelindiğini belirtmektedir. Bu durumda bu dosyanın tüm parçaları 
    sırasıyla şu cluster'lardadır:

    4 5 6 7 8 9 10 11 12 13

    Burada işletim sisteminin dosyanın parçalarını diskte ardışışıl cluster'lara yerleştirdiğini görüyorsunuz. Ancak bu durum 
    her zaman böyle olma zorunda değildir.

    16 bir FAT'te bir FAT elemanında bulunacak değerler şunlar olabilmektedir (değerler little Endian olarak WORD'e dönüştürülmüştür):

    0000            Boş cluster
    0001            Kullanılmıyor
    0002 -  FFEF    Geçerli, sonraki cluster
    FFF0H - FFF6    Reserved cluster
    FFF7            Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FFF8 - FFFF     Son cluster
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemleri FAT bölümünü nasıl ele alıp işlemektedir? Aslında FAT bölümündeki sektörler zaten çok kullanıldığı 
    için işletim sisteminin aşağı seviyeli disk cache sisteminde bulunuyor durumda olurlar. Ancak işletim sistemleri genellikle 
    FAT elemanları temelinde de bir cache sistemi de oluşturmaktadır. Böylece bir cluster değeri verildiğinde eğer daha önce o 
    cluster ile işlemler yapılmışsa o cluster'ın sonraki cluster'ı hızlı bir biçimde elde edilebilmektedir.

    Biz burada volümü açtığımızda tüm FAT bölümünü okuyup FATSYS yapısının içerisine yerleştireceğiz. Sonra da ilk cluster 
    numarası bilinen dosyaların cluster zincirini elde eden bir fonksiyon yazacağız. openfat_sys fonksiyonunun yeni versiyonu 
    aşağıdaki gibi olabilir:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if ((fd = open(path, O_RDWR)) == -1)
            goto EXIT1;

        if (read_bpb(fd, &fatsys->bpb) == -1)
            goto EXIT2;

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
            goto EXIT2;

        if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
            goto EXIT3;

        if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
            goto EXIT3;

        return fatsys;
    EXIT3:
        free(fatsys->fat);
    EXIT2:
        close(fd);
    EXIT1:
        free(fatsys);

        return NULL;
    }

    İlk cluster numarası bilinen dosyanın cluster zincirini elde eden fonksiyon da aşağıdaki gibi yazılabilir:

    uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            clu = *(uint16_t *)(fatsys->fat + clu * 2);
        } while (clu < 0xFFF8);
        *count = n;

        return chain;
    }

    Bu fonksiyonda dosyanın cluster zinciri için uint16_t türünden dinamik büyütülen bir dizi oluşturulmuştur. Dizi eski 
    uzunluğunun iki katı olacak biçimde büyütülmektedir. Fonksiyon bize cluster zincirini vermekte hem de bu zincirin 
    uzunluğunu vermektedir.

    Aşağıda tüm kodlar bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT3;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT3;

    return fatsys;

EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of clusters in file: %u\n", count);
    for (uint16_t i = 0; i < count; ++i)
        printf("%u  ", chain[i]);
    printf("\n");

    freeclu_chain(chain);

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdi ilk cluster'ını bildiğimiz bir text dosyanın içeriğini yazdırmak isteyelim. Bunun için önce getclu_chain16 
    fonksiyonunu çağırırız. Sonra read_cluster fonksiyonu ile cluster'ları okuyup içini yazdırabiliriz. Ancak burada şöyle 
    bir sorun vardır: Dosyanın son cluster'ı tıka basa dolu değildir. Orada dosyaya dahil olmayan bye'lar da vardır. İşletim 
    sistemi dosyanın uzunluğunu elde edip son cluster'daki dosyaya dahil olmayan kısmı belirleyebilmektedir.

    Aşağıda ilk cluster'ı bilinen bir text dosyanın yazdırılmasına yönelik bir örnek verilmiştir. Burada dosyanın son cluster'ındaki
    dosyaya ait olmayan kısım da yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    for (uint16_t i = 0; i < count; ++i) {
        if (read_cluster(fatsys, chain[i], buf) == -1)
            exit_sys("read_cluster");
        for (int i = 0; i < fatsys->clulen; ++i)
            putchar(buf[i]);
    }

    freeclu_chain(chain);
    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sisteminin dosya sistemi bize aslında cluster'larda olan dosya parçalarını "dosya" adı altında ardışıl byte 
    topluluğu gibi göstermektedir. Biz işletim sisteminin sistem fonksiyonu ile dosyayı açarız ve read fonksiyonu ile okumayı
    yaparız. Bütün diğer işlemler işletim sisteminin çekirdek kodları tarafından yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda 16 bit FAT için işlemler yaptık. Pekiyi 12 bit ve 32 bit FAT bölüm nasıldır? 32 bit FAT önemli bir farklılığa 
    sahip değildir. Her FAT elemanı 32 bir yani 4 byte uzunluktadır. Dolayısıyla daha büyük bir volüm için kullanılabilir. 
    16 bit FAT'te toplam 65536 FAT elemanı elemanı olabilir (Bazılarının kullanılmadığını da anımsayınız.) Bir cluster en fazla
    64 sektör uzunluğunda olabilmektedir. Bu durumda FAT16 sistremlerinde volümün maksimum uzunluğu 2^16 * 2^6 * 2^9 = 2GB.

    12 Bit FAT'ler biraz daha karmaşık görünümdedir. 12 bit 8'in katı değildir ve 3 hex digitle temsil edilmektedir. Bu nedenle
    12 Bit FAT'te FAT zinciri izlenirken dikkat edilmelidir. Eğer volüm küçükse (eskiden floppy diskler vardı ve onlar çok 
    küçüktü) FAt12 sistemi FAT tablosunun daha az yer kaplamasını sağlamaktadır.

    FAT12 sisteminde bir FAT elemanı 12 bit olduğu için FAT bölümünde en fazla 2^12 = 4096 FAT elemanı olabilir. Microsoft
    kendi format programında FAT12 volümlerinde bir cluster'ı maksimum 8 sektör olarak almaktadır. Bu durumda FAT12 volümü 
    maksimum 2^12 * 2^3 * 2^9 = 2^24 = 16MB olabilmektedir. Başka bir deyişle Microsoft 16MB'nin yukarısındaki volümleri FAT12
    olarak formatlamamaktadır.

    Aşağıda 12 bit FAT tablosunun baş kısmı görülmektedir:

    00000200  f8 ff ff 00 40 00 05 60  00 07 80 00 09 a0 00 0b  |....@..`........|
    00000210  c0 00 ff 0f 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000220  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000240  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000250  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000270  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    12 bit'in 3 hex digit yani 1.5 olduğuna dikkat ediniz. Buradaki 12 bit şöyle yapılmaktadır. Cluster numarası önce 1.5 ile 
    çarpılır ve noktalı kısım atılır. (Bu işlem 3 ile çarpılıp 2'ye bölünme biçiminde yapılabilir.) Elde edilen offset'ten WORD 
    bilgi çekilir. Eğer cluster numarası çifte yüksek anlamlı 4 bit atılır, eğer cluster numarası tek ise düşük anlamlı 4 bit 
    atılır. Yüksek anlamlı 4 bit'in atılması 0x0FFF ile "bit and" işlemi uygulanarak, düşük anlamlı 4 bit'in elde edilmesi 
    sayının 4 kez sağa ötelenerek yapılabilir. Örneğin yukarıdaki FAT bölümünde biz 4 numaralı cluster'ın değerini elde edecek 
    olalım. 4 * 1.5 = 6'dır. 6'ıncı offset'ten WORD çekilirse 0x6005 değeri elde edilir. Yüksek anlamı 4 bit atıldığında ise 
    0x005 değeri elde edilecektir. Şimdi 5 numaralı cluster'ın değerini elde etmek isteyelim. Bu durumda 5 * 1.5 = 7.5 olur. 
    Noktadan sonraki kısım atılırsa 7 elde edilir. 7'inci offset'ten WORD öçekildiğinde 0x0060 değeri elde edilecektir. Bu 
    değerin de düşük anlamlı 4 biti atıldığında 0x006 değeri elde edilir.

    12 Bit FAT sisteminde bir FAT elemanın alabileceği değerler de şöyledir:

    000             Boş cluster
    001             Kullanılmıyor
    002 - FEF       Geçerli, sonraki cluster
    FF0H - FF6      Reserved cluster
    FF7             Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FF8 - FFF       Son cluster

    12 bit FAT tablosunda ilk cluster değeri bilinen dosyanın cluster zincirlerini elde etmek için aşağıdaki gibi bir fonksiyon 
    yazılabilir.

    uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, word, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
            clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
        } while (clu < 0xFF8);
        *count = n;

        return chain;
    }

    Fonksiyonda 12 bit FAT değerinin elde edilmesi şöyle yapılmıştır:

    clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT32 sisteminde her FAT elemanı 32 bittir. Ancak bu sistemde boot sektördeki BPB alanında da faklılıklar vardır. Bu nedenle
    32 bit FAT sistemi FAT12 ve FAT16 ile tam uyumlu değildir. FAT32 için bazı fonksiyonların yeniden yazılması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz FAT doısya sisteminin boot sektörünü, FAT ve Data bölümlerini ele aldık. Ele almadığımız tek bölüm "Root Dir" bölümüdür. 
    Şimdi "Root Dir" bölümü ve dosya bilgilerinin nasıl saklandığı konusu üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Microsoft'un FAT dosya sisteminde ve UNIX/Linux sistemlerinde kullanılan i-node tabanlı dosya sistemlerinde dizinler de 
    tamamen bir dosya gibi organize edilmektedir. Yani dizinler de aslında birer dosyadır. Bir dosyanın içerisinde o dosyanın 
    bilgileri bulunurken bir dizin dosyasının içerisinde o dizindeki dosyalara ilişkin bilgiler bulunmaktadır. Yani dizinler 
    aslında "o dizindeki dosyaların bilgilerini içeren dosyalar" gibidir. Bir dizin dosyası "dizin girişlerinden (directory 
    entry) oluşmaktadır. FAt12 ve FAT16 dosya sistemlerinde bir dizin dosyasındaki dizin girişleri 32 byte uzunlupundaydı. 
    Yani dizin ddosyaları 32 byte'lık kayıtların peşi sıra gelmesiyle oluşuyordu. O zamanalarda DOS sistemlerinde bir dosyanın 
    ismi için en fazla 8 karakter, uzantısı için de en fazla 3 karakter kullanılabiliyordu. Dolayısıyla 32 byte'lık dizin 
    girişlerinin 1 byte'ı dosyanın ismi için ayrılmıştı. Sonra Microsoft dosya isimlerini 8+3 formatından çıkartarak onların 
    255'e kadar uzatılmasını sağladı. Ancak bu yaparken de geçmişe doğur uyumu korumak için birden fazla 32 byte'lık dizin
    girişleri kullandı. Biz önce burada klasik 8+3'lük dizin girişlerinin formatını göreceğiz.

    32'lik klasik dizin girişi formatı şöyledir:

    Offset (Hex)                    Uzunluk                     Anlamı

    00                              8 Byte                      Dosya ismi (File Name)
    08                              3 Byte                      Dosya Uzantısı (Extension)
    0B                              1 Byte                      Dosya Özelliği (Attribute)
    0C                              1 Byte                      Kullanılmıyor (Reserved)
    0D                              BYTE                        Yaratılma Zamanının Milisaniyesi
    0E                              WORD                        Dosyanın Yaratılma Zamanı (Creation Time)
    10                              WORD                        Dosyanın Yaratılma Tarihi (Creation Date)
    12                              WORD                        Son Okunma Zamanı (Last Access Time)
    14                              WORD                        Kullanılmıyor (Reserved)
    16                              WORD                        Son Yazma Zamanı (Last Write Time)
    18                              WORD                        Son Yazma Tarihi (Last Write Date)
    1A                              WORD                        İlk Cluster Numarası (First Cluster)
    1C                              DWORD                       Dosyanın Uzunluğu (File Length)

    Aşağıda "x.txt" dosyanın ve "mydir" dizinin 32 byte'lık dizin girişleri görülmektedir.

    58 20 20 20 20 20 20 20  54 58 54 20 00 0b 5d 92  |X       TXT ..].|
    59 59 59 59 00 00 5d 92  59 59 0e 00 0f 00 00 00  |YYYY..].YY......|

    4d 59 44 49 52 20 20 20  20 20 20 10 00 7a f0 96  |MYDIR      ..z..|
    59 59 59 59 00 00 f0 96  59 59 10 00 00 00 00 00  |YYYY....YY......|

    - Dosya İsmi: 32'lik dizin girişlerinin ilk 8'byte'ı dosya isminden oluşmaktadır. Eğer dosya ismi 8 karakterden kısa 
    ise SPACE karakterleriyle (0x20) padding yapılmaktadır. Klasik FAT16 ve FAT12 sistemlerinde dosya isimlerinin ve uzantılarının
    büyük harf-küçük harf duyarlılığı yoktur. Tüm dosyalar bu sistemlerde "büyük harfe dönüştürülerek" dizin girişlerinde 
    tutulmaktadır.

    - Dosya Uzantısı: Dosya uzantısı en fazla 3 karakterden oluşmaktadır. Eğer 3 karakterden kısa ise SPACE (0x20) karakterleriyle
    padding yapılmaktadır.

    - Dosya Özelliği: Bu alanda dosyanın özleliklerine ilişkin bit bit alanı bulundurulmaktadır. Buradaki her bit'in bir 
    anlamı vardır. Özellik byte'ı aşağıdaki bitlerden oluşmaktadır:

       7           6          5        4        3          2        1           0
    Reserved    Reserved    Archive   Dir     VLabel     System    Hidden    ReadOnly

    Eğer ReadOnly biti 1 ise dosya "read-only" biçimdedir. Böyle dosyalara işletim sistemi yazma yapmaz. Hidden biti 1 ise 
    dosya "dir" komutu uygulandığında görüntülenmez. DOS işletim sisteminin kendi dosyalarını System özelliği ile vurgulamaktadır. 
    Yani eğer bir dosya işletim sistemine ilişkin bir dosya ise System biti 1 olur.

    Volüm isimleri boot sektörün yanı sıra kök dizinde bir dosya ismi gibi de tutulmaktadır. Böyle girişlerin VLabel biti 
    1 olur. Eğer bir dizin söz konusu ise Dir biti 1 olmaktadır. FAT dosya sisteminde normal dosyalara "Archive" dosyaları 
    denilmektedir. Bu nedenle bu bit hemen her zaman 1 olarak görülür. Aşağıda "x.txt" ve "mydir" dizin girişlerine ilişkin 
    özellik byte'ınn bitleri görülmektedir:

    x.txt (0x20)        0 0 1 0 0 0 0 0
    mydir (0x10)        0 0 0 1 0 0 0 0

    "x.txt" dosyasının özellik bitlerinden yalnızca Archive biti set edilmiştir. "mydir" dizinin de yalnızca "Dir" biti set 
    edilmiştir. İşletim sistemi bir dizin girişinin normal bir dosyaya mı yoksa bir dizin dosyasına mı ilikin olduğunu özellik
    byte'ının 4 numaralı bitine bakarak tespit etmektedir.

    - Tarih ve Zaman Bilgileri FAT12 ve FAT16 dosya sistemlerinde 2 byte ile kodlanmaktadır. Eskiden DOS sistemlerinde dosyanın 
    yaratılma tarihi ve zamanı ve son okunma tarihi tutulmazdı. Bu alanlar "reserved" durumdaydı. Sonra Microsoft bu alanları 
    bu amaçla kullanmaya başladı. Tarih bilgisi byte içerisinde bitsel düzeyde tutulmaktadır. Tarih bilgisinin tutuluş formatı
    şöyledir:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
    y  y  y  y  y  y  y m m m m d d d d d 

    Burada WORD değerin düşük anlamlı 5 biti gün için, sonraki 4 biti ay için ve geri kalan 7 biti yıl için bulundurulmuştur. 
    Tarih bilgisinin yıl alanı için 7 bit ayrıldığına göre buraya nasıl 2024 gibi bir tarih yerleştirilebilmektedir. İşte DOS
    işletim sisteminin ilk versiyonu 1980 yılında oluşturulduğu için buradaki tarih bilgisi her zmana 1980 yılından itibaren 
    bir offset belirtmektedir. Yani örneğin 2024 yılı için buradaki yıl bitlerine 44 kodlanmaktadır. Örneğin bir dosyanın 32'lik
    dizin girişi şöyledir:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Buaradk 0x18'inci offset'ten little endian formatta WORD çekersek 0x5959 değerini elde ederiz. Şimdi bu WORD değeri 2'lik
    sistemde ifade edelim:

    5         9       5       9
    0101    1001    0101    1001

    Şimdi de yukarıda belirttiğimiz gibi sayıyı bit'lerine ayrıştıralım:

    0101100 => 44    1010 => 10     11001 => 25
      yıl             ay             gün

    O halde buradaki tarih 25/10/2024'tür.

    16 bitle (WORD ile) zaman bilgisi de şöyle kodlanmıştır:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
     h  h  h  h  h  m m m m m m s s s s s

    Burada bir noktayaya dikkat ediniz: 0 ile 24 arasındaki saatler 5 bit ile tutulabilir. 0 ile 60 arasındaki dakikalar ise 
    ancak 6 bit ile tutulabilir. Burada geriye 5 bit almıştır. Dolayısıyla saniyeleri tutmak için bu 5 bit yeterli değildir. 
    İşte FAT dosya sistemini tasarlayanlar saniyedeki duyarlılığı azaltarak saniye değerinin yarısını buraya yazılması yoluna
    gitmişlerdir. Yani zaman bilgisinin saniye kısmı eski FAT12 ve FAT16 sistemlerinde tam duyarlılıkla tutulamamaktadır. 
    Örneğin yukarıdaki dizin girişinde dosyanın son değiştirilme zamanı için 0x16'ıncı offset'ten WORD çektiğimizde 0xB309
    değerini elde ederiz. Şimdi bu değeri 2'lik sisteme dönüştürelim:

     B       3       0       9
    1011    0011    0000    1001

    Şimdi de bit alanlarını ayrıştıralım:

    10110 => 22     011000 => 24    01001 => 9
      saat            dakika          saniye

    Burada işletim sistemi saniye alanına mevcut saniyenin yarısını yazdığına göre bu dosyanın değiştirilme zamanı 22:24:18
    olacaktır.

    Burada küçük bir noktaya dikkatinizi çekmek istiyoruz: Eskiden dizin girişinin 0x0D numaralı BYTE'ı da "reserved" durumdaydı
    sonra bu byte'a dosyanın yaratılma zamanına ilişkin milisaniye değeri yerleştirildi. Dolayısıyla artık dosyanın yaratılma 
    zamanı saniye duyarlılığında ifade edilebilmektedir. Bu durumda yaratılma zamanındaki saniye 2 ile çarpılıp buradaki 
    milisaniye ile toplanmaktadır. Tabii genel olarak Microsoft'un arayüzü dosyaların zaman gilfgilerinin saniyelerini default
    durumda zaten gmstermemektedir. Örneğin:

    D:\>dir
    Volume in drive D is YENI BIRIM
    Volume Serial Number is 2C68-EBFD

    Directory of D:\

    25.10.2024  22:24                27 x.txt
    25.10.2024  22:26                 8 con
    25.10.2024  22:26                59 y.txt
    25.10.2024  22:28    <DIR>          mydir
                   3 File(s)             94 bytes
                1 Dir(s)      52.194.304 bytes free

    - İlk Cluster Numarası: Biz daha önce FAT bölümünü incelerken bir dosyanın cluster zincirini elde edebilmek için onun 
    ilk cluster numarasının bilinmesi gerektiğini belirtmiştik. (Bir bağlı listeyi dolaşabilmek için onun ilk düğümünün yerinin
    bilinmesi gerektiğini anımsayınız.) İşte bir dosyanın ilk cluster numarası dizin girişinde saklanmaktadır. Yani işletim 
    sistemi önce dosyanın dizin girişini bulmakta sonra FAT'ten onun cluster zincirini elde etmektedir. Yukarıdaki dosyasının 
    dizin girişini yeniden veriyoruz:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Burada söz konusu dosyanın ilk cluster numarası dizin girişinin 0x1A ofsfetinden başlayan WORD bilgidir. Bu bilgiyi örnek
    dizin girişinden çektiğimizde 0x006 değerini elde ederiz. Bu durumda bu dosyanın ilk cluster numarası 6'dır.

    - Dosyanın Uzunluğu: Dosyanın uzunluğu dizin girişindeki son 4 byte'lık (DWORD alan) alanda tutulmaktadır. İşletim sistemi
    dosyanın son cluster'ındaki geçerli byte sayısını bu uzunluktan yararlanarak elde etmektedir. Örneğin yukarıdaki dizin 
    girişine ilişkin dosya uzunluğu 0x0000001B = 27'dir. Dizin dosyalarına ilişkin uzunluklar için işletim sistemi hep 0 
    değerini yazmaktadır.

    Dizinler de bir dosya gibi ele alınmaktadır. Dolayısıyla dizinlerin de bir cluster zinciri vardır. Ancak FAT12 ve FAT16
    sistemlerinde kök dizinin yeri ve uzunluğu baştan bellidir. Kök dizin için bir cluster zinciri yoktur. FAT32 dosya sisteminde
    kök dizin de normal bir dizin gibi büyüyebilmektedir. Yani kök dizinin de bir cluster zinciri vardır.

    32'lik bir dizin girişini aşağıdaki gibi bir yapıyla temsil edebiliriz:

    #pragma pack(1)

    typedef struct tagDIR_ENTRY {
        unsigned char name[8];
        unsigned char ext[3];
        uint8_t attr;
        char reserved1[1];
        uint8_t crtime_ms;
        uint16_t crdate;
        uint16_t crtime;
        uint16_t rdtime;
        char reserved2[2];
        uint16_t wrtime;
        uint16_t wrdate;
        uint16_t fclu;
        uint32_t size;
    } DIR_ENTRY;

    #pragma pack()
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosya silindiğinde ne olur? İşletim sistemi FAT dosya sisteminde bir dosya silindiğinde iki işlem yapar:

    1) Dosyanın silindiğinin anlaşılması için dizin girişindeki dosya isminin ilk karakterini 0xE5 olarak değiştirir. Böylece 
    dizin girişlerini tararken 32'lik girişin ilk karajkter 0xE5 ise o dizin girişini silindiği gerekçesiyle atlamaktadır. 
    Ancak işletim sistemi bu 32'lik dizin girişinin diğer byte'larına dokunmamaktadır.

    2) İşletim sistemi dosyanın cluster zincirini de sıfırlamaktadır. Böylece bu dosyanın FAT'te kapladığı alan artık "boş" 
    gözükecektir. Ancak işletim sistemi dosyanın Data bölümündeki cluster'ları üzerinde herhangi bir işlem yapmaz.

    Pekiyi FAT dosya sisteminde "undelete" yapan programlar nasıl çalışmaktadır? İşte bu programlar dosyanın dizin girişine 
    bakıp onun ilk cluster'ının numarasını elde edip FAT bölümünde yersine bir algoritmayla onun cluster zincirini yeniden 
    oluşturmaya çalışmaktadır. Ancak böyle bir kurtarmanın garantisi yoktur. Çünkü işletim sistemi boşaltılmış cluster'ları 
    başka bir dosya için tahsis etmiş olabilir. Ya da FAT'teki cluster zincirini tahmin eden programlar bu konuda yanılabilmektedir. 
    Ancak ne olursa olsun dosyanın ilk karakteri silindiği için bu karakter kurtarma sırasında kullanıcıya sorulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                01/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT12 ve FAT16 sistemlerinin orijinali yalnızca 8+3'lük dosya isimlerini destekliyordu. Yani bir dosyanın ismi en fazla 
    8 karakterden uzantısı da en fazla 3 karakterden oluşabiliyordu. 90'lı yılların ortalarına doğru Microsoft FAT dosya 
    sisteminde uzun dosya isimlerinin de kullanılmasına olanak sağlamıştır. Microsoft bunu yaparken geçmişe doğru uyumu 
    mümkün olduğunca korumaya da çalışmıştır. Microsoft'un bu yeni düzenlemesinde 8+3'ten daha uzun dosya izimleri birden fazla
    32'lik girişle temsil edilmektedir. Ancak Microsoft geçmişe doğru uyumumu korumak için her uzun dosya isminin bir de 8+3'lük
    kısa ismini oluşturmak istemiştir. Bu durumda uzun dosya isimlerinin kullanıldığı FAT sistemlerinde 8+3'lük alan sığmayan 
    dosya isimleri aşağıdaki formata göre dizin girişlerinde bulundurulmaktadır:

    <32'lik giriş>
    <32'lik giiriş>
    ...
    <32'lik giriş>
    <dosyanın 8+3'lük kısa ismi>

    Tabii eğer istenirse (örneğin Linux böyle yapmaktadır) 8+3'lük sınıfı aşmayana dosyalar da sanki uzun isimli dosyalarmış gibi 
    saklanabilmektedir. Burada dosyanın 8+3'lük kısa isminin dışındaki uzun ismi de 32'lik girişlerde ASCII olarak değil UNICODE
    olarak tutulmaktadır.

    Uzun dosya isimlerine ilişkin girişlerin sonunda 8+3'lük kısa bir girişin de bulundurulduğunu belirtmiştik. Peki bu uzun dosya 
    isminden kısa giriş nasıl elde edilmektedir?

    Uzun dosya isimlerinin tutulduğu 32'lik girişlerin ilk byte'ında önemli bilgiler vardır. Bu byte'a "sıra numarası (sequence 
    number)" denilmektedir. Bu byte bit bit anlamlandırılmaktadır. Byte'ın bitlerinin anlamları şöyledir:

    D L X X X X X X

    Burada en yükske anlamlı bit olan D biti 32'lik girişin silinip silinmeidğini anlatmaktadır. Eğer bu giriş silinmişse bu
    bit 1, silinmemişse 0 olacaktır. 7 numaralı bit (L biti) 32'lik girişlerin aşağıdan yukarıya doğru son giriş olup olmadığını 
    belirtmektedir. Ger kalan 6 bit 32'lik girişlerin sıra numarasını belirtir. Yani her 32'lik girişin bir sıra numarası vardır. 
    Her 32'lik giriş uzun dosya isminin 13 UNICODE karakterini tutmaktadır. Pekiyi biz 32'lik bir girişin eski kısa ilişkin 
    32'lik bir giriş mi yoksa uzun ismin 32'lik girişlerinden biri mi olduğunu nasıl anlayabiliriz? İşte bunun için 32'lik 
    girişin 0x0B offset'inde bulunan özellik byte'ının düşük anlamlı 4 bitine bakmak gerekir. Eğer bu 4 bitin hepsi 1 ise 
    bu 32'lik giriş uzun dosya isminin 32'lik girişlerinden biridir.

    Aşağıda uzun dosya isimlerine ilişkin 32'lik girişlerin genel formatı verilmiştir. Ayrıntılı format için Microsoft'un 
    "FAT File System Specification" dokümanına başvurabilirsiniz.


    Field name        Offset    Size    Description
    LDIR_Ord        0        1        Sequence number (1-20) to identify where this entry is in the sequence of LFN entries to 
                                    compose an LFN. One indicates the top part of the LFN and any value with LAST_LONG_ENTRY 
                                    flag (0x40) indicates the last part of the LFN.
    LDIR_Name1        1        10        Part of LFN from 1st character to 5th character.
    LDIR_Attr        11        1        LFN attribute. Always ATTR_LONG_NAME and it indicates this is an LFN entry.
    LDIR_Type        12        1        Must be zero.
    LDIR_Chksum        13        1        Checksum of the SFN entry associated with this entry.
    LDIR_Name2        14        12        Part of LFN from 6th character to 11th character.
    LDIR_FstClusLO    26        2        Must be zero to avoid any wrong repair by old disk utility.
    LDIR_Name3        28        4        Part of LFN from 12th character to 13th character.

    Biz sonraki örneklerde uzun dosya isimlerini dikkate almayacağız. Onları geçeceğiz. Aşağıda kök uzun dosya isimlerinin 
    ve silinmiş dosya isimlerinin geçilerek kök dosya sistemindeki dosyaların listesini elde eden bir fonksiyon verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8
#define ROOT_DEF_CAPACITY        8
#define DIR_ENTRY_SIZE            32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    uint8_t *rootdir;        /* Root sectors */
    /* ... */
} FATSYS;

#pragma pack(1)

typedef struct tagDIR_ENTRY {
    unsigned char name[8];
    unsigned char ext[3];
    uint8_t attr;
    char reserved1[1];
    uint8_t crtime_ms;
    uint16_t crdate;
    uint16_t crtime;
    uint16_t rdtime;
    char reserved2[2];
    uint16_t wrtime;
    uint16_t wrdate;
    uint16_t fclu;
    uint32_t size;
} DIR_ENTRY;

#pragma pack()

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);
DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if ((fatsys->rootdir = (uint8_t *)malloc(fatsys->bpb.rootlen * fatsys->bpb.bps)) == NULL)
        goto EXIT3;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    if (lseek(fatsys->fd, fatsys->rootoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->rootdir, fatsys->bpb.rootlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    return fatsys;

EXIT4:
    free(fatsys->rootdir);
EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, word, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
        clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
    } while (clu < 0xFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count)
{
    DIR_ENTRY *dent, *temp;
    DIR_ENTRY *dents;
    uint32_t capacity;
    uint16_t n;

    if ((dents = (DIR_ENTRY *)malloc(DIR_ENTRY_SIZE * ROOT_DEF_CAPACITY)) == NULL)
        return NULL;

    n = 0;
    capacity = ROOT_DEF_CAPACITY;
    dent = (DIR_ENTRY *)fatsys->rootdir;
    for (uint16_t i = 0; i < fatsys->bpb.rootents; ++i) {
        if (dent[i].name[0] == 0)
            break;
        if (dent[i].name[0] == 0xE5 || (dent[i].attr & 0XF) == 0x0F)
            continue;

        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(dents, DIR_ENTRY_SIZE * capacity )) == NULL) {
                free(dents);
                return NULL;
            }
            dents = temp;
        }
        dents[n++] = dent[i];
    }
    *count = n;

    return dents;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];
    uint16_t count;
    uint16_t *chain;
    DIR_ENTRY *dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((dents = get_rootents(fatsys, &count)) == NULL) {
        fprintf(stderr, "cannot get root entries!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < count; ++i) {
        for (int k = 0; k < 8; ++k)
            if (dents[i].name[k] != ' ')
                putchar(dents[i].name[k]);

        if (dents[i].ext[0] != ' ')
                putchar('.');
        for (int k = 0; k < 3; ++k)
            if (dents[i].ext[k] != ' ')
                putchar(dents[i].ext[k]);

        putchar('\n');
    }

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi bir dizin dosyası içerisindeki 32'lik girişlerini gözden geçirirken dosya isminin ilk karakterini '\0' 
    karakter olarak gördüğünde (yani sayısal 0 değeri) işlemini sonlandırmaktadır. Yani dizin dosyası içerisindeki bütün 
    girişlerin gözden geçirilmesine gerek yoktur. Yukarıda da belirttiğimiz gibi dosya isminin ilk karakteri 0xE5 ise işletim 
    sistemi bu 32'lik girişi de silinmiş dosya olduğu gerekçesiyle geçmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde bir yol ifadesi verildiğinde o yol ifadesinin hedefindeki dosya ya da dizine ilişkin dizin girişinin 
    elde edilmesine "yol ifadelerinin çözümlenmesi (pathname resolution)" denilmektedir. Yol ifadelerinin çözümlenmesi eğer 
    yol ifadesi mutlaksa kök dizinden itibaren, göreli ise prosesin çalışma dizininden itibaren yapılmaktadır. Örneğin FAT 
    dosya sistemine ilişkin "\a\b\c\d.dat" biçiminde bir yol ifadesi verilmiş olsun. Burada hedeflenen "d.dat" dosyasına ilişkin
    dizin girişi bilgileridir. Ancak bunun için önce kök dizinde "a" girişi, sonra "a" dizininde "b" girişi, sonra "b" dizininde
    "c" girişi sonra da "c" girişinde "d.dat" girişi bulunmalıdır. Tabii biz burada Windows'taki bir yol ifadesini temel aldık.
    UNIX/Linux sistemlerinde dosya sistemleri mount edildiği için bu yol ifadesi aslında mount noktasına görelidir.

    İşletim sistemleri bir yol ifadesini çözümlerken yol ifadesindeki tüm yol bileşenlerine ilişkin dizin giriş bilgilerini de 
    bir cache sisteminde saklamaktadır. İşletim sistemlerinin oluşturduğu bu cache sistemine "directory entry cache" ya da kısaca
    "dentry cache" denilmektedir. Örneğin prgramcı aşağıdaki gibi bir yol ifadesi kullanmış olsun:

    "\a\b\c\d.dat"

    İşletim sistemi buradaki "a", "b", "c" ve "d.dat" dosyalarına ilişkin dizin giriş bilgilerini bir cache sisteminde saklamaktadır. 
    Böylece benzer yol ifadeleri için hiç disk okuması yapılmadan bu cache sisteminden bu bilgiler elde edilebilmektedir.
 ---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                177. Ders 03/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi FAT dosya sistemi için yol ifadelerini çözen basit yalın bir kodu nasıl yazabiliriz? Bizim bir yol ifadesi verildiğinde
    o yol ifadesini parse edip oradaki yol bileşenlerini elde edebilmemiz gerekir. Sonra dizinler bir dosya olduğuna göre dizinlere 
    ilişkin cluster zincirinde diğer bileşenin aranması gerekir. İşlemler böyle devam ettirilir. FAT dosya sistemi için yol 
    ifadesini çözümleyen bir fonksiyonun parametrik yapısı şöyle olabilir:

    int resolve_path(FATSYS *fatsys, const char *path, DIRECTORY_ENTRY *de);

    Biz mutlak yol ifadelerini çözümleyecek olalım. Her dizinin bir cluster zinciri vardır. Ancak FAT12 ve FAT16 sistemlerinde
    kök dizinin bir cluster zinciri yoktur. Kök dizinin yeri ve uzunluğu baştan bellidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                178. Ders 08/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde i-node tabanlı dosya sistemleri kullanılmaktadır. i-node tabanlı dosya sistemlerinin temel 
    organizasyonu FAT dosya sistemlerinden oldukça farklıdır. i-node tabanlı dosya sistemlerinin çeşitli varyasyonu vardır. 
    Linux sistemleri ve BSD sistemleri ağırlıklı olarak ext (extended file system) denilen dosya sistemini kullanmaktadır.
    ext dosya sistemi ilk kez 1992 yılında tasarlanmıtır. Sonra zaman içerisinde bu dosya sisteminin ext2, ext3 ve ext4 biçiminde 
    çeşitli varyasyonları oluşturulmuştur. Bugün artık genellikle bu ailenin son üyesi olan ext4 dosya sistemi kullanılmaktadır. 
    Ancak yukarıda da belirttiğimiz gibi i-node tabanlı dosya sistemleri bir aile belirtmektedir. Bu ailenin FAT sistemlerinde 
    olduğu gibi genel tasarımı birbirine benzerdir. Biz burada ext dosya sisteminin en uzun süre kullanılan versiyonu olan 
    ext konusunda temel bilgiler vereceğiz. ext2 dosya sisteminin resmi dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://cscie28.dce.harvard.edu/lectures/lect04/6_Extras/ext2-struct.html
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ext2 dosya sistemi üzerinde incelemeler ve denemeler yapmak için yine loop aygıtlarından faydalanabilrisiniz. Bunun için 
    yine önce içi sıfırlarla dolu bir dosya oluşturulur:

    $ dd if=/dev/zero of=ext2.dat bs=512 count=400000

    Sonra loop aygıt sürücüsü bu dosya için hazırlanır:

    $ sudo losetup /dev/loop0 ext2.dat

    Artık aygıt formatlanabilir:

    $ mkfs.ext2 /dev/loop0

    Mount işlemi aşağıdaki gibi yapılabilir:

    $ mkdir ext2
    $ sudo /dev/loop0 ext2
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    i-node tabanlı dosya sistemlerinde volüm kabaca aşağıdaki bölümlere ayrılmaktadır:

    <boot block>>
    <super block>
    <i-node block>
    <data block>

    Boot blok (boot block) işletim sistemini boot eden kodların bulunduğu bloktur. Süper blok (super block) FAT dosya sistemlerindeki 
    boot sektör BPB alanına benzemektedir. Yani burada dosya sistemine ilişkin meta data bilgiler bulunmaktadır. i-node blok 
    i-node elemanlarından oluşmaktadır. Data block FAT dosya sistemindeki Data bölümü gibidir. FAT dosya sistemindeki "cluster" 
    yerine i-node tabanlı dosya sistemlerinde "blok (block)" terimi kullanılmaktadır. Bir blok bir dosyanın parçası olabilecek 
    en küçük birimdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Süper blok hemen volümün 1024 byte offset'inde bulunmaktadır. (yani volümün başında boot sektör programları için 1024 
    byte yer ayrılmıştır. Süper blok süper bloktta belirtilen blok uzunluğu kadar uzunluğa sahiptir. (Ayrıca izleyen paragraflarda 
    da görüleceği gibi ext2 dosya sisteminde her blok grupta süper bloğun bir kopyası da bulunmaktadır.) Yukarıda da belirttiğimiz 
    gibi burada volüm hakkında meta data bilgileri bulunmaktadır. Buradaki alanlar ext2 dokümantasyonunda ayrıntılarıyla açıklanmıştır. 
    Süper blok içerisindeki alanlar aşağıdaki gibidir:

    | Alan                 Boyut (Byte)                Açıklama
    |-----------------------|----|-----------------------------------------------------------------------------------------
    | s_inodes_count        | 4  | Dosya sistemindeki toplam inode sayısı.
    | s_blocks_count        | 4  | Dosya sistemindeki toplam blok sayısı.
    | s_r_blocks_count      | 4  | Rezerve edilmiş blok sayısı.
    | s_free_blocks_count   | 4  | Boş blok sayısı.
    | s_free_inodes_count   | 4  | Boş inode sayısı.
    | s_first_data_block    | 4  | İlk veri bloğunun numarası (bu, kök dizinin bulunduğu blok).
    | s_log_block_size      | 4  | Blok boyutunun logaritmasının değeri (örneğin, 1 KB için 10, 4 KB için 12, vs.).
    | s_log_frag_size       | 4  | Parçacık boyutunun logaritması.
    | s_blocks_per_group    | 4  | Her blok grubundaki blok sayısı.
    | s_frags_per_group     | 4  | Her blok grubundaki fragman sayısı.
    | s_inodes_per_group    | 4  | Her blok grubundaki inode sayısı.
    | s_mtime               | 4  | Dosya sisteminin son değiştirilme zamanı (Unix zaman damgası).
    | s_wtime               | 4  | Dosya sisteminin son yazılma zamanı (Unix zaman damgası).
    | s_mnt_count           | 2  | Dosya sisteminin kaç kez bağlandığı (mount) sayısı.
    | s_max_mnt_count       | 2  | Dosya sisteminin kaç kez daha bağlanabileceği (yani, montaj sayısı aşımı).
    | s_magic               | 2  | Süper blok sihirli sayısı (bu, EXT2 dosya sistemini tanımlar ve genellikle `0xEF53`'tür).
    | s_state               | 2  | Dosya sisteminin durumu (örneğin, temiz mi, hata mı).
    | s_errors              | 2  | Hata durumunda yapılacak işlem (örneğin, “ignore”, “panic”, vb.).
    | s_minor_rev_level     | 2  | Küçük revizyon seviyesi (EXT2’yi güncelleyen küçük değişiklikler için).
    | s_lastcheck           | 4  | Dosya sisteminin son kontrol tarihi (Unix zaman damgası).
    | s_checkinterval       | 4  | Dosya sisteminin kontrol edilmesi gereken süre (saniye cinsinden).
    | s_creator_os          | 4  | Dosya sistemini oluşturan işletim sistemi türü (örneğin, Linux, Solaris, vb.).
    | s_rev_level           | 4  | EXT2 dosya sistemi revizyon seviyesi.
    | s_def_resuid          | 2  | Varsayılan rezerv kullanıcı ID'si (uid).
    | s_def_resgid          | 2  | Varsayılan rezerv grup ID'si (gid).
    | s_first_ino           | 4  | İlk inode numarası (genellikle kök dizini için).
    | s_inode_size          | 2  | Inode boyutu (genellikle 128 veya 256 byte).
    | s_block_group_nr      | 2  | Bu süper blok ile ilişkili blok grubu numarası.
    | s_feature_compat      | 4  | Uyumluluk özelliklerinin bit maskesi.
    | s_feature_incompat    | 4  | Uyumsuz özelliklerin bit maskesi.
    | s_feature_ro_compat   | 4  | Okuma-yazma uyumsuz özelliklerinin bit maskesi.
    | s_uuid                | 16 | Dosya sisteminin benzersiz tanımlayıcısı (UUID).
    | s_volume_name         | 16 | Dosya sistemi adının (etiketinin) olduğu alan.
    | s_last_mounted        | 64 | Dosya sisteminin son bağlandığı dizin yolu.
    | s_algorithm_usage_bmp | 4  | Bloklar ve inode'lar için kullanılan algoritmaların bit maskesi.
    | s_prealloc_blocks     | 1  | Önceden tahsis edilecek blok sayısı.
    | s_prealloc_dir_blocks | 1  | Önceden tahsis edilecek dizin blokları sayısı.
    | s_padding             | 118| Alanın sonundaki boşluk (süper bloğun uzunluğunu tamamlar).

    Buradaki önemli alanlar hakkında kısa bazı açıklamalar yapmak istiyoruz:

    s_inodes_count: Bu alanda dosya sistemindeki toplam i-node elemanlarının sayısı bulunmaktadır. Bir ext2 disk bölümünde en 
    fazla buradaki i-node elemanlarının sayısı kadar farklı dosya bulunabilir.

    s_blocks_count: Burada Data bölümündeki toplam blokların sayısı bulunmaktadır.

    s_r_blocks_count: Burada ayrılmış (reserve edielmiş) blokların sayısı bulunmaktadır.

    s_free_blocks_count: Burada Data bölümünde kullanımayan boş blokların sayısı tutulmaktadır.

    s_log_block_size: Burada 1024 değerinin 2 üzeri kaçla çarpılacağını belirten değer tutulmaktadır. Yani blok uzunluğu 
    1024 << s_log_block_siz biçiminde hesaplanmaktadır. Örneğin burada 2 değeri yazılıyorsa blok uzunluğu 2^2 * 1024 = 4096 byte'tır.

    s_inode_size: Burada bir i-ndeo elemanının kaç byte olduğu bilgisi yer almaktadır. Örnek dosya sistemimizde i-node elemanları 
    256 byte uzunluğundadır. 

    ext2 dosya sisteminin super block bilgisi ve bazı önemli alanlarına ilişkin bilgiler "dumpe2fs" isimli utility programla 
    elde edilebilir. Örneğin:

    $ dumpe2fs /dev/loop0

    Aşağıda bir ext2 süper bloğunun örnek bir içeriği verilmektedir:

    00004000  60 c3 00 00 50 c3 00 00  c4 09 00 00 f4 b6 00 00  |`...P...........|
    00000410  55 c3 00 00 00 00 00 00  02 00 00 00 02 00 00 00  |U...............|
    00000420  00 80 00 00 00 80 00 00  b0 61 00 00 51 5c 2e 67  |.........a..Q\.g|
    00000430  51 5c 2e 67 01 00 ff ff  53 ef 00 00 01 00 00 00  |Q\.g....S.......|
    00000440  42 5c 2e 67 00 00 00 00  00 00 00 00 01 00 00 00  |B\.g............|
    00000450  00 00 00 00 0b 00 00 00  00 01 00 00 38 00 00 00  |............8...|
    00000460  02 00 00 00 03 00 00 00  ec 89 02 3e a8 11 4c 01  |...........>..L.|
    00000470  b0 b5 f5 48 1e 30 79 d6  00 00 00 00 00 00 00 00  |...H.0y.........|
    00000480  00 00 00 00 00 00 00 00  2f 68 6f 6d 65 2f 6b 61  |......../home/ka|
    00000490  61 6e 2f 53 74 75 64 79  2f 55 6e 69 78 4c 69 6e  |an/Study/UnixLin|
    000004a0  75 78 2d 53 79 73 50 72  6f 67 2f 44 69 73 6b 49  |ux-SysProg/DiskI|
    000004b0  4f 2d 46 69 6c 65 53 79  73 74 65 6d 73 2f 65 78  |O-FileSystems/ex|
    000004c0  74 32 00 00 00 00 00 00  00 00 00 00 00 00 0c 00  |t2..............|
    000004d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000004e0  00 00 00 00 00 00 00 00  00 00 00 00 6e 47 e8 bc  |............nG..|
    000004f0  81 50 45 f3 bb 96 6c 7c  51 bc e3 8a 01 00 00 00  |.PE...l|Q.......|
    00000500  0c 00 00 00 00 00 00 00  42 5c 2e 67 00 00 00 00  |........B\.g....|

    Burada toplam i-node elemanlarının sayısı 0xC360 (50016) tanedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümünün i-node bloğu i-node elemanlarından oluşmaktadır. Her i-node elemanının ilki 0 olmak üzere bir indeks numarası 
    vardır. Örneğin:

    0       i-node elemanı
    1       i-node elemanı
    2       i-node elemanı
    3       i-node elemanı
    4       i-node elemanı
    ...
    300     i-node elemanı
    301     i-node elemanı
    302     i-node elemanı
    303     i-node elemanı
    304     i-node elemanı
    ...

    Bir dosyanın ismi haricindeki bütün bilgileri dosyaya ilişkin i-node elemanında tutulmaktadır. Zaten stat fonksiyonları 
    da aslında bilgileri bu i-node elemanından almaktadır. Her dosyanın diğerlerinden farklı bir i-node numarası olduğuna 
    dikkat ediniz. Dolayısıyla dosyanın i-node numarası o dosyayı karakterize etmektedir. ("ls" komutunda dosyanın i-node 
    numaralarının -i seçeneği ile elde edildiğini anımsayınız.) Burada hatırlatma yapmak amacıyla stat yapısını yeniden vermek 
    istiyoruz:

    struct stat {
        dev_t     st_dev;     /* ID of device containing file */
        ino_t     st_ino;     /* inode number */
        mode_t    st_mode;    /* protection */
        nlink_t   st_nlink;   /* number of hard links */
        uid_t     st_uid;     /* user ID of owner */
        gid_t     st_gid;     /* group ID of owner */
        dev_t     st_rdev;    /* device ID (if special file) */
        off_t     st_size;    /* total size, in bytes */
        blksize_t st_blksize; /* blocksize for file system I/O */
        blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
        time_t    st_atime;   /* time of last access */
        time_t    st_mtime;   /* time of last modification */
        time_t    st_ctime;   /* time of last status change */
    };

    ext2 dosya sisteminde bir i-node elemanın alanları aşağıdaki gibidir:

    | Alan         Boyut (Byte)                         Açıklama
    |--------------------------------------------------------------------------------------------------------------------
    |i_mode       | 2          | Dosya türü ve izinler (örneğin, `S_IFREG` (normal dosya), `S_IFDIR` (dizin), vs.).
    |i_uid        | 2          | Dosya sahibinin kullanıcı kimliği (UID).
    |i_size_lo    | 4          | Dosyanın boyutunun alt 32 biti (byte cinsinden).
    |i_atime      | 4          | Son erişim zamanı (Unix zaman damgası).
    |i_ctime      | 4          | Son inode değişiklik zamanı (Unix zaman damgası).
    |i_mtime      | 4          | Son değişiklik (modifikasyon) zamanı (Unix zaman damgası).
    |i_dtime      | 4          | Dosyanın silinme zamanı (Unix zaman damgası), eğer geçerliyse.
    |i_gid        | 2          | Dosya sahibinin grup kimliği (GID).
    |i_links_count| 2          | Dosyaya bağlı olan hard link (bağlantı) sayısı.
    |i_blocks     | 4          | Dosyanın disk üzerinde kullandığı blok sayısı (block, 512 byte'lık bloklar).
    |i_flags      | 4          | Dosya bayrakları (örneğin, `i_dirty`, `i_reserved` gibi).
    |i_osd1       | 4          | Linux spesifik alan (genellikle genişletilmiş özellikler için kullanılır).
    |i_block[15]  | 4 × 15 = 60| Dosyanın bloklarına işaretçi
    |i_generation | 4          | Dosyanın versiyon numarası (özellikle NFS gibi ağ dosya sistemlerinde kullanılır).
    |i_file_acl   | 4          | Dosya için ACL (Access Control List) blok numarası.
    |i_dir_acl    | 4          | Dizin için ACL blok numarası.
    |i_faddr      | 4          | Dosyanın "fragman adresi" (bu, çoğu zaman sıfırdır ve eski EXT2 uygulamalarında kullanılır).

    Biz bu alanların büyük çoğunluğunu aslında stat fonksiyonunda görmüştük. Ancak stat yapısında olmayan bazı elemanlar da 
    burada bulunmaktadır. Biz stat yapısında olmayan bazı önemli elemanlar üzerinde durmak istiyoruz:

    i_dtime: Bu alanda eğer dosya silinmişse dosyanın ne zaman silindiğine yönelik tarih zaman bilgisi tutulmaktadır. Buradaki
    değer 01/01/1970'ten geçen saniye sayısı cinsindedir.

    i_block ve i_blocks: Bu elemanlar izleyen paragraflarda adaha ayrıntılı bir biçimde ele alınacaktır.

    i_flags: Bu alanda ilgili dosyaya ilişkin bazı bayraklar tutulmaktadır.

    i_file_acl: Dosyaya ilişkin "erişim kontrol listesi (access control list)" ile ilgili bilgiler tutulmaktadır.

    i-node elemanında dosyanın isminin tutulmadığına dikkat ediniz. ext2 dosya sisteminde bir i-node elemanının uzunluğu süper
    bloğun s_inode_size elemaında yazmaktadır. Örnek sistemimizde i-node elemanları 256 byte uzunluktadır.

    Pekiyi dosyanın ismi nerededir ve dosyanın i-node numarası nereden elde edilmektedir? Bunu izleyen paragraflarda göreceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda i-node tabanlı bir disk bölümünün kaba organizasyonunun aşağıdaki gibi olduğunu belirtmiştik:

    <boot block>                    (1024 byte)
    <super block>
    <i-node block>
    <data block>

    Burada sanki süper bloktan hemen sonra i-node blok geliyormuş gibi biz organizasyon resmedilmiştir. Halbuki süper bloktan
    hemen sonra i-node blok gelmemektedir. ext2 dosya sisteminin gerçek yerleşimi aşağıdaki gibidir:

    <boot block>                      (1024 byte)
    <block group>
    <block group>
    <block group>

    Bir disk bölümü aslında blok gruplarından (block groups) oluşmaktadır. Her block grubu disk bölümüne ilişkin bir bölümü belirtir. 
    Bir block grubu aşağıdaki gibi bir yapıya sahiptir:

    <super block>
    <block group descriptor table>
    <block bitmap>
    <i-node bitmap>
    <i-node table>
    <data block>

    İşte "blok grup betimleyici tablosu (block group descriptor table)" block group'ları hakkında bilgi veren bir bölümdür. Bir 
    kaç blok bilginin yer aldığı super block'un "s_blocks_per_group" elemanında saklanmaktadır. Her blok grupta belli sayıda 
    i-node elemanı vardır. Bir blok gruptaki i-node elemanlarının sayısı super block'taki s_inodes_per_group elemanıyla 
    belirtilmektedir. Yani aslında ext2 dosya sisteminde aşağıdaki gibi bir oragnizasyon söz konusudur:

    <boot block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap>                   (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>
    ...

    Görüldüğü gibi ext2 dosya sisteminde super bloğun tek bir kopyası yoktur. Her block grupta super blok yeniden yer 
    almaktadır. Bir blok grupta ayrı bir i-node tablosunun ve data bölümünün olduğuna dikkat ediniz.

    Pekiyi neden ext2 dosya sisteminde disk bölümü birden fazla blok gruplara ayrılmıştır? İşte bunun nedenlerinden biri 
    güvenliktir. Yani i-node bloklardan biri bozulduğunda diğeri bozulmamış biçimde kalabilir.

    Blok gruplarındaki "blok grup betimelyici tablosu (block group descriptor table)" blok grupları hakkında bazı meta data 
    bilgileri tutmaktadır. Ancak blok grup betimleyicilerinde yalnızca o blok grubuna ilişkin bilgiler değil tüm blok gruplarına 
    ilişkin bilgiler tutulmaktadır. Yani her blok grubunda yeniden tüm blok gruplarına ilişkin bilgiler tutulmaktadır. 
    Block grup betimleyici tablosu blok grup betimleyicilerindne oluşan bir dizi gibidir:

    Block Grup Betimleyici Tablosu

    <block group descriptor>
    <block group descriptor>
    <block group descriptor>
    ...
    <block group descriptor>
    <block group descriptor>

    Bir blok grup betimleyicisinin alanları şöyledir:

    +----------------------------+---------------------------+--------------------------------------+
    | Yapı Elemanı               | Boyut (Byte)              | Açıklama                             |
    +----------------------------+---------------------------+--------------------------------------+
    | bg_block_bitmap            | 4                         | Blok haritasının başlangıç adresi    |
    | bg_inode_bitmap            | 4                         | İnode haritasının başlangıç adresi   |
    | bg_inode_table             | 4                         | İnode tablosunun başlangıç adresi    |
    | bg_free_blocks_count       | 2                         | Blok grubunda serbest blok sayısı    |
    | bg_free_inodes_count       | 2                         | Blok grubunda serbest inode sayısı   |
    | bg_used_dirs_count         | 2                         | Blok grubundaki kullanılan dizin sayısı |
    | bg_flags                   | 2                         | Blok grubunun bayrakları (flags)     |
    | bg_reserved                | 12                        | Rezerv alan (genellikle sıfırdır)    |
    +----------------------------+---------------------------+--------------------------------------+

    Blok grup betimleyicisi toplamda 32 byte yer kaplamaktadır. Her blok grubunda blok bitmap'in, i-node bitmap'in ve i-node 
    tablosunun yerinin blok numarası tutulmaktadır. Buradaki blok uzunlukları disk bölümünün başından itibaren yer belirtir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümü içerisindeki blokların numaralandırılması ile ilgili ince bir nokta vardır. Eğer disk bölümündeki blok uzunluğu
    1K yani 1024 byte ise boot block 0'ıncı bloktadır. Dolayısıyla ilk blok grubundaki süper blok 1'inci bloktadır. Ancak 
    blok büyüklüğü 1024'ten (yani 1K'dan) fazla ise bu durumda boot blok ile süper blok tek blok kabul edilmektedir. Boot blok 
    ile süper bloğun bulunduğu ilk bloğun numarası 0'dır.

    İlk blok grup betimleyici tablosunun yeri de blok grubundaki super block'tan hemen sonradır. Örneğin dosya sistemindeki 
    blok uzunluğu 4K (4096 byte) ise ilk blok betimleyici tablosunun yeri 4096'ıncı = 0x1000 offset'indedir. (Bu durumda boot 
    blok ile süper bloğun 0 numaralı blok biçiminde tek blok olarak ele alındığını anımsayınız.) Bir blok grubunun toplam 
    kapladığı blok sayısı süper block içerisindeki s_blocks_per_group elemanında tutulmaktadır. Örneğin biz k numaralı blok 
    grubun blok numarasını k * s_blocks_per_group işlemiyle elde edebiliriz.

    Aşağıda örnek bir blok grup betimleyici tablosu verilmiştir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ....

    Bir blok grup betimleyicisi 32 byte uzunluktadır. Burada toplam iki blok grup betimleyicisi yani disk bölümünde toplam 
    iki blok grubu bulunmaktadır.Bu iki blok grup betimleyicisini ayrı ayrı aşağıda veriyoruz:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Disk bölümünde toplam kaç blok grubu olduğu süper bloktaki s_blocks_count elemanında yazmaktadır.

    Bir blok grubundaki blok grup betimleyici tablosunun uzunluğu 1 blok kadardır. Blok bitmap'in ve I-node bitmap'in 
    uzunlukları doğrudan süper blokta yazmamaktadır. Bu uzunluklar dolaylı bir biçimde hesaplanmaktadır. Dolayısıyla bir 
    blok gruptaki data alanın başlangıç bloğu da dolaylı bir biçimde hesaplanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosyanın i-node numarası biliniyorsa onun disk bölümündeki yerini nasıl hesaplarız? Burada bizim bu i-node 
    elemanının hangi blok grubunda ve o blok grubunun i-node tablosunda nerede olduğunu belirlememiz gerekir. i-node tablosundaki
    i-node elemanları 1'den başlatılmıştır. Yani bizim elimizde i-node numarası n olan bir dosya varsa aslında bu dosya i-node
    tablosunun n - 1'inci i-node elemanındadır. Çünkü i-node tablosunun ilk i-node elemanının numrası 0 değil 1'dir. 

    Her blok grupta eşit sayıda i-node elemanı bulunmaktadır. Bir blok gruptaki i-node elemanlarının sayısı doğrudan süper 
    bloktaki s_inodes_per_group elemanında belirtilmektedir. Bu durumda ilgili i-node numarasına ilişkin i-node elemanı i-node
    numarası n olmak üzere (n  - 1) / s_inodes_per_group işlemiyle elde edilebilir. Tabii bu durumda (n - 1) % s_inodes_per_group 
    ifadesi de i-node elemanının o blok gruptaki i-node tablosunun kaçıncı elemanında olduğunu verecektir. Anımsanacağı gibi her 
    blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtiliyordu.

    Bir blok grubunun toplam kaç tane bloktan oluştuğu süper bloktaki s_blocks_per_group elemanında tutulmaktadır. Dolayısıyla 
    k'ıncı blok grubunun yeri k * s_blocks_per_group değeri ile tespit edilir. Blok numaralarına boot block dahil değildir. Yani
    ilk blok grubunun süper bloğunun blok numarası 0'dır.

    Bu durumda manuel olarak n numaralı i-node numarasına sahip bir dosyanın i-node elemanına şöyle erişilebilir:

    1) Önce n / s_inodes_per_group ile ilgili i-node elemanının hangi blok grubununda olduğu tespit edilir. Bu değer k olsun.

    2) Bu blok grubunun yeri k * s_blocks_per_group değeri ile elde edilir ve bu bloğa gidilir. Her bloğun başında 1 blokluk 
    süper blok vardır. Süper bloğu blok grup betimleyici tablosu izler. Blok grup betimleyici tablosu blok grup betimleyicilerinden 
    oluşmaktadır. Her blok grup betimleyicisi 32 byte yer kaplamaktadır. Dolayısıyla biz k numaralı blok grubuna ilişkin blok 
    betimleyicisinin yerini k * 32 ile tespit edebiliriz. (Aslında tüm blok gruplarındaki blok grup betimleyici tablolarının 
    birbirinin aynısı olduğunu anımsayınız.)

    3) İlgili blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtilmektedir. 
    Artık biz i-node elemanını burada belirtilen bloktan itibaren n % s_inodes_per_group kadar ilerideki i-node elemanı olarak 
    elde edebiliriz. Bir i-node elemanının uzunluğunun 256 byte olduğunu belirtmiştik.

    Şimdi 12'inci i-node elemanın yerini bu adımlardan geçerek bulmaya çalışalım. Elimizdeki disk bölümünde bir blok grupta 
    toplam 25008 tane i-node elemanı vardır. O halde 12 numaralı i-node elemanı 0'ıncı blok grubunun 11'inci i-node elemanındadır. 
    0'ınci blok grubu eğer blok uzunluğu 1K'dan fazla ise diskin 0'ıncı bloğundan başlamaktadır. (Tabii 0'sıncı bloğın hemen 
    başında boot blok, ondan 1024 byte sonra da 0'ın blok grubunun süper bloğu bulunmaktadır.) O halde elimizdeki disk bölümünün 
    0'ıncı blok grubunun blok betimleyici tablosu 1'inci bloktadır. Bunun yeri de bir blok 4096 byte olduğuna göre 0x1000 
    offset'indedir. Buradan elde edilen blok grup betimleyici tablosu şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Her blok grup betimleyicisinin 32 byte olduğunu anımsayınız. Bu duurmda 0'ıncı blok grup betimleyicisi şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubundaki i-node tablosunun blok numarası blok grup betimleyicisinin 8'inci offset'inde bulunan bg_inode_table
    elemanındadır. Bu elemandaki değer 0x00000010 (16)'dır. O halde bizim 16 numaralı bloğa gitmemiz gerekir. 16 numaralı 
    blok disk bölümünün 16 * 4096 = 65536 (0x10000) offset'indedir. Artık bu offset'te ilgili blok grubundaki i-node elemanları 
    bulunmaktadır. Bir i-node elemanı 128 byte olduğuna göre 11'inci elemanının yeri 11 * 256 = 2816 (0xB00) byte ileridedir. 
    O halde bu tablonun disk bölümünün başından itibarenki yeri 65536 + 2816 = 68352 (0x10B00) offset'indedir. Aşağıda ilgili
    i-node elemanının 256 byte'lık içeriği görülmektedir:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki ilk WORD bilgi (0x81A4) dosyanın erişim haklarını sonraki WORD bilgi (0x0000) kullanıcı id'sini belirtmektedir. 
    Sonraki DWORD bilgi (0x000079C8) de dosyanın uzunluğunu belirtmektedir. Diğer elemanların anlamlarına i-node yapısından 
    erişebilirsiniz. 

    i-node tablosundaki ilk n tane i-node elemanı reserved biçimde tutulmaktadır. Bunaların sayısı süper bloktaki s_first_ino 
    elemanında belirtilmektedir. Üzerinde çalıştığımız dosya sisteminde s_first_ino değeri 11'dir. Yani ilk 10 i-node elemanı 
    reserve edilmiştir. İlk i-node elemanının numarası 11'dir. Örnek dosya sistemimizdeki durum şöyledir:

    0. Blok Grubunun i-node Tablosu

    <1 numaralı i-node elemanı>    
    <2 numaralı i-node elemanı>     
    <3 numaralı i-node elemanı> 
    ...
    <10 numaralı i-node elemanı> 
    <11 numaralı i-node elemanı (ilk reserved olmaayan eleman)>
    ...

    Reserve edilmiş ilk i-node elemanlarının anlamları şöyledir:

    XT2_BAD_INO                1    bad blocks inode
    EXT2_ROOT_INO            2    root directory inode
    EXT2_ACL_IDX_INO        3    ACL index inode (deprecated?)
    EXT2_ACL_DATA_INO        4    ACL data inode (deprecated?)
    EXT2_BOOT_LOADER_INO    5    boot loader inode
    EXT2_UNDEL_DIR_INO        6    undelete directory inode
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            179. Ders 24/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Peekiyi ext2 dosya sisteminde bir dosyanın parçalarının (yani bloklarının) nerelerde olduğu bilgisi nerede tutulmaktadır?
    Anımsanacağı gibi FAT dosya sisteminde dosyanın parçalarının (orada block yerine cluster terminin kullanıldığını anımsayınız)
    diskin hangi cluster'larında olduğu FAT bölümünde saklanıyordu. İşte yalnızca ext2 dosya sisteminde değil i-node tabanlı 
    dosya sistemlerinde bir dosyanın diskte hangi bloklarda bulunduğu i-node elemanın içerisinde tutulmaktadır.i-node elemanlarının
    genel olarak 1228 byte ya da 256 byte uzunlukta olduğunu anımsayınız. Büyük bir dosyanın blok numaralarının bu kadar alana 
    sığmayacağı açıktır. PPekiyi o zaman dosyanın blok numaraları i-node elemanında nasıl tutulmaktadır?

    İşte i-node elemanında dosyanın hangi bloklerda olduğu "doğrudan (direct)", "dolaylı (indriect)", "çift dolaylı (double 
    indirect)" ve "üç dolaylı (triple indirect)"" bloklarda tutulmaktadır. i-node elemanının demimal 40'ncı offset'inde (i-node 
    elemanın 0x28 offset'indek, "i_blocks" isimli elemanında) 15 elemanlık her biri DWORD değerlerden oluşan bir dizi vardır. 
    Bu diziyi şöyle gösterebiliriz:

    0 <dosyanın 0'ıncı bloğunun numarası> 
    1 <dosyanın 1'inci bloğunun numarası> 
    2 <dosyanın 2'inci bloğunun numarası> 
    3 <dosyanın 3'üncü bloğunun numarası> 
    4 <dosyanın 4'üncü bloğunun numarası> 
    5 <dosyanın 5'inci bloğunun numarası> 
    6 <dosyanın 6'ıncı bloğunun numarası> 
    7 <dosyanın 7'inci bloğunun numarası> 
    8 <dosyanın 8'inci bloğunun numarası> 
    9 <dosyanın 9'uncu bloğunun numarası> 
    10 <dosyanın 10'uncu bloğunun numarası> 
    11 <dosyanın 11'inci bloğunun numarası> 
    12 <dolaylı blok numarası>
    13 çift dolaylı blok numarası>
    14 <üç dolaylı blok numarası>

    Bu durumda eğer dosya 12 blok ya da ondan daha küçükse zaten dosyanın parçalarının blok numaraları bu diznini ilk 12 
    elemanından doğrudan elde edilmektedir. Eğer dosya 12 bloktan büyükse bu durumda bu dizinin 12'indeksindeki elemanda 
    yazan blok numarası dosyanın diğer bloklarının blok numaralarını tutan bloğun numarasıdır. Yani dizinin 12'inci elemanında 
    blierilen bloğa gidildiğinde bu bloğun içerisinde blok numaraları vardır. Bu blok numaraları da dosyanın 12'inci bloğundan 
    itibaren bloklarının numaralarını belirtmektedir. Örneğin bir blok 4096 byte olsun. Bu durumda bir blokta 1024 tane blok 
    numarası olabilir. 12 blok numarası doğrudan olduğuna göre dolaylı blokla toplam dosyanın 1024 + 12 = 1036 tane bloğunun 
    yeri tutulmuş olacaktır. Pekiyi ya bu sistemde dosya 1026 bloktan daha büyükse? İşte bu durumda çift dolaylı blok numarasına 
    başvurulmaktadır. Çift dolaylı blok numarasına ilişkin bloğa gidildiğinde oradaki blok numaraları dosyanın blok numaraları 
    değil dosyanın blok numaralarının turulduğu blok numaralarıdır. Eğer dosya çift dolaylı bloklara sığmıyorsa üç dolaylı 
    bloğa başvurulmaktadır. Üç dolaylı blokta belirtilen blok numarasında çift dolaylı blokların numaraları vardır. Çift dolaylı
    blokların içerisinde dolaylı blokların numaraları vardır. Nihayet dolaylı blokların içerisinde de asıl blokların numaraları 
    vardır. 

    Pekiyi her bloğun 4K uzunluğunda olduğu bir sistemde bir dosyanın i-node elemanında belirtilen maksimum uzunluğu ne olabilir? 
    İşte bu uzunluk aşağıdaki değerlerin toplamıyla elde edilebilir:

    12 tane doğrudan blok = 12 * 4096
    1 tane dolaylı blok = 1024 * 4096
    1 tane çift dolaylı blok = 1024 * 1024 * 4096
    1 tane üç dolaylı blok = 1024 * 1024 * 1024 * 4096

    Toplam = 12 * 4096 + 1024 * 4096 + 1024 * 12024 * 4096 + 1024 * 1024 * 1024 * 4096 = 4448483065856 = 4 TB civarı.

    Şimdi aşağıdaki i-node elemanına bakıp dosya bloklarının yerlerini tespit edelim:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada dosyanın tüm blokları 0x28'inci offset'teki doğrudan bloklarda belirtilmektedir:

    00 08 00 00  => 0x800
    01 08 00 00  => 0x801
    02 08 00 00  => 0x802
    03 08 00 00  => 0x803
    04 08 00 00  => 0x804
    05 08 00 00  => 0x805
    06 08 00 00  => 0x806
    07 08 00 00  => 0x807

    Dosya 0x4 offset'inde belirtilen 0x79C8 = 31176 byte uzunluğundadır. Bu sistemde bir blok 4K olduğuna göre toplam dosyanın
    parçalarının 8 blok olması gerekmektedir. İşte burada söz konusu dosyanın blokları disk bölümünün başından itibaren 
    0x800, 0x801, 0x802, 0x803, 0x804, 0x805, 0x806 ve 0x807'inci bloklardadır. Söz konusu sistemde bir blok 4096 byte 
    olduğuna göre dosyanın ilk bloğunun offset numarası 0x800 * 0x1000 = 0x800000 biçimindedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                180. Ders 01/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de ext2 dosya sisteminde dizin organizasyonu üzerinde duralım. Tıpkı FAT dosya sistemlerinde olduğu gibi ext2 
    dosya sisteminde de dizinler birer dosya gibi organize edilmiştir. (Anımsanacağı gibi dizin dosyalarından biz opendir, 
    readdir, closedir fonksiyonlarrıyla okuma yaapabiliyorduk.) Yani dizinler aslında birer dosya gibidir. Dizin dosyaları 
    "dizin girişleri (directory entries)" denilen girişlerdne oluşmaktadır. 
    
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    ....
    
    Bir dizin girişin format şöyledir:

    Offset (bytes)        Size (bytes)         Açıklama
    0                       DWORD           inode numarası
    4                       WORD            girişin toplam uzunluğu
    6                       BYTE            dosya isminin uzunluğu
    7                       BYTE            dosyanın türü
    8                       0-255 Bytes     dosya ismi

    Aslında buradaki bilgiler Linux'taki readdir POSIX fonksiyonu ile de alınabilmektedir. readdir fonksiyonu POSIX standartlarına
    göre en az iki elemana sahip olmak zorundadır. Bunlar d_ino ve d_name elemanlarıdır. Ancak Linux'taki read bize daha fazla
    bilgi vermektedir. Linux'taki dirent yapısı şöyledir:

    struct dirent {
        ino_t          d_ino;       /* Inode number */
        off_t          d_off;       /* Not an offset; see below */
        unsigned short d_reclen;    /* Length of this record */
        unsigned char  d_type;      /* Type of file; not supported
                                        by all filesystem types */
        char           d_name[256]; /* Null-terminated filename */
    };

    Dizin girişleri FAT dosya sistemindeki gibi eşit uzunlukta girişlerden oluşmamaktadır. Bunun nedeni dosya isimlerinin 
    0 ile 255 karakter arasında değişebilmesidir. Dizin girişlerinin hemen başında DWORD bir alanda dosyaanın i-node numarası
    belirtilmektedir. Dizinler değişken uzulukta olduğu için ilgili girişin toplam kaç byte uzunlukta olduğu sonraki WORD 
    elemandaa tutulmaktadır. Girişteki dosya isminin uzunluğu ise sonrakişş BYTE elemanında tutulmaktadır. Dosyanın türü 
    hiç i-node elemanına erişmeden elde edilebilsin diye dizin girişlerinde de tutulmaktadır. Dosya türülerini belirten değerler
    şöyledir:

    İsim                Değer            Anlamı

    EXT2_FT_UNKNOWN        0                Unknown File Type
    EXT2_FT_REG_FILE    1                Regular File
    EXT2_FT_DIR            2                Directory File
    EXT2_FT_CHRDEV        3                Character Device
    EXT2_FT_BLKDEV        4                Block Device
    EXT2_FT_FIFO        5                Buffer File
    EXT2_FT_SOCK        6                Socket File
    EXT2_FT_SYMLINK        7                Symbolic Link
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            181. Ders06/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi ext2 dosya sisteminde işletim sistemi bit yol ifadesini nasıl çzöümlemektedir* Örneğin "/a/b/c.txt" gibi bir yol
    ifadesinde "c.txt" dosyasının i-node elemanına naısl erişmektedir? İşte kök dizin dosyasının bilgileri 2 numaralı i-node 
    elemanındadır. İşletim sistemi önce kök dizinin i-node elemanını elde eder. Oradan kök dizinin bloklarına erişir. O bloklar 
    içerisinde ilgili girişi arar. İşlemlerini bu biçimde devam ettirir. Örneğin "/a/b/c.txt" dosyasının i-node elemanına 
    erişmek için öncek kök dizinde "a" girişini arar. Sonra "a" girişin dizin olduğunu doğrular. Sonra "a" dizininde "b" 
    girişini arar. "b" girişinin de dosya olduğunu doğrular. Sonra "b" girişinin içerisinde "c.txt" arar ve hedef dosyanın 
    i-node bilgilerine erişir. 

    Şimdi adım adım elimizdeki disk bölümünde "/a/b/c.txt" dosyasının yerini bulmaya çalışalım. Tabii buradaki kök dizin 
    aslında mount edilmiş dosya sisteminin köküdür Biz bu dosya sistemini kursumuzda aşağıdaki noktaya mount ettik:
    
    "/home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems"

    Kök dizinin i-node elemanı (2 numaralı i-node elemanı) aşağıda verilmiştir:

    00010100  ed 41 00 00 00 10 00 00  a8 69 4c 67 a7 69 4c 67  |.A.......iLg.iLg|
    00010110  a7 69 4c 67 00 00 00 00  00 00 04 00 08 00 00 00  |.iLg............|
    00010120  00 00 00 00 04 00 00 00  2b 06 00 00 00 00 00 00  |........+.......|
    00010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 1c 7e f4 e6  | ......-...-.~..|
    00010190  42 5c 2e 67 00 00 00 00  00 00 00 00 00 00 00 00  |B\.g............|
    000101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada 0x28'inci offsetteki i_blocks elemanın yalnızca ilkinin dolu olduğunu görüyoruz. Demek ki kök dizin tek bir 
    bloktan oluşmaktadır. Kök dizinin blok numarası 0x62B'dir. Şimdi 0x62b bloğunun offset'ini hesaplayalım. Bunun için 
    bu değeri 0x1000 (4096) ile çarpmamız gerekir:

    0x62B * 0x1000 = 0x62B000 (6467584)

    Diskin bu offset'indeki değerler şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00  0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00 0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00 b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|
    0062b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki dizin girişlerini çözelim. Dizin giriş formatını aşağıda yeniden veriyoruz:

    Offset (bytes)        Size (bytes)         Açıklama
    0                       DWORD           inode numarası
    4                       WORD            girişin toplam uzunluğu
    6                       BYTE            dosya isminin uzunluğu
    7                       BYTE            dosyanın türü
    8                       0-255 Bytes     dosya ismi
    
    İlk dizin girişinin i-node numarası 2'dir. Bu girişin uzunluğu 0x0C = 12'dir. O halde
    bu dizin girişi şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02

    Burada dosya ismi 1 karakter uzunluktadır. Dosya ismi yalnızca 0x2E karakterinde oluşmaktadır. Bu karalter de "." karakteridir.
    Sonraki dizin girişinin i-node numarası yine 2'dir. Girişin uzunluğu yine 0xC = 12'dir. O halde giriş şöyledir:

    0062b000                                       02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00                           |................|   

    Buradaki dosya uzunlupunun 2 olduğu görülmektedir. Dosya ismi de 0x2E 0x2E karakterinden oluşmaktadır. Bu da ".." ismidir. 
    Her dizinin ilk iki elemanının bu biçimde olduğunu anımsayınız. Sonraki giriş ise şöyledir:

    0062b010                           0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00              |lost+found......|

    Burada dosya i-node numarası 0x0b = 11'dir. Dizin girişimin uzunluğu 0x14 = 20'dir. Dosya isminin uzunluğu 0xA = 10'dur. 
    Dosya ismi "lost+found" biçimindedir. Sonraki giriş ise şöyledir:

    0062b020                                       0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00              |....stdio.h..a..|

    Buaraki girişin i-node numarası 0xC = 12'dir. Girişin toplam uzunluğu 0x10 = 16'dır. Dosyanın isminin uzunluğu 7'dir. 
    Dosya ismi "stdio.h" biçimindedir. Sonraki giriş ise şöyledir:

    0062b030                                       b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|

    Burada dosyanın i-node numarası 0x61B2 = 25010'dur. Girişin uzunlu 0xC4 = 196'dır. (Bu değerin çok uzun olması önemli değildir. 
    Çünkü bu dizindeki son dosyadır.) Dosya isminin uzunluğu 1'dir. Doısya türü 0x02'dir. Yani bu giriş bir dizin belirtmektedir 
    Dos ismi "a" biçimindedir. 
    
    İşte işletim sistemi 0x61B2 = 25010'inci i-node elemanında bu dizinin bilgilerinin olduğunu tespit eder ve o i-node elemanını
    okur. Bu i-node elemanı aşağıdaki gibidir:

    08010100  ed 41 00 00 00 10 00 00  f8 2b 53 67 a7 69 4c 67  |.A.......+Sg.iLg|
    08010110  a7 69 4c 67 00 00 00 00  00 00 03 00 08 00 00 00  |.iLg............|
    08010120  00 00 00 00 02 00 00 00  2b 86 00 00 00 00 00 00  |........+.......|
    08010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010160  00 00 00 00 f9 65 fb 3c  00 00 00 00 00 00 00 00  |.....e.<........|
    08010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 04 7d e1 7b  | ......-...-.}.{|
    08010190  a7 69 4c 67 a0 15 ed 2d  00 00 00 00 00 00 00 00  |.iLg...-........|
    080101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    "a" dizinine ilişkin i-node elemanının 0x28'inci offset'teki blokları bir tanedir ve blok numarası 0x862B = 34547'dir. 
    Bu bloğun offseti'de 34547 * 4096 = 140685312'dir. Dizine ilişkin dizin bloğunun içeriği şöyledir:

    0862b000  b2 61 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |.a..............|
    0862b010  0c 00 02 02 2e 2e 00 00  b3 61 00 00 e8 0f 01 02  |.........a......|
    0862b020  62 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |b...............|
    0862b030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu dizin girişlerine bakıldığında "b" isimli girişin bulunduğu görülmektedir. İşte yol ifadesi bu aşamalardan geçilerek 
    çözümlenmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosya oluşturulurken boş bloklar nasıl tespit edilmektedir? İşte her blok grup betimleyicisi kendi blok grubundaki 
    boş blokları "block bitmap" denilen tabloda bit düzeyinde tutmaktadır. Blok bitmap tablosu her biti bir bloğun boş mu dolu 
    mu olduğunu tutmaktadır. Blok grup betimleyicisinde yalnızca blok grubunun yeri tutulur. Bunun blok uzunluğu ilgili blok
    gruplarındaki blok sayısına bakılarak tespit edilmelidir. Her blok grubunda eşit sayıda blok bulunur. Bu sayı süper blok
    içerisindeki s_blocks_per_group elemanında saklanmaktadır. Aşağıda bir grup betimleyicisinin blok bitmap tablosunun bir 
    bölümünü görüyorsunuz:

    0000e000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e010  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e020  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e030  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e040  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e050  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e060  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e070  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e080  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e090  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0a0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0b0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0c0  ff ff ff ff ff ff 01 00  00 00 00 00 00 00 00 00  |................|
    0000e0d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e100  ff 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki FF byte'larına dikkat ediniz. FF byte'ı aslında ikilik sistemde 1111 1111 bitlerine karşılık gelmektedir. Yani
    bu bloklar tamamen tahsis edilmiştir. 00 olan byte'lara ilişkin bloklar tahsis edilmemiş durumdadır. 

    I-node elemanlarının tahsis edilip edilmediğine yönelik de benzer bir tablo tutulmaktadır. Buna "i-node bitmap" tablosu 
    denilmektedir. Herr blok grubunda bir i-node bitmap tablosu bulunur. Bu tablo da bitlerden oluşmaktadır. Her bit ilgili 
    i-node elemanın boş mu dolu mu olduğunu bvelirtir. I-node bitmap tablosunun yeri de yine blok grup betimleyicinde tutulmaktadır.
    Bu tablonun uzunluğu da yine süper bloktaki "bir grup bloğundaki i-node elemanlarının sayısı" dikkate alınarak tespit 
    edilmektedir. Aşağıda örnek bir i-node bitmap talosunun bir kısmını görüyorsunuz:

    0000f000  ff 0f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubunda toplam 12 i-node elemanı tahsis edilmiş durumdadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosya sistemini tanıyabilmek için manuel işlemler yaptık. Pekiyi bu işlemleri prgramlama yoluyla 
    nasıl yapabiliriz? Yukarıda eçıkladığımız dosya sistemi alanlarına ilişkin yapılar çeşitli kütüphanelerin içerisinde hazır
    bir biçimde bulunmaktadır. Örneğin "libext2fs" kütüphanesi kurulduğunda <extfs/ext2_fs.h> dosyasında tüm yapı bildirimleri
    bulunacaktır. Kütüphanenin kurulumunu şöyle yapabilrisiniz:

    $ sudo apt-get install libext2fs-dev

    Aslında bu kütüphane ve ve <extfs/ext2_fs.h> başlık dosyası yalnızca ext2 dosya sistemine ilişkin değil ext2 ve ext4 dosya 
    sistemine ilişkin de yapıları ve fonksiyonları bulundurmaktadır. 

    Örneğin <extfs/ext2_fs.h> başlık dosyası içerisindeki süper blok yapısı aşağıdaki gibi bildirilmiştir:

    struct ext2_super_block {
        /*000*/    __u32    s_inodes_count;        /* Inodes count */
            __u32    s_blocks_count;        /* Blocks count */
            __u32    s_r_blocks_count;    /* Reserved blocks count */
            __u32    s_free_blocks_count;    /* Free blocks count */
        /*010*/    __u32    s_free_inodes_count;    /* Free inodes count */
            __u32    s_first_data_block;    /* First Data Block */
            __u32    s_log_block_size;    /* Block size */
            __u32    s_log_cluster_size;    /* Allocation cluster size */
        /*020*/    __u32    s_blocks_per_group;    /* # Blocks per group */
            __u32    s_clusters_per_group;    /* # Fragments per group */
            __u32    s_inodes_per_group;    /* # Inodes per group */
            __u32    s_mtime;        /* Mount time */
        /*030*/    __u32    s_wtime;        /* Write time */
            __u16    s_mnt_count;        /* Mount count */
            __s16    s_max_mnt_count;    /* Maximal mount count */
            __u16    s_magic;        /* Magic signature */
            __u16    s_state;        /* File system state */
            __u16    s_errors;        /* Behaviour when detecting errors */
            __u16    s_minor_rev_level;    /* minor revision level */
        /*040*/    __u32    s_lastcheck;        /* time of last check */
            __u32    s_checkinterval;    /* max. time between checks */
            __u32    s_creator_os;        /* OS */
            __u32    s_rev_level;        /* Revision level */
        /*050*/    __u16    s_def_resuid;        /* Default uid for reserved blocks */
            __u16    s_def_resgid;        /* Default gid for reserved blocks */
            /*
            * These fields are for EXT2_DYNAMIC_REV superblocks only.
            *
            * Note: the difference between the compatible feature set and
            * the incompatible feature set is that if there is a bit set
            * in the incompatible feature set that the kernel doesn't
            * know about, it should refuse to mount the filesystem.
            *
            * e2fsck's requirements are more strict; if it doesn't know
            * about a feature in either the compatible or incompatible
            * feature set, it must abort and not try to meddle with
            * things it doesn't understand...
            */
            __u32    s_first_ino;        /* First non-reserved inode */
            __u16   s_inode_size;        /* size of inode structure */
            __u16    s_block_group_nr;    /* block group # of this superblock */
            __u32    s_feature_compat;    /* compatible feature set */
        /*060*/    __u32    s_feature_incompat;    /* incompatible feature set */
            __u32    s_feature_ro_compat;    /* readonly-compatible feature set */
        /*068*/    __u8    s_uuid[16] __nonstring;        /* 128-bit uuid for volume */
        /*078*/    __u8    s_volume_name[EXT2_LABEL_LEN] __nonstring;    /* volume name, no NUL? */
        /*088*/    __u8    s_last_mounted[64] __nonstring;    /* directory last mounted on, no NUL? */
        /*0c8*/    __u32    s_algorithm_usage_bitmap; /* For compression */
            /*
            * Performance hints.  Directory preallocation should only
            * happen if the EXT2_FEATURE_COMPAT_DIR_PREALLOC flag is on.
            */
            __u8    s_prealloc_blocks;    /* Nr of blocks to try to preallocate*/
            __u8    s_prealloc_dir_blocks;    /* Nr to preallocate for dirs */
            __u16    s_reserved_gdt_blocks;    /* Per group table for online growth */
            /*
            * Journaling support valid if EXT2_FEATURE_COMPAT_HAS_JOURNAL set.
            */
        /*0d0*/    __u8    s_journal_uuid[16] __nonstring;    /* uuid of journal superblock */
        /*0e0*/    __u32    s_journal_inum;        /* inode number of journal file */
            __u32    s_journal_dev;        /* device number of journal file */
            __u32    s_last_orphan;        /* start of list of inodes to delete */
        /*0ec*/    __u32    s_hash_seed[4];        /* HTREE hash seed */
        /*0fc*/    __u8    s_def_hash_version;    /* Default hash version to use */
            __u8    s_jnl_backup_type;    /* Default type of journal backup */
            __u16    s_desc_size;        /* Group desc. size: INCOMPAT_64BIT */
        /*100*/    __u32    s_default_mount_opts;    /* default EXT2_MOUNT_* flags used */
            __u32    s_first_meta_bg;    /* First metablock group */
            __u32    s_mkfs_time;        /* When the filesystem was created */
        /*10c*/    __u32    s_jnl_blocks[17];    /* Backup of the journal inode */
        /*150*/    __u32    s_blocks_count_hi;    /* Blocks count high 32bits */
            __u32    s_r_blocks_count_hi;    /* Reserved blocks count high 32 bits*/
            __u32    s_free_blocks_hi;    /* Free blocks count */
            __u16    s_min_extra_isize;    /* All inodes have at least # bytes */
            __u16    s_want_extra_isize;    /* New inodes should reserve # bytes */
        /*160*/    __u32    s_flags;        /* Miscellaneous flags */
            __u16    s_raid_stride;        /* RAID stride in blocks */
            __u16    s_mmp_update_interval;  /* # seconds to wait in MMP checking */
            __u64    s_mmp_block;        /* Block for multi-mount protection */
        /*170*/    __u32    s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
            __u8    s_log_groups_per_flex;    /* FLEX_BG group size */
            __u8    s_checksum_type;    /* metadata checksum algorithm */
            __u8    s_encryption_level;    /* versioning level for encryption */
            __u8    s_reserved_pad;        /* Padding to next 32bits */
            __u64    s_kbytes_written;    /* nr of lifetime kilobytes written */
        /*180*/    __u32    s_snapshot_inum;    /* Inode number of active snapshot */
            __u32    s_snapshot_id;        /* sequential ID of active snapshot */
            __u64    s_snapshot_r_blocks_count; /* active snapshot reserved blocks */
        /*190*/    __u32    s_snapshot_list;    /* inode number of disk snapshot list */
        #define EXT4_S_ERR_START ext4_offsetof(struct ext2_super_block, s_error_count)
            __u32    s_error_count;        /* number of fs errors */
            __u32    s_first_error_time;    /* first time an error happened */
            __u32    s_first_error_ino;    /* inode involved in first error */
        /*1a0*/    __u64    s_first_error_block;    /* block involved in first error */
            __u8    s_first_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        /*1c8*/    __u32    s_first_error_line;    /* line number where error happened */
            __u32    s_last_error_time;    /* most recent time of an error */
        /*1d0*/    __u32    s_last_error_ino;    /* inode involved in last error */
            __u32    s_last_error_line;    /* line number where error happened */
            __u64    s_last_error_block;    /* block involved of last error */
        /*1e0*/    __u8    s_last_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        #define EXT4_S_ERR_END ext4_offsetof(struct ext2_super_block, s_mount_opts)
        /*200*/    __u8    s_mount_opts[64] __nonstring;    /* default mount options, no NUL? */
        /*240*/    __u32    s_usr_quota_inum;    /* inode number of user quota file */
            __u32    s_grp_quota_inum;    /* inode number of group quota file */
            __u32    s_overhead_clusters;    /* overhead blocks/clusters in fs */
        /*24c*/    __u32    s_backup_bgs[2];    /* If sparse_super2 enabled */
        /*254*/    __u8    s_encrypt_algos[4];    /* Encryption algorithms in use  */
        /*258*/    __u8    s_encrypt_pw_salt[16];    /* Salt used for string2key algorithm */
        /*268*/    __le32    s_lpf_ino;        /* Location of the lost+found inode */
            __le32  s_prj_quota_inum;    /* inode for tracking project quota */
        /*270*/    __le32    s_checksum_seed;    /* crc32c(orig_uuid) if csum_seed set */
        /*274*/    __u8    s_wtime_hi;
            __u8    s_mtime_hi;
            __u8    s_mkfs_time_hi;
            __u8    s_lastcheck_hi;
            __u8    s_first_error_time_hi;
            __u8    s_last_error_time_hi;
            __u8    s_first_error_errcode;
            __u8    s_last_error_errcode;
        /*27c*/ __le16    s_encoding;        /* Filename charset encoding */
            __le16    s_encoding_flags;    /* Filename charset encoding flags */
            __le32    s_reserved[95];        /* Padding to the end of the block */
        /*3fc*/    __u32    s_checksum;        /* crc32c(superblock) */
    };

    Kütüphane aşağıdaki bağlantıdan indireceğiniz pdf dosyasında dokümante edilmiştir:

    https://www.dubeyko.com/development/FileSystems/ext2fs/libext2fs.pdf

    Ayrıca "e2fsprogs" isimli pakette de ext2, ext3 ve ext4 dosya sistemlerine ilişkin pek çok yardımcı program bulunmaktadır.
    Örneğin bizim daha önce kullandığımız "dumpe2fs" programı bu paketin bir parçasıdır. Buradaki programlar "libext2fs" 
    kütüphanesi kulanılarak yazılmıştır. Paket pek çok bazı Linux dağıtımlarında default biçimde kurulu durumdadır. Eğer 
    dağıtımınızda kurulu değilse bu paketi aşağıdaki gibi kurabilirsiniz:

    $ sudo apt-get install e2fsprogs
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            182. Ders 08/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi "libext2fs" kütüphanesinin basit bir kullanımı üzerinde duracağız. Kütüphanenin temel başlık dosyası <extefs/extfs.h> 
    isimli dosyadır. Bu dosyanın include edilmesi gerekir:

    #include <ext2fs/ext2fs.h>

    Kütüphaneyi kullanan programlar derlenirken link aşamasında "-lext2fs" seçeneğinin bulundurulması gerekir. Örneğin:

    $ gcc -o sample sample.c -lext2fs

    Kütüphane içerisindeki fonksiyonların çooğunun geri dönüş değerleri errcode_t türündendir. errcode_t türü long biçimde 
    typedef edilmiştir. Fonksiyonlar başarı durumunda 0 değerine başarısızlık durumunda hata ile ilgili bir değere geri 
    dönmektedir. Hatayı yazdırmak için error_message isimli fonksiyon bulunmaktadır. Bu fonksiyona errcode_t değeri parametre
    olarak verilir, fonksiyon da hata yazısna ilişkin static bir dizinin başlangıç adresine geri döner. Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "%s\n", error_message(err));
        exit(EXIT_FAILURE);
    }
    
    Bu kütüphane kullanılarak yazılmış programlar genel olarak aygıtlara eriştiği için "sudo" ile çalıştırılması gerekir. 
    Aksi takdirde "Permission denied (EACCESS)" hatası ortaya çıkacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kğtğphanein kullanılması için ilk yapılacak işlem dosya sisteminin ext2fs_open fonksiyonu ile açılmasıdır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs open (const char *name, int args, int superblock, int block size, 
            io_manager manager, ext2_filsys *ret fs);

    Fonksiyonun birinci parametresi dosya sisteminin bulunduğu dosyanın ya da aygıt dosyasının yol ifadesini almaktadır. 
    Parametrelerin çoğu default 0 geçilebilir. Ancak io_manager parametresi için unix_io_manager argümanın girilmesi 
    gerekmektedir. Fonksiyon ext2fil_sys türünden handle belirten bir nesne vermektedir. Bu tür şöyle typedef edilmiştir:

    typedef struct struct_ext2_filsys *ext2_filsys;

    Dosya sistemine ilişkin tüm bilgiler bu struct_ext2_filsys yapısının içerisindedir. Bu yapı şöyle bildirilmiştir:

    struct struct_ext2_filsys {
        errcode_t            magic;
        io_channel            io;
        int                flags;
        char *                device_name;
        struct ext2_super_block    *     super;
        unsigned int            blocksize;
        int                fragsize;
        dgrp_t                group_desc_count;
        unsigned long            desc_blocks;
        struct opaque_ext2_group_desc *    group_desc;
        unsigned int            inode_blocks_per_group;
        ext2fs_inode_bitmap        inode_map;
        ext2fs_block_bitmap        block_map;
        ....
    };
        
    Örneğin bu yapının super elemanı süper blok bilgilerinin bulunduğu ext2_super_block isimli yapı nesnesinin adresi vermektedir. 

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!..\n");
        exit(EXIT_FAILURE);
    }

    Açılan dosya sisteminin işlem bitince ext2fs_close fonksiyonu ile kapatılması gerekir. Fonksiyonun prototipi şöyledir:
    
    errcode_t ext2fs close (ext2_filsys fs);

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!..\n");
        exit(EXIT_FAILURE);
    }
        
    /* ... */

    ext2fs_close(fs);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <ext2fs/ext2fs.h>

int main(void)
{
    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!..\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of Inode: %lu\n", (unsigned long)fs->super->s_inodes_count);    
    printf("Total Block: %lu\n", (unsigned long)fs->super->s_blocks_count);
    /* ... */

    ext2fs_close(fs);
        
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir numaraya sahip i-node elemanını elde edebilmek için ext2fs_read_inode fonksiyonu kullanılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs_read_inode(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode);

    Fonksiyonun birinci parametresi dosya sistemini temsil eden handle değeridir. İkinci parametre bilgileri elde edilecek 
    i-node elemanın numarasını belirtir. Üçüncü parametre de i-node bilgilerinin yerleştirileceği yapının adresini almaktadır. 
    Örneğin:

    if ((err = ext2fs_read_inode(fs, 13, &inode)) != 0) {
        fprintf(stderr, "cannot read inode!..\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                        183. Ders15/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diske birden fazla bağımısız dosya sisteminin (ve belki de işletm sisteminin) yüklenebilmesi için diskin mantıksal 
    bakımdan parçalara ayrılması gerekmektedir. Diskin mantıksal bakımdan parçalara ayrılmasına ise "disk bölümlemesi" 
    denilmektedir. Disk bölümlemesi aslında disk bölümlerinin hangi sektörden başlayıp kaç sektör uzunluğunda olduğunun belirlenmesi
    anlamına gelmektedir. Böylece her dosya sistemi başkasının alanına müdahale etmeden yalnızca o disk bölümünü kullanmaktadır.

    Diskteki disk bölümleri hakkında bilgileri barındıran tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. 
    Bugün için iki disk bölümleme tablo formatı kullanılmaktadır: 

    1) Klasik (legacy) MBR Disk Bölümleme Tablo Formatı
    2) Modern UEFI BIOS Sistemlerinin Kullandığı GPT (Guid Partiton Table) Formatı

    UEFI BIOS'lar GPT disk bölümleme tablosu kullanırken eski sistemler ve gömülü sistemler genel olarak klasik MBR disk 
    bölümleme tablosunu kullanmaktadır. Gömülü sistemler için oluşturduğumuz SD kartlar'daki disk bölümleme tablosu klasik 
    (legacy) disk bölümleme tablosudur. Ancak bugünkü büyük çaplı UEFI BIOS'lar önce GPT disk bölümleme tablosuna bakmakta 
    eğer onu bulamazsa klasik disk bölümleme tablosunu aramaktadır. Yani geçmişe doğru uyum korunmaya çalışılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirtitğimiz gibi disk sistemlerine okuma ve yazma işlemleri blok aygıt sürücüleri tarafından yapılmaktadır. 
    Dolayısıyla bir bir UNIX türevi sistemde her disk için "/dev" dizinin altında bir blok aygıt dosyası bulunmaktadır. Aynı 
    zamanda her disk bölümü için de bir blok aygıt dosyası bulunur. Böylece bir diskin bütünü üzerinde de yalnızca onun belli 
    bir bölümü üzerinde de çalışılabilir. Daha önceden de kullanmış olduğumuz "lsblk" komutu bize sistemimizdeki diskler ve 
    onların bölümleri hakkında bilgiler vermektedir. Örneğin çalıştığımız sistemde "lsblk"komutunu uyguladığımızda şöyle 
    bir çıktı ile karşılaşmaktayız:

    NAME MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
    loop0
        7:0    0 195,3M  0 loop /home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems/ext2
    sda    8:0    0    60G  0 disk 
    ├─sda1
    │      8:1    0     1M  0 part 
    ├─sda2
    │      8:2    0   513M  0 part /boot/efi
    └─sda3
        8:3    0  59,5G  0 part /
    sr0   11:0    1  1024M  0 rom  

    Buradaki "sda" aygıtı bir diski bütün olarak ele almak için kullanılmaktadır. Bu diskin 3 tane disk bölüme vardır. Bu 
    disk bölümleri de "sda1", "sda2" ve "sda3" aygıtlarıdır. Bu aygıtlara ilişkin "/dev" dizini altında aygıt dosyaları 
    bulunmaktadır. Örneğin:

    $ ls -l /dev/sda*
    brw-rw---- 1 root disk 8, 0 Ara  6 15:08 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ara  6 15:08 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ara  6 15:08 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ara  6 15:08 /dev/sda3

    Diskleri temsil eden isimler o diskin türüne göre değişebilmektedir. Normal hard diskler için isimlendirme "sda", "sdb", 
    "sdc" biçiminde yapılmaktadır. Bunların bölümleri de "sda1", "sda2", "sdb1, "sdb2" biçiminde yapılır. MicroSD kartlar 
    "mmcblk0", "mmcblk1", "mmcblk2" biçiminde isimlendirilmektedir. Bunların bölümleri de "mmcblk0p1", "mmcblk0p2", 
    mmcblk1p1", "mmcblk1p2" biçiminde yapılmaktadır. Eğer disk bir loop aygıtı biçimind oluşturulmuşsa disk bölümleri "loop0p1", 
    "loop0p2", "loop1p1", "loop1p2" biçiminde isimlendirilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik MBR (legacy) disk bölümlendirmesinde diskin ilk sektörüne (0 numaralı sektörüne) MBR (Master Boot REcord) sektörü 
    denilmektedir. MBR sektörünün sonundaki 2 byte MBR'nin bilinçli olarak oluşturulduğunu belirten sihirli bir sayıdan (magic 
    number) oluşmaktadır. Bu sihirli sayı hex olarak 55 AA biçimindedir. Aşağıda "loop0" aygıtı üzerinde oluştutulmuş bir MBR
    sektörü görülmektedir:

    00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  03 74 de d6 00 00 80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Sektörün sonunun 55 AA ile bittiğine dikkat ediniz. 

    Klasik MBR Disk Bölümlemesinde MBR sektörünün sonundaki 64 byte'a "Disk Bölümleme Tablosu (Disk Partition Table)" denilmektedir. 
    Tabii sektörün sonunda hex olarak 55 AA bulunduğu için disk bölümleme tablosu da bu 55 AA byte'larının hemen gerisindeki 
    64 byte'tadır. O halde MBR sektörünün sonu aşağıdaki gibidir:

    ... <64 byte (Disk Bölümleme Tablosu)>  55 AA

    Yukarıdaki MBR sektörünün son 64 byte'ı ve 55 AA değerleri aşağıda verilmiştir:

                                                         80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Başka bir deyişle Disk Bölümleme Tablosu MBR sektörünün 0x1BE (446) offset'inden başlayıp 64 byte sürmektedir. Disk Bölümleme 
    Tablosundaki her disk bölümü 16 byte ile betimlenmektedir. Dolayısıyla klasik Disk Bölümleme Tablosu 4 disk bölümünü barındırmaktadır. 
    Pekiyi bu durumda 4'ten fazla disk bölümü oluşturulamaz mı? İşte "Genişletilmiş Disk Bölümü (Extended Disk Partition)" kavramı 
    ile bu durum mümkün hale getirilmiştir. Yukarıdaki Disk Bölümle Tablosunun 16 byte'lık disk bölümleri aşağıda verilmiştr:

    80 01 01 00 83 20 0d 13  3f 00 00 00 01 b0 04 00
    00 20 0e 13 83 3e 18 26  40 b0 04 00 c0 af 04 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00

    Disk Bölümleme Tablosundaki 16 byte'lık disk bölümünün içeriği şöyledir:

    Offset (Hex)    uzunluk         Anlamı
    -------------------------------------------------------------------------------------------------
    0               1 BYTE          Disk Bölümünün Aktif Olup Olmadığı Bilgisi   
    1               3 BYTE          Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Başlangıç Sektörü 
    4               1 BYTE          Sistem ID Değeri    
    5               3 Byte          Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Bitiş Sektörü 
    8               4 BYTE (DWORD)  Disk Bölümünün LBA Sistemindeki Başlangıç Sektörü
    C               4 BYTE (DWORD)  Disk Bölümündeki Sektör Sayısı (Disk Bölümünün Uzunluğu)

    - 4 disk bölümünden yalnızca bir tanesi aktif olabilmektedir. Sistem aktif disk bölümünden boot edilmektedir. Aktif disk 
    bölümü için 0x80 değeri aktif olmayan disk bölümü için 0x00 değeri kullanılmaktadır. 

    - Eskiden diskteki bir sektörün yeri "hangi yüzde (her yüzü bir kafa okuduğu için, hangi kafada), hangi track'te (track'e 
    silindir (cylinder) de denilmektedir) ve hangi sektör diliminde olduğu bilgisiyle ifade ediliyordu. Bu koordinat sistemine
    CHS (Cylinder-Head-Sector) koordinat sistemi deniyordu. Sonra bu koordinat sisteminden vazgeçildi. Sektörün yeri ilk sektör 
    0 olmak üzere tek bir sayıyla temsil edilmeye başlandı. 

    - Her disk bölümünde farklı bir işletim sisteminin kullandığı dosya sistemi bulunuyor olabilir. "Sistem ID Değeri" o disk 
    bölümünde hangi işletim sistemine ilişkin bir dosya sisteminin bulunduğunu belirtmektedir. Böylece Disk Bölümleme Tablosunu 
    inceleyen kişiler disk bölümlerinin hangi işletim sistemi için oluşturulduğunu anlayabilmektedir. Tüm Sistem ID Değerleri 
    için bunların listelendiği dokümanlara başvurabilirsiniz. Biz burada birkaç System ID değerini verelim:

    0C: Windows FAT32 Sistemi
    0E: Windows FAT Sistemi 
    0F: Genişletilmiş Disk Bölümü
    83: Linux Dosya Sistemlerinden Birisi
    82: Linux İçin Swap Alanı Olarak Kullanılacak Disk Bölümü

    - Bir disk bölümü için en önemli iki bilgi onun diskin hangi sektöründen başlayıp kaç sektör uzunlukta olduğudur. Yani disk 
    bölümünün başlangıç sektör numarası ve toplam sektör sayısıdır. İşletim sistemleri böylece kendileri için belirlenmiş olan 
    disk bölümlerinin dışına erişmezler. Yani disk bölümleri adeta disk içerisindeki disklerin yerlerini belirtmektedir. 

    - 90'larla birlikte diskteki sektörlerin adreslenmesi için CHS sistemi yavaş yavaş bırakılmaya başlanmış LBA (Logical Block 
    Address) denilen sisteme geçilmiştir. Bu sistemde diskin ilk sektörü 0 olmak üzere her sektöre artan sırada bir tamsayı karşılık 
    düşürülmüştür. İşte bu koordinat sistemine LBA denilmektedir. Artık MBR Disk Bölümlerinde disk bölümünün başlangıç sektörü 
    LBA sistemine göre belirtilmektedir. 

    - LBA sisteminde bir disk bölümünde en fazla 2^32 tane sektör bulunabilir. Bir sektör 2^9 (512) byte olduğuna göre MBR
    Disk Bölümleme Tablosu en fazla 2^41 = 2TB diskleri destekleyebilmektedir. Gömülü sistemlerde henüz bu büyüklükte diskler 
    kullanılmadığı için klasik MBR Disk Bölümleme Tablosu iş görmektedir. Ancak masaüstü sistemlerde artık bu sınır aşılmaktadır. 
    İşte UEFI BIOS'lar tarafından kullanılan "GUID Disk Bölümlemesi (GPT)" bu sınırı çok daha ötelere taşımaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk Bölümleme Tablosu manuel bir biçimde oluşturulabilir. Ancak Disk Bölümleme Tablosu üzerinde işlem yapan çeşitli 
    araçlar da vardır. Linux sistemlerinde en yaygın kullanılan iki araç "fdisk" ve "gparted" isimli araçlardır. fdisk komut 
    satırından kullanılabilen basit bir programdır. "gparted" ise GUI arayüzü ile görsel bir biçimde aynı işlemleri yapmaktadır. 
    "fdisk" temel bir araçtır. Dolayısıyla Linux sistemleri kurulduğunda büyük olasılıkla zaten kurulmuş olarak sisteminizde 
    bulunuyor olacaktır. Ancak "gparted" programını Debian tabanlı sistemlerde aşağıdaki gibi siz kurmalısınız:

    $ sudo apt-get install gparted
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                184. Ders 22/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada Linux sistemlerindeki fdisk programının kullanımı üzerinde duracağız. Bu tür denemeleri loop aygıtları üzerinde 
    yapmalısınız. fdisk kullanımını maddeler halinde açıklayalım:

    1) Hangi disk üzerinde işlem yapılacaksa o diske ilişkin aygıt dosyası fdisk programına komut satırı argümanı olarak 
    verilmelidir. Tabii disk aygıt dosyaları "root" kullanıcısına ilişkin olduğu için fdisk programı da genellikle "sudo" 
    ile çalıştırılır. Örneğin önce blok aygıt sürücülerimize bakalım:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    ******************************************************

    Burada "sda" diski bir bütün olarak gösteren aygıt sürücüsüdür. Bu aygıt sürücüye ilişkin aygıt dosyası "/dev/sda" biçimindedir. 
    "sda1", "sda2" ve "sda5" disk üzerindeki disk bölümleridir. Bizim bölümlendirme için diski bir bütün olarak ele almamız gerekir. 
    Bu nedenle "sda" diski için fdisk programı şöyle çalıştırılmalıdır:

    $ sudo fdisk /dev/sda

    Tabi biz örneğimizde loop aygıtı kullanacağız. Bu durumda loop aygıtını şöyle kullanıma hazır hale getirebiliriz:

    ******************************************************
    $ dd if=/dev/zero of=disk.img bs=300M count=1
    1+0 kayıt girdi
    1+0 kayıt çıktı
    314572800 bytes (315 MB, 300 MiB) copied, 1,23241 s, 255 MB/s
    ******************************************************

    Buradan diski temsil eden içi sıfırlarla dolu 300MB'lik bir dosya oluşturduk. Şimdi bu dosyayı "/dev/loop0" aygıt dosyası 
    ile bir blok aygıtı gibi gösterelim:

    $ sudo losetup /dev/loop0 disk.img

    Artık "/dev/loop0" aygıt dosyası sanki bir disk gibi kullanılabilecektir. Bu aygıt üzerinde işlem yaptığımızda işlemden 
    "disk.img" dosyası etkilenecektir.

    Artık blok aygıt sürücülerine baktığımızda "loop0" aygıtını göreceğiz:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0    7:0    0  300M  0 loop
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    *****************************************************

    Artık fdisk programını bu aygıt üzerinde kullanabiliriz:

    $ sudo fdisk /dev/loop0

    2) Artık interaktif bir biçimde disk bölümlendirme işlemleri yapılabilir. Burada tek harfli çeşitli komutlar girildiğinde
    interaktif bir biçimde işlemler yapılmaktadır. Bu komutlardan önemli olanlarını açıklamak istiyoruz:

    - "n" (new) komutu yeni bir disk bölümü oluşturmak için kullanılmaktadır. Bu komut verildiğinde yaratılacak disk bölümünün 
    "primary" bölüm mü "extended" bölüm mü olduğu sorulmaktadır. Primary disk bölümü ana 4'lük girişteki bölümlerdir. Dolayısıyla
    burada genellikle "p" komutu ile "primary" disk bölümü oluşturulur. Sonra bize 4 girişten hangisinin disk bölümü olarak 
    oluşturulacağı sorulmaktadır. Bu durumda sıradaki numarayı vermek (disk tamamen ilk kez bölümlendiriliyorsa 1) uygun olur. 
    Sonra da bize ilgili disk bölümünün hangi sektörden başlatılacağı ve ne uzunlukta olacağı sorumaktadır. Aşağıda bir örnek 
    görüyorsunuz:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (0 birincil, 0 genişletilmiş, 4 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (1-4, varsayılan 1): 1
    İlk sektör (2048-614399, varsayılan 2048):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-614399, varsayılan 614399): +50M

    Yeni bir disk bölümü 1, 'Linux' tipinde ve 50 MiB boyutunda oluşturuldu.
    ***************************************************************************************

    - "p" (print) komutu oluşturulmuş olan disk bölümlerini görüntülemektedir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (montıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M 83 Linux
    **************************************************************************************

    - fdisk yaratılan disk bölümlerinin ID'sini default olarak 0x83 (Linux) yapmaktadır. Eğer disk bölümüne FAT dosya sistemi 
    yerleştirilecekse "t" (type) komutu ile bölüm ID'si değitirilmelidir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): t
    Seçilen disk bölümü 1
    Hex kod (bütün kodlar için L tuşlayın): c
    'Linux' disk bölümünün tipini 'W95 FAT32 (LBA)' olarak değiştirin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (montıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    **************************************************************************************

    Şu anda biz bir FAT disk bölümü yaratmış olduk. Şimdi ikinci Linux dosya sistemleri için ikinci bölümünü de yaratalım:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (1 birincil, 0 genişletilmiş, 3 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (2-4, varsayılan 2):
    İlk sektör (104448-614399, varsayılan 104448):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (104448-614399, varsayılan 614399):

    Yeni bir disk bölümü 2, 'Linux' tipinde ve 249 MiB boyutunda oluşturuldu.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (montıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    Artık diskimizde iki disk bölümü vardır.

    - Bir disk bölümünü aktive etmek için "a" komutu (activate) kullanılmaktadır. Örneğin biz FAT32 disk bölümünü aktif disk 
    bölümü haline getirelim:

    **************************************************************************************
    Komut (yardım için m): a
    Disk bölümü numarası (1,2, varsayılan 2): 1

    Disk bölümü 1'de önyüklenebilir bayrağı artık etkin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (montıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1 *           2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    - fdisk önce yazılacakları kendi içerisinde biriktirmekte sonra bunları diske yazmaktadır. Biriktirilenlerin diske yazılması 
    için "w" (write) komutu kullanılmaktadır. Örneğin:

    **************************************************************************************
    Komut (yardım için m): w
    Disk bölümleme tablosu değiştirildi.
    Disk bölüm tablosunu yeniden okumak için ioctl() çağrılıyor.
    Disk bölümü tablosu yeniden okunamadı.: Geçersiz bağımsız değişken

    Çekirdek hala eski tabloyu kullanıyor. Yeni tablo bir sonraki yeniden başlatma işleminden sonra ya da partprobe(8) veya 
    kpartx(8)'i çalıştırdığınızda kullanılacak.
    **************************************************************************************

    - Bir disk bölümünü silmek için "d" komutu kullanılmaktadır. Disk bölümlerini silerken dikkat ediniz.

    3) Disk bölümlerini oluşturduktan sonra çekirdeğin onları o anda görmesi için "partprobe" komutu kullanılmalıdır. Örneğin:

    **************************************************************************************
    $ sudo partprobe /dev/loop0
    [sudo] kaan için parola:
    $ lsblk
    NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0       7:0    0  300M  0 loop
    ├─loop0p1 259:0    0   50M  0 part
    └─loop0p2 259:1    0  249M  0 part
    sda         8:0    0   80G  0 disk
    ├─sda1      8:1    0  512M  0 part /boot/efi
    ├─sda2      8:2    0    1K  0 part
    └─sda5      8:5    0 79,5G  0 part /
    sr0        11:0    1 1024M  0 rom
    **************************************************************************************

    Aslında yukarıda yapılan işlemlerin sonucu olarak Disk Bölümleme Tablosu'ndaki iki giriş (32 byte) güncellenmiştir.

    5) fdisk programının başka komutları da vardır. Örneğin disk bölümlendirmesi yapıldıktan sonra bu bölümlendirme bilgileri 
    "O" komutu ile bir dosyaya aktarılabilir. Sonra "I" komutu ile bu dosyadan yükleme yapılabilir. Böylece farklı diskler 
    için aynı işlemlerin daha kolay yapılması sağlanabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux'taki sistem fonksiyonlarının nasıl çağrılacağı üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
     Linux'ta her sistem fonksiyonunun bir numarası vardır. Linux çekirdeği sistem fonksiyonlarının başlangıç adreslerini 
    bir gösterici dizisinde tutar. Bir sistem fonksiyonu çağrıldığında bu dizinin ilgi numaralı indeksindeki fonksiyonu 
    çağırır. Tabii akış sistem fonksiyonuna geçirilmeden thread'in akışı da user moddan kernel moda geçirilmektedir. Intel 
    sisteminde user moddan kernel moda geçiş 80H kesmesi yoluyla yapılmaktadır. Değişik sistemlerde bu işlemler değişik makine
    komutlarıyla yapıldığı için "libc" kütüphanesi syscall isimli bir sarma fonksiyon bulundurmuştur. Bu fonksiyona programcı 
    sistem fonksiyonunun numarasını ve parametrelerini girer. Fonksiyon sembolik makine dilinde yazılmış makine komutlarından 
    oluşmaktadır. Böylece ilgili sistemde çağrım için gereken işlemler taşınabilir bir biçimde yapılabilmektedir. syscall
    fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    long syscall(long number, ...);

    Fonksiyonun birinci parametresi sistem fonksiyonun numarasını almaktadır. Diğer parametreler ilgili sistem fonksiyonuna 
    geçirilecek argümanları almaktadır. Fonksiyonun geri dönüş değeri sistem fonksiyonuna bağlı olarak değişebilmektedir. 
    Pek çok sistem fonksiyonunda 0 başarı için kullanılmaktadır. Sistem fonksiyonlarının numaralarını Internet'te pek çok 
    yerde bulabilirsiniz. Aynı zamanda bu numaralar <sys/syscall.h> başlık dosyasında SYS_xxx biçiminde define edilmiştir. 
    Örneğin prosesi sonlandıran sys_exit isimli sistem fonksiyonun numarası 60'tır. Ancak biz bu numarayı kullanmak yerine 
    SYS_exit ismini de kullanabiliriz. SYS_exit aşağıdaki gibi define edilmiştir:

    #define SYS_exit        60  

    Aşağıda sys_exit sistem fonksiyonunun syscall fonksiyonuyla çağrılmasına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

int main(void)
{
    printf("running...\n");

    syscall(SYS_exit, 0);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bazı POSIX fonksiyonları Linux'ta doğrudan belli bir sistem fonksiyonunu çağırmaktadır.
    Örneğin open POSIX fonksiyonu Linux'ta doğrudan sys_open isimli sistem fonksiyonunu, read, write ve close POSIX fonksiyonları 
    doğrudan sys_read, sys_write ve sys_close sistem fonksiyonlarını, exit POSIX fonksiyonu sys_exit sistem fonksiyonunu çağırmaktadır. 
    GNU "libc" kütüphanesinde bazı sistem fonksiyonları için POSIX standartlarında olmayan sarma fonksiyonlar da bulundurulmuştur. 
    Ancak bazı sistem fonksiyonlarını çağıran POSIX fonksiyonları da sarma fonksiyonlar da yoktur. Bu tür durumlarda ilgili 
    sistem fonksiyonu numara belirtilerek syscall fonksiyonuyla çağrılabilir. 

    Aşağıdaki örnekte openi read ve close POSIX fonkssiyonları yerine doğrudan Linux'taki sistem fonksiyonları çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
    int fd;
    char buf[10];
    long result;

    if ((fd = syscall(SYS_open, "sample.c", O_RDONLY)) == -1) {
        perror("SYS_open");
        exit(EXIT_FAILURE);
    }

    if ((result = syscall(SYS_read, fd, buf, 10)) == -1) {
        perror("SYS_read");
        exit(EXIT_FAILURE);
    }
    buf[result] = '\0';
    puts(buf);

    if ((result = syscall(SYS_close, fd)) == -1) {
        perror("SYS_read");
        exit(EXIT_FAILURE);
    }
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux kaynak kodlarının derlenmesi ve sistemin yeni çekirdekle açılması üzerinde duracağız. Çekirdek kodlarının
    derlenmesi tüm Linux sistemleri için aynı biçimde yapılmaktadır. Ancak sistemin yeni çekirdekle açılması kullanılan "boot 
    loader" programın ayarlarıyla ilgilidir. Bugün masaüstü bilgisayarlarında ağırlıklı olarak GRUB isimli boot lader 
    kullanılmaktadır. Biz burada bu nedenle sürecin GRUB'ta nasıl yürütüleceğini ele alacağız. Gömülü sistemlerde ise ağırlıklı 
    olarak U-Boot denilen boot loader kullanılmaktadır. Biz kursumuzda U-Boot hakkında bir açıklama yapmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                        185. Ders Ders 26/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin çekirdeklerini belleğe yükleyip kontrolün çekirdek kodlarına bırakılmasını sağlayan araçlara 
    "önyükleyici (boot loader)" denilmektedir. Microsoft Windows sistemlerinde kendi önyükleyici programını kullanmaktadır. 
    Buna "Windows Boot Manager" ya da kısaca "bootmgr" de denilmektedir. UNIX/Linux dünyasında çeşitli önyükleyici programlar
    kullanılmıştır. Halen en yaygın kullanılan önyükleyici program "grub" isimli programdır. Tabii "grub" aynı zamanda Windows 
    işletim sistemini de yükleyebilmektedir. Grub önyükleyicisinden önce Linux sistemlerinde uzun bir süre "lilo" isimli 
    önyükleyici kullanılmıştır. Gömülü sistemlerde de çeşitli önyükleyiciler kullanılabilmektedir. Bazı gömülü sistemlerde 
    o gömülü sistemi üreten kurum tarafından oluşturulmuş olan önyükleyiciler kullanılmaktadır. Ancak gömülü sistemlerde en 
    çok kullanılan önyükleyici "U-Boot" isimli önyükleyicidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nasıl C'deki main fonksiyonuna komut satırı argümanları geçiriliyorsa işletim sistemi çekirdeklerine de çeşitli biçimlerde 
    parametreler geçirilebilmektedir. Böylece çekirdek belli bir konfigürasyonla işlev görecek biçimde başlatılabilmektedir.
    Linux çekirdeğini önyükleyici yüklediğine göre çekirdek parametreleri de önyükleyici tarafından çekirdeğe aktarılmaktadır. 
    Linux'ta bu parametreler "grub" önyükleyicisinin başvurduğu dosyalarda belirtilmektedir. Grub önyükleyicisinin kullanımı
    biraz ayrıntılıdır. Ancak biz burada "grub" işlemlerini daha basit ve görsel biçimde yapabilmek için "grub-customizer" 
    isimli bir programdan faydalanacağız. Bu programı Debian türevi sistemlerde aşağıdaki gibi yükleyebilirsiniz:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update
    $ sudo apt-get install grub-customizer

    Pekiyi neden işletim sistemini yüklemek için ayrı bir programa gereksinim duyulmuştur? Eskiden işletim sistemleri doğrudan
    BIOS kodları tarafındna yüklenebiliyordu. Ancak zamanla işletim sistemleri parametreler alacak biçimde geliştirildi. 
    Önyükleyiciler birden fazla çekirdeğin bulunduğu durumlarda basit ayarlarla sistem yöneticisinin istediği çekirdekle 
    boot işlemini yapabilmektedir. Diskte birden fazla işletim sisteminin bulunduğu durumlarda sistemin istenilen bir işletim 
    sistemi tarafından boot edilmesini sağlayabilmektedir. Örneğin makinemizde hem Windows hem de Linux aynı anda bulunuyor 
    olabilir. Önyükleyicimiz bize bir menü çıkartıp hangi işletim sistemi ile boot işlemini yapmak istediğimizi sorabilir. 
    Eskiden nispeten basit olan boot prosedürleri zamanla daha karmaşık hale gelmiştir. Önyükleyici programlara gereksinim 
    duyulmaya başlanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Pekiyi neden biz Linux çekirdeğini kaynak kodlardan yeniden derlemek isteyebiliriz? İşte bunun tipik nedenleri şunlar 
   olabilir:

    - Bazı çekirdek modüllerinin ve aygıt sürücülerinin çekirdek imajından çıkartılması ve dolayısıyla çekirdeğin küçültülmesi 
    için.
    - Yeni birtakım modüllerin ve aygıt sürücülerin çekirdek imajına eklenmesi için.
    - Çekirdeğe tamamen başka özelliklerin eklenmesi için.
    - Çekirdek üzerinde çekirdek parametreleriyle sağlanamayacak bazı konfigürasyon değişikliklerinin yapılabilmesi için.
    - Çekirdek kodlarında yapılan değişikliklerin etkin hale getirilmesi için.
    - Çekirdeğe yama (patch) yapılması için.
    - Yeni çıkan çekirdek kodlarının kullanılabilir hale getirilmesi için.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için öncelikle çekirdek kaynak kodlarının derlemenin yapılacağı bilgisayara indirilmesi gerekir. Pek 
    çok dağıtım default durumda çekirdeğin kaynak kodlarını kurulum sırasında makineye çekmemektedir. Çekirdek kodları "kernel.org"
    sitesinde bulundurulmaktadır. Tarayıcdan "kernel.org" sitesine girerek "pub/linux/kernel" dizinine geçtiğinizde tüm yayınlanmış
    çekirdek kodlarını göreceksiniz. İndirmeyi tarayıcıdan doğrudan yapabilirsiniz. Eğer indirmeyi komut satırından "wget" 
    programıyla yapmak istiyorsanız aşağıdaki URL'yi kullanabilirsiniz:

    https://cdn.kernel.org/pub/linux/kernel/v[MAJOR_VERSION].x/linux-[VERSION].tar.xz

    Buradaki MAJOR_VERSION "3", "4", "5" gibi tek bir sayıyı belirtmektedir. VERSION ise çekirdek büyük ve küçük numaralarını 
    belirtmektedir. Örneğin biz çekirdeğin 5.15.12 versiyonunu şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.15.12.tar.xz

    Örneğin çekirdeğin 6.8.1 versiyonunu da şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.1.tar.xz
   
   Çekirdek kodları indirildikten sonra onun açılması gerekir. Açma işlemi "tar" komutuyla aşağıdaki gibi yapılabilir:

    $ tar -xvJf linux-5.15.12.tar.xz

    Debian tabanlı sistemlerde o anda makinede yüklü olan mevcut çekirdeğin kaynak kodlarını indirmek için aşağıdaki komutu 
    kullanabilirsiniz:

    $ sudo apt-get install linux-source

    Burada yükleme "/usr/src" dizinine yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux kaynak kodlarının versiyonlanması eskiden daha farklıydı. Cekirdeğin 2.6 versiyonundan sonra versiyon numaralandırma 
    sistemi değiştirilmiştir. Eskiden (2.6 ve öncesinde) versiyon numaraları çok yavaş ilerletiliyordu. 2.6 sonrasındaki yeni 
    versiyonlamada versiyon numaraları daha hızlı ilerletilmeye başlanmıştır. Bugün kullanılan Linux versiyonları nokta ile 
    ayrılmış üç sayıdan oluşmaktadır:

    Majör.Minör.Patch-Extra (-rcX, -stable, -custom, -generic)

    Buradaki "majör numara" büyük ilerlemeleri "minör numara" ise küçük ilerlemeleri belirtmektedir. Eskiden (2.6 ve öncesinde) 
    tek sayı olan minör numaralar "geliştirme versiyonlarını (ya da beta versiyonlarını)", çift olanlar ise stabil hale ggetirilmiş 
    dağıtılan versiyonları belirtiyordu. Ancak 2.6 sonrasında artık tek ve çift minör numaralar arasında böyle bir farklılık 
    kalmamıştır. Patch numarası birtakım böceklerin ya da çok küçük yeniliklerin çekirdeğe dahil edildiği versiyonları belirtmektedir. 
    Bu bağlamda minör numaralardan daha küçük bir ilerlemenin söz konusu olduğunu anlatmaktadır. Burada Extra ile temsil edilen 
    alanda "rcX (X burada bir sayı belirtir) "stable", "custom", "generic", "realtime" gibi sözcükler de bulunmaktadır. "rc" 
    harfleri "release candidate" sözcüklerin kısaltmadır. Satabil sürümün öncesindeki son geliştirme sürümlerini belirtmektedir. 
    "stable" sözcüğü dağıtılan kararlı sürümü belirtir. Eğer sistem programcısı çekirdekte kendisi birtakım değişiklikler yapmışsa 
    genellikle bunun sonuna "custom" sözcüğünü getirir. Tabii bu "custom" sözcüğünü ayrıca "-<custom_version_number>" biçiminde 
    numaralar da izleyebilir. Buradaki numaralar sistem programcısının kendi özelleştirmesine ilişkin numaralardır. "generic" 
    sözcüğü ise genel kullanım için yapılandırılmış bir çekirdek olduğunu belirtmektedir. "realtime" yapılandırmanın gerçek 
    zamanlı sistem özelliği kazandırmak için yapıldığını belirtmektedir. "generic" ve "realtime" sözcüklerinin öncesinde "-N-" 
    biçiminde bir sayı da bulunabilmektedir. Bu sayı "dağıtıma özgü yama ya da derleme numarasını belirtmektedir.
    
    Çalışmakta olan Linux sistemi hakkında bilgiler "uname -a" komutu ile elde edilebilir. Örneğin:

    $ uname -a
    inux kaan-virtual-machine 5.15.0-91-generic #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

    Bu bilgi içerisindeki çekirdek versiyonu "uname -r" ile elde edilebilir:

    $ uname -r
    5.15.0-91-generic

    Buradan biz çekirdeğin "5.15.0" sürümünün kullanıldığını anlıyoruz. Burada genel yapılandırılmış bir çekirdek söz konusudur. 
    91 sayısı dağıtıma özgü yama ya da derleme numarasını belirtir.

    Aslında "uname" komutu bu bilgileri "/proc" dosya sisteminin içerisinde almaktadır. Örneğin:

    $ cat /proc/version
    Linux version 5.15.0-91-generic (buildd@lcy02-amd64-045) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld 
    (GNU Binutils for Ubuntu) 2.38) #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için zaten çekirdek kodlarında bir "build sistemi" oluşturulmuştur. Buna "KConfig sistemi" ya da 
    "KBuild sistemi" denilmektedir. Biz önce çekirdek derleme işleminin hangi adımlardan geçilerek yapılacağını göreceğiz. 
    Sonra çekirdeğin önemli konfigürasyon parametreleri üzerinde biraz duracağız. Sonra da çekirdekte bazı değişiklikler yapıp
    değiştirilmiş çekirdeği kullanacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdeğin davranışını değiştirmek için farklı olanaklara sahip 5 yöntem kullanılabilmektedir:

    1) Çekirdeğin boot parametreleri yoluyla davranışının değiştirilmesi. Bunun için çekirdeğin yeniden derlenmesi gerekmez.

    2) Kernel mode aygıt sürücüsü yazmak yoluyla çekirdeğin davranışının değiştirilmesi. Bunun çekirdek kodlarının yeniden 
    derlenmesi gerekmez.

    3) Çekirdeğin konfigürasyon parametrelerinin değiştirilmesiyle davranışının değiştirilmesi. Bunun için çekirdeğin yeniden 
    derlenmesi gerekir. 

    4) Çekirdeğin kodlarının değiştirilmesiyle davranışının değiştirilmesi. Bunun için de çekirdeğin yeniden derlenmesi gerekir. 

    5) Çekirdeğin bazı özellikleri "proc" dosya sistemindeki bazı dosyalara birtakım değerler yazarak da değiştirilebilmektedir.
    Aslında bu tür değişiklikler "systemd" init sisteminde "systemctl" komutuyla da yapılabilmektedir. Örneğin sistem çalışırken 
    bir prosesin açabileceği dosya sayısını "proc" dosya sistemi yoluyla şöyle değiştirebiliriz:

    $ echo 2048 | sudo tee /proc/sys/fs/file-max
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdek derlemesi tipik olarak aşağıdaki aşamalardan geçilerek gerçekleştirilmektedir:

    1) Derleme öncesinde derlemenin yapılacağı makinede bazı programların yüklenmiş olması gerekmektedir. Gerekebilecek tipik 
    programlar aşağıda verilmiştir:

    $ sudo apt update
    $ sudo apt install build-essential libncurses-dev bison flex libssl-dev wget gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf libelf-dev dwarves

    2) Çekirdek kodları indirilerek açılır. Biz bu konuyu yukarıda ele almıştık. İndirmeyi şöyle yapanbiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.9.2.tar.xz 
    
    Bu işlemden sonra "linux-6.9.2.tar.xz" isimli dosya indirilmiş durumdadır. Onu aşağıdaki gibi açabiliriz:

    $ tar -xvJf linux-6.9.2.tar.xz 

    Bu işlemden sonra "linux-6.9.2" isminde bir dizin oluşturulacaktır. 

    Ayıca ek bir bilgi olarak eğer Ubuntu türevi bir dağıtımda çalışıyorsanız istediğniz bir çekirdeği aşağıdaki gibi indirip 
    kurabilirsiniz:

    sudo apt install linux-image-<çekirdek_sürümü>

    Örneğin:

    $ sudo apt install linux-image-5.15.0-91-generic 

/*--------------------------------------------------------------------------------------------------------------------------
                                            186. Ders Ders 31/01/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/
    3) Çekirdek derlenmeden önce konfigüre edilmelidir. Çekirdeğin konfigüre edilmesi birtakım çekirdek özelliklerin belirlenmesi 
    anlamına gelmektedir. Konfigürasyon bilgileri çekirdek kaynak kod ağacının kök dizininde (örneğimizde "linux-6.9.2" dizini) 
    ".config" ismiyle bulunmalıdır. Bu ".config" dosyası default durumda kaynak dosyaların kök dizininde bulunmamaktadır. Bunun 
    çekirdeği derleyen kişi tarafından oluşturulması gerekmektedir. Çekirdek konfigürasyon parametreleri oldukça fazladır. Biz 
    izleyen paragraflarda önemli çekirdek konfigürasyon parametrelerini göreceğiz. Çekirdek konfigürasyon parametreleri çok 
    fazla olduğu için bunlar bazı genel amaçları karşılayacak biçimde default değerlerle önceden oluşturulmuş durumdadır. Bu 
    önceden oluşturulmuş default konfigürasyon dosyaları "arch/<mimari>/configs" dizininin içerisinde bulunmaktadır. Örneğin 
    Intel X86 mimarisi için bu default konfigürasyon dosyaları şöyledir:

    $ ls arch/x86/configs
    hardening.config  i386_defconfig  tiny.config  x86_64_defconfig  xen.config

    Burada biz 64 bit Linux sistemleri için "x86_64_defconfig" dosyasını kullanabiliriz. O halde bu dosyayı kaynak dosyaların 
    bulunduğu dizininin kök dizinine ".config" ismiyle kopyalayabiliriz:

    $ cp arch/x86/configs/x86_64_defconfig .config

    Biz bütün işlemlerde çekirdek kaynak kodlarının kök dizininde bulunduğumuzu (current working directory) varsayacağız. Ancak 
    burada bir noktaya dikkatinizi çekmek istiyoruz. Linux kaynak kodlarındaki default konfigürasyon dosyaları minimal biçimde
    konfigüre edilmiştir. Bu nedenle pek çok modül bu default konfigürasyon dosyalarında işaretlenmiş değildir. Bu default 
    konfigürasyon dosyalarını kullanarak derleme yaptığınızda bazı çekirdek modüllerinin seçilmemiş olması nedeniyle sisteminiz 
    açılmayabilir. Bu tür denemeleri zaten var olan konfigürasyon dosyalarını kullanarak yaparsanız daha fazla modül dosyası 
    oluşturulabilir ancak daha az zahmet çekebilirsiniz. Linux sistemlerinde genel olarak "/boot" dizini içerisinde 
    "configs-<çekirdek_sürümü>" ismi altında mevcut çekirdeğe ilişkin konfigürasyon dosyası bulundurulmaktadır.  

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Çekirdek kaynak kodlarındaki "arch/<paltform>/configs/x86_64_defconfig" 
    dizinindeki konfigürasyon dosyası ".config" ismiyle kopyalandıktan sonra ayrıca "make menuconfig" gibi bir işlemle onun 
    satırlarına bazı default değerlerin de eklenmesi gerekir. Bu default değerler "arch/<platform>" dizinindeki "Kconfig" dosyasından 
    gelmektedir. Bu nedenle bu default konfigürasyon dosyalarını kaynak kök dizine ".config" ismiyle kopyaladıktan sonra 
    aşağıda belirtildiği gibi "make menuconfig" yapmalısınız. 

    Aslında ".config" dosyasını oluşturmanın başka alternatif yolları da vardır:

    make defconfig: Bu komut çalıştığımız sisteme uygun olan konfigürasyon dosyasını temel alarak mevcut donanım bileşenlerini 
    de gözden geçirerek sistemin açılması için gerekli minimal bir konfigürasyon dosyasını ".config" ismiyle oluşturmaktadır. Örneğin 
    biz 64 bit Intel sistemine ilişkin bir bilgisayarda çalışıyorsak "make defconfig" dediğimizde "arch/x86/configs/x86_64_defconfig" 
    dosyası temel alınarak o anda çalışılmakta olan çekirdek donanımları da dikkate alınarak nispeten minimal olan bir konfigürasyon
    dosyası oluşturmaktadır.

    make oldconfig: Bu seçeneği kullanmak için kaynak kök dizinde bir ".config" dosyasının bulunyor olması gerekir. Ancak bu 
    seçenek KConfig dosyasındaki ve kaynak dosya ağacındaki diğer değişiklikleri de göz önüne alarak bu eski ".config" dosyasını 
    eğer söz konusu mimaride birtakım değişiklikler söz konusu ise o değişikliklere uyumlandırmaktadır. Yani örneğin biz eski
    bir ".config" dosyasını kullanıyor olabiliriz. Ancak çekirdeğin yeni versiyonlarında ek birtakım başka konfigürasyon parametreleri 
    de eklenmiş olabilir. Bu durumda "make oldconfig" bize bu eklenenler hakkında da bazı sorular sorup bunların dikkate alınmasını 
    sağlayacaktır. 

    make <platform>_defconfig: Bu seçenek belli bir platformun default konfig dosyasını ".config" dosyası olarak save etmektedir. 
    Örneğin biz Intel makinelerinde çalışıyor olabiliriz ancak BBB için default konfigürasyon dosyası oluşturmak isteyebiliriz. 
    Eğer biz "make defconfig" yaparsak Intel tabanlı bulunduğumuz platform dikkate alınarak ".config" dosyası oluşturulur. Ancak 
    biz burada örneğin "make bb.org_defconfig" komutunu uygularsak bu durumda Intel mimarisinde çalışıyor olsak da "bb.org_defconfig"
    konfigürasyon dosyası ".config" olarak save edilir. Tabii bu durumda biz aslında yine ilgili platformun konfigürasyon dosyasını 
    manuel olarak ".config" biçiminde de kopyalayabiliriz. 

    make modules: Bu seçenek ile yalnızca modüller derlenir. Yani bu seçenek ".config" dosyasında belirtilen aygıt sürücü dosyalarını 
    derler ancak çekirdek derlemesi yapmaz. Yalnızca "make" işlemi zaten aynı zamanda bu işlemi de yapmaktadır. 

    Aşağıdaki ilave konfig seçenekleri ise seyrek kullanılmaktadır:

    make allnoconfig: Tüm seçenekleri hayır (no) olarak ayarlar (minimal yapılandırma).
    make allyesconfig: Tüm seçenekleri evet (yes) olarak ayarlar (maksimum özellikler).
    make allmodconfig: Tüm aygıt sürücülerin çekirdeğin dışında modül (module) biçiminde derleneceğini belirtir.
    make localmodconfig: Sistemde o anda yüklü modüllere dayalı bir yapılandırma dosyası (".config" dosyası) oluşturur.
    make silentoldconfig: Yeni seçenekler için onları görmezden gelir ve o yeni özellikler ".config" dosyasına yansıtılmaz.
    make dtbs: Kaynak kod ağacında "/arch/platform/boot/dts" dizininideki aygıt ağacı kaynak dosyalarını derler ve "dtb" 
    dosyalarını elde eder. Gömülü sistemlerde bu işlemin yapılması ve her çekirdek versiyonuyla o versiyonun "dtb" dosyasının 
    kullanılması tavsiye edilir. 

    Yukarıda da belirttiğimiz gibi aslında pek çok dağıtım o anda yüklü olan çekirdeğe ilişkin konfigürasyon dosyasını "/boot" 
    dizini içerisinde "config-$(uname -r)" ismiyle bulundurmaktadır. Örneğin kursun yapılmakta olduğu Mint datıtımında "/boot" 
    dizinin içeriği şöyledir:

    $ ls /boot
    config-5.15.0-91-generic  grub        initrd.img-5.15.0-91-generic  vmlinuz
    efi                       initrd.img  System.map-5.15.0-91-generic  vmlinuz-5.15.0-91-generic

    Buradaki "config-5.15.0-91-generic" dosyası çalışmakta olduğumuz çekirdekte kullanılan konfigürasyon dosyasıdır. Benzer biçimde 
    BBB'deki built-in eMMC içerisinde bulunan çekirdekteki "/boot" dizininin içeriği de şöyledir:

    SOC.sh                      dtbs                System.map-5.10.168-ti-r71  
    initrd.img-5.10.168-ti-r71  uboot               config-5.10.168-ti-r71       
    vmlinuz-5.10.168-ti-r71

    Buradaki konfigürasyon dosyası da "config-5.10.168-ti-r71" biçimindedir. 

    Eğer çalışılan sistemdeki konfigürasyon dosyasını temel alacaksanız bu dosyayı Linux kaynak kodlarının bulunduğu kök dizine 
    ".config" ismiyle kopyalayabilirsiniz. Örneğin:

    $ cp /boot/config-$(uname -r) .config

    Fakat eski bir konfigürasyon dosyasını yemni bir öçekirdekle kullanmak için ayrıca "make oldconfig" işleminin de yapılması 
    gerekmektedir. 

    4) Şimdi elimizde pek çok değerin set edilmiş olduğu ".config" isimli bir konfigürasyon dosyası vardır. Artık bu konfigürasyon 
    dosyasından hareketle yalnızca istediğimiz bazı özellikleri değiştirebiliriz. Bunun için "make menuconfig" komutunu kullanabiliriz:
    
    $ make menuconfig

    Bu komut ile birlikte grafik ekranda konfigürasyon seçenekleri listelenecektir. Tabii buradaki seçenekler default değerler 
    almış durumdadır. Bunların üzerinde değişiklikler yaparak ".config" dosyasını save edebiliriz. Aslında "make menuconfig" 
    işlemi hiç ".config" dosyası oluşturulmadan doğrudan da yapılabilmektedir. Bu durumda hangi sistemde çalışılıyorsa o sisteme 
    özgü default config dosyası temel alınmaktadır. Biz en azından "General stup/Local version - append to kernel release" 
    seçeneğine "-custom" gibi bir sonek girmenizi böylece yeni çekirdeğe "-custom" soneki iliştirmenizi tavsiye ederiz. 

    ".config" dosyası elde edildiğinde çekirdek imzalamasını ortadan kaldırmak için dosyayı açıp aşağıdaki özellikleri belirtildiği 
    gibi değiştirebilirsiniz (bunların bazıları zaten default durumda aşağıdaki gibi dde olabilir):
    
    CONFIG_SYSTEM_TRUSTED_KEYS="" 
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    CONFIG_SYSTEM_TRUSTED_KEYRING=n
    CONFIG_SECONDARY_TRUSTED_KEYRING=n

    CONFIG_MODULE_SIG=n
    CONFIG_MODULE_SIG_ALL=n
    CONFIG_MODULE_SIG_KEY=""

    Çekirdek imzalaması konusu daha ileride ele alınacaktır.

    Yukarıda a belirttiğimiz gibi derlenecek çekirdeklere yerel bir versiyon numarası da atanabilmektedir. Bu işlem Bu işlem 
    "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak ya da ".config" 
    dosyasında "CONFIG_LOCALVERSION" kullanılarak yapılabilir. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Artık çekirdek sürümüne "-custom" sonekini eklemiş olduk.
    
    5) Derleme işlemi için "make" komutu kullanılmaktadır. Örneğin:

    $ make

    Eğer derleme işleminin birden fazla CPU ile yapılmasını istiyorsanız "-j<cpu_sayısı>" seçeneğini komuta dahil edebilirsiniz. 
    Çalışılan sistemdeki CPU sayısının "nproc" komutuyla elde edildiğini anımsayınız:

    $ make -j$(nproc)

    Derleme işlemi bittiğinde ürün olarak biz "çekirdek imajını", "çekirdek tarafından yüklenecek olan modül dosyalarını (aygıt 
    sürücü dosyalarını)" ve diğer bazı dosyaları elde etmiş oluruz. Derleme işleminden sonra elde oluşturulan dosyalar ve
    onların yerleri şöyledir (buradaki <çekirdek_sürümü> "uname -r" ile elde edilecek değeri belirtiyor):

    - Sıkıştırılmış Çekirdek Imajı: "arch/<platform>/boot" dizininde "bzImage" ismiyle oluşturulmaktadır. Denemeyi yaptığımız Intel makinede 
    dosyanın yol ifadesi "arch/x86_64/boot/bzImage" biçimindedir. 

    - Çekirdeğin Sıkıştırılmamış ELF İmajı: Kaynak kök dizininde "vmlinux" isminde dosya biçiminde ooluşturulur.

    - Çekirdek Modülleri (Aygıt Sürücü Dosyaları): "drivers" dizininin altındaki dizinlerde ve "fs" dizininin altındaki dizinlerde 
    ve "net" dizininin altındaki dizinlerde. Ancak "make modules_install" ile bunların hepsi belirli bir dizine çekilebilir.
    
    Çekirdek Sembol Tablosu: Kaynak kök dizininde "System.map" ismiyle bulunuyor.    

    Çekirdeğin derlemesi ne kadar zaman almaktadır? Şüphesiz bu derlemenin yapıldığı makineye göre değişebilir. Ancak derleme sürecinin
    uzamasına yol açan en önemli etken çekirdek konfigüre edilirken çok fazla modülün seçilmesidir. Pek çok dağıtım "belki lazım
    olur" gerekçesiyle konfigürasyon dosyalarında pek çok modülü dahil etmektedir. Bir dağıtımın konfigürasyon dosyasını kullandığınız 
    zaman çekirdek derlemesi uzayacaktır. Ayrıca çekirdek konfigüre edilirken çok fazla modülün dahil edilmesi modüllerin çok fazla 
    yer kaplamasına da yol açabilmektedir. Çekirdek kodlarındaki platforma özgü default konf,gürasyon dosyaları daha minimalist 
    bir biçimde oluşturulmuş durumdadır. 

    6) Derleme sonrasında farklı dizinlerde oluşturulmuş olan aygıt sürücü dosyalarını (modülleri) belli bir dizine kopyalamak 
    için "make modules_install" komutu kullanılmaktadır. Bu komut seçeneksiz kullanılırsa default olarak "/lib/modules/<çekirdek_sürümü>"
    dizinine kopyalama yapar. Her ne kadar bu komut pek çok ".ko" uzantılı aygıt sürücü dosyasını hedef dizine kopyalıyorsa 
    da bunların hepsi çekirdek tarafından belleğe yüklenmemektedir. Çekirdek gerektiği zaman gereken aygıt sürücüleri bu dizinden 
    alarak yüklemektedir. Örneğin:

    $ sudo make modules_install

    Aslında "make modules_install" komutunun modül dosyalarını (aygıt sürücü dosyalarını) istediğimiz bir dizine kopyalamasını 
    da sağlayabiliriz. Bunun için INSTALL_MOD_PATH komut satırı argümanı kullanılmaktadır. Örneğin:

    $ sudo INSTALL_MOD_PATH=modules make modules_install

    Burada aygıt sürücü dosyaları "/lib/modules/<çekirdek_sürümü>" dizinine değil bulunulan yerdeki "modules" dizinine 
    kopyalanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi "make modules_install" komutu yalnızca modül dosyalarını mı hedef dizine kopyalıyor? Hayır aslında bu komut modül 
    dosyalarının kopyalanması dışında bazı dosyaları da  oluşturup onları da hedef dizine kopyalamaktadır. Bu komut sırasıyla 
    şunları yapmaktadır:

    - Modül dosyalarını "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.dep" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.alias" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.order" isimli dosyayı oluşturur ve "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.builtin" isimli dosyayı "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.

    Aslında burada oluşturulan dosyaların bazıları mutlak anlamda bulunmak zorunda değildir. Ancak sistemin öngörüldüğü gibi 
    işlev göstermesi için bu dosyaların ilgili dizinde bulunması uygundur. 

    Bir aygıt sürücü başka bir aygıt sürücüleri de kullanıyor olabilir. Bu durumda bu aygıt sürücü yüklenirken onun kullandığı
    tüm sürücülerin özyinelemeli olarak yüklenmesi gerekir. İşte "modules.dep" dosyası bir aygıt sürücünün yüklenmesi için 
    başka hangi sürücülerin yüklenmesi gerektiği bilgisini tutmaktadır. Aslında "modules.dep" bir text dosyadır. Bu text dosya"
    satırlardan oluşmaktadır. Satırların içeriği şöyledir:

    <modül_yolu>: <bağımlılık> <bağımlılık2> ...

    Dosyanın içeriğine şöyle örnek verebiliriz:

    ...
    kernel/arch/x86/crypto/nhpoly1305-sse2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/nhpoly1305-avx2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/curve25519-x86_64.ko.zst: kernel/lib/crypto/libcurve25519-generic.ko.zst
    ...

    Eğer bu "modules.dep" dosyası olmazsa bu durumda "modeprob" komutu çalışmaz ve çekirdek modülleri yüklenirken eksik 
    yükleme yapılabilir. Dolayısıyla sistem düzgün bir biçimde açılmayabilir. Eğer bu dosya elimizde yoksa ya da bir biçimde
    silinmişse bu dosyayı yeniden oluşturabiliriz. Bunun için "dempmod -a" komutu kullanılmaktadır. Komut doğrudan kullanıldığında 
    o anda çekirdek sürümü için "modules.dep" dosyasını oluşturmaktadır. Örneğin:
    
    $ sudo depmod -a

    Ancak siz yüklü olan başka bir çekirdek sürümü için "modules.dep" dosyasını oluşturmak istiyorsanız bu durumda çekirdek 
    sürümünü de komut satırı argümanı olarak aşağıdaki gibi komuta vermelisiniz:

    $ sudo depmod -a <çekirdek sürümü>

    Tabii depmod komutunun çalışabilmesi için "/lib/modules/<çekirdek_sürümü> dizininde modül dosyalarının bulunuyor olması gerekir. 
    Çünkü bu komut bu dizindeki modül dosyalarını tek tek bulup ELF formatının ilgili bölümlerine bakarak modülün hangi modülleri 
    kullandığını tespit ederek "modules.dep" dosyasını oluşturur.

    "modules.alias" dosyası belli bir isim ya da id ile aygıt sürücü dosyasını eşleştiren bir text dosyadır. Bu dosyanın 
    bulunmaması bazı durumlarda sorunlara yol açmayabilir. Ancak örneğin USB port'a bir aygıt takıldığında bu aygıta ilişkin 
    aygıt sürücünün hangisi olduğu bilgisi bu dosyada tutulmaktadır. Bu durumda bu dosyanın olmayışı aygıt sürücünün yüklenememesine
    neden olabilir. Dosyanın içeriği aşağıdaki formata uygun satırlardan oluşmaktadır:

    alias <tanımlayıcı> <modül_adı>

    Örnek bir içerik şöyle olabilir:

    ...
    alias usb:v05ACp*d*dc*dsc*dp*ic*isc*ip*in* apple_mfi_fastcharge
    alias usb:v8086p0B63d*dc*dsc*dp*ic*isc*ip*in* usb_ljca
    alias usb:v0681p0010d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v0681p0005d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v07C0p1506d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    alias usb:v07C0p1505d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    ...

    Bu dosya bir biçimde silinirse yine "depmod" komutu ile oluşturulabilir. (Yani depmod komutu yalnızca "modules.dep" dosyasını
    değil bu dosyayı da oluşturmaktadır.)

    "modules.order" dosyası aygıt sürücü dosyalarının yüklenme sırasını barındıran bir text dosyadır. Bu dosyanın her satırında 
    bir çekirdek aygıt ssürücüsünün dosya yol ifadesi bulunur. Daha önce yazılmış aygıt sürücüler daha sonra yazılanlardan 
    daha önce yüklenir. Bu dosyanın olmaması genellikle bir soruna yol açmaz. Ancak modüllerin belli sırada yüklenmemesi 
    bozukluklara da neden olabilmektedir. Bu dosyanın da silinmesi durumunda yine bu dosya da "depmod" komutuyla oluşturulabilmektedir.

    7) Eğer gömülü sistemler için derleme yapıyorsanız kaynak kod ağacındaki "arch/<platform>/boot/dts" dizini içerisindeki aygıt
    ağacı kaynak dosyalarını da derlemelisiniz. Tabii elinizde zaten o versiyona özgü aygıt dosyası bulunuyor olabilir. Bu durumda 
    bu işlemi hiç yapmayabilirsiniz. Aygıt ağacı kaynak dpsyalarını derlemek için "make dtbs" komutunu kullanabilirsiniz:

    $ make dtbs

    Derlenmiş aygıt ağacı dosyaları "arch/<platform>/boot/dts" dizininde oluşturulacaktır.

    8) Bizim çekirdek imajını, geçici  kök dosya sistemine ilişkin dosyayı ve aygıt ağacı dosyasını uygun yere yerleştirmemiz 
    gerekir. Bu dosyalar "/boot" dizini içerisinde bulunmalıdır. Ancak aslında bu işlem de "make install" komutuyla otomatik 
    olarak yapılabilmektedir. "make install" komutu aynı zamanda "grub" isimli bootloder programın konfigürasyon dosyalarında da 
    güncelleme yapıp yeni çekirdeğin "grub" menüsü içerisinde görünmesini de sağlamaktadır. Komut şöyle kullanılabilir:

    $ sudo make install

    Bu komut ile sırasıyla yapılanlar şunlardır:

    - Çekirdek imaj dosyası "arch/<platform>/boot/bzImage" hedef "/boot" dizinine "vmlinuz-<çekirdek_sürümü>" 
    ismiyle kopyalanır.
    - "System.map" dosyası hedef "/boot" dizinine "System.map-<çekirdek_sürümü>" ismiyle kopyalanır.
    -  ".config" dosyası "/boot" dizinine "config-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "Geçici kök dosya sistemi dosyası oluşturulur ve hedef "/boot" dizinine "initrd.img-<çekirdek_sürümü>" ismiyle kopyalanır.
    - Eğer "grub" boot loader kullanılıyorsa "grub" konfigürasyonu güncellenir ve "grub"" menüsüne yeni girişler eklenir. Böylece
    sistemin otomatik olarak yeni çekirdekle açılması sağlanır.

    Yukarıda da belirttiğimiz gibi derleme işlemi sonucunda elde edilmiş olan dosyaların hedef sistemde bazı dizinlerde bulunuyor 
    olması gerekir. Bu yerleri bir kez daha belirtmek istiyoruz:

    - Çekirdek Imajı ---> "/boot" dizinine
    - Çekirdek Sembol Tablosu ---> "/boot" dizinine
    - Modül Dosyaları ---> "/lib/modules/<çekirdek_sürümü>/kernel" dizinin altında
        
    Ancak yukarıdaki dosyalar dışında isteğe bağlı olarak aşağıdaki dosyalar da hedef sisteme konuşlandırılabilir:

    - Konfigürasyon Dosyası ---> "/boot" dizini
    - Geçici Kök Dosya Sistemi Dosyası ---> "/boot" dizinine
    - Modüllere İlişkin Bazı Dosyalar ---> "/lib/modules/<çekirdek_sürümü>" dizinine
    
    Pekiyi yukarıda belirttiğimiz dosyalar hedef sistemdeki ilgili dizinlere hangi isimlerle kopyalanmalıdır? İşte tipik 
    isimlendirme şöyle olmalıdır (buradaki <çekirdek_sürümü> "uname -r" komutuyla elde edilecek olan yazıdır):

    - Çekirdek İmajı: "/boot/vmlinuz-<çekirdek_sürümü>". Örneğin "vmlinuz-6.9.2-custom" gibi.
    - Çekirdek Sembol Tablosu: "/boot/System.map-<çekirdek_sürümü>". Örneğin "System.map-6.9.2-custom" gibi.
    - Modüllere İlişkin Dosyalar: Bunlar yukarıda da belirttiğimiz gibi "/lib/modules/<çekirdek_sürümü>" dizininin içerisine
    kopyalanmalıdır. 
    - Konfigürasyon Dosyası: "/boot/config-<çekirdek_sürümü>". Örneğin "config-6.9.2-custom" gibi.
    - Geçici Kök Dosya Sistemine İlişkin Dosya: "/boot/initrd.img-<çekirdek_sürümü>". Örneğin "initrd.img-6.9.2-custom" gibi.

    Ayrıca bazı dağıtımlarda "/boot" dizini içerisindeki "vmlinuz" dosyası default olan "vmlinuz-<çekirdek_sürümü>" dosyasına, 
    "inird.img" dosyası da "/boot/initrd.img-<çekirdek_sürümü>" dosyasına sembolik link yapılmış durumda olabilir. Ancak bu sembolik 
    bağlantıları "grub" kullanmamaktadır. Aşağıda Intel sistemindeki "/boot" dizinin default içeriğini görüyorsunuz:

    $ ls -l
    total 141168
    -rw-r--r-- 1 root root    261963 Kas 14  2023 config-5.15.0-91-generic
    drwx------ 3 root root      4096 Oca  1  1970 efi
    drwxr-xr-x 7 root root      4096 Ara  5 19:02 grub
    lrwxrwxrwx 1 root root        28 Ara  5 20:28 initrd.img -> initrd.img-5.15.0-91-generic
    -rw-r--r-- 1 root root 126391088 Tem 11 20:19 initrd.img-5.15.0-91-generic
    -rw------- 1 root root   6273869 Kas 14  2023 System.map-5.15.0-91-generic
    lrwxrwxrwx 1 root root        25 Ara  5 20:28 vmlinuz -> vmlinuz-5.15.0-91-generic
    -rw-r--r-- 1 root root  11615272 Kas 14  2023 vmlinuz-5.15.0-91-generic
   
    Pekiyi derleme sonucunda elde ettiğimiz dosyaları manuel isimlendirirken çekirdek sürüm yazısını nasıl bileceğiz?
    Bunun için "uname -r" komutunu kullanamayız. Çünkü bu komut bize o anda çalışmakta olan çekirdeğin sürüm yazısını verir. 
    Biz yukarıdaki denemede Linux'un "6.9.2" sürümünü derledik. Bunun sonuna da "-custom" getirirsek sürüm yazısının 
    "6.9.2-custom" olmasını bekleriz. Ancak bu sürüm yazısı aslında manuel olarak isim değiştirmekle oluşturulamamaktadır. 
    Bu sürüm yazısı çekirdek imajının içerisine yazılmaktadır ve bizim bazı dosyayalara verdiğimiz isimlerin çekirdek içerisindeki 
    bu yazıyla uyumlu olması gerekir. Default olarak "kernel.org" sitesinden indirilen kaynak kodlar derlendiğinde çekirdek sürümü 
    "6.9.2" gibi üç haneli bir sayı olmaktadır. Yani yazının sonunda "-generic" gibi "-custom" gibi bir sonek yoktur. İşte çekirdeği 
    derlemeden önce daha önceden de belirttiğimiz gibi ".config" dosyasında "CONFIG_LOCALVERSION" özelliğine bu sürüm numarasından 
    sonra eklenecek bilgiyi girebilirsiniz. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Anımsayacağınız gibi bu işlem "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak 
    da yapılabilmektedir. Biz buradaki örneğimizde bu işlemi yaparak çekirdeği derledik. Dolayısıyla bizim derlediğimiz çekirdekte 
    çekirdek imajı içerisinde yazan sürüm ismi "6.9.2-custom" biçimindedir. Pekiyi biz bu ismi unutsaydık nasıl öğrenebilirdik. Bunun 
    basit bir yolu sıkıştırılmamış çekirdek dosyası içerisindeki (kaynak kök dizindeki "vmlinux" dosyası) string tablosunda "Linux version"
    yazısını aramaktır. Örneğin:

    $ strings vmlinux | grep "Linux version"
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) # SMP PREEMPT_DYNAMIC 
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) #2 SMP PREEMPT_DYNAMIC Thu Dec  5 17:55:14 +03 2024

    Buradan sürüm yazısının "6.9.2-custom" olduğu görülmektedir. O halde bizim derleme sonucunda elde ettiğimiz dosyaları 
    manuel biçimde kopyalarken sürüm bilgisi olarak "6.9.2-custom" yazısını kullanmalıyız. Çekirdek imajının "/boot" dizinine 
    manuel kopyalanması işlemi şöyle yapılabilir (kaynak kök dizinde bulunduğumuzu varsayıyoruz):

    $ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-6.9.2-custom
    
    Konfigürasyon dosyasını da şöyle kopyalayabiliriz:
    
    $ sudo cp .config /boot/config-6.9.2-custom
    
    Tabii bizim çekirdek modüllerini de "/lib/modules/6.9.2-custom/kernel" dizinine kopyalamamız gerekir. Ayrıca bir de 
    geçici kök dosya sistemine ilişkin dosyayı da kopyalamamız gerekir. Çekirdek modüllerinin kopyalanması biraz zahmetli bir 
    işlemdir. Çünkü bunlar derlediğimiz çekirdekte farklı dizinlerde bulunmaktadır. Bu kopyalamanın en etkin yolu "make modules_install"
    komutunu kullanmaktır. Benzer biçimde çekirdek dosyalarının ve gerekli diğer dosyaların uygun yerlere kopyalanması için 
    en etkin yöntem "make install" komutudur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak biz "make install" yaptığımızda eğer sistemimizde "grub" önyükleyicisi varsa komut "grub" konfigürasyon 
    dosyalarında güncellemeler yaparak sistemin yeni çekirdekle açılmasını sağlamaktadır. Ancak kullanıcı bir menü yoluyla 
    sistemin kendi istediği çekirdekle açılmasını sağlayabilir. Grub menüsü otomatik olarak görüntülenmemektedir. Boot işlemi 
    sırasında ESC tuşuna basılırsa menü görüntülenir. Eğer "grub" menüsünün her zaman görüntülenmesi isteniyorsa "/etc/default/grub" 
    dosyasındaki iki satır aşağıdaki gibi değiştirilmelidir:

    GRUB_TIMEOUT_STYLE=menu
    GRUB_TIMEOUT=5

    Buradaki GRUB_TIMEOUT satırı eğer menünün müdahale yapılmamışsa en fazla 5 saniye görüntüleneceğini belirtmektedir. 

    Bu işlemden sonra "update-grub" programı da çalıştırılmalıdır:

    $ sudo update-grub  

    Bu tür denemeler yapılırken "grub" menüleri bozulabilmektedir. Düzeltme işlemleri bazı konfigürasyon dosyalarının edit 
    edilmesiyle manuel biçimde yapılabilir. Konfigürasyon dosyaları güncelleendikten sonra "update-grub" programı mutlaka 
    çalıştırılmalıdır. Ancak eğer "grub" konfigürasyon dosyaları konusunda yeterli bilgiye sahip değilseniz "grub" işlemlerini 
    görsel bir biçimde "grub-customizer" isimli programla da yapabilirsiniz. Bu program "debian depolarında" olmadığı için 
    önce aşağıdaki gibi programın bulunduğu yerin "apt" kayıtlarına eklenmesi gerekmektedir:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update

    Bu işlemden sonra kurulum yapılabilir:

    $ sudo apt-get install grub-customizer
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çekirdek derleme ve yeni çekirdeği kurma sürecini maddeler halinde açıkladık. Şimdi yukarıdaki adımları özet 
    hale getirelim:

    1) Çekirdek derlemesi için gerekli olan araçlar indirilir. 

    2) Çekirdek kodları indirilir ve açılır.
    
    3) Zaten hazır olan konfigürasyon dosyası ".config" biçiminde kaynak kök dizine save edilir. 

    4) Konfigrasyon dosyası üzerinde "make menuconfig" komutu ile değişiklikler yapılır.

    5) Çekirdek derlemesi "make -j$(nproc)" komutu ile gereçekleştirilir. 

    6) Modüller ve ilgili dosyalar hedefe "sudo make modules_install" komututu ile konuşlandırılır.

    7) Çekirdek imajı ve ilgili dosyalar "sudo make install" komutu ile hedefe konuşlandırılır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi yeni çekirdeği derleyip sisteme dahil ettikten sonra nasıl onu sistemden tamamen çıkartabiliriz? Tabii yapılan 
    işlemlerin tersini yapmak gerekir. Bu işlem manuel biçimde şöyle yapılabilir:

    - "/lib/modules/<çekirdek_sürümü>" dizini tamamen silinebilir. 
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silinmelidir. 
    - "/boot" dizininden çekirdek sürümüne ilişkin dosyalar silindikten sonra "update-grub" programı sudo ile çalıştırılmalıdır. 
    Bu program "/boot" dininini inceleyip otomatik olarak ilgili girişleri  "grub" menüsünden siler. Yani aslında "grub" 
    konfigürasyon dosyaları üzerinde manuel değişiklik yapmaya gerek yoktur. "grub" işlemleri için diğer bir alternatif ise 
    "grub-customizer" programı ile görsel silme yapmaktır. Ancak bu program "/boot" dizini içerisindeki dosyaları ve modül 
    dosyalarını silmez. Yalnızca ilgili girişleri "grub" menüsündne çıkartmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            187. Ders 02/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz Intel sisteminde çalışırken ARM için çekirdek derlemesini nasıl yapabiliriz? Bir platformda çalışırken başka
    bir platform için derleme yapılabilir. Ancak hedef platforma ilişkin ismine "araç zinciri (toolchain)" denilen bir paketin 
    yüklenmiş olması gerekir. Araç zincirleri yalnızca derleyicilerden değil sistem programlama için gerekli olan çeşitli 
    programları barındıran paketlerdir. Örneğin ARM platformu için çeşitli araç zincirleri bulunmaktadır. ARM platformu için 
    en yaygın kullanılan araç zincirleri aşağıdaki bağlantıdan indirilebilir:

    https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

    Örneğin Beaglebone Black (BBB) için Windows'ta çalışan araç zinciri bu sitede aşağıdaki bağlantıya tıklanarak indirilebilir:

    arm-gnu-toolchain-14.2.rel1-mingw-w64-i686-arm-none-linux-gnueabihf.zip

    Genel olark araç zincirleri kullanılmadan önce birkaç çevre değişkeninin set edilmesi gerekmektedir:

    - CROSS_COMPILE isimli çevre değişkeni araç zincirinin öneki ile set edilmelidir. Örneğin:

    $ export CROSS_COMPILE=arm-none-linux-gnueabihf-

    - PATH çevre değişkenine araç zincirine ilişkin "bin" dizininin eklenmesi gerekir:

    $ PATH=$PATH:/home/kaan/Study/UnixLinux-SysProg/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-linux-gnueabihf/bin

    - ARCH çevre değişkeninin hedef platformu belirten bir yazı ile set edilmesi gerekir. ARM platformu için bu yazı "arm"
    biçimindedir:

    $ export ARCH=arm

    Bundan sonra çekirdeğin kaynak kodları yukarıda belirtildiği gibi derlenebilir. Burada bu işlemin ayrıntısı üzerinde 
    durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de çekirdek kodlarının değiştirilip derlenmesine bir örnek verelim. Çekirdek kodlarında değişiklik yapmanın birkaç 
    yolu olabilir:

    1) Çekirdek kodlarındaki bir dosya içerisinde bulunan fonksiyon kodlarında değişiklik yapılması.
    2) Çekirdek kodlarındaki bir dosya içerisine yeni bir fonksiyon eklenmesi.
    3) Çekirdek kodlarındaki bir dizin içerisine yeni bir C kaynak dosyası eklenmesi.
    4) Çekirdek kodlarındaki bir dizin içerisine yeni bir dizin ve bu dizinin içerisinde çok sayıda C kaynak dosyalarının 
    eklenmesi.

    Eğer biz birinci maddedeki ve ikinci maddedeki gibi çekirdek kodlarına yeni bir dosya eklemiyorsak çekirdeğin derlenmesini
    sağlayan make dosyalarında bir değişiklik yapmamıza gerek yoktur. Ancak çekirdeğe yeni bir kaynak dosya ya da dizin ekleyeceksek
    bu eklemeyi yaptığımız dizindeki make dosyasında bu ekleme izleyen paragraflarda açıklayacağımız biçimde belirtilmelidir. 
    Böylece çekirdek yeniden derlendiğinde bu dosyalar da çekirdek imajının içerisine eklenmiş olacaktır. Eğer kaynak kod 
    ağacında bir dizinin altına yeni bir dizin eklemek istersek bu durumda o dizini yine ana dizine ilişkin make dosyasında 
    belirtmemiz ve o dizinde ayrı bir Makefile oluşturmamız gerekmektedir. 

    Pekiyi çekirdek kodlarındaki bir dosya içerisindeki bir fonksiyonda değişiklik yaptığımızda çekirdek modüllerini yeniden 
    hedef makineye aktarmamız gerekir mi? İşte genel olarak bu tür basit değişikliklerde çekirdek modüllerinin güncellenmesi 
    gerekmemektedir. Ancak ne olursa olsun bu durum yapılan değişikliklere de bağlıdır. Bu nedenle çekirdek modüllerinin de 
    yeniden "make modules_install" komutu hedef makineye çekilmesi önerilir. 

    Örneğin biz çekirdek kaynak kod ağacında "fs/open.c" içerisinde "chdir" sistem fonksiyonun aşağıdaki gibi bir satır ekleyelim:

    SYSCALL_DEFINE1(chdir, const char __user *, filename)
    {
        struct path path;
        int error;
        unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;

        printk(KERN_INFO "directory is changing...\n");

    retry:
        error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
        if (error)
            goto out;

        error = path_permission(&path, MAY_EXEC | MAY_CHDIR);
        if (error)
            goto dput_and_out;

        set_fs_pwd(current->fs, &path);

    dput_and_out:
        path_put(&path);
        if (retry_estale(error, lookup_flags)) {
            lookup_flags |= LOOKUP_REVAL;
            goto retry;
        }
    out:
        return error;
    }

    Bu işlemden sonra sırasıyla aşağıdakiler yapıp sisytemi yeni ekirdekle açabiliriz:
    
    make -j$(nproc)
    make modules_install
    make install

    Bu yeni çekirdekte ne zaman bir dizin değiştirilse bir log yazısı oluşturulmaktadır. Bu yazıları "dmesg" komutuyla 
    görebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz çekirdeğin kaynak kod ağacına yeni bir ".c" dosyası eklemek istersek ne yapacağız? İşte bu durumda çekirdeğin
    make dosyalarında bu eklemenin belirtilmesi gerekmektedir. Çekirdek kodlarında her kaynak kod dizininde ayrı bir Makefile
    dosyası bulunmaktadır. Programcı yeni kaynak dosyayı hangi dizine ekliyorsa o dizine ilişkin Makefile içerisine aşağıdaki
    gibi bir satır eklemesi gerekir:

    obj-y += dosya_ismi.o

    Böylece artık make işlem yapıldığında bu dosya da derlenip çekirdek imajına dahil edilecektir. Buradaki += operatörü obj-y 
    isimli hedefe ekleme yapma anlamına gelmektedir. "obj" sözcüğünün yanındaki "-y" harfi ilgili dosyanın çekirdeğin bir 
    parçası biçiminde çekirdek imajının içerisine gömüleceğini belirtmektedir.  Make dosyalarının bazı satırlarında "obj-y" 
    yerine "obj-m" de görebilirsiniz. Bu da ilgili dosyanın ayrı bir modül biçiminde derleneceği anlamına gelmektedir. 
    Eklemeler genellikle çekirdek imajının içine yapıldığı için biz de "obj-y" kullanırız. Eğer bir dosyayı biz çekirdek 
    imajının içine gömmek yerine ayrı bir çekirdek modülü olarak derlemek istiyorsak bu durumda dosyayı yerleştirdiğimiz 
    dizinin "Makefile" dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-m += dosya_ismi.o

    Eğer çekirdek kaynak kodlarına tümden bir dizin eklemek istiyorsak bu durumda o dizini oluşturduğumuz dizindeki "Makefile"
    dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-y += dizin_ismi/

    Burada dizin isminden sonra '/' karakterini unutmayınız. Tabii bu ekleme bir modül biçiminde de olabilirdi:

    obj-m += dizin_ismi/

    Fakat bu ekleme yapıldıktan sonra bizim ayrıca yarattığımız dizinde "Makefile" isimli bir dosya oluşturmamız ve o dosyanın 
    içerisinde o dizinde çekirdek kodlarına ekleyeceğimiz dosyaları belirtmemiz gerekir. Örneğin biz "drivers" dizininin altına
    "mydriver" isimli bir dizin oluşturup onun da içerisine "a.c" "b.c" ve "c.c" dosyalarını eklemiş olalım. Bu durumda önce 
    "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki gibi bir satır ekleriz:

    obj-y += mydriver/

    Sonra da "mydriver" dizini içerisinde "Makefile" isimli bir dosya oluşturup bu dosyanın içerisinde de bu dizin içerisindeki 
    dosyaları belirtiriz. Örneğin:

    obj-y += a.o
    obj-y += b.o
    obj-y += c.o
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin biz kaynak kod ağacında "drivers" dizinin altında "mydriver" isimli dizin yaratıp onun içerisine "mydrive.c" 
    dosyasını yerleştirmek isteyelim. Sırasıyla şunları yapmamız gerekir:

    1) "drivers" dizini altında "mydriver" dizini yaratırız.

    2) "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki satır ekleriz:

    obj-y += mydriver/

    3) "drivers/mydriver" dizini içerisinde "mydriver.c" dosyasını oluştururz. Dosyanın içeriği şöyle olabilir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    static int __init helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    4) "drivers/mydriver" dizini içerisinde "Makefile" isimli dosya oluştururz ve içine aşağıdaki satır ekleriz:

    obj-y += mydriver.o

    5) Çekirdek kod dizinin kök dizinine gelip ve sırasıyla aşağıdaki komutları uygularız:

    make -j$(nproc)
    make modules_install
    make install

    Böylece sistem yeni çekirdekle açılabilir. Aygıt sürücünün çekirdeğe dahil edildiğini geçmiş dmesg mesajlarına bakarak
    aşağıdaki gibi anlayabilirssiniz:

    $ dmesg | grep -i "Hello World..."
    [    0.949515] Hello World...   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            188. Ders 07/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yeni bir sistem fonksiyonunu çekirdeğe eklemek isteyelim. Linux çekirdeğinde sistem fonksiyonlarının adresleri 
    bir fonksiyon gösterici dizisinde tutulmaktadır. Bu gösterici dizisinin her elemanı bir sistem fonksiyonun adresini içerir. 
    O halde çekirdeğe bir sistem fonksiyonu ekleyebilmek için sistem fonksiyonunu bir dosya içerisine yazmak ve bu tabloya 
    o fonksiyonu gösteren bir giriş eklemek gerekir. Bunun yapılış biçimi Linux'un çeşitli versiyonlarında değiştirilmiştir. 
    Aşağıda güncel bir versiyonda bu işlemin nasıl yapıldığına ilişkin bir örnek vereceğiz:

    1) Sistem fonksiyonumuz "mysyscall" biçiminde isimlendirmiş olalım. Önce yine çekirdek kaynak kod ağacında uygun bir dizine
    yine bir dosya eklemek gerekir. Bunun için en uygun dizin "kernel" dizinidir. Bu durumda sistem fonksiyonumuzu "kernel" 
    dizini içerisinde "mysyscall.c" ismiyle yazabiliriz:

    /* mysyscall.c */

    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h> 

    SYSCALL_DEFINE0(mysyscall)
    {
        printk(KERN_INFO "My system call\n");

        return 0;
    }

    Bundan sonra kernel dizini içerisindeki "Makefile" dosyasına aşağıdaki satırı ekleriz:

    obj-y += mysyscall.o

    2) Sistem fonksiyon tablosuna ilgili sistem fonksiyonu bir eleman olarak girilir. Sistem fonksiyon tablosu 
    "arch/<platform>/syscall/xxx.tbl" dosyasında belirtilmektedir. 64 bit Linux sistemleri için bu dosya 
    "arch/x86/entry/syscalls/syscall_64.tbl" biçimindedir. Ekleme bu dosyanın sonuna aşağıdaki gibi yapılabilir:

    ......
    544    x32    io_submit        compat_sys_io_submit
    545    x32    execveat        compat_sys_execveat
    546    x32    preadv2            compat_sys_preadv64v2
    547    x32    pwritev2        compat_sys_pwritev64v2
    # This is the end of the legacy x32 range.  Numbers 548 and above are
    # not special and are not to be used for x32-specific syscalls.
    548    common   mysyscall    sys_mysyscall

    3)  Artık çekirdek aaşağıdaki gibi derlenebilir:

    $ sudo make -j$(nproc)

    4) Çekirdek modüllerini aşağıdaki gibi install edebiliriz:

    $ sudo make modules_install

    5) Çekirdeğin kendisini de şöyle install edebiliriz:

    $ sudo make install
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem fonksiyonunu çekişrdeğe yerleştirip yeni çekirdekle makinemizi açtıktan sonra fonksiyonun tesitini aşağıdaki gibi 
    yapabiliriz:

    #include <stdio.h>
    #include <sys/syscall.h>
    #include <unistd.h>

    #define SYS_mysyscall       548

    int main(void)
    {
        printf("running...\n");

        syscall(SYS_mysyscall);

        return 0;
    }

    Bu programı derleyip çalıştırdıktan sonra "dmesg" yaptığımızda aşağıdaki gibi bir çıktı elde etmeliyiz:
    
    ....
    file uses a different sequence number ID, rotating.
    [  144.816248] warning: `ThreadPoolForeg' uses wireless extensions which will stop working for Wi-Fi 7 hardware; use nl80211
    [  487.365691] My system call
---------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Her ne kadar sistem programlamanın doğrudan veritabanlarıyla bir ilgisi yoksa da C programcılarının yine de sistem programcıların
    bazı durumlarda veritabanları oluşturup onları kullanması gerekebilmektedir. Bu bölümde C'den SQL kullanarak veritabanlarıyla 
    nasıl işlem yapılacağı üzerinde duracağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Eskiden veritabanı işlemleri kütüphanelerle yapılıyordu. Daha sonra veritabanı işlemleri için özel programlar geliştirildi. 
    Veritabanı işlemlerini ayrıntılı ve etkin bir biçimde gerçekleştiren yazılımlara "Veritabanı Yönetim Sistemleri (DBMS)"
    denilmektedir. Günümüzde çeşitli firmalar ve kurumlar tarafından geliştirilmiş pek çok VTYS vardır. Bunların bazıları 
    kapalı ve ücretli yazılımlardır. Bazıları ise açık kaynak kodlu ve ücretsiz yazılımlardır. En çok kullanılan VTYS yazılımları 
    şunlardır:

    - IBM DB2 (Dünyanın ilk VTYS'sidir.)
    - Oracle (Oracle firmasının en önemli ürünü.)
    - SQL Server (Microsoft firmaının VTYS'si.)
    - MySQL (Açık kaynak kodlu, ancak Oracle firması satın aldı ve gelecekteki durumu tartışmalı.)
    - MariaDB (Açık kaynak kodlu, MySQL Oracle yarafındna satın alınınca kapatılma tehlikesine karşı MySQL varyantı olarak 
    devam ettirlmektedir.)
    - PostgreSQL (Açık kaynak kodlu, son yıllarda geniş kesim tarafından kullanılan VTYS.)
    - SQLite (Gerçek anlamda bir VTYS değil, VTYS'yi taklit eden mini bir kütüphane gibi. Bu tür yazılımlara "gömülü VTYS" de
    denilmektedir.)
    - Microsoft Access Jet Motoru (Bu da Microsoft'un gömülü bir VTYS sistemidir. Micsofot Access tarafından da kullanılmaktadır.)

    Bir yazılımın VTYS olabilmesi için onun bazı gelişmiş özelliklere sahip olması gerekir:

    1) VTYS'ler kullanıcılarına yüksek seviyeli bir çalışma modeli sunmaktadır.
    
    2) VTYS'ler genellikle dış dünyadan istekleri "SQL (Structured Query Language)" denilen dekleratif bir dille almaktadır. 
    Yani programcı VTYS'ye iş yaptırmak için SQL denilen bir yüksek seviyeli dekleratif bir dil kullanmaktadır. VTYS SQL 
    komutlarını alıp onları parse eder ve C ve C++ gibi dillerde yazılmış olan motor kısmı (engine) tarafından işlemler yapılır. 
    SQL veritabanı işlemlerini yapan bir dil değildir. Programcı ile VTYS arasında yüksek seviyeli iletişim için kullanılan 
    bir dildir. VTYS'lerin motor ısımları genellikle C ve C++ gibi sistem programlama dilleriyle yazılmaktadır. 

    3) VTYS'ler pek çok yüksek seviyeli araçlara da sahiptir. Örneğin backup ve restore işlemlerini yapan araçlar her VTYS'de 
    bulunmaktadır. 

    4) VTYS'ler genellikle birden fazla kullanıcıya aynı anda hizmet verecek biçimde client-server mimarisine uygun biçimde
    yazılmaktadır. Bunlara uzaktan erişilebilmekte ve aynı anda pek çok kullanıcı bunlara iş yaptırabilmektedir. 

    5) VTYS'ler ileri derece güvenlik sunmaktadır. Bir kullanıcı başka bir kullanıcının bilgilerine erişememektedir. 

    6) VTYS'ler yüksek miktarda kayıtlardan oluşan veritabanarı üzerinde etkin bir biçimde işlemler yapabilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem programlama uygulamalarında bazen küçük veritabanalrının oluşturulması gerekebilmektedir. Bu tür durumlarda kapasiteli
    VTYS'ler yerine tek bir dosyadan oluşan adeta bir kütüphane biçiminde yazılmış olan gömülü VTYS'lerden (embedded DBMS)
    faydalanılmaktadır. Bunlar en çok kullanılanı SQLite denilen gömülü VTYS'dir. Örneğin bir tarayıcı yazdığımızı düşünelim. 
    Son ziyaret edilen Web sayfalarının bir biçimde tarayıcdan çıkıldıktan sonra saklanması gerekir. İşte bu tür durumlarda 
    SQLite gibi basit yapıda VTYS'ler tercih edilebilmektedir. Internet bağlantısı olmayan mobil cihazlarda da SQLite gibi 
    gömülü VTYS'ler çokça kullanılmaktadır. Örneğin biz bir soket uygulaması yazmış olalım. Bu uygulama bir log tutacak olsun. 
    Burada SQLServer, MySQL gibi büyük çaplı VTYS'ler yerine SQLite gibi bir gömülü VTYS'yi tercih edebiliriz. Gömülü VTYS'ler
    büyük çağlı veritabanlarında iyi bir performans gösterememektedir. Bunlar daha ok küçük ve orta çaplı veritabanlarında 
    kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanı işlemleri için C'den ziyade yüksek seviyeli diller tercih edilmektedir. Örneğin Java, C#, Python gibi diller 
    veritabanı işlemlerinde oldukça yaygın kullanılmaktadır. Benzer biçimde JavaScript de Web uygulamalarında veritabanları
    üzerinde işlem yapmak için kullanılan dillerdendir. Günümüzde veritabanlarının en çok kullanıldığı uygulamalar Web 
    uygulamalarıdır. Bir Web mağasına girdiğinizde oradaki bütün ürünler veritabanlarında tutulmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    VTYS'lerin client-server mimarisine uygun bir biçimde yazıldığını belirtmiştik. VTYS'lerle tipik çalışma şu biçimdedir:

    1) Programcı "kullanıcı ismi" ve "parola" ile VTYS'ye bağlanır. Bu durumda programcı client durumunda VTYS ise server 
    dumundadır. 

    2) Programcı VTYS'ye yaptırmak istediği şeyleri SQL dilinde oluşturur ve VTYS'ye SQL komutlarını gönderir. 

    3) VTYS bu SQL komutlarını parse eder ve istenilen işlemleri yapar, programcıya işlemin sonuçlarını iletir.

    4) Programcı işi bittiğinde bağlantıyı kapatır.

    Her ne kadar SQLite gibi Microsoft Access Jet Motoru gibi VTYS'ler aslında client-server çalışmıyor olsa da bunlar 
    çalışma biçimi olarak geniş kapasiteli VTYS'leri taklit etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanları tasarım bakımından birkaç gruba ayrılmaktadır. Günümüzde en çok kullanılan veritabanı mimarisine "İlişkisel
    Veritabanı (Relational Database) Mimarisi" denilmektedir. İlişkisel veritabanları "tablolardan (tables)" tablolar da 
    sütun ve satırlardna oluşmaktadır. Örneğin biz öğrencilerin bilgilerini tutmak için bir veritabanı tablosu oluştururz. 
    Bu tablo aşağıdaki görünümde olur:

    Adı Soyadı      Numarası        Sınıfı      
    ---------------------------------------
    Ali Serçe       1234            3B
    Güray Sönmez    6745            2C
    Ayşe Er         6234            2B
    ....

    Tablolardaki sütunlara "alan (field)" satırlara ise "satır (row)" ya da "kayıt (record)" denilmektedir. MySQL, SQLServer, 
    Oracle, SQLite gibi VTYS'ler ilişkissel veritabanı mimarisini kullanmaktadır. 

    Hiyerarşik bilgileri (örneğin bir ağaç yapısını) tutmak için hiyerarşik veritabanı mimarileri kullanılabilmektedir. Son 15
    senedir ismine "nosql" denilen ilişkisel olmayan ve özellikle metin tabanlı bilgiler üzerinde işlem yapan veritabanı 
    mimarileri sıkça kullanılır hale gelmiştir. Ancak en yaygın kullanılan mimari ilişkisel veritabanı mimarisidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    MyQL'i kurmak için tek yapılacak şey server programı http://dev.mysql.com/downloads/ sitesnden indirip yüklemektir. Kurulum 
    oldukça basittir. Birtakım sorular default değerlerle geçilebilir. Ancak kurulum sırasında MySQL kurulum programı bizden 
    “root” isimli yetkili kullanıcının parolasını istenecektir. Diğer Bu parola yetkili olarak VTYS'ye bağlanmak için gerekir. 
    Server programın yanı sıra bir yönetim ekranı elde etmek için ayrıca "MySql Workbench" programı da kurulabilir. 

    MySQL Linux sistemlerinde Debian paket yöneticisi ile aşağıdaki gibi basit bir biçimde kurulabilir:

    $ sudo apt-get install mysql-server

    Kütüphane dosyaları da şöyle indirilebilir:

    sudo apt-get install libmysqlclient21

    MySQL Workbench ise komut satırı yerine Web Sayfasından indirilerek kurululabilir. 

    Yukarıda da belirttiğimiz gibi MySQL kısmen paralı hale getirilince bunun MariDB isimli bir klonu oluşturuldu. MariDB'nin
    uzun vadede açık kaynak kod güvencesi olduğu için tercih edebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL paralı bir üründür. Fakat bunun da "Express Edition" isminde bedava bir sürümü vardır. Bu sürüm Microsoft'un sayfasından 
    indirilip kurulabilir. Tıpkı MySQL'de olduğu gibi SQL Server'da da yönetim konsol programı da vardır. Buna "SQL Server 
    Management Studio" denilmektedir. Bunun da indirilip kurulması tavsiye edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   SQLite zaten tek bir DLL'den oluşmaktadır. Dolayısıyla aslında kurulumu diye bir durum söz konusu değildir. Fakat biz 
   burada C için örnekler yaparken SQLite başlık dosyalarına ve SQLite DLL’inin import kütüphanesine sahip olmak zorundayız. 
   Bunların nasıl elde edileceği sonraki konularda ele alınacaktır. SQLite yönetim konsolu olarak pek çok alternatif vardır. 
   Bunlardan biri "FireFox Add On olarak çalışmaktadır. İkinci bir seçenek ise “SQLite Studio” aracıdır. Cross Platform olan 
   bu araç ilgili web sayfasından indirilerek kurulabilir. Ya da daha genel "DBeaver" da tercih edilebilir. 

   SQLite'ı Windows için aşağıdaki bağlantıdan indirebilirsiniz:

   https://www.sqlite.org/download.html

   Buradan indirilen zip dosyasının içerisinde bir tane ".DLL" dosyası bir ".DEF" dosyası bulunacaktır. Bu DLL'i PATH dizinlerinin
   içerisine ya da uygulama dizinin içerisine çekebilirsiniz. Linux'ta SQLite şöyle indirilebilir:

   $ sudo apt-get install sqlite
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanları tablolardan tablolar da sütunlardan (fields) oluşmaktadır. Tabii sütunların da veri türleri vardır. 
    SQL Standratlarında standart bazı veri türleri belirtilmiştir. Ancak SQL VTYS'den VTYS'ye değişiklik gösterebilmektedir. 
    Dolayısıyla her VTYS'nin SQL komutlarında bazı farklılıklar bulunabilmektedir. Biz burada bazı standart sütun türleri
    üzerinde duracağız. Çalıştığınız VTYS'nin dokğmanlarından onlara özgü ayrıntıları elde edebilirsiniz. 

    INTEGER: Tamsayısal bilgileri tutan bir türdür. İstenirse kaç digitlik sayıların tutulacağı da belirtilebilir.

    INT: Tipik olarak 4 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki int türü ile temsil edilebilir.)

    SMALLINT: Tipik olarak 2 byte'lık işaretli tamsayı türüdür. (Örneğin bu tür C’deki short türü ile temsil edilebilir.)

    BIGINT: Tipik olarak 8 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki long long türü ile temsil 
    edilebilir.)

    FLOAT: Tipik olarak 4 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki float  türü ile temsil edilebilir.)

    DOUBLE: Tipik olarak 8 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki double türü ile temsil edilebilir.)

    TIME: Zaman bilgisini saklamak için kullanılan türdür. 

    DATE: Tarih bilgisini saklamak için kullanılan türdür. 

    CHAR(n): n karakterli yazıyı tutmak için kullanılan türdür. 

    VARCHAR(n): En fazla n karakterli bir yazıyı tutmak için kullanılan türdür. 

    TINYTEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    TEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGTEXT:  (Tipik olarak 4GB'ye byte'a kadar)

    TINYBLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    BLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGBLOB:  Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 4GB'ye byte'a kadar)

    Tablo sütunlarının türleri tablo yaratılırken belirlenmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de temel SQL komutlarını görelim. SQL bazı ayrıntıları olan dekleratif bir programlama dilidir. Komutlardan oluşmaktadır.
    Biz burada temel SQL komutlarını ayrıntılarına girmeden ele alacağız.

    SQL büyük harf küçük harf duyarlılığı olmayan (case insensitive) bir dildir. Ancak geleneksel olarak anahtar sözcüklerin
    büyük harflerle yazılması tercih edilmektedir. SQL komutlarının sonunda sonlandırıcı olarak ';' karakteri bulundurulmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

*--------------------------------------------------------------------------------------------------------------------------
    CREATE DATABASE Komutu: İlişkisel veritabanlarında “veritabanı” tablolardan oluşmaktadır. Bu nedenle önce bir veritabanının 
    yaratılması, sonra da onun içerisinde tabloların yaratılması gerekir. Veritabanlarını yaratmak için CREATE DATABASE komutu 
    kullanılır. Komutun genel biçimi şöyledir:

    CREATE DATABASE <isim>;

    Örneğin:

    CREATE DATABASE student;

    USE Komutu: Belli bir veritabanı üzerinde işlemler yapmak için öncelikle onun seçilmesi gerekir. Bu işlem USE komutuyla 
    yapılır. Komutun genel biçimi şöyledir:

    USE <isim>;

    SHOW DATABASES Komutu: Bu komut VTYS'de yaratılmış olarak bulunan veritabanlarını gösterir. Komutun genel biçimi şöyledir:

    SHOW DATABASES;

    CREATE TABLE Komutu: Bu komut veritabanı için bir tablo yaratmak amacıyla kullanılır. Komutun genel biçimi şöyledir:

    CREATE TABLE <isim> (<isim> <tür>, <isim> <tür>, <isim> <tür>... );

    Aslında bu komutun bazı ayrıntıları vardır. Bu ayrıntılar ilgili dokümanlardan öğrenilebilir.

    Örneğin:

    CREATE TABLE student_info(student_id PRIMARY KEY AUTO_INCREMENT, student_name VARCHAR(45), student_no INTEGER);

    Bir tabloda tekrarlanması yasaklanmış olan sütunlara “birincil anahtar (primary key)” denilmektedir. Tablodaki kayıtların 
    hepsinin birincil anahtar sütunları farklı olmak zorundadır. Başka bir deyişle biz bir tabloya orada zaten var olan birincil 
    anahtar değerine ilişkin bir kayıt ekleyemeyiz. Her tabloda bir tane birincil anahtarın olması tavsiye edilmektedir. 
    Birincil anahtarın tablo yaratılırken CREATE TABLE komutunda belirtilme biçimi çeşitli VTYS’lerde farklı olabilmektedir.

    DROP TABLE Komutu: Bu komut tabloyu silmek için kullanılır. Komutun genel biçimi şöyledir:

    DROP TABLE <isim>;

    Örneğin:

    DROP TABLE person;

    INSERT INTO Komutu: Bu komut bir tabloya bir satır eklemek için kullanılır. Komutun genel biçimi şöyledir:

    INSERT INTO <tablo ismi> (sütun1, sütun2, sütun3,...) VALUES (değer1, değer2, değer3,...);

    Tabloya satır eklerken aslında her sütun bilgisinin belirtilmesi gerekmez. Bu durumda o sütun için tablo yaratılırken 
    (CREATE TABLE komutunda) belirlenmiş olan default değerler kullanılır. Komutun ayrıntılı genel biçimi için ilgili 
    dokümanlara başvurabilirsiniz. Örneğin:

    INSERT INTO student_info(student_name, student_no) VALUES('Güray Sönmez', 754);

    Değerler girilirken yazılar ve tarihler tek tırnak içerisinde belirtilmelidir.

    WHERE Cümleciği: Pek çok komut bir WHERE kısmı içermektedir. Where cümleciği koşul belirtmek için kullanılır. Koşullar 
    karşılaştırma operatörleriyle oluşturulur. Mantıksal operatörlerle birleştirilebilir. Örneğin:

    WHERE age > 20 AND birth_place = 'Eskişehir'

    LIKE operatörü joker karakterleri kullanılarak belli bir kalıba uyan yazı koşulu oluşturur. Örneğin:

    WHERE student_name LIKE 'A%'

    Burada student_name için 'a' ile başlayanlar koşulu verilmiştir. % karakteri "geri kalanı herhangi biçimde olabilir" 
    anlamına gelir. Örneğin:

    WHERE student_name LIKE '%an'

    Burada sonu 'an' ile bitenler koşulu verilmiştir.

    WHERE cümleciğinin bazı detayları vardır. Bu detaylar ilgili dokümanlardan öğrenilebilir.

    DELETE FROM Komutu: Bu komut bir tablodan satır silmek için kullanılır. Komutun genel biçimi şöyledir:

    DELETE FROM <tablo ismi> <WHERE cümleciği>;

    UPDATE Komutu: Update komutu belli kayıtların alan bilgilerini değiştirmek amacıyla kullanılır. Örneğin ismi "Kağan" 
    olan bir kaydı "Kaan" olarak değiştirmek isteyebiliriz. Ya da bir müşterinin bakiyesini değiştirmek isteyebiliriz. Komutun 
    genel biçimi şöyledir:

    UPDATE <tablo ismi> SET alan1 = değer1, alan2 = değer2, ... WHERE <koşul>;

    Örneğin:

    UPDATE student_info SET student_name = 'Kaan Kaplan' WHERE student_name = 'Kaan Aslan'

    DELETE ve UPDATE komutlarını kullanrıken dikkat ediniz. Çünkü eğer koşul belirtmezseniz ya da koşulu yanlış belirtirseniz
    yaptıpınız işlemden birden fazla kayıt etkilenir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı';

    Burada koşul zayıf oluşturulmuştur. Bu durumda bütün "Veli Ballı" isimleri "Ali Ballı" olarak değiştirilir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı' AND student_no = 754;

    Artık burada ismi "Veli Ballı" olan ve numarası 754 olan satırın ismi "Ali Ballı" olarak değiştirilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                        189. Ders 21/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SELECT Komutu: Koşulu sağlayan kayıtların elde edilmesi SELECT komutuyla yapılmaktadır. SELECT komutunun genel biçimi 
    oldukça ayrıntılıdır. Çünkü komuta çeşitli cümlecikler monte edilebilmektedir. Komutun genel biçimi şöyledir:

    SELECT <sütun_listesi> FROM <tablo_ismi> [WHERE <koşul];

    Eğer WHERE cümleciği kullanılmazsa tablodaki tüm kayıtlar elde edilir. Sütun listesi sütunların isimlerinden oluşmaktadır. 
    Uygulamacı yalnızca bazı sütun bilgilerini elde edebilir. Sütun istesi yerine * kullanılırsa "tüm sütunlar" anlamına gelmektedir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY stdent_name;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY stdent_name;

    ORDER BY default olarak kayıtları küçükten büyüğe (ASC) vermektedir. Ancak DESC ile büyükten küçüğe de sıralama yapılabilir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC;

    ORDER BY cümleciğinde birden fazla sütun belirtilebilir. Bu durumda ilk sütun değerleri aynıysa diğer sütunlar dikkate alınır. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC;

    Burada ismi aynı olanlar numaralarına göre küçükten büyüğe elde edilecektir.

    LIMIT cümleceği de SELECT cümlesiyle kullanılabilir. LIMIT anahtar sözcüğnün yanında bir sayı bulunur. Koşulu sağlayan 
    kayıtların belli sayıda miktarını elde etmek için kullanılır. Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC LIMIT 10;

    WHERE cümleciğinde built-in fonksiyonlar kullanılabilir. Örneğin:

    SELECT * FROM city WHERE char_length(city) = 6;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanlarında tablolarda veri tekrarı istenmez. Örneğin bir öğrenci veritabanı oluşturacak olalım. Bir öğrencinin 
    çeşitli bilgilerinin yanı sıra onun okulu hakkında da bilgileri tutmak isteyelim. Aşağıdaki gibi bir tablo tasarımı uygun 
    değildir:

    Adı Soyadı  No      Okul Adı                Okulun Bulunduğu Şehir      Okulun Türü
   --------------------------------------------------------------------------------------
    Ali Serçe   123     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    Kaan Aslan  745     Eskişehir Atatürk Lisesi    Eskişehir               Devlet Lisesi
    Hasan Bulur 734     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    ...                 ...                         ...                     ...

    Burada Okul Adı bilgileri gereksiz bir biçimde tekrarlanmaktadır. Bu tekrarı engellemek için iki tablo oluşturabiliriz.

    Öğrenci Tablosu

    Adı Soyadı     No      Okul ID'si
    ----------------------------------
    Ali Serçe      123     100
    Kaan Aslan     745     235
    Hasan Bulur    734     100
    ...             ...     ...

    Okul Tablosu

    Okul Id'si       Okul Adı                   Okulun Bulunduğu Şehir      Okulun Türü
    ------------------------------------------------------------------------------------
    ...              ...                        ...                         ...
    100              Tarsus Amerikan Lisesi     Mersin                      Devlet Lisesi
    150              Eskişehir Atatürk Lisesi   Eskişehir                   Devlet Lisesi
    ...              ...                        ...                         ...

    Burada veri tekrarı ortadan kaldırılmıştır. Tabii bu tablolarda da Okul ID'si ortak bir sütundur. Bu ortak sütun tablolar 
    arasında ilişki kurmak için gerekmektedir. Bu tür sütunlara "foreign key" de denilmektedir. Ancak yukarıdaki gibi tekrarlar 
    engellendiğinde gerekli bilgiler artık tek bir tablodan değil, çeşitli tablolardan çekilip alınacaktır. İşe çeşitli tablolardan 
    bilgilerin çekilip alınması işlemine "JOIN" işlemi denilmektedir. JOIN işleminin birkaç biçimi vardır (INNER JOIN, OUTER JOIN, 
    LEFT JOIN, RIGHT JOIN gibi). Ancak en fazla kullanılan JOIN işlemi "INNER JOIN" denilen işlemdir. JOIN denildiğinde zaten 
    default olarak INNER JOIN anlaşılır. INNER JOIN işleminde eğer iki tablo söz konusu ise önce iki tablonun kartezyen çarpımları 
    elde edilir. Her kaztezyen çarpım iki tablonun birleştirilmesi biçiminde ("join" ismi oradan geliyor) elde edilmektedir. 
    Sonra kartezyen çarpımlarda yalnızca belli koşulu sağlayan satırlar elde edilir. Böylece tablolar "ilişkisel (relational)" 
    biçimde birleştirilmiş olur.

    INNER JOIN sentaksı iki biçimde oluşturulabilmektedir. Birinci sentaks klasik eski tip sentakstır. İkinci sentaks daha modern 
    biçimdir. Klasik eski tip sentaks şöyledir:

    SELECT <iki tablodaki istenen sütunların listesi> FROM <birinci tablo ismi> INNER JOIN <ikinci tablo ismi> ON <koşul>;

    Örneğin:

    SELECT student.student_name, student.student_no, school.school_name FROM student INNER JOIN school ON 
    student.school_id = school.school_id WHERE stduent.student_no > 600;

    Sütun isimleri belirtilirken eğer çakışma yoksa yalnızca isimler yazılabilir. Ancak çakışma varsa tablo ismi ve nokta 
    operatörü ile sütunun hangi tabloya ilişkin olduğu belirtilmelidir. Bazı uygulamacılar çakışma olsa da olmasa da 
    niteliklendirme yaparlar. Bazı uygulamacılar yalnızca çakışan sütunlarda niteliklendirme yaparlar. Yukarıdaki örnekte 
    tüm sütunlar niteliklendirilerek belirtilmiştir. Bu örnek şöyle de yapılabilirdi:

    SELECT student_name, student_no, school_name FROM student INNER JOIN school ON student.school_id = school.school_id 
    WHERE student_no > 600;

    Modern INNER JOIN sentaksında SELECT komutunun FROM kısmında birden fazla tablo ismi belirtilir. Koşul da yine WHERE 
    cümleciğine taşınır. Örneğin:

    SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id AND 
    student_no > 600;

    Daha çok bu modern biçim tercih edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemlere başlamadan önce SQLite’ın programalama kurulumunu yapmamız gerekir. SQLite yukarıda da belirtitğimiz gibi 
    çok küçük (tek bir dinamik kütüphaneden oluşan) bir VTYS’dir. Dolayısıyla onun kurulması Windows’ta bildiğimiz anlamda 
    bir setup işlemi ile yapılmaz. Tabii bizim C’den SQLite kütüphanesini kullanabilmemiz için ona ilişkin başlık ve kütüphane 
    dosyalarını elde etmemiz gerekir. Windows'ta SQLite'ın resmi indirme sitesi şöyledir:

    https://sqlite.org/download.html

    Buradan aşağıdaki iki indirme yapılır:

    1) Precompiled Binaries for Windows (32 bit ya da 64 bit)
    2) SQLite Amalgamation

    Birinci indirmede tek bir DLL elde edilecektir. İkinci indirmede de "sqlite3.h" başlık dosyası ve kaynak dosyası elde 
    edilecektir.

    Ayrıca SQlite için "sqlite3" isminde komut satırından kullanılan bir program da bulundurulmuştur. Bu programın kullanımına 
    ilişkin bilgileri aşağıdaki bağlantıdan edinebilirsiniz:

    https://www.sqlite.org/cli.html

    Birinci indirmede Windows için gereken sqlite3.dll ve sqlite3.def dosyaları elde edilir. Buradaki “.def” dosyasına 
    “module definition file” denilmektedir. Bu dosya “DLL’in import kütüphanesi” gibi link aşamasına dahil edilebilir. 
    Ya da istenirse aşağıdaki komutla bu “.def” dosyasından “.lib” uzantılı “import kütüphanesi de oluşturulabilmektedir:

    LIB /DEF:sqlite3.def /machine:x86

    Buradaki machine argümanı hedef sistemi belirtmektedir. Burada 32 bit Windows sistemleri için x86, 64 bit Windows 
    sistemleri için "x64" kullanılmalıdır. Örneğin:

    LIB /DEF:sqlite3.def /machine:x64

    İkinci indirmeden biz SQLite’ın kaynak dosyalarını elde ederiz. Buradaki “sqlite3.h” dosyası SQLite fonksiyonları için 
    başlık dosyası niteliğindedir.

    Mac OS X için kurulum Windows’takine benzemektedir. Yine ilgili “.zip” dosyaları indirilip kurulum yapılabilir. Bu 
    sistemlerde derleme yaparken link aşamasında "-lsqlite3" ile kütüphane dosyasını belirtmeyi unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            190. Ders 23/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurulum sonrası her şeyin hazır oladuğunu anlamak için SQLite kütüphanesinin versiyon numarasını yazdıran aşağıdaki 
    gibi bir programla test işlemi yapabilirsiniz:

    #include <stdio.h>
    #include "sqlite3.h"

    int main(void)
    {
        printf("%s\n", sqlite3_libversion());

        return 0;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C’de SQLite veritabanı ile işlem yapmak için önce o veritabanının sqlite3_open fonksiyonuyla açılması gerekir. Bu işlemden 
    sqlite3 türünden bir handle elde edilir. sqlite3_open fonksiyonunun prototipi şöyledir:

    int sqlite3_open(
        const char *filename,   /* Database filename (UTF-8) */
        sqlite3 **ppDb          /* OUT: SQLite db handle */
    );

    Fonksiyonun birinci parametresi bizden sqlite dosyasının yol ifadesini alır. İkinci parametresi sqlite3 isimli yapı türünden 
    bir göstricinin adresini almaktadır. Fonksiyon handle alanını (yani sqlite yapı nesnesini) oluşturur. Onun adresini bu 
    göstericinin içerisine yerleştirir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtmektedir. Fonksiyon başarılıysa 
    SQLITE_OK değerine geri döner. Fonksiyon başarısız olduğunda yine dosyanın sqlite3_close fonksiyonuyla kapatılması gerekir. 
    Hata nedeni de sqlite3_errmsg fonksiyonuyla yazdırılabilir. Bu durumda sqlite dosyasının açılması tipik olarak şöyle 
    yapılabilir:

    if (sqlite3_open("student.db", &db) != SQLITE_OK) {
        fprintf(stderr, "sqlite3_open failed: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        exit(EXIT_FAILURE);
    }

    sqlite3_open fonksiyonu dosya varsa olanı açar, yoksa yeni bir SQLite DB dosyası yaratır.

    sqlite3_errmsg fonksiyonunun parametrik yapısı şöyledir:

    const char *sqlite3_errmsg(sqlite3 *db);

    sqlite3_close fonksiyonunun prototipi ise şöyledir:

    int sqlite3_close(sqlite3*);

    Dosya kapatılırken başarı kontrolü yapmaya gerek yoktur. Başarısızlık durumlarında hata mesajını stderr dosyasına yazdırıp
    programı sonlandıran bir sarma fonksiyon şöyle yazılabilir:

    void sqlite3_exit(const char *msg, sqlite3 *db)
    {
        fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
        sqlite3_close(db);

        exit(EXIT_FAILURE);
    }

    Böylece biz hata durumlarını aşağıdaki gibi ele alabiliriz:

    if (sqlite3_open("studentxxx.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    printf("success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SQLite'a bir SQL cümlesi göndermek için sqlite3_exec fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int sqlite3_exec(
        sqlite3 *db,                               /* An open database */
        const char *sql,                           /* SQL to be evaluated */
        int (*callback)(void*,int,char**,char**),  /* Callback function */
        void *param,                               /* 1st argument to callback */
        char **errmsg                              /* Error msg written here */
    );

    Fonskiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre sql cümlesinin 
    yazısını alır. Üçüncü parametre işlemden sonra çağrılacak “callback” fonksiyonun adresini almaktadır. Bu parametre NULL 
    geçilebilir. Dördüncü parametre bu “callback” fonksiyona geçirilecek argümanı belirtir. Bu parametre de NULL geçilebilir. 
    Son parametre ise char * türünden bir göstericinin adresini almaktadır. Hata drumunda hata mesajının adresi bu göstericiye 
    yerleştirilir. Bu parametre NULL olarak da geçilebilir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtir. Fonksiyon 
    başarılıysa SQLITE_OK değerine geri dönmektedir. Bu durumda biz hata mesajını yazdırdıktan sonra sqlite3_free fonksiyonu 
    ile tahsis edilen alanı serbest bırakabiliriz. Örneğin:

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) VALUES('Rasim Öztekin', 367)", 
                NULL, NULL, NULL) != SQLITE_OK)
        sqlite3_exit("sqlite3_exec", db);

    Aşağıdaki örnekte student_info veri tabanına sqlite3_exec fonksiyonu ile bir kayıt eklenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) \
            VALUES('Rasim Öztekin', 367)", NULL, NULL, NULL) != SQLITE_OK) 
        sqlite3_exit("sqlite3_exec", db);

    printf("Success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanından kayıtların elde edilmesi biraz daha ayrıntılı bir konudur. İstenilen kayıtların elde edilmesi için iki 
    yol vardır. Birincisinde önce sqlite3_prepare fonksiyonu ile SQL SELECT cümlesi VTYS’ye gönderilir. Sonra her bir kayıt 
    tek tek sqlite3_step fonksiyonu çağrılarak elde edilir. sqlite3_prepare fonksiyonundan elde edilen kayıtların bir liste 
    oluşturduğunu sqlite3_step fonksiyonunun da listede sonraki kayıta geçtiğini düşünebilirsiniz. Yani adeta sqlite3_step 
    fonksiyonu imleci bir sonraki kayda konumlandırıyormuş gibidir. O andaki kayıtın sütun elemanları sqlite3_column_xxx 
    fonksiyonlarıyla elde edilebilir. Burada xxx o sütunun türünü belirtmektedir. sqlite3_prepare fonksiyonunun prototipi 
    şöyledir:

    int sqlite3_prepare(
        sqlite3 *db,            /* Database handle */
        const char *zSql,       /* SQL statement, UTF-8 encoded */
        int nByte,              /* Maximum length of zSql in bytes. */
        sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
        const char **pzTail     /* OUT: Pointer to unused portion of zSql */
    );

    Fonksiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre SELECT 
    cümlesini belirtir. Üçüncü parametre ikinci parametredeki SELECT cümlesine ilişkin yazının uzunluğunu belirtir. Bu 
    parametre negatif değer geçilirse (örneğin -1) bu yazı null karaktere kadar ele alınır. Fonksiyonun dördüncü parametresi 
    sqlite3_stmt türünden bir yapı göstericisinin adresini almaktadır. Bu da bir handle değeri gibidir. Kayıtlar elde edilirken 
    bu handle değeri kullanılmaktadır. Son parametre NULL geçilebilir. Fonksiyon başarı durumunda SQLITE_OK değerine geri 
    dönmektedir. Fonksiyon başarılı olduğunda imleç ilk kayıdın bir gerisini göstermektedir. Yani işleme önce bir kez 
    sqlite3_step çağrısı yaparak başlamak gerekir. Her sqlite3_step çağrısı select edilen kayıtlardan bir sonrasına konumlanma 
    sağlar. sqlite3_step fonksiyonunun prototipi şöyledir:

    int sqlite3_step(sqlite3_stmt*);

    Fonksiyonun parametresi sqlite3_prepare fonksiyonundan alınan handle değeridir. Son kayda erişildikten sonra sqlite3_step 
    fonksiyonu SQLITE_DONE değerine geri dönmektedir. O halde bu yöntemde önce bir kez sqlite3_prepare fonksiyonu çağrılır. 
    Sonra bir döngü içerisinde sqlite2_step çağrıları yapılır. İmleç konumlandırıldıktan sonra sütun değerleri sqlite3_column_xxx 
    fonksiyonlarıyla elde edilmektedir. Her sütun türü için ayrı bir fonksiyon vardır. Bu fonksiyonlardan bazılarının 
    prototipleri aşağıda verilmiştir:

    const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
    double sqlite3_column_double(sqlite3_stmt*, int iCol);
    int sqlite3_column_int(sqlite3_stmt*, int iCol);
    sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
    const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
    const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
    int sqlite3_column_type(sqlite3_stmt*, int iCol);
    sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);

    Bu işlemler bittikten sonra sqlite3_finalize fonksiyonu çağrılmalıdır. Fonksiyonun prototipi şöyledir:

    int sqlite3_finalize(sqlite3_stmt *pStmt);

    Fonksiyon başarı durumunda SQLITE_OK değeri ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte komut satırında bir menü çıkartılmış ve seçilen seçeneğe göre uygun işlemler yapılmıştır. Menü 
    aşağıdaki gibidir:

    1) Kayıt Ekle
    2) Kayıt Sil
    3) Kayıt Bul
    4) Çıkış
    Seçiminiz:

    Örnekteki "student.db" veritabanı yoksa yaratılmaktadır varsa olan veritabanı açılmaktadır. Eğer veritabanı yoksa aşağıdaki
    SQL komutuyla tablo yaratılmıştır:

    "CREATE TABLE IF NOT EXISTS student_info(student_id INTEGER PRIMARY KEY AUTOINCREMENT, 
        student_name VARCHAR(64), 
        student_no INTEGER
    );"

    Görüldüğü gibi student_infıo tablosunda üç sütun vardır. Sütunlardan biri otomatik artırımlı PRIMARY KEY sütunudur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include "sqlite3.h"

int disp_menu(void);
void clear_stdin(void);
void add_record(sqlite3 *db);
void del_record(sqlite3 *db);
void find_record(sqlite3 *db);
void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;
    int option;

    setlocale(LC_ALL, "tr_TR.UTF-8");

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db,
            "CREATE TABLE IF NOT EXISTS student_info("
            "student_id INTEGER PRIMARY KEY AUTOINCREMENT, "
            "student_name VARCHAR(64), "
            "student_no INTEGER);", NULL, NULL, NULL != SQLITE_OK))
        sqlite3_exit("sqlite3_exec", db);

    for (;;) {
        if ((option = disp_menu()) == -1) {
            printf("Geçersiz seçenek!..\n");
            clear_stdin();
            continue;
        }
        switch (option) {
            case 1:
                add_record(db);
                break;
            case 2:
                del_record(db);
                break;
            case 3:
                find_record(db);
                break;
            case 4:
                goto EXIT;
            default:
                printf("Geçersiz seçenek!..\n");
        }
    }

EXIT:
    sqlite3_close(db);

    return 0;
}

int disp_menu(void)
{
    int option;

    printf("1) Kayıt Ekle\n");
    printf("2) Kayıt Sil\n");
    printf("3) Kayıt Bul\n");
    printf("4) Çıkış\n");

    printf("Seçiminiz: ");
    fflush(stdout);
    if (scanf("%d", &option) != 1)
        return -1;
    clear_stdin();

    return option;
}

void clear_stdin(void)
{
    while (getchar() != '\n')
        ;
}

void add_record(sqlite3 *db)
{
    char name[64];
    char sql[1024];
    char *str;
    int no;

    printf("Adı Soyadı:");
    fflush(stdout);
    fgets(name, 64, stdin);
    if ((str = strchr(name, '\n')) != NULL)
        *str = '\0';
    printf("No:");
    fflush(stdout);
    scanf("%d", &no);
    clear_stdin();

    sprintf(sql, "INSERT INTO student_info(student_name, student_no) VALUES('%s', %d);", name, no);

    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot add record!..\n");
}

void del_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';
    sprintf(sql, "DELETE FROM student_info WHERE %s;", condition);
    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot delete record!..\n");
}

void find_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;
    sqlite3_stmt *stmt;
    unsigned char *name;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';

    printf("\n");
    if (*str == '\0')
        strcpy(sql, "SELECT student_name, student_no FROM student_info");
    else
        sprintf(sql, "SELECT student_name, student_no FROM student_info WHERE %s;", condition);

    if (sqlite3_prepare(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        return;
    }

    while (sqlite3_step(stmt) != SQLITE_DONE) {
        name = sqlite3_column_text(stmt, 0);
        no = sqlite3_column_int(stmt, 1);
        printf("%s, %d\n", name, no);
    }

    sqlite3_finalize(stmt);

    printf("\n");
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki işlemlerin benzerlerinin MySQL'de nasıl yapılacağını görelim. MySQL'in de C için API'leri vardır. 
    MySQL VTYS’si ile işlemler MySQL’in gerekli kütüphanelerinin client tarafta kurulması gerekir. Bunun için Windows’ta, 
    macOS sistemlerinde ve Linux’ta “MySQL C++ Connector” denilen kurulum yapılabilir. Bu paket aşağıdaki bağlantıdan
    indirilebilir:

    https://downloads.mysql.com/archives/c-c/

    Bu kurulum yapıldığında tipik olarak gerekli olan kütüphaneler ve include dosyaları "C:\Program Files\MySQL\MySQL Connector C 6.1"
    gibi bir dizine kurulacaktır.

    Debian türevi (Ubuntu, Mint vs.) sistemlerde aşağıdaki apt-get komutu bu paketin indirilerek kurulmasını sağlamaktadır:

    $ sudo apt-get install libmysqlclient-dev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows ortamında VisualStudio IDE'sinde çalışıyorsanız projenizde "Additional Include Drectories" elemanında MySQL 
    Connector'ü kurduğunuz dizindeki include dizinini burada belirtmelisiniz. Ayrıca Windows'ta link işlemi için "libmysql.lib"
    import kütüphanesinin de projede belirtilmesi gerekmektedir. Ancak programın çalışabilmesi için "libmysql.dll" dosyasının 
    ya sistem tarafından bakılan dizinlerin birinde olması ya da PATH çevre değişkeni ile belirtilen dizinlerden birinde olması 
    gerekmektedir.

    Linux'ta MySQL include dosyaları "/usr/include/mysql" dizini içerisindedir. Dolayısıyla include işlemi <mysql/mysql.h>
    biçiminde yapılmalıdır. Linux'ta ayrıca "libmysqlclient" kütüphanesinin de bağlama işlemine dahil edilmesi gerekmektedir. 
    Derleme işlemini şöyle yapmalısınız:

    $ gcc -o sample sample.c -lmysqlclient
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir MYSQL C programda ilk yapılacak şey mysql_init fonksiyonu çağırarak bir handle elde etmektir:

    MYSQL *MySQL_init(MYSQL *MySQL);

    Bu fonksiyon parametre olarak bizden MYSQL türünden bir nesnenin adresini ister onun içini doldurur. Eğer parametre NULL 
    girilirse fonksiyon bu nesneyi kendisi tahsis edip bize aresini verecektir. Fonksiyon başarısız olabilir. Başarısızlık 
    durumunda NULL adrese geri döner. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "MySQL_init failed\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

int main(void)
{
    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysqlL_init failed\n");
        exit(EXIT_FAILURE);
    }

    printf("Ok\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    MYSQL * türünden handle elde ediltiktan sonra artık "IP adresi", "port numarası", "kullanıcı adı", "parola" ve bağlanılacak
    veritabını velirtilerek bağlantı mysl_real_connect fonksiyonuyla sağlanır. Fonksiyonun prototipi şöyledir:

    MYSQL *mysql_real_connect(MYSQL *MySQL, const char *host, const char *user, const char *passwd, const char *db, 
            unsigned int port, const char *unix_socket, unsigned long client_flag);

    Fonksiyonun birinci parametresi mysql_init fonksiyonundan elde edilmiş olan handle değeridir. İkinci parametre host'un
    IP adresini üçüncü parametre MySQL'deki kullanıcı ismini almaktadır. MySQL'i ilk kurduğunuzda tüm yetkilere sahip bir 
    "root" kullanıcısı bulunmaktadır. Bu kullanıcı tüm veritabanlarına erişebilmektedir. Tabii siz isterseniz kısıtlı 
    kullanılarda yaratabilirsiniz. Fonksiyonun dördüncü parametresi kullanıcıya ilişkin parolayı belirtmektedir. "root" 
    kullanıcısının parolası kurulum sırasında belirlenmektedir. Beşinci parametre kullanılacak veritabaınının ismini almaktadır. 
    Altıncı parametre port numarasını belirtmektedir. MySQL Server programlarının kullandığı default port numarası 3306'dır. 
    Son iki parametre NULL ve 0 biçiminde geçilebilir. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysql_init failed!..\n");
        exit(EXIT_FAILURE);
    }

    if (mysql_real_connect(db, "localhost", "root", "maviay", "student_info", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", NULL);

    MySQL ile çlışırken hata durumlarında bağlantıyı kapatıp prosesi sonlandırmak için aşağıdaki gibi bir fonksiyondan 
    faydalanabiliriz:

    void exit_err(const char *msg, MYSQL *db)
    {
        fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
        mysql_close(db);
        exit(EXIT_FAILURE);
    }

    mysql_close fonksiyonuna NULL adres geçilirse close işlemi yapılmaz ama mysql_init fonkisyonuyla tahsis edilmiş olan handle 
    alanu boşaltılır.

    Server'a bağlanırken birkaç problem ortaya çıkabilir. Server default SSL kullanıyor olabilir. Bu durumda SSL konfigürasyonunu
    yapmadıysanız bağlantı sırasında sorun oluşabilir. Bağlanırken SSL'i pasif hale getirmek için (disable etmek için) iki yöntem 
    kullanılabilir. Birincisi "mysql.ini" ya da "my.cnf" dosyasına aşağıdaki satırlar girilerek SSL kullanımı devra dışı bırakılabilir:

    [mysqld]
    ssl=0
    skip_ssl

    Windows sistemlerinde "mysql.ini" dosyası "C:\ProgramData\MySQL\MySQL Server 8.0" dizin içerisinde bulunmaktadır. Linux 
    sistemlerinde "my.cnf" dosyası "/etc/mysql" dizini içerisindedir. Bu dosyaları edit etmek için editörünüzü "Administrator" 
    ya da "sudo" hakkıya açmalısınız. İkinci yöntem programa özgü bir biçimde SSL'i mysql_options fonksiyonu ile devre dışı 
    bırakmaktır. Bu işlem şöyle yapıabilir:

    int ssl_mode = SSL_MODE_DISABLED;

    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode))
        exit_err("mysql_options failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Eskiden MySQL server programı default olarak uzak bağlantıları kabul ediyordu. Sonra default durumda uzak bağlantılara
    izin verilmemeye başlandı. Yani siz yerel ağınızda bile olsa başka bir makinedeki MySQL Server programına IP adresi ve 
    port numarası belirterek bağlanamayabilirsiniz. Uzak bağlantılara izin vermek için konfügrasyonda bazı ayarlamaların 
    yapılması gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            191. Ders 21/03/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL cümlesini server’a gönderip işletmek için MySQL_query fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int mysql_query(MYSQL *MySQL, const char *stmt_str);

    Fonksiyonun birinci parametresi handle değerini ikinci paarametresi SQL komut yazısını alır. Fonksiyon başarı durumunda 
    sıfır başarısızlık durumunda sıfır dışı bir değere geri döner. Örneğin:

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no) VALUES('Ali Eker', 345)") != 0) 
        exit_err("mysql_query", db);
    
    Aşağıda program bir bütün olarak verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode)) 
        exit_err("mysql_options failed", db);
    
    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL) 
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no, student_school_id) VALUES('Ali Eker', 122, 1)") != 0) 
        exit_err("mysql_query", db);
    
    printf("Ok\n");

    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    MySQL server'ı Linux'ta kullanıyorsanız tüm ayarlar default durumda Unicode UTF-8 enconding'ine ilişkindir. Linux ortamında 
    uzun süredir default encoding zaten Unicode UTF-8 olduğu için bu ortamda çalışırken bir encoding sorunu ortaya çıkmayacaktır. 
    Ancak Windows sistemlerinde MySQL server kurulduğunda default encoding Unicode UTF-8 yerine Microsoft'un 1254 Code Page'i
    olabilir. MySQL'de encoding çeşitli düzeylerde değiştirilebilmektedir. Örneğin:

    - Server Düzeyinde
    - Veritabanı Düzeyinde
    - Tablo Düzeyinde
    - Tablonun Sütunu Düzeyinde

    Aşağıdaki belirleme yukarıda yapılan belirlemeyi devre dışı bırakmaktadır. Ayrıca MySQL'de client ptogramlar da server
    ile bağlandığında server'dan belli bir encoding kullanmasını isteyebilmektedir. Yani server ayarları yapılmış olsa bile 
    client programların da encoding isteklerinin uygun olması gerekebilmektedir. Client'ın default encoding davranış da aslında
    server ayarlarından belilenebilmektedir. Client için bu ayar uygun değile client program bağlantıdan sonra mysql_options
    fonksiyonu ile bunu aşağıdaki gibi değiştirebilir:

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Belli koşulu sağlayan kayıtların ele geçirilmesi için başka bir deyişle SELECT cümlesi ile seçilen kayıtların elde 
    edilmesi için birkaç yol vardır. Bunun için önce SELECT cümlesi yine sql_query fonksiyonuyla uygulanır. Sonra select 
    edilen kayıtların elde edilmesi için şu işlemler yaplır:

    1) mysql_store_result fonksiyonu çağrılarak bir “result handle değeri” elde edilir:

    MYSQL_RES *mysql_store_result(MYSQL *MySQL);

    Fonksiyon parametre olarak bizden mysql_init ile elde edilen handle değerini alır ve bize kayıtları elde etmemiz için 
    gereken MYSQL_RES * türünden bir handle değeri verir. Fonksiyon başarısız olursa NULL adrese geri dönmektedir. 

    2) Kayıtların tek tek ele geçirilmesi için mysql_fetch_row fonksiyonu bir döngü içerisinde çağrılır. Bu fonksiyonun 
    prototipi şöyledir:

    MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);

    Fonksiyon mysql_store_result fonksiyonundan elde edilen handle değerini alır ve MYSQL_ROW türüyle geri döner. Bu tür 
    aslında char ** biçiminde typedef edilmiştir. Yani char türünden göstericileri tutan dizinin adresini belirtir. İşte 
    bu fonksiyon NULL adres döndürene kadar döngü içerisinde ilerlenir. Arık kayıtlara ilişkin sütun bilgilerine MYSQL_ROW 
    türünden göstericiye sütun numarası indeks yapılarak erişilir. Ancak bu türden erişim bize tüm sütunları yazı gibi 
    vermektedir. Kayıtlar elde ediltikten sonra mysql_store_result ile elde edilen alan mysql_free_result fonksiyonu ile 
    boşaltılmalıdır. Fonksiyonun parametrik yapısı şöyledir:

    void mysql_free_result(MYSQL_RES *result);   
    
    Örneğin:

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0) 
        exit_err("mysql_query", db);

    if ((res = mysql_store_result(db)) == NULL) 
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL) 
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);

    Burada önce SELECT cümlesi server'a gönderilmiş, sonra mysql_store_result fonksiyonu ile sonuçlar alınıp satırlar da 
    mysql_fetch_row çağrıları ile tek tek elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;
    MYSQL_RES *res;
    MYSQL_ROW row;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode) != 0) 
        exit_err("mysql_options failed", db);

    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL) 
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0) 
        exit_err("mysql_query", db);
    
    if ((res = mysql_store_result(db)) == NULL) 
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL) 
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);
    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            192. Ders 23/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu son bölümde işletim sistemlerindeki GUI (Graphical USer Interface) çalışma modeli hakkında temel bilgiler vereceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Bilgisayar ekranları temel olarak iki modda çalışmaktadır:

    1) Text Mod
    2) Grafik Mod

    Eskiden text mod çalışma çok yaygındı. Çünkü grafik kartları henüz gelişkin değildi. Ancak son 20 senedir grafik mod çalışma 
    baskın hale gelmiştir. 

    Text modda ekrana basılabilecek en küçük birim bir karakterdir. Bu karakterler kalıp olarak ekrana basılmaktadır. Dolayısıyla 
    text modda çalışma çok hızlıdır. Ancak text modda resimler görüntülenemez, filmler izlenemez. 
    
    Grafik modda ekranda görüntülenebilen en küçük görsel öğeye "pixel" denilmektedir. Pixel bir noktadır. İşte grafik modda 
    ekrandaki tüm görsel öeğeler bu pixel'lerin bir araya getirilmesiyle oluşmaktadır. Her pixel'in rengi diğerlerinden bağımsız 
    bir biçimde ayarlanabilmektedir. Bugünkü grafik kartlarında ve monitörlerde her pixel "kırmızı (red)", "yeşil (green)" ve 
    "mavinin (blue)" birer byte'lık tonal bileşimleriyle oluşturulmaktadır. Bir byte 8 bit olduğu için bir pixel 2^8 * 2^8 * 
    2^8 = 2^24 ≃ 16 milyon renkten herhangi biriyle renklendirilebilmektedir. Aslında grafik modda tüm resimler ve yazılar bu 
    pixel'lerin bir araya getirilmesiyle oluşturulmaktadır. Ekranı bir pixel matrisi olarak düşünebilirsiniz. Örneğin 1920x1080 
    HD çözünürlükte matriste 1920 sütun 1080 tane de satır bulunmaktadır. Yani ekranda toplam 2 milyon civarı pixel bulunur. 

    Aynı monitörde çözünürlüğü yükseltirsek pixel'ler küçülür, resimler ve yazılar ekranda daha küçük görünür hale gelir, ancak 
    ekrana daha fazla içerik sığar. Eğer çözünürlük düşürülürse bu kez pixel'ler büyür, yazılar ve resimler büyük gözükür. 
    Pekiyi çözünürlük sabit bırakılıp ekran büyütülürse ne olur? Yine pixel'ler büyüyecektir. Bu durumda çözünürlük yükseltildikçe 
    her şey küçüleceği için monitörün büyütülmesi uygun olur. Monitör büyüklüğü ile pixel yoğunlu arasındaki ilişki "DPI (Dot 
    Per Inch)" bir terimle ifade edilmektedir. DPI bir inch'teki pixel saysıdır. Çözünürlük aynı kalıp monitör büyütülürse DPI 
    düşer, çözünürlük aynı kalıp monitör küçültülürse DPI yükselir. Benzer biçimde monitör aynı kalıp çözünürlüğü düşürürsek 
    DPI düşecek, monitör aynı kalıp çözünürlüğü yükseltirsek DPI artacaktır. Belli bir DPI değerinden sonra artık çözünürlüğü 
    artırmanın da bir anlamı kalmamaktadır. Çünkü insan gözündeki alglayıcı kısım olan retinanın da bir çözünürlüğü vardır. 

    Ekrandaki görüntü aslında grafik kartları (GPU) tarafından oluşturulmaktadır. Görüntüyü ekrankartları oluşturur, onu belli 
    periyotta monitöre yollar, monitör de pixel'leri görüntüler. Yani monitör pasif bir aygıttır. Asıl işi yapan kısım grafik 
    kartlarıdır. 

    Ekranın bir bölümü text modda bir bölümü grafik modda olmaz. Bugün GUI arayüzlü işletim sistemlerinde konsol pencerelerini 
    açtığımızda o pencelere text modda çalışmamaktadır. Konsol pencereleri grafik modda text modu pixel'lerle simüle etmektedir. 
    Text mod çalışma çok yaygın ve pratik olduğu için bugün yine yoğun bir biçimde kullanılmaktadır. 

    Ekran koordinat sisteminde genellikle ekranın sol üst köşesi orijin noktasıdır. X ekseni sağa doğru, Y ekseni aşağıda 
    doğru ilerlemektedir. Ekran koordinat sisteminde her pixel'in bir koordinatı vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            193. Ders 11/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki GUI çalışma çok zengin olanaklar sunuyor, pekiyi neden o zaman hala konsol uygulamaları kullanılıyor? 
    İşte GUI programların yazılması oldukça zordur. GUI programların yazılmasını kolaylaştırmak için pek çok yüksek seviyeli 
    kütüphaneler oluşturulmuştur. Oysa text modda klasik konsol çalışma modeli oldukça basittir. Bazı sistemler ise hiç GUI 
    arayüzüne sahip olmayabilmektedir. Örneğin UNIX/Linux sistemlerinde hala klasik konsol çalılma modeli çok yaygın biçimde 
    kullanılmaktadır. (UNIX/Linux sistemleri özellikle sunucularda kullanıldığı için ve sunucuların grafik arayüze sahip olması 
    onların hızını ve kaynak kullanımını yavaşlatacağı için bu sistemlerde klasik konsol çalışma modeli hala en yaygın modeldir.)

    GUI çalışma modeli ile klasik konsol çalışma modelini karşılaştırarısak şunları söyleyebiliriz:

    - GUI çalışma modelinin uygulanması için bilgisayar sisteminin bazı gelişmiş özelliklere sahip olması gerekir. Halbuki 
    konsol çalışma modeli DOS gibi basit işletim sistemlerinde ve onların çalıştığı eski donanımlarda bile oldukça verimli
    bir biçimde uygulanabiliyordu.

    - GUI çalışma modelini kullanarak program yazmak oldukça zordur. Programcılar işlerini kolaylaştırmak için yüksek seviyeli
    GUI kütüphanelere gereksinim duyarlar. Bu da ek bir çalışma ve eğitim gerektirmektedir.  

    - GUI çalışma modeli konsol çalışma modeline göre yavaştır ve çok daha fazla sistem kaynağına gereksinim duymaktadır.

    - GUI çalışma modeli modern grafiksel bir girdi ve çıktı ortamı sunmaktadır. Halbuki konsol çalışma ortamında her şey
    karakterlerin kalıp olarak konsol ekranına basılmasıyla oluşturulmaktadır. Yani GUI çalışma modeli albenili ve zengin 
    bir arayüz sunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
     Windows’un çekirdek ile entegre edilmiş bir GUI alt sistemi vardır. Başka bir deyişle Windows’ta pencereli çalışma başka 
    bir katman tarafından değil doğrudan işletim sisteminin çekirdeği tarafından sağlanmaktadır. Windows’u GUI alt sistemi 
    olmadan kullanmak mümkün olsa da uygulamada çok zordur. Windows'ta GUI arayüz olmadan çalışma anlamlı değildir. 

    UNIX/Linux sistemlerinde grafik arayüz çekirdeğin üzerine oturtulan ve ismine X11 (ya da XWindow) denilen bir alt sistem 
    tarafından sağlanmaktadır. Yani örneğin Linux’un çekirdeğinin kaynak kodlarında pencere kavramına ilişkin hiçbir şey yoktur. 
    Ancak Windows’ta vardır. Zaten Linux sistemlerinde doğal çalışma grafik arayüz ile değil text ekrandaki konsol arayüzü 
    ile sağlanmaktadır. Server olarak kullanılan Linux sistemlerinde de genellikle sistemi yavaşlattığı gerekçesiyle grafik 
    arayüz kullanılmamaktadır. Son yıllarda UNIX/Linux dünyasında klasik X11 GUI alt sistemine bir alternatif olarak "Wayland" 
    isimli yeni bir alt sistem de tasarlanmıştır. Wayland alt sistemi X11'e göre daha modern ve hızlı bir tasarıma sahip olmakla 
    birlikte henüz yaygınlaşmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    X11 grafik sistemi client-server tarzda çalışmaktadır. Yani sanki X11 bir server program gibidir, pencere açmak ve pencereler 
    üzerinde işlemler yapmak isteyen programlar da client programlar gibidir. X11 sisteminde işlem yapabilmek için oluşturulmuş 
    temel kütüphaneye Xlib denilmektedir. Xlib'i X11’in API kütüphanesi olarak düşünebiliriz. Son yıllarda Xlib’in XCB isimli 
    daha modern bir versiyonu da oluşturulmuştur. Xlib ve XCB temelde C Programlama Dilinden kullanılmak için tasarlanmıştır. 
    Ancak bu kütüphaneler başka dillerden de kullanılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
 Grafik arayüze sahip pencereli sistemlerde genel olarak "mesaj tabanlı (message driven)" ya da "olay tabanlı (event driven)" 
    denilen çalışma modeli kullanılmaktadır. Mesaj tabanlı çalışma modelinin ayrıntıları sistemden sisteme değişebilmekle birlikte 
    burada biz her sistemde geçerli olan bazı temel bilgileri vermekle yetineceğiz. 

    Mesaj tabanlı programlama modelinde klavye ve fare gibi aygıtlarda oluşan girdileri programcı kendisi almaya çalışmaz. 
    Klavye gibi, fare gibi girdi aygıtlarını işletim sisteminin (ya da GUI alt sistemin) kendisi izler. Oluşan girdi olayı hangi 
    pencereye ilişkinse işletim sistemi ya da GUI alt sistem bu girdi olayını “mesaj” adı altında bir yapıya dönüştürerek o
    pencerenin iişkin olduğu (yani o pencereyi yaratan) programın “mesaj kuyruğu (message queue)” denilen bir kuyuk sistemine 
    yerleştirir. Mesaj kuyruğu içerisinde mesajların bulunduğu FIFO prensibiyle çalışan bir kuyruk veri yapısıdır.  Sistemin daha 
    iyi anlaşılması için süreci maddeler halinde özetlemek istiyoruz:

    1) Her programın (thread'li sistemlerde her thread’in) “mesaj kuyruğu” denilen bir kuyruk veri yapısı vardır. Mesaj kuyruğu 
    mesajlardan oluşmaktadır. 

    2) İşletim sistemi ya da GUI alt sistem gerçekleşen girdi olaylarını “mesaj (message)” adı altında bir yapı biçimine dönüşürmekte 
    ve bunu pencerenin ilişkin  olduğu programın (ya da thread’in) mesaj kuyruğuna eklemektedir.

    3) Mesajlar ilgili olayı betimleyen ve ona ilişkin bazı bilgileri barındıran yapı (structure) nesleridir. Örneğin Windows’ta 
    mesajlar MSG isimli bir yapıyla temsil edilmişleridir. Bu yapının elemanlarında mesajın ne mesajı olduğu (yani neden gönderildiği) 
    ve mesajın gönderilmesine neden olan olaya ilişkin bazı parametrik bilgiler bulunur.

    Görüldüğü gibi GUI programlama modelinde girdileri programcı elde etmeye çalışmamaktadır. Girdileri bizzat işletim sisteminin 
    kendisi ya da GUI alt sistemi elde edip programcıya mesaj adı altında iletmektedir.

    GUI programlama modelinde işletim sisteminin (ya da GUI alt sistemin) oluşan mesajı ilgili programın (ya da thread’in) mesaj 
    kuyruğuna eklemenin dışında başka bir sorumluluğu yoktur. Mesajların kuyruktan  alınarak işlenmesi ilgili programın sorumluluğundadır. 
    Böylece GUI programcısının mesaj kuyruğuna bakarak sıradaki mesajı alması ve ne olmuşsa ona uygun işlemleri yapması gerekir. 
    Bu modelde programcı kodunu şöyle düzenler: "Bir döngü içerisinde sıradaki mesajı kuyruktan al, onun neden gönderildiğini belirle, 
    uygun işlemleri yap, kuyrukta mesaj yoksa da blokede bekle”. İşte GUI programlarındaki mesaj kuyruğundan mesajı alıp işleyen 
    döngüye mesaj döngüsü (message loop) denilmektedir.

    Bir GUI programının işleyişini tipik akışı aşağıdaki gibi bir kodla temsil edebiliriz:

    int main(void)
    {
        <programın ana pencerisini yarat>

        for (;;) {
            <mesaj kuyruğundan sıradaki mesajı al>
            <mesajın ne mesajı olduğunu anla ve gerekeni yap>
            if (mesaj oencerinin x tuşuna basma mesajı mı)
                break;
        }

        return 0;
    }

    Bu temsili koddan da görüldüğü gibi tipik bir GUI programda programcı bir döngü içerisinde mesaj kuyruğundan sıradaki 
    mesajı alır ve onu işler. Mesajın işlenmesi ise “ne olmuş ve ben buna karşı ne yapmalıyım?” biçiminde oluşturulmuş olan 
    kodlarla yapılmaktadır. 

    Pekiyi bir GUI program nasıl sonlanmaktadır? İşte pencerenin sağındaki (bazı sistemlerde solundaki) X simgesine kullanıcı 
    tıkladığında işletim sistemi ya da GUI alt sistem bunu da bir mesaj olarak o pencerenin ilişkin olduğu prosesin (ya da 
    thread’in) mesaj kuyruğuna bırakır. Programcı da kuyruktan bu mesajı alarak mesaj döngüsünden çıkar ve program sonlanır. 
 
    GUI ortamımız (framewok) ister .NET, ister Java, ister MFC, isterse Qt olsun, işletim sisteminin ya da GUI alt sistemin 
    çalışması hep burada ele açıklandığı gibidir. Yani örneğin biz .NET'te ya da Java'da işlemlerin sanki başka biçimlerde 
    yapıldığını sanabiliriz. Aslında işlemler bu ortamlar tarafından aşağı seviyede yine burada anlatıldığı gibi yapılmaktadır. 
    Bu ortamlar (frameworks) ya da kütüphaneler çeşitli yükleri üzerimizden alarak bize daha rahat bir çalışma modeli sunarlar. 
    Ayrıca şunu da belirtmek istiyoruz: GUI programlama modeli özellikle nesne yönelimli programlama modeline çok uygun düşmektedir. 
    Bu nedenle bu konuda kullanılan kütüphanelerin büyük bölümü sınıflar biçiminde nesne yönelimli diller için oluşturulmuş 
    durumdadır. Örneğin Qt framework C++ ile, .NET Forms ve WPF framework'leri C# ile (ya da diğer nesne yönelimli :NET dilleri 
    ile) kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi GUI programlama modelindeki mesaj kavramını biraz daha açalım. Yukarıda da belirttiğimiz gibi bu modelde programcıyı 
    ilgilendiren çeşitli olaylara “mesaj” denilmektedir. Örneğin klavyeden bir tuşa basılması, pencere üzerine fare ile 
    tıklanması, pencere içerisinde farenin hareket ettirilmesi gibi olaylar hep birer mesaj oluşturmaktadır. İşletim sistemleri 
    ya da GUI alt sistemler mesajları birbirinden ayırmak için onlara birer numara karşılık getirirler. Örneğin Windows’ta 
    mesaj numaraları WM_XXX biçiminde sembolik sabitlerle kodlanmıştır. Programcılar da konuşurken ya da kod yazarken mesaj 
    numaralarını değil, bu sembolik sabitleri kullanırlar. (Örneğin WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_KEYDOWN gibi) Mesajların 
    numaraları yalnızca gerçekleşen olayın türünü belirtmektedir. Oysa bazı olaylarda gerçekleşen olaya ilişkin bazı bilgiler 
    de söz konusudur. İşte bir mesaja ilişkin o mesaja özgü bazı parametrik bilgiler de işletim sistemi ya da GUI alt sistem 
    tarafından mesajın bir parçası olarak mesajın içerisine kodlanmaktadır. Örneğin Windows’ta biz klavyeden bir tuşa bastığımızda 
    Windows WM_KEYDOWN isimli mesajı programın mesaj kuyruğuna bırakır. Bu mesajı kuyruktan alan programcı mesaj numarasına 
    bakarak klavyenin bir tuşuna basılmış olduğunu anlar. Fakat hangi tuşa basılmıştır? İşte Windows basılan tuşun bilgisini 
    de ayrıca bu mesajın içerisine kodlamaktadır. Örneğin  WM_LBUTTONDOWN mesajını Windows farenin sol tuşuna tıklandığında 
    kuyruğa bırakır. Ancak ayrıca basım koordinatını da mesaja ekler. Yani bir mesaj oluştuğunda yalnızca o mesajın hangi tür 
    bir olay yüzünden oluştuğu bilgisini değil aynı zamanda o olayla ilgili bazı bilgileri de kuyruktaki mesajın içerisinden 
    alabilmekteyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                             194. Ders 18/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows'ta GUI programları en aşağı seviyede Windows API fonksiyonları kullanılarak yazılmaktadır. Ekrana boş bir pencere
    çıkartan iskelet bir GUI programı aşağıdaki gibi yazılabilir:

    #include <windows.h>

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

    int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
    {
        WNDCLASS wndClass;
        HWND hWnd;
        MSG message;

        if (!hPrevInstance) {
            wndClass.style = CS_HREDRAW | CS_VREDRAW;
            wndClass.cbClsExtra = 0;
            wndClass.cbWndExtra = 0;
            wndClass.hInstance = hInstance;
            wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
            wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
            wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
            wndClass.lpszMenuName = NULL;
            wndClass.lpszClassName = "Generic";
            wndClass.lpfnWndProc = (WNDPROC)WndProc;
            if (!RegisterClass(&wndClass))
                return -1;
        }
        hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
        if (!hWnd)
            return -1;
        ShowWindow(hWnd, SW_RESTORE);
        UpdateWindow(hWnd);
        while (GetMessage(&message, 0, 0, 0)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }
        return message.wParam;
    }

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows sistemlerinde iskelet GUI programında şunların sırasıyla yapılması gerelmektedir:

    1) Önce WNDCLASS türünden bir yapı nesnesi tanımlanıp bunun içi doldurulur ve bu yapı RegisterClass APIO fonksiyonu ile
    sisteme register ettirilir. Bu WNDCKASS belirlemelerine "pencere sınıfı " denilmektedir. Örneğin:

    WNDCLASS wndClass;
    
    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }

    2) Programın ana penceresi pencere sınıfı kullanılarak yaratılır:

    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, 
                CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;

    Ana pencere yaratıldıktan sonra pencerenin görünür hale getirilmesi gerekmektedir:

    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);

    3) Artık program mesaj döngüsüne girmelidir. Mesaj döngüsü kuyruktan sıradaki mesajı alıp bunu işleyen döngüdür. Mesaj
    döngüsü şöyle oluşturulmaktadır:

    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }

    Burada GetMessage API fonksiyonu mesaj kuruğundan mesajı alır. TranslateMessage klavye mesajları için bazı dönüştürmeleri 
    yapmaktadır. Mesajın işlenmesine yol açan fonksiyon DispatchMessage isimli API fonksiyonudur. Ancak DispatchMessage aslında
    pencere sınıfında belirtilen fonksiyonun çağrılmasına yol açmaktadır. Örneğimizde bu fonksiyon WndProc ismindedir. Yani
    DisptachMessage yapıldığında aslında WndProc fonksiyonu çağrılmaktadır. Buna "pencere fonsiyonu" denir. Programcı mesajı
    bu fonksiyon içerisinde işler. WndProc fonksiyonu şöyle yazılmıştır:

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
            case WM_DESTROY:
                PostQuitMessage(0);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows'ta kuyruğa bırakılan bazı mesajların mutlaka işlenmesi gerekir. Bu işlem de çok sıkıcı olduğu için DefWindowProc
    isimli bir fonksiyon bulundurulmuştur. Programcı tarafından işlenmeyen mesajlar DefWindowProc fonksiyonuna verilir. Bu 
    fonksiyon mesaj için gereken bazı default işlemler varsa onu yapar. Programın sonlanması pencerenin X simgesine tıklanarak 
    yapılır. Bu durumda Windows kuyruğa WM_CLOSE isimli mesajı bırakır. DefWindowProc bu mesaj için DestroyWindow fonksiyonunu
    çağırır. Bu fonksiyon da WM_DESTROY mesajını oluşturur. Bu mesajda programcı PostQuitMessage API fonksiyonunu çağırır. 
    Bu API fonksiyonu da kuyruğa WM_QUIT mesajını bırakır. WM_QUIT mesajını alan GetMessage fonksiyonu 0 ile geri döner. 
    Böylece döngü sonlanır ve program da biter.
---------------------------------------------------------------------------------------------------------------------------*/

#include <windows.h>

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
{
    WNDCLASS wndClass;
    HWND hWnd;
    MSG message;

    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }
    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
        CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;
    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);
    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }
    return message.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:
        MessageBox(hWnd, u8"Farenin sol tuşuna basıldı", "Mesaj", MB_OK);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğmiz gibi UNIX/Linux sistemlerinde XWindow ya da X11 denilen bir katman kullanılmaktadır. Bu 
    katmanın API fonksiyonlarına Xlib ya da bunun modern biçimine XCB denilmektedir. Xlib ya da XCB çok aşağı seviyeli bir 
    kütüphanedir. Bu kütüphane kullanılarak GUI elemanlarını oluşturan X-Toolkit ya da kısaca Xt isimli ayrı bir kütüphane 
    vardır. Bu Xt üzerine kurulan Motif gibi başka kütüphaneler de vardır. Ayrıca Xlib ya da XCB üzerine kurulmuş olan iki 
    önemli kütüphane de Qt ve GTK (GTK+ da denilmektedir) kütüphanelerdir. Qt kütüphanesi C++ ile yazılmıştır, dolayısıyla 
    Qt için kodlar da C++ ile yazılmaktadır. GTK ise C'de yazılmıştır. 

                          +----------------------------+
                          |     GUI Uygulamaları      |
                          +----------------------------+
                           /            |            \
                          /             |             \
                         /              |              \
                +--------+        +-----------+     +----------+
                |   GTK  |        |   Qt      |     |  Motif   |
                +--------+        +-----------+     +----------+
                     |                |                  |
          +----------+----+       +--+--+--+        +---+--+
          | Xlib / Wayland|       |Xlib/XCB|        |  Xt  |
          +----------+----+       +--+--+--+        +---+--+
                     |                |                 |
                     |                |             +--+--+--+  
                     |                |             |Xlib/XCB|
                     |                |             +--+--+--+ 
                     |                |                 |
         +-----------+----------------+-----------------+-----------------+
         |      X Window System (X11)       |     Wayland (alternatif)    |
         +----------------------------------+-----------------------------+
         |               Donanım / OS (Çekirdek, GPU)                     |
         +----------------------------------------------------------------+

    Şimdi de bu kütüphanelerin hiyeararşisini tek tek gösterelim. GTK kütüphanesini şöyle gösterebiliriz:

    GTK
    Xlib / Wayland
    X Window / Wayland

    Xt kütüphanesini şöyle gösterebiliriz:

    Xt
    Xlib 
    X Window

    Motif kütüphanesini şöyle gösterebiliriz:

    Xt
    Xlib 
    X Window

    Qt kütüphanesini de şöyle gösterebiliriz:

    Qt
    Xlib / Wayland
    X Window / Wayland

    Bugün artık Xt ve Motif yeni uygulamalar tarafından pek kullanılmamaktadır. Bu nedenle yüksek seviyeli kütüphaneler için
    önemli iki alternatif GTK ve Qt kütüphaneleridir. GTK kütüphanesi C ile kullanılabilir. Ancak Qt için C++ bilmek gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Xlib ya da XCB kütüphaneleri oldukça düşük seviyeli kütüphanelerdir. Bunlar aslında X Window sistemlerinin aşağı seviyeli
    API kütüphanesi gibi düşünülebilir. Xlib ile GUI uygulmaları yazmak çok zordur. Çünkü Xlib içerisinde pencere yaratan 
    öğeler olsa da GUI uygulamalarında kullanılan düğmeler (push buttons), listeleme kutuları (listbox), checkbox gibi grafik 
    elemnlar bulunmamaktadır. Eğer C kullanılarak bu GUI elemanlar ile gelişmiş GUI programla roluşturmak istiyorsanız GTK 
    kütüphanesini kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX/Linux sistemlerinde en düşük seviyede Xlib kullana iskelet bir GUI programını yazmaya çalışalım. Bu program 
    ekrana boş bir pencere çıkartacaktır. Bunun öncelikle Xlib kütüphanesinin kurulması gerekmektedir. Bu işlem Debian tabanlı
    sistemlerde şöyle yapılabilir:

    $ sudo apt-get install libx11-dev

    Derleme işlemi sırasında X11 kütüphanesinin "-lX11" seçeneği ile belirtilmesi gerekmektedir. Örneğin:

    $ gcc -o generic-Xlib generic-Xlib.c -lX11
 
    Ekrana boş bir pencere çıkartan iskelet GUI programı şöyle yazılabilir:

    /* generic-Xlib.c */

    #include <X11/Xlib.h>
    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        Display *disp;
        Window w;
        XEvent e;
        int scr;

        disp = XOpenDisplay(NULL);
        if (disp == NULL) {
            fprintf(stderr, "Cannot open display\n");
            exit(1);
        }

        scr = DefaultScreen(disp);
        w = XCreateSimpleWindow(disp, RootWindow(disp, scr), 10, 10, 100, 100, 1,
                BlackPixel(disp, scr), WhitePixel(disp, scr));
        XSelectInput(disp, w, ExposureMask | KeyPressMask);
        XMapWindow(disp, w);

        for (;;) {
            XNextEvent(disp, &e);
            if (e.type == KeyPress)
                break;
        }

        XCloseDisplay(disp);

        return 0;
    }

    Burada sırasıyla şu işlemler yapılmıştır:

    1) XOpenDisplay fonksiyonu XWindow sunucusu ile bağlantı kurmak için kullanılmaktadır. Bu fonksiyon başarı durumunda bize 
    Display türünden bir handle verir. 
    
    2) Daha sonra bizim bu handle’ı vererek bir ekran (screen) nesnesi yaratmamız gerekir. Bu işlem de DeafultScreen fonksiyonuyla 
    yapılmaktadır. Bu fonksiyon bize ilgili ekranı betimleyen int türden bir değer vermektedir. 
    
    3) Örnek programımızda daha sonra uygulamanın ana penceresi XCreateSimpleWindow fonksiyonuyla yaratılmıştır. Bu fonksiyon 
    bize Window * türünden yaratılan pencereye ilişkin bir handle değeri vermektedir. 
    
    4) Programda daha sonra mesaj döngüsüne girmeden önce hangi girdi olaylarının izleneceğini belirlemek için XSelectInput 
    fonksiyonu çağrılmıştır. 
    
    5) Mesaj döngüsünden sıradaki mesaj XNextEvent fonksiyonuyla elde edilmektedir. (Bu fonksiyonu Windows'ta GetMessage API 
    fonksiyonuna benzetebilirsiniz. Bu fonksiyon bize kuyruktaki mesajı XEvent isimli bir yapı olarak verir. Örnek programımızda 
    bir tuşa basıldığında mesaj döngüsünden çıkılmaktadır. 
    
    6) Mesaj döngüsünden çıkıldığında XCloseDisplay fonksiyonu ile daha önce alınmış olan ekran geri bırakılmıştır. Tabii 
    ekran yok edildiğinde tüm pencereler de yok edilecektir. Ayrıca program sonlandığında X11 sistemi ile bağlantı da otomatik 
    koparılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    GTK pek çok ayrıntıya sahip olan C tabanlı bir GUI kütüphanesidir. GTK kürüphanesinin son versiyonu GTK 4'tür. Bu version 
    2020'de oluşturulmuştur. Ancak önceki versiyon olan GTK 3 halen daha yoğun olarak kullanılmaktadır. GTK 3 Debian tabanlı 
    sistemlerde şöyle kurulabilir:

    $ sudo apt-get install libgtk-3-dev

    GTK 4 ise şöyle kurulabilir:

    $ sudo apt-get install libgtk-4-dev

    GTK 3 ile GTK 4 birbirine çok benzemekle birlikte tam uyumlu değildir. 

    Biz burada GTK 4 için bazı küçük örnekler vereceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Ekrana boş bir pencere çıkartan iskelet GTK 4 programı şöyle oluşturulabilir:

    #include <gtk/gtk.h>

    void activate(GtkApplication *app, gpointer user_data) 
    {
        GtkWidget *window;

        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    int main(int argc, char **argv) 
    {
        GtkApplication *app;
        int status;

        app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);
        g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

        status = g_application_run(G_APPLICATION(app), argc, argv);

        g_object_unref(app);

        return status;
    }

    Bu program şöyle derlenebilir:

    $ gcc -o generic-gtk generic-gtk.c $(pkg-config --cflags --libs gtk4)

    Burada $(pkg-config --cflags --libs gtk4) ifadesi pkg-config programının çıktısının komut satırına yerleştirilmesini 
    sağlamaktadır. GTK 4 programlarının derlenmesi için komut satırında çeşitli include dizinlerine ilişkin seçeneklerin ve 
    birden fazla dinamik kütüphanenin devreye sokulması gerekmektedir. Bu $(pkg-config --cflags --libs gtk4) ifadesi aslında
    gereken komut satırı argümanlarını oluşurmaktadır. 

    Yukarıdaki iskelet programın açıklamasını şöyle yapabiliriz:

    1) Bir GTK 4 uygulamasında önce bir GtkApplication nesnesinin oluşturulması gerekir. GtkApplication yapısı uygulama ile
    ilgili çeşitli bilgileri tutmaktadır. Bu işlem iskelet programda şöyle yapılmıştır:

    app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);

    2) İskelet programda daha sonra uygulama çalıştırıldığında oluşan "activate" mesajı için activate isimli fonksiyonun 
    çağrılması sağlanmıştır. GTK'da mesaj yerine "sinyal (signal)" sözcüğü kullanılmaktadır:

    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    Bu sinyal bağlantısındna sonra artık activate isimli fonksiyon çağrılacaktır. Bizim bu fonksiyon içerisinde programın 
    ana penceresini yaratmamız gerekir. 

    3) activate fonksiyonu şöyle yazılmıştır:

    void activate(GtkApplication *app, gpointer user_data) 
    {
        GtkWidget *window;

        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    Uygulamanın ana penceresi gtk_application_window_new fonksiyonu ile yaratılmaktadır. Ana pencere diğer pencereler gibi 
    GtkWidget yapısı ile temsil edilmektedir. gtk_window_set_title fonksiyonu yaratılan pencerenin başlık kısmına (caption)
    çıkacak yazının set edilmesini sağlamaktadır. Ana pencerenin default genişlik ve yüksekliği gtk_window_set_default_size
    fonksiyonuyla oluşturulmaktadır. Bu işlemlerden sonra iskelet programda gtk_window_present fonksiyonu ile ana pencere 
    görünür hale getirilmiştir. 

    4) Ana pencere yaratıldıktan sonra artık mesaj döngüsü oluşturulmalıdır. GTK 4'te mesaj döngüsü manuel oluşturulmaz. 
    Mesaj döngüsü g_application_run fonksiyonu ile oluşturulmaktadır:

    status = g_application_run(G_APPLICATION(app), argc, argv);

    Program hayatını bu fonksiyon içerisinde oluşturulan mesaj döngüsünden geçirmektedir. 

    5) Mesaj döngüsünden yine pencerenin X tuşuna basıldığında çıkılır. İskelet programımızda mesaj döngüsünden çıkıldığında 
    heap'te tahsis edilen çeşitli nesnelerin yok edilmesi için  g_object_unref fonksiyonu çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------*/


